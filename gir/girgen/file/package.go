package file

import (
	"fmt"
	"io"
	"os"
	"path"
	"strings"

	"github.com/go-gst/go-glib/gir/girgen/typesystem"
)

// Package is repsonsible of collecting everything that the generators want to output. Pushing more data
// after comitting the Package is undefined
//
// It keeps track of the file.go but also file_export.go for C exports when needed.
type Package struct {
	namespace *typesystem.Namespace

	basepath string

	file
	Exported file

	registeredTypes gTypes

	externCallbacks externCallbacks

	cDefines cDefines
}

func NewPackage(basepath string, importOverrides map[string]string) *Package {
	return &Package{
		basepath:        basepath,
		externCallbacks: make(externCallbacks),
		cDefines:        make(cDefines),
		file: file{
			importBaseURIs: importOverrides,
		},
		Exported: file{
			importBaseURIs: importOverrides,
		},
	}
}

func (w *Package) SetNamespace(namespace *typesystem.Namespace) {
	w.namespace = namespace
	w.file.currentNs = namespace
	w.Exported.currentNs = namespace
}

func (p *Package) RegisterExternCallback(cb *typesystem.Callback) {
	p.externCallbacks[cb] = struct{}{}
}

// DefineC is used to declare #define macros in the C code. These will be output before any
// included headers.
func (p *Package) DefineC(def string) {
	p.cDefines[def] = struct{}{}
}

func (p *Package) RegisterGType(t typesystem.Marshalable) {
	if !t.CanMarshal() {
		return
	}
	p.registeredTypes = append(p.registeredTypes, t)

	// if the type is registered then we need gobject:
	p.GoImportNamespace(t.Type().Namespace)
}

func (p *Package) Commit() error {
	err := os.MkdirAll(p.folder(), 0700)

	if err != nil {
		return err
	}

	if !p.Exported.empty() {
		exportsFile := path.Join(p.folder(), fmt.Sprintf("%s_export.gen.go", p.namespace.GoName))

		err := p.writeFile(exportsFile, p.exportFileReader())

		if err != nil {
			return err
		}
	}

	if !p.empty() {
		goFile := path.Join(p.folder(), fmt.Sprintf("%s.gen.go", p.namespace.GoName))

		err = p.writeFile(goFile, p.mainFileReader())

		if err != nil {
			return err
		}
	}

	return nil
}

func (w *Package) writeFile(name string, r io.Reader) error {
	f, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)

	if err != nil {
		return err
	}
	defer f.Close()

	_, err = io.Copy(f, r)

	if err != nil {
		return err
	}

	return nil
}
func (w *Package) folder() string {
	if w.namespace.Version.Major > 1 {
		return path.Join(w.basepath, w.namespace.GoName, fmt.Sprintf("v%d", w.namespace.Version.Major))
	}
	return path.Join(w.basepath, w.namespace.GoName)
}

var str = strings.NewReader
var empty = io.MultiReader() // empty always returns EOF

// mainFileReader returns a reader that outputs the contents of the mainFileReader.go mainFileReader
func (w *Package) mainFileReader() io.Reader {
	if w.empty() {
		panic("unreachable")
	}

	return io.MultiReader(
		w.head(),
		w.goImports.formatted(),
		str("\n"),
		w.cPackagesFormatted(),
		str("// #cgo CFLAGS: -Wno-deprecated-declarations\n"),
		w.cDefines.reader(),
		cIncludesReader(w.namespace.CIncludes),
		w.externCallbacks.reader(),
		w.c(),
		str("import \"C\"\n"),
		str("\n"),
		w.registeredTypes.reader(),
		str("\n"),
		&w.goContents,
	)
}

// exportFileReader returns a reader that outputs the contents of the file_export.go file
func (w *Package) exportFileReader() io.Reader {
	if w.Exported.empty() {
		panic("unreachable")
	}

	return io.MultiReader(
		w.head(),
		w.Exported.goImports.formatted(),
		str("\n"),
		cIncludesReader(w.namespace.CIncludes),
		w.Exported.c(),
		str("import \"C\"\n"),
		str("\n"),
		&w.Exported.goContents,
	)
}

func (w *Package) head() io.Reader {
	return str(fmt.Sprintf("// Code generated by girgen for %s-%d. DO NOT EDIT.\n\npackage %s\n\n", w.namespace.Name, w.namespace.Version.Major, w.namespace.GoName))
}

func (w *Package) cPackagesFormatted() io.Reader {
	if len(w.namespace.Packages) == 0 {
		return empty
	}

	return io.MultiReader(
		str("// #cgo pkg-config: "),
		str(strings.Join(w.namespace.Packages, " ")),
		str("\n"),
	)
}

func cIncludesReader(cIncludes []string) io.Reader {
	var b strings.Builder

	for _, incl := range cIncludes {
		b.WriteString("// #include <")
		b.WriteString(incl)
		b.WriteString(">\n")
	}

	return strings.NewReader(b.String())
}
