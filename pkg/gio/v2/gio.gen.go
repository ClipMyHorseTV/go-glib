// Code generated by girgen for Gio-2. DO NOT EDIT.

package gio

import (
	"fmt"
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/core/classdata"
	"github.com/go-gst/go-glib/pkg/core/userdata"
	"github.com/go-gst/go-glib/pkg/glib/v2"
	"github.com/go-gst/go-glib/pkg/gobject/v2"
)

// #cgo pkg-config: gio-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gio.h>
// extern GFile* _goglib_gio2_VfsFileLookupFunc(GVfs*, const char*, gpointer);
// extern gboolean _goglib_glib2_SourceFunc(gpointer);
// extern void _goglib_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void destroyUserdata(gpointer);
// extern void _goglib_gio2_AppLaunchContext_launch_failed(GAppLaunchContext*, const char*);
// void _goglib_gio2_AppLaunchContext_virtual_launch_failed(void* fnptr, GAppLaunchContext* carg0, const char* carg1) {
// 	return ((void (*) (GAppLaunchContext*, const char*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Application_activate(GApplication*);
// extern void _goglib_gio2_Application_add_platform_data(GApplication*, GVariantBuilder*);
// extern int _goglib_gio2_Application_command_line(GApplication*, GApplicationCommandLine*);
// extern gint _goglib_gio2_Application_handle_local_options(GApplication*, GVariantDict*);
// extern gboolean _goglib_gio2_Application_name_lost(GApplication*);
// extern void _goglib_gio2_Application_open(GApplication*, GFile**, gint, const gchar*);
// extern void _goglib_gio2_Application_quit_mainloop(GApplication*);
// extern void _goglib_gio2_Application_run_mainloop(GApplication*);
// extern void _goglib_gio2_Application_shutdown(GApplication*);
// extern void _goglib_gio2_Application_startup(GApplication*);
// void _goglib_gio2_Application_virtual_activate(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_add_platform_data(void* fnptr, GApplication* carg0, GVariantBuilder* carg1) {
// 	return ((void (*) (GApplication*, GVariantBuilder*))(fnptr))(carg0, carg1);
// }
// int _goglib_gio2_Application_virtual_command_line(void* fnptr, GApplication* carg0, GApplicationCommandLine* carg1) {
// 	return ((int (*) (GApplication*, GApplicationCommandLine*))(fnptr))(carg0, carg1);
// }
// gint _goglib_gio2_Application_virtual_handle_local_options(void* fnptr, GApplication* carg0, GVariantDict* carg1) {
// 	return ((gint (*) (GApplication*, GVariantDict*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Application_virtual_name_lost(void* fnptr, GApplication* carg0) {
// 	return ((gboolean (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_open(void* fnptr, GApplication* carg0, GFile** carg1, gint carg2, const gchar* carg3) {
// 	return ((void (*) (GApplication*, GFile**, gint, const gchar*))(fnptr))(carg0, carg1, carg2, carg3);
// }
// void _goglib_gio2_Application_virtual_quit_mainloop(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_run_mainloop(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_shutdown(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_startup(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// extern void _goglib_gio2_ApplicationCommandLine_done(GApplicationCommandLine*);
// extern GInputStream* _goglib_gio2_ApplicationCommandLine_get_stdin(GApplicationCommandLine*);
// extern void _goglib_gio2_ApplicationCommandLine_print_literal(GApplicationCommandLine*, const gchar*);
// extern void _goglib_gio2_ApplicationCommandLine_printerr_literal(GApplicationCommandLine*, const gchar*);
// void _goglib_gio2_ApplicationCommandLine_virtual_done(void* fnptr, GApplicationCommandLine* carg0) {
// 	return ((void (*) (GApplicationCommandLine*))(fnptr))(carg0);
// }
// GInputStream* _goglib_gio2_ApplicationCommandLine_virtual_get_stdin(void* fnptr, GApplicationCommandLine* carg0) {
// 	return ((GInputStream* (*) (GApplicationCommandLine*))(fnptr))(carg0);
// }
// void _goglib_gio2_ApplicationCommandLine_virtual_print_literal(void* fnptr, GApplicationCommandLine* carg0, const gchar* carg1) {
// 	return ((void (*) (GApplicationCommandLine*, const gchar*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_ApplicationCommandLine_virtual_printerr_literal(void* fnptr, GApplicationCommandLine* carg0, const gchar* carg1) {
// 	return ((void (*) (GApplicationCommandLine*, const gchar*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Cancellable_cancelled(GCancellable*);
// void _goglib_gio2_Cancellable_virtual_cancelled(void* fnptr, GCancellable* carg0) {
// 	return ((void (*) (GCancellable*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_FileEnumerator_close_finish(GFileEnumerator*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileEnumerator_close_fn(GFileEnumerator*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileEnumerator_next_file(GFileEnumerator*, GCancellable*, GError*);
// extern GList* _goglib_gio2_FileEnumerator_next_files_finish(GFileEnumerator*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_FileEnumerator_virtual_close_finish(void* fnptr, GFileEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileEnumerator_virtual_close_fn(void* fnptr, GFileEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GFileEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GFileInfo* _goglib_gio2_FileEnumerator_virtual_next_file(void* fnptr, GFileEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_FileEnumerator_virtual_next_files_finish(void* fnptr, GFileEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gboolean _goglib_gio2_FileMonitor_cancel(GFileMonitor*);
// extern void _goglib_gio2_FileMonitor_changed(GFileMonitor*, GFile*, GFile*, GFileMonitorEvent);
// gboolean _goglib_gio2_FileMonitor_virtual_cancel(void* fnptr, GFileMonitor* carg0) {
// 	return ((gboolean (*) (GFileMonitor*))(fnptr))(carg0);
// }
// void _goglib_gio2_FileMonitor_virtual_changed(void* fnptr, GFileMonitor* carg0, GFile* carg1, GFile* carg2, GFileMonitorEvent carg3) {
// 	return ((void (*) (GFileMonitor*, GFile*, GFile*, GFileMonitorEvent))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern void _goglib_gio2_FilenameCompleter_got_completion_data(GFilenameCompleter*);
// void _goglib_gio2_FilenameCompleter_virtual_got_completion_data(void* fnptr, GFilenameCompleter* carg0) {
// 	return ((void (*) (GFilenameCompleter*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_IOStream_close_finish(GIOStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_IOStream_close_fn(GIOStream*, GCancellable*, GError*);
// extern GInputStream* _goglib_gio2_IOStream_get_input_stream(GIOStream*);
// extern GOutputStream* _goglib_gio2_IOStream_get_output_stream(GIOStream*);
// gboolean _goglib_gio2_IOStream_virtual_close_finish(void* fnptr, GIOStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GIOStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_IOStream_virtual_close_fn(void* fnptr, GIOStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GIOStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GInputStream* _goglib_gio2_IOStream_virtual_get_input_stream(void* fnptr, GIOStream* carg0) {
// 	return ((GInputStream* (*) (GIOStream*))(fnptr))(carg0);
// }
// GOutputStream* _goglib_gio2_IOStream_virtual_get_output_stream(void* fnptr, GIOStream* carg0) {
// 	return ((GOutputStream* (*) (GIOStream*))(fnptr))(carg0);
// }
// extern gchar* _goglib_gio2_InetAddress_to_string(GInetAddress*);
// gchar* _goglib_gio2_InetAddress_virtual_to_string(void* fnptr, GInetAddress* carg0) {
// 	return ((gchar* (*) (GInetAddress*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_InputStream_close_finish(GInputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_InputStream_close_fn(GInputStream*, GCancellable*, GError*);
// extern gssize _goglib_gio2_InputStream_read_finish(GInputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_InputStream_skip(GInputStream*, gsize, GCancellable*, GError*);
// extern gssize _goglib_gio2_InputStream_skip_finish(GInputStream*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_InputStream_virtual_close_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_InputStream_virtual_close_fn(void* fnptr, GInputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GInputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_read_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_skip(void* fnptr, GInputStream* carg0, gsize carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, gsize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_skip_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gboolean _goglib_gio2_MenuLinkIter_get_next(GMenuLinkIter*, const gchar*, GMenuModel*);
// gboolean _goglib_gio2_MenuLinkIter_virtual_get_next(void* fnptr, GMenuLinkIter* carg0, const gchar** carg1, GMenuModel** carg2) {
// 	return ((gboolean (*) (GMenuLinkIter*, const gchar**, GMenuModel**))(fnptr))(carg0, carg1, carg2);
// }
// extern GMenuModel* _goglib_gio2_MenuModel_get_item_link(GMenuModel*, gint, const gchar*);
// extern gint _goglib_gio2_MenuModel_get_n_items(GMenuModel*);
// extern gboolean _goglib_gio2_MenuModel_is_mutable(GMenuModel*);
// extern GMenuAttributeIter* _goglib_gio2_MenuModel_iterate_item_attributes(GMenuModel*, gint);
// extern GMenuLinkIter* _goglib_gio2_MenuModel_iterate_item_links(GMenuModel*, gint);
// GMenuModel* _goglib_gio2_MenuModel_virtual_get_item_link(void* fnptr, GMenuModel* carg0, gint carg1, const gchar* carg2) {
// 	return ((GMenuModel* (*) (GMenuModel*, gint, const gchar*))(fnptr))(carg0, carg1, carg2);
// }
// gint _goglib_gio2_MenuModel_virtual_get_n_items(void* fnptr, GMenuModel* carg0) {
// 	return ((gint (*) (GMenuModel*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_MenuModel_virtual_is_mutable(void* fnptr, GMenuModel* carg0) {
// 	return ((gboolean (*) (GMenuModel*))(fnptr))(carg0);
// }
// GMenuAttributeIter* _goglib_gio2_MenuModel_virtual_iterate_item_attributes(void* fnptr, GMenuModel* carg0, gint carg1) {
// 	return ((GMenuAttributeIter* (*) (GMenuModel*, gint))(fnptr))(carg0, carg1);
// }
// GMenuLinkIter* _goglib_gio2_MenuModel_virtual_iterate_item_links(void* fnptr, GMenuModel* carg0, gint carg1) {
// 	return ((GMenuLinkIter* (*) (GMenuModel*, gint))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_MountOperation_aborted(GMountOperation*);
// extern void _goglib_gio2_MountOperation_ask_password(GMountOperation*, const char*, const char*, const char*, GAskPasswordFlags);
// extern void _goglib_gio2_MountOperation_ask_question(GMountOperation*, const char*, const char**);
// extern void _goglib_gio2_MountOperation_reply(GMountOperation*, GMountOperationResult);
// extern void _goglib_gio2_MountOperation_show_unmount_progress(GMountOperation*, const gchar*, gint64, gint64);
// void _goglib_gio2_MountOperation_virtual_aborted(void* fnptr, GMountOperation* carg0) {
// 	return ((void (*) (GMountOperation*))(fnptr))(carg0);
// }
// void _goglib_gio2_MountOperation_virtual_ask_password(void* fnptr, GMountOperation* carg0, const char* carg1, const char* carg2, const char* carg3, GAskPasswordFlags carg4) {
// 	return ((void (*) (GMountOperation*, const char*, const char*, const char*, GAskPasswordFlags))(fnptr))(carg0, carg1, carg2, carg3, carg4);
// }
// void _goglib_gio2_MountOperation_virtual_ask_question(void* fnptr, GMountOperation* carg0, const char* carg1, const char** carg2) {
// 	return ((void (*) (GMountOperation*, const char*, const char**))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_MountOperation_virtual_reply(void* fnptr, GMountOperation* carg0, GMountOperationResult carg1) {
// 	return ((void (*) (GMountOperation*, GMountOperationResult))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_MountOperation_virtual_show_unmount_progress(void* fnptr, GMountOperation* carg0, const gchar* carg1, gint64 carg2, gint64 carg3) {
// 	return ((void (*) (GMountOperation*, const gchar*, gint64, gint64))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern gboolean _goglib_gio2_OutputStream_close_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_OutputStream_close_fn(GOutputStream*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_flush(GOutputStream*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_flush_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_splice(GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError*);
// extern gssize _goglib_gio2_OutputStream_splice_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_write_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_write_fn(GOutputStream*, void*, gsize, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_writev_finish(GOutputStream*, GAsyncResult*, gsize, GError*);
// extern gboolean _goglib_gio2_OutputStream_writev_fn(GOutputStream*, const GOutputVector*, gsize, gsize, GCancellable*, GError*);
// gboolean _goglib_gio2_OutputStream_virtual_close_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_close_fn(void* fnptr, GOutputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_flush(void* fnptr, GOutputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_flush_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_splice(void* fnptr, GOutputStream* carg0, GInputStream* carg1, GOutputStreamSpliceFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_splice_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_write_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_write_fn(void* fnptr, GOutputStream* carg0, void* carg1, gsize carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, void*, gsize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_writev_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, gsize* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, gsize*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_writev_fn(void* fnptr, GOutputStream* carg0, const GOutputVector* carg1, gsize carg2, gsize* carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, const GOutputVector*, gsize, gsize*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// extern gboolean _goglib_gio2_Permission_acquire(GPermission*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_Permission_acquire_finish(GPermission*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_Permission_release(GPermission*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_Permission_release_finish(GPermission*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_Permission_virtual_acquire(void* fnptr, GPermission* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_acquire_finish(void* fnptr, GPermission* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_release(void* fnptr, GPermission* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_release_finish(void* fnptr, GPermission* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gchar* _goglib_gio2_Resolver_lookup_by_address(GResolver*, GInetAddress*, GCancellable*, GError*);
// extern gchar* _goglib_gio2_Resolver_lookup_by_address_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name(GResolver*, const gchar*, GCancellable*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_with_flags(GResolver*, const gchar*, GResolverNameLookupFlags, GCancellable*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_with_flags_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_service_finish(GResolver*, GAsyncResult*, GError*);
// extern void _goglib_gio2_Resolver_reload(GResolver*);
// gchar* _goglib_gio2_Resolver_virtual_lookup_by_address(void* fnptr, GResolver* carg0, GInetAddress* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gchar* (*) (GResolver*, GInetAddress*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gchar* _goglib_gio2_Resolver_virtual_lookup_by_address_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gchar* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name(void* fnptr, GResolver* carg0, const gchar* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, const gchar*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_with_flags(void* fnptr, GResolver* carg0, const gchar* carg1, GResolverNameLookupFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, const gchar*, GResolverNameLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_service_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// void _goglib_gio2_Resolver_virtual_reload(void* fnptr, GResolver* carg0) {
// 	return ((void (*) (GResolver*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_Settings_change_event(GSettings*, const GQuark*, gint);
// extern void _goglib_gio2_Settings_changed(GSettings*, const gchar*);
// extern gboolean _goglib_gio2_Settings_writable_change_event(GSettings*, GQuark);
// extern void _goglib_gio2_Settings_writable_changed(GSettings*, const gchar*);
// gboolean _goglib_gio2_Settings_virtual_change_event(void* fnptr, GSettings* carg0, const GQuark* carg1, gint carg2) {
// 	return ((gboolean (*) (GSettings*, const GQuark*, gint))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_Settings_virtual_changed(void* fnptr, GSettings* carg0, const gchar* carg1) {
// 	return ((void (*) (GSettings*, const gchar*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Settings_virtual_writable_change_event(void* fnptr, GSettings* carg0, GQuark carg1) {
// 	return ((gboolean (*) (GSettings*, GQuark))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_Settings_virtual_writable_changed(void* fnptr, GSettings* carg0, const gchar* carg1) {
// 	return ((void (*) (GSettings*, const gchar*))(fnptr))(carg0, carg1);
// }
// extern GSocketFamily _goglib_gio2_SocketAddress_get_family(GSocketAddress*);
// extern gssize _goglib_gio2_SocketAddress_get_native_size(GSocketAddress*);
// GSocketFamily _goglib_gio2_SocketAddress_virtual_get_family(void* fnptr, GSocketAddress* carg0) {
// 	return ((GSocketFamily (*) (GSocketAddress*))(fnptr))(carg0);
// }
// gssize _goglib_gio2_SocketAddress_virtual_get_native_size(void* fnptr, GSocketAddress* carg0) {
// 	return ((gssize (*) (GSocketAddress*))(fnptr))(carg0);
// }
// extern GSocketAddress* _goglib_gio2_SocketAddressEnumerator_next(GSocketAddressEnumerator*, GCancellable*, GError*);
// extern GSocketAddress* _goglib_gio2_SocketAddressEnumerator_next_finish(GSocketAddressEnumerator*, GAsyncResult*, GError*);
// GSocketAddress* _goglib_gio2_SocketAddressEnumerator_virtual_next(void* fnptr, GSocketAddressEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((GSocketAddress* (*) (GSocketAddressEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GSocketAddress* _goglib_gio2_SocketAddressEnumerator_virtual_next_finish(void* fnptr, GSocketAddressEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GSocketAddress* (*) (GSocketAddressEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern void _goglib_gio2_SocketClient_event(GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*);
// void _goglib_gio2_SocketClient_virtual_event(void* fnptr, GSocketClient* carg0, GSocketClientEvent carg1, GSocketConnectable* carg2, GIOStream* carg3) {
// 	return ((void (*) (GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern int _goglib_gio2_SocketControlMessage_get_level(GSocketControlMessage*);
// extern gsize _goglib_gio2_SocketControlMessage_get_size(GSocketControlMessage*);
// extern int _goglib_gio2_SocketControlMessage_get_type(GSocketControlMessage*);
// int _goglib_gio2_SocketControlMessage_virtual_get_level(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((int (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// gsize _goglib_gio2_SocketControlMessage_virtual_get_size(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((gsize (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// int _goglib_gio2_SocketControlMessage_virtual_get_type(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((int (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// extern void _goglib_gio2_SocketListener_changed(GSocketListener*);
// extern void _goglib_gio2_SocketListener_event(GSocketListener*, GSocketListenerEvent, GSocket*);
// void _goglib_gio2_SocketListener_virtual_changed(void* fnptr, GSocketListener* carg0) {
// 	return ((void (*) (GSocketListener*))(fnptr))(carg0);
// }
// void _goglib_gio2_SocketListener_virtual_event(void* fnptr, GSocketListener* carg0, GSocketListenerEvent carg1, GSocket* carg2) {
// 	return ((void (*) (GSocketListener*, GSocketListenerEvent, GSocket*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_SocketService_incoming(GSocketService*, GSocketConnection*, GObject*);
// gboolean _goglib_gio2_SocketService_virtual_incoming(void* fnptr, GSocketService* carg0, GSocketConnection* carg1, GObject* carg2) {
// 	return ((gboolean (*) (GSocketService*, GSocketConnection*, GObject*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_ThreadedSocketService_run(GThreadedSocketService*, GSocketConnection*, GObject*);
// gboolean _goglib_gio2_ThreadedSocketService_virtual_run(void* fnptr, GThreadedSocketService* carg0, GSocketConnection* carg1, GObject* carg2) {
// 	return ((gboolean (*) (GThreadedSocketService*, GSocketConnection*, GObject*))(fnptr))(carg0, carg1, carg2);
// }
// extern GTlsCertificateFlags _goglib_gio2_TlsCertificate_verify(GTlsCertificate*, GSocketConnectable*, GTlsCertificate*);
// GTlsCertificateFlags _goglib_gio2_TlsCertificate_virtual_verify(void* fnptr, GTlsCertificate* carg0, GSocketConnectable* carg1, GTlsCertificate* carg2) {
// 	return ((GTlsCertificateFlags (*) (GTlsCertificate*, GSocketConnectable*, GTlsCertificate*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_TlsConnection_accept_certificate(GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags);
// extern const gchar* _goglib_gio2_TlsConnection_get_negotiated_protocol(GTlsConnection*);
// extern gboolean _goglib_gio2_TlsConnection_handshake(GTlsConnection*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_TlsConnection_handshake_finish(GTlsConnection*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_TlsConnection_virtual_accept_certificate(void* fnptr, GTlsConnection* carg0, GTlsCertificate* carg1, GTlsCertificateFlags carg2) {
// 	return ((gboolean (*) (GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags))(fnptr))(carg0, carg1, carg2);
// }
// const gchar* _goglib_gio2_TlsConnection_virtual_get_negotiated_protocol(void* fnptr, GTlsConnection* carg0) {
// 	return ((const gchar* (*) (GTlsConnection*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_TlsConnection_virtual_handshake(void* fnptr, GTlsConnection* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GTlsConnection*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_TlsConnection_virtual_handshake_finish(void* fnptr, GTlsConnection* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GTlsConnection*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gchar* _goglib_gio2_TlsDatabase_create_certificate_handle(GTlsDatabase*, GTlsCertificate*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_for_handle(GTlsDatabase*, const gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_issuer(GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GTlsCertificateFlags _goglib_gio2_TlsDatabase_verify_chain(GTlsDatabase*, GTlsCertificate*, const gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError*);
// extern GTlsCertificateFlags _goglib_gio2_TlsDatabase_verify_chain_finish(GTlsDatabase*, GAsyncResult*, GError*);
// gchar* _goglib_gio2_TlsDatabase_virtual_create_certificate_handle(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1) {
// 	return ((gchar* (*) (GTlsDatabase*, GTlsCertificate*))(fnptr))(carg0, carg1);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle(void* fnptr, GTlsDatabase* carg0, const gchar* carg1, GTlsInteraction* carg2, GTlsDatabaseLookupFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, const gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1, GTlsInteraction* carg2, GTlsDatabaseLookupFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_TlsDatabase_virtual_lookup_certificates_issued_by_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsCertificateFlags _goglib_gio2_TlsDatabase_virtual_verify_chain(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1, const gchar* carg2, GSocketConnectable* carg3, GTlsInteraction* carg4, GTlsDatabaseVerifyFlags carg5, GCancellable* carg6, GError** _cerr) {
// 	return ((GTlsCertificateFlags (*) (GTlsDatabase*, GTlsCertificate*, const gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, carg5, carg6, _cerr);
// }
// GTlsCertificateFlags _goglib_gio2_TlsDatabase_virtual_verify_chain_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificateFlags (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_ask_password(GTlsInteraction*, GTlsPassword*, GCancellable*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_ask_password_finish(GTlsInteraction*, GAsyncResult*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_request_certificate(GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_request_certificate_finish(GTlsInteraction*, GAsyncResult*, GError*);
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_ask_password(void* fnptr, GTlsInteraction* carg0, GTlsPassword* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GTlsPassword*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_ask_password_finish(void* fnptr, GTlsInteraction* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_request_certificate(void* fnptr, GTlsInteraction* carg0, GTlsConnection* carg1, GTlsCertificateRequestFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_request_certificate_finish(void* fnptr, GTlsInteraction* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern const gchar* _goglib_gio2_TlsPassword_get_default_warning(GTlsPassword*);
// extern const guchar* _goglib_gio2_TlsPassword_get_value(GTlsPassword*, gsize);
// const gchar* _goglib_gio2_TlsPassword_virtual_get_default_warning(void* fnptr, GTlsPassword* carg0) {
// 	return ((const gchar* (*) (GTlsPassword*))(fnptr))(carg0);
// }
// const guchar* _goglib_gio2_TlsPassword_virtual_get_value(void* fnptr, GTlsPassword* carg0, gsize* carg1) {
// 	return ((const guchar* (*) (GTlsPassword*, gsize*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Vfs_add_writable_namespaces(GVfs*, GFileAttributeInfoList*);
// extern GFile* _goglib_gio2_Vfs_get_file_for_path(GVfs*, const char*);
// extern GFile* _goglib_gio2_Vfs_get_file_for_uri(GVfs*, const char*);
// extern const gchar* const* _goglib_gio2_Vfs_get_supported_uri_schemes(GVfs*);
// extern gboolean _goglib_gio2_Vfs_is_active(GVfs*);
// extern void _goglib_gio2_Vfs_local_file_moved(GVfs*, const char*, const char*);
// extern void _goglib_gio2_Vfs_local_file_removed(GVfs*, const char*);
// extern gboolean _goglib_gio2_Vfs_local_file_set_attributes(GVfs*, const char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError*);
// extern GFile* _goglib_gio2_Vfs_parse_name(GVfs*, const char*);
// void _goglib_gio2_Vfs_virtual_add_writable_namespaces(void* fnptr, GVfs* carg0, GFileAttributeInfoList* carg1) {
// 	return ((void (*) (GVfs*, GFileAttributeInfoList*))(fnptr))(carg0, carg1);
// }
// GFile* _goglib_gio2_Vfs_virtual_get_file_for_path(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// GFile* _goglib_gio2_Vfs_virtual_get_file_for_uri(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// const gchar* const* _goglib_gio2_Vfs_virtual_get_supported_uri_schemes(void* fnptr, GVfs* carg0) {
// 	return ((const gchar* const* (*) (GVfs*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_Vfs_virtual_is_active(void* fnptr, GVfs* carg0) {
// 	return ((gboolean (*) (GVfs*))(fnptr))(carg0);
// }
// void _goglib_gio2_Vfs_virtual_local_file_moved(void* fnptr, GVfs* carg0, const char* carg1, const char* carg2) {
// 	return ((void (*) (GVfs*, const char*, const char*))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_Vfs_virtual_local_file_removed(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((void (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Vfs_virtual_local_file_set_attributes(void* fnptr, GVfs* carg0, const char* carg1, GFileInfo* carg2, GFileQueryInfoFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((gboolean (*) (GVfs*, const char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GFile* _goglib_gio2_Vfs_virtual_parse_name(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_VolumeMonitor_drive_changed(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_connected(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_disconnected(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_eject_button(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_stop_button(GVolumeMonitor*, GDrive*);
// extern GList* _goglib_gio2_VolumeMonitor_get_connected_drives(GVolumeMonitor*);
// extern GMount* _goglib_gio2_VolumeMonitor_get_mount_for_uuid(GVolumeMonitor*, const char*);
// extern GList* _goglib_gio2_VolumeMonitor_get_mounts(GVolumeMonitor*);
// extern GVolume* _goglib_gio2_VolumeMonitor_get_volume_for_uuid(GVolumeMonitor*, const char*);
// extern GList* _goglib_gio2_VolumeMonitor_get_volumes(GVolumeMonitor*);
// extern void _goglib_gio2_VolumeMonitor_mount_added(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_changed(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_pre_unmount(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_removed(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_volume_added(GVolumeMonitor*, GVolume*);
// extern void _goglib_gio2_VolumeMonitor_volume_changed(GVolumeMonitor*, GVolume*);
// extern void _goglib_gio2_VolumeMonitor_volume_removed(GVolumeMonitor*, GVolume*);
// void _goglib_gio2_VolumeMonitor_virtual_drive_changed(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_connected(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_disconnected(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_eject_button(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_stop_button(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_connected_drives(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// GMount* _goglib_gio2_VolumeMonitor_virtual_get_mount_for_uuid(void* fnptr, GVolumeMonitor* carg0, const char* carg1) {
// 	return ((GMount* (*) (GVolumeMonitor*, const char*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_mounts(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// GVolume* _goglib_gio2_VolumeMonitor_virtual_get_volume_for_uuid(void* fnptr, GVolumeMonitor* carg0, const char* carg1) {
// 	return ((GVolume* (*) (GVolumeMonitor*, const char*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_volumes(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_added(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_changed(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_pre_unmount(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_removed(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_added(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_changed(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_removed(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// extern gboolean _goglib_gio2_FileIOStream_can_seek(GFileIOStream*);
// extern gboolean _goglib_gio2_FileIOStream_can_truncate(GFileIOStream*);
// extern char* _goglib_gio2_FileIOStream_get_etag(GFileIOStream*);
// extern GFileInfo* _goglib_gio2_FileIOStream_query_info(GFileIOStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileIOStream_query_info_finish(GFileIOStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileIOStream_seek(GFileIOStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileIOStream_tell(GFileIOStream*);
// extern gboolean _goglib_gio2_FileIOStream_truncate_fn(GFileIOStream*, goffset, GCancellable*, GError*);
// gboolean _goglib_gio2_FileIOStream_virtual_can_seek(void* fnptr, GFileIOStream* carg0) {
// 	return ((gboolean (*) (GFileIOStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_can_truncate(void* fnptr, GFileIOStream* carg0) {
// 	return ((gboolean (*) (GFileIOStream*))(fnptr))(carg0);
// }
// char* _goglib_gio2_FileIOStream_virtual_get_etag(void* fnptr, GFileIOStream* carg0) {
// 	return ((char* (*) (GFileIOStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileIOStream_virtual_query_info(void* fnptr, GFileIOStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileIOStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileIOStream_virtual_query_info_finish(void* fnptr, GFileIOStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileIOStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_seek(void* fnptr, GFileIOStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileIOStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileIOStream_virtual_tell(void* fnptr, GFileIOStream* carg0) {
// 	return ((goffset (*) (GFileIOStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_truncate_fn(void* fnptr, GFileIOStream* carg0, goffset carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GFileIOStream*, goffset, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// extern gboolean _goglib_gio2_FileInputStream_can_seek(GFileInputStream*);
// extern GFileInfo* _goglib_gio2_FileInputStream_query_info(GFileInputStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileInputStream_query_info_finish(GFileInputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileInputStream_seek(GFileInputStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileInputStream_tell(GFileInputStream*);
// gboolean _goglib_gio2_FileInputStream_virtual_can_seek(void* fnptr, GFileInputStream* carg0) {
// 	return ((gboolean (*) (GFileInputStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileInputStream_virtual_query_info(void* fnptr, GFileInputStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileInputStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileInputStream_virtual_query_info_finish(void* fnptr, GFileInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileInputStream_virtual_seek(void* fnptr, GFileInputStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileInputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileInputStream_virtual_tell(void* fnptr, GFileInputStream* carg0) {
// 	return ((goffset (*) (GFileInputStream*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_FileOutputStream_can_seek(GFileOutputStream*);
// extern gboolean _goglib_gio2_FileOutputStream_can_truncate(GFileOutputStream*);
// extern char* _goglib_gio2_FileOutputStream_get_etag(GFileOutputStream*);
// extern GFileInfo* _goglib_gio2_FileOutputStream_query_info(GFileOutputStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileOutputStream_query_info_finish(GFileOutputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileOutputStream_seek(GFileOutputStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileOutputStream_tell(GFileOutputStream*);
// extern gboolean _goglib_gio2_FileOutputStream_truncate_fn(GFileOutputStream*, goffset, GCancellable*, GError*);
// gboolean _goglib_gio2_FileOutputStream_virtual_can_seek(void* fnptr, GFileOutputStream* carg0) {
// 	return ((gboolean (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_can_truncate(void* fnptr, GFileOutputStream* carg0) {
// 	return ((gboolean (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// char* _goglib_gio2_FileOutputStream_virtual_get_etag(void* fnptr, GFileOutputStream* carg0) {
// 	return ((char* (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileOutputStream_virtual_query_info(void* fnptr, GFileOutputStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileOutputStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileOutputStream_virtual_query_info_finish(void* fnptr, GFileOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_seek(void* fnptr, GFileOutputStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileOutputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileOutputStream_virtual_tell(void* fnptr, GFileOutputStream* carg0) {
// 	return ((goffset (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_truncate_fn(void* fnptr, GFileOutputStream* carg0, goffset carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GFileOutputStream*, goffset, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// extern gssize _goglib_gio2_BufferedInputStream_fill(GBufferedInputStream*, gssize, GCancellable*, GError*);
// extern gssize _goglib_gio2_BufferedInputStream_fill_finish(GBufferedInputStream*, GAsyncResult*, GError*);
// gssize _goglib_gio2_BufferedInputStream_virtual_fill(void* fnptr, GBufferedInputStream* carg0, gssize carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gssize (*) (GBufferedInputStream*, gssize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gssize _goglib_gio2_BufferedInputStream_virtual_fill_finish(void* fnptr, GBufferedInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GBufferedInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
import "C"

// GType values.
var (
	TypeBusType                    = gobject.Type(C.g_bus_type_get_type())
	TypeConverterResult            = gobject.Type(C.g_converter_result_get_type())
	TypeCredentialsType            = gobject.Type(C.g_credentials_type_get_type())
	TypeDataStreamByteOrder        = gobject.Type(C.g_data_stream_byte_order_get_type())
	TypeDataStreamNewlineType      = gobject.Type(C.g_data_stream_newline_type_get_type())
	TypeDriveStartStopType         = gobject.Type(C.g_drive_start_stop_type_get_type())
	TypeEmblemOrigin               = gobject.Type(C.g_emblem_origin_get_type())
	TypeFileAttributeStatus        = gobject.Type(C.g_file_attribute_status_get_type())
	TypeFileAttributeType          = gobject.Type(C.g_file_attribute_type_get_type())
	TypeFileMonitorEvent           = gobject.Type(C.g_file_monitor_event_get_type())
	TypeFileType                   = gobject.Type(C.g_file_type_get_type())
	TypeFilesystemPreviewType      = gobject.Type(C.g_filesystem_preview_type_get_type())
	TypeIOErrorEnum                = gobject.Type(C.g_io_error_enum_get_type())
	TypeIOModuleScopeFlags         = gobject.Type(C.g_io_module_scope_flags_get_type())
	TypeMemoryMonitorWarningLevel  = gobject.Type(C.g_memory_monitor_warning_level_get_type())
	TypeMountOperationResult       = gobject.Type(C.g_mount_operation_result_get_type())
	TypeNetworkConnectivity        = gobject.Type(C.g_network_connectivity_get_type())
	TypeNotificationPriority       = gobject.Type(C.g_notification_priority_get_type())
	TypePasswordSave               = gobject.Type(C.g_password_save_get_type())
	TypePollableReturn             = gobject.Type(C.g_pollable_return_get_type())
	TypeResolverError              = gobject.Type(C.g_resolver_error_get_type())
	TypeResolverRecordType         = gobject.Type(C.g_resolver_record_type_get_type())
	TypeResourceError              = gobject.Type(C.g_resource_error_get_type())
	TypeSocketClientEvent          = gobject.Type(C.g_socket_client_event_get_type())
	TypeSocketFamily               = gobject.Type(C.g_socket_family_get_type())
	TypeSocketListenerEvent        = gobject.Type(C.g_socket_listener_event_get_type())
	TypeSocketProtocol             = gobject.Type(C.g_socket_protocol_get_type())
	TypeSocketType                 = gobject.Type(C.g_socket_type_get_type())
	TypeTlsAuthenticationMode      = gobject.Type(C.g_tls_authentication_mode_get_type())
	TypeTlsCertificateRequestFlags = gobject.Type(C.g_tls_certificate_request_flags_get_type())
	TypeTlsChannelBindingError     = gobject.Type(C.g_tls_channel_binding_error_get_type())
	TypeTlsChannelBindingType      = gobject.Type(C.g_tls_channel_binding_type_get_type())
	TypeTlsDatabaseLookupFlags     = gobject.Type(C.g_tls_database_lookup_flags_get_type())
	TypeTlsError                   = gobject.Type(C.g_tls_error_get_type())
	TypeTlsInteractionResult       = gobject.Type(C.g_tls_interaction_result_get_type())
	TypeTlsProtocolVersion         = gobject.Type(C.g_tls_protocol_version_get_type())
	TypeTlsRehandshakeMode         = gobject.Type(C.g_tls_rehandshake_mode_get_type())
	TypeZlibCompressorFormat       = gobject.Type(C.g_zlib_compressor_format_get_type())
	TypeAppInfoCreateFlags         = gobject.Type(C.g_app_info_create_flags_get_type())
	TypeApplicationFlags           = gobject.Type(C.g_application_flags_get_type())
	TypeAskPasswordFlags           = gobject.Type(C.g_ask_password_flags_get_type())
	TypeBusNameOwnerFlags          = gobject.Type(C.g_bus_name_owner_flags_get_type())
	TypeBusNameWatcherFlags        = gobject.Type(C.g_bus_name_watcher_flags_get_type())
	TypeConverterFlags             = gobject.Type(C.g_converter_flags_get_type())
	TypeDriveStartFlags            = gobject.Type(C.g_drive_start_flags_get_type())
	TypeFileAttributeInfoFlags     = gobject.Type(C.g_file_attribute_info_flags_get_type())
	TypeFileCopyFlags              = gobject.Type(C.g_file_copy_flags_get_type())
	TypeFileCreateFlags            = gobject.Type(C.g_file_create_flags_get_type())
	TypeFileMeasureFlags           = gobject.Type(C.g_file_measure_flags_get_type())
	TypeFileMonitorFlags           = gobject.Type(C.g_file_monitor_flags_get_type())
	TypeFileQueryInfoFlags         = gobject.Type(C.g_file_query_info_flags_get_type())
	TypeIOStreamSpliceFlags        = gobject.Type(C.g_io_stream_splice_flags_get_type())
	TypeMountMountFlags            = gobject.Type(C.g_mount_mount_flags_get_type())
	TypeMountUnmountFlags          = gobject.Type(C.g_mount_unmount_flags_get_type())
	TypeOutputStreamSpliceFlags    = gobject.Type(C.g_output_stream_splice_flags_get_type())
	TypeResolverNameLookupFlags    = gobject.Type(C.g_resolver_name_lookup_flags_get_type())
	TypeResourceFlags              = gobject.Type(C.g_resource_flags_get_type())
	TypeResourceLookupFlags        = gobject.Type(C.g_resource_lookup_flags_get_type())
	TypeSettingsBindFlags          = gobject.Type(C.g_settings_bind_flags_get_type())
	TypeSocketMsgFlags             = gobject.Type(C.g_socket_msg_flags_get_type())
	TypeTlsCertificateFlags        = gobject.Type(C.g_tls_certificate_flags_get_type())
	TypeTlsDatabaseVerifyFlags     = gobject.Type(C.g_tls_database_verify_flags_get_type())
	TypeTlsPasswordFlags           = gobject.Type(C.g_tls_password_flags_get_type())
	TypeAction                     = gobject.Type(C.g_action_get_type())
	TypeActionGroup                = gobject.Type(C.g_action_group_get_type())
	TypeActionMap                  = gobject.Type(C.g_action_map_get_type())
	TypeAppInfo                    = gobject.Type(C.g_app_info_get_type())
	TypeAsyncInitable              = gobject.Type(C.g_async_initable_get_type())
	TypeAsyncResult                = gobject.Type(C.g_async_result_get_type())
	TypeConverter                  = gobject.Type(C.g_converter_get_type())
	TypeDatagramBased              = gobject.Type(C.g_datagram_based_get_type())
	TypeDrive                      = gobject.Type(C.g_drive_get_type())
	TypeDtlsConnection             = gobject.Type(C.g_dtls_connection_get_type())
	TypeDtlsServerConnection       = gobject.Type(C.g_dtls_server_connection_get_type())
	TypeFile                       = gobject.Type(C.g_file_get_type())
	TypeIcon                       = gobject.Type(C.g_icon_get_type())
	TypeInitable                   = gobject.Type(C.g_initable_get_type())
	TypeListModel                  = gobject.Type(C.g_list_model_get_type())
	TypeLoadableIcon               = gobject.Type(C.g_loadable_icon_get_type())
	TypeMemoryMonitor              = gobject.Type(C.g_memory_monitor_get_type())
	TypeMount                      = gobject.Type(C.g_mount_get_type())
	TypeNetworkMonitor             = gobject.Type(C.g_network_monitor_get_type())
	TypePollableInputStream        = gobject.Type(C.g_pollable_input_stream_get_type())
	TypePollableOutputStream       = gobject.Type(C.g_pollable_output_stream_get_type())
	TypePowerProfileMonitor        = gobject.Type(C.g_power_profile_monitor_get_type())
	TypeProxy                      = gobject.Type(C.g_proxy_get_type())
	TypeProxyResolver              = gobject.Type(C.g_proxy_resolver_get_type())
	TypeRemoteActionGroup          = gobject.Type(C.g_remote_action_group_get_type())
	TypeSeekable                   = gobject.Type(C.g_seekable_get_type())
	TypeSocketConnectable          = gobject.Type(C.g_socket_connectable_get_type())
	TypeTlsBackend                 = gobject.Type(C.g_tls_backend_get_type())
	TypeTlsClientConnection        = gobject.Type(C.g_tls_client_connection_get_type())
	TypeTlsFileDatabase            = gobject.Type(C.g_tls_file_database_get_type())
	TypeTlsServerConnection        = gobject.Type(C.g_tls_server_connection_get_type())
	TypeVolume                     = gobject.Type(C.g_volume_get_type())
	TypeDebugController            = gobject.Type(C.g_debug_controller_get_type())
	TypeDtlsClientConnection       = gobject.Type(C.g_dtls_client_connection_get_type())
	TypeAppInfoMonitor             = gobject.Type(C.g_app_info_monitor_get_type())
	TypeAppLaunchContext           = gobject.Type(C.g_app_launch_context_get_type())
	TypeApplication                = gobject.Type(C.g_application_get_type())
	TypeApplicationCommandLine     = gobject.Type(C.g_application_command_line_get_type())
	TypeBytesIcon                  = gobject.Type(C.g_bytes_icon_get_type())
	TypeCancellable                = gobject.Type(C.g_cancellable_get_type())
	TypeCharsetConverter           = gobject.Type(C.g_charset_converter_get_type())
	TypeCredentials                = gobject.Type(C.g_credentials_get_type())
	TypeEmblem                     = gobject.Type(C.g_emblem_get_type())
	TypeEmblemedIcon               = gobject.Type(C.g_emblemed_icon_get_type())
	TypeFileEnumerator             = gobject.Type(C.g_file_enumerator_get_type())
	TypeFileIcon                   = gobject.Type(C.g_file_icon_get_type())
	TypeFileInfo                   = gobject.Type(C.g_file_info_get_type())
	TypeFileMonitor                = gobject.Type(C.g_file_monitor_get_type())
	TypeFilenameCompleter          = gobject.Type(C.g_filename_completer_get_type())
	TypeIOStream                   = gobject.Type(C.g_io_stream_get_type())
	TypeInetAddress                = gobject.Type(C.g_inet_address_get_type())
	TypeInetAddressMask            = gobject.Type(C.g_inet_address_mask_get_type())
	TypeInputStream                = gobject.Type(C.g_input_stream_get_type())
	TypeListStore                  = gobject.Type(C.g_list_store_get_type())
	TypeMemoryInputStream          = gobject.Type(C.g_memory_input_stream_get_type())
	TypeMenuAttributeIter          = gobject.Type(C.g_menu_attribute_iter_get_type())
	TypeMenuItem                   = gobject.Type(C.g_menu_item_get_type())
	TypeMenuLinkIter               = gobject.Type(C.g_menu_link_iter_get_type())
	TypeMenuModel                  = gobject.Type(C.g_menu_model_get_type())
	TypeMountOperation             = gobject.Type(C.g_mount_operation_get_type())
	TypeNetworkAddress             = gobject.Type(C.g_network_address_get_type())
	TypeNetworkService             = gobject.Type(C.g_network_service_get_type())
	TypeNotification               = gobject.Type(C.g_notification_get_type())
	TypeOutputStream               = gobject.Type(C.g_output_stream_get_type())
	TypePermission                 = gobject.Type(C.g_permission_get_type())
	TypePropertyAction             = gobject.Type(C.g_property_action_get_type())
	TypeResolver                   = gobject.Type(C.g_resolver_get_type())
	TypeSettings                   = gobject.Type(C.g_settings_get_type())
	TypeSimpleAction               = gobject.Type(C.g_simple_action_get_type())
	TypeSimpleActionGroup          = gobject.Type(C.g_simple_action_group_get_type())
	TypeSimpleAsyncResult          = gobject.Type(C.g_simple_async_result_get_type())
	TypeSimpleIOStream             = gobject.Type(C.g_simple_io_stream_get_type())
	TypeSimplePermission           = gobject.Type(C.g_simple_permission_get_type())
	TypeSimpleProxyResolver        = gobject.Type(C.g_simple_proxy_resolver_get_type())
	TypeSocket                     = gobject.Type(C.g_socket_get_type())
	TypeSocketAddress              = gobject.Type(C.g_socket_address_get_type())
	TypeSocketAddressEnumerator    = gobject.Type(C.g_socket_address_enumerator_get_type())
	TypeSocketClient               = gobject.Type(C.g_socket_client_get_type())
	TypeSocketConnection           = gobject.Type(C.g_socket_connection_get_type())
	TypeSocketControlMessage       = gobject.Type(C.g_socket_control_message_get_type())
	TypeSocketListener             = gobject.Type(C.g_socket_listener_get_type())
	TypeSocketService              = gobject.Type(C.g_socket_service_get_type())
	TypeTask                       = gobject.Type(C.g_task_get_type())
	TypeTcpConnection              = gobject.Type(C.g_tcp_connection_get_type())
	TypeTcpWrapperConnection       = gobject.Type(C.g_tcp_wrapper_connection_get_type())
	TypeThemedIcon                 = gobject.Type(C.g_themed_icon_get_type())
	TypeThreadedSocketService      = gobject.Type(C.g_threaded_socket_service_get_type())
	TypeTlsCertificate             = gobject.Type(C.g_tls_certificate_get_type())
	TypeTlsConnection              = gobject.Type(C.g_tls_connection_get_type())
	TypeTlsDatabase                = gobject.Type(C.g_tls_database_get_type())
	TypeTlsInteraction             = gobject.Type(C.g_tls_interaction_get_type())
	TypeTlsPassword                = gobject.Type(C.g_tls_password_get_type())
	TypeVfs                        = gobject.Type(C.g_vfs_get_type())
	TypeVolumeMonitor              = gobject.Type(C.g_volume_monitor_get_type())
	TypeZlibDecompressor           = gobject.Type(C.g_zlib_decompressor_get_type())
	TypeFileIOStream               = gobject.Type(C.g_file_io_stream_get_type())
	TypeFileInputStream            = gobject.Type(C.g_file_input_stream_get_type())
	TypeFileOutputStream           = gobject.Type(C.g_file_output_stream_get_type())
	TypeFilterInputStream          = gobject.Type(C.g_filter_input_stream_get_type())
	TypeFilterOutputStream         = gobject.Type(C.g_filter_output_stream_get_type())
	TypeInetSocketAddress          = gobject.Type(C.g_inet_socket_address_get_type())
	TypeMemoryOutputStream         = gobject.Type(C.g_memory_output_stream_get_type())
	TypeMenu                       = gobject.Type(C.g_menu_get_type())
	TypeNativeSocketAddress        = gobject.Type(C.g_native_socket_address_get_type())
	TypeNativeVolumeMonitor        = gobject.Type(C.g_native_volume_monitor_get_type())
	TypeProxyAddress               = gobject.Type(C.g_proxy_address_get_type())
	TypeProxyAddressEnumerator     = gobject.Type(C.g_proxy_address_enumerator_get_type())
	TypeBufferedInputStream        = gobject.Type(C.g_buffered_input_stream_get_type())
	TypeBufferedOutputStream       = gobject.Type(C.g_buffered_output_stream_get_type())
	TypeConverterInputStream       = gobject.Type(C.g_converter_input_stream_get_type())
	TypeConverterOutputStream      = gobject.Type(C.g_converter_output_stream_get_type())
	TypeDataInputStream            = gobject.Type(C.g_data_input_stream_get_type())
	TypeDataOutputStream           = gobject.Type(C.g_data_output_stream_get_type())
	TypeFileAttributeInfoList      = gobject.Type(C.g_file_attribute_info_list_get_type())
	TypeFileAttributeMatcher       = gobject.Type(C.g_file_attribute_matcher_get_type())
	TypeSettingsSchema             = gobject.Type(C.g_settings_schema_get_type())
	TypeSettingsSchemaKey          = gobject.Type(C.g_settings_schema_key_get_type())
	TypeSettingsSchemaSource       = gobject.Type(C.g_settings_schema_source_get_type())
	TypeSrvTarget                  = gobject.Type(C.g_srv_target_get_type())
)

func init() {
	gobject.RegisterGValueMarshalers([]gobject.TypeMarshaler{
		gobject.TypeMarshaler{T: TypeBusType, F: marshalBusType},
		gobject.TypeMarshaler{T: TypeConverterResult, F: marshalConverterResult},
		gobject.TypeMarshaler{T: TypeCredentialsType, F: marshalCredentialsType},
		gobject.TypeMarshaler{T: TypeDataStreamByteOrder, F: marshalDataStreamByteOrder},
		gobject.TypeMarshaler{T: TypeDataStreamNewlineType, F: marshalDataStreamNewlineType},
		gobject.TypeMarshaler{T: TypeDriveStartStopType, F: marshalDriveStartStopType},
		gobject.TypeMarshaler{T: TypeEmblemOrigin, F: marshalEmblemOrigin},
		gobject.TypeMarshaler{T: TypeFileAttributeStatus, F: marshalFileAttributeStatus},
		gobject.TypeMarshaler{T: TypeFileAttributeType, F: marshalFileAttributeType},
		gobject.TypeMarshaler{T: TypeFileMonitorEvent, F: marshalFileMonitorEvent},
		gobject.TypeMarshaler{T: TypeFileType, F: marshalFileType},
		gobject.TypeMarshaler{T: TypeFilesystemPreviewType, F: marshalFilesystemPreviewType},
		gobject.TypeMarshaler{T: TypeIOErrorEnum, F: marshalIOErrorEnum},
		gobject.TypeMarshaler{T: TypeIOModuleScopeFlags, F: marshalIOModuleScopeFlags},
		gobject.TypeMarshaler{T: TypeMemoryMonitorWarningLevel, F: marshalMemoryMonitorWarningLevel},
		gobject.TypeMarshaler{T: TypeMountOperationResult, F: marshalMountOperationResult},
		gobject.TypeMarshaler{T: TypeNetworkConnectivity, F: marshalNetworkConnectivity},
		gobject.TypeMarshaler{T: TypeNotificationPriority, F: marshalNotificationPriority},
		gobject.TypeMarshaler{T: TypePasswordSave, F: marshalPasswordSave},
		gobject.TypeMarshaler{T: TypePollableReturn, F: marshalPollableReturn},
		gobject.TypeMarshaler{T: TypeResolverError, F: marshalResolverError},
		gobject.TypeMarshaler{T: TypeResolverRecordType, F: marshalResolverRecordType},
		gobject.TypeMarshaler{T: TypeResourceError, F: marshalResourceError},
		gobject.TypeMarshaler{T: TypeSocketClientEvent, F: marshalSocketClientEvent},
		gobject.TypeMarshaler{T: TypeSocketFamily, F: marshalSocketFamily},
		gobject.TypeMarshaler{T: TypeSocketListenerEvent, F: marshalSocketListenerEvent},
		gobject.TypeMarshaler{T: TypeSocketProtocol, F: marshalSocketProtocol},
		gobject.TypeMarshaler{T: TypeSocketType, F: marshalSocketType},
		gobject.TypeMarshaler{T: TypeTlsAuthenticationMode, F: marshalTlsAuthenticationMode},
		gobject.TypeMarshaler{T: TypeTlsCertificateRequestFlags, F: marshalTlsCertificateRequestFlags},
		gobject.TypeMarshaler{T: TypeTlsChannelBindingError, F: marshalTlsChannelBindingError},
		gobject.TypeMarshaler{T: TypeTlsChannelBindingType, F: marshalTlsChannelBindingType},
		gobject.TypeMarshaler{T: TypeTlsDatabaseLookupFlags, F: marshalTlsDatabaseLookupFlags},
		gobject.TypeMarshaler{T: TypeTlsError, F: marshalTlsError},
		gobject.TypeMarshaler{T: TypeTlsInteractionResult, F: marshalTlsInteractionResult},
		gobject.TypeMarshaler{T: TypeTlsProtocolVersion, F: marshalTlsProtocolVersion},
		gobject.TypeMarshaler{T: TypeTlsRehandshakeMode, F: marshalTlsRehandshakeMode},
		gobject.TypeMarshaler{T: TypeZlibCompressorFormat, F: marshalZlibCompressorFormat},
		gobject.TypeMarshaler{T: TypeAppInfoCreateFlags, F: marshalAppInfoCreateFlags},
		gobject.TypeMarshaler{T: TypeApplicationFlags, F: marshalApplicationFlags},
		gobject.TypeMarshaler{T: TypeAskPasswordFlags, F: marshalAskPasswordFlags},
		gobject.TypeMarshaler{T: TypeBusNameOwnerFlags, F: marshalBusNameOwnerFlags},
		gobject.TypeMarshaler{T: TypeBusNameWatcherFlags, F: marshalBusNameWatcherFlags},
		gobject.TypeMarshaler{T: TypeConverterFlags, F: marshalConverterFlags},
		gobject.TypeMarshaler{T: TypeDriveStartFlags, F: marshalDriveStartFlags},
		gobject.TypeMarshaler{T: TypeFileAttributeInfoFlags, F: marshalFileAttributeInfoFlags},
		gobject.TypeMarshaler{T: TypeFileCopyFlags, F: marshalFileCopyFlags},
		gobject.TypeMarshaler{T: TypeFileCreateFlags, F: marshalFileCreateFlags},
		gobject.TypeMarshaler{T: TypeFileMeasureFlags, F: marshalFileMeasureFlags},
		gobject.TypeMarshaler{T: TypeFileMonitorFlags, F: marshalFileMonitorFlags},
		gobject.TypeMarshaler{T: TypeFileQueryInfoFlags, F: marshalFileQueryInfoFlags},
		gobject.TypeMarshaler{T: TypeIOStreamSpliceFlags, F: marshalIOStreamSpliceFlags},
		gobject.TypeMarshaler{T: TypeMountMountFlags, F: marshalMountMountFlags},
		gobject.TypeMarshaler{T: TypeMountUnmountFlags, F: marshalMountUnmountFlags},
		gobject.TypeMarshaler{T: TypeOutputStreamSpliceFlags, F: marshalOutputStreamSpliceFlags},
		gobject.TypeMarshaler{T: TypeResolverNameLookupFlags, F: marshalResolverNameLookupFlags},
		gobject.TypeMarshaler{T: TypeResourceFlags, F: marshalResourceFlags},
		gobject.TypeMarshaler{T: TypeResourceLookupFlags, F: marshalResourceLookupFlags},
		gobject.TypeMarshaler{T: TypeSettingsBindFlags, F: marshalSettingsBindFlags},
		gobject.TypeMarshaler{T: TypeSocketMsgFlags, F: marshalSocketMsgFlags},
		gobject.TypeMarshaler{T: TypeTlsCertificateFlags, F: marshalTlsCertificateFlags},
		gobject.TypeMarshaler{T: TypeTlsDatabaseVerifyFlags, F: marshalTlsDatabaseVerifyFlags},
		gobject.TypeMarshaler{T: TypeTlsPasswordFlags, F: marshalTlsPasswordFlags},
		gobject.TypeMarshaler{T: TypeAction, F: marshalActionInstance},
		gobject.TypeMarshaler{T: TypeActionGroup, F: marshalActionGroupInstance},
		gobject.TypeMarshaler{T: TypeActionMap, F: marshalActionMapInstance},
		gobject.TypeMarshaler{T: TypeAppInfo, F: marshalAppInfoInstance},
		gobject.TypeMarshaler{T: TypeAsyncInitable, F: marshalAsyncInitableInstance},
		gobject.TypeMarshaler{T: TypeAsyncResult, F: marshalAsyncResultInstance},
		gobject.TypeMarshaler{T: TypeConverter, F: marshalConverterInstance},
		gobject.TypeMarshaler{T: TypeDatagramBased, F: marshalDatagramBasedInstance},
		gobject.TypeMarshaler{T: TypeDrive, F: marshalDriveInstance},
		gobject.TypeMarshaler{T: TypeDtlsConnection, F: marshalDtlsConnectionInstance},
		gobject.TypeMarshaler{T: TypeDtlsServerConnection, F: marshalDtlsServerConnectionInstance},
		gobject.TypeMarshaler{T: TypeFile, F: marshalFileInstance},
		gobject.TypeMarshaler{T: TypeIcon, F: marshalIconInstance},
		gobject.TypeMarshaler{T: TypeInitable, F: marshalInitableInstance},
		gobject.TypeMarshaler{T: TypeListModel, F: marshalListModelInstance},
		gobject.TypeMarshaler{T: TypeLoadableIcon, F: marshalLoadableIconInstance},
		gobject.TypeMarshaler{T: TypeMemoryMonitor, F: marshalMemoryMonitorInstance},
		gobject.TypeMarshaler{T: TypeMount, F: marshalMountInstance},
		gobject.TypeMarshaler{T: TypeNetworkMonitor, F: marshalNetworkMonitorInstance},
		gobject.TypeMarshaler{T: TypePollableInputStream, F: marshalPollableInputStreamInstance},
		gobject.TypeMarshaler{T: TypePollableOutputStream, F: marshalPollableOutputStreamInstance},
		gobject.TypeMarshaler{T: TypePowerProfileMonitor, F: marshalPowerProfileMonitorInstance},
		gobject.TypeMarshaler{T: TypeProxy, F: marshalProxyInstance},
		gobject.TypeMarshaler{T: TypeProxyResolver, F: marshalProxyResolverInstance},
		gobject.TypeMarshaler{T: TypeRemoteActionGroup, F: marshalRemoteActionGroupInstance},
		gobject.TypeMarshaler{T: TypeSeekable, F: marshalSeekableInstance},
		gobject.TypeMarshaler{T: TypeSocketConnectable, F: marshalSocketConnectableInstance},
		gobject.TypeMarshaler{T: TypeTlsBackend, F: marshalTlsBackendInstance},
		gobject.TypeMarshaler{T: TypeTlsClientConnection, F: marshalTlsClientConnectionInstance},
		gobject.TypeMarshaler{T: TypeTlsFileDatabase, F: marshalTlsFileDatabaseInstance},
		gobject.TypeMarshaler{T: TypeTlsServerConnection, F: marshalTlsServerConnectionInstance},
		gobject.TypeMarshaler{T: TypeVolume, F: marshalVolumeInstance},
		gobject.TypeMarshaler{T: TypeDebugController, F: marshalDebugControllerInstance},
		gobject.TypeMarshaler{T: TypeDtlsClientConnection, F: marshalDtlsClientConnectionInstance},
		gobject.TypeMarshaler{T: TypeAppInfoMonitor, F: marshalAppInfoMonitorInstance},
		gobject.TypeMarshaler{T: TypeAppLaunchContext, F: marshalAppLaunchContextInstance},
		gobject.TypeMarshaler{T: TypeApplication, F: marshalApplicationInstance},
		gobject.TypeMarshaler{T: TypeApplicationCommandLine, F: marshalApplicationCommandLineInstance},
		gobject.TypeMarshaler{T: TypeBytesIcon, F: marshalBytesIconInstance},
		gobject.TypeMarshaler{T: TypeCancellable, F: marshalCancellableInstance},
		gobject.TypeMarshaler{T: TypeCharsetConverter, F: marshalCharsetConverterInstance},
		gobject.TypeMarshaler{T: TypeCredentials, F: marshalCredentialsInstance},
		gobject.TypeMarshaler{T: TypeEmblem, F: marshalEmblemInstance},
		gobject.TypeMarshaler{T: TypeEmblemedIcon, F: marshalEmblemedIconInstance},
		gobject.TypeMarshaler{T: TypeFileEnumerator, F: marshalFileEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeFileIcon, F: marshalFileIconInstance},
		gobject.TypeMarshaler{T: TypeFileInfo, F: marshalFileInfoInstance},
		gobject.TypeMarshaler{T: TypeFileMonitor, F: marshalFileMonitorInstance},
		gobject.TypeMarshaler{T: TypeFilenameCompleter, F: marshalFilenameCompleterInstance},
		gobject.TypeMarshaler{T: TypeIOStream, F: marshalIOStreamInstance},
		gobject.TypeMarshaler{T: TypeInetAddress, F: marshalInetAddressInstance},
		gobject.TypeMarshaler{T: TypeInetAddressMask, F: marshalInetAddressMaskInstance},
		gobject.TypeMarshaler{T: TypeInputStream, F: marshalInputStreamInstance},
		gobject.TypeMarshaler{T: TypeListStore, F: marshalListStoreInstance},
		gobject.TypeMarshaler{T: TypeMemoryInputStream, F: marshalMemoryInputStreamInstance},
		gobject.TypeMarshaler{T: TypeMenuAttributeIter, F: marshalMenuAttributeIterInstance},
		gobject.TypeMarshaler{T: TypeMenuItem, F: marshalMenuItemInstance},
		gobject.TypeMarshaler{T: TypeMenuLinkIter, F: marshalMenuLinkIterInstance},
		gobject.TypeMarshaler{T: TypeMenuModel, F: marshalMenuModelInstance},
		gobject.TypeMarshaler{T: TypeMountOperation, F: marshalMountOperationInstance},
		gobject.TypeMarshaler{T: TypeNetworkAddress, F: marshalNetworkAddressInstance},
		gobject.TypeMarshaler{T: TypeNetworkService, F: marshalNetworkServiceInstance},
		gobject.TypeMarshaler{T: TypeNotification, F: marshalNotificationInstance},
		gobject.TypeMarshaler{T: TypeOutputStream, F: marshalOutputStreamInstance},
		gobject.TypeMarshaler{T: TypePermission, F: marshalPermissionInstance},
		gobject.TypeMarshaler{T: TypePropertyAction, F: marshalPropertyActionInstance},
		gobject.TypeMarshaler{T: TypeResolver, F: marshalResolverInstance},
		gobject.TypeMarshaler{T: TypeSettings, F: marshalSettingsInstance},
		gobject.TypeMarshaler{T: TypeSimpleAction, F: marshalSimpleActionInstance},
		gobject.TypeMarshaler{T: TypeSimpleActionGroup, F: marshalSimpleActionGroupInstance},
		gobject.TypeMarshaler{T: TypeSimpleAsyncResult, F: marshalSimpleAsyncResultInstance},
		gobject.TypeMarshaler{T: TypeSimpleIOStream, F: marshalSimpleIOStreamInstance},
		gobject.TypeMarshaler{T: TypeSimplePermission, F: marshalSimplePermissionInstance},
		gobject.TypeMarshaler{T: TypeSimpleProxyResolver, F: marshalSimpleProxyResolverInstance},
		gobject.TypeMarshaler{T: TypeSocket, F: marshalSocketInstance},
		gobject.TypeMarshaler{T: TypeSocketAddress, F: marshalSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeSocketAddressEnumerator, F: marshalSocketAddressEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeSocketClient, F: marshalSocketClientInstance},
		gobject.TypeMarshaler{T: TypeSocketConnection, F: marshalSocketConnectionInstance},
		gobject.TypeMarshaler{T: TypeSocketControlMessage, F: marshalSocketControlMessageInstance},
		gobject.TypeMarshaler{T: TypeSocketListener, F: marshalSocketListenerInstance},
		gobject.TypeMarshaler{T: TypeSocketService, F: marshalSocketServiceInstance},
		gobject.TypeMarshaler{T: TypeTask, F: marshalTaskInstance},
		gobject.TypeMarshaler{T: TypeTcpConnection, F: marshalTcpConnectionInstance},
		gobject.TypeMarshaler{T: TypeTcpWrapperConnection, F: marshalTcpWrapperConnectionInstance},
		gobject.TypeMarshaler{T: TypeThemedIcon, F: marshalThemedIconInstance},
		gobject.TypeMarshaler{T: TypeThreadedSocketService, F: marshalThreadedSocketServiceInstance},
		gobject.TypeMarshaler{T: TypeTlsCertificate, F: marshalTlsCertificateInstance},
		gobject.TypeMarshaler{T: TypeTlsConnection, F: marshalTlsConnectionInstance},
		gobject.TypeMarshaler{T: TypeTlsDatabase, F: marshalTlsDatabaseInstance},
		gobject.TypeMarshaler{T: TypeTlsInteraction, F: marshalTlsInteractionInstance},
		gobject.TypeMarshaler{T: TypeTlsPassword, F: marshalTlsPasswordInstance},
		gobject.TypeMarshaler{T: TypeVfs, F: marshalVfsInstance},
		gobject.TypeMarshaler{T: TypeVolumeMonitor, F: marshalVolumeMonitorInstance},
		gobject.TypeMarshaler{T: TypeZlibDecompressor, F: marshalZlibDecompressorInstance},
		gobject.TypeMarshaler{T: TypeFileIOStream, F: marshalFileIOStreamInstance},
		gobject.TypeMarshaler{T: TypeFileInputStream, F: marshalFileInputStreamInstance},
		gobject.TypeMarshaler{T: TypeFileOutputStream, F: marshalFileOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeFilterInputStream, F: marshalFilterInputStreamInstance},
		gobject.TypeMarshaler{T: TypeFilterOutputStream, F: marshalFilterOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeInetSocketAddress, F: marshalInetSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeMemoryOutputStream, F: marshalMemoryOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeMenu, F: marshalMenuInstance},
		gobject.TypeMarshaler{T: TypeNativeSocketAddress, F: marshalNativeSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeNativeVolumeMonitor, F: marshalNativeVolumeMonitorInstance},
		gobject.TypeMarshaler{T: TypeProxyAddress, F: marshalProxyAddressInstance},
		gobject.TypeMarshaler{T: TypeProxyAddressEnumerator, F: marshalProxyAddressEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeBufferedInputStream, F: marshalBufferedInputStreamInstance},
		gobject.TypeMarshaler{T: TypeBufferedOutputStream, F: marshalBufferedOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeConverterInputStream, F: marshalConverterInputStreamInstance},
		gobject.TypeMarshaler{T: TypeConverterOutputStream, F: marshalConverterOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeDataInputStream, F: marshalDataInputStreamInstance},
		gobject.TypeMarshaler{T: TypeDataOutputStream, F: marshalDataOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeFileAttributeInfoList, F: marshalFileAttributeInfoList},
		gobject.TypeMarshaler{T: TypeFileAttributeMatcher, F: marshalFileAttributeMatcher},
		gobject.TypeMarshaler{T: TypeSettingsSchema, F: marshalSettingsSchema},
		gobject.TypeMarshaler{T: TypeSettingsSchemaKey, F: marshalSettingsSchemaKey},
		gobject.TypeMarshaler{T: TypeSettingsSchemaSource, F: marshalSettingsSchemaSource},
		gobject.TypeMarshaler{T: TypeSrvTarget, F: marshalSrvTarget},
	})
}

// MENU_EXPORTER_MAX_SECTION_SIZE wraps G_MENU_EXPORTER_MAX_SECTION_SIZE
// 
// see also https://docs.gtk.org/gio/const.MENU_EXPORTER_MAX_SECTION_SIZE.html
//
const MENU_EXPORTER_MAX_SECTION_SIZE = 1000
// BusType wraps GBusType
// 
// see also https://docs.gtk.org/gio/enum.BusType.html
//
type BusType C.int

const (
	// BusTypeStarter wraps G_BUS_TYPE_STARTER
	// 
	// see also https://docs.gtk.org/gio/flags.BusType.html#starter
	//
	BusTypeStarter BusType = -1
	// BusTypeNone wraps G_BUS_TYPE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.BusType.html#none
	//
	BusTypeNone BusType = 0
	// BusTypeSystem wraps G_BUS_TYPE_SYSTEM
	// 
	// see also https://docs.gtk.org/gio/flags.BusType.html#system
	//
	BusTypeSystem BusType = 1
	// BusTypeSession wraps G_BUS_TYPE_SESSION
	// 
	// see also https://docs.gtk.org/gio/flags.BusType.html#session
	//
	BusTypeSession BusType = 2
)

func marshalBusType(p unsafe.Pointer) (any, error) {
	return BusType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = BusType(0)

func (e BusType) GoValueType() gobject.Type {
	return TypeBusType
}

func (e BusType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e BusType) String() string {
	switch e {
		case BusTypeNone: return "BusTypeNone"
		case BusTypeSession: return "BusTypeSession"
		case BusTypeStarter: return "BusTypeStarter"
		case BusTypeSystem: return "BusTypeSystem"
		default: return fmt.Sprintf("BusType(%d)", e)
	}
}

// ConverterResult wraps GConverterResult
// 
// see also https://docs.gtk.org/gio/enum.ConverterResult.html
//
type ConverterResult C.int

const (
	// ConverterError wraps G_CONVERTER_ERROR
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterResult.html#error
	//
	ConverterError ConverterResult = 0
	// ConverterConverted wraps G_CONVERTER_CONVERTED
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterResult.html#converted
	//
	ConverterConverted ConverterResult = 1
	// ConverterFinished wraps G_CONVERTER_FINISHED
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterResult.html#finished
	//
	ConverterFinished ConverterResult = 2
	// ConverterFlushed wraps G_CONVERTER_FLUSHED
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterResult.html#flushed
	//
	ConverterFlushed ConverterResult = 3
)

func marshalConverterResult(p unsafe.Pointer) (any, error) {
	return ConverterResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ConverterResult(0)

func (e ConverterResult) GoValueType() gobject.Type {
	return TypeConverterResult
}

func (e ConverterResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ConverterResult) String() string {
	switch e {
		case ConverterConverted: return "ConverterConverted"
		case ConverterError: return "ConverterError"
		case ConverterFinished: return "ConverterFinished"
		case ConverterFlushed: return "ConverterFlushed"
		default: return fmt.Sprintf("ConverterResult(%d)", e)
	}
}

// CredentialsType wraps GCredentialsType
// 
// see also https://docs.gtk.org/gio/enum.CredentialsType.html
//
type CredentialsType C.int

const (
	// CredentialsTypeInvalid wraps G_CREDENTIALS_TYPE_INVALID
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#invalid
	//
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred wraps G_CREDENTIALS_TYPE_LINUX_UCRED
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#linux_ucred
	//
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred wraps G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#freebsd_cmsgcred
	//
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred wraps G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#openbsd_sockpeercred
	//
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred wraps G_CREDENTIALS_TYPE_SOLARIS_UCRED
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#solaris_ucred
	//
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid wraps G_CREDENTIALS_TYPE_NETBSD_UNPCBID
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#netbsd_unpcbid
	//
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred wraps G_CREDENTIALS_TYPE_APPLE_XUCRED
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#apple_xucred
	//
	CredentialsTypeAppleXucred CredentialsType = 6
	// CredentialsTypeWin32Pid wraps G_CREDENTIALS_TYPE_WIN32_PID
	// 
	// see also https://docs.gtk.org/gio/flags.CredentialsType.html#win32_pid
	//
	CredentialsTypeWin32Pid CredentialsType = 7
)

func marshalCredentialsType(p unsafe.Pointer) (any, error) {
	return CredentialsType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = CredentialsType(0)

func (e CredentialsType) GoValueType() gobject.Type {
	return TypeCredentialsType
}

func (e CredentialsType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e CredentialsType) String() string {
	switch e {
		case CredentialsTypeAppleXucred: return "CredentialsTypeAppleXucred"
		case CredentialsTypeFreebsdCmsgcred: return "CredentialsTypeFreebsdCmsgcred"
		case CredentialsTypeInvalid: return "CredentialsTypeInvalid"
		case CredentialsTypeLinuxUcred: return "CredentialsTypeLinuxUcred"
		case CredentialsTypeNetbsdUnpcbid: return "CredentialsTypeNetbsdUnpcbid"
		case CredentialsTypeOpenbsdSockpeercred: return "CredentialsTypeOpenbsdSockpeercred"
		case CredentialsTypeSolarisUcred: return "CredentialsTypeSolarisUcred"
		case CredentialsTypeWin32Pid: return "CredentialsTypeWin32Pid"
		default: return fmt.Sprintf("CredentialsType(%d)", e)
	}
}

// DataStreamByteOrder wraps GDataStreamByteOrder
// 
// see also https://docs.gtk.org/gio/enum.DataStreamByteOrder.html
//
type DataStreamByteOrder C.int

const (
	// DataStreamByteOrderBigEndian wraps G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamByteOrder.html#big_endian
	//
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian wraps G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamByteOrder.html#little_endian
	//
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian wraps G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamByteOrder.html#host_endian
	//
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p unsafe.Pointer) (any, error) {
	return DataStreamByteOrder(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DataStreamByteOrder(0)

func (e DataStreamByteOrder) GoValueType() gobject.Type {
	return TypeDataStreamByteOrder
}

func (e DataStreamByteOrder) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DataStreamByteOrder) String() string {
	switch e {
		case DataStreamByteOrderBigEndian: return "DataStreamByteOrderBigEndian"
		case DataStreamByteOrderHostEndian: return "DataStreamByteOrderHostEndian"
		case DataStreamByteOrderLittleEndian: return "DataStreamByteOrderLittleEndian"
		default: return fmt.Sprintf("DataStreamByteOrder(%d)", e)
	}
}

// DataStreamNewlineType wraps GDataStreamNewlineType
// 
// see also https://docs.gtk.org/gio/enum.DataStreamNewlineType.html
//
type DataStreamNewlineType C.int

const (
	// DataStreamNewlineTypeLf wraps G_DATA_STREAM_NEWLINE_TYPE_LF
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamNewlineType.html#lf
	//
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr wraps G_DATA_STREAM_NEWLINE_TYPE_CR
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamNewlineType.html#cr
	//
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf wraps G_DATA_STREAM_NEWLINE_TYPE_CR_LF
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamNewlineType.html#cr_lf
	//
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny wraps G_DATA_STREAM_NEWLINE_TYPE_ANY
	// 
	// see also https://docs.gtk.org/gio/flags.DataStreamNewlineType.html#any
	//
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p unsafe.Pointer) (any, error) {
	return DataStreamNewlineType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DataStreamNewlineType(0)

func (e DataStreamNewlineType) GoValueType() gobject.Type {
	return TypeDataStreamNewlineType
}

func (e DataStreamNewlineType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DataStreamNewlineType) String() string {
	switch e {
		case DataStreamNewlineTypeAny: return "DataStreamNewlineTypeAny"
		case DataStreamNewlineTypeCr: return "DataStreamNewlineTypeCr"
		case DataStreamNewlineTypeCrLf: return "DataStreamNewlineTypeCrLf"
		case DataStreamNewlineTypeLf: return "DataStreamNewlineTypeLf"
		default: return fmt.Sprintf("DataStreamNewlineType(%d)", e)
	}
}

// DriveStartStopType wraps GDriveStartStopType
// 
// see also https://docs.gtk.org/gio/enum.DriveStartStopType.html
//
type DriveStartStopType C.int

const (
	// DriveStartStopTypeUnknown wraps G_DRIVE_START_STOP_TYPE_UNKNOWN
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartStopType.html#unknown
	//
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown wraps G_DRIVE_START_STOP_TYPE_SHUTDOWN
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartStopType.html#shutdown
	//
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork wraps G_DRIVE_START_STOP_TYPE_NETWORK
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartStopType.html#network
	//
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk wraps G_DRIVE_START_STOP_TYPE_MULTIDISK
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartStopType.html#multidisk
	//
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword wraps G_DRIVE_START_STOP_TYPE_PASSWORD
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartStopType.html#password
	//
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p unsafe.Pointer) (any, error) {
	return DriveStartStopType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DriveStartStopType(0)

func (e DriveStartStopType) GoValueType() gobject.Type {
	return TypeDriveStartStopType
}

func (e DriveStartStopType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DriveStartStopType) String() string {
	switch e {
		case DriveStartStopTypeMultidisk: return "DriveStartStopTypeMultidisk"
		case DriveStartStopTypeNetwork: return "DriveStartStopTypeNetwork"
		case DriveStartStopTypePassword: return "DriveStartStopTypePassword"
		case DriveStartStopTypeShutdown: return "DriveStartStopTypeShutdown"
		case DriveStartStopTypeUnknown: return "DriveStartStopTypeUnknown"
		default: return fmt.Sprintf("DriveStartStopType(%d)", e)
	}
}

// EmblemOrigin wraps GEmblemOrigin
// 
// see also https://docs.gtk.org/gio/enum.EmblemOrigin.html
//
type EmblemOrigin C.int

const (
	// EmblemOriginUnknown wraps G_EMBLEM_ORIGIN_UNKNOWN
	// 
	// see also https://docs.gtk.org/gio/flags.EmblemOrigin.html#unknown
	//
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice wraps G_EMBLEM_ORIGIN_DEVICE
	// 
	// see also https://docs.gtk.org/gio/flags.EmblemOrigin.html#device
	//
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata wraps G_EMBLEM_ORIGIN_LIVEMETADATA
	// 
	// see also https://docs.gtk.org/gio/flags.EmblemOrigin.html#livemetadata
	//
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag wraps G_EMBLEM_ORIGIN_TAG
	// 
	// see also https://docs.gtk.org/gio/flags.EmblemOrigin.html#tag
	//
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p unsafe.Pointer) (any, error) {
	return EmblemOrigin(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = EmblemOrigin(0)

func (e EmblemOrigin) GoValueType() gobject.Type {
	return TypeEmblemOrigin
}

func (e EmblemOrigin) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e EmblemOrigin) String() string {
	switch e {
		case EmblemOriginDevice: return "EmblemOriginDevice"
		case EmblemOriginLivemetadata: return "EmblemOriginLivemetadata"
		case EmblemOriginTag: return "EmblemOriginTag"
		case EmblemOriginUnknown: return "EmblemOriginUnknown"
		default: return fmt.Sprintf("EmblemOrigin(%d)", e)
	}
}

// FileAttributeStatus wraps GFileAttributeStatus
// 
// see also https://docs.gtk.org/gio/enum.FileAttributeStatus.html
//
type FileAttributeStatus C.int

const (
	// FileAttributeStatusUnset wraps G_FILE_ATTRIBUTE_STATUS_UNSET
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeStatus.html#unset
	//
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet wraps G_FILE_ATTRIBUTE_STATUS_SET
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeStatus.html#set
	//
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting wraps G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeStatus.html#error_setting
	//
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p unsafe.Pointer) (any, error) {
	return FileAttributeStatus(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileAttributeStatus(0)

func (e FileAttributeStatus) GoValueType() gobject.Type {
	return TypeFileAttributeStatus
}

func (e FileAttributeStatus) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileAttributeStatus) String() string {
	switch e {
		case FileAttributeStatusErrorSetting: return "FileAttributeStatusErrorSetting"
		case FileAttributeStatusSet: return "FileAttributeStatusSet"
		case FileAttributeStatusUnset: return "FileAttributeStatusUnset"
		default: return fmt.Sprintf("FileAttributeStatus(%d)", e)
	}
}

// FileAttributeType wraps GFileAttributeType
// 
// see also https://docs.gtk.org/gio/enum.FileAttributeType.html
//
type FileAttributeType C.int

const (
	// FileAttributeTypeInvalid wraps G_FILE_ATTRIBUTE_TYPE_INVALID
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#invalid
	//
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString wraps G_FILE_ATTRIBUTE_TYPE_STRING
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#string
	//
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString wraps G_FILE_ATTRIBUTE_TYPE_BYTE_STRING
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#byte_string
	//
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean wraps G_FILE_ATTRIBUTE_TYPE_BOOLEAN
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#boolean
	//
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32 wraps G_FILE_ATTRIBUTE_TYPE_UINT32
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#uint32
	//
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32 wraps G_FILE_ATTRIBUTE_TYPE_INT32
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#int32
	//
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64 wraps G_FILE_ATTRIBUTE_TYPE_UINT64
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#uint64
	//
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64 wraps G_FILE_ATTRIBUTE_TYPE_INT64
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#int64
	//
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject wraps G_FILE_ATTRIBUTE_TYPE_OBJECT
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#object
	//
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv wraps G_FILE_ATTRIBUTE_TYPE_STRINGV
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeType.html#stringv
	//
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p unsafe.Pointer) (any, error) {
	return FileAttributeType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileAttributeType(0)

func (e FileAttributeType) GoValueType() gobject.Type {
	return TypeFileAttributeType
}

func (e FileAttributeType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileAttributeType) String() string {
	switch e {
		case FileAttributeTypeBoolean: return "FileAttributeTypeBoolean"
		case FileAttributeTypeByteString: return "FileAttributeTypeByteString"
		case FileAttributeTypeInt32: return "FileAttributeTypeInt32"
		case FileAttributeTypeInt64: return "FileAttributeTypeInt64"
		case FileAttributeTypeInvalid: return "FileAttributeTypeInvalid"
		case FileAttributeTypeObject: return "FileAttributeTypeObject"
		case FileAttributeTypeString: return "FileAttributeTypeString"
		case FileAttributeTypeStringv: return "FileAttributeTypeStringv"
		case FileAttributeTypeUint32: return "FileAttributeTypeUint32"
		case FileAttributeTypeUint64: return "FileAttributeTypeUint64"
		default: return fmt.Sprintf("FileAttributeType(%d)", e)
	}
}

// FileMonitorEvent wraps GFileMonitorEvent
// 
// see also https://docs.gtk.org/gio/enum.FileMonitorEvent.html
//
type FileMonitorEvent C.int

const (
	// FileMonitorEventChanged wraps G_FILE_MONITOR_EVENT_CHANGED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#changed
	//
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint wraps G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#changes_done_hint
	//
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted wraps G_FILE_MONITOR_EVENT_DELETED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#deleted
	//
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated wraps G_FILE_MONITOR_EVENT_CREATED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#created
	//
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged wraps G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#attribute_changed
	//
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount wraps G_FILE_MONITOR_EVENT_PRE_UNMOUNT
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#pre_unmount
	//
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted wraps G_FILE_MONITOR_EVENT_UNMOUNTED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#unmounted
	//
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved wraps G_FILE_MONITOR_EVENT_MOVED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#moved
	//
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed wraps G_FILE_MONITOR_EVENT_RENAMED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#renamed
	//
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn wraps G_FILE_MONITOR_EVENT_MOVED_IN
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#moved_in
	//
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut wraps G_FILE_MONITOR_EVENT_MOVED_OUT
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorEvent.html#moved_out
	//
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p unsafe.Pointer) (any, error) {
	return FileMonitorEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileMonitorEvent(0)

func (e FileMonitorEvent) GoValueType() gobject.Type {
	return TypeFileMonitorEvent
}

func (e FileMonitorEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileMonitorEvent) String() string {
	switch e {
		case FileMonitorEventAttributeChanged: return "FileMonitorEventAttributeChanged"
		case FileMonitorEventChanged: return "FileMonitorEventChanged"
		case FileMonitorEventChangesDoneHint: return "FileMonitorEventChangesDoneHint"
		case FileMonitorEventCreated: return "FileMonitorEventCreated"
		case FileMonitorEventDeleted: return "FileMonitorEventDeleted"
		case FileMonitorEventMoved: return "FileMonitorEventMoved"
		case FileMonitorEventMovedIn: return "FileMonitorEventMovedIn"
		case FileMonitorEventMovedOut: return "FileMonitorEventMovedOut"
		case FileMonitorEventPreUnmount: return "FileMonitorEventPreUnmount"
		case FileMonitorEventRenamed: return "FileMonitorEventRenamed"
		case FileMonitorEventUnmounted: return "FileMonitorEventUnmounted"
		default: return fmt.Sprintf("FileMonitorEvent(%d)", e)
	}
}

// FileType wraps GFileType
// 
// see also https://docs.gtk.org/gio/enum.FileType.html
//
type FileType C.int

const (
	// FileTypeUnknown wraps G_FILE_TYPE_UNKNOWN
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#unknown
	//
	FileTypeUnknown FileType = 0
	// FileTypeRegular wraps G_FILE_TYPE_REGULAR
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#regular
	//
	FileTypeRegular FileType = 1
	// FileTypeDirectory wraps G_FILE_TYPE_DIRECTORY
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#directory
	//
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink wraps G_FILE_TYPE_SYMBOLIC_LINK
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#symbolic_link
	//
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial wraps G_FILE_TYPE_SPECIAL
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#special
	//
	FileTypeSpecial FileType = 4
	// FileTypeShortcut wraps G_FILE_TYPE_SHORTCUT
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#shortcut
	//
	FileTypeShortcut FileType = 5
	// FileTypeMountable wraps G_FILE_TYPE_MOUNTABLE
	// 
	// see also https://docs.gtk.org/gio/flags.FileType.html#mountable
	//
	FileTypeMountable FileType = 6
)

func marshalFileType(p unsafe.Pointer) (any, error) {
	return FileType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileType(0)

func (e FileType) GoValueType() gobject.Type {
	return TypeFileType
}

func (e FileType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileType) String() string {
	switch e {
		case FileTypeDirectory: return "FileTypeDirectory"
		case FileTypeMountable: return "FileTypeMountable"
		case FileTypeRegular: return "FileTypeRegular"
		case FileTypeShortcut: return "FileTypeShortcut"
		case FileTypeSpecial: return "FileTypeSpecial"
		case FileTypeSymbolicLink: return "FileTypeSymbolicLink"
		case FileTypeUnknown: return "FileTypeUnknown"
		default: return fmt.Sprintf("FileType(%d)", e)
	}
}

// FilesystemPreviewType wraps GFilesystemPreviewType
// 
// see also https://docs.gtk.org/gio/enum.FilesystemPreviewType.html
//
type FilesystemPreviewType C.int

const (
	// FilesystemPreviewTypeIfAlways wraps G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS
	// 
	// see also https://docs.gtk.org/gio/flags.FilesystemPreviewType.html#if_always
	//
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal wraps G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL
	// 
	// see also https://docs.gtk.org/gio/flags.FilesystemPreviewType.html#if_local
	//
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever wraps G_FILESYSTEM_PREVIEW_TYPE_NEVER
	// 
	// see also https://docs.gtk.org/gio/flags.FilesystemPreviewType.html#never
	//
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p unsafe.Pointer) (any, error) {
	return FilesystemPreviewType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FilesystemPreviewType(0)

func (e FilesystemPreviewType) GoValueType() gobject.Type {
	return TypeFilesystemPreviewType
}

func (e FilesystemPreviewType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FilesystemPreviewType) String() string {
	switch e {
		case FilesystemPreviewTypeIfAlways: return "FilesystemPreviewTypeIfAlways"
		case FilesystemPreviewTypeIfLocal: return "FilesystemPreviewTypeIfLocal"
		case FilesystemPreviewTypeNever: return "FilesystemPreviewTypeNever"
		default: return fmt.Sprintf("FilesystemPreviewType(%d)", e)
	}
}

// IOErrorEnum wraps GIOErrorEnum
// 
// see also https://docs.gtk.org/gio/enum.IOErrorEnum.html
//
type IOErrorEnum C.int

const (
	// IOErrorFailed wraps G_IO_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#failed
	//
	IOErrorFailed IOErrorEnum = 0
	// IOErrorNotFound wraps G_IO_ERROR_NOT_FOUND
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_found
	//
	IOErrorNotFound IOErrorEnum = 1
	// IOErrorExists wraps G_IO_ERROR_EXISTS
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#exists
	//
	IOErrorExists IOErrorEnum = 2
	// IOErrorIsDirectory wraps G_IO_ERROR_IS_DIRECTORY
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#is_directory
	//
	IOErrorIsDirectory IOErrorEnum = 3
	// IOErrorNotDirectory wraps G_IO_ERROR_NOT_DIRECTORY
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_directory
	//
	IOErrorNotDirectory IOErrorEnum = 4
	// IOErrorNotEmpty wraps G_IO_ERROR_NOT_EMPTY
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_empty
	//
	IOErrorNotEmpty IOErrorEnum = 5
	// IOErrorNotRegularFile wraps G_IO_ERROR_NOT_REGULAR_FILE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_regular_file
	//
	IOErrorNotRegularFile IOErrorEnum = 6
	// IOErrorNotSymbolicLink wraps G_IO_ERROR_NOT_SYMBOLIC_LINK
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_symbolic_link
	//
	IOErrorNotSymbolicLink IOErrorEnum = 7
	// IOErrorNotMountableFile wraps G_IO_ERROR_NOT_MOUNTABLE_FILE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_mountable_file
	//
	IOErrorNotMountableFile IOErrorEnum = 8
	// IOErrorFilenameTooLong wraps G_IO_ERROR_FILENAME_TOO_LONG
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#filename_too_long
	//
	IOErrorFilenameTooLong IOErrorEnum = 9
	// IOErrorInvalidFilename wraps G_IO_ERROR_INVALID_FILENAME
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#invalid_filename
	//
	IOErrorInvalidFilename IOErrorEnum = 10
	// IOErrorTooManyLinks wraps G_IO_ERROR_TOO_MANY_LINKS
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#too_many_links
	//
	IOErrorTooManyLinks IOErrorEnum = 11
	// IOErrorNoSpace wraps G_IO_ERROR_NO_SPACE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#no_space
	//
	IOErrorNoSpace IOErrorEnum = 12
	// IOErrorInvalidArgument wraps G_IO_ERROR_INVALID_ARGUMENT
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#invalid_argument
	//
	IOErrorInvalidArgument IOErrorEnum = 13
	// IOErrorPermissionDenied wraps G_IO_ERROR_PERMISSION_DENIED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#permission_denied
	//
	IOErrorPermissionDenied IOErrorEnum = 14
	// IOErrorNotSupported wraps G_IO_ERROR_NOT_SUPPORTED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_supported
	//
	IOErrorNotSupported IOErrorEnum = 15
	// IOErrorNotMounted wraps G_IO_ERROR_NOT_MOUNTED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_mounted
	//
	IOErrorNotMounted IOErrorEnum = 16
	// IOErrorAlreadyMounted wraps G_IO_ERROR_ALREADY_MOUNTED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#already_mounted
	//
	IOErrorAlreadyMounted IOErrorEnum = 17
	// IOErrorClosed wraps G_IO_ERROR_CLOSED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#closed
	//
	IOErrorClosed IOErrorEnum = 18
	// IOErrorCancelled wraps G_IO_ERROR_CANCELLED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#cancelled
	//
	IOErrorCancelled IOErrorEnum = 19
	// IOErrorPending wraps G_IO_ERROR_PENDING
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#pending
	//
	IOErrorPending IOErrorEnum = 20
	// IOErrorReadOnly wraps G_IO_ERROR_READ_ONLY
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#read_only
	//
	IOErrorReadOnly IOErrorEnum = 21
	// IOErrorCantCreateBackup wraps G_IO_ERROR_CANT_CREATE_BACKUP
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#cant_create_backup
	//
	IOErrorCantCreateBackup IOErrorEnum = 22
	// IOErrorWrongEtag wraps G_IO_ERROR_WRONG_ETAG
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#wrong_etag
	//
	IOErrorWrongEtag IOErrorEnum = 23
	// IOErrorTimedOut wraps G_IO_ERROR_TIMED_OUT
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#timed_out
	//
	IOErrorTimedOut IOErrorEnum = 24
	// IOErrorWouldRecurse wraps G_IO_ERROR_WOULD_RECURSE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#would_recurse
	//
	IOErrorWouldRecurse IOErrorEnum = 25
	// IOErrorBusy wraps G_IO_ERROR_BUSY
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#busy
	//
	IOErrorBusy IOErrorEnum = 26
	// IOErrorWouldBlock wraps G_IO_ERROR_WOULD_BLOCK
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#would_block
	//
	IOErrorWouldBlock IOErrorEnum = 27
	// IOErrorHostNotFound wraps G_IO_ERROR_HOST_NOT_FOUND
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#host_not_found
	//
	IOErrorHostNotFound IOErrorEnum = 28
	// IOErrorWouldMerge wraps G_IO_ERROR_WOULD_MERGE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#would_merge
	//
	IOErrorWouldMerge IOErrorEnum = 29
	// IOErrorFailedHandled wraps G_IO_ERROR_FAILED_HANDLED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#failed_handled
	//
	IOErrorFailedHandled IOErrorEnum = 30
	// IOErrorTooManyOpenFiles wraps G_IO_ERROR_TOO_MANY_OPEN_FILES
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#too_many_open_files
	//
	IOErrorTooManyOpenFiles IOErrorEnum = 31
	// IOErrorNotInitialized wraps G_IO_ERROR_NOT_INITIALIZED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_initialized
	//
	IOErrorNotInitialized IOErrorEnum = 32
	// IOErrorAddressInUse wraps G_IO_ERROR_ADDRESS_IN_USE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#address_in_use
	//
	IOErrorAddressInUse IOErrorEnum = 33
	// IOErrorPartialInput wraps G_IO_ERROR_PARTIAL_INPUT
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#partial_input
	//
	IOErrorPartialInput IOErrorEnum = 34
	// IOErrorInvalidData wraps G_IO_ERROR_INVALID_DATA
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#invalid_data
	//
	IOErrorInvalidData IOErrorEnum = 35
	// IOErrorDBusError wraps G_IO_ERROR_DBUS_ERROR
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#dbus_error
	//
	IOErrorDBusError IOErrorEnum = 36
	// IOErrorHostUnreachable wraps G_IO_ERROR_HOST_UNREACHABLE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#host_unreachable
	//
	IOErrorHostUnreachable IOErrorEnum = 37
	// IOErrorNetworkUnreachable wraps G_IO_ERROR_NETWORK_UNREACHABLE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#network_unreachable
	//
	IOErrorNetworkUnreachable IOErrorEnum = 38
	// IOErrorConnectionRefused wraps G_IO_ERROR_CONNECTION_REFUSED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#connection_refused
	//
	IOErrorConnectionRefused IOErrorEnum = 39
	// IOErrorProxyFailed wraps G_IO_ERROR_PROXY_FAILED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#proxy_failed
	//
	IOErrorProxyFailed IOErrorEnum = 40
	// IOErrorProxyAuthFailed wraps G_IO_ERROR_PROXY_AUTH_FAILED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#proxy_auth_failed
	//
	IOErrorProxyAuthFailed IOErrorEnum = 41
	// IOErrorProxyNeedAuth wraps G_IO_ERROR_PROXY_NEED_AUTH
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#proxy_need_auth
	//
	IOErrorProxyNeedAuth IOErrorEnum = 42
	// IOErrorProxyNotAllowed wraps G_IO_ERROR_PROXY_NOT_ALLOWED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#proxy_not_allowed
	//
	IOErrorProxyNotAllowed IOErrorEnum = 43
	// IOErrorBrokenPipe wraps G_IO_ERROR_BROKEN_PIPE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#broken_pipe
	//
	IOErrorBrokenPipe IOErrorEnum = 44
	// IOErrorConnectionClosed wraps G_IO_ERROR_CONNECTION_CLOSED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#connection_closed
	//
	IOErrorConnectionClosed IOErrorEnum = 44
	// IOErrorNotConnected wraps G_IO_ERROR_NOT_CONNECTED
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#not_connected
	//
	IOErrorNotConnected IOErrorEnum = 45
	// IOErrorMessageTooLarge wraps G_IO_ERROR_MESSAGE_TOO_LARGE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#message_too_large
	//
	IOErrorMessageTooLarge IOErrorEnum = 46
	// IOErrorNoSuchDevice wraps G_IO_ERROR_NO_SUCH_DEVICE
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#no_such_device
	//
	IOErrorNoSuchDevice IOErrorEnum = 47
	// IOErrorDestinationUnset wraps G_IO_ERROR_DESTINATION_UNSET
	// 
	// see also https://docs.gtk.org/gio/flags.IOErrorEnum.html#destination_unset
	//
	IOErrorDestinationUnset IOErrorEnum = 48
)

func marshalIOErrorEnum(p unsafe.Pointer) (any, error) {
	return IOErrorEnum(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = IOErrorEnum(0)

func (e IOErrorEnum) GoValueType() gobject.Type {
	return TypeIOErrorEnum
}

func (e IOErrorEnum) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e IOErrorEnum) String() string {
	switch e {
		case IOErrorAddressInUse: return "IOErrorAddressInUse"
		case IOErrorAlreadyMounted: return "IOErrorAlreadyMounted"
		case IOErrorBrokenPipe: return "IOErrorBrokenPipe"
		case IOErrorBusy: return "IOErrorBusy"
		case IOErrorCancelled: return "IOErrorCancelled"
		case IOErrorCantCreateBackup: return "IOErrorCantCreateBackup"
		case IOErrorClosed: return "IOErrorClosed"
		case IOErrorConnectionRefused: return "IOErrorConnectionRefused"
		case IOErrorDBusError: return "IOErrorDBusError"
		case IOErrorDestinationUnset: return "IOErrorDestinationUnset"
		case IOErrorExists: return "IOErrorExists"
		case IOErrorFailed: return "IOErrorFailed"
		case IOErrorFailedHandled: return "IOErrorFailedHandled"
		case IOErrorFilenameTooLong: return "IOErrorFilenameTooLong"
		case IOErrorHostNotFound: return "IOErrorHostNotFound"
		case IOErrorHostUnreachable: return "IOErrorHostUnreachable"
		case IOErrorInvalidArgument: return "IOErrorInvalidArgument"
		case IOErrorInvalidData: return "IOErrorInvalidData"
		case IOErrorInvalidFilename: return "IOErrorInvalidFilename"
		case IOErrorIsDirectory: return "IOErrorIsDirectory"
		case IOErrorMessageTooLarge: return "IOErrorMessageTooLarge"
		case IOErrorNetworkUnreachable: return "IOErrorNetworkUnreachable"
		case IOErrorNoSpace: return "IOErrorNoSpace"
		case IOErrorNoSuchDevice: return "IOErrorNoSuchDevice"
		case IOErrorNotConnected: return "IOErrorNotConnected"
		case IOErrorNotDirectory: return "IOErrorNotDirectory"
		case IOErrorNotEmpty: return "IOErrorNotEmpty"
		case IOErrorNotFound: return "IOErrorNotFound"
		case IOErrorNotInitialized: return "IOErrorNotInitialized"
		case IOErrorNotMountableFile: return "IOErrorNotMountableFile"
		case IOErrorNotMounted: return "IOErrorNotMounted"
		case IOErrorNotRegularFile: return "IOErrorNotRegularFile"
		case IOErrorNotSupported: return "IOErrorNotSupported"
		case IOErrorNotSymbolicLink: return "IOErrorNotSymbolicLink"
		case IOErrorPartialInput: return "IOErrorPartialInput"
		case IOErrorPending: return "IOErrorPending"
		case IOErrorPermissionDenied: return "IOErrorPermissionDenied"
		case IOErrorProxyAuthFailed: return "IOErrorProxyAuthFailed"
		case IOErrorProxyFailed: return "IOErrorProxyFailed"
		case IOErrorProxyNeedAuth: return "IOErrorProxyNeedAuth"
		case IOErrorProxyNotAllowed: return "IOErrorProxyNotAllowed"
		case IOErrorReadOnly: return "IOErrorReadOnly"
		case IOErrorTimedOut: return "IOErrorTimedOut"
		case IOErrorTooManyLinks: return "IOErrorTooManyLinks"
		case IOErrorTooManyOpenFiles: return "IOErrorTooManyOpenFiles"
		case IOErrorWouldBlock: return "IOErrorWouldBlock"
		case IOErrorWouldMerge: return "IOErrorWouldMerge"
		case IOErrorWouldRecurse: return "IOErrorWouldRecurse"
		case IOErrorWrongEtag: return "IOErrorWrongEtag"
		default: return fmt.Sprintf("IOErrorEnum(%d)", e)
	}
}

// IOModuleScopeFlags wraps GIOModuleScopeFlags
// 
// see also https://docs.gtk.org/gio/enum.IOModuleScopeFlags.html
//
type IOModuleScopeFlags C.int

const (
	// IOModuleScopeNone wraps G_IO_MODULE_SCOPE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.IOModuleScopeFlags.html#none
	//
	IOModuleScopeNone IOModuleScopeFlags = 0
	// IOModuleScopeBlockDuplicates wraps G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
	// 
	// see also https://docs.gtk.org/gio/flags.IOModuleScopeFlags.html#block_duplicates
	//
	IOModuleScopeBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p unsafe.Pointer) (any, error) {
	return IOModuleScopeFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = IOModuleScopeFlags(0)

func (e IOModuleScopeFlags) GoValueType() gobject.Type {
	return TypeIOModuleScopeFlags
}

func (e IOModuleScopeFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e IOModuleScopeFlags) String() string {
	switch e {
		case IOModuleScopeBlockDuplicates: return "IOModuleScopeBlockDuplicates"
		case IOModuleScopeNone: return "IOModuleScopeNone"
		default: return fmt.Sprintf("IOModuleScopeFlags(%d)", e)
	}
}

// MemoryMonitorWarningLevel wraps GMemoryMonitorWarningLevel
// 
// see also https://docs.gtk.org/gio/enum.MemoryMonitorWarningLevel.html
//
type MemoryMonitorWarningLevel C.int

const (
	// MemoryMonitorWarningLevelLow wraps G_MEMORY_MONITOR_WARNING_LEVEL_LOW
	// 
	// see also https://docs.gtk.org/gio/flags.MemoryMonitorWarningLevel.html#low
	//
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium wraps G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM
	// 
	// see also https://docs.gtk.org/gio/flags.MemoryMonitorWarningLevel.html#medium
	//
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical wraps G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL
	// 
	// see also https://docs.gtk.org/gio/flags.MemoryMonitorWarningLevel.html#critical
	//
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p unsafe.Pointer) (any, error) {
	return MemoryMonitorWarningLevel(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = MemoryMonitorWarningLevel(0)

func (e MemoryMonitorWarningLevel) GoValueType() gobject.Type {
	return TypeMemoryMonitorWarningLevel
}

func (e MemoryMonitorWarningLevel) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e MemoryMonitorWarningLevel) String() string {
	switch e {
		case MemoryMonitorWarningLevelCritical: return "MemoryMonitorWarningLevelCritical"
		case MemoryMonitorWarningLevelLow: return "MemoryMonitorWarningLevelLow"
		case MemoryMonitorWarningLevelMedium: return "MemoryMonitorWarningLevelMedium"
		default: return fmt.Sprintf("MemoryMonitorWarningLevel(%d)", e)
	}
}

// MountOperationResult wraps GMountOperationResult
// 
// see also https://docs.gtk.org/gio/enum.MountOperationResult.html
//
type MountOperationResult C.int

const (
	// MountOperationHandled wraps G_MOUNT_OPERATION_HANDLED
	// 
	// see also https://docs.gtk.org/gio/flags.MountOperationResult.html#handled
	//
	MountOperationHandled MountOperationResult = 0
	// MountOperationAborted wraps G_MOUNT_OPERATION_ABORTED
	// 
	// see also https://docs.gtk.org/gio/flags.MountOperationResult.html#aborted
	//
	MountOperationAborted MountOperationResult = 1
	// MountOperationUnhandled wraps G_MOUNT_OPERATION_UNHANDLED
	// 
	// see also https://docs.gtk.org/gio/flags.MountOperationResult.html#unhandled
	//
	MountOperationUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p unsafe.Pointer) (any, error) {
	return MountOperationResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = MountOperationResult(0)

func (e MountOperationResult) GoValueType() gobject.Type {
	return TypeMountOperationResult
}

func (e MountOperationResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e MountOperationResult) String() string {
	switch e {
		case MountOperationAborted: return "MountOperationAborted"
		case MountOperationHandled: return "MountOperationHandled"
		case MountOperationUnhandled: return "MountOperationUnhandled"
		default: return fmt.Sprintf("MountOperationResult(%d)", e)
	}
}

// NetworkConnectivity wraps GNetworkConnectivity
// 
// see also https://docs.gtk.org/gio/enum.NetworkConnectivity.html
//
type NetworkConnectivity C.int

const (
	// NetworkConnectivityLocal wraps G_NETWORK_CONNECTIVITY_LOCAL
	// 
	// see also https://docs.gtk.org/gio/flags.NetworkConnectivity.html#local
	//
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited wraps G_NETWORK_CONNECTIVITY_LIMITED
	// 
	// see also https://docs.gtk.org/gio/flags.NetworkConnectivity.html#limited
	//
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal wraps G_NETWORK_CONNECTIVITY_PORTAL
	// 
	// see also https://docs.gtk.org/gio/flags.NetworkConnectivity.html#portal
	//
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull wraps G_NETWORK_CONNECTIVITY_FULL
	// 
	// see also https://docs.gtk.org/gio/flags.NetworkConnectivity.html#full
	//
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p unsafe.Pointer) (any, error) {
	return NetworkConnectivity(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = NetworkConnectivity(0)

func (e NetworkConnectivity) GoValueType() gobject.Type {
	return TypeNetworkConnectivity
}

func (e NetworkConnectivity) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e NetworkConnectivity) String() string {
	switch e {
		case NetworkConnectivityFull: return "NetworkConnectivityFull"
		case NetworkConnectivityLimited: return "NetworkConnectivityLimited"
		case NetworkConnectivityLocal: return "NetworkConnectivityLocal"
		case NetworkConnectivityPortal: return "NetworkConnectivityPortal"
		default: return fmt.Sprintf("NetworkConnectivity(%d)", e)
	}
}

// NotificationPriority wraps GNotificationPriority
// 
// see also https://docs.gtk.org/gio/enum.NotificationPriority.html
//
type NotificationPriority C.int

const (
	// NotificationPriorityNormal wraps G_NOTIFICATION_PRIORITY_NORMAL
	// 
	// see also https://docs.gtk.org/gio/flags.NotificationPriority.html#normal
	//
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow wraps G_NOTIFICATION_PRIORITY_LOW
	// 
	// see also https://docs.gtk.org/gio/flags.NotificationPriority.html#low
	//
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh wraps G_NOTIFICATION_PRIORITY_HIGH
	// 
	// see also https://docs.gtk.org/gio/flags.NotificationPriority.html#high
	//
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent wraps G_NOTIFICATION_PRIORITY_URGENT
	// 
	// see also https://docs.gtk.org/gio/flags.NotificationPriority.html#urgent
	//
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p unsafe.Pointer) (any, error) {
	return NotificationPriority(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = NotificationPriority(0)

func (e NotificationPriority) GoValueType() gobject.Type {
	return TypeNotificationPriority
}

func (e NotificationPriority) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e NotificationPriority) String() string {
	switch e {
		case NotificationPriorityHigh: return "NotificationPriorityHigh"
		case NotificationPriorityLow: return "NotificationPriorityLow"
		case NotificationPriorityNormal: return "NotificationPriorityNormal"
		case NotificationPriorityUrgent: return "NotificationPriorityUrgent"
		default: return fmt.Sprintf("NotificationPriority(%d)", e)
	}
}

// PasswordSave wraps GPasswordSave
// 
// see also https://docs.gtk.org/gio/enum.PasswordSave.html
//
type PasswordSave C.int

const (
	// PasswordSaveNever wraps G_PASSWORD_SAVE_NEVER
	// 
	// see also https://docs.gtk.org/gio/flags.PasswordSave.html#never
	//
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession wraps G_PASSWORD_SAVE_FOR_SESSION
	// 
	// see also https://docs.gtk.org/gio/flags.PasswordSave.html#for_session
	//
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently wraps G_PASSWORD_SAVE_PERMANENTLY
	// 
	// see also https://docs.gtk.org/gio/flags.PasswordSave.html#permanently
	//
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p unsafe.Pointer) (any, error) {
	return PasswordSave(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = PasswordSave(0)

func (e PasswordSave) GoValueType() gobject.Type {
	return TypePasswordSave
}

func (e PasswordSave) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e PasswordSave) String() string {
	switch e {
		case PasswordSaveForSession: return "PasswordSaveForSession"
		case PasswordSaveNever: return "PasswordSaveNever"
		case PasswordSavePermanently: return "PasswordSavePermanently"
		default: return fmt.Sprintf("PasswordSave(%d)", e)
	}
}

// PollableReturn wraps GPollableReturn
// 
// see also https://docs.gtk.org/gio/enum.PollableReturn.html
//
type PollableReturn C.int

const (
	// PollableReturnFailed wraps G_POLLABLE_RETURN_FAILED
	// 
	// see also https://docs.gtk.org/gio/flags.PollableReturn.html#failed
	//
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOK wraps G_POLLABLE_RETURN_OK
	// 
	// see also https://docs.gtk.org/gio/flags.PollableReturn.html#ok
	//
	PollableReturnOK PollableReturn = 1
	// PollableReturnWouldBlock wraps G_POLLABLE_RETURN_WOULD_BLOCK
	// 
	// see also https://docs.gtk.org/gio/flags.PollableReturn.html#would_block
	//
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p unsafe.Pointer) (any, error) {
	return PollableReturn(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = PollableReturn(0)

func (e PollableReturn) GoValueType() gobject.Type {
	return TypePollableReturn
}

func (e PollableReturn) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e PollableReturn) String() string {
	switch e {
		case PollableReturnFailed: return "PollableReturnFailed"
		case PollableReturnOK: return "PollableReturnOK"
		case PollableReturnWouldBlock: return "PollableReturnWouldBlock"
		default: return fmt.Sprintf("PollableReturn(%d)", e)
	}
}

// ResolverError wraps GResolverError
// 
// see also https://docs.gtk.org/gio/enum.ResolverError.html
//
type ResolverError C.int

const (
	// ResolverErrorNotFound wraps G_RESOLVER_ERROR_NOT_FOUND
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverError.html#not_found
	//
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure wraps G_RESOLVER_ERROR_TEMPORARY_FAILURE
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverError.html#temporary_failure
	//
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal wraps G_RESOLVER_ERROR_INTERNAL
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverError.html#internal
	//
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p unsafe.Pointer) (any, error) {
	return ResolverError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResolverError(0)

func (e ResolverError) GoValueType() gobject.Type {
	return TypeResolverError
}

func (e ResolverError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResolverError) String() string {
	switch e {
		case ResolverErrorInternal: return "ResolverErrorInternal"
		case ResolverErrorNotFound: return "ResolverErrorNotFound"
		case ResolverErrorTemporaryFailure: return "ResolverErrorTemporaryFailure"
		default: return fmt.Sprintf("ResolverError(%d)", e)
	}
}

// ResolverErrorQuark wraps g_resolver_error_quark
// 
// see also https://docs.gtk.org/gio/func.g_resolver_error_quark.html
//
func ResolverErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_resolver_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// ResolverRecordType wraps GResolverRecordType
// 
// see also https://docs.gtk.org/gio/enum.ResolverRecordType.html
//
type ResolverRecordType C.int

const (
	// ResolverRecordSrv wraps G_RESOLVER_RECORD_SRV
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverRecordType.html#srv
	//
	ResolverRecordSrv ResolverRecordType = 1
	// ResolverRecordMx wraps G_RESOLVER_RECORD_MX
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverRecordType.html#mx
	//
	ResolverRecordMx ResolverRecordType = 2
	// ResolverRecordTxt wraps G_RESOLVER_RECORD_TXT
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverRecordType.html#txt
	//
	ResolverRecordTxt ResolverRecordType = 3
	// ResolverRecordSoa wraps G_RESOLVER_RECORD_SOA
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverRecordType.html#soa
	//
	ResolverRecordSoa ResolverRecordType = 4
	// ResolverRecordNs wraps G_RESOLVER_RECORD_NS
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverRecordType.html#ns
	//
	ResolverRecordNs ResolverRecordType = 5
)

func marshalResolverRecordType(p unsafe.Pointer) (any, error) {
	return ResolverRecordType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResolverRecordType(0)

func (e ResolverRecordType) GoValueType() gobject.Type {
	return TypeResolverRecordType
}

func (e ResolverRecordType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResolverRecordType) String() string {
	switch e {
		case ResolverRecordMx: return "ResolverRecordMx"
		case ResolverRecordNs: return "ResolverRecordNs"
		case ResolverRecordSoa: return "ResolverRecordSoa"
		case ResolverRecordSrv: return "ResolverRecordSrv"
		case ResolverRecordTxt: return "ResolverRecordTxt"
		default: return fmt.Sprintf("ResolverRecordType(%d)", e)
	}
}

// ResourceError wraps GResourceError
// 
// see also https://docs.gtk.org/gio/enum.ResourceError.html
//
type ResourceError C.int

const (
	// ResourceErrorNotFound wraps G_RESOURCE_ERROR_NOT_FOUND
	// 
	// see also https://docs.gtk.org/gio/flags.ResourceError.html#not_found
	//
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal wraps G_RESOURCE_ERROR_INTERNAL
	// 
	// see also https://docs.gtk.org/gio/flags.ResourceError.html#internal
	//
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p unsafe.Pointer) (any, error) {
	return ResourceError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResourceError(0)

func (e ResourceError) GoValueType() gobject.Type {
	return TypeResourceError
}

func (e ResourceError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResourceError) String() string {
	switch e {
		case ResourceErrorInternal: return "ResourceErrorInternal"
		case ResourceErrorNotFound: return "ResourceErrorNotFound"
		default: return fmt.Sprintf("ResourceError(%d)", e)
	}
}

// ResourceErrorQuark wraps g_resource_error_quark
// 
// see also https://docs.gtk.org/gio/func.g_resource_error_quark.html
//
func ResourceErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_resource_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// SocketClientEvent wraps GSocketClientEvent
// 
// see also https://docs.gtk.org/gio/enum.SocketClientEvent.html
//
type SocketClientEvent C.int

const (
	// SocketClientResolving wraps G_SOCKET_CLIENT_RESOLVING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#resolving
	//
	SocketClientResolving SocketClientEvent = 0
	// SocketClientResolved wraps G_SOCKET_CLIENT_RESOLVED
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#resolved
	//
	SocketClientResolved SocketClientEvent = 1
	// SocketClientConnecting wraps G_SOCKET_CLIENT_CONNECTING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#connecting
	//
	SocketClientConnecting SocketClientEvent = 2
	// SocketClientConnected wraps G_SOCKET_CLIENT_CONNECTED
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#connected
	//
	SocketClientConnected SocketClientEvent = 3
	// SocketClientProxyNegotiating wraps G_SOCKET_CLIENT_PROXY_NEGOTIATING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#proxy_negotiating
	//
	SocketClientProxyNegotiating SocketClientEvent = 4
	// SocketClientProxyNegotiated wraps G_SOCKET_CLIENT_PROXY_NEGOTIATED
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#proxy_negotiated
	//
	SocketClientProxyNegotiated SocketClientEvent = 5
	// SocketClientTlsHandshaking wraps G_SOCKET_CLIENT_TLS_HANDSHAKING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#tls_handshaking
	//
	SocketClientTlsHandshaking SocketClientEvent = 6
	// SocketClientTlsHandshaked wraps G_SOCKET_CLIENT_TLS_HANDSHAKED
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#tls_handshaked
	//
	SocketClientTlsHandshaked SocketClientEvent = 7
	// SocketClientComplete wraps G_SOCKET_CLIENT_COMPLETE
	// 
	// see also https://docs.gtk.org/gio/flags.SocketClientEvent.html#complete
	//
	SocketClientComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p unsafe.Pointer) (any, error) {
	return SocketClientEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketClientEvent(0)

func (e SocketClientEvent) GoValueType() gobject.Type {
	return TypeSocketClientEvent
}

func (e SocketClientEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketClientEvent) String() string {
	switch e {
		case SocketClientComplete: return "SocketClientComplete"
		case SocketClientConnected: return "SocketClientConnected"
		case SocketClientConnecting: return "SocketClientConnecting"
		case SocketClientProxyNegotiated: return "SocketClientProxyNegotiated"
		case SocketClientProxyNegotiating: return "SocketClientProxyNegotiating"
		case SocketClientResolved: return "SocketClientResolved"
		case SocketClientResolving: return "SocketClientResolving"
		case SocketClientTlsHandshaked: return "SocketClientTlsHandshaked"
		case SocketClientTlsHandshaking: return "SocketClientTlsHandshaking"
		default: return fmt.Sprintf("SocketClientEvent(%d)", e)
	}
}

// SocketFamily wraps GSocketFamily
// 
// see also https://docs.gtk.org/gio/enum.SocketFamily.html
//
type SocketFamily C.int

const (
	// SocketFamilyInvalid wraps G_SOCKET_FAMILY_INVALID
	// 
	// see also https://docs.gtk.org/gio/flags.SocketFamily.html#invalid
	//
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyIpv4 wraps G_SOCKET_FAMILY_IPV4
	// 
	// see also https://docs.gtk.org/gio/flags.SocketFamily.html#ipv4
	//
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6 wraps G_SOCKET_FAMILY_IPV6
	// 
	// see also https://docs.gtk.org/gio/flags.SocketFamily.html#ipv6
	//
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p unsafe.Pointer) (any, error) {
	return SocketFamily(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketFamily(0)

func (e SocketFamily) GoValueType() gobject.Type {
	return TypeSocketFamily
}

func (e SocketFamily) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketFamily) String() string {
	switch e {
		case SocketFamilyInvalid: return "SocketFamilyInvalid"
		case SocketFamilyIpv4: return "SocketFamilyIpv4"
		case SocketFamilyIpv6: return "SocketFamilyIpv6"
		default: return fmt.Sprintf("SocketFamily(%d)", e)
	}
}

// SocketListenerEvent wraps GSocketListenerEvent
// 
// see also https://docs.gtk.org/gio/enum.SocketListenerEvent.html
//
type SocketListenerEvent C.int

const (
	// SocketListenerBinding wraps G_SOCKET_LISTENER_BINDING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketListenerEvent.html#binding
	//
	SocketListenerBinding SocketListenerEvent = 0
	// SocketListenerBound wraps G_SOCKET_LISTENER_BOUND
	// 
	// see also https://docs.gtk.org/gio/flags.SocketListenerEvent.html#bound
	//
	SocketListenerBound SocketListenerEvent = 1
	// SocketListenerListening wraps G_SOCKET_LISTENER_LISTENING
	// 
	// see also https://docs.gtk.org/gio/flags.SocketListenerEvent.html#listening
	//
	SocketListenerListening SocketListenerEvent = 2
	// SocketListenerListened wraps G_SOCKET_LISTENER_LISTENED
	// 
	// see also https://docs.gtk.org/gio/flags.SocketListenerEvent.html#listened
	//
	SocketListenerListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p unsafe.Pointer) (any, error) {
	return SocketListenerEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketListenerEvent(0)

func (e SocketListenerEvent) GoValueType() gobject.Type {
	return TypeSocketListenerEvent
}

func (e SocketListenerEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketListenerEvent) String() string {
	switch e {
		case SocketListenerBinding: return "SocketListenerBinding"
		case SocketListenerBound: return "SocketListenerBound"
		case SocketListenerListened: return "SocketListenerListened"
		case SocketListenerListening: return "SocketListenerListening"
		default: return fmt.Sprintf("SocketListenerEvent(%d)", e)
	}
}

// SocketProtocol wraps GSocketProtocol
// 
// see also https://docs.gtk.org/gio/enum.SocketProtocol.html
//
type SocketProtocol C.int

const (
	// SocketProtocolUnknown wraps G_SOCKET_PROTOCOL_UNKNOWN
	// 
	// see also https://docs.gtk.org/gio/flags.SocketProtocol.html#unknown
	//
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault wraps G_SOCKET_PROTOCOL_DEFAULT
	// 
	// see also https://docs.gtk.org/gio/flags.SocketProtocol.html#default
	//
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp wraps G_SOCKET_PROTOCOL_TCP
	// 
	// see also https://docs.gtk.org/gio/flags.SocketProtocol.html#tcp
	//
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp wraps G_SOCKET_PROTOCOL_UDP
	// 
	// see also https://docs.gtk.org/gio/flags.SocketProtocol.html#udp
	//
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp wraps G_SOCKET_PROTOCOL_SCTP
	// 
	// see also https://docs.gtk.org/gio/flags.SocketProtocol.html#sctp
	//
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p unsafe.Pointer) (any, error) {
	return SocketProtocol(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketProtocol(0)

func (e SocketProtocol) GoValueType() gobject.Type {
	return TypeSocketProtocol
}

func (e SocketProtocol) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketProtocol) String() string {
	switch e {
		case SocketProtocolDefault: return "SocketProtocolDefault"
		case SocketProtocolSctp: return "SocketProtocolSctp"
		case SocketProtocolTcp: return "SocketProtocolTcp"
		case SocketProtocolUdp: return "SocketProtocolUdp"
		case SocketProtocolUnknown: return "SocketProtocolUnknown"
		default: return fmt.Sprintf("SocketProtocol(%d)", e)
	}
}

// SocketType wraps GSocketType
// 
// see also https://docs.gtk.org/gio/enum.SocketType.html
//
type SocketType C.int

const (
	// SocketTypeInvalid wraps G_SOCKET_TYPE_INVALID
	// 
	// see also https://docs.gtk.org/gio/flags.SocketType.html#invalid
	//
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream wraps G_SOCKET_TYPE_STREAM
	// 
	// see also https://docs.gtk.org/gio/flags.SocketType.html#stream
	//
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram wraps G_SOCKET_TYPE_DATAGRAM
	// 
	// see also https://docs.gtk.org/gio/flags.SocketType.html#datagram
	//
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket wraps G_SOCKET_TYPE_SEQPACKET
	// 
	// see also https://docs.gtk.org/gio/flags.SocketType.html#seqpacket
	//
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p unsafe.Pointer) (any, error) {
	return SocketType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketType(0)

func (e SocketType) GoValueType() gobject.Type {
	return TypeSocketType
}

func (e SocketType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketType) String() string {
	switch e {
		case SocketTypeDatagram: return "SocketTypeDatagram"
		case SocketTypeInvalid: return "SocketTypeInvalid"
		case SocketTypeSeqpacket: return "SocketTypeSeqpacket"
		case SocketTypeStream: return "SocketTypeStream"
		default: return fmt.Sprintf("SocketType(%d)", e)
	}
}

// TlsAuthenticationMode wraps GTlsAuthenticationMode
// 
// see also https://docs.gtk.org/gio/enum.TlsAuthenticationMode.html
//
type TlsAuthenticationMode C.int

const (
	// TlsAuthenticationNone wraps G_TLS_AUTHENTICATION_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsAuthenticationMode.html#none
	//
	TlsAuthenticationNone TlsAuthenticationMode = 0
	// TlsAuthenticationRequested wraps G_TLS_AUTHENTICATION_REQUESTED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsAuthenticationMode.html#requested
	//
	TlsAuthenticationRequested TlsAuthenticationMode = 1
	// TlsAuthenticationRequired wraps G_TLS_AUTHENTICATION_REQUIRED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsAuthenticationMode.html#required
	//
	TlsAuthenticationRequired TlsAuthenticationMode = 2
)

func marshalTlsAuthenticationMode(p unsafe.Pointer) (any, error) {
	return TlsAuthenticationMode(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsAuthenticationMode(0)

func (e TlsAuthenticationMode) GoValueType() gobject.Type {
	return TypeTlsAuthenticationMode
}

func (e TlsAuthenticationMode) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsAuthenticationMode) String() string {
	switch e {
		case TlsAuthenticationNone: return "TlsAuthenticationNone"
		case TlsAuthenticationRequested: return "TlsAuthenticationRequested"
		case TlsAuthenticationRequired: return "TlsAuthenticationRequired"
		default: return fmt.Sprintf("TlsAuthenticationMode(%d)", e)
	}
}

// TlsCertificateRequestFlags wraps GTlsCertificateRequestFlags
// 
// see also https://docs.gtk.org/gio/enum.TlsCertificateRequestFlags.html
//
type TlsCertificateRequestFlags C.int

const (
	// TlsCertificateRequestNone wraps G_TLS_CERTIFICATE_REQUEST_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateRequestFlags.html#none
	//
	TlsCertificateRequestNone TlsCertificateRequestFlags = 0
)

func marshalTlsCertificateRequestFlags(p unsafe.Pointer) (any, error) {
	return TlsCertificateRequestFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsCertificateRequestFlags(0)

func (e TlsCertificateRequestFlags) GoValueType() gobject.Type {
	return TypeTlsCertificateRequestFlags
}

func (e TlsCertificateRequestFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsCertificateRequestFlags) String() string {
	switch e {
		case TlsCertificateRequestNone: return "TlsCertificateRequestNone"
		default: return fmt.Sprintf("TlsCertificateRequestFlags(%d)", e)
	}
}

// TlsChannelBindingError wraps GTlsChannelBindingError
// 
// see also https://docs.gtk.org/gio/enum.TlsChannelBindingError.html
//
type TlsChannelBindingError C.int

const (
	// TlsChannelBindingErrorNotImplemented wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingError.html#not_implemented
	//
	TlsChannelBindingErrorNotImplemented TlsChannelBindingError = 0
	// TlsChannelBindingErrorInvalidState wraps G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingError.html#invalid_state
	//
	TlsChannelBindingErrorInvalidState TlsChannelBindingError = 1
	// TlsChannelBindingErrorNotAvailable wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingError.html#not_available
	//
	TlsChannelBindingErrorNotAvailable TlsChannelBindingError = 2
	// TlsChannelBindingErrorNotSupported wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingError.html#not_supported
	//
	TlsChannelBindingErrorNotSupported TlsChannelBindingError = 3
	// TlsChannelBindingErrorGeneralError wraps G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingError.html#general_error
	//
	TlsChannelBindingErrorGeneralError TlsChannelBindingError = 4
)

func marshalTlsChannelBindingError(p unsafe.Pointer) (any, error) {
	return TlsChannelBindingError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsChannelBindingError(0)

func (e TlsChannelBindingError) GoValueType() gobject.Type {
	return TypeTlsChannelBindingError
}

func (e TlsChannelBindingError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsChannelBindingError) String() string {
	switch e {
		case TlsChannelBindingErrorGeneralError: return "TlsChannelBindingErrorGeneralError"
		case TlsChannelBindingErrorInvalidState: return "TlsChannelBindingErrorInvalidState"
		case TlsChannelBindingErrorNotAvailable: return "TlsChannelBindingErrorNotAvailable"
		case TlsChannelBindingErrorNotImplemented: return "TlsChannelBindingErrorNotImplemented"
		case TlsChannelBindingErrorNotSupported: return "TlsChannelBindingErrorNotSupported"
		default: return fmt.Sprintf("TlsChannelBindingError(%d)", e)
	}
}

// TlsChannelBindingErrorQuark wraps g_tls_channel_binding_error_quark
// 
// see also https://docs.gtk.org/gio/func.g_tls_channel_binding_error_quark.html
//
func TlsChannelBindingErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_tls_channel_binding_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TlsChannelBindingType wraps GTlsChannelBindingType
// 
// see also https://docs.gtk.org/gio/enum.TlsChannelBindingType.html
//
type TlsChannelBindingType C.int

const (
	// TlsChannelBindingTlsUnique wraps G_TLS_CHANNEL_BINDING_TLS_UNIQUE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingType.html#unique
	//
	TlsChannelBindingTlsUnique TlsChannelBindingType = 0
	// TlsChannelBindingTlsServerEndPoint wraps G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingType.html#server_end_point
	//
	TlsChannelBindingTlsServerEndPoint TlsChannelBindingType = 1
	// TlsChannelBindingTlsExporter wraps G_TLS_CHANNEL_BINDING_TLS_EXPORTER
	// 
	// see also https://docs.gtk.org/gio/flags.TlsChannelBindingType.html#exporter
	//
	TlsChannelBindingTlsExporter TlsChannelBindingType = 2
)

func marshalTlsChannelBindingType(p unsafe.Pointer) (any, error) {
	return TlsChannelBindingType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsChannelBindingType(0)

func (e TlsChannelBindingType) GoValueType() gobject.Type {
	return TypeTlsChannelBindingType
}

func (e TlsChannelBindingType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsChannelBindingType) String() string {
	switch e {
		case TlsChannelBindingTlsExporter: return "TlsChannelBindingTlsExporter"
		case TlsChannelBindingTlsServerEndPoint: return "TlsChannelBindingTlsServerEndPoint"
		case TlsChannelBindingTlsUnique: return "TlsChannelBindingTlsUnique"
		default: return fmt.Sprintf("TlsChannelBindingType(%d)", e)
	}
}

// TlsDatabaseLookupFlags wraps GTlsDatabaseLookupFlags
// 
// see also https://docs.gtk.org/gio/enum.TlsDatabaseLookupFlags.html
//
type TlsDatabaseLookupFlags C.int

const (
	// TlsDatabaseLookupNone wraps G_TLS_DATABASE_LOOKUP_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsDatabaseLookupFlags.html#none
	//
	TlsDatabaseLookupNone TlsDatabaseLookupFlags = 0
	// TlsDatabaseLookupKeypair wraps G_TLS_DATABASE_LOOKUP_KEYPAIR
	// 
	// see also https://docs.gtk.org/gio/flags.TlsDatabaseLookupFlags.html#keypair
	//
	TlsDatabaseLookupKeypair TlsDatabaseLookupFlags = 1
)

func marshalTlsDatabaseLookupFlags(p unsafe.Pointer) (any, error) {
	return TlsDatabaseLookupFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsDatabaseLookupFlags(0)

func (e TlsDatabaseLookupFlags) GoValueType() gobject.Type {
	return TypeTlsDatabaseLookupFlags
}

func (e TlsDatabaseLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsDatabaseLookupFlags) String() string {
	switch e {
		case TlsDatabaseLookupKeypair: return "TlsDatabaseLookupKeypair"
		case TlsDatabaseLookupNone: return "TlsDatabaseLookupNone"
		default: return fmt.Sprintf("TlsDatabaseLookupFlags(%d)", e)
	}
}

// TlsError wraps GTlsError
// 
// see also https://docs.gtk.org/gio/enum.TlsError.html
//
type TlsError C.int

const (
	// TlsErrorUnavailable wraps G_TLS_ERROR_UNAVAILABLE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#unavailable
	//
	TlsErrorUnavailable TlsError = 0
	// TlsErrorMisc wraps G_TLS_ERROR_MISC
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#misc
	//
	TlsErrorMisc TlsError = 1
	// TlsErrorBadCertificate wraps G_TLS_ERROR_BAD_CERTIFICATE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#bad_certificate
	//
	TlsErrorBadCertificate TlsError = 2
	// TlsErrorNotTls wraps G_TLS_ERROR_NOT_TLS
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#not_tls
	//
	TlsErrorNotTls TlsError = 3
	// TlsErrorHandshake wraps G_TLS_ERROR_HANDSHAKE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#handshake
	//
	TlsErrorHandshake TlsError = 4
	// TlsErrorCertificateRequired wraps G_TLS_ERROR_CERTIFICATE_REQUIRED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#certificate_required
	//
	TlsErrorCertificateRequired TlsError = 5
	// TlsErrorEOF wraps G_TLS_ERROR_EOF
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#eof
	//
	TlsErrorEOF TlsError = 6
	// TlsErrorInappropriateFallback wraps G_TLS_ERROR_INAPPROPRIATE_FALLBACK
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#inappropriate_fallback
	//
	TlsErrorInappropriateFallback TlsError = 7
	// TlsErrorBadCertificatePassword wraps G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD
	// 
	// see also https://docs.gtk.org/gio/flags.TlsError.html#bad_certificate_password
	//
	TlsErrorBadCertificatePassword TlsError = 8
)

func marshalTlsError(p unsafe.Pointer) (any, error) {
	return TlsError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsError(0)

func (e TlsError) GoValueType() gobject.Type {
	return TypeTlsError
}

func (e TlsError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsError) String() string {
	switch e {
		case TlsErrorBadCertificate: return "TlsErrorBadCertificate"
		case TlsErrorBadCertificatePassword: return "TlsErrorBadCertificatePassword"
		case TlsErrorCertificateRequired: return "TlsErrorCertificateRequired"
		case TlsErrorEOF: return "TlsErrorEOF"
		case TlsErrorHandshake: return "TlsErrorHandshake"
		case TlsErrorInappropriateFallback: return "TlsErrorInappropriateFallback"
		case TlsErrorMisc: return "TlsErrorMisc"
		case TlsErrorNotTls: return "TlsErrorNotTls"
		case TlsErrorUnavailable: return "TlsErrorUnavailable"
		default: return fmt.Sprintf("TlsError(%d)", e)
	}
}

// TlsErrorQuark wraps g_tls_error_quark
// 
// see also https://docs.gtk.org/gio/func.g_tls_error_quark.html
//
func TlsErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_tls_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TlsInteractionResult wraps GTlsInteractionResult
// 
// see also https://docs.gtk.org/gio/enum.TlsInteractionResult.html
//
type TlsInteractionResult C.int

const (
	// TlsInteractionUnhandled wraps G_TLS_INTERACTION_UNHANDLED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsInteractionResult.html#unhandled
	//
	TlsInteractionUnhandled TlsInteractionResult = 0
	// TlsInteractionHandled wraps G_TLS_INTERACTION_HANDLED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsInteractionResult.html#handled
	//
	TlsInteractionHandled TlsInteractionResult = 1
	// TlsInteractionFailed wraps G_TLS_INTERACTION_FAILED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsInteractionResult.html#failed
	//
	TlsInteractionFailed TlsInteractionResult = 2
)

func marshalTlsInteractionResult(p unsafe.Pointer) (any, error) {
	return TlsInteractionResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsInteractionResult(0)

func (e TlsInteractionResult) GoValueType() gobject.Type {
	return TypeTlsInteractionResult
}

func (e TlsInteractionResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsInteractionResult) String() string {
	switch e {
		case TlsInteractionFailed: return "TlsInteractionFailed"
		case TlsInteractionHandled: return "TlsInteractionHandled"
		case TlsInteractionUnhandled: return "TlsInteractionUnhandled"
		default: return fmt.Sprintf("TlsInteractionResult(%d)", e)
	}
}

// TlsProtocolVersion wraps GTlsProtocolVersion
// 
// see also https://docs.gtk.org/gio/enum.TlsProtocolVersion.html
//
type TlsProtocolVersion C.int

const (
	// TlsProtocolVersionUnknown wraps G_TLS_PROTOCOL_VERSION_UNKNOWN
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#unknown
	//
	TlsProtocolVersionUnknown TlsProtocolVersion = 0
	// TlsProtocolVersionSsl30 wraps G_TLS_PROTOCOL_VERSION_SSL_3_0
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#ssl_3_0
	//
	TlsProtocolVersionSsl30 TlsProtocolVersion = 1
	// TlsProtocolVersionTls10 wraps G_TLS_PROTOCOL_VERSION_TLS_1_0
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#tls_1_0
	//
	TlsProtocolVersionTls10 TlsProtocolVersion = 2
	// TlsProtocolVersionTls11 wraps G_TLS_PROTOCOL_VERSION_TLS_1_1
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#tls_1_1
	//
	TlsProtocolVersionTls11 TlsProtocolVersion = 3
	// TlsProtocolVersionTls12 wraps G_TLS_PROTOCOL_VERSION_TLS_1_2
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#tls_1_2
	//
	TlsProtocolVersionTls12 TlsProtocolVersion = 4
	// TlsProtocolVersionTls13 wraps G_TLS_PROTOCOL_VERSION_TLS_1_3
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#tls_1_3
	//
	TlsProtocolVersionTls13 TlsProtocolVersion = 5
	// TlsProtocolVersionDtls10 wraps G_TLS_PROTOCOL_VERSION_DTLS_1_0
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#dtls_1_0
	//
	TlsProtocolVersionDtls10 TlsProtocolVersion = 201
	// TlsProtocolVersionDtls12 wraps G_TLS_PROTOCOL_VERSION_DTLS_1_2
	// 
	// see also https://docs.gtk.org/gio/flags.TlsProtocolVersion.html#dtls_1_2
	//
	TlsProtocolVersionDtls12 TlsProtocolVersion = 202
)

func marshalTlsProtocolVersion(p unsafe.Pointer) (any, error) {
	return TlsProtocolVersion(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsProtocolVersion(0)

func (e TlsProtocolVersion) GoValueType() gobject.Type {
	return TypeTlsProtocolVersion
}

func (e TlsProtocolVersion) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsProtocolVersion) String() string {
	switch e {
		case TlsProtocolVersionDtls10: return "TlsProtocolVersionDtls10"
		case TlsProtocolVersionDtls12: return "TlsProtocolVersionDtls12"
		case TlsProtocolVersionSsl30: return "TlsProtocolVersionSsl30"
		case TlsProtocolVersionTls10: return "TlsProtocolVersionTls10"
		case TlsProtocolVersionTls11: return "TlsProtocolVersionTls11"
		case TlsProtocolVersionTls12: return "TlsProtocolVersionTls12"
		case TlsProtocolVersionTls13: return "TlsProtocolVersionTls13"
		case TlsProtocolVersionUnknown: return "TlsProtocolVersionUnknown"
		default: return fmt.Sprintf("TlsProtocolVersion(%d)", e)
	}
}

// TlsRehandshakeMode wraps GTlsRehandshakeMode
// 
// see also https://docs.gtk.org/gio/enum.TlsRehandshakeMode.html
//
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
type TlsRehandshakeMode C.int

const (
	// TlsRehandshakeNever wraps G_TLS_REHANDSHAKE_NEVER
	// 
	// see also https://docs.gtk.org/gio/flags.TlsRehandshakeMode.html#never
	//
	TlsRehandshakeNever TlsRehandshakeMode = 0
	// TlsRehandshakeSafely wraps G_TLS_REHANDSHAKE_SAFELY
	// 
	// see also https://docs.gtk.org/gio/flags.TlsRehandshakeMode.html#safely
	//
	TlsRehandshakeSafely TlsRehandshakeMode = 1
	// TlsRehandshakeUnsafely wraps G_TLS_REHANDSHAKE_UNSAFELY
	// 
	// see also https://docs.gtk.org/gio/flags.TlsRehandshakeMode.html#unsafely
	//
	TlsRehandshakeUnsafely TlsRehandshakeMode = 2
)

func marshalTlsRehandshakeMode(p unsafe.Pointer) (any, error) {
	return TlsRehandshakeMode(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsRehandshakeMode(0)

func (e TlsRehandshakeMode) GoValueType() gobject.Type {
	return TypeTlsRehandshakeMode
}

func (e TlsRehandshakeMode) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsRehandshakeMode) String() string {
	switch e {
		case TlsRehandshakeNever: return "TlsRehandshakeNever"
		case TlsRehandshakeSafely: return "TlsRehandshakeSafely"
		case TlsRehandshakeUnsafely: return "TlsRehandshakeUnsafely"
		default: return fmt.Sprintf("TlsRehandshakeMode(%d)", e)
	}
}

// ZlibCompressorFormat wraps GZlibCompressorFormat
// 
// see also https://docs.gtk.org/gio/enum.ZlibCompressorFormat.html
//
type ZlibCompressorFormat C.int

const (
	// ZlibCompressorFormatZlib wraps G_ZLIB_COMPRESSOR_FORMAT_ZLIB
	// 
	// see also https://docs.gtk.org/gio/flags.ZlibCompressorFormat.html#zlib
	//
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip wraps G_ZLIB_COMPRESSOR_FORMAT_GZIP
	// 
	// see also https://docs.gtk.org/gio/flags.ZlibCompressorFormat.html#gzip
	//
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw wraps G_ZLIB_COMPRESSOR_FORMAT_RAW
	// 
	// see also https://docs.gtk.org/gio/flags.ZlibCompressorFormat.html#raw
	//
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p unsafe.Pointer) (any, error) {
	return ZlibCompressorFormat(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ZlibCompressorFormat(0)

func (e ZlibCompressorFormat) GoValueType() gobject.Type {
	return TypeZlibCompressorFormat
}

func (e ZlibCompressorFormat) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ZlibCompressorFormat) String() string {
	switch e {
		case ZlibCompressorFormatGzip: return "ZlibCompressorFormatGzip"
		case ZlibCompressorFormatRaw: return "ZlibCompressorFormatRaw"
		case ZlibCompressorFormatZlib: return "ZlibCompressorFormatZlib"
		default: return fmt.Sprintf("ZlibCompressorFormat(%d)", e)
	}
}

// AppInfoCreateFlags wraps GAppInfoCreateFlags
// 
// see also https://docs.gtk.org/gio/flags.AppInfoCreateFlags.html
//
type AppInfoCreateFlags C.gint

const (
	// AppInfoCreateNone wraps G_APP_INFO_CREATE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.AppInfoCreateFlags.html#none
	//
	AppInfoCreateNone AppInfoCreateFlags = 0
	// AppInfoCreateNeedsTerminal wraps G_APP_INFO_CREATE_NEEDS_TERMINAL
	// 
	// see also https://docs.gtk.org/gio/flags.AppInfoCreateFlags.html#needs_terminal
	//
	AppInfoCreateNeedsTerminal AppInfoCreateFlags = 1
	// AppInfoCreateSupportsUris wraps G_APP_INFO_CREATE_SUPPORTS_URIS
	// 
	// see also https://docs.gtk.org/gio/flags.AppInfoCreateFlags.html#supports_uris
	//
	AppInfoCreateSupportsUris AppInfoCreateFlags = 2
	// AppInfoCreateSupportsStartupNotification wraps G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION
	// 
	// see also https://docs.gtk.org/gio/flags.AppInfoCreateFlags.html#supports_startup_notification
	//
	AppInfoCreateSupportsStartupNotification AppInfoCreateFlags = 4
)

func marshalAppInfoCreateFlags(p unsafe.Pointer) (any, error) {
	return AppInfoCreateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a AppInfoCreateFlags) Has(other AppInfoCreateFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = AppInfoCreateFlags(0)

func (f AppInfoCreateFlags) GoValueType() gobject.Type {
	return TypeAppInfoCreateFlags
}

func (f AppInfoCreateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f AppInfoCreateFlags) String() string {
	if f == 0 {
		return "AppInfoCreateFlags(0)"
	}

	var parts []string
	if (f & AppInfoCreateNone) != 0 {
		parts = append(parts, "AppInfoCreateNone")
	}
	if (f & AppInfoCreateNeedsTerminal) != 0 {
		parts = append(parts, "AppInfoCreateNeedsTerminal")
	}
	if (f & AppInfoCreateSupportsUris) != 0 {
		parts = append(parts, "AppInfoCreateSupportsUris")
	}
	if (f & AppInfoCreateSupportsStartupNotification) != 0 {
		parts = append(parts, "AppInfoCreateSupportsStartupNotification")
	}
	return "AppInfoCreateFlags(" + strings.Join(parts, "|") + ")"
}

// ApplicationFlags wraps GApplicationFlags
// 
// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html
//
type ApplicationFlags C.gint

const (
	// ApplicationFlagsNone wraps G_APPLICATION_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#flags_none
	//
	//
	// Deprecated: (since 2.74.0) Use [flags@Gio.ApplicationFlags.DEFAULT_FLAGS].
	ApplicationFlagsNone ApplicationFlags = 0
	// ApplicationDefaultFlags wraps G_APPLICATION_DEFAULT_FLAGS
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#default_flags
	//
	ApplicationDefaultFlags ApplicationFlags = 0
	// ApplicationIsService wraps G_APPLICATION_IS_SERVICE
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#is_service
	//
	ApplicationIsService ApplicationFlags = 1
	// ApplicationIsLauncher wraps G_APPLICATION_IS_LAUNCHER
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#is_launcher
	//
	ApplicationIsLauncher ApplicationFlags = 2
	// ApplicationHandlesOpen wraps G_APPLICATION_HANDLES_OPEN
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#handles_open
	//
	ApplicationHandlesOpen ApplicationFlags = 4
	// ApplicationHandlesCommandLine wraps G_APPLICATION_HANDLES_COMMAND_LINE
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#handles_command_line
	//
	ApplicationHandlesCommandLine ApplicationFlags = 8
	// ApplicationSendEnvironment wraps G_APPLICATION_SEND_ENVIRONMENT
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#send_environment
	//
	ApplicationSendEnvironment ApplicationFlags = 16
	// ApplicationNonUnique wraps G_APPLICATION_NON_UNIQUE
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#non_unique
	//
	ApplicationNonUnique ApplicationFlags = 32
	// ApplicationCanOverrideAppID wraps G_APPLICATION_CAN_OVERRIDE_APP_ID
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#can_override_app_id
	//
	ApplicationCanOverrideAppID ApplicationFlags = 64
	// ApplicationAllowReplacement wraps G_APPLICATION_ALLOW_REPLACEMENT
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#allow_replacement
	//
	ApplicationAllowReplacement ApplicationFlags = 128
	// ApplicationReplace wraps G_APPLICATION_REPLACE
	// 
	// see also https://docs.gtk.org/gio/flags.ApplicationFlags.html#replace
	//
	ApplicationReplace ApplicationFlags = 256
)

func marshalApplicationFlags(p unsafe.Pointer) (any, error) {
	return ApplicationFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a ApplicationFlags) Has(other ApplicationFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = ApplicationFlags(0)

func (f ApplicationFlags) GoValueType() gobject.Type {
	return TypeApplicationFlags
}

func (f ApplicationFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ApplicationFlags) String() string {
	if f == 0 {
		return "ApplicationFlags(0)"
	}

	var parts []string
	if (f & ApplicationFlagsNone) != 0 {
		parts = append(parts, "ApplicationFlagsNone")
	}
	if (f & ApplicationDefaultFlags) != 0 {
		parts = append(parts, "ApplicationDefaultFlags")
	}
	if (f & ApplicationIsService) != 0 {
		parts = append(parts, "ApplicationIsService")
	}
	if (f & ApplicationIsLauncher) != 0 {
		parts = append(parts, "ApplicationIsLauncher")
	}
	if (f & ApplicationHandlesOpen) != 0 {
		parts = append(parts, "ApplicationHandlesOpen")
	}
	if (f & ApplicationHandlesCommandLine) != 0 {
		parts = append(parts, "ApplicationHandlesCommandLine")
	}
	if (f & ApplicationSendEnvironment) != 0 {
		parts = append(parts, "ApplicationSendEnvironment")
	}
	if (f & ApplicationNonUnique) != 0 {
		parts = append(parts, "ApplicationNonUnique")
	}
	if (f & ApplicationCanOverrideAppID) != 0 {
		parts = append(parts, "ApplicationCanOverrideAppID")
	}
	if (f & ApplicationAllowReplacement) != 0 {
		parts = append(parts, "ApplicationAllowReplacement")
	}
	if (f & ApplicationReplace) != 0 {
		parts = append(parts, "ApplicationReplace")
	}
	return "ApplicationFlags(" + strings.Join(parts, "|") + ")"
}

// AskPasswordFlags wraps GAskPasswordFlags
// 
// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html
//
type AskPasswordFlags C.gint

const (
	// AskPasswordNeedPassword wraps G_ASK_PASSWORD_NEED_PASSWORD
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#need_password
	//
	AskPasswordNeedPassword AskPasswordFlags = 1
	// AskPasswordNeedUsername wraps G_ASK_PASSWORD_NEED_USERNAME
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#need_username
	//
	AskPasswordNeedUsername AskPasswordFlags = 2
	// AskPasswordNeedDomain wraps G_ASK_PASSWORD_NEED_DOMAIN
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#need_domain
	//
	AskPasswordNeedDomain AskPasswordFlags = 4
	// AskPasswordSavingSupported wraps G_ASK_PASSWORD_SAVING_SUPPORTED
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#saving_supported
	//
	AskPasswordSavingSupported AskPasswordFlags = 8
	// AskPasswordAnonymousSupported wraps G_ASK_PASSWORD_ANONYMOUS_SUPPORTED
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#anonymous_supported
	//
	AskPasswordAnonymousSupported AskPasswordFlags = 16
	// AskPasswordTcrypt wraps G_ASK_PASSWORD_TCRYPT
	// 
	// see also https://docs.gtk.org/gio/flags.AskPasswordFlags.html#tcrypt
	//
	AskPasswordTcrypt AskPasswordFlags = 32
)

func marshalAskPasswordFlags(p unsafe.Pointer) (any, error) {
	return AskPasswordFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a AskPasswordFlags) Has(other AskPasswordFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = AskPasswordFlags(0)

func (f AskPasswordFlags) GoValueType() gobject.Type {
	return TypeAskPasswordFlags
}

func (f AskPasswordFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f AskPasswordFlags) String() string {
	if f == 0 {
		return "AskPasswordFlags(0)"
	}

	var parts []string
	if (f & AskPasswordNeedPassword) != 0 {
		parts = append(parts, "AskPasswordNeedPassword")
	}
	if (f & AskPasswordNeedUsername) != 0 {
		parts = append(parts, "AskPasswordNeedUsername")
	}
	if (f & AskPasswordNeedDomain) != 0 {
		parts = append(parts, "AskPasswordNeedDomain")
	}
	if (f & AskPasswordSavingSupported) != 0 {
		parts = append(parts, "AskPasswordSavingSupported")
	}
	if (f & AskPasswordAnonymousSupported) != 0 {
		parts = append(parts, "AskPasswordAnonymousSupported")
	}
	if (f & AskPasswordTcrypt) != 0 {
		parts = append(parts, "AskPasswordTcrypt")
	}
	return "AskPasswordFlags(" + strings.Join(parts, "|") + ")"
}

// BusNameOwnerFlags wraps GBusNameOwnerFlags
// 
// see also https://docs.gtk.org/gio/flags.BusNameOwnerFlags.html
//
type BusNameOwnerFlags C.gint

const (
	// BusNameOwnerFlagsNone wraps G_BUS_NAME_OWNER_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameOwnerFlags.html#none
	//
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0
	// BusNameOwnerFlagsAllowReplacement wraps G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameOwnerFlags.html#allow_replacement
	//
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 1
	// BusNameOwnerFlagsReplace wraps G_BUS_NAME_OWNER_FLAGS_REPLACE
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameOwnerFlags.html#replace
	//
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 2
	// BusNameOwnerFlagsDoNotQueue wraps G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameOwnerFlags.html#do_not_queue
	//
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 4
)

func marshalBusNameOwnerFlags(p unsafe.Pointer) (any, error) {
	return BusNameOwnerFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BusNameOwnerFlags) Has(other BusNameOwnerFlags) bool {
	return (b & other) == other
}

var _ gobject.GoValueInitializer = BusNameOwnerFlags(0)

func (f BusNameOwnerFlags) GoValueType() gobject.Type {
	return TypeBusNameOwnerFlags
}

func (f BusNameOwnerFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f BusNameOwnerFlags) String() string {
	if f == 0 {
		return "BusNameOwnerFlags(0)"
	}

	var parts []string
	if (f & BusNameOwnerFlagsNone) != 0 {
		parts = append(parts, "BusNameOwnerFlagsNone")
	}
	if (f & BusNameOwnerFlagsAllowReplacement) != 0 {
		parts = append(parts, "BusNameOwnerFlagsAllowReplacement")
	}
	if (f & BusNameOwnerFlagsReplace) != 0 {
		parts = append(parts, "BusNameOwnerFlagsReplace")
	}
	if (f & BusNameOwnerFlagsDoNotQueue) != 0 {
		parts = append(parts, "BusNameOwnerFlagsDoNotQueue")
	}
	return "BusNameOwnerFlags(" + strings.Join(parts, "|") + ")"
}

// BusNameWatcherFlags wraps GBusNameWatcherFlags
// 
// see also https://docs.gtk.org/gio/flags.BusNameWatcherFlags.html
//
type BusNameWatcherFlags C.gint

const (
	// BusNameWatcherFlagsNone wraps G_BUS_NAME_WATCHER_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameWatcherFlags.html#none
	//
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0
	// BusNameWatcherFlagsAutoStart wraps G_BUS_NAME_WATCHER_FLAGS_AUTO_START
	// 
	// see also https://docs.gtk.org/gio/flags.BusNameWatcherFlags.html#auto_start
	//
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 1
)

func marshalBusNameWatcherFlags(p unsafe.Pointer) (any, error) {
	return BusNameWatcherFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BusNameWatcherFlags) Has(other BusNameWatcherFlags) bool {
	return (b & other) == other
}

var _ gobject.GoValueInitializer = BusNameWatcherFlags(0)

func (f BusNameWatcherFlags) GoValueType() gobject.Type {
	return TypeBusNameWatcherFlags
}

func (f BusNameWatcherFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f BusNameWatcherFlags) String() string {
	if f == 0 {
		return "BusNameWatcherFlags(0)"
	}

	var parts []string
	if (f & BusNameWatcherFlagsNone) != 0 {
		parts = append(parts, "BusNameWatcherFlagsNone")
	}
	if (f & BusNameWatcherFlagsAutoStart) != 0 {
		parts = append(parts, "BusNameWatcherFlagsAutoStart")
	}
	return "BusNameWatcherFlags(" + strings.Join(parts, "|") + ")"
}

// ConverterFlags wraps GConverterFlags
// 
// see also https://docs.gtk.org/gio/flags.ConverterFlags.html
//
type ConverterFlags C.gint

const (
	// ConverterNoFlags wraps G_CONVERTER_NO_FLAGS
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterFlags.html#none
	//
	ConverterNoFlags ConverterFlags = 0
	// ConverterInputAtEnd wraps G_CONVERTER_INPUT_AT_END
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterFlags.html#input_at_end
	//
	ConverterInputAtEnd ConverterFlags = 1
	// ConverterFlush wraps G_CONVERTER_FLUSH
	// 
	// see also https://docs.gtk.org/gio/flags.ConverterFlags.html#flush
	//
	ConverterFlush ConverterFlags = 2
)

func marshalConverterFlags(p unsafe.Pointer) (any, error) {
	return ConverterFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if c contains other
func (c ConverterFlags) Has(other ConverterFlags) bool {
	return (c & other) == other
}

var _ gobject.GoValueInitializer = ConverterFlags(0)

func (f ConverterFlags) GoValueType() gobject.Type {
	return TypeConverterFlags
}

func (f ConverterFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ConverterFlags) String() string {
	if f == 0 {
		return "ConverterFlags(0)"
	}

	var parts []string
	if (f & ConverterNoFlags) != 0 {
		parts = append(parts, "ConverterNoFlags")
	}
	if (f & ConverterInputAtEnd) != 0 {
		parts = append(parts, "ConverterInputAtEnd")
	}
	if (f & ConverterFlush) != 0 {
		parts = append(parts, "ConverterFlush")
	}
	return "ConverterFlags(" + strings.Join(parts, "|") + ")"
}

// DriveStartFlags wraps GDriveStartFlags
// 
// see also https://docs.gtk.org/gio/flags.DriveStartFlags.html
//
type DriveStartFlags C.gint

const (
	// DriveStartNone wraps G_DRIVE_START_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.DriveStartFlags.html#none
	//
	DriveStartNone DriveStartFlags = 0
)

func marshalDriveStartFlags(p unsafe.Pointer) (any, error) {
	return DriveStartFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if d contains other
func (d DriveStartFlags) Has(other DriveStartFlags) bool {
	return (d & other) == other
}

var _ gobject.GoValueInitializer = DriveStartFlags(0)

func (f DriveStartFlags) GoValueType() gobject.Type {
	return TypeDriveStartFlags
}

func (f DriveStartFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f DriveStartFlags) String() string {
	if f == 0 {
		return "DriveStartFlags(0)"
	}

	var parts []string
	if (f & DriveStartNone) != 0 {
		parts = append(parts, "DriveStartNone")
	}
	return "DriveStartFlags(" + strings.Join(parts, "|") + ")"
}

// FileAttributeInfoFlags wraps GFileAttributeInfoFlags
// 
// see also https://docs.gtk.org/gio/flags.FileAttributeInfoFlags.html
//
type FileAttributeInfoFlags C.gint

const (
	// FileAttributeInfoNone wraps G_FILE_ATTRIBUTE_INFO_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeInfoFlags.html#none
	//
	FileAttributeInfoNone FileAttributeInfoFlags = 0
	// FileAttributeInfoCopyWithFile wraps G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeInfoFlags.html#copy_with_file
	//
	FileAttributeInfoCopyWithFile FileAttributeInfoFlags = 1
	// FileAttributeInfoCopyWhenMoved wraps G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED
	// 
	// see also https://docs.gtk.org/gio/flags.FileAttributeInfoFlags.html#copy_when_moved
	//
	FileAttributeInfoCopyWhenMoved FileAttributeInfoFlags = 2
)

func marshalFileAttributeInfoFlags(p unsafe.Pointer) (any, error) {
	return FileAttributeInfoFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileAttributeInfoFlags) Has(other FileAttributeInfoFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileAttributeInfoFlags(0)

func (f FileAttributeInfoFlags) GoValueType() gobject.Type {
	return TypeFileAttributeInfoFlags
}

func (f FileAttributeInfoFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileAttributeInfoFlags) String() string {
	if f == 0 {
		return "FileAttributeInfoFlags(0)"
	}

	var parts []string
	if (f & FileAttributeInfoNone) != 0 {
		parts = append(parts, "FileAttributeInfoNone")
	}
	if (f & FileAttributeInfoCopyWithFile) != 0 {
		parts = append(parts, "FileAttributeInfoCopyWithFile")
	}
	if (f & FileAttributeInfoCopyWhenMoved) != 0 {
		parts = append(parts, "FileAttributeInfoCopyWhenMoved")
	}
	return "FileAttributeInfoFlags(" + strings.Join(parts, "|") + ")"
}

// FileCopyFlags wraps GFileCopyFlags
// 
// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html
//
type FileCopyFlags C.gint

const (
	// FileCopyNone wraps G_FILE_COPY_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#none
	//
	FileCopyNone FileCopyFlags = 0
	// FileCopyOverwrite wraps G_FILE_COPY_OVERWRITE
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#overwrite
	//
	FileCopyOverwrite FileCopyFlags = 1
	// FileCopyBackup wraps G_FILE_COPY_BACKUP
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#backup
	//
	FileCopyBackup FileCopyFlags = 2
	// FileCopyNofollowSymlinks wraps G_FILE_COPY_NOFOLLOW_SYMLINKS
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#nofollow_symlinks
	//
	FileCopyNofollowSymlinks FileCopyFlags = 4
	// FileCopyAllMetadata wraps G_FILE_COPY_ALL_METADATA
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#all_metadata
	//
	FileCopyAllMetadata FileCopyFlags = 8
	// FileCopyNoFallbackForMove wraps G_FILE_COPY_NO_FALLBACK_FOR_MOVE
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#no_fallback_for_move
	//
	FileCopyNoFallbackForMove FileCopyFlags = 16
	// FileCopyTargetDefaultPerms wraps G_FILE_COPY_TARGET_DEFAULT_PERMS
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#target_default_perms
	//
	FileCopyTargetDefaultPerms FileCopyFlags = 32
	// FileCopyTargetDefaultModifiedTime wraps G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME
	// 
	// see also https://docs.gtk.org/gio/flags.FileCopyFlags.html#target_default_modified_time
	//
	FileCopyTargetDefaultModifiedTime FileCopyFlags = 64
)

func marshalFileCopyFlags(p unsafe.Pointer) (any, error) {
	return FileCopyFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileCopyFlags) Has(other FileCopyFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileCopyFlags(0)

func (f FileCopyFlags) GoValueType() gobject.Type {
	return TypeFileCopyFlags
}

func (f FileCopyFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileCopyFlags) String() string {
	if f == 0 {
		return "FileCopyFlags(0)"
	}

	var parts []string
	if (f & FileCopyNone) != 0 {
		parts = append(parts, "FileCopyNone")
	}
	if (f & FileCopyOverwrite) != 0 {
		parts = append(parts, "FileCopyOverwrite")
	}
	if (f & FileCopyBackup) != 0 {
		parts = append(parts, "FileCopyBackup")
	}
	if (f & FileCopyNofollowSymlinks) != 0 {
		parts = append(parts, "FileCopyNofollowSymlinks")
	}
	if (f & FileCopyAllMetadata) != 0 {
		parts = append(parts, "FileCopyAllMetadata")
	}
	if (f & FileCopyNoFallbackForMove) != 0 {
		parts = append(parts, "FileCopyNoFallbackForMove")
	}
	if (f & FileCopyTargetDefaultPerms) != 0 {
		parts = append(parts, "FileCopyTargetDefaultPerms")
	}
	if (f & FileCopyTargetDefaultModifiedTime) != 0 {
		parts = append(parts, "FileCopyTargetDefaultModifiedTime")
	}
	return "FileCopyFlags(" + strings.Join(parts, "|") + ")"
}

// FileCreateFlags wraps GFileCreateFlags
// 
// see also https://docs.gtk.org/gio/flags.FileCreateFlags.html
//
type FileCreateFlags C.gint

const (
	// FileCreateNone wraps G_FILE_CREATE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileCreateFlags.html#none
	//
	FileCreateNone FileCreateFlags = 0
	// FileCreatePrivate wraps G_FILE_CREATE_PRIVATE
	// 
	// see also https://docs.gtk.org/gio/flags.FileCreateFlags.html#private
	//
	FileCreatePrivate FileCreateFlags = 1
	// FileCreateReplaceDestination wraps G_FILE_CREATE_REPLACE_DESTINATION
	// 
	// see also https://docs.gtk.org/gio/flags.FileCreateFlags.html#replace_destination
	//
	FileCreateReplaceDestination FileCreateFlags = 2
)

func marshalFileCreateFlags(p unsafe.Pointer) (any, error) {
	return FileCreateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileCreateFlags) Has(other FileCreateFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileCreateFlags(0)

func (f FileCreateFlags) GoValueType() gobject.Type {
	return TypeFileCreateFlags
}

func (f FileCreateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileCreateFlags) String() string {
	if f == 0 {
		return "FileCreateFlags(0)"
	}

	var parts []string
	if (f & FileCreateNone) != 0 {
		parts = append(parts, "FileCreateNone")
	}
	if (f & FileCreatePrivate) != 0 {
		parts = append(parts, "FileCreatePrivate")
	}
	if (f & FileCreateReplaceDestination) != 0 {
		parts = append(parts, "FileCreateReplaceDestination")
	}
	return "FileCreateFlags(" + strings.Join(parts, "|") + ")"
}

// FileMeasureFlags wraps GFileMeasureFlags
// 
// see also https://docs.gtk.org/gio/flags.FileMeasureFlags.html
//
type FileMeasureFlags C.gint

const (
	// FileMeasureNone wraps G_FILE_MEASURE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileMeasureFlags.html#none
	//
	FileMeasureNone FileMeasureFlags = 0
	// FileMeasureReportAnyError wraps G_FILE_MEASURE_REPORT_ANY_ERROR
	// 
	// see also https://docs.gtk.org/gio/flags.FileMeasureFlags.html#report_any_error
	//
	FileMeasureReportAnyError FileMeasureFlags = 2
	// FileMeasureApparentSize wraps G_FILE_MEASURE_APPARENT_SIZE
	// 
	// see also https://docs.gtk.org/gio/flags.FileMeasureFlags.html#apparent_size
	//
	FileMeasureApparentSize FileMeasureFlags = 4
	// FileMeasureNoXdev wraps G_FILE_MEASURE_NO_XDEV
	// 
	// see also https://docs.gtk.org/gio/flags.FileMeasureFlags.html#no_xdev
	//
	FileMeasureNoXdev FileMeasureFlags = 8
)

func marshalFileMeasureFlags(p unsafe.Pointer) (any, error) {
	return FileMeasureFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileMeasureFlags) Has(other FileMeasureFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileMeasureFlags(0)

func (f FileMeasureFlags) GoValueType() gobject.Type {
	return TypeFileMeasureFlags
}

func (f FileMeasureFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileMeasureFlags) String() string {
	if f == 0 {
		return "FileMeasureFlags(0)"
	}

	var parts []string
	if (f & FileMeasureNone) != 0 {
		parts = append(parts, "FileMeasureNone")
	}
	if (f & FileMeasureReportAnyError) != 0 {
		parts = append(parts, "FileMeasureReportAnyError")
	}
	if (f & FileMeasureApparentSize) != 0 {
		parts = append(parts, "FileMeasureApparentSize")
	}
	if (f & FileMeasureNoXdev) != 0 {
		parts = append(parts, "FileMeasureNoXdev")
	}
	return "FileMeasureFlags(" + strings.Join(parts, "|") + ")"
}

// FileMonitorFlags wraps GFileMonitorFlags
// 
// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html
//
type FileMonitorFlags C.gint

const (
	// FileMonitorNone wraps G_FILE_MONITOR_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html#none
	//
	FileMonitorNone FileMonitorFlags = 0
	// FileMonitorWatchMounts wraps G_FILE_MONITOR_WATCH_MOUNTS
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html#watch_mounts
	//
	FileMonitorWatchMounts FileMonitorFlags = 1
	// FileMonitorSendMoved wraps G_FILE_MONITOR_SEND_MOVED
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html#send_moved
	//
	FileMonitorSendMoved FileMonitorFlags = 2
	// FileMonitorWatchHardLinks wraps G_FILE_MONITOR_WATCH_HARD_LINKS
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html#watch_hard_links
	//
	FileMonitorWatchHardLinks FileMonitorFlags = 4
	// FileMonitorWatchMoves wraps G_FILE_MONITOR_WATCH_MOVES
	// 
	// see also https://docs.gtk.org/gio/flags.FileMonitorFlags.html#watch_moves
	//
	FileMonitorWatchMoves FileMonitorFlags = 8
)

func marshalFileMonitorFlags(p unsafe.Pointer) (any, error) {
	return FileMonitorFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileMonitorFlags) Has(other FileMonitorFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileMonitorFlags(0)

func (f FileMonitorFlags) GoValueType() gobject.Type {
	return TypeFileMonitorFlags
}

func (f FileMonitorFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileMonitorFlags) String() string {
	if f == 0 {
		return "FileMonitorFlags(0)"
	}

	var parts []string
	if (f & FileMonitorNone) != 0 {
		parts = append(parts, "FileMonitorNone")
	}
	if (f & FileMonitorWatchMounts) != 0 {
		parts = append(parts, "FileMonitorWatchMounts")
	}
	if (f & FileMonitorSendMoved) != 0 {
		parts = append(parts, "FileMonitorSendMoved")
	}
	if (f & FileMonitorWatchHardLinks) != 0 {
		parts = append(parts, "FileMonitorWatchHardLinks")
	}
	if (f & FileMonitorWatchMoves) != 0 {
		parts = append(parts, "FileMonitorWatchMoves")
	}
	return "FileMonitorFlags(" + strings.Join(parts, "|") + ")"
}

// FileQueryInfoFlags wraps GFileQueryInfoFlags
// 
// see also https://docs.gtk.org/gio/flags.FileQueryInfoFlags.html
//
type FileQueryInfoFlags C.gint

const (
	// FileQueryInfoNone wraps G_FILE_QUERY_INFO_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.FileQueryInfoFlags.html#none
	//
	FileQueryInfoNone FileQueryInfoFlags = 0
	// FileQueryInfoNofollowSymlinks wraps G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
	// 
	// see also https://docs.gtk.org/gio/flags.FileQueryInfoFlags.html#nofollow_symlinks
	//
	FileQueryInfoNofollowSymlinks FileQueryInfoFlags = 1
)

func marshalFileQueryInfoFlags(p unsafe.Pointer) (any, error) {
	return FileQueryInfoFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileQueryInfoFlags) Has(other FileQueryInfoFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileQueryInfoFlags(0)

func (f FileQueryInfoFlags) GoValueType() gobject.Type {
	return TypeFileQueryInfoFlags
}

func (f FileQueryInfoFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileQueryInfoFlags) String() string {
	if f == 0 {
		return "FileQueryInfoFlags(0)"
	}

	var parts []string
	if (f & FileQueryInfoNone) != 0 {
		parts = append(parts, "FileQueryInfoNone")
	}
	if (f & FileQueryInfoNofollowSymlinks) != 0 {
		parts = append(parts, "FileQueryInfoNofollowSymlinks")
	}
	return "FileQueryInfoFlags(" + strings.Join(parts, "|") + ")"
}

// IOStreamSpliceFlags wraps GIOStreamSpliceFlags
// 
// see also https://docs.gtk.org/gio/flags.IOStreamSpliceFlags.html
//
type IOStreamSpliceFlags C.gint

const (
	// IOStreamSpliceNone wraps G_IO_STREAM_SPLICE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.IOStreamSpliceFlags.html#none
	//
	IOStreamSpliceNone IOStreamSpliceFlags = 0
	// IOStreamSpliceCloseStream1 wraps G_IO_STREAM_SPLICE_CLOSE_STREAM1
	// 
	// see also https://docs.gtk.org/gio/flags.IOStreamSpliceFlags.html#close_stream1
	//
	IOStreamSpliceCloseStream1 IOStreamSpliceFlags = 1
	// IOStreamSpliceCloseStream2 wraps G_IO_STREAM_SPLICE_CLOSE_STREAM2
	// 
	// see also https://docs.gtk.org/gio/flags.IOStreamSpliceFlags.html#close_stream2
	//
	IOStreamSpliceCloseStream2 IOStreamSpliceFlags = 2
	// IOStreamSpliceWaitForBoth wraps G_IO_STREAM_SPLICE_WAIT_FOR_BOTH
	// 
	// see also https://docs.gtk.org/gio/flags.IOStreamSpliceFlags.html#wait_for_both
	//
	IOStreamSpliceWaitForBoth IOStreamSpliceFlags = 4
)

func marshalIOStreamSpliceFlags(p unsafe.Pointer) (any, error) {
	return IOStreamSpliceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if i contains other
func (i IOStreamSpliceFlags) Has(other IOStreamSpliceFlags) bool {
	return (i & other) == other
}

var _ gobject.GoValueInitializer = IOStreamSpliceFlags(0)

func (f IOStreamSpliceFlags) GoValueType() gobject.Type {
	return TypeIOStreamSpliceFlags
}

func (f IOStreamSpliceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f IOStreamSpliceFlags) String() string {
	if f == 0 {
		return "IOStreamSpliceFlags(0)"
	}

	var parts []string
	if (f & IOStreamSpliceNone) != 0 {
		parts = append(parts, "IOStreamSpliceNone")
	}
	if (f & IOStreamSpliceCloseStream1) != 0 {
		parts = append(parts, "IOStreamSpliceCloseStream1")
	}
	if (f & IOStreamSpliceCloseStream2) != 0 {
		parts = append(parts, "IOStreamSpliceCloseStream2")
	}
	if (f & IOStreamSpliceWaitForBoth) != 0 {
		parts = append(parts, "IOStreamSpliceWaitForBoth")
	}
	return "IOStreamSpliceFlags(" + strings.Join(parts, "|") + ")"
}

// MountMountFlags wraps GMountMountFlags
// 
// see also https://docs.gtk.org/gio/flags.MountMountFlags.html
//
type MountMountFlags C.gint

const (
	// MountMountNone wraps G_MOUNT_MOUNT_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.MountMountFlags.html#none
	//
	MountMountNone MountMountFlags = 0
)

func marshalMountMountFlags(p unsafe.Pointer) (any, error) {
	return MountMountFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if m contains other
func (m MountMountFlags) Has(other MountMountFlags) bool {
	return (m & other) == other
}

var _ gobject.GoValueInitializer = MountMountFlags(0)

func (f MountMountFlags) GoValueType() gobject.Type {
	return TypeMountMountFlags
}

func (f MountMountFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f MountMountFlags) String() string {
	if f == 0 {
		return "MountMountFlags(0)"
	}

	var parts []string
	if (f & MountMountNone) != 0 {
		parts = append(parts, "MountMountNone")
	}
	return "MountMountFlags(" + strings.Join(parts, "|") + ")"
}

// MountUnmountFlags wraps GMountUnmountFlags
// 
// see also https://docs.gtk.org/gio/flags.MountUnmountFlags.html
//
type MountUnmountFlags C.gint

const (
	// MountUnmountNone wraps G_MOUNT_UNMOUNT_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.MountUnmountFlags.html#none
	//
	MountUnmountNone MountUnmountFlags = 0
	// MountUnmountForce wraps G_MOUNT_UNMOUNT_FORCE
	// 
	// see also https://docs.gtk.org/gio/flags.MountUnmountFlags.html#force
	//
	MountUnmountForce MountUnmountFlags = 1
)

func marshalMountUnmountFlags(p unsafe.Pointer) (any, error) {
	return MountUnmountFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if m contains other
func (m MountUnmountFlags) Has(other MountUnmountFlags) bool {
	return (m & other) == other
}

var _ gobject.GoValueInitializer = MountUnmountFlags(0)

func (f MountUnmountFlags) GoValueType() gobject.Type {
	return TypeMountUnmountFlags
}

func (f MountUnmountFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f MountUnmountFlags) String() string {
	if f == 0 {
		return "MountUnmountFlags(0)"
	}

	var parts []string
	if (f & MountUnmountNone) != 0 {
		parts = append(parts, "MountUnmountNone")
	}
	if (f & MountUnmountForce) != 0 {
		parts = append(parts, "MountUnmountForce")
	}
	return "MountUnmountFlags(" + strings.Join(parts, "|") + ")"
}

// OutputStreamSpliceFlags wraps GOutputStreamSpliceFlags
// 
// see also https://docs.gtk.org/gio/flags.OutputStreamSpliceFlags.html
//
type OutputStreamSpliceFlags C.gint

const (
	// OutputStreamSpliceNone wraps G_OUTPUT_STREAM_SPLICE_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.OutputStreamSpliceFlags.html#none
	//
	OutputStreamSpliceNone OutputStreamSpliceFlags = 0
	// OutputStreamSpliceCloseSource wraps G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE
	// 
	// see also https://docs.gtk.org/gio/flags.OutputStreamSpliceFlags.html#close_source
	//
	OutputStreamSpliceCloseSource OutputStreamSpliceFlags = 1
	// OutputStreamSpliceCloseTarget wraps G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET
	// 
	// see also https://docs.gtk.org/gio/flags.OutputStreamSpliceFlags.html#close_target
	//
	OutputStreamSpliceCloseTarget OutputStreamSpliceFlags = 2
)

func marshalOutputStreamSpliceFlags(p unsafe.Pointer) (any, error) {
	return OutputStreamSpliceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if o contains other
func (o OutputStreamSpliceFlags) Has(other OutputStreamSpliceFlags) bool {
	return (o & other) == other
}

var _ gobject.GoValueInitializer = OutputStreamSpliceFlags(0)

func (f OutputStreamSpliceFlags) GoValueType() gobject.Type {
	return TypeOutputStreamSpliceFlags
}

func (f OutputStreamSpliceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f OutputStreamSpliceFlags) String() string {
	if f == 0 {
		return "OutputStreamSpliceFlags(0)"
	}

	var parts []string
	if (f & OutputStreamSpliceNone) != 0 {
		parts = append(parts, "OutputStreamSpliceNone")
	}
	if (f & OutputStreamSpliceCloseSource) != 0 {
		parts = append(parts, "OutputStreamSpliceCloseSource")
	}
	if (f & OutputStreamSpliceCloseTarget) != 0 {
		parts = append(parts, "OutputStreamSpliceCloseTarget")
	}
	return "OutputStreamSpliceFlags(" + strings.Join(parts, "|") + ")"
}

// ResolverNameLookupFlags wraps GResolverNameLookupFlags
// 
// see also https://docs.gtk.org/gio/flags.ResolverNameLookupFlags.html
//
type ResolverNameLookupFlags C.gint

const (
	// ResolverNameLookupFlagsDefault wraps G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverNameLookupFlags.html#default
	//
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0
	// ResolverNameLookupFlagsIpv4Only wraps G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverNameLookupFlags.html#ipv4_only
	//
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 1
	// ResolverNameLookupFlagsIpv6Only wraps G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY
	// 
	// see also https://docs.gtk.org/gio/flags.ResolverNameLookupFlags.html#ipv6_only
	//
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 2
)

func marshalResolverNameLookupFlags(p unsafe.Pointer) (any, error) {
	return ResolverNameLookupFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResolverNameLookupFlags) Has(other ResolverNameLookupFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResolverNameLookupFlags(0)

func (f ResolverNameLookupFlags) GoValueType() gobject.Type {
	return TypeResolverNameLookupFlags
}

func (f ResolverNameLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResolverNameLookupFlags) String() string {
	if f == 0 {
		return "ResolverNameLookupFlags(0)"
	}

	var parts []string
	if (f & ResolverNameLookupFlagsDefault) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsDefault")
	}
	if (f & ResolverNameLookupFlagsIpv4Only) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsIpv4Only")
	}
	if (f & ResolverNameLookupFlagsIpv6Only) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsIpv6Only")
	}
	return "ResolverNameLookupFlags(" + strings.Join(parts, "|") + ")"
}

// ResourceFlags wraps GResourceFlags
// 
// see also https://docs.gtk.org/gio/flags.ResourceFlags.html
//
type ResourceFlags C.gint

const (
	// ResourceFlagsNone wraps G_RESOURCE_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.ResourceFlags.html#none
	//
	ResourceFlagsNone ResourceFlags = 0
	// ResourceFlagsCompressed wraps G_RESOURCE_FLAGS_COMPRESSED
	// 
	// see also https://docs.gtk.org/gio/flags.ResourceFlags.html#compressed
	//
	ResourceFlagsCompressed ResourceFlags = 1
)

func marshalResourceFlags(p unsafe.Pointer) (any, error) {
	return ResourceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResourceFlags) Has(other ResourceFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResourceFlags(0)

func (f ResourceFlags) GoValueType() gobject.Type {
	return TypeResourceFlags
}

func (f ResourceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResourceFlags) String() string {
	if f == 0 {
		return "ResourceFlags(0)"
	}

	var parts []string
	if (f & ResourceFlagsNone) != 0 {
		parts = append(parts, "ResourceFlagsNone")
	}
	if (f & ResourceFlagsCompressed) != 0 {
		parts = append(parts, "ResourceFlagsCompressed")
	}
	return "ResourceFlags(" + strings.Join(parts, "|") + ")"
}

// ResourceLookupFlags wraps GResourceLookupFlags
// 
// see also https://docs.gtk.org/gio/flags.ResourceLookupFlags.html
//
type ResourceLookupFlags C.gint

const (
	// ResourceLookupFlagsNone wraps G_RESOURCE_LOOKUP_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.ResourceLookupFlags.html#none
	//
	ResourceLookupFlagsNone ResourceLookupFlags = 0
)

func marshalResourceLookupFlags(p unsafe.Pointer) (any, error) {
	return ResourceLookupFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResourceLookupFlags) Has(other ResourceLookupFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResourceLookupFlags(0)

func (f ResourceLookupFlags) GoValueType() gobject.Type {
	return TypeResourceLookupFlags
}

func (f ResourceLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResourceLookupFlags) String() string {
	if f == 0 {
		return "ResourceLookupFlags(0)"
	}

	var parts []string
	if (f & ResourceLookupFlagsNone) != 0 {
		parts = append(parts, "ResourceLookupFlagsNone")
	}
	return "ResourceLookupFlags(" + strings.Join(parts, "|") + ")"
}

// SettingsBindFlags wraps GSettingsBindFlags
// 
// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html
//
type SettingsBindFlags C.gint

const (
	// SettingsBindDefault wraps G_SETTINGS_BIND_DEFAULT
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#default
	//
	SettingsBindDefault SettingsBindFlags = 0
	// SettingsBindGet wraps G_SETTINGS_BIND_GET
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#get
	//
	SettingsBindGet SettingsBindFlags = 1
	// SettingsBindSet wraps G_SETTINGS_BIND_SET
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#set
	//
	SettingsBindSet SettingsBindFlags = 2
	// SettingsBindNoSensitivity wraps G_SETTINGS_BIND_NO_SENSITIVITY
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#no_sensitivity
	//
	SettingsBindNoSensitivity SettingsBindFlags = 4
	// SettingsBindGetNoChanges wraps G_SETTINGS_BIND_GET_NO_CHANGES
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#get_no_changes
	//
	SettingsBindGetNoChanges SettingsBindFlags = 8
	// SettingsBindInvertBoolean wraps G_SETTINGS_BIND_INVERT_BOOLEAN
	// 
	// see also https://docs.gtk.org/gio/flags.SettingsBindFlags.html#invert_boolean
	//
	SettingsBindInvertBoolean SettingsBindFlags = 16
)

func marshalSettingsBindFlags(p unsafe.Pointer) (any, error) {
	return SettingsBindFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if s contains other
func (s SettingsBindFlags) Has(other SettingsBindFlags) bool {
	return (s & other) == other
}

var _ gobject.GoValueInitializer = SettingsBindFlags(0)

func (f SettingsBindFlags) GoValueType() gobject.Type {
	return TypeSettingsBindFlags
}

func (f SettingsBindFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f SettingsBindFlags) String() string {
	if f == 0 {
		return "SettingsBindFlags(0)"
	}

	var parts []string
	if (f & SettingsBindDefault) != 0 {
		parts = append(parts, "SettingsBindDefault")
	}
	if (f & SettingsBindGet) != 0 {
		parts = append(parts, "SettingsBindGet")
	}
	if (f & SettingsBindSet) != 0 {
		parts = append(parts, "SettingsBindSet")
	}
	if (f & SettingsBindNoSensitivity) != 0 {
		parts = append(parts, "SettingsBindNoSensitivity")
	}
	if (f & SettingsBindGetNoChanges) != 0 {
		parts = append(parts, "SettingsBindGetNoChanges")
	}
	if (f & SettingsBindInvertBoolean) != 0 {
		parts = append(parts, "SettingsBindInvertBoolean")
	}
	return "SettingsBindFlags(" + strings.Join(parts, "|") + ")"
}

// SocketMsgFlags wraps GSocketMsgFlags
// 
// see also https://docs.gtk.org/gio/flags.SocketMsgFlags.html
//
type SocketMsgFlags C.gint

const (
	// SocketMsgNone wraps G_SOCKET_MSG_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.SocketMsgFlags.html#none
	//
	SocketMsgNone SocketMsgFlags = 0
	// SocketMsgOob wraps G_SOCKET_MSG_OOB
	// 
	// see also https://docs.gtk.org/gio/flags.SocketMsgFlags.html#oob
	//
	SocketMsgOob SocketMsgFlags = 1
	// SocketMsgPeek wraps G_SOCKET_MSG_PEEK
	// 
	// see also https://docs.gtk.org/gio/flags.SocketMsgFlags.html#peek
	//
	SocketMsgPeek SocketMsgFlags = 2
	// SocketMsgDontroute wraps G_SOCKET_MSG_DONTROUTE
	// 
	// see also https://docs.gtk.org/gio/flags.SocketMsgFlags.html#dontroute
	//
	SocketMsgDontroute SocketMsgFlags = 4
)

func marshalSocketMsgFlags(p unsafe.Pointer) (any, error) {
	return SocketMsgFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if s contains other
func (s SocketMsgFlags) Has(other SocketMsgFlags) bool {
	return (s & other) == other
}

var _ gobject.GoValueInitializer = SocketMsgFlags(0)

func (f SocketMsgFlags) GoValueType() gobject.Type {
	return TypeSocketMsgFlags
}

func (f SocketMsgFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f SocketMsgFlags) String() string {
	if f == 0 {
		return "SocketMsgFlags(0)"
	}

	var parts []string
	if (f & SocketMsgNone) != 0 {
		parts = append(parts, "SocketMsgNone")
	}
	if (f & SocketMsgOob) != 0 {
		parts = append(parts, "SocketMsgOob")
	}
	if (f & SocketMsgPeek) != 0 {
		parts = append(parts, "SocketMsgPeek")
	}
	if (f & SocketMsgDontroute) != 0 {
		parts = append(parts, "SocketMsgDontroute")
	}
	return "SocketMsgFlags(" + strings.Join(parts, "|") + ")"
}

// TlsCertificateFlags wraps GTlsCertificateFlags
// 
// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html
//
type TlsCertificateFlags C.gint

const (
	// TlsCertificateNoFlags wraps G_TLS_CERTIFICATE_NO_FLAGS
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#no_flags
	//
	TlsCertificateNoFlags TlsCertificateFlags = 0
	// TlsCertificateUnknownCa wraps G_TLS_CERTIFICATE_UNKNOWN_CA
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#unknown_ca
	//
	TlsCertificateUnknownCa TlsCertificateFlags = 1
	// TlsCertificateBadIdentity wraps G_TLS_CERTIFICATE_BAD_IDENTITY
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#bad_identity
	//
	TlsCertificateBadIdentity TlsCertificateFlags = 2
	// TlsCertificateNotActivated wraps G_TLS_CERTIFICATE_NOT_ACTIVATED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#not_activated
	//
	TlsCertificateNotActivated TlsCertificateFlags = 4
	// TlsCertificateExpired wraps G_TLS_CERTIFICATE_EXPIRED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#expired
	//
	TlsCertificateExpired TlsCertificateFlags = 8
	// TlsCertificateRevoked wraps G_TLS_CERTIFICATE_REVOKED
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#revoked
	//
	TlsCertificateRevoked TlsCertificateFlags = 16
	// TlsCertificateInsecure wraps G_TLS_CERTIFICATE_INSECURE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#insecure
	//
	TlsCertificateInsecure TlsCertificateFlags = 32
	// TlsCertificateGenericError wraps G_TLS_CERTIFICATE_GENERIC_ERROR
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#generic_error
	//
	TlsCertificateGenericError TlsCertificateFlags = 64
	// TlsCertificateValidateAll wraps G_TLS_CERTIFICATE_VALIDATE_ALL
	// 
	// see also https://docs.gtk.org/gio/flags.TlsCertificateFlags.html#validate_all
	//
	TlsCertificateValidateAll TlsCertificateFlags = 127
)

func marshalTlsCertificateFlags(p unsafe.Pointer) (any, error) {
	return TlsCertificateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsCertificateFlags) Has(other TlsCertificateFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsCertificateFlags(0)

func (f TlsCertificateFlags) GoValueType() gobject.Type {
	return TypeTlsCertificateFlags
}

func (f TlsCertificateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsCertificateFlags) String() string {
	if f == 0 {
		return "TlsCertificateFlags(0)"
	}

	var parts []string
	if (f & TlsCertificateNoFlags) != 0 {
		parts = append(parts, "TlsCertificateNoFlags")
	}
	if (f & TlsCertificateUnknownCa) != 0 {
		parts = append(parts, "TlsCertificateUnknownCa")
	}
	if (f & TlsCertificateBadIdentity) != 0 {
		parts = append(parts, "TlsCertificateBadIdentity")
	}
	if (f & TlsCertificateNotActivated) != 0 {
		parts = append(parts, "TlsCertificateNotActivated")
	}
	if (f & TlsCertificateExpired) != 0 {
		parts = append(parts, "TlsCertificateExpired")
	}
	if (f & TlsCertificateRevoked) != 0 {
		parts = append(parts, "TlsCertificateRevoked")
	}
	if (f & TlsCertificateInsecure) != 0 {
		parts = append(parts, "TlsCertificateInsecure")
	}
	if (f & TlsCertificateGenericError) != 0 {
		parts = append(parts, "TlsCertificateGenericError")
	}
	if (f & TlsCertificateValidateAll) != 0 {
		parts = append(parts, "TlsCertificateValidateAll")
	}
	return "TlsCertificateFlags(" + strings.Join(parts, "|") + ")"
}

// TlsDatabaseVerifyFlags wraps GTlsDatabaseVerifyFlags
// 
// see also https://docs.gtk.org/gio/flags.TlsDatabaseVerifyFlags.html
//
type TlsDatabaseVerifyFlags C.gint

const (
	// TlsDatabaseVerifyNone wraps G_TLS_DATABASE_VERIFY_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsDatabaseVerifyFlags.html#none
	//
	TlsDatabaseVerifyNone TlsDatabaseVerifyFlags = 0
)

func marshalTlsDatabaseVerifyFlags(p unsafe.Pointer) (any, error) {
	return TlsDatabaseVerifyFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsDatabaseVerifyFlags) Has(other TlsDatabaseVerifyFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsDatabaseVerifyFlags(0)

func (f TlsDatabaseVerifyFlags) GoValueType() gobject.Type {
	return TypeTlsDatabaseVerifyFlags
}

func (f TlsDatabaseVerifyFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsDatabaseVerifyFlags) String() string {
	if f == 0 {
		return "TlsDatabaseVerifyFlags(0)"
	}

	var parts []string
	if (f & TlsDatabaseVerifyNone) != 0 {
		parts = append(parts, "TlsDatabaseVerifyNone")
	}
	return "TlsDatabaseVerifyFlags(" + strings.Join(parts, "|") + ")"
}

// TlsPasswordFlags wraps GTlsPasswordFlags
// 
// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html
//
type TlsPasswordFlags C.gint

const (
	// TlsPasswordNone wraps G_TLS_PASSWORD_NONE
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#none
	//
	TlsPasswordNone TlsPasswordFlags = 0
	// TlsPasswordRetry wraps G_TLS_PASSWORD_RETRY
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#retry
	//
	TlsPasswordRetry TlsPasswordFlags = 2
	// TlsPasswordManyTries wraps G_TLS_PASSWORD_MANY_TRIES
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#many_tries
	//
	TlsPasswordManyTries TlsPasswordFlags = 4
	// TlsPasswordFinalTry wraps G_TLS_PASSWORD_FINAL_TRY
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#final_try
	//
	TlsPasswordFinalTry TlsPasswordFlags = 8
	// TlsPasswordPkcs11User wraps G_TLS_PASSWORD_PKCS11_USER
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#pkcs11_user
	//
	TlsPasswordPkcs11User TlsPasswordFlags = 16
	// TlsPasswordPkcs11SecurityOfficer wraps G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#pkcs11_security_officer
	//
	TlsPasswordPkcs11SecurityOfficer TlsPasswordFlags = 32
	// TlsPasswordPkcs11ContextSpecific wraps G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC
	// 
	// see also https://docs.gtk.org/gio/flags.TlsPasswordFlags.html#pkcs11_context_specific
	//
	TlsPasswordPkcs11ContextSpecific TlsPasswordFlags = 64
)

func marshalTlsPasswordFlags(p unsafe.Pointer) (any, error) {
	return TlsPasswordFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsPasswordFlags) Has(other TlsPasswordFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsPasswordFlags(0)

func (f TlsPasswordFlags) GoValueType() gobject.Type {
	return TypeTlsPasswordFlags
}

func (f TlsPasswordFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsPasswordFlags) String() string {
	if f == 0 {
		return "TlsPasswordFlags(0)"
	}

	var parts []string
	if (f & TlsPasswordNone) != 0 {
		parts = append(parts, "TlsPasswordNone")
	}
	if (f & TlsPasswordRetry) != 0 {
		parts = append(parts, "TlsPasswordRetry")
	}
	if (f & TlsPasswordManyTries) != 0 {
		parts = append(parts, "TlsPasswordManyTries")
	}
	if (f & TlsPasswordFinalTry) != 0 {
		parts = append(parts, "TlsPasswordFinalTry")
	}
	if (f & TlsPasswordPkcs11User) != 0 {
		parts = append(parts, "TlsPasswordPkcs11User")
	}
	if (f & TlsPasswordPkcs11SecurityOfficer) != 0 {
		parts = append(parts, "TlsPasswordPkcs11SecurityOfficer")
	}
	if (f & TlsPasswordPkcs11ContextSpecific) != 0 {
		parts = append(parts, "TlsPasswordPkcs11ContextSpecific")
	}
	return "TlsPasswordFlags(" + strings.Join(parts, "|") + ")"
}

// AsyncReadyCallback wraps GAsyncReadyCallback
// 
// see also https://docs.gtk.org/gio/callback.AsyncReadyCallback.html
//
type AsyncReadyCallback func(sourceObject gobject.Object, res AsyncResult)

// VfsFileLookupFunc wraps GVfsFileLookupFunc
// 
// see also https://docs.gtk.org/gio/callback.VfsFileLookupFunc.html
//
type VfsFileLookupFunc func(vfs Vfs, identifier string) (goret File)

// BusGet wraps g_bus_get
// 
// see also https://docs.gtk.org/gio/func.g_bus_get.html
//
func BusGet(busType BusType, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 C.GBusType            // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = C.GBusType(busType)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_bus_get(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// BusUnownName wraps g_bus_unown_name
// 
// see also https://docs.gtk.org/gio/func.g_bus_unown_name.html
//
func BusUnownName(ownerId uint) {
	var carg1 C.guint // in, none, casted

	carg1 = C.guint(ownerId)

	C.g_bus_unown_name(carg1)
	runtime.KeepAlive(ownerId)
}

// BusUnwatchName wraps g_bus_unwatch_name
// 
// see also https://docs.gtk.org/gio/func.g_bus_unwatch_name.html
//
func BusUnwatchName(watcherId uint) {
	var carg1 C.guint // in, none, casted

	carg1 = C.guint(watcherId)

	C.g_bus_unwatch_name(carg1)
	runtime.KeepAlive(watcherId)
}

// ContentTypeCanBeExecutable wraps g_content_type_can_be_executable
// 
// see also https://docs.gtk.org/gio/func.g_content_type_can_be_executable.html
//
func ContentTypeCanBeExecutable(typ string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_can_be_executable(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeEquals wraps g_content_type_equals
// 
// see also https://docs.gtk.org/gio/func.g_content_type_equals.html
//
func ContentTypeEquals(type1 string, type2 string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(type1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(type2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_equals(carg1, carg2)
	runtime.KeepAlive(type1)
	runtime.KeepAlive(type2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeFromMimeType wraps g_content_type_from_mime_type
// 
// see also https://docs.gtk.org/gio/func.g_content_type_from_mime_type.html
//
func ContentTypeFromMimeType(mimeType string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_from_mime_type(carg1)
	runtime.KeepAlive(mimeType)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetDescription wraps g_content_type_get_description
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_description.html
//
func ContentTypeGetDescription(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_description(carg1)
	runtime.KeepAlive(typ)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGetGenericIconName wraps g_content_type_get_generic_icon_name
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_generic_icon_name.html
//
func ContentTypeGetGenericIconName(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_generic_icon_name(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetIcon wraps g_content_type_get_icon
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_icon.html
//
func ContentTypeGetIcon(typ string) Icon {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_icon(carg1)
	runtime.KeepAlive(typ)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGetMimeDirs wraps g_content_type_get_mime_dirs
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_mime_dirs.html
//
func ContentTypeGetMimeDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_content_type_get_mime_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// ContentTypeGetMimeType wraps g_content_type_get_mime_type
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_mime_type.html
//
func ContentTypeGetMimeType(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_mime_type(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetSymbolicIcon wraps g_content_type_get_symbolic_icon
// 
// see also https://docs.gtk.org/gio/func.g_content_type_get_symbolic_icon.html
//
func ContentTypeGetSymbolicIcon(typ string) Icon {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_symbolic_icon(carg1)
	runtime.KeepAlive(typ)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGuess wraps g_content_type_guess
// 
// see also https://docs.gtk.org/gio/func.g_content_type_guess.html
//
func ContentTypeGuess(filename string, data []byte) (bool, string) {
	var carg1 *C.gchar   // in, none, string, nullable-string
	var carg2 *C.guchar  // in, transfer: none, C Pointers: 1, Name: array[guchar], nullable, array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize    // implicit
	var carg4 C.gboolean // out
	var cret  *C.gchar   // return, full, string

	if filename != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = data
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_content_type_guess(carg1, carg2, carg3, &carg4)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(data)

	var resultUncertain bool
	var goret           string

	if carg4 != 0 {
		resultUncertain = true
	}
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return resultUncertain, goret
}

// ContentTypeGuessForTree wraps g_content_type_guess_for_tree
// 
// see also https://docs.gtk.org/gio/func.g_content_type_guess_for_tree.html
//
func ContentTypeGuessForTree(root File) []string {
	var carg1 *C.GFile  // in, none, converted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.GFile)(UnsafeFileToGlibNone(root))

	cret = C.g_content_type_guess_for_tree(carg1)
	runtime.KeepAlive(root)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ContentTypeIsA wraps g_content_type_is_a
// 
// see also https://docs.gtk.org/gio/func.g_content_type_is_a.html
//
func ContentTypeIsA(typ string, supertype string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(supertype)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_is_a(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeIsMimeType wraps g_content_type_is_mime_type
// 
// see also https://docs.gtk.org/gio/func.g_content_type_is_mime_type.html
//
func ContentTypeIsMimeType(typ string, mimeType string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_is_mime_type(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(mimeType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeIsUnknown wraps g_content_type_is_unknown
// 
// see also https://docs.gtk.org/gio/func.g_content_type_is_unknown.html
//
func ContentTypeIsUnknown(typ string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_is_unknown(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeSetMimeDirs wraps g_content_type_set_mime_dirs
// 
// see also https://docs.gtk.org/gio/func.g_content_type_set_mime_dirs.html
//
func ContentTypeSetMimeDirs(dirs []string) {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = dirs
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_content_type_set_mime_dirs(carg1)
	runtime.KeepAlive(dirs)
}

// ContentTypesGetRegistered wraps g_content_types_get_registered
// 
// see also https://docs.gtk.org/gio/func.g_content_types_get_registered.html
//
func ContentTypesGetRegistered() []string {
	var cret *C.GList // container, transfer: full

	cret = C.g_content_types_get_registered()

	var goret []string

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) string {
			var dst string // string
			dst = C.GoString((*C.char)(v))
			defer C.free(v)
			return dst
		},
	)

	return goret
}

// DBusAddressEscapeValue wraps g_dbus_address_escape_value
// 
// see also https://docs.gtk.org/gio/func.g_dbus_address_escape_value.html
//
func DBusAddressEscapeValue(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_address_escape_value(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusAddressGetForBusSync wraps g_dbus_address_get_for_bus_sync
// 
// see also https://docs.gtk.org/gio/func.g_dbus_address_get_for_bus_sync.html
//
func DBusAddressGetForBusSync(busType BusType, cancellable Cancellable) (string, error) {
	var carg1 C.GBusType      // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = C.GBusType(busType)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dbus_address_get_for_bus_sync(carg1, carg2, &_cerr)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DBusAddressGetStream wraps g_dbus_address_get_stream
// 
// see also https://docs.gtk.org/gio/func.g_dbus_address_get_stream.html
//
func DBusAddressGetStream(address string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dbus_address_get_stream(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// DBusAddressGetStreamFinish wraps g_dbus_address_get_stream_finish
// 
// see also https://docs.gtk.org/gio/func.g_dbus_address_get_stream_finish.html
//
func DBusAddressGetStreamFinish(res AsyncResult) (string, IOStream, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_dbus_address_get_stream_finish(carg1, &carg2, &_cerr)
	runtime.KeepAlive(res)

	var outGuid string
	var goret   IOStream
	var _goerr  error

	if carg2 != nil {
		outGuid = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outGuid, goret, _goerr
}

// DBusAddressGetStreamSync wraps g_dbus_address_get_stream_sync
// 
// see also https://docs.gtk.org/gio/func.g_dbus_address_get_stream_sync.html
//
func DBusAddressGetStreamSync(address string, cancellable Cancellable) (string, IOStream, error) {
	var carg1 *C.gchar        // in, none, string
	var carg3 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dbus_address_get_stream_sync(carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var outGuid string
	var goret   IOStream
	var _goerr  error

	if carg2 != nil {
		outGuid = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outGuid, goret, _goerr
}

// DBusEscapeObjectPath wraps g_dbus_escape_object_path
// 
// see also https://docs.gtk.org/gio/func.g_dbus_escape_object_path.html
//
func DBusEscapeObjectPath(s string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_escape_object_path(carg1)
	runtime.KeepAlive(s)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusEscapeObjectPathBytestring wraps g_dbus_escape_object_path_bytestring
// 
// see also https://docs.gtk.org/gio/func.g_dbus_escape_object_path_bytestring.html
//
func DBusEscapeObjectPathBytestring(bytes []uint8) string {
	var carg1 *C.guint8 // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	_ = bytes
	_ = carg1
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")

	cret = C.g_dbus_escape_object_path_bytestring(carg1)
	runtime.KeepAlive(bytes)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusGenerateGuid wraps g_dbus_generate_guid
// 
// see also https://docs.gtk.org/gio/func.g_dbus_generate_guid.html
//
func DBusGenerateGuid() string {
	var cret *C.gchar // return, full, string

	cret = C.g_dbus_generate_guid()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusIsAddress wraps g_dbus_is_address
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_address.html
//
func DBusIsAddress(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_address(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsErrorName wraps g_dbus_is_error_name
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_error_name.html
//
func DBusIsErrorName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_error_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsGuid wraps g_dbus_is_guid
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_guid.html
//
func DBusIsGuid(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_guid(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsInterfaceName wraps g_dbus_is_interface_name
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_interface_name.html
//
func DBusIsInterfaceName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_interface_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsMemberName wraps g_dbus_is_member_name
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_member_name.html
//
func DBusIsMemberName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_member_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsName wraps g_dbus_is_name
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_name.html
//
func DBusIsName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsSupportedAddress wraps g_dbus_is_supported_address
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_supported_address.html
//
func DBusIsSupportedAddress(str string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_supported_address(carg1, &_cerr)
	runtime.KeepAlive(str)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DBusIsUniqueName wraps g_dbus_is_unique_name
// 
// see also https://docs.gtk.org/gio/func.g_dbus_is_unique_name.html
//
func DBusIsUniqueName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_unique_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusUnescapeObjectPath wraps g_dbus_unescape_object_path
// 
// see also https://docs.gtk.org/gio/func.g_dbus_unescape_object_path.html
//
func DBusUnescapeObjectPath(s string) []uint8 {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.guint8 // return, transfer: none, C Pointers: 1, Name: array[guint8], scope: , nullable, array (inner guint8 (*typesystem.CastablePrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_unescape_object_path(carg1)
	runtime.KeepAlive(s)

	var goret []uint8

	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint8 (guint8*) because of unknown reason")

	return goret
}

// IOErrorFromErrno wraps g_io_error_from_errno
// 
// see also https://docs.gtk.org/gio/func.g_io_error_from_errno.html
//
func IOErrorFromErrno(errNo int32) IOErrorEnum {
	var carg1 C.gint         // in, none, casted
	var cret  C.GIOErrorEnum // return, none, casted

	carg1 = C.gint(errNo)

	cret = C.g_io_error_from_errno(carg1)
	runtime.KeepAlive(errNo)

	var goret IOErrorEnum

	goret = IOErrorEnum(cret)

	return goret
}

// IOErrorFromFileError wraps g_io_error_from_file_error
// 
// see also https://docs.gtk.org/gio/func.g_io_error_from_file_error.html
//
func IOErrorFromFileError(fileError glib.FileError) IOErrorEnum {
	var carg1 C.GFileError   // in, none, casted
	var cret  C.GIOErrorEnum // return, none, casted

	carg1 = C.GFileError(fileError)

	cret = C.g_io_error_from_file_error(carg1)
	runtime.KeepAlive(fileError)

	var goret IOErrorEnum

	goret = IOErrorEnum(cret)

	return goret
}

// IOErrorQuark wraps g_io_error_quark
// 
// see also https://docs.gtk.org/gio/func.g_io_error_quark.html
//
func IOErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_io_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// IOModulesScanAllInDirectory wraps g_io_modules_scan_all_in_directory
// 
// see also https://docs.gtk.org/gio/func.g_io_modules_scan_all_in_directory.html
//
func IOModulesScanAllInDirectory(dirname string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(dirname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_io_modules_scan_all_in_directory(carg1)
	runtime.KeepAlive(dirname)
}

// IOModulesScanAllInDirectoryWithScope wraps g_io_modules_scan_all_in_directory_with_scope
// 
// see also https://docs.gtk.org/gio/func.g_io_modules_scan_all_in_directory_with_scope.html
//
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var carg1 *C.gchar          // in, none, string
	var carg2 *C.GIOModuleScope // in, none, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dirname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GIOModuleScope)(UnsafeIOModuleScopeToGlibNone(scope))

	C.g_io_modules_scan_all_in_directory_with_scope(carg1, carg2)
	runtime.KeepAlive(dirname)
	runtime.KeepAlive(scope)
}

// IOSchedulerCancelAllJobs wraps g_io_scheduler_cancel_all_jobs
// 
// see also https://docs.gtk.org/gio/func.g_io_scheduler_cancel_all_jobs.html
//
//
// Deprecated: (since 2.36.0) You should never call this function, since you don't
// know how other libraries in your program might be making use of
// gioscheduler.
func IOSchedulerCancelAllJobs() {

	C.g_io_scheduler_cancel_all_jobs()
}

// PollableStreamRead wraps g_pollable_stream_read
// 
// see also https://docs.gtk.org/gio/func.g_pollable_stream_read.html
//
func PollableStreamRead(stream InputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 unsafe.Pointer  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 C.gboolean      // in
	var carg5 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_read(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PollableStreamWrite wraps g_pollable_stream_write
// 
// see also https://docs.gtk.org/gio/func.g_pollable_stream_write.html
//
func PollableStreamWrite(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var carg5 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_write(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PollableStreamWriteAll wraps g_pollable_stream_write_all
// 
// see also https://docs.gtk.org/gio/func.g_pollable_stream_write_all.html
//
func PollableStreamWriteAll(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (uint, bool, error) {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var carg6 *C.GCancellable  // in, none, converted, nullable
	var carg5 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_write_all(carg1, carg2, carg3, carg4, &carg5, carg6, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// ResourcesEnumerateChildren wraps g_resources_enumerate_children
// 
// see also https://docs.gtk.org/gio/func.g_resources_enumerate_children.html
//
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  **C.char               // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_enumerate_children(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResourcesGetInfo wraps g_resources_get_info
// 
// see also https://docs.gtk.org/gio/func.g_resources_get_info.html
//
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, bool, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var carg3 C.gsize                // out, full, casted
	var carg4 C.guint32              // out, full, casted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_get_info(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var size   uint
	var flags  uint32
	var goret  bool
	var _goerr error

	size = uint(carg3)
	flags = uint32(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return size, flags, goret, _goerr
}

// ResourcesLookupData wraps g_resources_lookup_data
// 
// see also https://docs.gtk.org/gio/func.g_resources_lookup_data.html
//
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  *C.GBytes              // return, full, converted
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_lookup_data(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResourcesOpenStream wraps g_resources_open_stream
// 
// see also https://docs.gtk.org/gio/func.g_resources_open_stream.html
//
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  *C.GInputStream        // return, full, converted
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_open_stream(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  InputStream
	var _goerr error

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ActionInstance is the instance type used by all types implementing GAction. It is used internally by the bindings. Users should use the interface [Action] instead.
type ActionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Action = (*ActionInstance)(nil)

// Action wraps GAction
// 
// see also https://docs.gtk.org/gio/interface.Action.html
//
type Action interface {
	upcastToGAction() *ActionInstance

	// GetEnabled wraps g_action_get_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_action_get_enabled.g_action_get_enabled.html
	//
	GetEnabled() bool
	// GetName wraps g_action_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_action_get_name.g_action_get_name.html
	//
	GetName() string
	// GetParameterType wraps g_action_get_parameter_type
	// 
	// see also https://docs.gtk.org/gio/method.g_action_get_parameter_type.g_action_get_parameter_type.html
	//
	GetParameterType() *glib.VariantType
	// GetStateType wraps g_action_get_state_type
	// 
	// see also https://docs.gtk.org/gio/method.g_action_get_state_type.g_action_get_state_type.html
	//
	GetStateType() *glib.VariantType
}

var _ Action = (*ActionInstance)(nil)

func unsafeWrapAction(base *gobject.ObjectInstance) *ActionInstance {
	return &ActionInstance{
		Instance: *base,
	}
}

func marshalActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionInstance) upcastToGAction() *ActionInstance {
	return a
}

// UnsafeActionFromGlibNone is used to convert raw GAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionFromGlibNone(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibNone(c).(Action)
}

// UnsafeActionFromGlibFull is used to convert raw GAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionFromGlibFull(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibFull(c).(Action)
}

// UnsafeActionFromGlibBorrow is used to convert raw GAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionFromGlibBorrow(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Action)
}

// UnsafeActionToGlibNone is used to convert the instance to it's C value GAction. This is used by the bindings internally.
func UnsafeActionToGlibNone(c Action) unsafe.Pointer {
	i := c.upcastToGAction()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionToGlibFull is used to convert the instance to it's C value GAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionToGlibFull(c Action) unsafe.Pointer {
	i := c.upcastToGAction()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ActionNameIsValid wraps g_action_name_is_valid
// 
// see also https://docs.gtk.org/gio/func.g_action_name_is_valid.html
//
func ActionNameIsValid(actionName string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_name_is_valid(carg1)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetEnabled wraps g_action_get_enabled
// 
// see also https://docs.gtk.org/gio/method.g_action_get_enabled.g_action_get_enabled.html
//
func (action *ActionInstance) GetEnabled() bool {
	var carg0 *C.GAction // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_enabled(carg0)
	runtime.KeepAlive(action)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetName wraps g_action_get_name
// 
// see also https://docs.gtk.org/gio/method.g_action_get_name.g_action_get_name.html
//
func (action *ActionInstance) GetName() string {
	var carg0 *C.GAction // in, none, converted
	var cret  *C.gchar   // return, none, string

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_name(carg0)
	runtime.KeepAlive(action)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetParameterType wraps g_action_get_parameter_type
// 
// see also https://docs.gtk.org/gio/method.g_action_get_parameter_type.g_action_get_parameter_type.html
//
func (action *ActionInstance) GetParameterType() *glib.VariantType {
	var carg0 *C.GAction      // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_parameter_type(carg0)
	runtime.KeepAlive(action)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetStateType wraps g_action_get_state_type
// 
// see also https://docs.gtk.org/gio/method.g_action_get_state_type.g_action_get_state_type.html
//
func (action *ActionInstance) GetStateType() *glib.VariantType {
	var carg0 *C.GAction      // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_state_type(carg0)
	runtime.KeepAlive(action)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ActionGroupInstance is the instance type used by all types implementing GActionGroup. It is used internally by the bindings. Users should use the interface [ActionGroup] instead.
type ActionGroupInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ActionGroup = (*ActionGroupInstance)(nil)

// ActionGroup wraps GActionGroup
// 
// see also https://docs.gtk.org/gio/interface.ActionGroup.html
//
type ActionGroup interface {
	upcastToGActionGroup() *ActionGroupInstance

	// ActionAdded wraps g_action_group_action_added
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_action_added.g_action_group_action_added.html
	//
	ActionAdded(string)
	// ActionEnabledChanged wraps g_action_group_action_enabled_changed
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_action_enabled_changed.g_action_group_action_enabled_changed.html
	//
	ActionEnabledChanged(string, bool)
	// ActionRemoved wraps g_action_group_action_removed
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_action_removed.g_action_group_action_removed.html
	//
	ActionRemoved(string)
	// GetActionEnabled wraps g_action_group_get_action_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_get_action_enabled.g_action_group_get_action_enabled.html
	//
	GetActionEnabled(string) bool
	// GetActionParameterType wraps g_action_group_get_action_parameter_type
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_get_action_parameter_type.g_action_group_get_action_parameter_type.html
	//
	GetActionParameterType(string) *glib.VariantType
	// GetActionStateType wraps g_action_group_get_action_state_type
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_get_action_state_type.g_action_group_get_action_state_type.html
	//
	GetActionStateType(string) *glib.VariantType
	// HasAction wraps g_action_group_has_action
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_has_action.g_action_group_has_action.html
	//
	HasAction(string) bool
	// ListActions wraps g_action_group_list_actions
	// 
	// see also https://docs.gtk.org/gio/method.g_action_group_list_actions.g_action_group_list_actions.html
	//
	ListActions() []string
	// ConnectActionAdded connects the provided callback to the "action-added" signal
	// 
	// see also https://docs.gtk.org/gio/signal.ActionGroup.action-added.html
	//
	ConnectActionAdded(func(ActionGroup, string)) gobject.SignalHandle
	// ConnectActionEnabledChanged connects the provided callback to the "action-enabled-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.ActionGroup.action-enabled-changed.html
	//
	ConnectActionEnabledChanged(func(ActionGroup, string, bool)) gobject.SignalHandle
	// ConnectActionRemoved connects the provided callback to the "action-removed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.ActionGroup.action-removed.html
	//
	ConnectActionRemoved(func(ActionGroup, string)) gobject.SignalHandle
}

var _ ActionGroup = (*ActionGroupInstance)(nil)

func unsafeWrapActionGroup(base *gobject.ObjectInstance) *ActionGroupInstance {
	return &ActionGroupInstance{
		Instance: *base,
	}
}

func marshalActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionGroupInstance) upcastToGActionGroup() *ActionGroupInstance {
	return a
}

// UnsafeActionGroupFromGlibNone is used to convert raw GActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionGroupFromGlibNone(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(ActionGroup)
}

// UnsafeActionGroupFromGlibFull is used to convert raw GActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionGroupFromGlibFull(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(ActionGroup)
}

// UnsafeActionGroupFromGlibBorrow is used to convert raw GActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionGroupFromGlibBorrow(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ActionGroup)
}

// UnsafeActionGroupToGlibNone is used to convert the instance to it's C value GActionGroup. This is used by the bindings internally.
func UnsafeActionGroupToGlibNone(c ActionGroup) unsafe.Pointer {
	i := c.upcastToGActionGroup()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionGroupToGlibFull is used to convert the instance to it's C value GActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionGroupToGlibFull(c ActionGroup) unsafe.Pointer {
	i := c.upcastToGActionGroup()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ActionAdded wraps g_action_group_action_added
// 
// see also https://docs.gtk.org/gio/method.g_action_group_action_added.g_action_group_action_added.html
//
func (actionGroup *ActionGroupInstance) ActionAdded(actionName string) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_group_action_added(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// ActionEnabledChanged wraps g_action_group_action_enabled_changed
// 
// see also https://docs.gtk.org/gio/method.g_action_group_action_enabled_changed.g_action_group_action_enabled_changed.html
//
func (actionGroup *ActionGroupInstance) ActionEnabledChanged(actionName string, enabled bool) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gboolean      // in

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))
	if enabled {
		carg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(carg0, carg1, carg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// ActionRemoved wraps g_action_group_action_removed
// 
// see also https://docs.gtk.org/gio/method.g_action_group_action_removed.g_action_group_action_removed.html
//
func (actionGroup *ActionGroupInstance) ActionRemoved(actionName string) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_group_action_removed(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// GetActionEnabled wraps g_action_group_get_action_enabled
// 
// see also https://docs.gtk.org/gio/method.g_action_group_get_action_enabled.g_action_group_get_action_enabled.html
//
func (actionGroup *ActionGroupInstance) GetActionEnabled(actionName string) bool {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_enabled(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetActionParameterType wraps g_action_group_get_action_parameter_type
// 
// see also https://docs.gtk.org/gio/method.g_action_group_get_action_parameter_type.g_action_group_get_action_parameter_type.html
//
func (actionGroup *ActionGroupInstance) GetActionParameterType(actionName string) *glib.VariantType {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_parameter_type(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetActionStateType wraps g_action_group_get_action_state_type
// 
// see also https://docs.gtk.org/gio/method.g_action_group_get_action_state_type.g_action_group_get_action_state_type.html
//
func (actionGroup *ActionGroupInstance) GetActionStateType(actionName string) *glib.VariantType {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_state_type(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// HasAction wraps g_action_group_has_action
// 
// see also https://docs.gtk.org/gio/method.g_action_group_has_action.g_action_group_has_action.html
//
func (actionGroup *ActionGroupInstance) HasAction(actionName string) bool {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_has_action(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListActions wraps g_action_group_list_actions
// 
// see also https://docs.gtk.org/gio/method.g_action_group_list_actions.g_action_group_list_actions.html
//
func (actionGroup *ActionGroupInstance) ListActions() []string {
	var carg0 *C.GActionGroup // in, none, converted
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))

	cret = C.g_action_group_list_actions(carg0)
	runtime.KeepAlive(actionGroup)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ConnectActionAdded connects the provided callback to the "action-added" signal
// 
// see also https://docs.gtk.org/gio/signal.ActionGroup.action-added.html
//
func (o *ActionGroupInstance) ConnectActionAdded(fn func(ActionGroup, string)) gobject.SignalHandle {
	return o.Instance.Connect("action-added", fn)
}

// ConnectActionEnabledChanged connects the provided callback to the "action-enabled-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.ActionGroup.action-enabled-changed.html
//
func (o *ActionGroupInstance) ConnectActionEnabledChanged(fn func(ActionGroup, string, bool)) gobject.SignalHandle {
	return o.Instance.Connect("action-enabled-changed", fn)
}

// ConnectActionRemoved connects the provided callback to the "action-removed" signal
// 
// see also https://docs.gtk.org/gio/signal.ActionGroup.action-removed.html
//
func (o *ActionGroupInstance) ConnectActionRemoved(fn func(ActionGroup, string)) gobject.SignalHandle {
	return o.Instance.Connect("action-removed", fn)
}

// ActionMapInstance is the instance type used by all types implementing GActionMap. It is used internally by the bindings. Users should use the interface [ActionMap] instead.
type ActionMapInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ActionMap = (*ActionMapInstance)(nil)

// ActionMap wraps GActionMap
// 
// see also https://docs.gtk.org/gio/interface.ActionMap.html
//
type ActionMap interface {
	upcastToGActionMap() *ActionMapInstance

	// AddAction wraps g_action_map_add_action
	// 
	// see also https://docs.gtk.org/gio/method.g_action_map_add_action.g_action_map_add_action.html
	//
	AddAction(Action)
	// LookupAction wraps g_action_map_lookup_action
	// 
	// see also https://docs.gtk.org/gio/method.g_action_map_lookup_action.g_action_map_lookup_action.html
	//
	LookupAction(string) Action
	// RemoveAction wraps g_action_map_remove_action
	// 
	// see also https://docs.gtk.org/gio/method.g_action_map_remove_action.g_action_map_remove_action.html
	//
	RemoveAction(string)
	// RemoveActionEntries wraps g_action_map_remove_action_entries
	// 
	// see also https://docs.gtk.org/gio/method.g_action_map_remove_action_entries.g_action_map_remove_action_entries.html
	//
	RemoveActionEntries([]ActionEntry)
}

var _ ActionMap = (*ActionMapInstance)(nil)

func unsafeWrapActionMap(base *gobject.ObjectInstance) *ActionMapInstance {
	return &ActionMapInstance{
		Instance: *base,
	}
}

func marshalActionMapInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionMapInstance) upcastToGActionMap() *ActionMapInstance {
	return a
}

// UnsafeActionMapFromGlibNone is used to convert raw GActionMap pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionMapFromGlibNone(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibNone(c).(ActionMap)
}

// UnsafeActionMapFromGlibFull is used to convert raw GActionMap pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionMapFromGlibFull(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibFull(c).(ActionMap)
}

// UnsafeActionMapFromGlibBorrow is used to convert raw GActionMap pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionMapFromGlibBorrow(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ActionMap)
}

// UnsafeActionMapToGlibNone is used to convert the instance to it's C value GActionMap. This is used by the bindings internally.
func UnsafeActionMapToGlibNone(c ActionMap) unsafe.Pointer {
	i := c.upcastToGActionMap()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionMapToGlibFull is used to convert the instance to it's C value GActionMap, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionMapToGlibFull(c ActionMap) unsafe.Pointer {
	i := c.upcastToGActionMap()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// AddAction wraps g_action_map_add_action
// 
// see also https://docs.gtk.org/gio/method.g_action_map_add_action.g_action_map_add_action.html
//
func (actionMap *ActionMapInstance) AddAction(action Action) {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.GAction    // in, none, converted

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.GAction)(UnsafeActionToGlibNone(action))

	C.g_action_map_add_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(action)
}

// LookupAction wraps g_action_map_lookup_action
// 
// see also https://docs.gtk.org/gio/method.g_action_map_lookup_action.g_action_map_lookup_action.html
//
func (actionMap *ActionMapInstance) LookupAction(actionName string) Action {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.GAction    // return, none, converted, nullable

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_map_lookup_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)

	var goret Action

	if cret != nil {
		goret = UnsafeActionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// RemoveAction wraps g_action_map_remove_action
// 
// see also https://docs.gtk.org/gio/method.g_action_map_remove_action.g_action_map_remove_action.html
//
func (actionMap *ActionMapInstance) RemoveAction(actionName string) {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.gchar      // in, none, string

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_map_remove_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)
}

// RemoveActionEntries wraps g_action_map_remove_action_entries
// 
// see also https://docs.gtk.org/gio/method.g_action_map_remove_action_entries.g_action_map_remove_action_entries.html
//
func (actionMap *ActionMapInstance) RemoveActionEntries(entries []ActionEntry) {
	var carg0 *C.GActionMap   // in, none, converted
	var carg1 *C.GActionEntry // in, transfer: none, C Pointers: 1, Name: array[ActionEntry], array (inner GActionEntry (*typesystem.Record), length-by: carg2)
	var carg2 C.gint          // implicit

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	_ = entries
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []ActionEntry (const GActionEntry*) because of unimplemented: non-fixed size array")

	C.g_action_map_remove_action_entries(carg0, carg1, carg2)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(entries)
}

// AppInfoInstance is the instance type used by all types implementing GAppInfo. It is used internally by the bindings. Users should use the interface [AppInfo] instead.
type AppInfoInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AppInfo = (*AppInfoInstance)(nil)

// AppInfo wraps GAppInfo
// 
// see also https://docs.gtk.org/gio/interface.AppInfo.html
//
type AppInfo interface {
	upcastToGAppInfo() *AppInfoInstance

	// AddSupportsType wraps g_app_info_add_supports_type
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_add_supports_type.g_app_info_add_supports_type.html
	//
	AddSupportsType(string) (bool, error)
	// CanDelete wraps g_app_info_can_delete
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_can_delete.g_app_info_can_delete.html
	//
	CanDelete() bool
	// CanRemoveSupportsType wraps g_app_info_can_remove_supports_type
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_can_remove_supports_type.g_app_info_can_remove_supports_type.html
	//
	CanRemoveSupportsType() bool
	// Delete wraps g_app_info_delete
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_delete.g_app_info_delete.html
	//
	Delete() bool
	// Dup wraps g_app_info_dup
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_dup.g_app_info_dup.html
	//
	Dup() AppInfo
	// Equal wraps g_app_info_equal
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_equal.g_app_info_equal.html
	//
	Equal(AppInfo) bool
	// GetCommandline wraps g_app_info_get_commandline
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_commandline.g_app_info_get_commandline.html
	//
	GetCommandline() string
	// GetDescription wraps g_app_info_get_description
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_description.g_app_info_get_description.html
	//
	GetDescription() string
	// GetDisplayName wraps g_app_info_get_display_name
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_display_name.g_app_info_get_display_name.html
	//
	GetDisplayName() string
	// GetExecutable wraps g_app_info_get_executable
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_executable.g_app_info_get_executable.html
	//
	GetExecutable() string
	// GetIcon wraps g_app_info_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_icon.g_app_info_get_icon.html
	//
	GetIcon() Icon
	// GetID wraps g_app_info_get_id
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_id.g_app_info_get_id.html
	//
	GetID() string
	// GetName wraps g_app_info_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_name.g_app_info_get_name.html
	//
	GetName() string
	// GetSupportedTypes wraps g_app_info_get_supported_types
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_get_supported_types.g_app_info_get_supported_types.html
	//
	GetSupportedTypes() []string
	// LaunchUrisFinish wraps g_app_info_launch_uris_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_launch_uris_finish.g_app_info_launch_uris_finish.html
	//
	LaunchUrisFinish(AsyncResult) (bool, error)
	// RemoveSupportsType wraps g_app_info_remove_supports_type
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_remove_supports_type.g_app_info_remove_supports_type.html
	//
	RemoveSupportsType(string) (bool, error)
	// SetAsDefaultForExtension wraps g_app_info_set_as_default_for_extension
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_set_as_default_for_extension.g_app_info_set_as_default_for_extension.html
	//
	SetAsDefaultForExtension(string) (bool, error)
	// SetAsDefaultForType wraps g_app_info_set_as_default_for_type
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_set_as_default_for_type.g_app_info_set_as_default_for_type.html
	//
	SetAsDefaultForType(string) (bool, error)
	// SetAsLastUsedForType wraps g_app_info_set_as_last_used_for_type
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_set_as_last_used_for_type.g_app_info_set_as_last_used_for_type.html
	//
	SetAsLastUsedForType(string) (bool, error)
	// ShouldShow wraps g_app_info_should_show
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_should_show.g_app_info_should_show.html
	//
	ShouldShow() bool
	// SupportsFiles wraps g_app_info_supports_files
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_supports_files.g_app_info_supports_files.html
	//
	SupportsFiles() bool
	// SupportsUris wraps g_app_info_supports_uris
	// 
	// see also https://docs.gtk.org/gio/method.g_app_info_supports_uris.g_app_info_supports_uris.html
	//
	SupportsUris() bool
}

var _ AppInfo = (*AppInfoInstance)(nil)

func unsafeWrapAppInfo(base *gobject.ObjectInstance) *AppInfoInstance {
	return &AppInfoInstance{
		Instance: *base,
	}
}

func marshalAppInfoInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AppInfoInstance) upcastToGAppInfo() *AppInfoInstance {
	return a
}

// UnsafeAppInfoFromGlibNone is used to convert raw GAppInfo pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoFromGlibNone(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibNone(c).(AppInfo)
}

// UnsafeAppInfoFromGlibFull is used to convert raw GAppInfo pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoFromGlibFull(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibFull(c).(AppInfo)
}

// UnsafeAppInfoFromGlibBorrow is used to convert raw GAppInfo pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppInfoFromGlibBorrow(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppInfo)
}

// UnsafeAppInfoToGlibNone is used to convert the instance to it's C value GAppInfo. This is used by the bindings internally.
func UnsafeAppInfoToGlibNone(c AppInfo) unsafe.Pointer {
	i := c.upcastToGAppInfo()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAppInfoToGlibFull is used to convert the instance to it's C value GAppInfo, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppInfoToGlibFull(c AppInfo) unsafe.Pointer {
	i := c.upcastToGAppInfo()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// AppInfoCreateFromCommandline wraps g_app_info_create_from_commandline
// 
// see also https://docs.gtk.org/gio/func.g_app_info_create_from_commandline.html
//
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) (AppInfo, error) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string, nullable-string
	var carg3 C.GAppInfoCreateFlags // in, none, casted
	var cret  *C.GAppInfo           // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(commandline)))
	defer C.free(unsafe.Pointer(carg1))
	if applicationName != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(applicationName)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = C.GAppInfoCreateFlags(flags)

	cret = C.g_app_info_create_from_commandline(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(commandline)
	runtime.KeepAlive(applicationName)
	runtime.KeepAlive(flags)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetAll wraps g_app_info_get_all
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_all.html
//
func AppInfoGetAll() []AppInfo {
	var cret *C.GList // container, transfer: full

	cret = C.g_app_info_get_all()

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetAllForType wraps g_app_info_get_all_for_type
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_all_for_type.html
//
func AppInfoGetAllForType(contentType string) []AppInfo {
	var carg1 *C.char  // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_all_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetDefaultForType wraps g_app_info_get_default_for_type
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_type.html
//
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfo {
	var carg1 *C.char     // in, none, string
	var carg2 C.gboolean  // in
	var cret  *C.GAppInfo // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))
	if mustSupportUris {
		carg2 = C.TRUE
	}

	cret = C.g_app_info_get_default_for_type(carg1, carg2)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)

	var goret AppInfo

	if cret != nil {
		goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// AppInfoGetDefaultForTypeAsync wraps g_app_info_get_default_for_type_async
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_type_async.html
//
func AppInfoGetDefaultForTypeAsync(contentType string, mustSupportUris bool, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 C.gboolean            // in
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))
	if mustSupportUris {
		carg2 = C.TRUE
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_get_default_for_type_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForTypeFinish wraps g_app_info_get_default_for_type_finish
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_type_finish.html
//
func AppInfoGetDefaultForTypeFinish(result AsyncResult) (AppInfo, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_get_default_for_type_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetDefaultForURIScheme wraps g_app_info_get_default_for_uri_scheme
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_uri_scheme.html
//
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfo {
	var carg1 *C.char     // in, none, string
	var cret  *C.GAppInfo // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_default_for_uri_scheme(carg1)
	runtime.KeepAlive(uriScheme)

	var goret AppInfo

	if cret != nil {
		goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// AppInfoGetDefaultForURISchemeAsync wraps g_app_info_get_default_for_uri_scheme_async
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_uri_scheme_async.html
//
func AppInfoGetDefaultForURISchemeAsync(uriScheme string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_get_default_for_uri_scheme_async(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForURISchemeFinish wraps g_app_info_get_default_for_uri_scheme_finish
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_default_for_uri_scheme_finish.html
//
func AppInfoGetDefaultForURISchemeFinish(result AsyncResult) (AppInfo, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_get_default_for_uri_scheme_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetFallbackForType wraps g_app_info_get_fallback_for_type
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_fallback_for_type.html
//
func AppInfoGetFallbackForType(contentType string) []AppInfo {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_fallback_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetRecommendedForType wraps g_app_info_get_recommended_for_type
// 
// see also https://docs.gtk.org/gio/func.g_app_info_get_recommended_for_type.html
//
func AppInfoGetRecommendedForType(contentType string) []AppInfo {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_recommended_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoLaunchDefaultForURI wraps g_app_info_launch_default_for_uri
// 
// see also https://docs.gtk.org/gio/func.g_app_info_launch_default_for_uri.html
//
func AppInfoLaunchDefaultForURI(uri string, _context AppLaunchContext) (bool, error) {
	var carg1 *C.char              // in, none, string
	var carg2 *C.GAppLaunchContext // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if _context != nil {
		carg2 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	}

	cret = C.g_app_info_launch_default_for_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(_context)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoLaunchDefaultForURIAsync wraps g_app_info_launch_default_for_uri_async
// 
// see also https://docs.gtk.org/gio/func.g_app_info_launch_default_for_uri_async.html
//
func AppInfoLaunchDefaultForURIAsync(uri string, _context AppLaunchContext, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.GAppLaunchContext  // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if _context != nil {
		carg2 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_launch_default_for_uri_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoLaunchDefaultForURIFinish wraps g_app_info_launch_default_for_uri_finish
// 
// see also https://docs.gtk.org/gio/func.g_app_info_launch_default_for_uri_finish.html
//
func AppInfoLaunchDefaultForURIFinish(result AsyncResult) (bool, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_launch_default_for_uri_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoResetTypeAssociations wraps g_app_info_reset_type_associations
// 
// see also https://docs.gtk.org/gio/func.g_app_info_reset_type_associations.html
//
func AppInfoResetTypeAssociations(contentType string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_info_reset_type_associations(carg1)
	runtime.KeepAlive(contentType)
}

// AddSupportsType wraps g_app_info_add_supports_type
// 
// see also https://docs.gtk.org/gio/method.g_app_info_add_supports_type.g_app_info_add_supports_type.html
//
func (appinfo *AppInfoInstance) AddSupportsType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_add_supports_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CanDelete wraps g_app_info_can_delete
// 
// see also https://docs.gtk.org/gio/method.g_app_info_can_delete.g_app_info_can_delete.html
//
func (appinfo *AppInfoInstance) CanDelete() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_can_delete(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanRemoveSupportsType wraps g_app_info_can_remove_supports_type
// 
// see also https://docs.gtk.org/gio/method.g_app_info_can_remove_supports_type.g_app_info_can_remove_supports_type.html
//
func (appinfo *AppInfoInstance) CanRemoveSupportsType() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_can_remove_supports_type(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Delete wraps g_app_info_delete
// 
// see also https://docs.gtk.org/gio/method.g_app_info_delete.g_app_info_delete.html
//
func (appinfo *AppInfoInstance) Delete() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_delete(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Dup wraps g_app_info_dup
// 
// see also https://docs.gtk.org/gio/method.g_app_info_dup.g_app_info_dup.html
//
func (appinfo *AppInfoInstance) Dup() AppInfo {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.GAppInfo // return, full, converted

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_dup(carg0)
	runtime.KeepAlive(appinfo)

	var goret AppInfo

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_app_info_equal
// 
// see also https://docs.gtk.org/gio/method.g_app_info_equal.g_app_info_equal.html
//
func (appinfo1 *AppInfoInstance) Equal(appinfo2 AppInfo) bool {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo1))
	carg1 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo2))

	cret = C.g_app_info_equal(carg0, carg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCommandline wraps g_app_info_get_commandline
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_commandline.g_app_info_get_commandline.html
//
func (appinfo *AppInfoInstance) GetCommandline() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_commandline(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDescription wraps g_app_info_get_description
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_description.g_app_info_get_description.html
//
func (appinfo *AppInfoInstance) GetDescription() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable-string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_description(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDisplayName wraps g_app_info_get_display_name
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_display_name.g_app_info_get_display_name.html
//
func (appinfo *AppInfoInstance) GetDisplayName() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_display_name(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetExecutable wraps g_app_info_get_executable
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_executable.g_app_info_get_executable.html
//
func (appinfo *AppInfoInstance) GetExecutable() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_executable(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetIcon wraps g_app_info_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_icon.g_app_info_get_icon.html
//
func (appinfo *AppInfoInstance) GetIcon() Icon {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.GIcon    // return, none, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_icon(carg0)
	runtime.KeepAlive(appinfo)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetID wraps g_app_info_get_id
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_id.g_app_info_get_id.html
//
func (appinfo *AppInfoInstance) GetID() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable-string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_id(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetName wraps g_app_info_get_name
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_name.g_app_info_get_name.html
//
func (appinfo *AppInfoInstance) GetName() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_name(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSupportedTypes wraps g_app_info_get_supported_types
// 
// see also https://docs.gtk.org/gio/method.g_app_info_get_supported_types.g_app_info_get_supported_types.html
//
func (appinfo *AppInfoInstance) GetSupportedTypes() []string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  **C.char    // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_supported_types(carg0)
	runtime.KeepAlive(appinfo)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const char**) because of unknown reason")

	return goret
}

// LaunchUrisFinish wraps g_app_info_launch_uris_finish
// 
// see also https://docs.gtk.org/gio/method.g_app_info_launch_uris_finish.g_app_info_launch_uris_finish.html
//
func (appinfo *AppInfoInstance) LaunchUrisFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GAppInfo     // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_launch_uris_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveSupportsType wraps g_app_info_remove_supports_type
// 
// see also https://docs.gtk.org/gio/method.g_app_info_remove_supports_type.g_app_info_remove_supports_type.html
//
func (appinfo *AppInfoInstance) RemoveSupportsType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_remove_supports_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsDefaultForExtension wraps g_app_info_set_as_default_for_extension
// 
// see also https://docs.gtk.org/gio/method.g_app_info_set_as_default_for_extension.g_app_info_set_as_default_for_extension.html
//
func (appinfo *AppInfoInstance) SetAsDefaultForExtension(extension string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_default_for_extension(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsDefaultForType wraps g_app_info_set_as_default_for_type
// 
// see also https://docs.gtk.org/gio/method.g_app_info_set_as_default_for_type.g_app_info_set_as_default_for_type.html
//
func (appinfo *AppInfoInstance) SetAsDefaultForType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_default_for_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsLastUsedForType wraps g_app_info_set_as_last_used_for_type
// 
// see also https://docs.gtk.org/gio/method.g_app_info_set_as_last_used_for_type.g_app_info_set_as_last_used_for_type.html
//
func (appinfo *AppInfoInstance) SetAsLastUsedForType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_last_used_for_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShouldShow wraps g_app_info_should_show
// 
// see also https://docs.gtk.org/gio/method.g_app_info_should_show.g_app_info_should_show.html
//
func (appinfo *AppInfoInstance) ShouldShow() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_should_show(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsFiles wraps g_app_info_supports_files
// 
// see also https://docs.gtk.org/gio/method.g_app_info_supports_files.g_app_info_supports_files.html
//
func (appinfo *AppInfoInstance) SupportsFiles() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_supports_files(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsUris wraps g_app_info_supports_uris
// 
// see also https://docs.gtk.org/gio/method.g_app_info_supports_uris.g_app_info_supports_uris.html
//
func (appinfo *AppInfoInstance) SupportsUris() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_supports_uris(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// AsyncInitableInstance is the instance type used by all types implementing GAsyncInitable. It is used internally by the bindings. Users should use the interface [AsyncInitable] instead.
type AsyncInitableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AsyncInitable = (*AsyncInitableInstance)(nil)

// AsyncInitable wraps GAsyncInitable
// 
// see also https://docs.gtk.org/gio/interface.AsyncInitable.html
//
type AsyncInitable interface {
	upcastToGAsyncInitable() *AsyncInitableInstance

	// InitAsync wraps g_async_initable_init_async
	// 
	// see also https://docs.gtk.org/gio/method.g_async_initable_init_async.g_async_initable_init_async.html
	//
	InitAsync(int32, Cancellable, AsyncReadyCallback)
	// InitFinish wraps g_async_initable_init_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_async_initable_init_finish.g_async_initable_init_finish.html
	//
	InitFinish(AsyncResult) (bool, error)
	// NewFinish wraps g_async_initable_new_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_async_initable_new_finish.g_async_initable_new_finish.html
	//
	NewFinish(AsyncResult) (gobject.Object, error)
}

var _ AsyncInitable = (*AsyncInitableInstance)(nil)

func unsafeWrapAsyncInitable(base *gobject.ObjectInstance) *AsyncInitableInstance {
	return &AsyncInitableInstance{
		Instance: *base,
	}
}

func marshalAsyncInitableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AsyncInitableInstance) upcastToGAsyncInitable() *AsyncInitableInstance {
	return a
}

// UnsafeAsyncInitableFromGlibNone is used to convert raw GAsyncInitable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibNone(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibNone(c).(AsyncInitable)
}

// UnsafeAsyncInitableFromGlibFull is used to convert raw GAsyncInitable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibFull(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibFull(c).(AsyncInitable)
}

// UnsafeAsyncInitableFromGlibBorrow is used to convert raw GAsyncInitable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibBorrow(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AsyncInitable)
}

// UnsafeAsyncInitableToGlibNone is used to convert the instance to it's C value GAsyncInitable. This is used by the bindings internally.
func UnsafeAsyncInitableToGlibNone(c AsyncInitable) unsafe.Pointer {
	i := c.upcastToGAsyncInitable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAsyncInitableToGlibFull is used to convert the instance to it's C value GAsyncInitable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableToGlibFull(c AsyncInitable) unsafe.Pointer {
	i := c.upcastToGAsyncInitable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// InitAsync wraps g_async_initable_init_async
// 
// see also https://docs.gtk.org/gio/method.g_async_initable_init_async.g_async_initable_init_async.html
//
func (initable *AsyncInitableInstance) InitAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GAsyncInitable     // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_async_initable_init_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// InitFinish wraps g_async_initable_init_finish
// 
// see also https://docs.gtk.org/gio/method.g_async_initable_init_finish.g_async_initable_init_finish.html
//
func (initable *AsyncInitableInstance) InitFinish(res AsyncResult) (bool, error) {
	var carg0 *C.GAsyncInitable // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_initable_init_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewFinish wraps g_async_initable_new_finish
// 
// see also https://docs.gtk.org/gio/method.g_async_initable_new_finish.g_async_initable_new_finish.html
//
func (initable *AsyncInitableInstance) NewFinish(res AsyncResult) (gobject.Object, error) {
	var carg0 *C.GAsyncInitable // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  *C.GObject        // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_initable_new_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var goret  gobject.Object
	var _goerr error

	goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AsyncResultInstance is the instance type used by all types implementing GAsyncResult. It is used internally by the bindings. Users should use the interface [AsyncResult] instead.
type AsyncResultInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AsyncResult = (*AsyncResultInstance)(nil)

// AsyncResult wraps GAsyncResult
// 
// see also https://docs.gtk.org/gio/interface.AsyncResult.html
//
type AsyncResult interface {
	upcastToGAsyncResult() *AsyncResultInstance

	// GetSourceObject wraps g_async_result_get_source_object
	// 
	// see also https://docs.gtk.org/gio/method.g_async_result_get_source_object.g_async_result_get_source_object.html
	//
	GetSourceObject() gobject.Object
	// LegacyPropagateError wraps g_async_result_legacy_propagate_error
	// 
	// see also https://docs.gtk.org/gio/method.g_async_result_legacy_propagate_error.g_async_result_legacy_propagate_error.html
	//
	LegacyPropagateError() (bool, error)
}

var _ AsyncResult = (*AsyncResultInstance)(nil)

func unsafeWrapAsyncResult(base *gobject.ObjectInstance) *AsyncResultInstance {
	return &AsyncResultInstance{
		Instance: *base,
	}
}

func marshalAsyncResultInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AsyncResultInstance) upcastToGAsyncResult() *AsyncResultInstance {
	return a
}

// UnsafeAsyncResultFromGlibNone is used to convert raw GAsyncResult pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibNone(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibNone(c).(AsyncResult)
}

// UnsafeAsyncResultFromGlibFull is used to convert raw GAsyncResult pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibFull(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibFull(c).(AsyncResult)
}

// UnsafeAsyncResultFromGlibBorrow is used to convert raw GAsyncResult pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibBorrow(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AsyncResult)
}

// UnsafeAsyncResultToGlibNone is used to convert the instance to it's C value GAsyncResult. This is used by the bindings internally.
func UnsafeAsyncResultToGlibNone(c AsyncResult) unsafe.Pointer {
	i := c.upcastToGAsyncResult()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAsyncResultToGlibFull is used to convert the instance to it's C value GAsyncResult, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAsyncResultToGlibFull(c AsyncResult) unsafe.Pointer {
	i := c.upcastToGAsyncResult()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetSourceObject wraps g_async_result_get_source_object
// 
// see also https://docs.gtk.org/gio/method.g_async_result_get_source_object.g_async_result_get_source_object.html
//
func (res *AsyncResultInstance) GetSourceObject() gobject.Object {
	var carg0 *C.GAsyncResult // in, none, converted
	var cret  *C.GObject      // return, full, converted, nullable

	carg0 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_result_get_source_object(carg0)
	runtime.KeepAlive(res)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// LegacyPropagateError wraps g_async_result_legacy_propagate_error
// 
// see also https://docs.gtk.org/gio/method.g_async_result_legacy_propagate_error.g_async_result_legacy_propagate_error.html
//
func (res *AsyncResultInstance) LegacyPropagateError() (bool, error) {
	var carg0 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_result_legacy_propagate_error(carg0, &_cerr)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConverterInstance is the instance type used by all types implementing GConverter. It is used internally by the bindings. Users should use the interface [Converter] instead.
type ConverterInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Converter = (*ConverterInstance)(nil)

// Converter wraps GConverter
// 
// see also https://docs.gtk.org/gio/interface.Converter.html
//
type Converter interface {
	upcastToGConverter() *ConverterInstance

	// Convert wraps g_converter_convert
	// 
	// see also https://docs.gtk.org/gio/method.g_converter_convert.g_converter_convert.html
	//
	Convert([]byte, []byte, ConverterFlags) (uint, uint, ConverterResult, error)
	// ConvertBytes wraps g_converter_convert_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_converter_convert_bytes.g_converter_convert_bytes.html
	//
	ConvertBytes(*glib.Bytes) (*glib.Bytes, error)
	// Reset wraps g_converter_reset
	// 
	// see also https://docs.gtk.org/gio/method.g_converter_reset.g_converter_reset.html
	//
	Reset()
}

var _ Converter = (*ConverterInstance)(nil)

func unsafeWrapConverter(base *gobject.ObjectInstance) *ConverterInstance {
	return &ConverterInstance{
		Instance: *base,
	}
}

func marshalConverterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (c *ConverterInstance) upcastToGConverter() *ConverterInstance {
	return c
}

// UnsafeConverterFromGlibNone is used to convert raw GConverter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterFromGlibNone(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibNone(c).(Converter)
}

// UnsafeConverterFromGlibFull is used to convert raw GConverter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterFromGlibFull(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibFull(c).(Converter)
}

// UnsafeConverterFromGlibBorrow is used to convert raw GConverter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterFromGlibBorrow(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Converter)
}

// UnsafeConverterToGlibNone is used to convert the instance to it's C value GConverter. This is used by the bindings internally.
func UnsafeConverterToGlibNone(c Converter) unsafe.Pointer {
	i := c.upcastToGConverter()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeConverterToGlibFull is used to convert the instance to it's C value GConverter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterToGlibFull(c Converter) unsafe.Pointer {
	i := c.upcastToGConverter()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Convert wraps g_converter_convert
// 
// see also https://docs.gtk.org/gio/method.g_converter_convert.g_converter_convert.html
//
func (converter *ConverterInstance) Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (uint, uint, ConverterResult, error) {
	var carg0 *C.GConverter      // in, none, converted
	var carg1 unsafe.Pointer     // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 unsafe.Pointer     // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg4)
	var carg4 C.gsize            // implicit
	var carg5 C.GConverterFlags  // in, none, casted
	var carg6 C.gsize            // out, full, casted
	var carg7 C.gsize            // out, full, casted
	var cret  C.GConverterResult // return, none, casted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))
	_ = inbuf
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	_ = outbuf
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg5 = C.GConverterFlags(flags)

	cret = C.g_converter_convert(carg0, carg1, carg2, carg3, carg4, carg5, &carg6, &carg7, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(flags)

	var bytesRead    uint
	var bytesWritten uint
	var goret        ConverterResult
	var _goerr       error

	bytesRead = uint(carg6)
	bytesWritten = uint(carg7)
	goret = ConverterResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// ConvertBytes wraps g_converter_convert_bytes
// 
// see also https://docs.gtk.org/gio/method.g_converter_convert_bytes.g_converter_convert_bytes.html
//
func (converter *ConverterInstance) ConvertBytes(bytes *glib.Bytes) (*glib.Bytes, error) {
	var carg0 *C.GConverter // in, none, converted
	var carg1 *C.GBytes     // in, none, converted
	var cret  *C.GBytes     // return, full, converted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_converter_convert_bytes(carg0, carg1, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(bytes)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Reset wraps g_converter_reset
// 
// see also https://docs.gtk.org/gio/method.g_converter_reset.g_converter_reset.html
//
func (converter *ConverterInstance) Reset() {
	var carg0 *C.GConverter // in, none, converted

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	C.g_converter_reset(carg0)
	runtime.KeepAlive(converter)
}

// DatagramBasedInstance is the instance type used by all types implementing GDatagramBased. It is used internally by the bindings. Users should use the interface [DatagramBased] instead.
type DatagramBasedInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DatagramBased = (*DatagramBasedInstance)(nil)

// DatagramBased wraps GDatagramBased
// 
// see also https://docs.gtk.org/gio/interface.DatagramBased.html
//
type DatagramBased interface {
	upcastToGDatagramBased() *DatagramBasedInstance

	// ConditionCheck wraps g_datagram_based_condition_check
	// 
	// see also https://docs.gtk.org/gio/method.g_datagram_based_condition_check.g_datagram_based_condition_check.html
	//
	ConditionCheck(glib.IOCondition) glib.IOCondition
	// ConditionWait wraps g_datagram_based_condition_wait
	// 
	// see also https://docs.gtk.org/gio/method.g_datagram_based_condition_wait.g_datagram_based_condition_wait.html
	//
	ConditionWait(glib.IOCondition, int64, Cancellable) (bool, error)
	// ReceiveMessages wraps g_datagram_based_receive_messages
	// 
	// see also https://docs.gtk.org/gio/method.g_datagram_based_receive_messages.g_datagram_based_receive_messages.html
	//
	ReceiveMessages([]InputMessage, int32, int64, Cancellable) (int32, error)
	// SendMessages wraps g_datagram_based_send_messages
	// 
	// see also https://docs.gtk.org/gio/method.g_datagram_based_send_messages.g_datagram_based_send_messages.html
	//
	SendMessages([]OutputMessage, int32, int64, Cancellable) (int32, error)
}

var _ DatagramBased = (*DatagramBasedInstance)(nil)

func unsafeWrapDatagramBased(base *gobject.ObjectInstance) *DatagramBasedInstance {
	return &DatagramBasedInstance{
		Instance: *base,
	}
}

func marshalDatagramBasedInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DatagramBasedInstance) upcastToGDatagramBased() *DatagramBasedInstance {
	return d
}

// UnsafeDatagramBasedFromGlibNone is used to convert raw GDatagramBased pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibNone(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibNone(c).(DatagramBased)
}

// UnsafeDatagramBasedFromGlibFull is used to convert raw GDatagramBased pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibFull(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibFull(c).(DatagramBased)
}

// UnsafeDatagramBasedFromGlibBorrow is used to convert raw GDatagramBased pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibBorrow(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DatagramBased)
}

// UnsafeDatagramBasedToGlibNone is used to convert the instance to it's C value GDatagramBased. This is used by the bindings internally.
func UnsafeDatagramBasedToGlibNone(c DatagramBased) unsafe.Pointer {
	i := c.upcastToGDatagramBased()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDatagramBasedToGlibFull is used to convert the instance to it's C value GDatagramBased, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedToGlibFull(c DatagramBased) unsafe.Pointer {
	i := c.upcastToGDatagramBased()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ConditionCheck wraps g_datagram_based_condition_check
// 
// see also https://docs.gtk.org/gio/method.g_datagram_based_condition_check.g_datagram_based_condition_check.html
//
func (datagramBased *DatagramBasedInstance) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 C.GIOCondition    // in, none, casted
	var cret  C.GIOCondition    // return, none, casted

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	carg1 = C.GIOCondition(condition)

	cret = C.g_datagram_based_condition_check(carg0, carg1)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)

	var goret glib.IOCondition

	goret = glib.IOCondition(cret)

	return goret
}

// ConditionWait wraps g_datagram_based_condition_wait
// 
// see also https://docs.gtk.org/gio/method.g_datagram_based_condition_wait.g_datagram_based_condition_wait.html
//
func (datagramBased *DatagramBasedInstance) ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 C.GIOCondition    // in, none, casted
	var carg2 C.gint64          // in, none, casted
	var carg3 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	carg1 = C.GIOCondition(condition)
	carg2 = C.gint64(timeout)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_condition_wait(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveMessages wraps g_datagram_based_receive_messages
// 
// see also https://docs.gtk.org/gio/method.g_datagram_based_receive_messages.g_datagram_based_receive_messages.html
//
func (datagramBased *DatagramBasedInstance) ReceiveMessages(messages []InputMessage, flags int32, timeout int64, cancellable Cancellable) (int32, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 *C.GInputMessage  // in, transfer: none, C Pointers: 1, Name: array[InputMessage], array (inner GInputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 C.gint64          // in, none, casted
	var carg5 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []InputMessage (GInputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	carg4 = C.gint64(timeout)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_receive_messages(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessages wraps g_datagram_based_send_messages
// 
// see also https://docs.gtk.org/gio/method.g_datagram_based_send_messages.g_datagram_based_send_messages.html
//
func (datagramBased *DatagramBasedInstance) SendMessages(messages []OutputMessage, flags int32, timeout int64, cancellable Cancellable) (int32, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 *C.GOutputMessage // in, transfer: none, C Pointers: 1, Name: array[OutputMessage], array (inner GOutputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 C.gint64          // in, none, casted
	var carg5 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputMessage (GOutputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	carg4 = C.gint64(timeout)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_send_messages(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DriveInstance is the instance type used by all types implementing GDrive. It is used internally by the bindings. Users should use the interface [Drive] instead.
type DriveInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Drive = (*DriveInstance)(nil)

// Drive wraps GDrive
// 
// see also https://docs.gtk.org/gio/interface.Drive.html
//
type Drive interface {
	upcastToGDrive() *DriveInstance

	// CanEject wraps g_drive_can_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_can_eject.g_drive_can_eject.html
	//
	CanEject() bool
	// CanPollForMedia wraps g_drive_can_poll_for_media
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_can_poll_for_media.g_drive_can_poll_for_media.html
	//
	CanPollForMedia() bool
	// CanStart wraps g_drive_can_start
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_can_start.g_drive_can_start.html
	//
	CanStart() bool
	// CanStartDegraded wraps g_drive_can_start_degraded
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_can_start_degraded.g_drive_can_start_degraded.html
	//
	CanStartDegraded() bool
	// CanStop wraps g_drive_can_stop
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_can_stop.g_drive_can_stop.html
	//
	CanStop() bool
	// Eject wraps g_drive_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_eject.g_drive_eject.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_drive_eject_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_eject_finish.g_drive_eject_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_drive_eject_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_eject_with_operation.g_drive_eject_with_operation.html
	//
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_drive_eject_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_eject_with_operation_finish.g_drive_eject_with_operation_finish.html
	//
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateIdentifiers wraps g_drive_enumerate_identifiers
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_enumerate_identifiers.g_drive_enumerate_identifiers.html
	//
	EnumerateIdentifiers() []string
	// GetIcon wraps g_drive_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_icon.g_drive_get_icon.html
	//
	GetIcon() Icon
	// GetIdentifier wraps g_drive_get_identifier
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_identifier.g_drive_get_identifier.html
	//
	GetIdentifier(string) string
	// GetName wraps g_drive_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_name.g_drive_get_name.html
	//
	GetName() string
	// GetSortKey wraps g_drive_get_sort_key
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_sort_key.g_drive_get_sort_key.html
	//
	GetSortKey() string
	// GetStartStopType wraps g_drive_get_start_stop_type
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_start_stop_type.g_drive_get_start_stop_type.html
	//
	GetStartStopType() DriveStartStopType
	// GetSymbolicIcon wraps g_drive_get_symbolic_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_symbolic_icon.g_drive_get_symbolic_icon.html
	//
	GetSymbolicIcon() Icon
	// GetVolumes wraps g_drive_get_volumes
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_get_volumes.g_drive_get_volumes.html
	//
	GetVolumes() []Volume
	// HasMedia wraps g_drive_has_media
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_has_media.g_drive_has_media.html
	//
	HasMedia() bool
	// HasVolumes wraps g_drive_has_volumes
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_has_volumes.g_drive_has_volumes.html
	//
	HasVolumes() bool
	// IsMediaCheckAutomatic wraps g_drive_is_media_check_automatic
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_is_media_check_automatic.g_drive_is_media_check_automatic.html
	//
	IsMediaCheckAutomatic() bool
	// IsMediaRemovable wraps g_drive_is_media_removable
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_is_media_removable.g_drive_is_media_removable.html
	//
	IsMediaRemovable() bool
	// IsRemovable wraps g_drive_is_removable
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_is_removable.g_drive_is_removable.html
	//
	IsRemovable() bool
	// PollForMedia wraps g_drive_poll_for_media
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_poll_for_media.g_drive_poll_for_media.html
	//
	PollForMedia(Cancellable, AsyncReadyCallback)
	// PollForMediaFinish wraps g_drive_poll_for_media_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_poll_for_media_finish.g_drive_poll_for_media_finish.html
	//
	PollForMediaFinish(AsyncResult) (bool, error)
	// Start wraps g_drive_start
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_start.g_drive_start.html
	//
	Start(DriveStartFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StartFinish wraps g_drive_start_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_start_finish.g_drive_start_finish.html
	//
	StartFinish(AsyncResult) (bool, error)
	// Stop wraps g_drive_stop
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_stop.g_drive_stop.html
	//
	Stop(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StopFinish wraps g_drive_stop_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_drive_stop_finish.g_drive_stop_finish.html
	//
	StopFinish(AsyncResult) (bool, error)
	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Drive.changed.html
	//
	ConnectChanged(func(Drive)) gobject.SignalHandle
	// ConnectDisconnected connects the provided callback to the "disconnected" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Drive.disconnected.html
	//
	ConnectDisconnected(func(Drive)) gobject.SignalHandle
	// ConnectEjectButton connects the provided callback to the "eject-button" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Drive.eject-button.html
	//
	ConnectEjectButton(func(Drive)) gobject.SignalHandle
	// ConnectStopButton connects the provided callback to the "stop-button" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Drive.stop-button.html
	//
	ConnectStopButton(func(Drive)) gobject.SignalHandle
}

var _ Drive = (*DriveInstance)(nil)

func unsafeWrapDrive(base *gobject.ObjectInstance) *DriveInstance {
	return &DriveInstance{
		Instance: *base,
	}
}

func marshalDriveInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DriveInstance) upcastToGDrive() *DriveInstance {
	return d
}

// UnsafeDriveFromGlibNone is used to convert raw GDrive pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDriveFromGlibNone(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibNone(c).(Drive)
}

// UnsafeDriveFromGlibFull is used to convert raw GDrive pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDriveFromGlibFull(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibFull(c).(Drive)
}

// UnsafeDriveFromGlibBorrow is used to convert raw GDrive pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDriveFromGlibBorrow(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Drive)
}

// UnsafeDriveToGlibNone is used to convert the instance to it's C value GDrive. This is used by the bindings internally.
func UnsafeDriveToGlibNone(c Drive) unsafe.Pointer {
	i := c.upcastToGDrive()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDriveToGlibFull is used to convert the instance to it's C value GDrive, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDriveToGlibFull(c Drive) unsafe.Pointer {
	i := c.upcastToGDrive()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_drive_can_eject
// 
// see also https://docs.gtk.org/gio/method.g_drive_can_eject.g_drive_can_eject.html
//
func (drive *DriveInstance) CanEject() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_eject(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanPollForMedia wraps g_drive_can_poll_for_media
// 
// see also https://docs.gtk.org/gio/method.g_drive_can_poll_for_media.g_drive_can_poll_for_media.html
//
func (drive *DriveInstance) CanPollForMedia() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_poll_for_media(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStart wraps g_drive_can_start
// 
// see also https://docs.gtk.org/gio/method.g_drive_can_start.g_drive_can_start.html
//
func (drive *DriveInstance) CanStart() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_start(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStartDegraded wraps g_drive_can_start_degraded
// 
// see also https://docs.gtk.org/gio/method.g_drive_can_start_degraded.g_drive_can_start_degraded.html
//
func (drive *DriveInstance) CanStartDegraded() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_start_degraded(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStop wraps g_drive_can_stop
// 
// see also https://docs.gtk.org/gio/method.g_drive_can_stop.g_drive_can_stop.html
//
func (drive *DriveInstance) CanStop() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_stop(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_drive_eject
// 
// see also https://docs.gtk.org/gio/method.g_drive_eject.g_drive_eject.html
//
//
// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation() instead.
func (drive *DriveInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_drive_eject_finish
// 
// see also https://docs.gtk.org/gio/method.g_drive_eject_finish.g_drive_eject_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation_finish() instead.
func (drive *DriveInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_drive_eject_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_drive_eject_with_operation.g_drive_eject_with_operation.html
//
func (drive *DriveInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_drive_eject_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_drive_eject_with_operation_finish.g_drive_eject_with_operation_finish.html
//
func (drive *DriveInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateIdentifiers wraps g_drive_enumerate_identifiers
// 
// see also https://docs.gtk.org/gio/method.g_drive_enumerate_identifiers.g_drive_enumerate_identifiers.html
//
func (drive *DriveInstance) EnumerateIdentifiers() []string {
	var carg0 *C.GDrive // in, none, converted
	var cret  **C.char  // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_enumerate_identifiers(carg0)
	runtime.KeepAlive(drive)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetIcon wraps g_drive_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_icon.g_drive_get_icon.html
//
func (drive *DriveInstance) GetIcon() Icon {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_icon(carg0)
	runtime.KeepAlive(drive)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIdentifier wraps g_drive_get_identifier
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_identifier.g_drive_get_identifier.html
//
func (drive *DriveInstance) GetIdentifier(kind string) string {
	var carg0 *C.GDrive // in, none, converted
	var carg1 *C.char   // in, none, string
	var cret  *C.char   // return, full, string, nullable-string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_drive_get_identifier(carg0, carg1)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(kind)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetName wraps g_drive_get_name
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_name.g_drive_get_name.html
//
func (drive *DriveInstance) GetName() string {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.char   // return, full, string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_name(carg0)
	runtime.KeepAlive(drive)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_drive_get_sort_key
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_sort_key.g_drive_get_sort_key.html
//
func (drive *DriveInstance) GetSortKey() string {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.gchar  // return, none, string, nullable-string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_sort_key(carg0)
	runtime.KeepAlive(drive)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetStartStopType wraps g_drive_get_start_stop_type
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_start_stop_type.g_drive_get_start_stop_type.html
//
func (drive *DriveInstance) GetStartStopType() DriveStartStopType {
	var carg0 *C.GDrive             // in, none, converted
	var cret  C.GDriveStartStopType // return, none, casted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_start_stop_type(carg0)
	runtime.KeepAlive(drive)

	var goret DriveStartStopType

	goret = DriveStartStopType(cret)

	return goret
}

// GetSymbolicIcon wraps g_drive_get_symbolic_icon
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_symbolic_icon.g_drive_get_symbolic_icon.html
//
func (drive *DriveInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_symbolic_icon(carg0)
	runtime.KeepAlive(drive)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetVolumes wraps g_drive_get_volumes
// 
// see also https://docs.gtk.org/gio/method.g_drive_get_volumes.g_drive_get_volumes.html
//
func (drive *DriveInstance) GetVolumes() []Volume {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GList  // container, transfer: full

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_volumes(carg0)
	runtime.KeepAlive(drive)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// HasMedia wraps g_drive_has_media
// 
// see also https://docs.gtk.org/gio/method.g_drive_has_media.g_drive_has_media.html
//
func (drive *DriveInstance) HasMedia() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_has_media(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasVolumes wraps g_drive_has_volumes
// 
// see also https://docs.gtk.org/gio/method.g_drive_has_volumes.g_drive_has_volumes.html
//
func (drive *DriveInstance) HasVolumes() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_has_volumes(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMediaCheckAutomatic wraps g_drive_is_media_check_automatic
// 
// see also https://docs.gtk.org/gio/method.g_drive_is_media_check_automatic.g_drive_is_media_check_automatic.html
//
func (drive *DriveInstance) IsMediaCheckAutomatic() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_media_check_automatic(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMediaRemovable wraps g_drive_is_media_removable
// 
// see also https://docs.gtk.org/gio/method.g_drive_is_media_removable.g_drive_is_media_removable.html
//
func (drive *DriveInstance) IsMediaRemovable() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_media_removable(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsRemovable wraps g_drive_is_removable
// 
// see also https://docs.gtk.org/gio/method.g_drive_is_removable.g_drive_is_removable.html
//
func (drive *DriveInstance) IsRemovable() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_removable(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollForMedia wraps g_drive_poll_for_media
// 
// see also https://docs.gtk.org/gio/method.g_drive_poll_for_media.g_drive_poll_for_media.html
//
func (drive *DriveInstance) PollForMedia(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_poll_for_media(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// PollForMediaFinish wraps g_drive_poll_for_media_finish
// 
// see also https://docs.gtk.org/gio/method.g_drive_poll_for_media_finish.g_drive_poll_for_media_finish.html
//
func (drive *DriveInstance) PollForMediaFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_poll_for_media_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Start wraps g_drive_start
// 
// see also https://docs.gtk.org/gio/method.g_drive_start.g_drive_start.html
//
func (drive *DriveInstance) Start(flags DriveStartFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GDriveStartFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GDriveStartFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_start(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StartFinish wraps g_drive_start_finish
// 
// see also https://docs.gtk.org/gio/method.g_drive_start_finish.g_drive_start_finish.html
//
func (drive *DriveInstance) StartFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_start_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Stop wraps g_drive_stop
// 
// see also https://docs.gtk.org/gio/method.g_drive_stop.g_drive_stop.html
//
func (drive *DriveInstance) Stop(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_stop(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StopFinish wraps g_drive_stop_finish
// 
// see also https://docs.gtk.org/gio/method.g_drive_stop_finish.g_drive_stop_finish.html
//
func (drive *DriveInstance) StopFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_stop_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.Drive.changed.html
//
func (o *DriveInstance) ConnectChanged(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectDisconnected connects the provided callback to the "disconnected" signal
// 
// see also https://docs.gtk.org/gio/signal.Drive.disconnected.html
//
func (o *DriveInstance) ConnectDisconnected(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("disconnected", fn)
}

// ConnectEjectButton connects the provided callback to the "eject-button" signal
// 
// see also https://docs.gtk.org/gio/signal.Drive.eject-button.html
//
func (o *DriveInstance) ConnectEjectButton(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("eject-button", fn)
}

// ConnectStopButton connects the provided callback to the "stop-button" signal
// 
// see also https://docs.gtk.org/gio/signal.Drive.stop-button.html
//
func (o *DriveInstance) ConnectStopButton(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("stop-button", fn)
}

// DtlsConnectionInstance is the instance type used by all types implementing GDtlsConnection. It is used internally by the bindings. Users should use the interface [DtlsConnection] instead.
type DtlsConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsConnection = (*DtlsConnectionInstance)(nil)

// DtlsConnection wraps GDtlsConnection
// 
// see also https://docs.gtk.org/gio/interface.DtlsConnection.html
//
type DtlsConnection interface {
	upcastToGDtlsConnection() *DtlsConnectionInstance

	// Close wraps g_dtls_connection_close
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_close.g_dtls_connection_close.html
	//
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_dtls_connection_close_async
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_close_async.g_dtls_connection_close_async.html
	//
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_dtls_connection_close_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_close_finish.g_dtls_connection_close_finish.html
	//
	CloseFinish(AsyncResult) (bool, error)
	// EmitAcceptCertificate wraps g_dtls_connection_emit_accept_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_emit_accept_certificate.g_dtls_connection_emit_accept_certificate.html
	//
	EmitAcceptCertificate(TlsCertificate, TlsCertificateFlags) bool
	// GetCertificate wraps g_dtls_connection_get_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_certificate.g_dtls_connection_get_certificate.html
	//
	GetCertificate() TlsCertificate
	// GetCiphersuiteName wraps g_dtls_connection_get_ciphersuite_name
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_ciphersuite_name.g_dtls_connection_get_ciphersuite_name.html
	//
	GetCiphersuiteName() string
	// GetDatabase wraps g_dtls_connection_get_database
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_database.g_dtls_connection_get_database.html
	//
	GetDatabase() TlsDatabase
	// GetInteraction wraps g_dtls_connection_get_interaction
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_interaction.g_dtls_connection_get_interaction.html
	//
	GetInteraction() TlsInteraction
	// GetNegotiatedProtocol wraps g_dtls_connection_get_negotiated_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_negotiated_protocol.g_dtls_connection_get_negotiated_protocol.html
	//
	GetNegotiatedProtocol() string
	// GetPeerCertificate wraps g_dtls_connection_get_peer_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_peer_certificate.g_dtls_connection_get_peer_certificate.html
	//
	GetPeerCertificate() TlsCertificate
	// GetPeerCertificateErrors wraps g_dtls_connection_get_peer_certificate_errors
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_peer_certificate_errors.g_dtls_connection_get_peer_certificate_errors.html
	//
	GetPeerCertificateErrors() TlsCertificateFlags
	// GetProtocolVersion wraps g_dtls_connection_get_protocol_version
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_protocol_version.g_dtls_connection_get_protocol_version.html
	//
	GetProtocolVersion() TlsProtocolVersion
	// GetRehandshakeMode wraps g_dtls_connection_get_rehandshake_mode
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_rehandshake_mode.g_dtls_connection_get_rehandshake_mode.html
	//
	//
	// Deprecated: (since 2.64.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	GetRehandshakeMode() TlsRehandshakeMode
	// GetRequireCloseNotify wraps g_dtls_connection_get_require_close_notify
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_require_close_notify.g_dtls_connection_get_require_close_notify.html
	//
	GetRequireCloseNotify() bool
	// Handshake wraps g_dtls_connection_handshake
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake.g_dtls_connection_handshake.html
	//
	Handshake(Cancellable) (bool, error)
	// HandshakeAsync wraps g_dtls_connection_handshake_async
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake_async.g_dtls_connection_handshake_async.html
	//
	HandshakeAsync(int32, Cancellable, AsyncReadyCallback)
	// HandshakeFinish wraps g_dtls_connection_handshake_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake_finish.g_dtls_connection_handshake_finish.html
	//
	HandshakeFinish(AsyncResult) (bool, error)
	// SetAdvertisedProtocols wraps g_dtls_connection_set_advertised_protocols
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_advertised_protocols.g_dtls_connection_set_advertised_protocols.html
	//
	SetAdvertisedProtocols([]string)
	// SetCertificate wraps g_dtls_connection_set_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_certificate.g_dtls_connection_set_certificate.html
	//
	SetCertificate(TlsCertificate)
	// SetDatabase wraps g_dtls_connection_set_database
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_database.g_dtls_connection_set_database.html
	//
	SetDatabase(TlsDatabase)
	// SetInteraction wraps g_dtls_connection_set_interaction
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_interaction.g_dtls_connection_set_interaction.html
	//
	SetInteraction(TlsInteraction)
	// SetRehandshakeMode wraps g_dtls_connection_set_rehandshake_mode
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_rehandshake_mode.g_dtls_connection_set_rehandshake_mode.html
	//
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	SetRehandshakeMode(TlsRehandshakeMode)
	// SetRequireCloseNotify wraps g_dtls_connection_set_require_close_notify
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_require_close_notify.g_dtls_connection_set_require_close_notify.html
	//
	SetRequireCloseNotify(bool)
	// Shutdown wraps g_dtls_connection_shutdown
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown.g_dtls_connection_shutdown.html
	//
	Shutdown(bool, bool, Cancellable) (bool, error)
	// ShutdownAsync wraps g_dtls_connection_shutdown_async
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown_async.g_dtls_connection_shutdown_async.html
	//
	ShutdownAsync(bool, bool, int32, Cancellable, AsyncReadyCallback)
	// ShutdownFinish wraps g_dtls_connection_shutdown_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown_finish.g_dtls_connection_shutdown_finish.html
	//
	ShutdownFinish(AsyncResult) (bool, error)
	// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
	// 
	// see also https://docs.gtk.org/gio/signal.DtlsConnection.accept-certificate.html
	//
	ConnectAcceptCertificate(func(DtlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle
}

var _ DtlsConnection = (*DtlsConnectionInstance)(nil)

func unsafeWrapDtlsConnection(base *gobject.ObjectInstance) *DtlsConnectionInstance {
	return &DtlsConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsConnectionInstance) upcastToGDtlsConnection() *DtlsConnectionInstance {
	return d
}

// UnsafeDtlsConnectionFromGlibNone is used to convert raw GDtlsConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibNone(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsConnection)
}

// UnsafeDtlsConnectionFromGlibFull is used to convert raw GDtlsConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibFull(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsConnection)
}

// UnsafeDtlsConnectionFromGlibBorrow is used to convert raw GDtlsConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibBorrow(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsConnection)
}

// UnsafeDtlsConnectionToGlibNone is used to convert the instance to it's C value GDtlsConnection. This is used by the bindings internally.
func UnsafeDtlsConnectionToGlibNone(c DtlsConnection) unsafe.Pointer {
	i := c.upcastToGDtlsConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsConnectionToGlibFull is used to convert the instance to it's C value GDtlsConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionToGlibFull(c DtlsConnection) unsafe.Pointer {
	i := c.upcastToGDtlsConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Close wraps g_dtls_connection_close
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_close.g_dtls_connection_close.html
//
func (conn *DtlsConnectionInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_dtls_connection_close_async
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_close_async.g_dtls_connection_close_async.html
//
func (conn *DtlsConnectionInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_dtls_connection_close_finish
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_close_finish.g_dtls_connection_close_finish.html
//
func (conn *DtlsConnectionInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EmitAcceptCertificate wraps g_dtls_connection_emit_accept_certificate
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_emit_accept_certificate.g_dtls_connection_emit_accept_certificate.html
//
func (conn *DtlsConnectionInstance) EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GDtlsConnection     // in, none, converted
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C.g_dtls_connection_emit_accept_certificate(carg0, carg1, carg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCertificate wraps g_dtls_connection_get_certificate
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_certificate.g_dtls_connection_get_certificate.html
//
func (conn *DtlsConnectionInstance) GetCertificate() TlsCertificate {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCiphersuiteName wraps g_dtls_connection_get_ciphersuite_name
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_ciphersuite_name.g_dtls_connection_get_ciphersuite_name.html
//
func (conn *DtlsConnectionInstance) GetCiphersuiteName() string {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_ciphersuite_name(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetDatabase wraps g_dtls_connection_get_database
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_database.g_dtls_connection_get_database.html
//
func (conn *DtlsConnectionInstance) GetDatabase() TlsDatabase {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsDatabase    // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_database(carg0)
	runtime.KeepAlive(conn)

	var goret TlsDatabase

	if cret != nil {
		goret = UnsafeTlsDatabaseFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetInteraction wraps g_dtls_connection_get_interaction
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_interaction.g_dtls_connection_get_interaction.html
//
func (conn *DtlsConnectionInstance) GetInteraction() TlsInteraction {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsInteraction // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_interaction(carg0)
	runtime.KeepAlive(conn)

	var goret TlsInteraction

	if cret != nil {
		goret = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetNegotiatedProtocol wraps g_dtls_connection_get_negotiated_protocol
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_negotiated_protocol.g_dtls_connection_get_negotiated_protocol.html
//
func (conn *DtlsConnectionInstance) GetNegotiatedProtocol() string {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_negotiated_protocol(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPeerCertificate wraps g_dtls_connection_get_peer_certificate
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_peer_certificate.g_dtls_connection_get_peer_certificate.html
//
func (conn *DtlsConnectionInstance) GetPeerCertificate() TlsCertificate {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_peer_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetPeerCertificateErrors wraps g_dtls_connection_get_peer_certificate_errors
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_peer_certificate_errors.g_dtls_connection_get_peer_certificate_errors.html
//
func (conn *DtlsConnectionInstance) GetPeerCertificateErrors() TlsCertificateFlags {
	var carg0 *C.GDtlsConnection     // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_peer_certificate_errors(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// GetProtocolVersion wraps g_dtls_connection_get_protocol_version
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_protocol_version.g_dtls_connection_get_protocol_version.html
//
func (conn *DtlsConnectionInstance) GetProtocolVersion() TlsProtocolVersion {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var cret  C.GTlsProtocolVersion // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_protocol_version(carg0)
	runtime.KeepAlive(conn)

	var goret TlsProtocolVersion

	goret = TlsProtocolVersion(cret)

	return goret
}

// GetRehandshakeMode wraps g_dtls_connection_get_rehandshake_mode
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_rehandshake_mode.g_dtls_connection_get_rehandshake_mode.html
//
//
// Deprecated: (since 2.64.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *DtlsConnectionInstance) GetRehandshakeMode() TlsRehandshakeMode {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var cret  C.GTlsRehandshakeMode // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_rehandshake_mode(carg0)
	runtime.KeepAlive(conn)

	var goret TlsRehandshakeMode

	goret = TlsRehandshakeMode(cret)

	return goret
}

// GetRequireCloseNotify wraps g_dtls_connection_get_require_close_notify
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_get_require_close_notify.g_dtls_connection_get_require_close_notify.html
//
func (conn *DtlsConnectionInstance) GetRequireCloseNotify() bool {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_require_close_notify(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Handshake wraps g_dtls_connection_handshake
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake.g_dtls_connection_handshake.html
//
func (conn *DtlsConnectionInstance) Handshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_handshake(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HandshakeAsync wraps g_dtls_connection_handshake_async
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake_async.g_dtls_connection_handshake_async.html
//
func (conn *DtlsConnectionInstance) HandshakeAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_handshake_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// HandshakeFinish wraps g_dtls_connection_handshake_finish
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_handshake_finish.g_dtls_connection_handshake_finish.html
//
func (conn *DtlsConnectionInstance) HandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_handshake_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAdvertisedProtocols wraps g_dtls_connection_set_advertised_protocols
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_advertised_protocols.g_dtls_connection_set_advertised_protocols.html
//
func (conn *DtlsConnectionInstance) SetAdvertisedProtocols(protocols []string) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 **C.gchar          // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	_ = protocols
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_dtls_connection_set_advertised_protocols(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate wraps g_dtls_connection_set_certificate
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_certificate.g_dtls_connection_set_certificate.html
//
func (conn *DtlsConnectionInstance) SetCertificate(certificate TlsCertificate) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	C.g_dtls_connection_set_certificate(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase wraps g_dtls_connection_set_database
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_database.g_dtls_connection_set_database.html
//
func (conn *DtlsConnectionInstance) SetDatabase(database TlsDatabase) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsDatabase    // in, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_dtls_connection_set_database(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction wraps g_dtls_connection_set_interaction
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_interaction.g_dtls_connection_set_interaction.html
//
func (conn *DtlsConnectionInstance) SetInteraction(interaction TlsInteraction) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsInteraction // in, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if interaction != nil {
		carg1 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}

	C.g_dtls_connection_set_interaction(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode wraps g_dtls_connection_set_rehandshake_mode
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_rehandshake_mode.g_dtls_connection_set_rehandshake_mode.html
//
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *DtlsConnectionInstance) SetRehandshakeMode(mode TlsRehandshakeMode) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.GTlsRehandshakeMode // in, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.GTlsRehandshakeMode(mode)

	C.g_dtls_connection_set_rehandshake_mode(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify wraps g_dtls_connection_set_require_close_notify
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_set_require_close_notify.g_dtls_connection_set_require_close_notify.html
//
func (conn *DtlsConnectionInstance) SetRequireCloseNotify(requireCloseNotify bool) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if requireCloseNotify {
		carg1 = C.TRUE
	}

	C.g_dtls_connection_set_require_close_notify(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// Shutdown wraps g_dtls_connection_shutdown
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown.g_dtls_connection_shutdown.html
//
func (conn *DtlsConnectionInstance) Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 C.gboolean         // in
	var carg2 C.gboolean         // in
	var carg3 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_shutdown(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShutdownAsync wraps g_dtls_connection_shutdown_async
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown_async.g_dtls_connection_shutdown_async.html
//
func (conn *DtlsConnectionInstance) ShutdownAsync(shutdownRead bool, shutdownWrite bool, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.gboolean            // in
	var carg2 C.gboolean            // in
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_shutdown_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ShutdownFinish wraps g_dtls_connection_shutdown_finish
// 
// see also https://docs.gtk.org/gio/method.g_dtls_connection_shutdown_finish.g_dtls_connection_shutdown_finish.html
//
func (conn *DtlsConnectionInstance) ShutdownFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_shutdown_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
// 
// see also https://docs.gtk.org/gio/signal.DtlsConnection.accept-certificate.html
//
func (o *DtlsConnectionInstance) ConnectAcceptCertificate(fn func(DtlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle {
	return o.Instance.Connect("accept-certificate", fn)
}

// DtlsServerConnectionInstance is the instance type used by all types implementing GDtlsServerConnection. It is used internally by the bindings. Users should use the interface [DtlsServerConnection] instead.
type DtlsServerConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsServerConnection = (*DtlsServerConnectionInstance)(nil)

// DtlsServerConnection wraps GDtlsServerConnection
// 
// see also https://docs.gtk.org/gio/interface.DtlsServerConnection.html
//
type DtlsServerConnection interface {
	upcastToGDtlsServerConnection() *DtlsServerConnectionInstance
}

var _ DtlsServerConnection = (*DtlsServerConnectionInstance)(nil)

func unsafeWrapDtlsServerConnection(base *gobject.ObjectInstance) *DtlsServerConnectionInstance {
	return &DtlsServerConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsServerConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsServerConnectionInstance) upcastToGDtlsServerConnection() *DtlsServerConnectionInstance {
	return d
}

// UnsafeDtlsServerConnectionFromGlibNone is used to convert raw GDtlsServerConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibNone(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionFromGlibFull is used to convert raw GDtlsServerConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibFull(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionFromGlibBorrow is used to convert raw GDtlsServerConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibBorrow(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionToGlibNone is used to convert the instance to it's C value GDtlsServerConnection. This is used by the bindings internally.
func UnsafeDtlsServerConnectionToGlibNone(c DtlsServerConnection) unsafe.Pointer {
	i := c.upcastToGDtlsServerConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsServerConnectionToGlibFull is used to convert the instance to it's C value GDtlsServerConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionToGlibFull(c DtlsServerConnection) unsafe.Pointer {
	i := c.upcastToGDtlsServerConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewDtlsServerConnection wraps g_dtls_server_connection_new
// 
// see also https://docs.gtk.org/gio/func.g_dtls_server_connection_new.html
//
func NewDtlsServerConnection(baseSocket DatagramBased, certificate TlsCertificate) (DtlsServerConnection, error) {
	var carg1 *C.GDatagramBased  // in, none, converted
	var carg2 *C.GTlsCertificate // in, none, converted, nullable
	var cret  *C.GDatagramBased  // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(baseSocket))
	if certificate != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	}

	cret = C.g_dtls_server_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(certificate)

	var goret  DtlsServerConnection
	var _goerr error

	goret = UnsafeDtlsServerConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileInstance is the instance type used by all types implementing GFile. It is used internally by the bindings. Users should use the interface [File] instead.
type FileInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ File = (*FileInstance)(nil)

// File wraps GFile
// 
// see also https://docs.gtk.org/gio/interface.File.html
//
type File interface {
	upcastToGFile() *FileInstance

	// AppendTo wraps g_file_append_to
	// 
	// see also https://docs.gtk.org/gio/method.g_file_append_to.g_file_append_to.html
	//
	AppendTo(FileCreateFlags, Cancellable) (FileOutputStream, error)
	// AppendToAsync wraps g_file_append_to_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_append_to_async.g_file_append_to_async.html
	//
	AppendToAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// AppendToFinish wraps g_file_append_to_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_append_to_finish.g_file_append_to_finish.html
	//
	AppendToFinish(AsyncResult) (FileOutputStream, error)
	// BuildAttributeListForCopy wraps g_file_build_attribute_list_for_copy
	// 
	// see also https://docs.gtk.org/gio/method.g_file_build_attribute_list_for_copy.g_file_build_attribute_list_for_copy.html
	//
	BuildAttributeListForCopy(FileCopyFlags, Cancellable) (string, error)
	// CopyAttributes wraps g_file_copy_attributes
	// 
	// see also https://docs.gtk.org/gio/method.g_file_copy_attributes.g_file_copy_attributes.html
	//
	CopyAttributes(File, FileCopyFlags, Cancellable) (bool, error)
	// CopyFinish wraps g_file_copy_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_copy_finish.g_file_copy_finish.html
	//
	CopyFinish(AsyncResult) (bool, error)
	// Create wraps g_file_create
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create.g_file_create.html
	//
	Create(FileCreateFlags, Cancellable) (FileOutputStream, error)
	// CreateAsync wraps g_file_create_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create_async.g_file_create_async.html
	//
	CreateAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// CreateFinish wraps g_file_create_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create_finish.g_file_create_finish.html
	//
	CreateFinish(AsyncResult) (FileOutputStream, error)
	// CreateReadwrite wraps g_file_create_readwrite
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create_readwrite.g_file_create_readwrite.html
	//
	CreateReadwrite(FileCreateFlags, Cancellable) (FileIOStream, error)
	// CreateReadwriteAsync wraps g_file_create_readwrite_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create_readwrite_async.g_file_create_readwrite_async.html
	//
	CreateReadwriteAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// CreateReadwriteFinish wraps g_file_create_readwrite_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_create_readwrite_finish.g_file_create_readwrite_finish.html
	//
	CreateReadwriteFinish(AsyncResult) (FileIOStream, error)
	// Delete wraps g_file_delete
	// 
	// see also https://docs.gtk.org/gio/method.g_file_delete.g_file_delete.html
	//
	Delete(Cancellable) (bool, error)
	// DeleteAsync wraps g_file_delete_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_delete_async.g_file_delete_async.html
	//
	DeleteAsync(int32, Cancellable, AsyncReadyCallback)
	// DeleteFinish wraps g_file_delete_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_delete_finish.g_file_delete_finish.html
	//
	DeleteFinish(AsyncResult) (bool, error)
	// Dup wraps g_file_dup
	// 
	// see also https://docs.gtk.org/gio/method.g_file_dup.g_file_dup.html
	//
	Dup() File
	// EjectMountable wraps g_file_eject_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_eject_mountable.g_file_eject_mountable.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation() instead.
	EjectMountable(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectMountableFinish wraps g_file_eject_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_finish.g_file_eject_mountable_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation_finish()
	//   instead.
	EjectMountableFinish(AsyncResult) (bool, error)
	// EjectMountableWithOperation wraps g_file_eject_mountable_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_with_operation.g_file_eject_mountable_with_operation.html
	//
	EjectMountableWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectMountableWithOperationFinish wraps g_file_eject_mountable_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_with_operation_finish.g_file_eject_mountable_with_operation_finish.html
	//
	EjectMountableWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateChildren wraps g_file_enumerate_children
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerate_children.g_file_enumerate_children.html
	//
	EnumerateChildren(string, FileQueryInfoFlags, Cancellable) (FileEnumerator, error)
	// EnumerateChildrenAsync wraps g_file_enumerate_children_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerate_children_async.g_file_enumerate_children_async.html
	//
	EnumerateChildrenAsync(string, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// EnumerateChildrenFinish wraps g_file_enumerate_children_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerate_children_finish.g_file_enumerate_children_finish.html
	//
	EnumerateChildrenFinish(AsyncResult) (FileEnumerator, error)
	// Equal wraps g_file_equal
	// 
	// see also https://docs.gtk.org/gio/method.g_file_equal.g_file_equal.html
	//
	Equal(File) bool
	// FindEnclosingMount wraps g_file_find_enclosing_mount
	// 
	// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount.g_file_find_enclosing_mount.html
	//
	FindEnclosingMount(Cancellable) (Mount, error)
	// FindEnclosingMountAsync wraps g_file_find_enclosing_mount_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount_async.g_file_find_enclosing_mount_async.html
	//
	FindEnclosingMountAsync(int32, Cancellable, AsyncReadyCallback)
	// FindEnclosingMountFinish wraps g_file_find_enclosing_mount_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount_finish.g_file_find_enclosing_mount_finish.html
	//
	FindEnclosingMountFinish(AsyncResult) (Mount, error)
	// GetBasename wraps g_file_get_basename
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_basename.g_file_get_basename.html
	//
	GetBasename() string
	// GetChild wraps g_file_get_child
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_child.g_file_get_child.html
	//
	GetChild(string) File
	// GetChildForDisplayName wraps g_file_get_child_for_display_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_child_for_display_name.g_file_get_child_for_display_name.html
	//
	GetChildForDisplayName(string) (File, error)
	// GetParent wraps g_file_get_parent
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_parent.g_file_get_parent.html
	//
	GetParent() File
	// GetParseName wraps g_file_get_parse_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_parse_name.g_file_get_parse_name.html
	//
	GetParseName() string
	// GetPath wraps g_file_get_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_path.g_file_get_path.html
	//
	GetPath() string
	// GetRelativePath wraps g_file_get_relative_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_relative_path.g_file_get_relative_path.html
	//
	GetRelativePath(File) string
	// GetURI wraps g_file_get_uri
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_uri.g_file_get_uri.html
	//
	GetURI() string
	// GetURIScheme wraps g_file_get_uri_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_file_get_uri_scheme.g_file_get_uri_scheme.html
	//
	GetURIScheme() string
	// HasParent wraps g_file_has_parent
	// 
	// see also https://docs.gtk.org/gio/method.g_file_has_parent.g_file_has_parent.html
	//
	HasParent(File) bool
	// HasPrefix wraps g_file_has_prefix
	// 
	// see also https://docs.gtk.org/gio/method.g_file_has_prefix.g_file_has_prefix.html
	//
	HasPrefix(File) bool
	// HasURIScheme wraps g_file_has_uri_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_file_has_uri_scheme.g_file_has_uri_scheme.html
	//
	HasURIScheme(string) bool
	// IsNative wraps g_file_is_native
	// 
	// see also https://docs.gtk.org/gio/method.g_file_is_native.g_file_is_native.html
	//
	IsNative() bool
	// LoadBytes wraps g_file_load_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_bytes.g_file_load_bytes.html
	//
	LoadBytes(Cancellable) (string, *glib.Bytes, error)
	// LoadBytesAsync wraps g_file_load_bytes_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_bytes_async.g_file_load_bytes_async.html
	//
	LoadBytesAsync(Cancellable, AsyncReadyCallback)
	// LoadBytesFinish wraps g_file_load_bytes_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_bytes_finish.g_file_load_bytes_finish.html
	//
	LoadBytesFinish(AsyncResult) (string, *glib.Bytes, error)
	// LoadContents wraps g_file_load_contents
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_contents.g_file_load_contents.html
	//
	LoadContents(Cancellable) (string, string, bool, error)
	// LoadContentsAsync wraps g_file_load_contents_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_contents_async.g_file_load_contents_async.html
	//
	LoadContentsAsync(Cancellable, AsyncReadyCallback)
	// LoadContentsFinish wraps g_file_load_contents_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_contents_finish.g_file_load_contents_finish.html
	//
	LoadContentsFinish(AsyncResult) (string, string, bool, error)
	// LoadPartialContentsFinish wraps g_file_load_partial_contents_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_load_partial_contents_finish.g_file_load_partial_contents_finish.html
	//
	LoadPartialContentsFinish(AsyncResult) (string, string, bool, error)
	// MakeDirectory wraps g_file_make_directory
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_directory.g_file_make_directory.html
	//
	MakeDirectory(Cancellable) (bool, error)
	// MakeDirectoryAsync wraps g_file_make_directory_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_directory_async.g_file_make_directory_async.html
	//
	MakeDirectoryAsync(int32, Cancellable, AsyncReadyCallback)
	// MakeDirectoryFinish wraps g_file_make_directory_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_directory_finish.g_file_make_directory_finish.html
	//
	MakeDirectoryFinish(AsyncResult) (bool, error)
	// MakeDirectoryWithParents wraps g_file_make_directory_with_parents
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_directory_with_parents.g_file_make_directory_with_parents.html
	//
	MakeDirectoryWithParents(Cancellable) (bool, error)
	// MakeSymbolicLink wraps g_file_make_symbolic_link
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link.g_file_make_symbolic_link.html
	//
	MakeSymbolicLink(string, Cancellable) (bool, error)
	// MakeSymbolicLinkAsync wraps g_file_make_symbolic_link_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link_async.g_file_make_symbolic_link_async.html
	//
	MakeSymbolicLinkAsync(string, int32, Cancellable, AsyncReadyCallback)
	// MakeSymbolicLinkFinish wraps g_file_make_symbolic_link_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link_finish.g_file_make_symbolic_link_finish.html
	//
	MakeSymbolicLinkFinish(AsyncResult) (bool, error)
	// MeasureDiskUsageFinish wraps g_file_measure_disk_usage_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_measure_disk_usage_finish.g_file_measure_disk_usage_finish.html
	//
	MeasureDiskUsageFinish(AsyncResult) (uint64, uint64, uint64, bool, error)
	// Monitor wraps g_file_monitor
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor.g_file_monitor.html
	//
	Monitor(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MonitorDirectory wraps g_file_monitor_directory
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_directory.g_file_monitor_directory.html
	//
	MonitorDirectory(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MonitorFile wraps g_file_monitor_file
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_file.g_file_monitor_file.html
	//
	MonitorFile(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MountEnclosingVolume wraps g_file_mount_enclosing_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_file_mount_enclosing_volume.g_file_mount_enclosing_volume.html
	//
	MountEnclosingVolume(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountEnclosingVolumeFinish wraps g_file_mount_enclosing_volume_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_mount_enclosing_volume_finish.g_file_mount_enclosing_volume_finish.html
	//
	MountEnclosingVolumeFinish(AsyncResult) (bool, error)
	// MountMountable wraps g_file_mount_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_mount_mountable.g_file_mount_mountable.html
	//
	MountMountable(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountMountableFinish wraps g_file_mount_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_mount_mountable_finish.g_file_mount_mountable_finish.html
	//
	MountMountableFinish(AsyncResult) (File, error)
	// MoveFinish wraps g_file_move_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_move_finish.g_file_move_finish.html
	//
	MoveFinish(AsyncResult) (bool, error)
	// OpenReadwrite wraps g_file_open_readwrite
	// 
	// see also https://docs.gtk.org/gio/method.g_file_open_readwrite.g_file_open_readwrite.html
	//
	OpenReadwrite(Cancellable) (FileIOStream, error)
	// OpenReadwriteAsync wraps g_file_open_readwrite_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_open_readwrite_async.g_file_open_readwrite_async.html
	//
	OpenReadwriteAsync(int32, Cancellable, AsyncReadyCallback)
	// OpenReadwriteFinish wraps g_file_open_readwrite_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_open_readwrite_finish.g_file_open_readwrite_finish.html
	//
	OpenReadwriteFinish(AsyncResult) (FileIOStream, error)
	// PeekPath wraps g_file_peek_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_peek_path.g_file_peek_path.html
	//
	PeekPath() string
	// PollMountable wraps g_file_poll_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_poll_mountable.g_file_poll_mountable.html
	//
	PollMountable(Cancellable, AsyncReadyCallback)
	// PollMountableFinish wraps g_file_poll_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_poll_mountable_finish.g_file_poll_mountable_finish.html
	//
	PollMountableFinish(AsyncResult) (bool, error)
	// QueryDefaultHandler wraps g_file_query_default_handler
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_default_handler.g_file_query_default_handler.html
	//
	QueryDefaultHandler(Cancellable) (AppInfo, error)
	// QueryDefaultHandlerAsync wraps g_file_query_default_handler_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_default_handler_async.g_file_query_default_handler_async.html
	//
	QueryDefaultHandlerAsync(int32, Cancellable, AsyncReadyCallback)
	// QueryDefaultHandlerFinish wraps g_file_query_default_handler_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_default_handler_finish.g_file_query_default_handler_finish.html
	//
	QueryDefaultHandlerFinish(AsyncResult) (AppInfo, error)
	// QueryExists wraps g_file_query_exists
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_exists.g_file_query_exists.html
	//
	QueryExists(Cancellable) bool
	// QueryFileType wraps g_file_query_file_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_file_type.g_file_query_file_type.html
	//
	QueryFileType(FileQueryInfoFlags, Cancellable) FileType
	// QueryFilesystemInfo wraps g_file_query_filesystem_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info.g_file_query_filesystem_info.html
	//
	QueryFilesystemInfo(string, Cancellable) (FileInfo, error)
	// QueryFilesystemInfoAsync wraps g_file_query_filesystem_info_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info_async.g_file_query_filesystem_info_async.html
	//
	QueryFilesystemInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryFilesystemInfoFinish wraps g_file_query_filesystem_info_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info_finish.g_file_query_filesystem_info_finish.html
	//
	QueryFilesystemInfoFinish(AsyncResult) (FileInfo, error)
	// QueryInfo wraps g_file_query_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_info.g_file_query_info.html
	//
	QueryInfo(string, FileQueryInfoFlags, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_query_info_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_info_async.g_file_query_info_async.html
	//
	QueryInfoAsync(string, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_query_info_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_info_finish.g_file_query_info_finish.html
	//
	QueryInfoFinish(AsyncResult) (FileInfo, error)
	// QuerySettableAttributes wraps g_file_query_settable_attributes
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_settable_attributes.g_file_query_settable_attributes.html
	//
	QuerySettableAttributes(Cancellable) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces wraps g_file_query_writable_namespaces
	// 
	// see also https://docs.gtk.org/gio/method.g_file_query_writable_namespaces.g_file_query_writable_namespaces.html
	//
	QueryWritableNamespaces(Cancellable) (*FileAttributeInfoList, error)
	// Read wraps g_file_read
	// 
	// see also https://docs.gtk.org/gio/method.g_file_read.g_file_read.html
	//
	Read(Cancellable) (FileInputStream, error)
	// ReadAsync wraps g_file_read_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_read_async.g_file_read_async.html
	//
	ReadAsync(int32, Cancellable, AsyncReadyCallback)
	// ReadFinish wraps g_file_read_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_read_finish.g_file_read_finish.html
	//
	ReadFinish(AsyncResult) (FileInputStream, error)
	// Replace wraps g_file_replace
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace.g_file_replace.html
	//
	Replace(string, bool, FileCreateFlags, Cancellable) (FileOutputStream, error)
	// ReplaceAsync wraps g_file_replace_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_async.g_file_replace_async.html
	//
	ReplaceAsync(string, bool, FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// ReplaceContents wraps g_file_replace_contents
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_contents.g_file_replace_contents.html
	//
	ReplaceContents(string, string, bool, FileCreateFlags, Cancellable) (string, bool, error)
	// ReplaceContentsAsync wraps g_file_replace_contents_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_contents_async.g_file_replace_contents_async.html
	//
	ReplaceContentsAsync(string, string, bool, FileCreateFlags, Cancellable, AsyncReadyCallback)
	// ReplaceContentsBytesAsync wraps g_file_replace_contents_bytes_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_contents_bytes_async.g_file_replace_contents_bytes_async.html
	//
	ReplaceContentsBytesAsync(*glib.Bytes, string, bool, FileCreateFlags, Cancellable, AsyncReadyCallback)
	// ReplaceContentsFinish wraps g_file_replace_contents_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_contents_finish.g_file_replace_contents_finish.html
	//
	ReplaceContentsFinish(AsyncResult) (string, bool, error)
	// ReplaceFinish wraps g_file_replace_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_finish.g_file_replace_finish.html
	//
	ReplaceFinish(AsyncResult) (FileOutputStream, error)
	// ReplaceReadwrite wraps g_file_replace_readwrite
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite.g_file_replace_readwrite.html
	//
	ReplaceReadwrite(string, bool, FileCreateFlags, Cancellable) (FileIOStream, error)
	// ReplaceReadwriteAsync wraps g_file_replace_readwrite_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite_async.g_file_replace_readwrite_async.html
	//
	ReplaceReadwriteAsync(string, bool, FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// ReplaceReadwriteFinish wraps g_file_replace_readwrite_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite_finish.g_file_replace_readwrite_finish.html
	//
	ReplaceReadwriteFinish(AsyncResult) (FileIOStream, error)
	// ResolveRelativePath wraps g_file_resolve_relative_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_resolve_relative_path.g_file_resolve_relative_path.html
	//
	ResolveRelativePath(string) File
	// SetAttributeByteString wraps g_file_set_attribute_byte_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_byte_string.g_file_set_attribute_byte_string.html
	//
	SetAttributeByteString(string, string, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeInt32 wraps g_file_set_attribute_int32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_int32.g_file_set_attribute_int32.html
	//
	SetAttributeInt32(string, int32, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeInt64 wraps g_file_set_attribute_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_int64.g_file_set_attribute_int64.html
	//
	SetAttributeInt64(string, int64, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeString wraps g_file_set_attribute_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_string.g_file_set_attribute_string.html
	//
	SetAttributeString(string, string, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeUint32 wraps g_file_set_attribute_uint32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_uint32.g_file_set_attribute_uint32.html
	//
	SetAttributeUint32(string, uint32, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeUint64 wraps g_file_set_attribute_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attribute_uint64.g_file_set_attribute_uint64.html
	//
	SetAttributeUint64(string, uint64, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributesAsync wraps g_file_set_attributes_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attributes_async.g_file_set_attributes_async.html
	//
	SetAttributesAsync(FileInfo, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// SetAttributesFinish wraps g_file_set_attributes_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attributes_finish.g_file_set_attributes_finish.html
	//
	SetAttributesFinish(AsyncResult) (FileInfo, bool, error)
	// SetAttributesFromInfo wraps g_file_set_attributes_from_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_attributes_from_info.g_file_set_attributes_from_info.html
	//
	SetAttributesFromInfo(FileInfo, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetDisplayName wraps g_file_set_display_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_display_name.g_file_set_display_name.html
	//
	SetDisplayName(string, Cancellable) (File, error)
	// SetDisplayNameAsync wraps g_file_set_display_name_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_display_name_async.g_file_set_display_name_async.html
	//
	SetDisplayNameAsync(string, int32, Cancellable, AsyncReadyCallback)
	// SetDisplayNameFinish wraps g_file_set_display_name_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_set_display_name_finish.g_file_set_display_name_finish.html
	//
	SetDisplayNameFinish(AsyncResult) (File, error)
	// StartMountable wraps g_file_start_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_start_mountable.g_file_start_mountable.html
	//
	StartMountable(DriveStartFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StartMountableFinish wraps g_file_start_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_start_mountable_finish.g_file_start_mountable_finish.html
	//
	StartMountableFinish(AsyncResult) (bool, error)
	// StopMountable wraps g_file_stop_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_stop_mountable.g_file_stop_mountable.html
	//
	StopMountable(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StopMountableFinish wraps g_file_stop_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_stop_mountable_finish.g_file_stop_mountable_finish.html
	//
	StopMountableFinish(AsyncResult) (bool, error)
	// SupportsThreadContexts wraps g_file_supports_thread_contexts
	// 
	// see also https://docs.gtk.org/gio/method.g_file_supports_thread_contexts.g_file_supports_thread_contexts.html
	//
	SupportsThreadContexts() bool
	// Trash wraps g_file_trash
	// 
	// see also https://docs.gtk.org/gio/method.g_file_trash.g_file_trash.html
	//
	Trash(Cancellable) (bool, error)
	// TrashAsync wraps g_file_trash_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_trash_async.g_file_trash_async.html
	//
	TrashAsync(int32, Cancellable, AsyncReadyCallback)
	// TrashFinish wraps g_file_trash_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_trash_finish.g_file_trash_finish.html
	//
	TrashFinish(AsyncResult) (bool, error)
	// UnmountMountable wraps g_file_unmount_mountable
	// 
	// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable.g_file_unmount_mountable.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation() instead.
	UnmountMountable(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// UnmountMountableFinish wraps g_file_unmount_mountable_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_finish.g_file_unmount_mountable_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation_finish()
	//   instead.
	UnmountMountableFinish(AsyncResult) (bool, error)
	// UnmountMountableWithOperation wraps g_file_unmount_mountable_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_with_operation.g_file_unmount_mountable_with_operation.html
	//
	UnmountMountableWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// UnmountMountableWithOperationFinish wraps g_file_unmount_mountable_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_with_operation_finish.g_file_unmount_mountable_with_operation_finish.html
	//
	UnmountMountableWithOperationFinish(AsyncResult) (bool, error)
}

var _ File = (*FileInstance)(nil)

func unsafeWrapFile(base *gobject.ObjectInstance) *FileInstance {
	return &FileInstance{
		Instance: *base,
	}
}

func marshalFileInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (f *FileInstance) upcastToGFile() *FileInstance {
	return f
}

// UnsafeFileFromGlibNone is used to convert raw GFile pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileFromGlibNone(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibNone(c).(File)
}

// UnsafeFileFromGlibFull is used to convert raw GFile pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileFromGlibFull(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibFull(c).(File)
}

// UnsafeFileFromGlibBorrow is used to convert raw GFile pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileFromGlibBorrow(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibBorrow(c).(File)
}

// UnsafeFileToGlibNone is used to convert the instance to it's C value GFile. This is used by the bindings internally.
func UnsafeFileToGlibNone(c File) unsafe.Pointer {
	i := c.upcastToGFile()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeFileToGlibFull is used to convert the instance to it's C value GFile, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileToGlibFull(c File) unsafe.Pointer {
	i := c.upcastToGFile()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewFileBuildFilenamev wraps g_file_new_build_filenamev
// 
// see also https://docs.gtk.org/gio/func.g_file_new_build_filenamev.html
//
func NewFileBuildFilenamev(args []string) File {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.GFile  // return, full, converted

	_ = args
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_file_new_build_filenamev(carg1)
	runtime.KeepAlive(args)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForCommandlineArg wraps g_file_new_for_commandline_arg
// 
// see also https://docs.gtk.org/gio/func.g_file_new_for_commandline_arg.html
//
func NewFileForCommandlineArg(arg string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_commandline_arg(carg1)
	runtime.KeepAlive(arg)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForCommandlineArgAndCwd wraps g_file_new_for_commandline_arg_and_cwd
// 
// see also https://docs.gtk.org/gio/func.g_file_new_for_commandline_arg_and_cwd.html
//
func NewFileForCommandlineArgAndCwd(arg string, cwd string) File {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(cwd)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_file_new_for_commandline_arg_and_cwd(carg1, carg2)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(cwd)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForPath wraps g_file_new_for_path
// 
// see also https://docs.gtk.org/gio/func.g_file_new_for_path.html
//
func NewFileForPath(path string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_path(carg1)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForURI wraps g_file_new_for_uri
// 
// see also https://docs.gtk.org/gio/func.g_file_new_for_uri.html
//
func NewFileForURI(uri string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_uri(carg1)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileTmp wraps g_file_new_tmp
// 
// see also https://docs.gtk.org/gio/func.g_file_new_tmp.html
//
func NewFileTmp(tmpl string) (FileIOStream, File, error) {
	var carg1 *C.char          // in, none, string, nullable-string
	var carg2 *C.GFileIOStream // out, full, converted
	var cret  *C.GFile         // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_new_tmp(carg1, &carg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var iostream FileIOStream
	var goret    File
	var _goerr   error

	iostream = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(carg2))
	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return iostream, goret, _goerr
}

// NewFileTmpAsync wraps g_file_new_tmp_async
// 
// see also https://docs.gtk.org/gio/func.g_file_new_tmp_async.html
//
func NewFileTmpAsync(tmpl string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_new_tmp_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirAsync wraps g_file_new_tmp_dir_async
// 
// see also https://docs.gtk.org/gio/func.g_file_new_tmp_dir_async.html
//
func NewFileTmpDirAsync(tmpl string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_new_tmp_dir_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirFinish wraps g_file_new_tmp_dir_finish
// 
// see also https://docs.gtk.org/gio/func.g_file_new_tmp_dir_finish.html
//
func NewFileTmpDirFinish(result AsyncResult) (File, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_new_tmp_dir_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewFileTmpFinish wraps g_file_new_tmp_finish
// 
// see also https://docs.gtk.org/gio/func.g_file_new_tmp_finish.html
//
func NewFileTmpFinish(result AsyncResult) (FileIOStream, File, error) {
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 *C.GFileIOStream // out, full, converted
	var cret  *C.GFile         // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_new_tmp_finish(carg1, &carg2, &_cerr)
	runtime.KeepAlive(result)

	var iostream FileIOStream
	var goret    File
	var _goerr   error

	iostream = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(carg2))
	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return iostream, goret, _goerr
}

// FileParseName wraps g_file_parse_name
// 
// see also https://docs.gtk.org/gio/func.g_file_parse_name.html
//
func FileParseName(parseName string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_parse_name(carg1)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AppendTo wraps g_file_append_to
// 
// see also https://docs.gtk.org/gio/method.g_file_append_to.g_file_append_to.html
//
func (file *FileInstance) AppendTo(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 C.GFileCreateFlags   // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_append_to(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppendToAsync wraps g_file_append_to_async
// 
// see also https://docs.gtk.org/gio/method.g_file_append_to_async.g_file_append_to_async.html
//
func (file *FileInstance) AppendToAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_append_to_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppendToFinish wraps g_file_append_to_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_append_to_finish.g_file_append_to_finish.html
//
func (file *FileInstance) AppendToFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_append_to_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// BuildAttributeListForCopy wraps g_file_build_attribute_list_for_copy
// 
// see also https://docs.gtk.org/gio/method.g_file_build_attribute_list_for_copy.g_file_build_attribute_list_for_copy.html
//
func (file *FileInstance) BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (string, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 C.GFileCopyFlags // in, none, casted
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.char          // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCopyFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_build_attribute_list_for_copy(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopyAttributes wraps g_file_copy_attributes
// 
// see also https://docs.gtk.org/gio/method.g_file_copy_attributes.g_file_copy_attributes.html
//
func (source *FileInstance) CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GFile         // in, none, converted
	var carg2 C.GFileCopyFlags // in, none, casted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(source))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(destination))
	carg2 = C.GFileCopyFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_copy_attributes(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(source)
	runtime.KeepAlive(destination)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopyFinish wraps g_file_copy_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_copy_finish.g_file_copy_finish.html
//
func (file *FileInstance) CopyFinish(res AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_copy_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Create wraps g_file_create
// 
// see also https://docs.gtk.org/gio/method.g_file_create.g_file_create.html
//
func (file *FileInstance) Create(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 C.GFileCreateFlags   // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_create(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateAsync wraps g_file_create_async
// 
// see also https://docs.gtk.org/gio/method.g_file_create_async.g_file_create_async.html
//
func (file *FileInstance) CreateAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_create_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CreateFinish wraps g_file_create_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_create_finish.g_file_create_finish.html
//
func (file *FileInstance) CreateFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_create_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateReadwrite wraps g_file_create_readwrite
// 
// see also https://docs.gtk.org/gio/method.g_file_create_readwrite.g_file_create_readwrite.html
//
func (file *FileInstance) CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 C.GFileCreateFlags // in, none, casted
	var carg2 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileIOStream   // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_create_readwrite(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateReadwriteAsync wraps g_file_create_readwrite_async
// 
// see also https://docs.gtk.org/gio/method.g_file_create_readwrite_async.g_file_create_readwrite_async.html
//
func (file *FileInstance) CreateReadwriteAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_create_readwrite_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CreateReadwriteFinish wraps g_file_create_readwrite_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_create_readwrite_finish.g_file_create_readwrite_finish.html
//
func (file *FileInstance) CreateReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_create_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Delete wraps g_file_delete
// 
// see also https://docs.gtk.org/gio/method.g_file_delete.g_file_delete.html
//
func (file *FileInstance) Delete(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_delete(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DeleteAsync wraps g_file_delete_async
// 
// see also https://docs.gtk.org/gio/method.g_file_delete_async.g_file_delete_async.html
//
func (file *FileInstance) DeleteAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_delete_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// DeleteFinish wraps g_file_delete_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_delete_finish.g_file_delete_finish.html
//
func (file *FileInstance) DeleteFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_delete_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Dup wraps g_file_dup
// 
// see also https://docs.gtk.org/gio/method.g_file_dup.g_file_dup.html
//
func (file *FileInstance) Dup() File {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_dup(carg0)
	runtime.KeepAlive(file)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// EjectMountable wraps g_file_eject_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_eject_mountable.g_file_eject_mountable.html
//
//
// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation() instead.
func (file *FileInstance) EjectMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_eject_mountable(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectMountableFinish wraps g_file_eject_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_finish.g_file_eject_mountable_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation_finish()
//   instead.
func (file *FileInstance) EjectMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_eject_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectMountableWithOperation wraps g_file_eject_mountable_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_with_operation.g_file_eject_mountable_with_operation.html
//
func (file *FileInstance) EjectMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_eject_mountable_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectMountableWithOperationFinish wraps g_file_eject_mountable_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_eject_mountable_with_operation_finish.g_file_eject_mountable_with_operation_finish.html
//
func (file *FileInstance) EjectMountableWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_eject_mountable_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateChildren wraps g_file_enumerate_children
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerate_children.g_file_enumerate_children.html
//
func (file *FileInstance) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileEnumerator, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GFileEnumerator    // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerate_children(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileEnumerator
	var _goerr error

	goret = UnsafeFileEnumeratorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateChildrenAsync wraps g_file_enumerate_children_async
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerate_children_async.g_file_enumerate_children_async.html
//
func (file *FileInstance) EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerate_children_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EnumerateChildrenFinish wraps g_file_enumerate_children_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerate_children_finish.g_file_enumerate_children_finish.html
//
func (file *FileInstance) EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GFileEnumerator // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_enumerate_children_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileEnumerator
	var _goerr error

	goret = UnsafeFileEnumeratorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_file_equal
// 
// see also https://docs.gtk.org/gio/method.g_file_equal.g_file_equal.html
//
func (file1 *FileInstance) Equal(file2 File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file1))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file2))

	cret = C.g_file_equal(carg0, carg1)
	runtime.KeepAlive(file1)
	runtime.KeepAlive(file2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// FindEnclosingMount wraps g_file_find_enclosing_mount
// 
// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount.g_file_find_enclosing_mount.html
//
func (file *FileInstance) FindEnclosingMount(cancellable Cancellable) (Mount, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GMount       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_find_enclosing_mount(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  Mount
	var _goerr error

	goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FindEnclosingMountAsync wraps g_file_find_enclosing_mount_async
// 
// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount_async.g_file_find_enclosing_mount_async.html
//
func (file *FileInstance) FindEnclosingMountAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_find_enclosing_mount_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FindEnclosingMountFinish wraps g_file_find_enclosing_mount_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_find_enclosing_mount_finish.g_file_find_enclosing_mount_finish.html
//
func (file *FileInstance) FindEnclosingMountFinish(res AsyncResult) (Mount, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GMount       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_find_enclosing_mount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  Mount
	var _goerr error

	goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBasename wraps g_file_get_basename
// 
// see also https://docs.gtk.org/gio/method.g_file_get_basename.g_file_get_basename.html
//
func (file *FileInstance) GetBasename() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_basename(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetChild wraps g_file_get_child
// 
// see also https://docs.gtk.org/gio/method.g_file_get_child.g_file_get_child.html
//
func (file *FileInstance) GetChild(name string) File {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_child(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(name)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetChildForDisplayName wraps g_file_get_child_for_display_name
// 
// see also https://docs.gtk.org/gio/method.g_file_get_child_for_display_name.g_file_get_child_for_display_name.html
//
func (file *FileInstance) GetChildForDisplayName(displayName string) (File, error) {
	var carg0 *C.GFile  // in, none, converted
	var carg1 *C.char   // in, none, string
	var cret  *C.GFile  // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_child_for_display_name(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetParent wraps g_file_get_parent
// 
// see also https://docs.gtk.org/gio/method.g_file_get_parent.g_file_get_parent.html
//
func (file *FileInstance) GetParent() File {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.GFile // return, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_parent(carg0)
	runtime.KeepAlive(file)

	var goret File

	if cret != nil {
		goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetParseName wraps g_file_get_parse_name
// 
// see also https://docs.gtk.org/gio/method.g_file_get_parse_name.g_file_get_parse_name.html
//
func (file *FileInstance) GetParseName() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_parse_name(carg0)
	runtime.KeepAlive(file)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetPath wraps g_file_get_path
// 
// see also https://docs.gtk.org/gio/method.g_file_get_path.g_file_get_path.html
//
func (file *FileInstance) GetPath() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_path(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetRelativePath wraps g_file_get_relative_path
// 
// see also https://docs.gtk.org/gio/method.g_file_get_relative_path.g_file_get_relative_path.html
//
func (parent *FileInstance) GetRelativePath(descendant File) string {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(parent))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(descendant))

	cret = C.g_file_get_relative_path(carg0, carg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(descendant)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetURI wraps g_file_get_uri
// 
// see also https://docs.gtk.org/gio/method.g_file_get_uri.g_file_get_uri.html
//
func (file *FileInstance) GetURI() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_uri(carg0)
	runtime.KeepAlive(file)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetURIScheme wraps g_file_get_uri_scheme
// 
// see also https://docs.gtk.org/gio/method.g_file_get_uri_scheme.g_file_get_uri_scheme.html
//
func (file *FileInstance) GetURIScheme() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable-string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_uri_scheme(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// HasParent wraps g_file_has_parent
// 
// see also https://docs.gtk.org/gio/method.g_file_has_parent.g_file_has_parent.html
//
func (file *FileInstance) HasParent(parent File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted, nullable
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if parent != nil {
		carg1 = (*C.GFile)(UnsafeFileToGlibNone(parent))
	}

	cret = C.g_file_has_parent(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(parent)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasPrefix wraps g_file_has_prefix
// 
// see also https://docs.gtk.org/gio/method.g_file_has_prefix.g_file_has_prefix.html
//
func (file *FileInstance) HasPrefix(prefix File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(prefix))

	cret = C.g_file_has_prefix(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(prefix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasURIScheme wraps g_file_has_uri_scheme
// 
// see also https://docs.gtk.org/gio/method.g_file_has_uri_scheme.g_file_has_uri_scheme.html
//
func (file *FileInstance) HasURIScheme(uriScheme string) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_has_uri_scheme(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(uriScheme)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsNative wraps g_file_is_native
// 
// see also https://docs.gtk.org/gio/method.g_file_is_native.g_file_is_native.html
//
func (file *FileInstance) IsNative() bool {
	var carg0 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_is_native(carg0)
	runtime.KeepAlive(file)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadBytes wraps g_file_load_bytes
// 
// see also https://docs.gtk.org/gio/method.g_file_load_bytes.g_file_load_bytes.html
//
func (file *FileInstance) LoadBytes(cancellable Cancellable) (string, *glib.Bytes, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_load_bytes(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var etagOut string
	var goret   *glib.Bytes
	var _goerr  error

	if carg2 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return etagOut, goret, _goerr
}

// LoadBytesAsync wraps g_file_load_bytes_async
// 
// see also https://docs.gtk.org/gio/method.g_file_load_bytes_async.g_file_load_bytes_async.html
//
func (file *FileInstance) LoadBytesAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_load_bytes_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadBytesFinish wraps g_file_load_bytes_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_load_bytes_finish.g_file_load_bytes_finish.html
//
func (file *FileInstance) LoadBytesFinish(result AsyncResult) (string, *glib.Bytes, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_load_bytes_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var etagOut string
	var goret   *glib.Bytes
	var _goerr  error

	if carg2 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return etagOut, goret, _goerr
}

// LoadContents wraps g_file_load_contents
// 
// see also https://docs.gtk.org/gio/method.g_file_load_contents.g_file_load_contents.html
//
func (file *FileInstance) LoadContents(cancellable Cancellable) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_load_contents(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// LoadContentsAsync wraps g_file_load_contents_async
// 
// see also https://docs.gtk.org/gio/method.g_file_load_contents_async.g_file_load_contents_async.html
//
func (file *FileInstance) LoadContentsAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_load_contents_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadContentsFinish wraps g_file_load_contents_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_load_contents_finish.g_file_load_contents_finish.html
//
func (file *FileInstance) LoadContentsFinish(res AsyncResult) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_load_contents_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// LoadPartialContentsFinish wraps g_file_load_partial_contents_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_load_partial_contents_finish.g_file_load_partial_contents_finish.html
//
func (file *FileInstance) LoadPartialContentsFinish(res AsyncResult) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_load_partial_contents_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// MakeDirectory wraps g_file_make_directory
// 
// see also https://docs.gtk.org/gio/method.g_file_make_directory.g_file_make_directory.html
//
func (file *FileInstance) MakeDirectory(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_directory(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeDirectoryAsync wraps g_file_make_directory_async
// 
// see also https://docs.gtk.org/gio/method.g_file_make_directory_async.g_file_make_directory_async.html
//
func (file *FileInstance) MakeDirectoryAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_make_directory_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MakeDirectoryFinish wraps g_file_make_directory_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_make_directory_finish.g_file_make_directory_finish.html
//
func (file *FileInstance) MakeDirectoryFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_make_directory_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeDirectoryWithParents wraps g_file_make_directory_with_parents
// 
// see also https://docs.gtk.org/gio/method.g_file_make_directory_with_parents.g_file_make_directory_with_parents.html
//
func (file *FileInstance) MakeDirectoryWithParents(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_directory_with_parents(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeSymbolicLink wraps g_file_make_symbolic_link
// 
// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link.g_file_make_symbolic_link.html
//
func (file *FileInstance) MakeSymbolicLink(symlinkValue string, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_symbolic_link(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeSymbolicLinkAsync wraps g_file_make_symbolic_link_async
// 
// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link_async.g_file_make_symbolic_link_async.html
//
func (file *FileInstance) MakeSymbolicLinkAsync(symlinkValue string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_make_symbolic_link_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MakeSymbolicLinkFinish wraps g_file_make_symbolic_link_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_make_symbolic_link_finish.g_file_make_symbolic_link_finish.html
//
func (file *FileInstance) MakeSymbolicLinkFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_make_symbolic_link_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MeasureDiskUsageFinish wraps g_file_measure_disk_usage_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_measure_disk_usage_finish.g_file_measure_disk_usage_finish.html
//
func (file *FileInstance) MeasureDiskUsageFinish(result AsyncResult) (uint64, uint64, uint64, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.guint64       // out, full, casted
	var carg3 C.guint64       // out, full, casted
	var carg4 C.guint64       // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_measure_disk_usage_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var diskUsage uint64
	var numDirs   uint64
	var numFiles  uint64
	var goret     bool
	var _goerr    error

	diskUsage = uint64(carg2)
	numDirs = uint64(carg3)
	numFiles = uint64(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return diskUsage, numDirs, numFiles, goret, _goerr
}

// Monitor wraps g_file_monitor
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor.g_file_monitor.html
//
func (file *FileInstance) Monitor(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MonitorDirectory wraps g_file_monitor_directory
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_directory.g_file_monitor_directory.html
//
func (file *FileInstance) MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor_directory(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MonitorFile wraps g_file_monitor_file
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_file.g_file_monitor_file.html
//
func (file *FileInstance) MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor_file(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MountEnclosingVolume wraps g_file_mount_enclosing_volume
// 
// see also https://docs.gtk.org/gio/method.g_file_mount_enclosing_volume.g_file_mount_enclosing_volume.html
//
func (location *FileInstance) MountEnclosingVolume(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(location))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_mount_enclosing_volume(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(location)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountEnclosingVolumeFinish wraps g_file_mount_enclosing_volume_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_mount_enclosing_volume_finish.g_file_mount_enclosing_volume_finish.html
//
func (location *FileInstance) MountEnclosingVolumeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(location))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_mount_enclosing_volume_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(location)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MountMountable wraps g_file_mount_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_mount_mountable.g_file_mount_mountable.html
//
func (file *FileInstance) MountMountable(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_mount_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountMountableFinish wraps g_file_mount_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_mount_mountable_finish.g_file_mount_mountable_finish.html
//
func (file *FileInstance) MountMountableFinish(result AsyncResult) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_mount_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MoveFinish wraps g_file_move_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_move_finish.g_file_move_finish.html
//
func (file *FileInstance) MoveFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_move_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// OpenReadwrite wraps g_file_open_readwrite
// 
// see also https://docs.gtk.org/gio/method.g_file_open_readwrite.g_file_open_readwrite.html
//
func (file *FileInstance) OpenReadwrite(cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_open_readwrite(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// OpenReadwriteAsync wraps g_file_open_readwrite_async
// 
// see also https://docs.gtk.org/gio/method.g_file_open_readwrite_async.g_file_open_readwrite_async.html
//
func (file *FileInstance) OpenReadwriteAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_open_readwrite_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// OpenReadwriteFinish wraps g_file_open_readwrite_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_open_readwrite_finish.g_file_open_readwrite_finish.html
//
func (file *FileInstance) OpenReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_open_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PeekPath wraps g_file_peek_path
// 
// see also https://docs.gtk.org/gio/method.g_file_peek_path.g_file_peek_path.html
//
func (file *FileInstance) PeekPath() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, none, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_peek_path(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PollMountable wraps g_file_poll_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_poll_mountable.g_file_poll_mountable.html
//
func (file *FileInstance) PollMountable(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_poll_mountable(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// PollMountableFinish wraps g_file_poll_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_poll_mountable_finish.g_file_poll_mountable_finish.html
//
func (file *FileInstance) PollMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_poll_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryDefaultHandler wraps g_file_query_default_handler
// 
// see also https://docs.gtk.org/gio/method.g_file_query_default_handler.g_file_query_default_handler.html
//
func (file *FileInstance) QueryDefaultHandler(cancellable Cancellable) (AppInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_default_handler(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryDefaultHandlerAsync wraps g_file_query_default_handler_async
// 
// see also https://docs.gtk.org/gio/method.g_file_query_default_handler_async.g_file_query_default_handler_async.html
//
func (file *FileInstance) QueryDefaultHandlerAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_default_handler_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryDefaultHandlerFinish wraps g_file_query_default_handler_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_query_default_handler_finish.g_file_query_default_handler_finish.html
//
func (file *FileInstance) QueryDefaultHandlerFinish(result AsyncResult) (AppInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_query_default_handler_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryExists wraps g_file_query_exists
// 
// see also https://docs.gtk.org/gio/method.g_file_query_exists.g_file_query_exists.html
//
func (file *FileInstance) QueryExists(cancellable Cancellable) bool {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_exists(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// QueryFileType wraps g_file_query_file_type
// 
// see also https://docs.gtk.org/gio/method.g_file_query_file_type.g_file_query_file_type.html
//
func (file *FileInstance) QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileQueryInfoFlags // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  C.GFileType           // return, none, casted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_file_type(carg0, carg1, carg2)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret FileType

	goret = FileType(cret)

	return goret
}

// QueryFilesystemInfo wraps g_file_query_filesystem_info
// 
// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info.g_file_query_filesystem_info.html
//
func (file *FileInstance) QueryFilesystemInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_filesystem_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryFilesystemInfoAsync wraps g_file_query_filesystem_info_async
// 
// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info_async.g_file_query_filesystem_info_async.html
//
func (file *FileInstance) QueryFilesystemInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_filesystem_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryFilesystemInfoFinish wraps g_file_query_filesystem_info_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_query_filesystem_info_finish.g_file_query_filesystem_info_finish.html
//
func (file *FileInstance) QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_query_filesystem_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfo wraps g_file_query_info
// 
// see also https://docs.gtk.org/gio/method.g_file_query_info.g_file_query_info.html
//
func (file *FileInstance) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GFileInfo          // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_info(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_query_info_async
// 
// see also https://docs.gtk.org/gio/method.g_file_query_info_async.g_file_query_info_async.html
//
func (file *FileInstance) QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_query_info_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_query_info_finish.g_file_query_info_finish.html
//
func (file *FileInstance) QueryInfoFinish(res AsyncResult) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QuerySettableAttributes wraps g_file_query_settable_attributes
// 
// see also https://docs.gtk.org/gio/method.g_file_query_settable_attributes.g_file_query_settable_attributes.html
//
func (file *FileInstance) QuerySettableAttributes(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var carg0 *C.GFile                  // in, none, converted
	var carg1 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GFileAttributeInfoList // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_settable_attributes(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  *FileAttributeInfoList
	var _goerr error

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryWritableNamespaces wraps g_file_query_writable_namespaces
// 
// see also https://docs.gtk.org/gio/method.g_file_query_writable_namespaces.g_file_query_writable_namespaces.html
//
func (file *FileInstance) QueryWritableNamespaces(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var carg0 *C.GFile                  // in, none, converted
	var carg1 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GFileAttributeInfoList // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_writable_namespaces(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  *FileAttributeInfoList
	var _goerr error

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Read wraps g_file_read
// 
// see also https://docs.gtk.org/gio/method.g_file_read.g_file_read.html
//
func (file *FileInstance) Read(cancellable Cancellable) (FileInputStream, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileInputStream // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_read(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  FileInputStream
	var _goerr error

	goret = UnsafeFileInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadAsync wraps g_file_read_async
// 
// see also https://docs.gtk.org/gio/method.g_file_read_async.g_file_read_async.html
//
func (file *FileInstance) ReadAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_read_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadFinish wraps g_file_read_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_read_finish.g_file_read_finish.html
//
func (file *FileInstance) ReadFinish(res AsyncResult) (FileInputStream, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var cret  *C.GFileInputStream // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_read_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInputStream
	var _goerr error

	goret = UnsafeFileInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Replace wraps g_file_replace
// 
// see also https://docs.gtk.org/gio/method.g_file_replace.g_file_replace.html
//
func (file *FileInstance) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.char              // in, none, string, nullable-string
	var carg2 C.gboolean           // in
	var carg3 C.GFileCreateFlags   // in, none, casted
	var carg4 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceAsync wraps g_file_replace_async
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_async.g_file_replace_async.html
//
func (file *FileInstance) ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.gboolean            // in
	var carg3 C.GFileCreateFlags    // in, none, casted
	var carg4 C.int                 // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	carg4 = C.int(ioPriority)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContents wraps g_file_replace_contents
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_contents.g_file_replace_contents.html
//
func (file *FileInstance) ReplaceContents(contents string, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (string, bool, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.char            // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 *C.char            // in, none, string, nullable-string
	var carg4 C.gboolean         // in
	var carg5 C.GFileCreateFlags // in, none, casted
	var carg7 *C.GCancellable    // in, none, converted, nullable
	var carg6 *C.char            // out, full, string, nullable-string
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	_ = contents
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const char*) because of unimplemented: non-fixed size array")
	if etag != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if makeBackup {
		carg4 = C.TRUE
	}
	carg5 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg7 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace_contents(carg0, carg1, carg2, carg3, carg4, carg5, &carg6, carg7, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var newEtag string
	var goret   bool
	var _goerr  error

	if carg6 != nil {
		newEtag = C.GoString((*C.char)(unsafe.Pointer(carg6)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return newEtag, goret, _goerr
}

// ReplaceContentsAsync wraps g_file_replace_contents_async
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_contents_async.g_file_replace_contents_async.html
//
func (file *FileInstance) ReplaceContentsAsync(contents string, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 *C.char               // in, none, string, nullable-string
	var carg4 C.gboolean            // in
	var carg5 C.GFileCreateFlags    // in, none, casted
	var carg6 *C.GCancellable       // in, none, converted, nullable
	var carg7 C.GAsyncReadyCallback // callback, scope: async, closure: carg8, nullable
	var carg8 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	_ = contents
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const char*) because of unimplemented: non-fixed size array")
	if etag != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if makeBackup {
		carg4 = C.TRUE
	}
	carg5 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg7 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg8 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_contents_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContentsBytesAsync wraps g_file_replace_contents_bytes_async
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_contents_bytes_async.g_file_replace_contents_bytes_async.html
//
func (file *FileInstance) ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GBytes             // in, none, converted
	var carg2 *C.char               // in, none, string, nullable-string
	var carg3 C.gboolean            // in
	var carg4 C.GFileCreateFlags    // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(contents))
	if etag != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if makeBackup {
		carg3 = C.TRUE
	}
	carg4 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_contents_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContentsFinish wraps g_file_replace_contents_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_contents_finish.g_file_replace_contents_finish.html
//
func (file *FileInstance) ReplaceContentsFinish(res AsyncResult) (string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_contents_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var newEtag string
	var goret   bool
	var _goerr  error

	if carg2 != nil {
		newEtag = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return newEtag, goret, _goerr
}

// ReplaceFinish wraps g_file_replace_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_finish.g_file_replace_finish.html
//
func (file *FileInstance) ReplaceFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceReadwrite wraps g_file_replace_readwrite
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite.g_file_replace_readwrite.html
//
func (file *FileInstance) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string
	var carg2 C.gboolean         // in
	var carg3 C.GFileCreateFlags // in, none, casted
	var carg4 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileIOStream   // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace_readwrite(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceReadwriteAsync wraps g_file_replace_readwrite_async
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite_async.g_file_replace_readwrite_async.html
//
func (file *FileInstance) ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.gboolean            // in
	var carg3 C.GFileCreateFlags    // in, none, casted
	var carg4 C.int                 // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	carg4 = C.int(ioPriority)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_readwrite_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceReadwriteFinish wraps g_file_replace_readwrite_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_replace_readwrite_finish.g_file_replace_readwrite_finish.html
//
func (file *FileInstance) ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResolveRelativePath wraps g_file_resolve_relative_path
// 
// see also https://docs.gtk.org/gio/method.g_file_resolve_relative_path.g_file_resolve_relative_path.html
//
func (file *FileInstance) ResolveRelativePath(relativePath string) File {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_resolve_relative_path(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(relativePath)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetAttributeByteString wraps g_file_set_attribute_byte_string
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_byte_string.g_file_set_attribute_byte_string.html
//
func (file *FileInstance) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_byte_string(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeInt32 wraps g_file_set_attribute_int32
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_int32.g_file_set_attribute_int32.html
//
func (file *FileInstance) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.gint32              // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint32(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_int32(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeInt64 wraps g_file_set_attribute_int64
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_int64.g_file_set_attribute_int64.html
//
func (file *FileInstance) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.gint64              // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_int64(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeString wraps g_file_set_attribute_string
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_string.g_file_set_attribute_string.html
//
func (file *FileInstance) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_string(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeUint32 wraps g_file_set_attribute_uint32
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_uint32.g_file_set_attribute_uint32.html
//
func (file *FileInstance) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.guint32             // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint32(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_uint32(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeUint64 wraps g_file_set_attribute_uint64
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attribute_uint64.g_file_set_attribute_uint64.html
//
func (file *FileInstance) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.guint64             // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_uint64(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributesAsync wraps g_file_set_attributes_async
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attributes_async.g_file_set_attributes_async.html
//
func (file *FileInstance) SetAttributesAsync(info FileInfo, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GFileInfo          // in, none, converted
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_set_attributes_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SetAttributesFinish wraps g_file_set_attributes_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attributes_finish.g_file_set_attributes_finish.html
//
func (file *FileInstance) SetAttributesFinish(result AsyncResult) (FileInfo, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.GFileInfo    // out, full, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_set_attributes_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var info   FileInfo
	var goret  bool
	var _goerr error

	info = UnsafeFileInfoFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return info, goret, _goerr
}

// SetAttributesFromInfo wraps g_file_set_attributes_from_info
// 
// see also https://docs.gtk.org/gio/method.g_file_set_attributes_from_info.g_file_set_attributes_from_info.html
//
func (file *FileInstance) SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GFileInfo          // in, none, converted
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attributes_from_info(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDisplayName wraps g_file_set_display_name
// 
// see also https://docs.gtk.org/gio/method.g_file_set_display_name.g_file_set_display_name.html
//
func (file *FileInstance) SetDisplayName(displayName string, cancellable Cancellable) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_display_name(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(cancellable)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDisplayNameAsync wraps g_file_set_display_name_async
// 
// see also https://docs.gtk.org/gio/method.g_file_set_display_name_async.g_file_set_display_name_async.html
//
func (file *FileInstance) SetDisplayNameAsync(displayName string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_set_display_name_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SetDisplayNameFinish wraps g_file_set_display_name_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_set_display_name_finish.g_file_set_display_name_finish.html
//
func (file *FileInstance) SetDisplayNameFinish(res AsyncResult) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_set_display_name_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// StartMountable wraps g_file_start_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_start_mountable.g_file_start_mountable.html
//
func (file *FileInstance) StartMountable(flags DriveStartFlags, startOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GDriveStartFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(startOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_start_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StartMountableFinish wraps g_file_start_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_start_mountable_finish.g_file_start_mountable_finish.html
//
func (file *FileInstance) StartMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_start_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// StopMountable wraps g_file_stop_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_stop_mountable.g_file_stop_mountable.html
//
func (file *FileInstance) StopMountable(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_stop_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StopMountableFinish wraps g_file_stop_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_stop_mountable_finish.g_file_stop_mountable_finish.html
//
func (file *FileInstance) StopMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_stop_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SupportsThreadContexts wraps g_file_supports_thread_contexts
// 
// see also https://docs.gtk.org/gio/method.g_file_supports_thread_contexts.g_file_supports_thread_contexts.html
//
func (file *FileInstance) SupportsThreadContexts() bool {
	var carg0 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_supports_thread_contexts(carg0)
	runtime.KeepAlive(file)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Trash wraps g_file_trash
// 
// see also https://docs.gtk.org/gio/method.g_file_trash.g_file_trash.html
//
func (file *FileInstance) Trash(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_trash(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TrashAsync wraps g_file_trash_async
// 
// see also https://docs.gtk.org/gio/method.g_file_trash_async.g_file_trash_async.html
//
func (file *FileInstance) TrashAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_trash_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// TrashFinish wraps g_file_trash_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_trash_finish.g_file_trash_finish.html
//
func (file *FileInstance) TrashFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_trash_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountMountable wraps g_file_unmount_mountable
// 
// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable.g_file_unmount_mountable.html
//
//
// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation() instead.
func (file *FileInstance) UnmountMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_unmount_mountable(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountMountableFinish wraps g_file_unmount_mountable_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_finish.g_file_unmount_mountable_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation_finish()
//   instead.
func (file *FileInstance) UnmountMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_unmount_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountMountableWithOperation wraps g_file_unmount_mountable_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_with_operation.g_file_unmount_mountable_with_operation.html
//
func (file *FileInstance) UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_unmount_mountable_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountMountableWithOperationFinish wraps g_file_unmount_mountable_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_unmount_mountable_with_operation_finish.g_file_unmount_mountable_with_operation_finish.html
//
func (file *FileInstance) UnmountMountableWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_unmount_mountable_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IconInstance is the instance type used by all types implementing GIcon. It is used internally by the bindings. Users should use the interface [Icon] instead.
type IconInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Icon = (*IconInstance)(nil)

// Icon wraps GIcon
// 
// see also https://docs.gtk.org/gio/interface.Icon.html
//
type Icon interface {
	upcastToGIcon() *IconInstance

	// Equal wraps g_icon_equal
	// 
	// see also https://docs.gtk.org/gio/method.g_icon_equal.g_icon_equal.html
	//
	Equal(Icon) bool
	// String wraps g_icon_to_string
	// 
	// see also https://docs.gtk.org/gio/method.g_icon_to_string.g_icon_to_string.html
	//
	String() string
}

var _ Icon = (*IconInstance)(nil)

func unsafeWrapIcon(base *gobject.ObjectInstance) *IconInstance {
	return &IconInstance{
		Instance: *base,
	}
}

func marshalIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (i *IconInstance) upcastToGIcon() *IconInstance {
	return i
}

// UnsafeIconFromGlibNone is used to convert raw GIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeIconFromGlibNone(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibNone(c).(Icon)
}

// UnsafeIconFromGlibFull is used to convert raw GIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeIconFromGlibFull(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibFull(c).(Icon)
}

// UnsafeIconFromGlibBorrow is used to convert raw GIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeIconFromGlibBorrow(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Icon)
}

// UnsafeIconToGlibNone is used to convert the instance to it's C value GIcon. This is used by the bindings internally.
func UnsafeIconToGlibNone(c Icon) unsafe.Pointer {
	i := c.upcastToGIcon()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeIconToGlibFull is used to convert the instance to it's C value GIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeIconToGlibFull(c Icon) unsafe.Pointer {
	i := c.upcastToGIcon()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewIconForString wraps g_icon_new_for_string
// 
// see also https://docs.gtk.org/gio/func.g_icon_new_for_string.html
//
func NewIconForString(str string) (Icon, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GIcon  // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_icon_new_for_string(carg1, &_cerr)
	runtime.KeepAlive(str)

	var goret  Icon
	var _goerr error

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_icon_equal
// 
// see also https://docs.gtk.org/gio/method.g_icon_equal.g_icon_equal.html
//
func (icon1 *IconInstance) Equal(icon2 Icon) bool {
	var carg0 *C.GIcon   // in, none, converted
	var carg1 *C.GIcon   // in, none, converted, nullable
	var cret  C.gboolean // return

	carg0 = (*C.GIcon)(UnsafeIconToGlibNone(icon1))
	if icon2 != nil {
		carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon2))
	}

	cret = C.g_icon_equal(carg0, carg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// String wraps g_icon_to_string
// 
// see also https://docs.gtk.org/gio/method.g_icon_to_string.g_icon_to_string.html
//
func (icon *IconInstance) String() string {
	var carg0 *C.GIcon // in, none, converted
	var cret  *C.gchar // return, full, string, nullable-string

	carg0 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	cret = C.g_icon_to_string(carg0)
	runtime.KeepAlive(icon)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// InitableInstance is the instance type used by all types implementing GInitable. It is used internally by the bindings. Users should use the interface [Initable] instead.
type InitableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Initable = (*InitableInstance)(nil)

// Initable wraps GInitable
// 
// see also https://docs.gtk.org/gio/interface.Initable.html
//
type Initable interface {
	upcastToGInitable() *InitableInstance

	// Init wraps g_initable_init
	// 
	// see also https://docs.gtk.org/gio/method.g_initable_init.g_initable_init.html
	//
	Init(Cancellable) (bool, error)
}

var _ Initable = (*InitableInstance)(nil)

func unsafeWrapInitable(base *gobject.ObjectInstance) *InitableInstance {
	return &InitableInstance{
		Instance: *base,
	}
}

func marshalInitableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (i *InitableInstance) upcastToGInitable() *InitableInstance {
	return i
}

// UnsafeInitableFromGlibNone is used to convert raw GInitable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInitableFromGlibNone(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibNone(c).(Initable)
}

// UnsafeInitableFromGlibFull is used to convert raw GInitable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInitableFromGlibFull(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibFull(c).(Initable)
}

// UnsafeInitableFromGlibBorrow is used to convert raw GInitable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInitableFromGlibBorrow(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Initable)
}

// UnsafeInitableToGlibNone is used to convert the instance to it's C value GInitable. This is used by the bindings internally.
func UnsafeInitableToGlibNone(c Initable) unsafe.Pointer {
	i := c.upcastToGInitable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeInitableToGlibFull is used to convert the instance to it's C value GInitable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInitableToGlibFull(c Initable) unsafe.Pointer {
	i := c.upcastToGInitable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Init wraps g_initable_init
// 
// see also https://docs.gtk.org/gio/method.g_initable_init.g_initable_init.html
//
func (initable *InitableInstance) Init(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInitable    // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInitable)(UnsafeInitableToGlibNone(initable))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_initable_init(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ListModelInstance is the instance type used by all types implementing GListModel. It is used internally by the bindings. Users should use the interface [ListModel] instead.
type ListModelInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ListModel = (*ListModelInstance)(nil)

// ListModel wraps GListModel
// 
// see also https://docs.gtk.org/gio/interface.ListModel.html
//
type ListModel interface {
	upcastToGListModel() *ListModelInstance

	// GetItemType wraps g_list_model_get_item_type
	// 
	// see also https://docs.gtk.org/gio/method.g_list_model_get_item_type.g_list_model_get_item_type.html
	//
	GetItemType() gobject.Type
	// GetNItems wraps g_list_model_get_n_items
	// 
	// see also https://docs.gtk.org/gio/method.g_list_model_get_n_items.g_list_model_get_n_items.html
	//
	GetNItems() uint
	// GetObject wraps g_list_model_get_object
	// 
	// see also https://docs.gtk.org/gio/method.g_list_model_get_object.g_list_model_get_object.html
	//
	GetObject(uint) gobject.Object
	// ItemsChanged wraps g_list_model_items_changed
	// 
	// see also https://docs.gtk.org/gio/method.g_list_model_items_changed.g_list_model_items_changed.html
	//
	ItemsChanged(uint, uint, uint)
	// ConnectItemsChanged connects the provided callback to the "items-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.ListModel.items-changed.html
	//
	ConnectItemsChanged(func(ListModel, uint, uint, uint)) gobject.SignalHandle
}

var _ ListModel = (*ListModelInstance)(nil)

func unsafeWrapListModel(base *gobject.ObjectInstance) *ListModelInstance {
	return &ListModelInstance{
		Instance: *base,
	}
}

func marshalListModelInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (l *ListModelInstance) upcastToGListModel() *ListModelInstance {
	return l
}

// UnsafeListModelFromGlibNone is used to convert raw GListModel pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeListModelFromGlibNone(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibNone(c).(ListModel)
}

// UnsafeListModelFromGlibFull is used to convert raw GListModel pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeListModelFromGlibFull(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibFull(c).(ListModel)
}

// UnsafeListModelFromGlibBorrow is used to convert raw GListModel pointers to go without touching any references. This is used by the bindings internally.
func UnsafeListModelFromGlibBorrow(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ListModel)
}

// UnsafeListModelToGlibNone is used to convert the instance to it's C value GListModel. This is used by the bindings internally.
func UnsafeListModelToGlibNone(c ListModel) unsafe.Pointer {
	i := c.upcastToGListModel()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeListModelToGlibFull is used to convert the instance to it's C value GListModel, while removeing the finalizer. This is used by the bindings internally.
func UnsafeListModelToGlibFull(c ListModel) unsafe.Pointer {
	i := c.upcastToGListModel()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetItemType wraps g_list_model_get_item_type
// 
// see also https://docs.gtk.org/gio/method.g_list_model_get_item_type.g_list_model_get_item_type.html
//
func (list *ListModelInstance) GetItemType() gobject.Type {
	var carg0 *C.GListModel // in, none, converted
	var cret  C.GType       // return, none, casted, alias

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))

	cret = C.g_list_model_get_item_type(carg0)
	runtime.KeepAlive(list)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetNItems wraps g_list_model_get_n_items
// 
// see also https://docs.gtk.org/gio/method.g_list_model_get_n_items.g_list_model_get_n_items.html
//
func (list *ListModelInstance) GetNItems() uint {
	var carg0 *C.GListModel // in, none, converted
	var cret  C.guint       // return, none, casted

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))

	cret = C.g_list_model_get_n_items(carg0)
	runtime.KeepAlive(list)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetObject wraps g_list_model_get_object
// 
// see also https://docs.gtk.org/gio/method.g_list_model_get_object.g_list_model_get_object.html
//
func (list *ListModelInstance) GetObject(position uint) gobject.Object {
	var carg0 *C.GListModel // in, none, converted
	var carg1 C.guint       // in, none, casted
	var cret  *C.GObject    // return, full, converted, nullable

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))
	carg1 = C.guint(position)

	cret = C.g_list_model_get_object(carg0, carg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ItemsChanged wraps g_list_model_items_changed
// 
// see also https://docs.gtk.org/gio/method.g_list_model_items_changed.g_list_model_items_changed.html
//
func (list *ListModelInstance) ItemsChanged(position uint, removed uint, added uint) {
	var carg0 *C.GListModel // in, none, converted
	var carg1 C.guint       // in, none, casted
	var carg2 C.guint       // in, none, casted
	var carg3 C.guint       // in, none, casted

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))
	carg1 = C.guint(position)
	carg2 = C.guint(removed)
	carg3 = C.guint(added)

	C.g_list_model_items_changed(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// ConnectItemsChanged connects the provided callback to the "items-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.ListModel.items-changed.html
//
func (o *ListModelInstance) ConnectItemsChanged(fn func(ListModel, uint, uint, uint)) gobject.SignalHandle {
	return o.Instance.Connect("items-changed", fn)
}

// LoadableIconInstance is the instance type used by all types implementing GLoadableIcon. It is used internally by the bindings. Users should use the interface [LoadableIcon] instead.
type LoadableIconInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ LoadableIcon = (*LoadableIconInstance)(nil)

// LoadableIcon wraps GLoadableIcon
// 
// see also https://docs.gtk.org/gio/interface.LoadableIcon.html
//
type LoadableIcon interface {
	upcastToGLoadableIcon() *LoadableIconInstance

	// Load wraps g_loadable_icon_load
	// 
	// see also https://docs.gtk.org/gio/method.g_loadable_icon_load.g_loadable_icon_load.html
	//
	Load(int32, Cancellable) (string, InputStream, error)
	// LoadAsync wraps g_loadable_icon_load_async
	// 
	// see also https://docs.gtk.org/gio/method.g_loadable_icon_load_async.g_loadable_icon_load_async.html
	//
	LoadAsync(int32, Cancellable, AsyncReadyCallback)
	// LoadFinish wraps g_loadable_icon_load_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_loadable_icon_load_finish.g_loadable_icon_load_finish.html
	//
	LoadFinish(AsyncResult) (string, InputStream, error)
}

var _ LoadableIcon = (*LoadableIconInstance)(nil)

func unsafeWrapLoadableIcon(base *gobject.ObjectInstance) *LoadableIconInstance {
	return &LoadableIconInstance{
		Instance: *base,
	}
}

func marshalLoadableIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (l *LoadableIconInstance) upcastToGLoadableIcon() *LoadableIconInstance {
	return l
}

// UnsafeLoadableIconFromGlibNone is used to convert raw GLoadableIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibNone(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(LoadableIcon)
}

// UnsafeLoadableIconFromGlibFull is used to convert raw GLoadableIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibFull(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(LoadableIcon)
}

// UnsafeLoadableIconFromGlibBorrow is used to convert raw GLoadableIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibBorrow(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(LoadableIcon)
}

// UnsafeLoadableIconToGlibNone is used to convert the instance to it's C value GLoadableIcon. This is used by the bindings internally.
func UnsafeLoadableIconToGlibNone(c LoadableIcon) unsafe.Pointer {
	i := c.upcastToGLoadableIcon()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeLoadableIconToGlibFull is used to convert the instance to it's C value GLoadableIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeLoadableIconToGlibFull(c LoadableIcon) unsafe.Pointer {
	i := c.upcastToGLoadableIcon()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Load wraps g_loadable_icon_load
// 
// see also https://docs.gtk.org/gio/method.g_loadable_icon_load.g_loadable_icon_load.html
//
func (icon *LoadableIconInstance) Load(size int32, cancellable Cancellable) (string, InputStream, error) {
	var carg0 *C.GLoadableIcon // in, none, converted
	var carg1 C.int            // in, none, casted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var carg2 *C.char          // out, full, string
	var cret  *C.GInputStream  // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = C.int(size)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_loadable_icon_load(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var typ    string
	var goret  InputStream
	var _goerr error

	typ = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return typ, goret, _goerr
}

// LoadAsync wraps g_loadable_icon_load_async
// 
// see also https://docs.gtk.org/gio/method.g_loadable_icon_load_async.g_loadable_icon_load_async.html
//
func (icon *LoadableIconInstance) LoadAsync(size int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GLoadableIcon      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = C.int(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_loadable_icon_load_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadFinish wraps g_loadable_icon_load_finish
// 
// see also https://docs.gtk.org/gio/method.g_loadable_icon_load_finish.g_loadable_icon_load_finish.html
//
func (icon *LoadableIconInstance) LoadFinish(res AsyncResult) (string, InputStream, error) {
	var carg0 *C.GLoadableIcon // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 *C.char          // out, full, string
	var cret  *C.GInputStream  // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_loadable_icon_load_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(res)

	var typ    string
	var goret  InputStream
	var _goerr error

	typ = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return typ, goret, _goerr
}

// MemoryMonitorInstance is the instance type used by all types implementing GMemoryMonitor. It is used internally by the bindings. Users should use the interface [MemoryMonitor] instead.
type MemoryMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ MemoryMonitor = (*MemoryMonitorInstance)(nil)

// MemoryMonitor wraps GMemoryMonitor
// 
// see also https://docs.gtk.org/gio/interface.MemoryMonitor.html
//
type MemoryMonitor interface {
	upcastToGMemoryMonitor() *MemoryMonitorInstance

	// ConnectLowMemoryWarning connects the provided callback to the "low-memory-warning" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MemoryMonitor.low-memory-warning.html
	//
	ConnectLowMemoryWarning(func(MemoryMonitor, MemoryMonitorWarningLevel)) gobject.SignalHandle
}

var _ MemoryMonitor = (*MemoryMonitorInstance)(nil)

func unsafeWrapMemoryMonitor(base *gobject.ObjectInstance) *MemoryMonitorInstance {
	return &MemoryMonitorInstance{
		Instance: *base,
	}
}

func marshalMemoryMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (m *MemoryMonitorInstance) upcastToGMemoryMonitor() *MemoryMonitorInstance {
	return m
}

// UnsafeMemoryMonitorFromGlibNone is used to convert raw GMemoryMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibNone(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorFromGlibFull is used to convert raw GMemoryMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibFull(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorFromGlibBorrow is used to convert raw GMemoryMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibBorrow(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorToGlibNone is used to convert the instance to it's C value GMemoryMonitor. This is used by the bindings internally.
func UnsafeMemoryMonitorToGlibNone(c MemoryMonitor) unsafe.Pointer {
	i := c.upcastToGMemoryMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeMemoryMonitorToGlibFull is used to convert the instance to it's C value GMemoryMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorToGlibFull(c MemoryMonitor) unsafe.Pointer {
	i := c.upcastToGMemoryMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// MemoryMonitorDupDefault wraps g_memory_monitor_dup_default
// 
// see also https://docs.gtk.org/gio/func.g_memory_monitor_dup_default.html
//
func MemoryMonitorDupDefault() MemoryMonitor {
	var cret *C.GMemoryMonitor // return, full, converted

	cret = C.g_memory_monitor_dup_default()

	var goret MemoryMonitor

	goret = UnsafeMemoryMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectLowMemoryWarning connects the provided callback to the "low-memory-warning" signal
// 
// see also https://docs.gtk.org/gio/signal.MemoryMonitor.low-memory-warning.html
//
func (o *MemoryMonitorInstance) ConnectLowMemoryWarning(fn func(MemoryMonitor, MemoryMonitorWarningLevel)) gobject.SignalHandle {
	return o.Instance.Connect("low-memory-warning", fn)
}

// MountInstance is the instance type used by all types implementing GMount. It is used internally by the bindings. Users should use the interface [Mount] instead.
type MountInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Mount = (*MountInstance)(nil)

// Mount wraps GMount
// 
// see also https://docs.gtk.org/gio/interface.Mount.html
//
type Mount interface {
	upcastToGMount() *MountInstance

	// CanEject wraps g_mount_can_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_can_eject.g_mount_can_eject.html
	//
	CanEject() bool
	// CanUnmount wraps g_mount_can_unmount
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_can_unmount.g_mount_can_unmount.html
	//
	CanUnmount() bool
	// Eject wraps g_mount_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_eject.g_mount_eject.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_mount_eject_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_eject_finish.g_mount_eject_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_mount_eject_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_eject_with_operation.g_mount_eject_with_operation.html
	//
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_mount_eject_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_eject_with_operation_finish.g_mount_eject_with_operation_finish.html
	//
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// GetDefaultLocation wraps g_mount_get_default_location
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_default_location.g_mount_get_default_location.html
	//
	GetDefaultLocation() File
	// GetDrive wraps g_mount_get_drive
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_drive.g_mount_get_drive.html
	//
	GetDrive() Drive
	// GetIcon wraps g_mount_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_icon.g_mount_get_icon.html
	//
	GetIcon() Icon
	// GetName wraps g_mount_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_name.g_mount_get_name.html
	//
	GetName() string
	// GetRoot wraps g_mount_get_root
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_root.g_mount_get_root.html
	//
	GetRoot() File
	// GetSortKey wraps g_mount_get_sort_key
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_sort_key.g_mount_get_sort_key.html
	//
	GetSortKey() string
	// GetSymbolicIcon wraps g_mount_get_symbolic_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_symbolic_icon.g_mount_get_symbolic_icon.html
	//
	GetSymbolicIcon() Icon
	// GetUuid wraps g_mount_get_uuid
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_uuid.g_mount_get_uuid.html
	//
	GetUuid() string
	// GetVolume wraps g_mount_get_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_get_volume.g_mount_get_volume.html
	//
	GetVolume() Volume
	// GuessContentType wraps g_mount_guess_content_type
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type.g_mount_guess_content_type.html
	//
	GuessContentType(bool, Cancellable, AsyncReadyCallback)
	// GuessContentTypeFinish wraps g_mount_guess_content_type_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type_finish.g_mount_guess_content_type_finish.html
	//
	GuessContentTypeFinish(AsyncResult) ([]string, error)
	// GuessContentTypeSync wraps g_mount_guess_content_type_sync
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type_sync.g_mount_guess_content_type_sync.html
	//
	GuessContentTypeSync(bool, Cancellable) ([]string, error)
	// IsShadowed wraps g_mount_is_shadowed
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_is_shadowed.g_mount_is_shadowed.html
	//
	IsShadowed() bool
	// Remount wraps g_mount_remount
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_remount.g_mount_remount.html
	//
	Remount(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// RemountFinish wraps g_mount_remount_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_remount_finish.g_mount_remount_finish.html
	//
	RemountFinish(AsyncResult) (bool, error)
	// Shadow wraps g_mount_shadow
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_shadow.g_mount_shadow.html
	//
	Shadow()
	// Unmount wraps g_mount_unmount
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_unmount.g_mount_unmount.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation() instead.
	Unmount(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// UnmountFinish wraps g_mount_unmount_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_unmount_finish.g_mount_unmount_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation_finish() instead.
	UnmountFinish(AsyncResult) (bool, error)
	// UnmountWithOperation wraps g_mount_unmount_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_unmount_with_operation.g_mount_unmount_with_operation.html
	//
	UnmountWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// UnmountWithOperationFinish wraps g_mount_unmount_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_unmount_with_operation_finish.g_mount_unmount_with_operation_finish.html
	//
	UnmountWithOperationFinish(AsyncResult) (bool, error)
	// Unshadow wraps g_mount_unshadow
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_unshadow.g_mount_unshadow.html
	//
	Unshadow()
	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Mount.changed.html
	//
	ConnectChanged(func(Mount)) gobject.SignalHandle
	// ConnectPreUnmount connects the provided callback to the "pre-unmount" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Mount.pre-unmount.html
	//
	ConnectPreUnmount(func(Mount)) gobject.SignalHandle
	// ConnectUnmounted connects the provided callback to the "unmounted" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Mount.unmounted.html
	//
	ConnectUnmounted(func(Mount)) gobject.SignalHandle
}

var _ Mount = (*MountInstance)(nil)

func unsafeWrapMount(base *gobject.ObjectInstance) *MountInstance {
	return &MountInstance{
		Instance: *base,
	}
}

func marshalMountInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (m *MountInstance) upcastToGMount() *MountInstance {
	return m
}

// UnsafeMountFromGlibNone is used to convert raw GMount pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMountFromGlibNone(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibNone(c).(Mount)
}

// UnsafeMountFromGlibFull is used to convert raw GMount pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMountFromGlibFull(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibFull(c).(Mount)
}

// UnsafeMountFromGlibBorrow is used to convert raw GMount pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMountFromGlibBorrow(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Mount)
}

// UnsafeMountToGlibNone is used to convert the instance to it's C value GMount. This is used by the bindings internally.
func UnsafeMountToGlibNone(c Mount) unsafe.Pointer {
	i := c.upcastToGMount()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeMountToGlibFull is used to convert the instance to it's C value GMount, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMountToGlibFull(c Mount) unsafe.Pointer {
	i := c.upcastToGMount()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_mount_can_eject
// 
// see also https://docs.gtk.org/gio/method.g_mount_can_eject.g_mount_can_eject.html
//
func (mount *MountInstance) CanEject() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_can_eject(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanUnmount wraps g_mount_can_unmount
// 
// see also https://docs.gtk.org/gio/method.g_mount_can_unmount.g_mount_can_unmount.html
//
func (mount *MountInstance) CanUnmount() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_can_unmount(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_mount_eject
// 
// see also https://docs.gtk.org/gio/method.g_mount_eject.g_mount_eject.html
//
//
// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation() instead.
func (mount *MountInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_mount_eject_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_eject_finish.g_mount_eject_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation_finish() instead.
func (mount *MountInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_mount_eject_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_mount_eject_with_operation.g_mount_eject_with_operation.html
//
func (mount *MountInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_mount_eject_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_eject_with_operation_finish.g_mount_eject_with_operation_finish.html
//
func (mount *MountInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDefaultLocation wraps g_mount_get_default_location
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_default_location.g_mount_get_default_location.html
//
func (mount *MountInstance) GetDefaultLocation() File {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GFile  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_default_location(carg0)
	runtime.KeepAlive(mount)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDrive wraps g_mount_get_drive
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_drive.g_mount_get_drive.html
//
func (mount *MountInstance) GetDrive() Drive {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GDrive // return, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_drive(carg0)
	runtime.KeepAlive(mount)

	var goret Drive

	if cret != nil {
		goret = UnsafeDriveFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetIcon wraps g_mount_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_icon.g_mount_get_icon.html
//
func (mount *MountInstance) GetIcon() Icon {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_icon(carg0)
	runtime.KeepAlive(mount)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetName wraps g_mount_get_name
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_name.g_mount_get_name.html
//
func (mount *MountInstance) GetName() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.char   // return, full, string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_name(carg0)
	runtime.KeepAlive(mount)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetRoot wraps g_mount_get_root
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_root.g_mount_get_root.html
//
func (mount *MountInstance) GetRoot() File {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GFile  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_root(carg0)
	runtime.KeepAlive(mount)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_mount_get_sort_key
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_sort_key.g_mount_get_sort_key.html
//
func (mount *MountInstance) GetSortKey() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.gchar  // return, none, string, nullable-string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_sort_key(carg0)
	runtime.KeepAlive(mount)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetSymbolicIcon wraps g_mount_get_symbolic_icon
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_symbolic_icon.g_mount_get_symbolic_icon.html
//
func (mount *MountInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_symbolic_icon(carg0)
	runtime.KeepAlive(mount)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetUuid wraps g_mount_get_uuid
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_uuid.g_mount_get_uuid.html
//
func (mount *MountInstance) GetUuid() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.char   // return, full, string, nullable-string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_uuid(carg0)
	runtime.KeepAlive(mount)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetVolume wraps g_mount_get_volume
// 
// see also https://docs.gtk.org/gio/method.g_mount_get_volume.g_mount_get_volume.html
//
func (mount *MountInstance) GetVolume() Volume {
	var carg0 *C.GMount  // in, none, converted
	var cret  *C.GVolume // return, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_volume(carg0)
	runtime.KeepAlive(mount)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GuessContentType wraps g_mount_guess_content_type
// 
// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type.g_mount_guess_content_type.html
//
func (mount *MountInstance) GuessContentType(forceRescan bool, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.gboolean            // in
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	if forceRescan {
		carg1 = C.TRUE
	}
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_guess_content_type(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// GuessContentTypeFinish wraps g_mount_guess_content_type_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type_finish.g_mount_guess_content_type_finish.html
//
func (mount *MountInstance) GuessContentTypeFinish(result AsyncResult) ([]string, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_guess_content_type_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GuessContentTypeSync wraps g_mount_guess_content_type_sync
// 
// see also https://docs.gtk.org/gio/method.g_mount_guess_content_type_sync.g_mount_guess_content_type_sync.html
//
func (mount *MountInstance) GuessContentTypeSync(forceRescan bool, cancellable Cancellable) ([]string, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 C.gboolean      // in
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	if forceRescan {
		carg1 = C.TRUE
	}
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_mount_guess_content_type_sync(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(cancellable)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IsShadowed wraps g_mount_is_shadowed
// 
// see also https://docs.gtk.org/gio/method.g_mount_is_shadowed.g_mount_is_shadowed.html
//
func (mount *MountInstance) IsShadowed() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_is_shadowed(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Remount wraps g_mount_remount
// 
// see also https://docs.gtk.org/gio/method.g_mount_remount.g_mount_remount.html
//
func (mount *MountInstance) Remount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_remount(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// RemountFinish wraps g_mount_remount_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_remount_finish.g_mount_remount_finish.html
//
func (mount *MountInstance) RemountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_remount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Shadow wraps g_mount_shadow
// 
// see also https://docs.gtk.org/gio/method.g_mount_shadow.g_mount_shadow.html
//
func (mount *MountInstance) Shadow() {
	var carg0 *C.GMount // in, none, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C.g_mount_shadow(carg0)
	runtime.KeepAlive(mount)
}

// Unmount wraps g_mount_unmount
// 
// see also https://docs.gtk.org/gio/method.g_mount_unmount.g_mount_unmount.html
//
//
// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation() instead.
func (mount *MountInstance) Unmount(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_unmount(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountFinish wraps g_mount_unmount_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_unmount_finish.g_mount_unmount_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation_finish() instead.
func (mount *MountInstance) UnmountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_unmount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountWithOperation wraps g_mount_unmount_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_mount_unmount_with_operation.g_mount_unmount_with_operation.html
//
func (mount *MountInstance) UnmountWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_unmount_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountWithOperationFinish wraps g_mount_unmount_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_mount_unmount_with_operation_finish.g_mount_unmount_with_operation_finish.html
//
func (mount *MountInstance) UnmountWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_unmount_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Unshadow wraps g_mount_unshadow
// 
// see also https://docs.gtk.org/gio/method.g_mount_unshadow.g_mount_unshadow.html
//
func (mount *MountInstance) Unshadow() {
	var carg0 *C.GMount // in, none, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C.g_mount_unshadow(carg0)
	runtime.KeepAlive(mount)
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.Mount.changed.html
//
func (o *MountInstance) ConnectChanged(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectPreUnmount connects the provided callback to the "pre-unmount" signal
// 
// see also https://docs.gtk.org/gio/signal.Mount.pre-unmount.html
//
func (o *MountInstance) ConnectPreUnmount(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("pre-unmount", fn)
}

// ConnectUnmounted connects the provided callback to the "unmounted" signal
// 
// see also https://docs.gtk.org/gio/signal.Mount.unmounted.html
//
func (o *MountInstance) ConnectUnmounted(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("unmounted", fn)
}

// NetworkMonitorInstance is the instance type used by all types implementing GNetworkMonitor. It is used internally by the bindings. Users should use the interface [NetworkMonitor] instead.
type NetworkMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ NetworkMonitor = (*NetworkMonitorInstance)(nil)

// NetworkMonitor wraps GNetworkMonitor
// 
// see also https://docs.gtk.org/gio/interface.NetworkMonitor.html
//
type NetworkMonitor interface {
	upcastToGNetworkMonitor() *NetworkMonitorInstance

	// CanReach wraps g_network_monitor_can_reach
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach.g_network_monitor_can_reach.html
	//
	CanReach(SocketConnectable, Cancellable) (bool, error)
	// CanReachAsync wraps g_network_monitor_can_reach_async
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach_async.g_network_monitor_can_reach_async.html
	//
	CanReachAsync(SocketConnectable, Cancellable, AsyncReadyCallback)
	// CanReachFinish wraps g_network_monitor_can_reach_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach_finish.g_network_monitor_can_reach_finish.html
	//
	CanReachFinish(AsyncResult) (bool, error)
	// GetConnectivity wraps g_network_monitor_get_connectivity
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_get_connectivity.g_network_monitor_get_connectivity.html
	//
	GetConnectivity() NetworkConnectivity
	// GetNetworkAvailable wraps g_network_monitor_get_network_available
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_get_network_available.g_network_monitor_get_network_available.html
	//
	GetNetworkAvailable() bool
	// GetNetworkMetered wraps g_network_monitor_get_network_metered
	// 
	// see also https://docs.gtk.org/gio/method.g_network_monitor_get_network_metered.g_network_monitor_get_network_metered.html
	//
	GetNetworkMetered() bool
	// ConnectNetworkChanged connects the provided callback to the "network-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.NetworkMonitor.network-changed.html
	//
	ConnectNetworkChanged(func(NetworkMonitor, bool)) gobject.SignalHandle
}

var _ NetworkMonitor = (*NetworkMonitorInstance)(nil)

func unsafeWrapNetworkMonitor(base *gobject.ObjectInstance) *NetworkMonitorInstance {
	return &NetworkMonitorInstance{
		Instance: *base,
	}
}

func marshalNetworkMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (n *NetworkMonitorInstance) upcastToGNetworkMonitor() *NetworkMonitorInstance {
	return n
}

// UnsafeNetworkMonitorFromGlibNone is used to convert raw GNetworkMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibNone(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorFromGlibFull is used to convert raw GNetworkMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibFull(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorFromGlibBorrow is used to convert raw GNetworkMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibBorrow(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorToGlibNone is used to convert the instance to it's C value GNetworkMonitor. This is used by the bindings internally.
func UnsafeNetworkMonitorToGlibNone(c NetworkMonitor) unsafe.Pointer {
	i := c.upcastToGNetworkMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeNetworkMonitorToGlibFull is used to convert the instance to it's C value GNetworkMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorToGlibFull(c NetworkMonitor) unsafe.Pointer {
	i := c.upcastToGNetworkMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NetworkMonitorGetDefault wraps g_network_monitor_get_default
// 
// see also https://docs.gtk.org/gio/func.g_network_monitor_get_default.html
//
func NetworkMonitorGetDefault() NetworkMonitor {
	var cret *C.GNetworkMonitor // return, none, converted

	cret = C.g_network_monitor_get_default()

	var goret NetworkMonitor

	goret = UnsafeNetworkMonitorFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// CanReach wraps g_network_monitor_can_reach
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach.g_network_monitor_can_reach.html
//
func (monitor *NetworkMonitorInstance) CanReach(connectable SocketConnectable, cancellable Cancellable) (bool, error) {
	var carg0 *C.GNetworkMonitor    // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_network_monitor_can_reach(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CanReachAsync wraps g_network_monitor_can_reach_async
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach_async.g_network_monitor_can_reach_async.html
//
func (monitor *NetworkMonitorInstance) CanReachAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GNetworkMonitor    // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_network_monitor_can_reach_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CanReachFinish wraps g_network_monitor_can_reach_finish
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_can_reach_finish.g_network_monitor_can_reach_finish.html
//
func (monitor *NetworkMonitorInstance) CanReachFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_network_monitor_can_reach_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetConnectivity wraps g_network_monitor_get_connectivity
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_get_connectivity.g_network_monitor_get_connectivity.html
//
func (monitor *NetworkMonitorInstance) GetConnectivity() NetworkConnectivity {
	var carg0 *C.GNetworkMonitor     // in, none, converted
	var cret  C.GNetworkConnectivity // return, none, casted

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_connectivity(carg0)
	runtime.KeepAlive(monitor)

	var goret NetworkConnectivity

	goret = NetworkConnectivity(cret)

	return goret
}

// GetNetworkAvailable wraps g_network_monitor_get_network_available
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_get_network_available.g_network_monitor_get_network_available.html
//
func (monitor *NetworkMonitorInstance) GetNetworkAvailable() bool {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_network_available(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNetworkMetered wraps g_network_monitor_get_network_metered
// 
// see also https://docs.gtk.org/gio/method.g_network_monitor_get_network_metered.g_network_monitor_get_network_metered.html
//
func (monitor *NetworkMonitorInstance) GetNetworkMetered() bool {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_network_metered(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectNetworkChanged connects the provided callback to the "network-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.NetworkMonitor.network-changed.html
//
func (o *NetworkMonitorInstance) ConnectNetworkChanged(fn func(NetworkMonitor, bool)) gobject.SignalHandle {
	return o.Instance.Connect("network-changed", fn)
}

// PollableInputStreamInstance is the instance type used by all types implementing GPollableInputStream. It is used internally by the bindings. Users should use the interface [PollableInputStream] instead.
type PollableInputStreamInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PollableInputStream = (*PollableInputStreamInstance)(nil)

// PollableInputStream wraps GPollableInputStream
// 
// see also https://docs.gtk.org/gio/interface.PollableInputStream.html
//
type PollableInputStream interface {
	upcastToGPollableInputStream() *PollableInputStreamInstance

	// CanPoll wraps g_pollable_input_stream_can_poll
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_input_stream_can_poll.g_pollable_input_stream_can_poll.html
	//
	CanPoll() bool
	// IsReadable wraps g_pollable_input_stream_is_readable
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_input_stream_is_readable.g_pollable_input_stream_is_readable.html
	//
	IsReadable() bool
}

var _ PollableInputStream = (*PollableInputStreamInstance)(nil)

func unsafeWrapPollableInputStream(base *gobject.ObjectInstance) *PollableInputStreamInstance {
	return &PollableInputStreamInstance{
		Instance: *base,
	}
}

func marshalPollableInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PollableInputStreamInstance) upcastToGPollableInputStream() *PollableInputStreamInstance {
	return p
}

// UnsafePollableInputStreamFromGlibNone is used to convert raw GPollableInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibNone(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(PollableInputStream)
}

// UnsafePollableInputStreamFromGlibFull is used to convert raw GPollableInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibFull(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(PollableInputStream)
}

// UnsafePollableInputStreamFromGlibBorrow is used to convert raw GPollableInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibBorrow(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PollableInputStream)
}

// UnsafePollableInputStreamToGlibNone is used to convert the instance to it's C value GPollableInputStream. This is used by the bindings internally.
func UnsafePollableInputStreamToGlibNone(c PollableInputStream) unsafe.Pointer {
	i := c.upcastToGPollableInputStream()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePollableInputStreamToGlibFull is used to convert the instance to it's C value GPollableInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamToGlibFull(c PollableInputStream) unsafe.Pointer {
	i := c.upcastToGPollableInputStream()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanPoll wraps g_pollable_input_stream_can_poll
// 
// see also https://docs.gtk.org/gio/method.g_pollable_input_stream_can_poll.g_pollable_input_stream_can_poll.html
//
func (stream *PollableInputStreamInstance) CanPoll() bool {
	var carg0 *C.GPollableInputStream // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPollableInputStream)(UnsafePollableInputStreamToGlibNone(stream))

	cret = C.g_pollable_input_stream_can_poll(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsReadable wraps g_pollable_input_stream_is_readable
// 
// see also https://docs.gtk.org/gio/method.g_pollable_input_stream_is_readable.g_pollable_input_stream_is_readable.html
//
func (stream *PollableInputStreamInstance) IsReadable() bool {
	var carg0 *C.GPollableInputStream // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPollableInputStream)(UnsafePollableInputStreamToGlibNone(stream))

	cret = C.g_pollable_input_stream_is_readable(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollableOutputStreamInstance is the instance type used by all types implementing GPollableOutputStream. It is used internally by the bindings. Users should use the interface [PollableOutputStream] instead.
type PollableOutputStreamInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PollableOutputStream = (*PollableOutputStreamInstance)(nil)

// PollableOutputStream wraps GPollableOutputStream
// 
// see also https://docs.gtk.org/gio/interface.PollableOutputStream.html
//
type PollableOutputStream interface {
	upcastToGPollableOutputStream() *PollableOutputStreamInstance

	// CanPoll wraps g_pollable_output_stream_can_poll
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_can_poll.g_pollable_output_stream_can_poll.html
	//
	CanPoll() bool
	// IsWritable wraps g_pollable_output_stream_is_writable
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_is_writable.g_pollable_output_stream_is_writable.html
	//
	IsWritable() bool
	// WriteNonblocking wraps g_pollable_output_stream_write_nonblocking
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_write_nonblocking.g_pollable_output_stream_write_nonblocking.html
	//
	WriteNonblocking([]byte, Cancellable) (int, error)
	// WritevNonblocking wraps g_pollable_output_stream_writev_nonblocking
	// 
	// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_writev_nonblocking.g_pollable_output_stream_writev_nonblocking.html
	//
	WritevNonblocking([]OutputVector, Cancellable) (uint, PollableReturn, error)
}

var _ PollableOutputStream = (*PollableOutputStreamInstance)(nil)

func unsafeWrapPollableOutputStream(base *gobject.ObjectInstance) *PollableOutputStreamInstance {
	return &PollableOutputStreamInstance{
		Instance: *base,
	}
}

func marshalPollableOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PollableOutputStreamInstance) upcastToGPollableOutputStream() *PollableOutputStreamInstance {
	return p
}

// UnsafePollableOutputStreamFromGlibNone is used to convert raw GPollableOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibNone(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamFromGlibFull is used to convert raw GPollableOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibFull(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamFromGlibBorrow is used to convert raw GPollableOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibBorrow(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamToGlibNone is used to convert the instance to it's C value GPollableOutputStream. This is used by the bindings internally.
func UnsafePollableOutputStreamToGlibNone(c PollableOutputStream) unsafe.Pointer {
	i := c.upcastToGPollableOutputStream()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePollableOutputStreamToGlibFull is used to convert the instance to it's C value GPollableOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamToGlibFull(c PollableOutputStream) unsafe.Pointer {
	i := c.upcastToGPollableOutputStream()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanPoll wraps g_pollable_output_stream_can_poll
// 
// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_can_poll.g_pollable_output_stream_can_poll.html
//
func (stream *PollableOutputStreamInstance) CanPoll() bool {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))

	cret = C.g_pollable_output_stream_can_poll(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsWritable wraps g_pollable_output_stream_is_writable
// 
// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_is_writable.g_pollable_output_stream_is_writable.html
//
func (stream *PollableOutputStreamInstance) IsWritable() bool {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))

	cret = C.g_pollable_output_stream_is_writable(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// WriteNonblocking wraps g_pollable_output_stream_write_nonblocking
// 
// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_write_nonblocking.g_pollable_output_stream_write_nonblocking.html
//
func (stream *PollableOutputStreamInstance) WriteNonblocking(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var carg1 unsafe.Pointer           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize                  // implicit
	var carg3 *C.GCancellable          // in, none, converted, nullable
	var cret  C.gssize                 // return, none, casted
	var _cerr *C.GError                // out, full, converted, nullable

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_output_stream_write_nonblocking(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WritevNonblocking wraps g_pollable_output_stream_writev_nonblocking
// 
// see also https://docs.gtk.org/gio/method.g_pollable_output_stream_writev_nonblocking.g_pollable_output_stream_writev_nonblocking.html
//
func (stream *PollableOutputStreamInstance) WritevNonblocking(vectors []OutputVector, cancellable Cancellable) (uint, PollableReturn, error) {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var carg1 *C.GOutputVector         // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize                  // implicit
	var carg4 *C.GCancellable          // in, none, converted, nullable
	var carg3 C.gsize                  // out, full, casted
	var cret  C.GPollableReturn        // return, none, casted
	var _cerr *C.GError                // out, full, converted, nullable

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_output_stream_writev_nonblocking(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        PollableReturn
	var _goerr       error

	bytesWritten = uint(carg3)
	goret = PollableReturn(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// PowerProfileMonitorInstance is the instance type used by all types implementing GPowerProfileMonitor. It is used internally by the bindings. Users should use the interface [PowerProfileMonitor] instead.
type PowerProfileMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PowerProfileMonitor = (*PowerProfileMonitorInstance)(nil)

// PowerProfileMonitor wraps GPowerProfileMonitor
// 
// see also https://docs.gtk.org/gio/interface.PowerProfileMonitor.html
//
type PowerProfileMonitor interface {
	upcastToGPowerProfileMonitor() *PowerProfileMonitorInstance

	// GetPowerSaverEnabled wraps g_power_profile_monitor_get_power_saver_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_power_profile_monitor_get_power_saver_enabled.g_power_profile_monitor_get_power_saver_enabled.html
	//
	GetPowerSaverEnabled() bool
}

var _ PowerProfileMonitor = (*PowerProfileMonitorInstance)(nil)

func unsafeWrapPowerProfileMonitor(base *gobject.ObjectInstance) *PowerProfileMonitorInstance {
	return &PowerProfileMonitorInstance{
		Instance: *base,
	}
}

func marshalPowerProfileMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PowerProfileMonitorInstance) upcastToGPowerProfileMonitor() *PowerProfileMonitorInstance {
	return p
}

// UnsafePowerProfileMonitorFromGlibNone is used to convert raw GPowerProfileMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibNone(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorFromGlibFull is used to convert raw GPowerProfileMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibFull(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorFromGlibBorrow is used to convert raw GPowerProfileMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibBorrow(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorToGlibNone is used to convert the instance to it's C value GPowerProfileMonitor. This is used by the bindings internally.
func UnsafePowerProfileMonitorToGlibNone(c PowerProfileMonitor) unsafe.Pointer {
	i := c.upcastToGPowerProfileMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePowerProfileMonitorToGlibFull is used to convert the instance to it's C value GPowerProfileMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorToGlibFull(c PowerProfileMonitor) unsafe.Pointer {
	i := c.upcastToGPowerProfileMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// PowerProfileMonitorDupDefault wraps g_power_profile_monitor_dup_default
// 
// see also https://docs.gtk.org/gio/func.g_power_profile_monitor_dup_default.html
//
func PowerProfileMonitorDupDefault() PowerProfileMonitor {
	var cret *C.GPowerProfileMonitor // return, full, converted

	cret = C.g_power_profile_monitor_dup_default()

	var goret PowerProfileMonitor

	goret = UnsafePowerProfileMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetPowerSaverEnabled wraps g_power_profile_monitor_get_power_saver_enabled
// 
// see also https://docs.gtk.org/gio/method.g_power_profile_monitor_get_power_saver_enabled.g_power_profile_monitor_get_power_saver_enabled.html
//
func (monitor *PowerProfileMonitorInstance) GetPowerSaverEnabled() bool {
	var carg0 *C.GPowerProfileMonitor // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPowerProfileMonitor)(UnsafePowerProfileMonitorToGlibNone(monitor))

	cret = C.g_power_profile_monitor_get_power_saver_enabled(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ProxyInstance is the instance type used by all types implementing GProxy. It is used internally by the bindings. Users should use the interface [Proxy] instead.
type ProxyInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Proxy = (*ProxyInstance)(nil)

// Proxy wraps GProxy
// 
// see also https://docs.gtk.org/gio/interface.Proxy.html
//
type Proxy interface {
	upcastToGProxy() *ProxyInstance

	// ConnectProxy wraps g_proxy_connect
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_connect.g_proxy_connect.html
	//
	ConnectProxy(IOStream, ProxyAddress, Cancellable) (IOStream, error)
	// ConnectAsync wraps g_proxy_connect_async
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_connect_async.g_proxy_connect_async.html
	//
	ConnectAsync(IOStream, ProxyAddress, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_proxy_connect_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_connect_finish.g_proxy_connect_finish.html
	//
	ConnectFinish(AsyncResult) (IOStream, error)
	// SupportsHostname wraps g_proxy_supports_hostname
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_supports_hostname.g_proxy_supports_hostname.html
	//
	SupportsHostname() bool
}

var _ Proxy = (*ProxyInstance)(nil)

func unsafeWrapProxy(base *gobject.ObjectInstance) *ProxyInstance {
	return &ProxyInstance{
		Instance: *base,
	}
}

func marshalProxyInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *ProxyInstance) upcastToGProxy() *ProxyInstance {
	return p
}

// UnsafeProxyFromGlibNone is used to convert raw GProxy pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyFromGlibNone(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibNone(c).(Proxy)
}

// UnsafeProxyFromGlibFull is used to convert raw GProxy pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyFromGlibFull(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibFull(c).(Proxy)
}

// UnsafeProxyFromGlibBorrow is used to convert raw GProxy pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyFromGlibBorrow(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Proxy)
}

// UnsafeProxyToGlibNone is used to convert the instance to it's C value GProxy. This is used by the bindings internally.
func UnsafeProxyToGlibNone(c Proxy) unsafe.Pointer {
	i := c.upcastToGProxy()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeProxyToGlibFull is used to convert the instance to it's C value GProxy, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyToGlibFull(c Proxy) unsafe.Pointer {
	i := c.upcastToGProxy()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ProxyGetDefaultForProtocol wraps g_proxy_get_default_for_protocol
// 
// see also https://docs.gtk.org/gio/func.g_proxy_get_default_for_protocol.html
//
func ProxyGetDefaultForProtocol(protocol string) Proxy {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GProxy // return, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_proxy_get_default_for_protocol(carg1)
	runtime.KeepAlive(protocol)

	var goret Proxy

	if cret != nil {
		goret = UnsafeProxyFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ConnectProxy wraps g_proxy_connect
// 
// see also https://docs.gtk.org/gio/method.g_proxy_connect.g_proxy_connect.html
//
func (proxy *ProxyInstance) ConnectProxy(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable) (IOStream, error) {
	var carg0 *C.GProxy        // in, none, converted
	var carg1 *C.GIOStream     // in, none, converted
	var carg2 *C.GProxyAddress // in, none, converted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GIOStream     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))
	carg2 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxyAddress))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_proxy_connect(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(cancellable)

	var goret  IOStream
	var _goerr error

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_proxy_connect_async
// 
// see also https://docs.gtk.org/gio/method.g_proxy_connect_async.g_proxy_connect_async.html
//
func (proxy *ProxyInstance) ConnectAsync(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GProxy             // in, none, converted
	var carg1 *C.GIOStream          // in, none, converted
	var carg2 *C.GProxyAddress      // in, none, converted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))
	carg2 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxyAddress))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_proxy_connect_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_proxy_connect_finish
// 
// see also https://docs.gtk.org/gio/method.g_proxy_connect_finish.g_proxy_connect_finish.html
//
func (proxy *ProxyInstance) ConnectFinish(result AsyncResult) (IOStream, error) {
	var carg0 *C.GProxy       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_proxy_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(result)

	var goret  IOStream
	var _goerr error

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SupportsHostname wraps g_proxy_supports_hostname
// 
// see also https://docs.gtk.org/gio/method.g_proxy_supports_hostname.g_proxy_supports_hostname.html
//
func (proxy *ProxyInstance) SupportsHostname() bool {
	var carg0 *C.GProxy  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))

	cret = C.g_proxy_supports_hostname(carg0)
	runtime.KeepAlive(proxy)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ProxyResolverInstance is the instance type used by all types implementing GProxyResolver. It is used internally by the bindings. Users should use the interface [ProxyResolver] instead.
type ProxyResolverInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ProxyResolver = (*ProxyResolverInstance)(nil)

// ProxyResolver wraps GProxyResolver
// 
// see also https://docs.gtk.org/gio/interface.ProxyResolver.html
//
type ProxyResolver interface {
	upcastToGProxyResolver() *ProxyResolverInstance

	// IsSupported wraps g_proxy_resolver_is_supported
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_resolver_is_supported.g_proxy_resolver_is_supported.html
	//
	IsSupported() bool
	// Lookup wraps g_proxy_resolver_lookup
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup.g_proxy_resolver_lookup.html
	//
	Lookup(string, Cancellable) ([]string, error)
	// LookupAsync wraps g_proxy_resolver_lookup_async
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup_async.g_proxy_resolver_lookup_async.html
	//
	LookupAsync(string, Cancellable, AsyncReadyCallback)
	// LookupFinish wraps g_proxy_resolver_lookup_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup_finish.g_proxy_resolver_lookup_finish.html
	//
	LookupFinish(AsyncResult) ([]string, error)
}

var _ ProxyResolver = (*ProxyResolverInstance)(nil)

func unsafeWrapProxyResolver(base *gobject.ObjectInstance) *ProxyResolverInstance {
	return &ProxyResolverInstance{
		Instance: *base,
	}
}

func marshalProxyResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *ProxyResolverInstance) upcastToGProxyResolver() *ProxyResolverInstance {
	return p
}

// UnsafeProxyResolverFromGlibNone is used to convert raw GProxyResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibNone(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyResolver)
}

// UnsafeProxyResolverFromGlibFull is used to convert raw GProxyResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibFull(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyResolver)
}

// UnsafeProxyResolverFromGlibBorrow is used to convert raw GProxyResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibBorrow(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyResolver)
}

// UnsafeProxyResolverToGlibNone is used to convert the instance to it's C value GProxyResolver. This is used by the bindings internally.
func UnsafeProxyResolverToGlibNone(c ProxyResolver) unsafe.Pointer {
	i := c.upcastToGProxyResolver()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeProxyResolverToGlibFull is used to convert the instance to it's C value GProxyResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyResolverToGlibFull(c ProxyResolver) unsafe.Pointer {
	i := c.upcastToGProxyResolver()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ProxyResolverGetDefault wraps g_proxy_resolver_get_default
// 
// see also https://docs.gtk.org/gio/func.g_proxy_resolver_get_default.html
//
func ProxyResolverGetDefault() ProxyResolver {
	var cret *C.GProxyResolver // return, none, converted

	cret = C.g_proxy_resolver_get_default()

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsSupported wraps g_proxy_resolver_is_supported
// 
// see also https://docs.gtk.org/gio/method.g_proxy_resolver_is_supported.g_proxy_resolver_is_supported.html
//
func (resolver *ProxyResolverInstance) IsSupported() bool {
	var carg0 *C.GProxyResolver // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))

	cret = C.g_proxy_resolver_is_supported(carg0)
	runtime.KeepAlive(resolver)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Lookup wraps g_proxy_resolver_lookup
// 
// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup.g_proxy_resolver_lookup.html
//
func (resolver *ProxyResolverInstance) Lookup(uri string, cancellable Cancellable) ([]string, error) {
	var carg0 *C.GProxyResolver // in, none, converted
	var carg1 *C.gchar          // in, none, string
	var carg2 *C.GCancellable   // in, none, converted, nullable
	var cret  **C.gchar         // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_proxy_resolver_lookup(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cancellable)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupAsync wraps g_proxy_resolver_lookup_async
// 
// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup_async.g_proxy_resolver_lookup_async.html
//
func (resolver *ProxyResolverInstance) LookupAsync(uri string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GProxyResolver     // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_proxy_resolver_lookup_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupFinish wraps g_proxy_resolver_lookup_finish
// 
// see also https://docs.gtk.org/gio/method.g_proxy_resolver_lookup_finish.g_proxy_resolver_lookup_finish.html
//
func (resolver *ProxyResolverInstance) LookupFinish(result AsyncResult) ([]string, error) {
	var carg0 *C.GProxyResolver // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  **C.gchar         // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_proxy_resolver_lookup_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoteActionGroupInstance is the instance type used by all types implementing GRemoteActionGroup. It is used internally by the bindings. Users should use the interface [RemoteActionGroup] instead.
type RemoteActionGroupInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ RemoteActionGroup = (*RemoteActionGroupInstance)(nil)

// RemoteActionGroup wraps GRemoteActionGroup
// 
// see also https://docs.gtk.org/gio/interface.RemoteActionGroup.html
//
type RemoteActionGroup interface {
	upcastToGRemoteActionGroup() *RemoteActionGroupInstance
}

var _ RemoteActionGroup = (*RemoteActionGroupInstance)(nil)

func unsafeWrapRemoteActionGroup(base *gobject.ObjectInstance) *RemoteActionGroupInstance {
	return &RemoteActionGroupInstance{
		Instance: *base,
	}
}

func marshalRemoteActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (r *RemoteActionGroupInstance) upcastToGRemoteActionGroup() *RemoteActionGroupInstance {
	return r
}

// UnsafeRemoteActionGroupFromGlibNone is used to convert raw GRemoteActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibNone(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupFromGlibFull is used to convert raw GRemoteActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibFull(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupFromGlibBorrow is used to convert raw GRemoteActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibBorrow(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupToGlibNone is used to convert the instance to it's C value GRemoteActionGroup. This is used by the bindings internally.
func UnsafeRemoteActionGroupToGlibNone(c RemoteActionGroup) unsafe.Pointer {
	i := c.upcastToGRemoteActionGroup()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeRemoteActionGroupToGlibFull is used to convert the instance to it's C value GRemoteActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupToGlibFull(c RemoteActionGroup) unsafe.Pointer {
	i := c.upcastToGRemoteActionGroup()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// SeekableInstance is the instance type used by all types implementing GSeekable. It is used internally by the bindings. Users should use the interface [Seekable] instead.
type SeekableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Seekable = (*SeekableInstance)(nil)

// Seekable wraps GSeekable
// 
// see also https://docs.gtk.org/gio/interface.Seekable.html
//
type Seekable interface {
	upcastToGSeekable() *SeekableInstance

	// CanSeek wraps g_seekable_can_seek
	// 
	// see also https://docs.gtk.org/gio/method.g_seekable_can_seek.g_seekable_can_seek.html
	//
	CanSeek() bool
	// CanTruncate wraps g_seekable_can_truncate
	// 
	// see also https://docs.gtk.org/gio/method.g_seekable_can_truncate.g_seekable_can_truncate.html
	//
	CanTruncate() bool
	// Seek wraps g_seekable_seek
	// 
	// see also https://docs.gtk.org/gio/method.g_seekable_seek.g_seekable_seek.html
	//
	Seek(int64, glib.SeekType, Cancellable) (bool, error)
	// Tell wraps g_seekable_tell
	// 
	// see also https://docs.gtk.org/gio/method.g_seekable_tell.g_seekable_tell.html
	//
	Tell() int64
	// Truncate wraps g_seekable_truncate
	// 
	// see also https://docs.gtk.org/gio/method.g_seekable_truncate.g_seekable_truncate.html
	//
	Truncate(int64, Cancellable) (bool, error)
}

var _ Seekable = (*SeekableInstance)(nil)

func unsafeWrapSeekable(base *gobject.ObjectInstance) *SeekableInstance {
	return &SeekableInstance{
		Instance: *base,
	}
}

func marshalSeekableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (s *SeekableInstance) upcastToGSeekable() *SeekableInstance {
	return s
}

// UnsafeSeekableFromGlibNone is used to convert raw GSeekable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSeekableFromGlibNone(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibNone(c).(Seekable)
}

// UnsafeSeekableFromGlibFull is used to convert raw GSeekable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSeekableFromGlibFull(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibFull(c).(Seekable)
}

// UnsafeSeekableFromGlibBorrow is used to convert raw GSeekable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSeekableFromGlibBorrow(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Seekable)
}

// UnsafeSeekableToGlibNone is used to convert the instance to it's C value GSeekable. This is used by the bindings internally.
func UnsafeSeekableToGlibNone(c Seekable) unsafe.Pointer {
	i := c.upcastToGSeekable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeSeekableToGlibFull is used to convert the instance to it's C value GSeekable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSeekableToGlibFull(c Seekable) unsafe.Pointer {
	i := c.upcastToGSeekable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanSeek wraps g_seekable_can_seek
// 
// see also https://docs.gtk.org/gio/method.g_seekable_can_seek.g_seekable_can_seek.html
//
func (seekable *SeekableInstance) CanSeek() bool {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_can_seek(carg0)
	runtime.KeepAlive(seekable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanTruncate wraps g_seekable_can_truncate
// 
// see also https://docs.gtk.org/gio/method.g_seekable_can_truncate.g_seekable_can_truncate.html
//
func (seekable *SeekableInstance) CanTruncate() bool {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_can_truncate(carg0)
	runtime.KeepAlive(seekable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Seek wraps g_seekable_seek
// 
// see also https://docs.gtk.org/gio/method.g_seekable_seek.g_seekable_seek.html
//
func (seekable *SeekableInstance) Seek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSeekable    // in, none, converted
	var carg1 C.goffset       // in, none, casted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_seekable_seek(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Tell wraps g_seekable_tell
// 
// see also https://docs.gtk.org/gio/method.g_seekable_tell.g_seekable_tell.html
//
func (seekable *SeekableInstance) Tell() int64 {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.goffset    // return, none, casted

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_tell(carg0)
	runtime.KeepAlive(seekable)

	var goret int64

	goret = int64(cret)

	return goret
}

// Truncate wraps g_seekable_truncate
// 
// see also https://docs.gtk.org/gio/method.g_seekable_truncate.g_seekable_truncate.html
//
func (seekable *SeekableInstance) Truncate(offset int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSeekable    // in, none, converted
	var carg1 C.goffset       // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))
	carg1 = C.goffset(offset)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_seekable_truncate(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SocketConnectableInstance is the instance type used by all types implementing GSocketConnectable. It is used internally by the bindings. Users should use the interface [SocketConnectable] instead.
type SocketConnectableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ SocketConnectable = (*SocketConnectableInstance)(nil)

// SocketConnectable wraps GSocketConnectable
// 
// see also https://docs.gtk.org/gio/interface.SocketConnectable.html
//
type SocketConnectable interface {
	upcastToGSocketConnectable() *SocketConnectableInstance

	// Enumerate wraps g_socket_connectable_enumerate
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connectable_enumerate.g_socket_connectable_enumerate.html
	//
	Enumerate() SocketAddressEnumerator
	// ProxyEnumerate wraps g_socket_connectable_proxy_enumerate
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connectable_proxy_enumerate.g_socket_connectable_proxy_enumerate.html
	//
	ProxyEnumerate() SocketAddressEnumerator
	// String wraps g_socket_connectable_to_string
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connectable_to_string.g_socket_connectable_to_string.html
	//
	String() string
}

var _ SocketConnectable = (*SocketConnectableInstance)(nil)

func unsafeWrapSocketConnectable(base *gobject.ObjectInstance) *SocketConnectableInstance {
	return &SocketConnectableInstance{
		Instance: *base,
	}
}

func marshalSocketConnectableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (s *SocketConnectableInstance) upcastToGSocketConnectable() *SocketConnectableInstance {
	return s
}

// UnsafeSocketConnectableFromGlibNone is used to convert raw GSocketConnectable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibNone(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketConnectable)
}

// UnsafeSocketConnectableFromGlibFull is used to convert raw GSocketConnectable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibFull(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketConnectable)
}

// UnsafeSocketConnectableFromGlibBorrow is used to convert raw GSocketConnectable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibBorrow(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketConnectable)
}

// UnsafeSocketConnectableToGlibNone is used to convert the instance to it's C value GSocketConnectable. This is used by the bindings internally.
func UnsafeSocketConnectableToGlibNone(c SocketConnectable) unsafe.Pointer {
	i := c.upcastToGSocketConnectable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeSocketConnectableToGlibFull is used to convert the instance to it's C value GSocketConnectable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableToGlibFull(c SocketConnectable) unsafe.Pointer {
	i := c.upcastToGSocketConnectable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Enumerate wraps g_socket_connectable_enumerate
// 
// see also https://docs.gtk.org/gio/method.g_socket_connectable_enumerate.g_socket_connectable_enumerate.html
//
func (connectable *SocketConnectableInstance) Enumerate() SocketAddressEnumerator {
	var carg0 *C.GSocketConnectable       // in, none, converted
	var cret  *C.GSocketAddressEnumerator // return, full, converted

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_enumerate(carg0)
	runtime.KeepAlive(connectable)

	var goret SocketAddressEnumerator

	goret = UnsafeSocketAddressEnumeratorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ProxyEnumerate wraps g_socket_connectable_proxy_enumerate
// 
// see also https://docs.gtk.org/gio/method.g_socket_connectable_proxy_enumerate.g_socket_connectable_proxy_enumerate.html
//
func (connectable *SocketConnectableInstance) ProxyEnumerate() SocketAddressEnumerator {
	var carg0 *C.GSocketConnectable       // in, none, converted
	var cret  *C.GSocketAddressEnumerator // return, full, converted

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_proxy_enumerate(carg0)
	runtime.KeepAlive(connectable)

	var goret SocketAddressEnumerator

	goret = UnsafeSocketAddressEnumeratorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// String wraps g_socket_connectable_to_string
// 
// see also https://docs.gtk.org/gio/method.g_socket_connectable_to_string.g_socket_connectable_to_string.html
//
func (connectable *SocketConnectableInstance) String() string {
	var carg0 *C.GSocketConnectable // in, none, converted
	var cret  *C.gchar              // return, full, string

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_to_string(carg0)
	runtime.KeepAlive(connectable)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// TlsBackendInstance is the instance type used by all types implementing GTlsBackend. It is used internally by the bindings. Users should use the interface [TlsBackend] instead.
type TlsBackendInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsBackend = (*TlsBackendInstance)(nil)

// TlsBackend wraps GTlsBackend
// 
// see also https://docs.gtk.org/gio/interface.TlsBackend.html
//
type TlsBackend interface {
	upcastToGTlsBackend() *TlsBackendInstance

	// GetCertificateType wraps g_tls_backend_get_certificate_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_certificate_type.g_tls_backend_get_certificate_type.html
	//
	GetCertificateType() gobject.Type
	// GetClientConnectionType wraps g_tls_backend_get_client_connection_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_client_connection_type.g_tls_backend_get_client_connection_type.html
	//
	GetClientConnectionType() gobject.Type
	// GetDefaultDatabase wraps g_tls_backend_get_default_database
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_default_database.g_tls_backend_get_default_database.html
	//
	GetDefaultDatabase() TlsDatabase
	// GetDtlsClientConnectionType wraps g_tls_backend_get_dtls_client_connection_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_dtls_client_connection_type.g_tls_backend_get_dtls_client_connection_type.html
	//
	GetDtlsClientConnectionType() gobject.Type
	// GetDtlsServerConnectionType wraps g_tls_backend_get_dtls_server_connection_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_dtls_server_connection_type.g_tls_backend_get_dtls_server_connection_type.html
	//
	GetDtlsServerConnectionType() gobject.Type
	// GetFileDatabaseType wraps g_tls_backend_get_file_database_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_file_database_type.g_tls_backend_get_file_database_type.html
	//
	GetFileDatabaseType() gobject.Type
	// GetServerConnectionType wraps g_tls_backend_get_server_connection_type
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_get_server_connection_type.g_tls_backend_get_server_connection_type.html
	//
	GetServerConnectionType() gobject.Type
	// SetDefaultDatabase wraps g_tls_backend_set_default_database
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_set_default_database.g_tls_backend_set_default_database.html
	//
	SetDefaultDatabase(TlsDatabase)
	// SupportsDtls wraps g_tls_backend_supports_dtls
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_supports_dtls.g_tls_backend_supports_dtls.html
	//
	SupportsDtls() bool
	// SupportsTls wraps g_tls_backend_supports_tls
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_backend_supports_tls.g_tls_backend_supports_tls.html
	//
	SupportsTls() bool
}

var _ TlsBackend = (*TlsBackendInstance)(nil)

func unsafeWrapTlsBackend(base *gobject.ObjectInstance) *TlsBackendInstance {
	return &TlsBackendInstance{
		Instance: *base,
	}
}

func marshalTlsBackendInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsBackendInstance) upcastToGTlsBackend() *TlsBackendInstance {
	return t
}

// UnsafeTlsBackendFromGlibNone is used to convert raw GTlsBackend pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibNone(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsBackend)
}

// UnsafeTlsBackendFromGlibFull is used to convert raw GTlsBackend pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibFull(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsBackend)
}

// UnsafeTlsBackendFromGlibBorrow is used to convert raw GTlsBackend pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibBorrow(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsBackend)
}

// UnsafeTlsBackendToGlibNone is used to convert the instance to it's C value GTlsBackend. This is used by the bindings internally.
func UnsafeTlsBackendToGlibNone(c TlsBackend) unsafe.Pointer {
	i := c.upcastToGTlsBackend()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsBackendToGlibFull is used to convert the instance to it's C value GTlsBackend, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsBackendToGlibFull(c TlsBackend) unsafe.Pointer {
	i := c.upcastToGTlsBackend()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// TlsBackendGetDefault wraps g_tls_backend_get_default
// 
// see also https://docs.gtk.org/gio/func.g_tls_backend_get_default.html
//
func TlsBackendGetDefault() TlsBackend {
	var cret *C.GTlsBackend // return, none, converted

	cret = C.g_tls_backend_get_default()

	var goret TlsBackend

	goret = UnsafeTlsBackendFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCertificateType wraps g_tls_backend_get_certificate_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_certificate_type.g_tls_backend_get_certificate_type.html
//
func (backend *TlsBackendInstance) GetCertificateType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_certificate_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetClientConnectionType wraps g_tls_backend_get_client_connection_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_client_connection_type.g_tls_backend_get_client_connection_type.html
//
func (backend *TlsBackendInstance) GetClientConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_client_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetDefaultDatabase wraps g_tls_backend_get_default_database
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_default_database.g_tls_backend_get_default_database.html
//
func (backend *TlsBackendInstance) GetDefaultDatabase() TlsDatabase {
	var carg0 *C.GTlsBackend  // in, none, converted
	var cret  *C.GTlsDatabase // return, full, converted

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_default_database(carg0)
	runtime.KeepAlive(backend)

	var goret TlsDatabase

	goret = UnsafeTlsDatabaseFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDtlsClientConnectionType wraps g_tls_backend_get_dtls_client_connection_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_dtls_client_connection_type.g_tls_backend_get_dtls_client_connection_type.html
//
func (backend *TlsBackendInstance) GetDtlsClientConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_dtls_client_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetDtlsServerConnectionType wraps g_tls_backend_get_dtls_server_connection_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_dtls_server_connection_type.g_tls_backend_get_dtls_server_connection_type.html
//
func (backend *TlsBackendInstance) GetDtlsServerConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_dtls_server_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetFileDatabaseType wraps g_tls_backend_get_file_database_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_file_database_type.g_tls_backend_get_file_database_type.html
//
func (backend *TlsBackendInstance) GetFileDatabaseType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_file_database_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetServerConnectionType wraps g_tls_backend_get_server_connection_type
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_get_server_connection_type.g_tls_backend_get_server_connection_type.html
//
func (backend *TlsBackendInstance) GetServerConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_server_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SetDefaultDatabase wraps g_tls_backend_set_default_database
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_set_default_database.g_tls_backend_set_default_database.html
//
func (backend *TlsBackendInstance) SetDefaultDatabase(database TlsDatabase) {
	var carg0 *C.GTlsBackend  // in, none, converted
	var carg1 *C.GTlsDatabase // in, none, converted, nullable

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_tls_backend_set_default_database(carg0, carg1)
	runtime.KeepAlive(backend)
	runtime.KeepAlive(database)
}

// SupportsDtls wraps g_tls_backend_supports_dtls
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_supports_dtls.g_tls_backend_supports_dtls.html
//
func (backend *TlsBackendInstance) SupportsDtls() bool {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_supports_dtls(carg0)
	runtime.KeepAlive(backend)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsTls wraps g_tls_backend_supports_tls
// 
// see also https://docs.gtk.org/gio/method.g_tls_backend_supports_tls.g_tls_backend_supports_tls.html
//
func (backend *TlsBackendInstance) SupportsTls() bool {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_supports_tls(carg0)
	runtime.KeepAlive(backend)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TlsClientConnectionInstance is the instance type used by all types implementing GTlsClientConnection. It is used internally by the bindings. Users should use the interface [TlsClientConnection] instead.
type TlsClientConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsClientConnection = (*TlsClientConnectionInstance)(nil)

// TlsClientConnection wraps GTlsClientConnection
// 
// see also https://docs.gtk.org/gio/interface.TlsClientConnection.html
//
type TlsClientConnection interface {
	upcastToGTlsClientConnection() *TlsClientConnectionInstance

	// CopySessionState wraps g_tls_client_connection_copy_session_state
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_copy_session_state.g_tls_client_connection_copy_session_state.html
	//
	CopySessionState(TlsClientConnection)
	// GetServerIdentity wraps g_tls_client_connection_get_server_identity
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_server_identity.g_tls_client_connection_get_server_identity.html
	//
	GetServerIdentity() SocketConnectable
	// GetUseSsl3 wraps g_tls_client_connection_get_use_ssl3
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_use_ssl3.g_tls_client_connection_get_use_ssl3.html
	//
	//
	// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
	GetUseSsl3() bool
	// GetValidationFlags wraps g_tls_client_connection_get_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_validation_flags.g_tls_client_connection_get_validation_flags.html
	//
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	GetValidationFlags() TlsCertificateFlags
	// SetServerIdentity wraps g_tls_client_connection_set_server_identity
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_server_identity.g_tls_client_connection_set_server_identity.html
	//
	SetServerIdentity(SocketConnectable)
	// SetUseSsl3 wraps g_tls_client_connection_set_use_ssl3
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_use_ssl3.g_tls_client_connection_set_use_ssl3.html
	//
	//
	// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
	SetUseSsl3(bool)
	// SetValidationFlags wraps g_tls_client_connection_set_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_validation_flags.g_tls_client_connection_set_validation_flags.html
	//
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	SetValidationFlags(TlsCertificateFlags)
}

var _ TlsClientConnection = (*TlsClientConnectionInstance)(nil)

func unsafeWrapTlsClientConnection(base *gobject.ObjectInstance) *TlsClientConnectionInstance {
	return &TlsClientConnectionInstance{
		Instance: *base,
	}
}

func marshalTlsClientConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsClientConnectionInstance) upcastToGTlsClientConnection() *TlsClientConnectionInstance {
	return t
}

// UnsafeTlsClientConnectionFromGlibNone is used to convert raw GTlsClientConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibNone(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionFromGlibFull is used to convert raw GTlsClientConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibFull(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionFromGlibBorrow is used to convert raw GTlsClientConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibBorrow(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionToGlibNone is used to convert the instance to it's C value GTlsClientConnection. This is used by the bindings internally.
func UnsafeTlsClientConnectionToGlibNone(c TlsClientConnection) unsafe.Pointer {
	i := c.upcastToGTlsClientConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsClientConnectionToGlibFull is used to convert the instance to it's C value GTlsClientConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionToGlibFull(c TlsClientConnection) unsafe.Pointer {
	i := c.upcastToGTlsClientConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsClientConnection wraps g_tls_client_connection_new
// 
// see also https://docs.gtk.org/gio/func.g_tls_client_connection_new.html
//
func NewTlsClientConnection(baseIoStream IOStream, serverIdentity SocketConnectable) (TlsClientConnection, error) {
	var carg1 *C.GIOStream          // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, converted, nullable
	var cret  *C.GIOStream          // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	if serverIdentity != nil {
		carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(serverIdentity))
	}

	cret = C.g_tls_client_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(serverIdentity)

	var goret  TlsClientConnection
	var _goerr error

	goret = UnsafeTlsClientConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopySessionState wraps g_tls_client_connection_copy_session_state
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_copy_session_state.g_tls_client_connection_copy_session_state.html
//
func (conn *TlsClientConnectionInstance) CopySessionState(source TlsClientConnection) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 *C.GTlsClientConnection // in, none, converted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(source))

	C.g_tls_client_connection_copy_session_state(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

// GetServerIdentity wraps g_tls_client_connection_get_server_identity
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_server_identity.g_tls_client_connection_get_server_identity.html
//
func (conn *TlsClientConnectionInstance) GetServerIdentity() SocketConnectable {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  *C.GSocketConnectable   // return, none, converted, nullable

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_server_identity(carg0)
	runtime.KeepAlive(conn)

	var goret SocketConnectable

	if cret != nil {
		goret = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetUseSsl3 wraps g_tls_client_connection_get_use_ssl3
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_use_ssl3.g_tls_client_connection_get_use_ssl3.html
//
//
// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
func (conn *TlsClientConnectionInstance) GetUseSsl3() bool {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_use_ssl3(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetValidationFlags wraps g_tls_client_connection_get_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_get_validation_flags.g_tls_client_connection_get_validation_flags.html
//
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (conn *TlsClientConnectionInstance) GetValidationFlags() TlsCertificateFlags {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  C.GTlsCertificateFlags  // return, none, casted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_validation_flags(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetServerIdentity wraps g_tls_client_connection_set_server_identity
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_server_identity.g_tls_client_connection_set_server_identity.html
//
func (conn *TlsClientConnectionInstance) SetServerIdentity(identity SocketConnectable) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 *C.GSocketConnectable   // in, none, converted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))

	C.g_tls_client_connection_set_server_identity(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetUseSsl3 wraps g_tls_client_connection_set_use_ssl3
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_use_ssl3.g_tls_client_connection_set_use_ssl3.html
//
//
// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
func (conn *TlsClientConnectionInstance) SetUseSsl3(useSsl3 bool) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 C.gboolean              // in

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	if useSsl3 {
		carg1 = C.TRUE
	}

	C.g_tls_client_connection_set_use_ssl3(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSsl3)
}

// SetValidationFlags wraps g_tls_client_connection_set_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_tls_client_connection_set_validation_flags.g_tls_client_connection_set_validation_flags.html
//
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (conn *TlsClientConnectionInstance) SetValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 C.GTlsCertificateFlags  // in, none, casted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_tls_client_connection_set_validation_flags(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// TlsFileDatabaseInstance is the instance type used by all types implementing GTlsFileDatabase. It is used internally by the bindings. Users should use the interface [TlsFileDatabase] instead.
type TlsFileDatabaseInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsFileDatabase = (*TlsFileDatabaseInstance)(nil)

// TlsFileDatabase wraps GTlsFileDatabase
// 
// see also https://docs.gtk.org/gio/interface.TlsFileDatabase.html
//
type TlsFileDatabase interface {
	upcastToGTlsFileDatabase() *TlsFileDatabaseInstance
}

var _ TlsFileDatabase = (*TlsFileDatabaseInstance)(nil)

func unsafeWrapTlsFileDatabase(base *gobject.ObjectInstance) *TlsFileDatabaseInstance {
	return &TlsFileDatabaseInstance{
		Instance: *base,
	}
}

func marshalTlsFileDatabaseInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsFileDatabaseInstance) upcastToGTlsFileDatabase() *TlsFileDatabaseInstance {
	return t
}

// UnsafeTlsFileDatabaseFromGlibNone is used to convert raw GTlsFileDatabase pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibNone(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseFromGlibFull is used to convert raw GTlsFileDatabase pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibFull(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseFromGlibBorrow is used to convert raw GTlsFileDatabase pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibBorrow(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseToGlibNone is used to convert the instance to it's C value GTlsFileDatabase. This is used by the bindings internally.
func UnsafeTlsFileDatabaseToGlibNone(c TlsFileDatabase) unsafe.Pointer {
	i := c.upcastToGTlsFileDatabase()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsFileDatabaseToGlibFull is used to convert the instance to it's C value GTlsFileDatabase, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseToGlibFull(c TlsFileDatabase) unsafe.Pointer {
	i := c.upcastToGTlsFileDatabase()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsFileDatabase wraps g_tls_file_database_new
// 
// see also https://docs.gtk.org/gio/func.g_tls_file_database_new.html
//
func NewTlsFileDatabase(anchors string) (TlsFileDatabase, error) {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GTlsDatabase // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(anchors)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_file_database_new(carg1, &_cerr)
	runtime.KeepAlive(anchors)

	var goret  TlsFileDatabase
	var _goerr error

	goret = UnsafeTlsFileDatabaseFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsServerConnectionInstance is the instance type used by all types implementing GTlsServerConnection. It is used internally by the bindings. Users should use the interface [TlsServerConnection] instead.
type TlsServerConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsServerConnection = (*TlsServerConnectionInstance)(nil)

// TlsServerConnection wraps GTlsServerConnection
// 
// see also https://docs.gtk.org/gio/interface.TlsServerConnection.html
//
type TlsServerConnection interface {
	upcastToGTlsServerConnection() *TlsServerConnectionInstance
}

var _ TlsServerConnection = (*TlsServerConnectionInstance)(nil)

func unsafeWrapTlsServerConnection(base *gobject.ObjectInstance) *TlsServerConnectionInstance {
	return &TlsServerConnectionInstance{
		Instance: *base,
	}
}

func marshalTlsServerConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsServerConnectionInstance) upcastToGTlsServerConnection() *TlsServerConnectionInstance {
	return t
}

// UnsafeTlsServerConnectionFromGlibNone is used to convert raw GTlsServerConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibNone(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionFromGlibFull is used to convert raw GTlsServerConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibFull(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionFromGlibBorrow is used to convert raw GTlsServerConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibBorrow(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionToGlibNone is used to convert the instance to it's C value GTlsServerConnection. This is used by the bindings internally.
func UnsafeTlsServerConnectionToGlibNone(c TlsServerConnection) unsafe.Pointer {
	i := c.upcastToGTlsServerConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsServerConnectionToGlibFull is used to convert the instance to it's C value GTlsServerConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionToGlibFull(c TlsServerConnection) unsafe.Pointer {
	i := c.upcastToGTlsServerConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsServerConnection wraps g_tls_server_connection_new
// 
// see also https://docs.gtk.org/gio/func.g_tls_server_connection_new.html
//
func NewTlsServerConnection(baseIoStream IOStream, certificate TlsCertificate) (TlsServerConnection, error) {
	var carg1 *C.GIOStream       // in, none, converted
	var carg2 *C.GTlsCertificate // in, none, converted, nullable
	var cret  *C.GIOStream       // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	if certificate != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	}

	cret = C.g_tls_server_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(certificate)

	var goret  TlsServerConnection
	var _goerr error

	goret = UnsafeTlsServerConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VolumeInstance is the instance type used by all types implementing GVolume. It is used internally by the bindings. Users should use the interface [Volume] instead.
type VolumeInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Volume = (*VolumeInstance)(nil)

// Volume wraps GVolume
// 
// see also https://docs.gtk.org/gio/interface.Volume.html
//
type Volume interface {
	upcastToGVolume() *VolumeInstance

	// CanEject wraps g_volume_can_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_can_eject.g_volume_can_eject.html
	//
	CanEject() bool
	// CanMount wraps g_volume_can_mount
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_can_mount.g_volume_can_mount.html
	//
	CanMount() bool
	// Eject wraps g_volume_eject
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_eject.g_volume_eject.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_volume_eject_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_eject_finish.g_volume_eject_finish.html
	//
	//
	// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_volume_eject_with_operation
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_eject_with_operation.g_volume_eject_with_operation.html
	//
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_volume_eject_with_operation_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_eject_with_operation_finish.g_volume_eject_with_operation_finish.html
	//
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateIdentifiers wraps g_volume_enumerate_identifiers
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_enumerate_identifiers.g_volume_enumerate_identifiers.html
	//
	EnumerateIdentifiers() []string
	// GetActivationRoot wraps g_volume_get_activation_root
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_activation_root.g_volume_get_activation_root.html
	//
	GetActivationRoot() File
	// GetDrive wraps g_volume_get_drive
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_drive.g_volume_get_drive.html
	//
	GetDrive() Drive
	// GetIcon wraps g_volume_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_icon.g_volume_get_icon.html
	//
	GetIcon() Icon
	// GetIdentifier wraps g_volume_get_identifier
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_identifier.g_volume_get_identifier.html
	//
	GetIdentifier(string) string
	// GetMount wraps g_volume_get_mount
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_mount.g_volume_get_mount.html
	//
	GetMount() Mount
	// GetName wraps g_volume_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_name.g_volume_get_name.html
	//
	GetName() string
	// GetSortKey wraps g_volume_get_sort_key
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_sort_key.g_volume_get_sort_key.html
	//
	GetSortKey() string
	// GetSymbolicIcon wraps g_volume_get_symbolic_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_symbolic_icon.g_volume_get_symbolic_icon.html
	//
	GetSymbolicIcon() Icon
	// GetUuid wraps g_volume_get_uuid
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_get_uuid.g_volume_get_uuid.html
	//
	GetUuid() string
	// Mount wraps g_volume_mount
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_mount.g_volume_mount.html
	//
	Mount(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountFinish wraps g_volume_mount_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_mount_finish.g_volume_mount_finish.html
	//
	MountFinish(AsyncResult) (bool, error)
	// ShouldAutomount wraps g_volume_should_automount
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_should_automount.g_volume_should_automount.html
	//
	ShouldAutomount() bool
	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Volume.changed.html
	//
	ConnectChanged(func(Volume)) gobject.SignalHandle
	// ConnectRemoved connects the provided callback to the "removed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Volume.removed.html
	//
	ConnectRemoved(func(Volume)) gobject.SignalHandle
}

var _ Volume = (*VolumeInstance)(nil)

func unsafeWrapVolume(base *gobject.ObjectInstance) *VolumeInstance {
	return &VolumeInstance{
		Instance: *base,
	}
}

func marshalVolumeInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (v *VolumeInstance) upcastToGVolume() *VolumeInstance {
	return v
}

// UnsafeVolumeFromGlibNone is used to convert raw GVolume pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeFromGlibNone(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibNone(c).(Volume)
}

// UnsafeVolumeFromGlibFull is used to convert raw GVolume pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeFromGlibFull(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibFull(c).(Volume)
}

// UnsafeVolumeFromGlibBorrow is used to convert raw GVolume pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVolumeFromGlibBorrow(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Volume)
}

// UnsafeVolumeToGlibNone is used to convert the instance to it's C value GVolume. This is used by the bindings internally.
func UnsafeVolumeToGlibNone(c Volume) unsafe.Pointer {
	i := c.upcastToGVolume()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeVolumeToGlibFull is used to convert the instance to it's C value GVolume, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVolumeToGlibFull(c Volume) unsafe.Pointer {
	i := c.upcastToGVolume()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_volume_can_eject
// 
// see also https://docs.gtk.org/gio/method.g_volume_can_eject.g_volume_can_eject.html
//
func (volume *VolumeInstance) CanEject() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_can_eject(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanMount wraps g_volume_can_mount
// 
// see also https://docs.gtk.org/gio/method.g_volume_can_mount.g_volume_can_mount.html
//
func (volume *VolumeInstance) CanMount() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_can_mount(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_volume_eject
// 
// see also https://docs.gtk.org/gio/method.g_volume_eject.g_volume_eject.html
//
//
// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation() instead.
func (volume *VolumeInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_volume_eject_finish
// 
// see also https://docs.gtk.org/gio/method.g_volume_eject_finish.g_volume_eject_finish.html
//
//
// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation_finish() instead.
func (volume *VolumeInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_volume_eject_with_operation
// 
// see also https://docs.gtk.org/gio/method.g_volume_eject_with_operation.g_volume_eject_with_operation.html
//
func (volume *VolumeInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_volume_eject_with_operation_finish
// 
// see also https://docs.gtk.org/gio/method.g_volume_eject_with_operation_finish.g_volume_eject_with_operation_finish.html
//
func (volume *VolumeInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateIdentifiers wraps g_volume_enumerate_identifiers
// 
// see also https://docs.gtk.org/gio/method.g_volume_enumerate_identifiers.g_volume_enumerate_identifiers.html
//
func (volume *VolumeInstance) EnumerateIdentifiers() []string {
	var carg0 *C.GVolume // in, none, converted
	var cret  **C.char   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_enumerate_identifiers(carg0)
	runtime.KeepAlive(volume)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetActivationRoot wraps g_volume_get_activation_root
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_activation_root.g_volume_get_activation_root.html
//
func (volume *VolumeInstance) GetActivationRoot() File {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GFile   // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_activation_root(carg0)
	runtime.KeepAlive(volume)

	var goret File

	if cret != nil {
		goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetDrive wraps g_volume_get_drive
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_drive.g_volume_get_drive.html
//
func (volume *VolumeInstance) GetDrive() Drive {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GDrive  // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_drive(carg0)
	runtime.KeepAlive(volume)

	var goret Drive

	if cret != nil {
		goret = UnsafeDriveFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetIcon wraps g_volume_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_icon.g_volume_get_icon.html
//
func (volume *VolumeInstance) GetIcon() Icon {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GIcon   // return, full, converted

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_icon(carg0)
	runtime.KeepAlive(volume)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIdentifier wraps g_volume_get_identifier
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_identifier.g_volume_get_identifier.html
//
func (volume *VolumeInstance) GetIdentifier(kind string) string {
	var carg0 *C.GVolume // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  *C.char    // return, full, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_get_identifier(carg0, carg1)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(kind)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetMount wraps g_volume_get_mount
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_mount.g_volume_get_mount.html
//
func (volume *VolumeInstance) GetMount() Mount {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GMount  // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_mount(carg0)
	runtime.KeepAlive(volume)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetName wraps g_volume_get_name
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_name.g_volume_get_name.html
//
func (volume *VolumeInstance) GetName() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.char    // return, full, string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_name(carg0)
	runtime.KeepAlive(volume)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_volume_get_sort_key
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_sort_key.g_volume_get_sort_key.html
//
func (volume *VolumeInstance) GetSortKey() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_sort_key(carg0)
	runtime.KeepAlive(volume)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetSymbolicIcon wraps g_volume_get_symbolic_icon
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_symbolic_icon.g_volume_get_symbolic_icon.html
//
func (volume *VolumeInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GIcon   // return, full, converted

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_symbolic_icon(carg0)
	runtime.KeepAlive(volume)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetUuid wraps g_volume_get_uuid
// 
// see also https://docs.gtk.org/gio/method.g_volume_get_uuid.g_volume_get_uuid.html
//
func (volume *VolumeInstance) GetUuid() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.char    // return, full, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_uuid(carg0)
	runtime.KeepAlive(volume)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Mount wraps g_volume_mount
// 
// see also https://docs.gtk.org/gio/method.g_volume_mount.g_volume_mount.html
//
func (volume *VolumeInstance) Mount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_mount(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountFinish wraps g_volume_mount_finish
// 
// see also https://docs.gtk.org/gio/method.g_volume_mount_finish.g_volume_mount_finish.html
//
func (volume *VolumeInstance) MountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_mount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShouldAutomount wraps g_volume_should_automount
// 
// see also https://docs.gtk.org/gio/method.g_volume_should_automount.g_volume_should_automount.html
//
func (volume *VolumeInstance) ShouldAutomount() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_should_automount(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.Volume.changed.html
//
func (o *VolumeInstance) ConnectChanged(fn func(Volume)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectRemoved connects the provided callback to the "removed" signal
// 
// see also https://docs.gtk.org/gio/signal.Volume.removed.html
//
func (o *VolumeInstance) ConnectRemoved(fn func(Volume)) gobject.SignalHandle {
	return o.Instance.Connect("removed", fn)
}

// DebugControllerInstance is the instance type used by all types implementing GDebugController. It is used internally by the bindings. Users should use the interface [DebugController] instead.
type DebugControllerInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DebugController = (*DebugControllerInstance)(nil)

// DebugController wraps GDebugController
// 
// see also https://docs.gtk.org/gio/interface.DebugController.html
//
type DebugController interface {
	upcastToGDebugController() *DebugControllerInstance

	// GetDebugEnabled wraps g_debug_controller_get_debug_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_debug_controller_get_debug_enabled.g_debug_controller_get_debug_enabled.html
	//
	GetDebugEnabled() bool
	// SetDebugEnabled wraps g_debug_controller_set_debug_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_debug_controller_set_debug_enabled.g_debug_controller_set_debug_enabled.html
	//
	SetDebugEnabled(bool)
}

var _ DebugController = (*DebugControllerInstance)(nil)

func unsafeWrapDebugController(base *gobject.ObjectInstance) *DebugControllerInstance {
	return &DebugControllerInstance{
		Instance: *base,
	}
}

func marshalDebugControllerInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DebugControllerInstance) upcastToGDebugController() *DebugControllerInstance {
	return d
}

// UnsafeDebugControllerFromGlibNone is used to convert raw GDebugController pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibNone(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibNone(c).(DebugController)
}

// UnsafeDebugControllerFromGlibFull is used to convert raw GDebugController pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibFull(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibFull(c).(DebugController)
}

// UnsafeDebugControllerFromGlibBorrow is used to convert raw GDebugController pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibBorrow(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DebugController)
}

// UnsafeDebugControllerToGlibNone is used to convert the instance to it's C value GDebugController. This is used by the bindings internally.
func UnsafeDebugControllerToGlibNone(c DebugController) unsafe.Pointer {
	i := c.upcastToGDebugController()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDebugControllerToGlibFull is used to convert the instance to it's C value GDebugController, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDebugControllerToGlibFull(c DebugController) unsafe.Pointer {
	i := c.upcastToGDebugController()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetDebugEnabled wraps g_debug_controller_get_debug_enabled
// 
// see also https://docs.gtk.org/gio/method.g_debug_controller_get_debug_enabled.g_debug_controller_get_debug_enabled.html
//
func (self *DebugControllerInstance) GetDebugEnabled() bool {
	var carg0 *C.GDebugController // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GDebugController)(UnsafeDebugControllerToGlibNone(self))

	cret = C.g_debug_controller_get_debug_enabled(carg0)
	runtime.KeepAlive(self)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetDebugEnabled wraps g_debug_controller_set_debug_enabled
// 
// see also https://docs.gtk.org/gio/method.g_debug_controller_set_debug_enabled.g_debug_controller_set_debug_enabled.html
//
func (self *DebugControllerInstance) SetDebugEnabled(debugEnabled bool) {
	var carg0 *C.GDebugController // in, none, converted
	var carg1 C.gboolean          // in

	carg0 = (*C.GDebugController)(UnsafeDebugControllerToGlibNone(self))
	if debugEnabled {
		carg1 = C.TRUE
	}

	C.g_debug_controller_set_debug_enabled(carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(debugEnabled)
}

// DtlsClientConnectionInstance is the instance type used by all types implementing GDtlsClientConnection. It is used internally by the bindings. Users should use the interface [DtlsClientConnection] instead.
type DtlsClientConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsClientConnection = (*DtlsClientConnectionInstance)(nil)

// DtlsClientConnection wraps GDtlsClientConnection
// 
// see also https://docs.gtk.org/gio/interface.DtlsClientConnection.html
//
type DtlsClientConnection interface {
	upcastToGDtlsClientConnection() *DtlsClientConnectionInstance

	// GetServerIdentity wraps g_dtls_client_connection_get_server_identity
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_get_server_identity.g_dtls_client_connection_get_server_identity.html
	//
	GetServerIdentity() SocketConnectable
	// GetValidationFlags wraps g_dtls_client_connection_get_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_get_validation_flags.g_dtls_client_connection_get_validation_flags.html
	//
	//
	// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
	GetValidationFlags() TlsCertificateFlags
	// SetServerIdentity wraps g_dtls_client_connection_set_server_identity
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_set_server_identity.g_dtls_client_connection_set_server_identity.html
	//
	SetServerIdentity(SocketConnectable)
	// SetValidationFlags wraps g_dtls_client_connection_set_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_set_validation_flags.g_dtls_client_connection_set_validation_flags.html
	//
	//
	// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
	SetValidationFlags(TlsCertificateFlags)
}

var _ DtlsClientConnection = (*DtlsClientConnectionInstance)(nil)

func unsafeWrapDtlsClientConnection(base *gobject.ObjectInstance) *DtlsClientConnectionInstance {
	return &DtlsClientConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsClientConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsClientConnectionInstance) upcastToGDtlsClientConnection() *DtlsClientConnectionInstance {
	return d
}

// UnsafeDtlsClientConnectionFromGlibNone is used to convert raw GDtlsClientConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibNone(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionFromGlibFull is used to convert raw GDtlsClientConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibFull(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionFromGlibBorrow is used to convert raw GDtlsClientConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibBorrow(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionToGlibNone is used to convert the instance to it's C value GDtlsClientConnection. This is used by the bindings internally.
func UnsafeDtlsClientConnectionToGlibNone(c DtlsClientConnection) unsafe.Pointer {
	i := c.upcastToGDtlsClientConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsClientConnectionToGlibFull is used to convert the instance to it's C value GDtlsClientConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionToGlibFull(c DtlsClientConnection) unsafe.Pointer {
	i := c.upcastToGDtlsClientConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewDtlsClientConnection wraps g_dtls_client_connection_new
// 
// see also https://docs.gtk.org/gio/func.g_dtls_client_connection_new.html
//
func NewDtlsClientConnection(baseSocket DatagramBased, serverIdentity SocketConnectable) (DtlsClientConnection, error) {
	var carg1 *C.GDatagramBased     // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, converted, nullable
	var cret  *C.GDatagramBased     // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(baseSocket))
	if serverIdentity != nil {
		carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(serverIdentity))
	}

	cret = C.g_dtls_client_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(serverIdentity)

	var goret  DtlsClientConnection
	var _goerr error

	goret = UnsafeDtlsClientConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetServerIdentity wraps g_dtls_client_connection_get_server_identity
// 
// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_get_server_identity.g_dtls_client_connection_get_server_identity.html
//
func (conn *DtlsClientConnectionInstance) GetServerIdentity() SocketConnectable {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var cret  *C.GSocketConnectable    // return, none, converted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))

	cret = C.g_dtls_client_connection_get_server_identity(carg0)
	runtime.KeepAlive(conn)

	var goret SocketConnectable

	goret = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetValidationFlags wraps g_dtls_client_connection_get_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_get_validation_flags.g_dtls_client_connection_get_validation_flags.html
//
//
// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
func (conn *DtlsClientConnectionInstance) GetValidationFlags() TlsCertificateFlags {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var cret  C.GTlsCertificateFlags   // return, none, casted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))

	cret = C.g_dtls_client_connection_get_validation_flags(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetServerIdentity wraps g_dtls_client_connection_set_server_identity
// 
// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_set_server_identity.g_dtls_client_connection_set_server_identity.html
//
func (conn *DtlsClientConnectionInstance) SetServerIdentity(identity SocketConnectable) {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var carg1 *C.GSocketConnectable    // in, none, converted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))

	C.g_dtls_client_connection_set_server_identity(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetValidationFlags wraps g_dtls_client_connection_set_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_dtls_client_connection_set_validation_flags.g_dtls_client_connection_set_validation_flags.html
//
//
// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
func (conn *DtlsClientConnectionInstance) SetValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var carg1 C.GTlsCertificateFlags   // in, none, casted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_dtls_client_connection_set_validation_flags(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// AppInfoMonitorInstance is the instance type used by all types extending GAppInfoMonitor. It is used internally by the bindings. Users should use the interface [AppInfoMonitor] instead.
type AppInfoMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ AppInfoMonitor = (*AppInfoMonitorInstance)(nil)

// AppInfoMonitor wraps GAppInfoMonitor
// 
// see also https://docs.gtk.org/gio/class.AppInfoMonitor.html
//
type AppInfoMonitor interface {
	gobject.Object
	upcastToGAppInfoMonitor() *AppInfoMonitorInstance

	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.AppInfoMonitor.changed.html
	//
	ConnectChanged(func(AppInfoMonitor)) gobject.SignalHandle
}

func unsafeWrapAppInfoMonitor(base *gobject.ObjectInstance) *AppInfoMonitorInstance {
	return &AppInfoMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeAppInfoMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppInfoMonitor(inst)
		},
	)
}

func marshalAppInfoMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeAppInfoMonitorFromGlibNone is used to convert raw GAppInfoMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibNone(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(AppInfoMonitor)
}

// UnsafeAppInfoMonitorFromGlibFull is used to convert raw GAppInfoMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibFull(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(AppInfoMonitor)
}

// UnsafeAppInfoMonitorFromGlibBorrow is used to convert raw GAppInfoMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibBorrow(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppInfoMonitor)
}

func (a *AppInfoMonitorInstance) upcastToGAppInfoMonitor() *AppInfoMonitorInstance {
	return a
}

// UnsafeAppInfoMonitorToGlibNone is used to convert the instance to it's C value GAppInfoMonitor. This is used by the bindings internally.
func UnsafeAppInfoMonitorToGlibNone(c AppInfoMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeAppInfoMonitorToGlibFull is used to convert the instance to it's C value GAppInfoMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorToGlibFull(c AppInfoMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// AppInfoMonitorGet wraps g_app_info_monitor_get
// 
// see also https://docs.gtk.org/gio/func.g_app_info_monitor_get.html
//
func AppInfoMonitorGet() AppInfoMonitor {
	var cret *C.GAppInfoMonitor // return, full, converted

	cret = C.g_app_info_monitor_get()

	var goret AppInfoMonitor

	goret = UnsafeAppInfoMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.AppInfoMonitor.changed.html
//
func (o *AppInfoMonitorInstance) ConnectChanged(fn func(AppInfoMonitor)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// AppLaunchContextInstance is the instance type used by all types extending GAppLaunchContext. It is used internally by the bindings. Users should use the interface [AppLaunchContext] instead.
type AppLaunchContextInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ AppLaunchContext = (*AppLaunchContextInstance)(nil)

// AppLaunchContext wraps GAppLaunchContext
// 
// see also https://docs.gtk.org/gio/class.AppLaunchContext.html
//
type AppLaunchContext interface {
	gobject.Object
	upcastToGAppLaunchContext() *AppLaunchContextInstance

	// GetEnvironment wraps g_app_launch_context_get_environment
	// 
	// see also https://docs.gtk.org/gio/method.g_app_launch_context_get_environment.g_app_launch_context_get_environment.html
	//
	GetEnvironment() []string
	// LaunchFailed wraps g_app_launch_context_launch_failed
	// 
	// see also https://docs.gtk.org/gio/method.g_app_launch_context_launch_failed.g_app_launch_context_launch_failed.html
	//
	LaunchFailed(string)
	// Setenv wraps g_app_launch_context_setenv
	// 
	// see also https://docs.gtk.org/gio/method.g_app_launch_context_setenv.g_app_launch_context_setenv.html
	//
	Setenv(string, string)
	// Unsetenv wraps g_app_launch_context_unsetenv
	// 
	// see also https://docs.gtk.org/gio/method.g_app_launch_context_unsetenv.g_app_launch_context_unsetenv.html
	//
	Unsetenv(string)
	// ConnectLaunchFailed connects the provided callback to the "launch-failed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.AppLaunchContext.launch-failed.html
	//
	ConnectLaunchFailed(func(AppLaunchContext, string)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentLaunchFailed calls the default implementations of the `GAppLaunchContext.launch_failed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.AppLaunchContext.launch_failed.html
	ParentLaunchFailed(startupNotifyId string)
}

func unsafeWrapAppLaunchContext(base *gobject.ObjectInstance) *AppLaunchContextInstance {
	return &AppLaunchContextInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeAppLaunchContext,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppLaunchContext(inst)
		},
	)
}

func marshalAppLaunchContextInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeAppLaunchContextFromGlibNone is used to convert raw GAppLaunchContext pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibNone(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibNone(c).(AppLaunchContext)
}

// UnsafeAppLaunchContextFromGlibFull is used to convert raw GAppLaunchContext pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibFull(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibFull(c).(AppLaunchContext)
}

// UnsafeAppLaunchContextFromGlibBorrow is used to convert raw GAppLaunchContext pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibBorrow(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppLaunchContext)
}

func (a *AppLaunchContextInstance) upcastToGAppLaunchContext() *AppLaunchContextInstance {
	return a
}

// UnsafeAppLaunchContextToGlibNone is used to convert the instance to it's C value GAppLaunchContext. This is used by the bindings internally.
func UnsafeAppLaunchContextToGlibNone(c AppLaunchContext) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeAppLaunchContextToGlibFull is used to convert the instance to it's C value GAppLaunchContext, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextToGlibFull(c AppLaunchContext) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewAppLaunchContext wraps g_app_launch_context_new
// 
// see also https://docs.gtk.org/gio/func.g_app_launch_context_new.html
//
func NewAppLaunchContext() AppLaunchContext {
	var cret *C.GAppLaunchContext // return, full, converted

	cret = C.g_app_launch_context_new()

	var goret AppLaunchContext

	goret = UnsafeAppLaunchContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetEnvironment wraps g_app_launch_context_get_environment
// 
// see also https://docs.gtk.org/gio/method.g_app_launch_context_get_environment.g_app_launch_context_get_environment.html
//
func (_context *AppLaunchContextInstance) GetEnvironment() []string {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var cret  **C.char             // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))

	cret = C.g_app_launch_context_get_environment(carg0)
	runtime.KeepAlive(_context)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// LaunchFailed wraps g_app_launch_context_launch_failed
// 
// see also https://docs.gtk.org/gio/method.g_app_launch_context_launch_failed.g_app_launch_context_launch_failed.html
//
func (_context *AppLaunchContextInstance) LaunchFailed(startupNotifyId string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_launch_context_launch_failed(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(startupNotifyId)
}

// Setenv wraps g_app_launch_context_setenv
// 
// see also https://docs.gtk.org/gio/method.g_app_launch_context_setenv.g_app_launch_context_setenv.html
//
func (_context *AppLaunchContextInstance) Setenv(variable string, value string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_app_launch_context_setenv(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
}

// Unsetenv wraps g_app_launch_context_unsetenv
// 
// see also https://docs.gtk.org/gio/method.g_app_launch_context_unsetenv.g_app_launch_context_unsetenv.html
//
func (_context *AppLaunchContextInstance) Unsetenv(variable string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_launch_context_unsetenv(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(variable)
}

// ConnectLaunchFailed connects the provided callback to the "launch-failed" signal
// 
// see also https://docs.gtk.org/gio/signal.AppLaunchContext.launch-failed.html
//
func (o *AppLaunchContextInstance) ConnectLaunchFailed(fn func(AppLaunchContext, string)) gobject.SignalHandle {
	return o.Connect("launch-failed", fn)
}

// AppLaunchContextOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type AppLaunchContextOverrides[Instance AppLaunchContext] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // LaunchFailed allows you to override the implementation of the virtual method launch_failed.
	// 
	// see also https://docs.gtk.org/gio/method.AppLaunchContext.launch_failed.html
	LaunchFailed func(Instance, string)
}

// UnsafeApplyAppLaunchContextOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyAppLaunchContextOverrides[Instance AppLaunchContext](gclass unsafe.Pointer, overrides AppLaunchContextOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GAppLaunchContextClass)(gclass)

	if overrides.LaunchFailed != nil {
		pclass.launch_failed = (*[0]byte)(C._goglib_gio2_AppLaunchContext_launch_failed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_AppLaunchContext_launch_failed",
			func(carg0 *C.GAppLaunchContext, carg1 *C.char) {
				var _context        Instance // go GAppLaunchContext subclass
				var startupNotifyId string   // in, none, string

				_context = UnsafeAppLaunchContextFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				startupNotifyId = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.LaunchFailed(_context, startupNotifyId)
			},
		)
	}
}

// ParentLaunchFailed calls the default implementations of the `GAppLaunchContext.launch_failed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.AppLaunchContext.launch_failed.html
func (_context *AppLaunchContextInstance) ParentLaunchFailed(startupNotifyId string) {
	var carg0 *C.GAppLaunchContext
	var carg1 *C.char // in, none, converted

	parentclass := (*C.GAppLaunchContextClass)(classdata.PeekParentClass(UnsafeAppLaunchContextToGlibNone(_context)))

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_AppLaunchContext_virtual_launch_failed(unsafe.Pointer(parentclass.launch_failed), carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(startupNotifyId)
}

// RegisterAppLaunchContextSubClass is used to register a go subclass of GAppLaunchContext. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterAppLaunchContextSubClass[InstanceT AppLaunchContext](
		name string,
		classInit func(class *AppLaunchContextClass),
		constructor func() InstanceT,
		overrides AppLaunchContextOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeAppLaunchContext,
		UnsafeAppLaunchContextClassFromGlibBorrow,
		UnsafeApplyAppLaunchContextOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppLaunchContext(obj)
		},
		interfaceInits...,
	)
}

// ApplicationInstance is the instance type used by all types extending GApplication. It is used internally by the bindings. Users should use the interface [Application] instead.
type ApplicationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Application = (*ApplicationInstance)(nil)

// Application wraps GApplication
// 
// see also https://docs.gtk.org/gio/class.Application.html
//
type Application interface {
	gobject.Object
	upcastToGApplication() *ApplicationInstance

	// Activate wraps g_application_activate
	// 
	// see also https://docs.gtk.org/gio/method.g_application_activate.g_application_activate.html
	//
	Activate()
	// AddMainOption wraps g_application_add_main_option
	// 
	// see also https://docs.gtk.org/gio/method.g_application_add_main_option.g_application_add_main_option.html
	//
	AddMainOption(string, byte, glib.OptionFlags, glib.OptionArg, string, string)
	// AddMainOptionEntries wraps g_application_add_main_option_entries
	// 
	// see also https://docs.gtk.org/gio/method.g_application_add_main_option_entries.g_application_add_main_option_entries.html
	//
	AddMainOptionEntries([]glib.OptionEntry)
	// AddOptionGroup wraps g_application_add_option_group
	// 
	// see also https://docs.gtk.org/gio/method.g_application_add_option_group.g_application_add_option_group.html
	//
	AddOptionGroup(*glib.OptionGroup)
	// GetApplicationID wraps g_application_get_application_id
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_application_id.g_application_get_application_id.html
	//
	GetApplicationID() string
	// GetDBusObjectPath wraps g_application_get_dbus_object_path
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_dbus_object_path.g_application_get_dbus_object_path.html
	//
	GetDBusObjectPath() string
	// GetFlags wraps g_application_get_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_flags.g_application_get_flags.html
	//
	GetFlags() ApplicationFlags
	// GetInactivityTimeout wraps g_application_get_inactivity_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_inactivity_timeout.g_application_get_inactivity_timeout.html
	//
	GetInactivityTimeout() uint
	// GetIsBusy wraps g_application_get_is_busy
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_is_busy.g_application_get_is_busy.html
	//
	GetIsBusy() bool
	// GetIsRegistered wraps g_application_get_is_registered
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_is_registered.g_application_get_is_registered.html
	//
	GetIsRegistered() bool
	// GetIsRemote wraps g_application_get_is_remote
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_is_remote.g_application_get_is_remote.html
	//
	GetIsRemote() bool
	// GetResourceBasePath wraps g_application_get_resource_base_path
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_resource_base_path.g_application_get_resource_base_path.html
	//
	GetResourceBasePath() string
	// GetVersion wraps g_application_get_version
	// 
	// see also https://docs.gtk.org/gio/method.g_application_get_version.g_application_get_version.html
	//
	GetVersion() string
	// Hold wraps g_application_hold
	// 
	// see also https://docs.gtk.org/gio/method.g_application_hold.g_application_hold.html
	//
	Hold()
	// MarkBusy wraps g_application_mark_busy
	// 
	// see also https://docs.gtk.org/gio/method.g_application_mark_busy.g_application_mark_busy.html
	//
	MarkBusy()
	// Open wraps g_application_open
	// 
	// see also https://docs.gtk.org/gio/method.g_application_open.g_application_open.html
	//
	Open([]File, string)
	// Quit wraps g_application_quit
	// 
	// see also https://docs.gtk.org/gio/method.g_application_quit.g_application_quit.html
	//
	Quit()
	// Register wraps g_application_register
	// 
	// see also https://docs.gtk.org/gio/method.g_application_register.g_application_register.html
	//
	Register(Cancellable) (bool, error)
	// Release wraps g_application_release
	// 
	// see also https://docs.gtk.org/gio/method.g_application_release.g_application_release.html
	//
	Release()
	// Run wraps g_application_run
	// 
	// see also https://docs.gtk.org/gio/method.g_application_run.g_application_run.html
	//
	Run([]string) int32
	// SendNotification wraps g_application_send_notification
	// 
	// see also https://docs.gtk.org/gio/method.g_application_send_notification.g_application_send_notification.html
	//
	SendNotification(string, Notification)
	// SetActionGroup wraps g_application_set_action_group
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_action_group.g_application_set_action_group.html
	//
	//
	// Deprecated: (since 2.32.0) Use the #GActionMap interface instead.  Never ever
	// mix use of this API with use of #GActionMap on the same @application
	// or things will go very badly wrong.  This function is known to
	// introduce buggy behaviour (ie: signals not emitted on changes to the
	// action group), so you should really use #GActionMap instead.
	SetActionGroup(ActionGroup)
	// SetApplicationID wraps g_application_set_application_id
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_application_id.g_application_set_application_id.html
	//
	SetApplicationID(string)
	// SetDefault wraps g_application_set_default
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_default.g_application_set_default.html
	//
	SetDefault()
	// SetFlags wraps g_application_set_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_flags.g_application_set_flags.html
	//
	SetFlags(ApplicationFlags)
	// SetInactivityTimeout wraps g_application_set_inactivity_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_inactivity_timeout.g_application_set_inactivity_timeout.html
	//
	SetInactivityTimeout(uint)
	// SetOptionContextDescription wraps g_application_set_option_context_description
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_option_context_description.g_application_set_option_context_description.html
	//
	SetOptionContextDescription(string)
	// SetOptionContextParameterString wraps g_application_set_option_context_parameter_string
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_option_context_parameter_string.g_application_set_option_context_parameter_string.html
	//
	SetOptionContextParameterString(string)
	// SetOptionContextSummary wraps g_application_set_option_context_summary
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_option_context_summary.g_application_set_option_context_summary.html
	//
	SetOptionContextSummary(string)
	// SetResourceBasePath wraps g_application_set_resource_base_path
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_resource_base_path.g_application_set_resource_base_path.html
	//
	SetResourceBasePath(string)
	// SetVersion wraps g_application_set_version
	// 
	// see also https://docs.gtk.org/gio/method.g_application_set_version.g_application_set_version.html
	//
	SetVersion(string)
	// UnmarkBusy wraps g_application_unmark_busy
	// 
	// see also https://docs.gtk.org/gio/method.g_application_unmark_busy.g_application_unmark_busy.html
	//
	UnmarkBusy()
	// WithdrawNotification wraps g_application_withdraw_notification
	// 
	// see also https://docs.gtk.org/gio/method.g_application_withdraw_notification.g_application_withdraw_notification.html
	//
	WithdrawNotification(string)
	// ConnectActivate connects the provided callback to the "activate" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.activate.html
	//
	ConnectActivate(func(Application)) gobject.SignalHandle
	// ConnectCommandLine connects the provided callback to the "command-line" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.command-line.html
	//
	ConnectCommandLine(func(Application, ApplicationCommandLine) int32) gobject.SignalHandle
	// ConnectHandleLocalOptions connects the provided callback to the "handle-local-options" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.handle-local-options.html
	//
	ConnectHandleLocalOptions(func(Application, glib.VariantDict) int32) gobject.SignalHandle
	// ConnectNameLost connects the provided callback to the "name-lost" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.name-lost.html
	//
	ConnectNameLost(func(Application) bool) gobject.SignalHandle
	// ConnectOpen connects the provided callback to the "open" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.open.html
	//
	ConnectOpen(func(Application, []byte, int32, string)) gobject.SignalHandle
	// ConnectShutdown connects the provided callback to the "shutdown" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.shutdown.html
	//
	ConnectShutdown(func(Application)) gobject.SignalHandle
	// ConnectStartup connects the provided callback to the "startup" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Application.startup.html
	//
	ConnectStartup(func(Application)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentActivate calls the default implementations of the `GApplication.activate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.activate.html
	ParentActivate()
	// ParentAddPlatformData calls the default implementations of the `GApplication.add_platform_data` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.add_platform_data.html
	ParentAddPlatformData(builder *glib.VariantBuilder)
	// ParentCommandLine calls the default implementations of the `GApplication.command_line` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.command_line.html
	ParentCommandLine(commandLine ApplicationCommandLine) int32
	// ParentHandleLocalOptions calls the default implementations of the `GApplication.handle_local_options` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.handle_local_options.html
	ParentHandleLocalOptions(options *glib.VariantDict) int32
	// ParentNameLost calls the default implementations of the `GApplication.name_lost` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.name_lost.html
	ParentNameLost() bool
	// ParentOpen calls the default implementations of the `GApplication.open` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.open.html
	ParentOpen(files []File, hint string)
	// ParentQuitMainloop calls the default implementations of the `GApplication.quit_mainloop` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.quit_mainloop.html
	ParentQuitMainloop()
	// ParentRunMainloop calls the default implementations of the `GApplication.run_mainloop` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.run_mainloop.html
	ParentRunMainloop()
	// ParentShutdown calls the default implementations of the `GApplication.shutdown` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.shutdown.html
	ParentShutdown()
	// ParentStartup calls the default implementations of the `GApplication.startup` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Application.startup.html
	ParentStartup()
}

func unsafeWrapApplication(base *gobject.ObjectInstance) *ApplicationInstance {
	return &ApplicationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeApplication,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplication(inst)
		},
	)
}

func marshalApplicationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeApplicationFromGlibNone is used to convert raw GApplication pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationFromGlibNone(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibNone(c).(Application)
}

// UnsafeApplicationFromGlibFull is used to convert raw GApplication pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationFromGlibFull(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibFull(c).(Application)
}

// UnsafeApplicationFromGlibBorrow is used to convert raw GApplication pointers to go without touching any references. This is used by the bindings internally.
func UnsafeApplicationFromGlibBorrow(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Application)
}

func (a *ApplicationInstance) upcastToGApplication() *ApplicationInstance {
	return a
}

// UnsafeApplicationToGlibNone is used to convert the instance to it's C value GApplication. This is used by the bindings internally.
func UnsafeApplicationToGlibNone(c Application) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeApplicationToGlibFull is used to convert the instance to it's C value GApplication, while removeing the finalizer. This is used by the bindings internally.
func UnsafeApplicationToGlibFull(c Application) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewApplication wraps g_application_new
// 
// see also https://docs.gtk.org/gio/func.g_application_new.html
//
func NewApplication(applicationId string, flags ApplicationFlags) Application {
	var carg1 *C.gchar            // in, none, string, nullable-string
	var carg2 C.GApplicationFlags // in, none, casted
	var cret  *C.GApplication     // return, full, converted

	if applicationId != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GApplicationFlags(flags)

	cret = C.g_application_new(carg1, carg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var goret Application

	goret = UnsafeApplicationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ApplicationGetDefault wraps g_application_get_default
// 
// see also https://docs.gtk.org/gio/func.g_application_get_default.html
//
func ApplicationGetDefault() Application {
	var cret *C.GApplication // return, none, converted, nullable

	cret = C.g_application_get_default()

	var goret Application

	if cret != nil {
		goret = UnsafeApplicationFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ApplicationIDIsValid wraps g_application_id_is_valid
// 
// see also https://docs.gtk.org/gio/func.g_application_id_is_valid.html
//
func ApplicationIDIsValid(applicationId string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_id_is_valid(carg1)
	runtime.KeepAlive(applicationId)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Activate wraps g_application_activate
// 
// see also https://docs.gtk.org/gio/method.g_application_activate.g_application_activate.html
//
func (application *ApplicationInstance) Activate() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_activate(carg0)
	runtime.KeepAlive(application)
}

// AddMainOption wraps g_application_add_main_option
// 
// see also https://docs.gtk.org/gio/method.g_application_add_main_option.g_application_add_main_option.html
//
func (application *ApplicationInstance) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 C.char          // in, none, casted
	var carg3 C.GOptionFlags  // in, none, casted
	var carg4 C.GOptionArg    // in, none, casted
	var carg5 *C.char         // in, none, string
	var carg6 *C.char         // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(longName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.char(shortName)
	carg3 = C.GOptionFlags(flags)
	carg4 = C.GOptionArg(arg)
	carg5 = (*C.char)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg5))
	if argDescription != "" {
		carg6 = (*C.char)(unsafe.Pointer(C.CString(argDescription)))
		defer C.free(unsafe.Pointer(carg6))
	}

	C.g_application_add_main_option(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(application)
	runtime.KeepAlive(longName)
	runtime.KeepAlive(shortName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(description)
	runtime.KeepAlive(argDescription)
}

// AddMainOptionEntries wraps g_application_add_main_option_entries
// 
// see also https://docs.gtk.org/gio/method.g_application_add_main_option_entries.g_application_add_main_option_entries.html
//
func (application *ApplicationInstance) AddMainOptionEntries(entries []glib.OptionEntry) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GOptionEntry // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []glib.OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")

	C.g_application_add_main_option_entries(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(entries)
}

// AddOptionGroup wraps g_application_add_option_group
// 
// see also https://docs.gtk.org/gio/method.g_application_add_option_group.g_application_add_option_group.html
//
func (application *ApplicationInstance) AddOptionGroup(group *glib.OptionGroup) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GOptionGroup // in, full, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GOptionGroup)(glib.UnsafeOptionGroupToGlibFull(group))

	C.g_application_add_option_group(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(group)
}

// GetApplicationID wraps g_application_get_application_id
// 
// see also https://docs.gtk.org/gio/method.g_application_get_application_id.g_application_get_application_id.html
//
func (application *ApplicationInstance) GetApplicationID() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_application_id(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDBusObjectPath wraps g_application_get_dbus_object_path
// 
// see also https://docs.gtk.org/gio/method.g_application_get_dbus_object_path.g_application_get_dbus_object_path.html
//
func (application *ApplicationInstance) GetDBusObjectPath() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_dbus_object_path(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFlags wraps g_application_get_flags
// 
// see also https://docs.gtk.org/gio/method.g_application_get_flags.g_application_get_flags.html
//
func (application *ApplicationInstance) GetFlags() ApplicationFlags {
	var carg0 *C.GApplication     // in, none, converted
	var cret  C.GApplicationFlags // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_flags(carg0)
	runtime.KeepAlive(application)

	var goret ApplicationFlags

	goret = ApplicationFlags(cret)

	return goret
}

// GetInactivityTimeout wraps g_application_get_inactivity_timeout
// 
// see also https://docs.gtk.org/gio/method.g_application_get_inactivity_timeout.g_application_get_inactivity_timeout.html
//
func (application *ApplicationInstance) GetInactivityTimeout() uint {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.guint         // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_inactivity_timeout(carg0)
	runtime.KeepAlive(application)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetIsBusy wraps g_application_get_is_busy
// 
// see also https://docs.gtk.org/gio/method.g_application_get_is_busy.g_application_get_is_busy.html
//
func (application *ApplicationInstance) GetIsBusy() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_busy(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsRegistered wraps g_application_get_is_registered
// 
// see also https://docs.gtk.org/gio/method.g_application_get_is_registered.g_application_get_is_registered.html
//
func (application *ApplicationInstance) GetIsRegistered() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_registered(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsRemote wraps g_application_get_is_remote
// 
// see also https://docs.gtk.org/gio/method.g_application_get_is_remote.g_application_get_is_remote.html
//
func (application *ApplicationInstance) GetIsRemote() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_remote(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetResourceBasePath wraps g_application_get_resource_base_path
// 
// see also https://docs.gtk.org/gio/method.g_application_get_resource_base_path.g_application_get_resource_base_path.html
//
func (application *ApplicationInstance) GetResourceBasePath() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_resource_base_path(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetVersion wraps g_application_get_version
// 
// see also https://docs.gtk.org/gio/method.g_application_get_version.g_application_get_version.html
//
func (application *ApplicationInstance) GetVersion() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_version(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Hold wraps g_application_hold
// 
// see also https://docs.gtk.org/gio/method.g_application_hold.g_application_hold.html
//
func (application *ApplicationInstance) Hold() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_hold(carg0)
	runtime.KeepAlive(application)
}

// MarkBusy wraps g_application_mark_busy
// 
// see also https://docs.gtk.org/gio/method.g_application_mark_busy.g_application_mark_busy.html
//
func (application *ApplicationInstance) MarkBusy() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_mark_busy(carg0)
	runtime.KeepAlive(application)
}

// Open wraps g_application_open
// 
// see also https://docs.gtk.org/gio/method.g_application_open.g_application_open.html
//
func (application *ApplicationInstance) Open(files []File, hint string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 **C.GFile       // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
	var carg2 C.gint          // implicit
	var carg3 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = files
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []File (GFile**) because of unimplemented: inner pointers in array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_application_open(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// Quit wraps g_application_quit
// 
// see also https://docs.gtk.org/gio/method.g_application_quit.g_application_quit.html
//
func (application *ApplicationInstance) Quit() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_quit(carg0)
	runtime.KeepAlive(application)
}

// Register wraps g_application_register
// 
// see also https://docs.gtk.org/gio/method.g_application_register.g_application_register.html
//
func (application *ApplicationInstance) Register(cancellable Cancellable) (bool, error) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_application_register(carg0, carg1, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Release wraps g_application_release
// 
// see also https://docs.gtk.org/gio/method.g_application_release.g_application_release.html
//
func (application *ApplicationInstance) Release() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_release(carg0)
	runtime.KeepAlive(application)
}

// Run wraps g_application_run
// 
// see also https://docs.gtk.org/gio/method.g_application_run.g_application_run.html
//
func (application *ApplicationInstance) Run(argv []string) int32 {
	var carg0 *C.GApplication // in, none, converted
	var carg1 C.int           // implicit
	var carg2 **C.char        // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), length-by: carg1)
	var cret  C.int           // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = argv
	_ = carg2
	_ = carg1
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	cret = C.g_application_run(carg0, carg1, carg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(argv)

	var goret int32

	goret = int32(cret)

	return goret
}

// SendNotification wraps g_application_send_notification
// 
// see also https://docs.gtk.org/gio/method.g_application_send_notification.g_application_send_notification.html
//
func (application *ApplicationInstance) SendNotification(id string, notification Notification) {
	var carg0 *C.GApplication  // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.GNotification // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if id != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))

	C.g_application_send_notification(carg0, carg1, carg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
	runtime.KeepAlive(notification)
}

// SetActionGroup wraps g_application_set_action_group
// 
// see also https://docs.gtk.org/gio/method.g_application_set_action_group.g_application_set_action_group.html
//
//
// Deprecated: (since 2.32.0) Use the #GActionMap interface instead.  Never ever
// mix use of this API with use of #GActionMap on the same @application
// or things will go very badly wrong.  This function is known to
// introduce buggy behaviour (ie: signals not emitted on changes to the
// action group), so you should really use #GActionMap instead.
func (application *ApplicationInstance) SetActionGroup(actionGroup ActionGroup) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GActionGroup // in, none, converted, nullable

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if actionGroup != nil {
		carg1 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	}

	C.g_application_set_action_group(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(actionGroup)
}

// SetApplicationID wraps g_application_set_application_id
// 
// see also https://docs.gtk.org/gio/method.g_application_set_application_id.g_application_set_application_id.html
//
func (application *ApplicationInstance) SetApplicationID(applicationId string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if applicationId != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_application_id(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(applicationId)
}

// SetDefault wraps g_application_set_default
// 
// see also https://docs.gtk.org/gio/method.g_application_set_default.g_application_set_default.html
//
func (application *ApplicationInstance) SetDefault() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_set_default(carg0)
	runtime.KeepAlive(application)
}

// SetFlags wraps g_application_set_flags
// 
// see also https://docs.gtk.org/gio/method.g_application_set_flags.g_application_set_flags.html
//
func (application *ApplicationInstance) SetFlags(flags ApplicationFlags) {
	var carg0 *C.GApplication     // in, none, converted
	var carg1 C.GApplicationFlags // in, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = C.GApplicationFlags(flags)

	C.g_application_set_flags(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(flags)
}

// SetInactivityTimeout wraps g_application_set_inactivity_timeout
// 
// see also https://docs.gtk.org/gio/method.g_application_set_inactivity_timeout.g_application_set_inactivity_timeout.html
//
func (application *ApplicationInstance) SetInactivityTimeout(inactivityTimeout uint) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 C.guint         // in, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(inactivityTimeout)
}

// SetOptionContextDescription wraps g_application_set_option_context_description
// 
// see also https://docs.gtk.org/gio/method.g_application_set_option_context_description.g_application_set_option_context_description.html
//
func (application *ApplicationInstance) SetOptionContextDescription(description string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if description != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_description(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(description)
}

// SetOptionContextParameterString wraps g_application_set_option_context_parameter_string
// 
// see also https://docs.gtk.org/gio/method.g_application_set_option_context_parameter_string.g_application_set_option_context_parameter_string.html
//
func (application *ApplicationInstance) SetOptionContextParameterString(parameterString string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if parameterString != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(parameterString)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_parameter_string(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(parameterString)
}

// SetOptionContextSummary wraps g_application_set_option_context_summary
// 
// see also https://docs.gtk.org/gio/method.g_application_set_option_context_summary.g_application_set_option_context_summary.html
//
func (application *ApplicationInstance) SetOptionContextSummary(summary string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if summary != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_summary(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(summary)
}

// SetResourceBasePath wraps g_application_set_resource_base_path
// 
// see also https://docs.gtk.org/gio/method.g_application_set_resource_base_path.g_application_set_resource_base_path.html
//
func (application *ApplicationInstance) SetResourceBasePath(resourcePath string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if resourcePath != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_resource_base_path(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(resourcePath)
}

// SetVersion wraps g_application_set_version
// 
// see also https://docs.gtk.org/gio/method.g_application_set_version.g_application_set_version.html
//
func (application *ApplicationInstance) SetVersion(version string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(version)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_set_version(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(version)
}

// UnmarkBusy wraps g_application_unmark_busy
// 
// see also https://docs.gtk.org/gio/method.g_application_unmark_busy.g_application_unmark_busy.html
//
func (application *ApplicationInstance) UnmarkBusy() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_unmark_busy(carg0)
	runtime.KeepAlive(application)
}

// WithdrawNotification wraps g_application_withdraw_notification
// 
// see also https://docs.gtk.org/gio/method.g_application_withdraw_notification.g_application_withdraw_notification.html
//
func (application *ApplicationInstance) WithdrawNotification(id string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_withdraw_notification(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
}

// ConnectActivate connects the provided callback to the "activate" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.activate.html
//
func (o *ApplicationInstance) ConnectActivate(fn func(Application)) gobject.SignalHandle {
	return o.Connect("activate", fn)
}

// ConnectCommandLine connects the provided callback to the "command-line" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.command-line.html
//
func (o *ApplicationInstance) ConnectCommandLine(fn func(Application, ApplicationCommandLine) int32) gobject.SignalHandle {
	return o.Connect("command-line", fn)
}

// ConnectHandleLocalOptions connects the provided callback to the "handle-local-options" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.handle-local-options.html
//
func (o *ApplicationInstance) ConnectHandleLocalOptions(fn func(Application, glib.VariantDict) int32) gobject.SignalHandle {
	return o.Connect("handle-local-options", fn)
}

// ConnectNameLost connects the provided callback to the "name-lost" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.name-lost.html
//
func (o *ApplicationInstance) ConnectNameLost(fn func(Application) bool) gobject.SignalHandle {
	return o.Connect("name-lost", fn)
}

// ConnectOpen connects the provided callback to the "open" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.open.html
//
func (o *ApplicationInstance) ConnectOpen(fn func(Application, []byte, int32, string)) gobject.SignalHandle {
	return o.Connect("open", fn)
}

// ConnectShutdown connects the provided callback to the "shutdown" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.shutdown.html
//
func (o *ApplicationInstance) ConnectShutdown(fn func(Application)) gobject.SignalHandle {
	return o.Connect("shutdown", fn)
}

// ConnectStartup connects the provided callback to the "startup" signal
// 
// see also https://docs.gtk.org/gio/signal.Application.startup.html
//
func (o *ApplicationInstance) ConnectStartup(fn func(Application)) gobject.SignalHandle {
	return o.Connect("startup", fn)
}

// ApplicationOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ApplicationOverrides[Instance Application] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Activate allows you to override the implementation of the virtual method activate.
	// 
	// see also https://docs.gtk.org/gio/method.Application.activate.html
	Activate func(Instance)
	// // AddPlatformData allows you to override the implementation of the virtual method add_platform_data.
	// 
	// see also https://docs.gtk.org/gio/method.Application.add_platform_data.html
	AddPlatformData func(Instance, *glib.VariantBuilder)
	// // CommandLine allows you to override the implementation of the virtual method command_line.
	// 
	// see also https://docs.gtk.org/gio/method.Application.command_line.html
	CommandLine func(Instance, ApplicationCommandLine) int32
	// // HandleLocalOptions allows you to override the implementation of the virtual method handle_local_options.
	// 
	// see also https://docs.gtk.org/gio/method.Application.handle_local_options.html
	HandleLocalOptions func(Instance, *glib.VariantDict) int32
	// // NameLost allows you to override the implementation of the virtual method name_lost.
	// 
	// see also https://docs.gtk.org/gio/method.Application.name_lost.html
	NameLost func(Instance) bool
	// // Open allows you to override the implementation of the virtual method open.
	// 
	// see also https://docs.gtk.org/gio/method.Application.open.html
	Open func(Instance, []File, string)
	// // QuitMainloop allows you to override the implementation of the virtual method quit_mainloop.
	// 
	// see also https://docs.gtk.org/gio/method.Application.quit_mainloop.html
	QuitMainloop func(Instance)
	// // RunMainloop allows you to override the implementation of the virtual method run_mainloop.
	// 
	// see also https://docs.gtk.org/gio/method.Application.run_mainloop.html
	RunMainloop func(Instance)
	// // Shutdown allows you to override the implementation of the virtual method shutdown.
	// 
	// see also https://docs.gtk.org/gio/method.Application.shutdown.html
	Shutdown func(Instance)
	// // Startup allows you to override the implementation of the virtual method startup.
	// 
	// see also https://docs.gtk.org/gio/method.Application.startup.html
	Startup func(Instance)
}

// UnsafeApplyApplicationOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyApplicationOverrides[Instance Application](gclass unsafe.Pointer, overrides ApplicationOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GApplicationClass)(gclass)

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._goglib_gio2_Application_activate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_activate",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Activate(application)
			},
		)
	}

	if overrides.AddPlatformData != nil {
		pclass.add_platform_data = (*[0]byte)(C._goglib_gio2_Application_add_platform_data)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_add_platform_data",
			func(carg0 *C.GApplication, carg1 *C.GVariantBuilder) {
				var application Instance             // go GApplication subclass
				var builder     *glib.VariantBuilder // in, none, converted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				builder = glib.UnsafeVariantBuilderFromGlibNone(unsafe.Pointer(carg1))

				overrides.AddPlatformData(application, builder)
			},
		)
	}

	if overrides.CommandLine != nil {
		pclass.command_line = (*[0]byte)(C._goglib_gio2_Application_command_line)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_command_line",
			func(carg0 *C.GApplication, carg1 *C.GApplicationCommandLine) (cret C.int) {
				var application Instance               // go GApplication subclass
				var commandLine ApplicationCommandLine // in, none, converted
				var goret       int32                  // return, none, casted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				commandLine = UnsafeApplicationCommandLineFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.CommandLine(application, commandLine)

				cret = C.int(goret)

				return cret
			},
		)
	}

	if overrides.HandleLocalOptions != nil {
		pclass.handle_local_options = (*[0]byte)(C._goglib_gio2_Application_handle_local_options)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_handle_local_options",
			func(carg0 *C.GApplication, carg1 *C.GVariantDict) (cret C.gint) {
				var application Instance          // go GApplication subclass
				var options     *glib.VariantDict // in, none, converted
				var goret       int32             // return, none, casted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				options = glib.UnsafeVariantDictFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.HandleLocalOptions(application, options)

				cret = C.gint(goret)

				return cret
			},
		)
	}

	if overrides.NameLost != nil {
		pclass.name_lost = (*[0]byte)(C._goglib_gio2_Application_name_lost)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_name_lost",
			func(carg0 *C.GApplication) (cret C.gboolean) {
				var application Instance // go GApplication subclass
				var goret       bool     // return

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.NameLost(application)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._goglib_gio2_Application_open)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_open",
			func(carg0 *C.GApplication, carg1 **C.GFile, carg2 C.gint, carg3 *C.gchar) {
				var application Instance // go GApplication subclass
				var files       []File   // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
				var hint        string   // in, none, string

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = files
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []File (GFile**) because of unknown reason")
				hint = C.GoString((*C.char)(unsafe.Pointer(carg3)))

				overrides.Open(application, files, hint)
			},
		)
	}

	if overrides.QuitMainloop != nil {
		pclass.quit_mainloop = (*[0]byte)(C._goglib_gio2_Application_quit_mainloop)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_quit_mainloop",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.QuitMainloop(application)
			},
		)
	}

	if overrides.RunMainloop != nil {
		pclass.run_mainloop = (*[0]byte)(C._goglib_gio2_Application_run_mainloop)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_run_mainloop",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.RunMainloop(application)
			},
		)
	}

	if overrides.Shutdown != nil {
		pclass.shutdown = (*[0]byte)(C._goglib_gio2_Application_shutdown)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_shutdown",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Shutdown(application)
			},
		)
	}

	if overrides.Startup != nil {
		pclass.startup = (*[0]byte)(C._goglib_gio2_Application_startup)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_startup",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Startup(application)
			},
		)
	}
}

// ParentActivate calls the default implementations of the `GApplication.activate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.activate.html
func (application *ApplicationInstance) ParentActivate() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_activate(unsafe.Pointer(parentclass.activate), carg0)
	runtime.KeepAlive(application)
}

// ParentAddPlatformData calls the default implementations of the `GApplication.add_platform_data` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.add_platform_data.html
func (application *ApplicationInstance) ParentAddPlatformData(builder *glib.VariantBuilder) {
	var carg0 *C.GApplication
	var carg1 *C.GVariantBuilder // in, none, converted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GVariantBuilder)(glib.UnsafeVariantBuilderToGlibNone(builder))

	C._goglib_gio2_Application_virtual_add_platform_data(unsafe.Pointer(parentclass.add_platform_data), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(builder)
}

// ParentCommandLine calls the default implementations of the `GApplication.command_line` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.command_line.html
func (application *ApplicationInstance) ParentCommandLine(commandLine ApplicationCommandLine) int32 {
	var carg0 *C.GApplication
	var carg1 *C.GApplicationCommandLine // in, none, converted
	var cret  C.int                      // return, none, casted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(commandLine))

	cret = C._goglib_gio2_Application_virtual_command_line(unsafe.Pointer(parentclass.command_line), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(commandLine)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentHandleLocalOptions calls the default implementations of the `GApplication.handle_local_options` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.handle_local_options.html
func (application *ApplicationInstance) ParentHandleLocalOptions(options *glib.VariantDict) int32 {
	var carg0 *C.GApplication
	var carg1 *C.GVariantDict // in, none, converted
	var cret  C.gint          // return, none, casted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GVariantDict)(glib.UnsafeVariantDictToGlibNone(options))

	cret = C._goglib_gio2_Application_virtual_handle_local_options(unsafe.Pointer(parentclass.handle_local_options), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(options)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentNameLost calls the default implementations of the `GApplication.name_lost` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.name_lost.html
func (application *ApplicationInstance) ParentNameLost() bool {
	var carg0 *C.GApplication
	var cret  C.gboolean // return

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C._goglib_gio2_Application_virtual_name_lost(unsafe.Pointer(parentclass.name_lost), carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentOpen calls the default implementations of the `GApplication.open` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.open.html
func (application *ApplicationInstance) ParentOpen(files []File, hint string) {
	var carg0 *C.GApplication
	var carg1 **C.GFile // in, none, converted
	var carg2 C.gint    // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
	var carg3 *C.gchar  // implicit

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = files
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []File (GFile**) because of unimplemented: inner pointers in array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(carg3))

	C._goglib_gio2_Application_virtual_open(unsafe.Pointer(parentclass.open), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// ParentQuitMainloop calls the default implementations of the `GApplication.quit_mainloop` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.quit_mainloop.html
func (application *ApplicationInstance) ParentQuitMainloop() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_quit_mainloop(unsafe.Pointer(parentclass.quit_mainloop), carg0)
	runtime.KeepAlive(application)
}

// ParentRunMainloop calls the default implementations of the `GApplication.run_mainloop` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.run_mainloop.html
func (application *ApplicationInstance) ParentRunMainloop() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_run_mainloop(unsafe.Pointer(parentclass.run_mainloop), carg0)
	runtime.KeepAlive(application)
}

// ParentShutdown calls the default implementations of the `GApplication.shutdown` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.shutdown.html
func (application *ApplicationInstance) ParentShutdown() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_shutdown(unsafe.Pointer(parentclass.shutdown), carg0)
	runtime.KeepAlive(application)
}

// ParentStartup calls the default implementations of the `GApplication.startup` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Application.startup.html
func (application *ApplicationInstance) ParentStartup() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_startup(unsafe.Pointer(parentclass.startup), carg0)
	runtime.KeepAlive(application)
}

// RegisterApplicationSubClass is used to register a go subclass of GApplication. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterApplicationSubClass[InstanceT Application](
		name string,
		classInit func(class *ApplicationClass),
		constructor func() InstanceT,
		overrides ApplicationOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeApplication,
		UnsafeApplicationClassFromGlibBorrow,
		UnsafeApplyApplicationOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplication(obj)
		},
		interfaceInits...,
	)
}

// ApplicationCommandLineInstance is the instance type used by all types extending GApplicationCommandLine. It is used internally by the bindings. Users should use the interface [ApplicationCommandLine] instead.
type ApplicationCommandLineInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ApplicationCommandLine = (*ApplicationCommandLineInstance)(nil)

// ApplicationCommandLine wraps GApplicationCommandLine
// 
// see also https://docs.gtk.org/gio/class.ApplicationCommandLine.html
//
type ApplicationCommandLine interface {
	gobject.Object
	upcastToGApplicationCommandLine() *ApplicationCommandLineInstance

	// CreateFileForArg wraps g_application_command_line_create_file_for_arg
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_create_file_for_arg.g_application_command_line_create_file_for_arg.html
	//
	CreateFileForArg(string) File
	// Done wraps g_application_command_line_done
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_done.g_application_command_line_done.html
	//
	Done()
	// GetArguments wraps g_application_command_line_get_arguments
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_arguments.g_application_command_line_get_arguments.html
	//
	GetArguments() (int32, []string)
	// GetCwd wraps g_application_command_line_get_cwd
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_cwd.g_application_command_line_get_cwd.html
	//
	GetCwd() string
	// GetEnviron wraps g_application_command_line_get_environ
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_environ.g_application_command_line_get_environ.html
	//
	GetEnviron() []string
	// GetExitStatus wraps g_application_command_line_get_exit_status
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_exit_status.g_application_command_line_get_exit_status.html
	//
	GetExitStatus() int32
	// GetIsRemote wraps g_application_command_line_get_is_remote
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_is_remote.g_application_command_line_get_is_remote.html
	//
	GetIsRemote() bool
	// GetOptionsDict wraps g_application_command_line_get_options_dict
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_options_dict.g_application_command_line_get_options_dict.html
	//
	GetOptionsDict() *glib.VariantDict
	// GetStdin wraps g_application_command_line_get_stdin
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_get_stdin.g_application_command_line_get_stdin.html
	//
	GetStdin() InputStream
	// Getenv wraps g_application_command_line_getenv
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_getenv.g_application_command_line_getenv.html
	//
	Getenv(string) string
	// PrintLiteral wraps g_application_command_line_print_literal
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_print_literal.g_application_command_line_print_literal.html
	//
	PrintLiteral(string)
	// PrinterrLiteral wraps g_application_command_line_printerr_literal
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_printerr_literal.g_application_command_line_printerr_literal.html
	//
	PrinterrLiteral(string)
	// SetExitStatus wraps g_application_command_line_set_exit_status
	// 
	// see also https://docs.gtk.org/gio/method.g_application_command_line_set_exit_status.g_application_command_line_set_exit_status.html
	//
	SetExitStatus(int32)

	// chain up virtual methods:

	// ParentDone calls the default implementations of the `GApplicationCommandLine.done` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.done.html
	ParentDone()
	// ParentGetStdin calls the default implementations of the `GApplicationCommandLine.get_stdin` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.get_stdin.html
	ParentGetStdin() InputStream
	// ParentPrintLiteral calls the default implementations of the `GApplicationCommandLine.print_literal` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.print_literal.html
	ParentPrintLiteral(message string)
	// ParentPrinterrLiteral calls the default implementations of the `GApplicationCommandLine.printerr_literal` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.printerr_literal.html
	ParentPrinterrLiteral(message string)
}

func unsafeWrapApplicationCommandLine(base *gobject.ObjectInstance) *ApplicationCommandLineInstance {
	return &ApplicationCommandLineInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeApplicationCommandLine,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplicationCommandLine(inst)
		},
	)
}

func marshalApplicationCommandLineInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeApplicationCommandLineFromGlibNone is used to convert raw GApplicationCommandLine pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibNone(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibNone(c).(ApplicationCommandLine)
}

// UnsafeApplicationCommandLineFromGlibFull is used to convert raw GApplicationCommandLine pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibFull(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibFull(c).(ApplicationCommandLine)
}

// UnsafeApplicationCommandLineFromGlibBorrow is used to convert raw GApplicationCommandLine pointers to go without touching any references. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibBorrow(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ApplicationCommandLine)
}

func (a *ApplicationCommandLineInstance) upcastToGApplicationCommandLine() *ApplicationCommandLineInstance {
	return a
}

// UnsafeApplicationCommandLineToGlibNone is used to convert the instance to it's C value GApplicationCommandLine. This is used by the bindings internally.
func UnsafeApplicationCommandLineToGlibNone(c ApplicationCommandLine) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeApplicationCommandLineToGlibFull is used to convert the instance to it's C value GApplicationCommandLine, while removeing the finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineToGlibFull(c ApplicationCommandLine) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// CreateFileForArg wraps g_application_command_line_create_file_for_arg
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_create_file_for_arg.g_application_command_line_create_file_for_arg.html
//
func (cmdline *ApplicationCommandLineInstance) CreateFileForArg(arg string) File {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var cret  *C.GFile                   // return, full, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_command_line_create_file_for_arg(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(arg)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Done wraps g_application_command_line_done
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_done.g_application_command_line_done.html
//
func (cmdline *ApplicationCommandLineInstance) Done() {
	var carg0 *C.GApplicationCommandLine // in, none, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	C.g_application_command_line_done(carg0)
	runtime.KeepAlive(cmdline)
}

// GetArguments wraps g_application_command_line_get_arguments
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_arguments.g_application_command_line_get_arguments.html
//
func (cmdline *ApplicationCommandLineInstance) GetArguments() (int32, []string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 C.int                      // out, full, casted
	var cret  **C.gchar                  // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_arguments(carg0, &carg1)
	runtime.KeepAlive(cmdline)

	var argc  int32
	var goret []string

	argc = int32(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return argc, goret
}

// GetCwd wraps g_application_command_line_get_cwd
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_cwd.g_application_command_line_get_cwd.html
//
func (cmdline *ApplicationCommandLineInstance) GetCwd() string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.gchar                   // return, none, string, nullable

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_cwd(carg0)
	runtime.KeepAlive(cmdline)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetEnviron wraps g_application_command_line_get_environ
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_environ.g_application_command_line_get_environ.html
//
func (cmdline *ApplicationCommandLineInstance) GetEnviron() []string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  **C.gchar                  // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_environ(carg0)
	runtime.KeepAlive(cmdline)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetExitStatus wraps g_application_command_line_get_exit_status
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_exit_status.g_application_command_line_get_exit_status.html
//
func (cmdline *ApplicationCommandLineInstance) GetExitStatus() int32 {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  C.int                      // return, none, casted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_exit_status(carg0)
	runtime.KeepAlive(cmdline)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetIsRemote wraps g_application_command_line_get_is_remote
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_is_remote.g_application_command_line_get_is_remote.html
//
func (cmdline *ApplicationCommandLineInstance) GetIsRemote() bool {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  C.gboolean                 // return

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_is_remote(carg0)
	runtime.KeepAlive(cmdline)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetOptionsDict wraps g_application_command_line_get_options_dict
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_options_dict.g_application_command_line_get_options_dict.html
//
func (cmdline *ApplicationCommandLineInstance) GetOptionsDict() *glib.VariantDict {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.GVariantDict            // return, none, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_options_dict(carg0)
	runtime.KeepAlive(cmdline)

	var goret *glib.VariantDict

	goret = glib.UnsafeVariantDictFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetStdin wraps g_application_command_line_get_stdin
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_get_stdin.g_application_command_line_get_stdin.html
//
func (cmdline *ApplicationCommandLineInstance) GetStdin() InputStream {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.GInputStream            // return, full, converted, nullable

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_stdin(carg0)
	runtime.KeepAlive(cmdline)

	var goret InputStream

	if cret != nil {
		goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// Getenv wraps g_application_command_line_getenv
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_getenv.g_application_command_line_getenv.html
//
func (cmdline *ApplicationCommandLineInstance) Getenv(name string) string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var cret  *C.gchar                   // return, none, string, nullable-string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_command_line_getenv(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(name)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PrintLiteral wraps g_application_command_line_print_literal
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_print_literal.g_application_command_line_print_literal.html
//
func (cmdline *ApplicationCommandLineInstance) PrintLiteral(message string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_command_line_print_literal(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// PrinterrLiteral wraps g_application_command_line_printerr_literal
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_printerr_literal.g_application_command_line_printerr_literal.html
//
func (cmdline *ApplicationCommandLineInstance) PrinterrLiteral(message string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_command_line_printerr_literal(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// SetExitStatus wraps g_application_command_line_set_exit_status
// 
// see also https://docs.gtk.org/gio/method.g_application_command_line_set_exit_status.g_application_command_line_set_exit_status.html
//
func (cmdline *ApplicationCommandLineInstance) SetExitStatus(exitStatus int32) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 C.int                      // in, none, casted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = C.int(exitStatus)

	C.g_application_command_line_set_exit_status(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(exitStatus)
}

// ApplicationCommandLineOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ApplicationCommandLineOverrides[Instance ApplicationCommandLine] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Done allows you to override the implementation of the virtual method done.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.done.html
	Done func(Instance)
	// // GetStdin allows you to override the implementation of the virtual method get_stdin.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.get_stdin.html
	GetStdin func(Instance) InputStream
	// // PrintLiteral allows you to override the implementation of the virtual method print_literal.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.print_literal.html
	PrintLiteral func(Instance, string)
	// // PrinterrLiteral allows you to override the implementation of the virtual method printerr_literal.
	// 
	// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.printerr_literal.html
	PrinterrLiteral func(Instance, string)
}

// UnsafeApplyApplicationCommandLineOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyApplicationCommandLineOverrides[Instance ApplicationCommandLine](gclass unsafe.Pointer, overrides ApplicationCommandLineOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GApplicationCommandLineClass)(gclass)

	if overrides.Done != nil {
		pclass.done = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_done)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_done",
			func(carg0 *C.GApplicationCommandLine) {
				var cmdline Instance // go GApplicationCommandLine subclass

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Done(cmdline)
			},
		)
	}

	if overrides.GetStdin != nil {
		pclass.get_stdin = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_get_stdin)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_get_stdin",
			func(carg0 *C.GApplicationCommandLine) (cret *C.GInputStream) {
				var cmdline Instance    // go GApplicationCommandLine subclass
				var goret   InputStream // return, full, converted, nullable

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetStdin(cmdline)

				if goret != nil {
					cret = (*C.GInputStream)(UnsafeInputStreamToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.PrintLiteral != nil {
		pclass.print_literal = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_print_literal)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_print_literal",
			func(carg0 *C.GApplicationCommandLine, carg1 *C.gchar) {
				var cmdline Instance // go GApplicationCommandLine subclass
				var message string   // in, none, string

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.PrintLiteral(cmdline, message)
			},
		)
	}

	if overrides.PrinterrLiteral != nil {
		pclass.printerr_literal = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_printerr_literal)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_printerr_literal",
			func(carg0 *C.GApplicationCommandLine, carg1 *C.gchar) {
				var cmdline Instance // go GApplicationCommandLine subclass
				var message string   // in, none, string

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.PrinterrLiteral(cmdline, message)
			},
		)
	}
}

// ParentDone calls the default implementations of the `GApplicationCommandLine.done` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.done.html
func (cmdline *ApplicationCommandLineInstance) ParentDone() {
	var carg0 *C.GApplicationCommandLine

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	C._goglib_gio2_ApplicationCommandLine_virtual_done(unsafe.Pointer(parentclass.done), carg0)
	runtime.KeepAlive(cmdline)
}

// ParentGetStdin calls the default implementations of the `GApplicationCommandLine.get_stdin` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.get_stdin.html
func (cmdline *ApplicationCommandLineInstance) ParentGetStdin() InputStream {
	var carg0 *C.GApplicationCommandLine
	var cret  *C.GInputStream // return, full, converted, nullable

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C._goglib_gio2_ApplicationCommandLine_virtual_get_stdin(unsafe.Pointer(parentclass.get_stdin), carg0)
	runtime.KeepAlive(cmdline)

	var goret InputStream

	if cret != nil {
		goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentPrintLiteral calls the default implementations of the `GApplicationCommandLine.print_literal` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.print_literal.html
func (cmdline *ApplicationCommandLineInstance) ParentPrintLiteral(message string) {
	var carg0 *C.GApplicationCommandLine
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_ApplicationCommandLine_virtual_print_literal(unsafe.Pointer(parentclass.print_literal), carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// ParentPrinterrLiteral calls the default implementations of the `GApplicationCommandLine.printerr_literal` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.ApplicationCommandLine.printerr_literal.html
func (cmdline *ApplicationCommandLineInstance) ParentPrinterrLiteral(message string) {
	var carg0 *C.GApplicationCommandLine
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_ApplicationCommandLine_virtual_printerr_literal(unsafe.Pointer(parentclass.printerr_literal), carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// RegisterApplicationCommandLineSubClass is used to register a go subclass of GApplicationCommandLine. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterApplicationCommandLineSubClass[InstanceT ApplicationCommandLine](
		name string,
		classInit func(class *ApplicationCommandLineClass),
		constructor func() InstanceT,
		overrides ApplicationCommandLineOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeApplicationCommandLine,
		UnsafeApplicationCommandLineClassFromGlibBorrow,
		UnsafeApplyApplicationCommandLineOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplicationCommandLine(obj)
		},
		interfaceInits...,
	)
}

// BytesIconInstance is the instance type used by all types extending GBytesIcon. It is used internally by the bindings. Users should use the interface [BytesIcon] instead.
type BytesIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ BytesIcon = (*BytesIconInstance)(nil)

// BytesIcon wraps GBytesIcon
// 
// see also https://docs.gtk.org/gio/class.BytesIcon.html
//
type BytesIcon interface {
	gobject.Object
	upcastToGBytesIcon() *BytesIconInstance

	// GetBytes wraps g_bytes_icon_get_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_bytes_icon_get_bytes.g_bytes_icon_get_bytes.html
	//
	GetBytes() *glib.Bytes
}

func unsafeWrapBytesIcon(base *gobject.ObjectInstance) *BytesIconInstance {
	return &BytesIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBytesIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBytesIcon(inst)
		},
	)
}

func marshalBytesIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBytesIconFromGlibNone is used to convert raw GBytesIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBytesIconFromGlibNone(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(BytesIcon)
}

// UnsafeBytesIconFromGlibFull is used to convert raw GBytesIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBytesIconFromGlibFull(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(BytesIcon)
}

// UnsafeBytesIconFromGlibBorrow is used to convert raw GBytesIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBytesIconFromGlibBorrow(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BytesIcon)
}

func (b *BytesIconInstance) upcastToGBytesIcon() *BytesIconInstance {
	return b
}

// UnsafeBytesIconToGlibNone is used to convert the instance to it's C value GBytesIcon. This is used by the bindings internally.
func UnsafeBytesIconToGlibNone(c BytesIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBytesIconToGlibFull is used to convert the instance to it's C value GBytesIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBytesIconToGlibFull(c BytesIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBytesIcon wraps g_bytes_icon_new
// 
// see also https://docs.gtk.org/gio/func.g_bytes_icon_new.html
//
func NewBytesIcon(bytes *glib.Bytes) BytesIcon {
	var carg1 *C.GBytes // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_bytes_icon_new(carg1)
	runtime.KeepAlive(bytes)

	var goret BytesIcon

	goret = UnsafeBytesIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetBytes wraps g_bytes_icon_get_bytes
// 
// see also https://docs.gtk.org/gio/method.g_bytes_icon_get_bytes.g_bytes_icon_get_bytes.html
//
func (icon *BytesIconInstance) GetBytes() *glib.Bytes {
	var carg0 *C.GBytesIcon // in, none, converted
	var cret  *C.GBytes     // return, none, converted

	carg0 = (*C.GBytesIcon)(UnsafeBytesIconToGlibNone(icon))

	cret = C.g_bytes_icon_get_bytes(carg0)
	runtime.KeepAlive(icon)

	var goret *glib.Bytes

	goret = glib.UnsafeBytesFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// CancellableInstance is the instance type used by all types extending GCancellable. It is used internally by the bindings. Users should use the interface [Cancellable] instead.
type CancellableInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Cancellable = (*CancellableInstance)(nil)

// Cancellable wraps GCancellable
// 
// see also https://docs.gtk.org/gio/class.Cancellable.html
//
type Cancellable interface {
	gobject.Object
	upcastToGCancellable() *CancellableInstance

	// Cancel wraps g_cancellable_cancel
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_cancel.g_cancellable_cancel.html
	//
	Cancel()
	// Disconnect wraps g_cancellable_disconnect
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_disconnect.g_cancellable_disconnect.html
	//
	Disconnect(uint32)
	// GetFd wraps g_cancellable_get_fd
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_get_fd.g_cancellable_get_fd.html
	//
	GetFd() int32
	// IsCancelled wraps g_cancellable_is_cancelled
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_is_cancelled.g_cancellable_is_cancelled.html
	//
	IsCancelled() bool
	// MakePollfd wraps g_cancellable_make_pollfd
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_make_pollfd.g_cancellable_make_pollfd.html
	//
	MakePollfd(*glib.PollFD) bool
	// PopCurrent wraps g_cancellable_pop_current
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_pop_current.g_cancellable_pop_current.html
	//
	PopCurrent()
	// PushCurrent wraps g_cancellable_push_current
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_push_current.g_cancellable_push_current.html
	//
	PushCurrent()
	// ReleaseFd wraps g_cancellable_release_fd
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_release_fd.g_cancellable_release_fd.html
	//
	ReleaseFd()
	// Reset wraps g_cancellable_reset
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_reset.g_cancellable_reset.html
	//
	Reset()
	// SetErrorIfCancelled wraps g_cancellable_set_error_if_cancelled
	// 
	// see also https://docs.gtk.org/gio/method.g_cancellable_set_error_if_cancelled.g_cancellable_set_error_if_cancelled.html
	//
	SetErrorIfCancelled() (bool, error)
	// ConnectCancelled connects the provided callback to the "cancelled" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Cancellable.cancelled.html
	//
	ConnectCancelled(func(Cancellable)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentCancelled calls the default implementations of the `GCancellable.cancelled` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Cancellable.cancelled.html
	ParentCancelled()
}

func unsafeWrapCancellable(base *gobject.ObjectInstance) *CancellableInstance {
	return &CancellableInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCancellable,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCancellable(inst)
		},
	)
}

func marshalCancellableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCancellableFromGlibNone is used to convert raw GCancellable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCancellableFromGlibNone(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibNone(c).(Cancellable)
}

// UnsafeCancellableFromGlibFull is used to convert raw GCancellable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCancellableFromGlibFull(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibFull(c).(Cancellable)
}

// UnsafeCancellableFromGlibBorrow is used to convert raw GCancellable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCancellableFromGlibBorrow(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Cancellable)
}

func (c *CancellableInstance) upcastToGCancellable() *CancellableInstance {
	return c
}

// UnsafeCancellableToGlibNone is used to convert the instance to it's C value GCancellable. This is used by the bindings internally.
func UnsafeCancellableToGlibNone(c Cancellable) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCancellableToGlibFull is used to convert the instance to it's C value GCancellable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCancellableToGlibFull(c Cancellable) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCancellable wraps g_cancellable_new
// 
// see also https://docs.gtk.org/gio/func.g_cancellable_new.html
//
func NewCancellable() Cancellable {
	var cret *C.GCancellable // return, full, converted

	cret = C.g_cancellable_new()

	var goret Cancellable

	goret = UnsafeCancellableFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// CancellableGetCurrent wraps g_cancellable_get_current
// 
// see also https://docs.gtk.org/gio/func.g_cancellable_get_current.html
//
func CancellableGetCurrent() Cancellable {
	var cret *C.GCancellable // return, none, converted, nullable

	cret = C.g_cancellable_get_current()

	var goret Cancellable

	if cret != nil {
		goret = UnsafeCancellableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Cancel wraps g_cancellable_cancel
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_cancel.g_cancellable_cancel.html
//
func (cancellable *CancellableInstance) Cancel() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_cancel(carg0)
	runtime.KeepAlive(cancellable)
}

// Disconnect wraps g_cancellable_disconnect
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_disconnect.g_cancellable_disconnect.html
//
func (cancellable *CancellableInstance) Disconnect(handlerId uint32) {
	var carg0 *C.GCancellable // in, none, converted
	var carg1 C.gulong        // in, none, casted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	carg1 = C.gulong(handlerId)

	C.g_cancellable_disconnect(carg0, carg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(handlerId)
}

// GetFd wraps g_cancellable_get_fd
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_get_fd.g_cancellable_get_fd.html
//
func (cancellable *CancellableInstance) GetFd() int32 {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.int           // return, none, casted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_get_fd(carg0)
	runtime.KeepAlive(cancellable)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsCancelled wraps g_cancellable_is_cancelled
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_is_cancelled.g_cancellable_is_cancelled.html
//
func (cancellable *CancellableInstance) IsCancelled() bool {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_is_cancelled(carg0)
	runtime.KeepAlive(cancellable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MakePollfd wraps g_cancellable_make_pollfd
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_make_pollfd.g_cancellable_make_pollfd.html
//
func (cancellable *CancellableInstance) MakePollfd(pollfd *glib.PollFD) bool {
	var carg0 *C.GCancellable // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	carg1 = (*C.GPollFD)(glib.UnsafePollFDToGlibNone(pollfd))

	cret = C.g_cancellable_make_pollfd(carg0, carg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(pollfd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PopCurrent wraps g_cancellable_pop_current
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_pop_current.g_cancellable_pop_current.html
//
func (cancellable *CancellableInstance) PopCurrent() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_pop_current(carg0)
	runtime.KeepAlive(cancellable)
}

// PushCurrent wraps g_cancellable_push_current
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_push_current.g_cancellable_push_current.html
//
func (cancellable *CancellableInstance) PushCurrent() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_push_current(carg0)
	runtime.KeepAlive(cancellable)
}

// ReleaseFd wraps g_cancellable_release_fd
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_release_fd.g_cancellable_release_fd.html
//
func (cancellable *CancellableInstance) ReleaseFd() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_release_fd(carg0)
	runtime.KeepAlive(cancellable)
}

// Reset wraps g_cancellable_reset
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_reset.g_cancellable_reset.html
//
func (cancellable *CancellableInstance) Reset() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_reset(carg0)
	runtime.KeepAlive(cancellable)
}

// SetErrorIfCancelled wraps g_cancellable_set_error_if_cancelled
// 
// see also https://docs.gtk.org/gio/method.g_cancellable_set_error_if_cancelled.g_cancellable_set_error_if_cancelled.html
//
func (cancellable *CancellableInstance) SetErrorIfCancelled() (bool, error) {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_set_error_if_cancelled(carg0, &_cerr)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectCancelled connects the provided callback to the "cancelled" signal
// 
// see also https://docs.gtk.org/gio/signal.Cancellable.cancelled.html
//
func (o *CancellableInstance) ConnectCancelled(fn func(Cancellable)) gobject.SignalHandle {
	return o.Connect("cancelled", fn)
}

// CancellableOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type CancellableOverrides[Instance Cancellable] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Cancelled allows you to override the implementation of the virtual method cancelled.
	// 
	// see also https://docs.gtk.org/gio/method.Cancellable.cancelled.html
	Cancelled func(Instance)
}

// UnsafeApplyCancellableOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyCancellableOverrides[Instance Cancellable](gclass unsafe.Pointer, overrides CancellableOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GCancellableClass)(gclass)

	if overrides.Cancelled != nil {
		pclass.cancelled = (*[0]byte)(C._goglib_gio2_Cancellable_cancelled)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Cancellable_cancelled",
			func(carg0 *C.GCancellable) {
				var cancellable Instance // go GCancellable subclass

				cancellable = UnsafeCancellableFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Cancelled(cancellable)
			},
		)
	}
}

// ParentCancelled calls the default implementations of the `GCancellable.cancelled` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Cancellable.cancelled.html
func (cancellable *CancellableInstance) ParentCancelled() {
	var carg0 *C.GCancellable

	parentclass := (*C.GCancellableClass)(classdata.PeekParentClass(UnsafeCancellableToGlibNone(cancellable)))

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C._goglib_gio2_Cancellable_virtual_cancelled(unsafe.Pointer(parentclass.cancelled), carg0)
	runtime.KeepAlive(cancellable)
}

// RegisterCancellableSubClass is used to register a go subclass of GCancellable. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterCancellableSubClass[InstanceT Cancellable](
		name string,
		classInit func(class *CancellableClass),
		constructor func() InstanceT,
		overrides CancellableOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeCancellable,
		UnsafeCancellableClassFromGlibBorrow,
		UnsafeApplyCancellableOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCancellable(obj)
		},
		interfaceInits...,
	)
}

// CharsetConverterInstance is the instance type used by all types extending GCharsetConverter. It is used internally by the bindings. Users should use the interface [CharsetConverter] instead.
type CharsetConverterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ CharsetConverter = (*CharsetConverterInstance)(nil)

// CharsetConverter wraps GCharsetConverter
// 
// see also https://docs.gtk.org/gio/class.CharsetConverter.html
//
type CharsetConverter interface {
	gobject.Object
	upcastToGCharsetConverter() *CharsetConverterInstance

	// GetNumFallbacks wraps g_charset_converter_get_num_fallbacks
	// 
	// see also https://docs.gtk.org/gio/method.g_charset_converter_get_num_fallbacks.g_charset_converter_get_num_fallbacks.html
	//
	GetNumFallbacks() uint
	// GetUseFallback wraps g_charset_converter_get_use_fallback
	// 
	// see also https://docs.gtk.org/gio/method.g_charset_converter_get_use_fallback.g_charset_converter_get_use_fallback.html
	//
	GetUseFallback() bool
	// SetUseFallback wraps g_charset_converter_set_use_fallback
	// 
	// see also https://docs.gtk.org/gio/method.g_charset_converter_set_use_fallback.g_charset_converter_set_use_fallback.html
	//
	SetUseFallback(bool)

	// chain up virtual methods:
}

func unsafeWrapCharsetConverter(base *gobject.ObjectInstance) *CharsetConverterInstance {
	return &CharsetConverterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCharsetConverter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCharsetConverter(inst)
		},
	)
}

func marshalCharsetConverterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCharsetConverterFromGlibNone is used to convert raw GCharsetConverter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibNone(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibNone(c).(CharsetConverter)
}

// UnsafeCharsetConverterFromGlibFull is used to convert raw GCharsetConverter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibFull(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibFull(c).(CharsetConverter)
}

// UnsafeCharsetConverterFromGlibBorrow is used to convert raw GCharsetConverter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibBorrow(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(CharsetConverter)
}

func (c *CharsetConverterInstance) upcastToGCharsetConverter() *CharsetConverterInstance {
	return c
}

// UnsafeCharsetConverterToGlibNone is used to convert the instance to it's C value GCharsetConverter. This is used by the bindings internally.
func UnsafeCharsetConverterToGlibNone(c CharsetConverter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCharsetConverterToGlibFull is used to convert the instance to it's C value GCharsetConverter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterToGlibFull(c CharsetConverter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCharsetConverter wraps g_charset_converter_new
// 
// see also https://docs.gtk.org/gio/func.g_charset_converter_new.html
//
func NewCharsetConverter(toCharset string, fromCharset string) (CharsetConverter, error) {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var cret  *C.GCharsetConverter // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(toCharset)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(fromCharset)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_charset_converter_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(toCharset)
	runtime.KeepAlive(fromCharset)

	var goret  CharsetConverter
	var _goerr error

	goret = UnsafeCharsetConverterFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetNumFallbacks wraps g_charset_converter_get_num_fallbacks
// 
// see also https://docs.gtk.org/gio/method.g_charset_converter_get_num_fallbacks.g_charset_converter_get_num_fallbacks.html
//
func (converter *CharsetConverterInstance) GetNumFallbacks() uint {
	var carg0 *C.GCharsetConverter // in, none, converted
	var cret  C.guint              // return, none, casted

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))

	cret = C.g_charset_converter_get_num_fallbacks(carg0)
	runtime.KeepAlive(converter)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUseFallback wraps g_charset_converter_get_use_fallback
// 
// see also https://docs.gtk.org/gio/method.g_charset_converter_get_use_fallback.g_charset_converter_get_use_fallback.html
//
func (converter *CharsetConverterInstance) GetUseFallback() bool {
	var carg0 *C.GCharsetConverter // in, none, converted
	var cret  C.gboolean           // return

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))

	cret = C.g_charset_converter_get_use_fallback(carg0)
	runtime.KeepAlive(converter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUseFallback wraps g_charset_converter_set_use_fallback
// 
// see also https://docs.gtk.org/gio/method.g_charset_converter_set_use_fallback.g_charset_converter_set_use_fallback.html
//
func (converter *CharsetConverterInstance) SetUseFallback(useFallback bool) {
	var carg0 *C.GCharsetConverter // in, none, converted
	var carg1 C.gboolean           // in

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))
	if useFallback {
		carg1 = C.TRUE
	}

	C.g_charset_converter_set_use_fallback(carg0, carg1)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(useFallback)
}

// CharsetConverterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type CharsetConverterOverrides[Instance CharsetConverter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyCharsetConverterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyCharsetConverterOverrides[Instance CharsetConverter](gclass unsafe.Pointer, overrides CharsetConverterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterCharsetConverterSubClass is used to register a go subclass of GCharsetConverter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterCharsetConverterSubClass[InstanceT CharsetConverter](
		name string,
		classInit func(class *CharsetConverterClass),
		constructor func() InstanceT,
		overrides CharsetConverterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeCharsetConverter,
		UnsafeCharsetConverterClassFromGlibBorrow,
		UnsafeApplyCharsetConverterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCharsetConverter(obj)
		},
		interfaceInits...,
	)
}

// CredentialsInstance is the instance type used by all types extending GCredentials. It is used internally by the bindings. Users should use the interface [Credentials] instead.
type CredentialsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Credentials = (*CredentialsInstance)(nil)

// Credentials wraps GCredentials
// 
// see also https://docs.gtk.org/gio/class.Credentials.html
//
type Credentials interface {
	gobject.Object
	upcastToGCredentials() *CredentialsInstance

	// IsSameUser wraps g_credentials_is_same_user
	// 
	// see also https://docs.gtk.org/gio/method.g_credentials_is_same_user.g_credentials_is_same_user.html
	//
	IsSameUser(Credentials) (bool, error)
	// String wraps g_credentials_to_string
	// 
	// see also https://docs.gtk.org/gio/method.g_credentials_to_string.g_credentials_to_string.html
	//
	String() string
}

func unsafeWrapCredentials(base *gobject.ObjectInstance) *CredentialsInstance {
	return &CredentialsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCredentials,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCredentials(inst)
		},
	)
}

func marshalCredentialsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCredentialsFromGlibNone is used to convert raw GCredentials pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCredentialsFromGlibNone(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibNone(c).(Credentials)
}

// UnsafeCredentialsFromGlibFull is used to convert raw GCredentials pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCredentialsFromGlibFull(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibFull(c).(Credentials)
}

// UnsafeCredentialsFromGlibBorrow is used to convert raw GCredentials pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCredentialsFromGlibBorrow(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Credentials)
}

func (c *CredentialsInstance) upcastToGCredentials() *CredentialsInstance {
	return c
}

// UnsafeCredentialsToGlibNone is used to convert the instance to it's C value GCredentials. This is used by the bindings internally.
func UnsafeCredentialsToGlibNone(c Credentials) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCredentialsToGlibFull is used to convert the instance to it's C value GCredentials, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCredentialsToGlibFull(c Credentials) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCredentials wraps g_credentials_new
// 
// see also https://docs.gtk.org/gio/func.g_credentials_new.html
//
func NewCredentials() Credentials {
	var cret *C.GCredentials // return, full, converted

	cret = C.g_credentials_new()

	var goret Credentials

	goret = UnsafeCredentialsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IsSameUser wraps g_credentials_is_same_user
// 
// see also https://docs.gtk.org/gio/method.g_credentials_is_same_user.g_credentials_is_same_user.html
//
func (credentials *CredentialsInstance) IsSameUser(otherCredentials Credentials) (bool, error) {
	var carg0 *C.GCredentials // in, none, converted
	var carg1 *C.GCredentials // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(credentials))
	carg1 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(otherCredentials))

	cret = C.g_credentials_is_same_user(carg0, carg1, &_cerr)
	runtime.KeepAlive(credentials)
	runtime.KeepAlive(otherCredentials)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// String wraps g_credentials_to_string
// 
// see also https://docs.gtk.org/gio/method.g_credentials_to_string.g_credentials_to_string.html
//
func (credentials *CredentialsInstance) String() string {
	var carg0 *C.GCredentials // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(credentials))

	cret = C.g_credentials_to_string(carg0)
	runtime.KeepAlive(credentials)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// EmblemInstance is the instance type used by all types extending GEmblem. It is used internally by the bindings. Users should use the interface [Emblem] instead.
type EmblemInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Emblem = (*EmblemInstance)(nil)

// Emblem wraps GEmblem
// 
// see also https://docs.gtk.org/gio/class.Emblem.html
//
type Emblem interface {
	gobject.Object
	upcastToGEmblem() *EmblemInstance

	// GetIcon wraps g_emblem_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_emblem_get_icon.g_emblem_get_icon.html
	//
	GetIcon() Icon
	// GetOrigin wraps g_emblem_get_origin
	// 
	// see also https://docs.gtk.org/gio/method.g_emblem_get_origin.g_emblem_get_origin.html
	//
	GetOrigin() EmblemOrigin
}

func unsafeWrapEmblem(base *gobject.ObjectInstance) *EmblemInstance {
	return &EmblemInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeEmblem,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblem(inst)
		},
	)
}

func marshalEmblemInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeEmblemFromGlibNone is used to convert raw GEmblem pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemFromGlibNone(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibNone(c).(Emblem)
}

// UnsafeEmblemFromGlibFull is used to convert raw GEmblem pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemFromGlibFull(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibFull(c).(Emblem)
}

// UnsafeEmblemFromGlibBorrow is used to convert raw GEmblem pointers to go without touching any references. This is used by the bindings internally.
func UnsafeEmblemFromGlibBorrow(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Emblem)
}

func (e *EmblemInstance) upcastToGEmblem() *EmblemInstance {
	return e
}

// UnsafeEmblemToGlibNone is used to convert the instance to it's C value GEmblem. This is used by the bindings internally.
func UnsafeEmblemToGlibNone(c Emblem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeEmblemToGlibFull is used to convert the instance to it's C value GEmblem, while removeing the finalizer. This is used by the bindings internally.
func UnsafeEmblemToGlibFull(c Emblem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewEmblem wraps g_emblem_new
// 
// see also https://docs.gtk.org/gio/func.g_emblem_new.html
//
func NewEmblem(icon Icon) Emblem {
	var carg1 *C.GIcon   // in, none, converted
	var cret  *C.GEmblem // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	cret = C.g_emblem_new(carg1)
	runtime.KeepAlive(icon)

	var goret Emblem

	goret = UnsafeEmblemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewEmblemWithOrigin wraps g_emblem_new_with_origin
// 
// see also https://docs.gtk.org/gio/func.g_emblem_new_with_origin.html
//
func NewEmblemWithOrigin(icon Icon, origin EmblemOrigin) Emblem {
	var carg1 *C.GIcon        // in, none, converted
	var carg2 C.GEmblemOrigin // in, none, casted
	var cret  *C.GEmblem      // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))
	carg2 = C.GEmblemOrigin(origin)

	cret = C.g_emblem_new_with_origin(carg1, carg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(origin)

	var goret Emblem

	goret = UnsafeEmblemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIcon wraps g_emblem_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_emblem_get_icon.g_emblem_get_icon.html
//
func (emblem *EmblemInstance) GetIcon() Icon {
	var carg0 *C.GEmblem // in, none, converted
	var cret  *C.GIcon   // return, none, converted

	carg0 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	cret = C.g_emblem_get_icon(carg0)
	runtime.KeepAlive(emblem)

	var goret Icon

	goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetOrigin wraps g_emblem_get_origin
// 
// see also https://docs.gtk.org/gio/method.g_emblem_get_origin.g_emblem_get_origin.html
//
func (emblem *EmblemInstance) GetOrigin() EmblemOrigin {
	var carg0 *C.GEmblem      // in, none, converted
	var cret  C.GEmblemOrigin // return, none, casted

	carg0 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	cret = C.g_emblem_get_origin(carg0)
	runtime.KeepAlive(emblem)

	var goret EmblemOrigin

	goret = EmblemOrigin(cret)

	return goret
}

// EmblemedIconInstance is the instance type used by all types extending GEmblemedIcon. It is used internally by the bindings. Users should use the interface [EmblemedIcon] instead.
type EmblemedIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ EmblemedIcon = (*EmblemedIconInstance)(nil)

// EmblemedIcon wraps GEmblemedIcon
// 
// see also https://docs.gtk.org/gio/class.EmblemedIcon.html
//
type EmblemedIcon interface {
	gobject.Object
	upcastToGEmblemedIcon() *EmblemedIconInstance

	// AddEmblem wraps g_emblemed_icon_add_emblem
	// 
	// see also https://docs.gtk.org/gio/method.g_emblemed_icon_add_emblem.g_emblemed_icon_add_emblem.html
	//
	AddEmblem(Emblem)
	// ClearEmblems wraps g_emblemed_icon_clear_emblems
	// 
	// see also https://docs.gtk.org/gio/method.g_emblemed_icon_clear_emblems.g_emblemed_icon_clear_emblems.html
	//
	ClearEmblems()
	// GetEmblems wraps g_emblemed_icon_get_emblems
	// 
	// see also https://docs.gtk.org/gio/method.g_emblemed_icon_get_emblems.g_emblemed_icon_get_emblems.html
	//
	GetEmblems() []Emblem
	// GetIcon wraps g_emblemed_icon_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_emblemed_icon_get_icon.g_emblemed_icon_get_icon.html
	//
	GetIcon() Icon

	// chain up virtual methods:
}

func unsafeWrapEmblemedIcon(base *gobject.ObjectInstance) *EmblemedIconInstance {
	return &EmblemedIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeEmblemedIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblemedIcon(inst)
		},
	)
}

func marshalEmblemedIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeEmblemedIconFromGlibNone is used to convert raw GEmblemedIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibNone(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(EmblemedIcon)
}

// UnsafeEmblemedIconFromGlibFull is used to convert raw GEmblemedIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibFull(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(EmblemedIcon)
}

// UnsafeEmblemedIconFromGlibBorrow is used to convert raw GEmblemedIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibBorrow(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(EmblemedIcon)
}

func (e *EmblemedIconInstance) upcastToGEmblemedIcon() *EmblemedIconInstance {
	return e
}

// UnsafeEmblemedIconToGlibNone is used to convert the instance to it's C value GEmblemedIcon. This is used by the bindings internally.
func UnsafeEmblemedIconToGlibNone(c EmblemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeEmblemedIconToGlibFull is used to convert the instance to it's C value GEmblemedIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconToGlibFull(c EmblemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewEmblemedIcon wraps g_emblemed_icon_new
// 
// see also https://docs.gtk.org/gio/func.g_emblemed_icon_new.html
//
func NewEmblemedIcon(icon Icon, emblem Emblem) EmblemedIcon {
	var carg1 *C.GIcon   // in, none, converted
	var carg2 *C.GEmblem // in, none, converted, nullable
	var cret  *C.GIcon   // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))
	if emblem != nil {
		carg2 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))
	}

	cret = C.g_emblemed_icon_new(carg1, carg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(emblem)

	var goret EmblemedIcon

	goret = UnsafeEmblemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddEmblem wraps g_emblemed_icon_add_emblem
// 
// see also https://docs.gtk.org/gio/method.g_emblemed_icon_add_emblem.g_emblemed_icon_add_emblem.html
//
func (emblemed *EmblemedIconInstance) AddEmblem(emblem Emblem) {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var carg1 *C.GEmblem       // in, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))
	carg1 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	C.g_emblemed_icon_add_emblem(carg0, carg1)
	runtime.KeepAlive(emblemed)
	runtime.KeepAlive(emblem)
}

// ClearEmblems wraps g_emblemed_icon_clear_emblems
// 
// see also https://docs.gtk.org/gio/method.g_emblemed_icon_clear_emblems.g_emblemed_icon_clear_emblems.html
//
func (emblemed *EmblemedIconInstance) ClearEmblems() {
	var carg0 *C.GEmblemedIcon // in, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	C.g_emblemed_icon_clear_emblems(carg0)
	runtime.KeepAlive(emblemed)
}

// GetEmblems wraps g_emblemed_icon_get_emblems
// 
// see also https://docs.gtk.org/gio/method.g_emblemed_icon_get_emblems.g_emblemed_icon_get_emblems.html
//
func (emblemed *EmblemedIconInstance) GetEmblems() []Emblem {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var cret  *C.GList         // container, transfer: none

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	cret = C.g_emblemed_icon_get_emblems(carg0)
	runtime.KeepAlive(emblemed)

	var goret []Emblem

	goret = glib.UnsafeListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Emblem {
			var dst Emblem // converted
			dst = UnsafeEmblemFromGlibNone(v)
			return dst
		},
	)

	return goret
}

// GetIcon wraps g_emblemed_icon_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_emblemed_icon_get_icon.g_emblemed_icon_get_icon.html
//
func (emblemed *EmblemedIconInstance) GetIcon() Icon {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var cret  *C.GIcon         // return, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	cret = C.g_emblemed_icon_get_icon(carg0)
	runtime.KeepAlive(emblemed)

	var goret Icon

	goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// EmblemedIconOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type EmblemedIconOverrides[Instance EmblemedIcon] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyEmblemedIconOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyEmblemedIconOverrides[Instance EmblemedIcon](gclass unsafe.Pointer, overrides EmblemedIconOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterEmblemedIconSubClass is used to register a go subclass of GEmblemedIcon. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterEmblemedIconSubClass[InstanceT EmblemedIcon](
		name string,
		classInit func(class *EmblemedIconClass),
		constructor func() InstanceT,
		overrides EmblemedIconOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeEmblemedIcon,
		UnsafeEmblemedIconClassFromGlibBorrow,
		UnsafeApplyEmblemedIconOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblemedIcon(obj)
		},
		interfaceInits...,
	)
}

// FileEnumeratorInstance is the instance type used by all types extending GFileEnumerator. It is used internally by the bindings. Users should use the interface [FileEnumerator] instead.
type FileEnumeratorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileEnumerator = (*FileEnumeratorInstance)(nil)

// FileEnumerator wraps GFileEnumerator
// 
// see also https://docs.gtk.org/gio/class.FileEnumerator.html
//
type FileEnumerator interface {
	gobject.Object
	upcastToGFileEnumerator() *FileEnumeratorInstance

	// Close wraps g_file_enumerator_close
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_close.g_file_enumerator_close.html
	//
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_file_enumerator_close_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_close_async.g_file_enumerator_close_async.html
	//
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_file_enumerator_close_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_close_finish.g_file_enumerator_close_finish.html
	//
	CloseFinish(AsyncResult) (bool, error)
	// GetChild wraps g_file_enumerator_get_child
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_get_child.g_file_enumerator_get_child.html
	//
	GetChild(FileInfo) File
	// GetContainer wraps g_file_enumerator_get_container
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_get_container.g_file_enumerator_get_container.html
	//
	GetContainer() File
	// HasPending wraps g_file_enumerator_has_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_has_pending.g_file_enumerator_has_pending.html
	//
	HasPending() bool
	// IsClosed wraps g_file_enumerator_is_closed
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_is_closed.g_file_enumerator_is_closed.html
	//
	IsClosed() bool
	// Iterate wraps g_file_enumerator_iterate
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_iterate.g_file_enumerator_iterate.html
	//
	Iterate(Cancellable) (FileInfo, File, bool, error)
	// NextFile wraps g_file_enumerator_next_file
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_file.g_file_enumerator_next_file.html
	//
	NextFile(Cancellable) (FileInfo, error)
	// NextFilesAsync wraps g_file_enumerator_next_files_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_files_async.g_file_enumerator_next_files_async.html
	//
	NextFilesAsync(int32, int32, Cancellable, AsyncReadyCallback)
	// NextFilesFinish wraps g_file_enumerator_next_files_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_files_finish.g_file_enumerator_next_files_finish.html
	//
	NextFilesFinish(AsyncResult) ([]FileInfo, error)
	// SetPending wraps g_file_enumerator_set_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_file_enumerator_set_pending.g_file_enumerator_set_pending.html
	//
	SetPending(bool)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GFileEnumerator.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.close_finish.html
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GFileEnumerator.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.close_fn.html
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentNextFile calls the default implementations of the `GFileEnumerator.next_file` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.next_file.html
	ParentNextFile(cancellable Cancellable) (FileInfo, error)
	// ParentNextFilesFinish calls the default implementations of the `GFileEnumerator.next_files_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.next_files_finish.html
	ParentNextFilesFinish(result AsyncResult) ([]FileInfo, error)
}

func unsafeWrapFileEnumerator(base *gobject.ObjectInstance) *FileEnumeratorInstance {
	return &FileEnumeratorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileEnumerator(inst)
		},
	)
}

func marshalFileEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileEnumeratorFromGlibNone is used to convert raw GFileEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibNone(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(FileEnumerator)
}

// UnsafeFileEnumeratorFromGlibFull is used to convert raw GFileEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibFull(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(FileEnumerator)
}

// UnsafeFileEnumeratorFromGlibBorrow is used to convert raw GFileEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibBorrow(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileEnumerator)
}

func (f *FileEnumeratorInstance) upcastToGFileEnumerator() *FileEnumeratorInstance {
	return f
}

// UnsafeFileEnumeratorToGlibNone is used to convert the instance to it's C value GFileEnumerator. This is used by the bindings internally.
func UnsafeFileEnumeratorToGlibNone(c FileEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileEnumeratorToGlibFull is used to convert the instance to it's C value GFileEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorToGlibFull(c FileEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Close wraps g_file_enumerator_close
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_close.g_file_enumerator_close.html
//
func (enumerator *FileEnumeratorInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_file_enumerator_close_async
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_close_async.g_file_enumerator_close_async.html
//
func (enumerator *FileEnumeratorInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileEnumerator    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerator_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_file_enumerator_close_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_close_finish.g_file_enumerator_close_finish.html
//
func (enumerator *FileEnumeratorInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_enumerator_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetChild wraps g_file_enumerator_get_child
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_get_child.g_file_enumerator_get_child.html
//
func (enumerator *FileEnumeratorInstance) GetChild(info FileInfo) File {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GFileInfo       // in, none, converted
	var cret  *C.GFile           // return, full, converted

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_enumerator_get_child(carg0, carg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(info)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContainer wraps g_file_enumerator_get_container
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_get_container.g_file_enumerator_get_container.html
//
func (enumerator *FileEnumeratorInstance) GetContainer() File {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  *C.GFile           // return, none, converted

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_get_container(carg0)
	runtime.KeepAlive(enumerator)

	var goret File

	goret = UnsafeFileFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// HasPending wraps g_file_enumerator_has_pending
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_has_pending.g_file_enumerator_has_pending.html
//
func (enumerator *FileEnumeratorInstance) HasPending() bool {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_has_pending(carg0)
	runtime.KeepAlive(enumerator)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_file_enumerator_is_closed
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_is_closed.g_file_enumerator_is_closed.html
//
func (enumerator *FileEnumeratorInstance) IsClosed() bool {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_is_closed(carg0)
	runtime.KeepAlive(enumerator)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Iterate wraps g_file_enumerator_iterate
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_iterate.g_file_enumerator_iterate.html
//
func (direnum *FileEnumeratorInstance) Iterate(cancellable Cancellable) (FileInfo, File, bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg3 *C.GCancellable    // in, none, converted, nullable
	var carg1 *C.GFileInfo       // out, none, converted
	var carg2 *C.GFile           // out, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(direnum))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_iterate(carg0, &carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(direnum)
	runtime.KeepAlive(cancellable)

	var outInfo  FileInfo
	var outChild File
	var goret    bool
	var _goerr   error

	outInfo = UnsafeFileInfoFromGlibNone(unsafe.Pointer(carg1))
	outChild = UnsafeFileFromGlibNone(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outInfo, outChild, goret, _goerr
}

// NextFile wraps g_file_enumerator_next_file
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_file.g_file_enumerator_next_file.html
//
func (enumerator *FileEnumeratorInstance) NextFile(cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileInfo       // return, full, converted, nullable
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_next_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	if cret != nil {
		goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NextFilesAsync wraps g_file_enumerator_next_files_async
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_files_async.g_file_enumerator_next_files_async.html
//
func (enumerator *FileEnumeratorInstance) NextFilesAsync(numFiles int32, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileEnumerator    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = C.int(numFiles)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerator_next_files_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(numFiles)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NextFilesFinish wraps g_file_enumerator_next_files_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_next_files_finish.g_file_enumerator_next_files_finish.html
//
func (enumerator *FileEnumeratorInstance) NextFilesFinish(result AsyncResult) ([]FileInfo, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GList           // container, transfer: full
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_enumerator_next_files_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  []FileInfo
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) FileInfo {
			var dst FileInfo // converted
			dst = UnsafeFileInfoFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetPending wraps g_file_enumerator_set_pending
// 
// see also https://docs.gtk.org/gio/method.g_file_enumerator_set_pending.g_file_enumerator_set_pending.html
//
func (enumerator *FileEnumeratorInstance) SetPending(pending bool) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if pending {
		carg1 = C.TRUE
	}

	C.g_file_enumerator_set_pending(carg0, carg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(pending)
}

// FileEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileEnumeratorOverrides[Instance FileEnumerator] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.close_finish.html
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.close_fn.html
	CloseFn func(Instance, Cancellable) (bool, error)
	// // NextFile allows you to override the implementation of the virtual method next_file.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.next_file.html
	NextFile func(Instance, Cancellable) (FileInfo, error)
	// // NextFilesFinish allows you to override the implementation of the virtual method next_files_finish.
	// 
	// see also https://docs.gtk.org/gio/method.FileEnumerator.next_files_finish.html
	NextFilesFinish func(Instance, AsyncResult) ([]FileInfo, error)
}

// UnsafeApplyFileEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileEnumeratorOverrides[Instance FileEnumerator](gclass unsafe.Pointer, overrides FileEnumeratorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFileEnumeratorClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_FileEnumerator_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_close_finish",
			func(carg0 *C.GFileEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var enumerator Instance    // go GFileEnumerator subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(enumerator, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_FileEnumerator_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_close_fn",
			func(carg0 *C.GFileEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var enumerator  Instance    // go GFileEnumerator subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(enumerator, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFile != nil {
		pclass.next_file = (*[0]byte)(C._goglib_gio2_FileEnumerator_next_file)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_next_file",
			func(carg0 *C.GFileEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var enumerator  Instance    // go GFileEnumerator subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted, nullable
				var _goerr      error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.NextFile(enumerator, cancellable)

				if goret != nil {
					cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFilesFinish != nil {
		pclass.next_files_finish = (*[0]byte)(C._goglib_gio2_FileEnumerator_next_files_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_next_files_finish",
			func(carg0 *C.GFileEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var enumerator Instance    // go GFileEnumerator subclass
				var result     AsyncResult // in, none, converted
				var goret      []FileInfo  // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr     error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.NextFilesFinish(enumerator, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []FileInfo (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GFileEnumerator.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileEnumerator.close_finish.html
func (enumerator *FileEnumeratorInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileEnumerator_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GFileEnumerator.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileEnumerator.close_fn.html
func (enumerator *FileEnumeratorInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileEnumerator_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFile calls the default implementations of the `GFileEnumerator.next_file` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileEnumerator.next_file.html
func (enumerator *FileEnumeratorInstance) ParentNextFile(cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GCancellable // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted, nullable
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileEnumerator_virtual_next_file(unsafe.Pointer(parentclass.next_file), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	if cret != nil {
		goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFilesFinish calls the default implementations of the `GFileEnumerator.next_files_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileEnumerator.next_files_finish.html
func (enumerator *FileEnumeratorInstance) ParentNextFilesFinish(result AsyncResult) ([]FileInfo, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileEnumerator_virtual_next_files_finish(unsafe.Pointer(parentclass.next_files_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  []FileInfo
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) FileInfo {
			var dst FileInfo // converted
			dst = UnsafeFileInfoFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileEnumeratorSubClass is used to register a go subclass of GFileEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileEnumeratorSubClass[InstanceT FileEnumerator](
		name string,
		classInit func(class *FileEnumeratorClass),
		constructor func() InstanceT,
		overrides FileEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileEnumerator,
		UnsafeFileEnumeratorClassFromGlibBorrow,
		UnsafeApplyFileEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileEnumerator(obj)
		},
		interfaceInits...,
	)
}

// FileIconInstance is the instance type used by all types extending GFileIcon. It is used internally by the bindings. Users should use the interface [FileIcon] instead.
type FileIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileIcon = (*FileIconInstance)(nil)

// FileIcon wraps GFileIcon
// 
// see also https://docs.gtk.org/gio/class.FileIcon.html
//
type FileIcon interface {
	gobject.Object
	upcastToGFileIcon() *FileIconInstance

	// GetFile wraps g_file_icon_get_file
	// 
	// see also https://docs.gtk.org/gio/method.g_file_icon_get_file.g_file_icon_get_file.html
	//
	GetFile() File
}

func unsafeWrapFileIcon(base *gobject.ObjectInstance) *FileIconInstance {
	return &FileIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIcon(inst)
		},
	)
}

func marshalFileIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileIconFromGlibNone is used to convert raw GFileIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIconFromGlibNone(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(FileIcon)
}

// UnsafeFileIconFromGlibFull is used to convert raw GFileIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIconFromGlibFull(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(FileIcon)
}

// UnsafeFileIconFromGlibBorrow is used to convert raw GFileIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileIconFromGlibBorrow(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileIcon)
}

func (f *FileIconInstance) upcastToGFileIcon() *FileIconInstance {
	return f
}

// UnsafeFileIconToGlibNone is used to convert the instance to it's C value GFileIcon. This is used by the bindings internally.
func UnsafeFileIconToGlibNone(c FileIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileIconToGlibFull is used to convert the instance to it's C value GFileIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileIconToGlibFull(c FileIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFileIcon wraps g_file_icon_new
// 
// see also https://docs.gtk.org/gio/func.g_file_icon_new.html
//
func NewFileIcon(file File) FileIcon {
	var carg1 *C.GFile // in, none, converted
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_icon_new(carg1)
	runtime.KeepAlive(file)

	var goret FileIcon

	goret = UnsafeFileIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFile wraps g_file_icon_get_file
// 
// see also https://docs.gtk.org/gio/method.g_file_icon_get_file.g_file_icon_get_file.html
//
func (icon *FileIconInstance) GetFile() File {
	var carg0 *C.GFileIcon // in, none, converted
	var cret  *C.GFile     // return, none, converted

	carg0 = (*C.GFileIcon)(UnsafeFileIconToGlibNone(icon))

	cret = C.g_file_icon_get_file(carg0)
	runtime.KeepAlive(icon)

	var goret File

	goret = UnsafeFileFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// FileInfoInstance is the instance type used by all types extending GFileInfo. It is used internally by the bindings. Users should use the interface [FileInfo] instead.
type FileInfoInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileInfo = (*FileInfoInstance)(nil)

// FileInfo wraps GFileInfo
// 
// see also https://docs.gtk.org/gio/class.FileInfo.html
//
type FileInfo interface {
	gobject.Object
	upcastToGFileInfo() *FileInfoInstance

	// ClearStatus wraps g_file_info_clear_status
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_clear_status.g_file_info_clear_status.html
	//
	ClearStatus()
	// CopyInto wraps g_file_info_copy_into
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_copy_into.g_file_info_copy_into.html
	//
	CopyInto(FileInfo)
	// Dup wraps g_file_info_dup
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_dup.g_file_info_dup.html
	//
	Dup() FileInfo
	// GetAttributeAsString wraps g_file_info_get_attribute_as_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_as_string.g_file_info_get_attribute_as_string.html
	//
	GetAttributeAsString(string) string
	// GetAttributeBoolean wraps g_file_info_get_attribute_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_boolean.g_file_info_get_attribute_boolean.html
	//
	GetAttributeBoolean(string) bool
	// GetAttributeByteString wraps g_file_info_get_attribute_byte_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_byte_string.g_file_info_get_attribute_byte_string.html
	//
	GetAttributeByteString(string) string
	// GetAttributeFilePath wraps g_file_info_get_attribute_file_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_file_path.g_file_info_get_attribute_file_path.html
	//
	GetAttributeFilePath(string) string
	// GetAttributeInt32 wraps g_file_info_get_attribute_int32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_int32.g_file_info_get_attribute_int32.html
	//
	GetAttributeInt32(string) int32
	// GetAttributeInt64 wraps g_file_info_get_attribute_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_int64.g_file_info_get_attribute_int64.html
	//
	GetAttributeInt64(string) int64
	// GetAttributeObject wraps g_file_info_get_attribute_object
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_object.g_file_info_get_attribute_object.html
	//
	GetAttributeObject(string) gobject.Object
	// GetAttributeStatus wraps g_file_info_get_attribute_status
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_status.g_file_info_get_attribute_status.html
	//
	GetAttributeStatus(string) FileAttributeStatus
	// GetAttributeString wraps g_file_info_get_attribute_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_string.g_file_info_get_attribute_string.html
	//
	GetAttributeString(string) string
	// GetAttributeStringv wraps g_file_info_get_attribute_stringv
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_stringv.g_file_info_get_attribute_stringv.html
	//
	GetAttributeStringv(string) []string
	// GetAttributeType wraps g_file_info_get_attribute_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_type.g_file_info_get_attribute_type.html
	//
	GetAttributeType(string) FileAttributeType
	// GetAttributeUint32 wraps g_file_info_get_attribute_uint32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_uint32.g_file_info_get_attribute_uint32.html
	//
	GetAttributeUint32(string) uint32
	// GetAttributeUint64 wraps g_file_info_get_attribute_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_uint64.g_file_info_get_attribute_uint64.html
	//
	GetAttributeUint64(string) uint64
	// GetContentType wraps g_file_info_get_content_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_content_type.g_file_info_get_content_type.html
	//
	GetContentType() string
	// GetDisplayName wraps g_file_info_get_display_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_display_name.g_file_info_get_display_name.html
	//
	GetDisplayName() string
	// GetEditName wraps g_file_info_get_edit_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_edit_name.g_file_info_get_edit_name.html
	//
	GetEditName() string
	// GetEtag wraps g_file_info_get_etag
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_etag.g_file_info_get_etag.html
	//
	GetEtag() string
	// GetFileType wraps g_file_info_get_file_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_file_type.g_file_info_get_file_type.html
	//
	GetFileType() FileType
	// GetIcon wraps g_file_info_get_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_icon.g_file_info_get_icon.html
	//
	GetIcon() Icon
	// GetIsBackup wraps g_file_info_get_is_backup
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_is_backup.g_file_info_get_is_backup.html
	//
	GetIsBackup() bool
	// GetIsHidden wraps g_file_info_get_is_hidden
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_is_hidden.g_file_info_get_is_hidden.html
	//
	GetIsHidden() bool
	// GetIsSymlink wraps g_file_info_get_is_symlink
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_is_symlink.g_file_info_get_is_symlink.html
	//
	GetIsSymlink() bool
	// GetName wraps g_file_info_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_name.g_file_info_get_name.html
	//
	GetName() string
	// GetSize wraps g_file_info_get_size
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_size.g_file_info_get_size.html
	//
	GetSize() int64
	// GetSortOrder wraps g_file_info_get_sort_order
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_sort_order.g_file_info_get_sort_order.html
	//
	GetSortOrder() int32
	// GetSymbolicIcon wraps g_file_info_get_symbolic_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_symbolic_icon.g_file_info_get_symbolic_icon.html
	//
	GetSymbolicIcon() Icon
	// GetSymlinkTarget wraps g_file_info_get_symlink_target
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_get_symlink_target.g_file_info_get_symlink_target.html
	//
	GetSymlinkTarget() string
	// HasAttribute wraps g_file_info_has_attribute
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_has_attribute.g_file_info_has_attribute.html
	//
	HasAttribute(string) bool
	// HasNamespace wraps g_file_info_has_namespace
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_has_namespace.g_file_info_has_namespace.html
	//
	HasNamespace(string) bool
	// ListAttributes wraps g_file_info_list_attributes
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_list_attributes.g_file_info_list_attributes.html
	//
	ListAttributes(string) []string
	// RemoveAttribute wraps g_file_info_remove_attribute
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_remove_attribute.g_file_info_remove_attribute.html
	//
	RemoveAttribute(string)
	// SetAttributeBoolean wraps g_file_info_set_attribute_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_boolean.g_file_info_set_attribute_boolean.html
	//
	SetAttributeBoolean(string, bool)
	// SetAttributeByteString wraps g_file_info_set_attribute_byte_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_byte_string.g_file_info_set_attribute_byte_string.html
	//
	SetAttributeByteString(string, string)
	// SetAttributeFilePath wraps g_file_info_set_attribute_file_path
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_file_path.g_file_info_set_attribute_file_path.html
	//
	SetAttributeFilePath(string, string)
	// SetAttributeInt32 wraps g_file_info_set_attribute_int32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_int32.g_file_info_set_attribute_int32.html
	//
	SetAttributeInt32(string, int32)
	// SetAttributeInt64 wraps g_file_info_set_attribute_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_int64.g_file_info_set_attribute_int64.html
	//
	SetAttributeInt64(string, int64)
	// SetAttributeMask wraps g_file_info_set_attribute_mask
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_mask.g_file_info_set_attribute_mask.html
	//
	SetAttributeMask(*FileAttributeMatcher)
	// SetAttributeObject wraps g_file_info_set_attribute_object
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_object.g_file_info_set_attribute_object.html
	//
	SetAttributeObject(string, gobject.Object)
	// SetAttributeStatus wraps g_file_info_set_attribute_status
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_status.g_file_info_set_attribute_status.html
	//
	SetAttributeStatus(string, FileAttributeStatus) bool
	// SetAttributeString wraps g_file_info_set_attribute_string
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_string.g_file_info_set_attribute_string.html
	//
	SetAttributeString(string, string)
	// SetAttributeStringv wraps g_file_info_set_attribute_stringv
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_stringv.g_file_info_set_attribute_stringv.html
	//
	SetAttributeStringv(string, []string)
	// SetAttributeUint32 wraps g_file_info_set_attribute_uint32
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_uint32.g_file_info_set_attribute_uint32.html
	//
	SetAttributeUint32(string, uint32)
	// SetAttributeUint64 wraps g_file_info_set_attribute_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_uint64.g_file_info_set_attribute_uint64.html
	//
	SetAttributeUint64(string, uint64)
	// SetContentType wraps g_file_info_set_content_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_content_type.g_file_info_set_content_type.html
	//
	SetContentType(string)
	// SetDisplayName wraps g_file_info_set_display_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_display_name.g_file_info_set_display_name.html
	//
	SetDisplayName(string)
	// SetEditName wraps g_file_info_set_edit_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_edit_name.g_file_info_set_edit_name.html
	//
	SetEditName(string)
	// SetFileType wraps g_file_info_set_file_type
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_file_type.g_file_info_set_file_type.html
	//
	SetFileType(FileType)
	// SetIcon wraps g_file_info_set_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_icon.g_file_info_set_icon.html
	//
	SetIcon(Icon)
	// SetIsHidden wraps g_file_info_set_is_hidden
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_is_hidden.g_file_info_set_is_hidden.html
	//
	SetIsHidden(bool)
	// SetIsSymlink wraps g_file_info_set_is_symlink
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_is_symlink.g_file_info_set_is_symlink.html
	//
	SetIsSymlink(bool)
	// SetName wraps g_file_info_set_name
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_name.g_file_info_set_name.html
	//
	SetName(string)
	// SetSize wraps g_file_info_set_size
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_size.g_file_info_set_size.html
	//
	SetSize(int64)
	// SetSortOrder wraps g_file_info_set_sort_order
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_sort_order.g_file_info_set_sort_order.html
	//
	SetSortOrder(int32)
	// SetSymbolicIcon wraps g_file_info_set_symbolic_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_symbolic_icon.g_file_info_set_symbolic_icon.html
	//
	SetSymbolicIcon(Icon)
	// SetSymlinkTarget wraps g_file_info_set_symlink_target
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_set_symlink_target.g_file_info_set_symlink_target.html
	//
	SetSymlinkTarget(string)
	// UnsetAttributeMask wraps g_file_info_unset_attribute_mask
	// 
	// see also https://docs.gtk.org/gio/method.g_file_info_unset_attribute_mask.g_file_info_unset_attribute_mask.html
	//
	UnsetAttributeMask()
}

func unsafeWrapFileInfo(base *gobject.ObjectInstance) *FileInfoInstance {
	return &FileInfoInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileInfo,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInfo(inst)
		},
	)
}

func marshalFileInfoInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileInfoFromGlibNone is used to convert raw GFileInfo pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInfoFromGlibNone(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibNone(c).(FileInfo)
}

// UnsafeFileInfoFromGlibFull is used to convert raw GFileInfo pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInfoFromGlibFull(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibFull(c).(FileInfo)
}

// UnsafeFileInfoFromGlibBorrow is used to convert raw GFileInfo pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileInfoFromGlibBorrow(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileInfo)
}

func (f *FileInfoInstance) upcastToGFileInfo() *FileInfoInstance {
	return f
}

// UnsafeFileInfoToGlibNone is used to convert the instance to it's C value GFileInfo. This is used by the bindings internally.
func UnsafeFileInfoToGlibNone(c FileInfo) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileInfoToGlibFull is used to convert the instance to it's C value GFileInfo, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileInfoToGlibFull(c FileInfo) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFileInfo wraps g_file_info_new
// 
// see also https://docs.gtk.org/gio/func.g_file_info_new.html
//
func NewFileInfo() FileInfo {
	var cret *C.GFileInfo // return, full, converted

	cret = C.g_file_info_new()

	var goret FileInfo

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ClearStatus wraps g_file_info_clear_status
// 
// see also https://docs.gtk.org/gio/method.g_file_info_clear_status.g_file_info_clear_status.html
//
func (info *FileInfoInstance) ClearStatus() {
	var carg0 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	C.g_file_info_clear_status(carg0)
	runtime.KeepAlive(info)
}

// CopyInto wraps g_file_info_copy_into
// 
// see also https://docs.gtk.org/gio/method.g_file_info_copy_into.g_file_info_copy_into.html
//
func (srcInfo *FileInfoInstance) CopyInto(destInfo FileInfo) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(srcInfo))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(destInfo))

	C.g_file_info_copy_into(carg0, carg1)
	runtime.KeepAlive(srcInfo)
	runtime.KeepAlive(destInfo)
}

// Dup wraps g_file_info_dup
// 
// see also https://docs.gtk.org/gio/method.g_file_info_dup.g_file_info_dup.html
//
func (other *FileInfoInstance) Dup() FileInfo {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GFileInfo // return, full, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(other))

	cret = C.g_file_info_dup(carg0)
	runtime.KeepAlive(other)

	var goret FileInfo

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAttributeAsString wraps g_file_info_get_attribute_as_string
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_as_string.g_file_info_get_attribute_as_string.html
//
func (info *FileInfoInstance) GetAttributeAsString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, full, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_as_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetAttributeBoolean wraps g_file_info_get_attribute_boolean
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_boolean.g_file_info_get_attribute_boolean.html
//
func (info *FileInfoInstance) GetAttributeBoolean(attribute string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_boolean(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetAttributeByteString wraps g_file_info_get_attribute_byte_string
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_byte_string.g_file_info_get_attribute_byte_string.html
//
func (info *FileInfoInstance) GetAttributeByteString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_byte_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeFilePath wraps g_file_info_get_attribute_file_path
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_file_path.g_file_info_get_attribute_file_path.html
//
func (info *FileInfoInstance) GetAttributeFilePath(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_file_path(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeInt32 wraps g_file_info_get_attribute_int32
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_int32.g_file_info_get_attribute_int32.html
//
func (info *FileInfoInstance) GetAttributeInt32(attribute string) int32 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_int32(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetAttributeInt64 wraps g_file_info_get_attribute_int64
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_int64.g_file_info_get_attribute_int64.html
//
func (info *FileInfoInstance) GetAttributeInt64(attribute string) int64 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gint64     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_int64(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetAttributeObject wraps g_file_info_get_attribute_object
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_object.g_file_info_get_attribute_object.html
//
func (info *FileInfoInstance) GetAttributeObject(attribute string) gobject.Object {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.GObject   // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_object(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetAttributeStatus wraps g_file_info_get_attribute_status
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_status.g_file_info_get_attribute_status.html
//
func (info *FileInfoInstance) GetAttributeStatus(attribute string) FileAttributeStatus {
	var carg0 *C.GFileInfo           // in, none, converted
	var carg1 *C.char                // in, none, string
	var cret  C.GFileAttributeStatus // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_status(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret FileAttributeStatus

	goret = FileAttributeStatus(cret)

	return goret
}

// GetAttributeString wraps g_file_info_get_attribute_string
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_string.g_file_info_get_attribute_string.html
//
func (info *FileInfoInstance) GetAttributeString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeStringv wraps g_file_info_get_attribute_stringv
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_stringv.g_file_info_get_attribute_stringv.html
//
func (info *FileInfoInstance) GetAttributeStringv(attribute string) []string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  **C.char     // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_stringv(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetAttributeType wraps g_file_info_get_attribute_type
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_type.g_file_info_get_attribute_type.html
//
func (info *FileInfoInstance) GetAttributeType(attribute string) FileAttributeType {
	var carg0 *C.GFileInfo         // in, none, converted
	var carg1 *C.char              // in, none, string
	var cret  C.GFileAttributeType // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret FileAttributeType

	goret = FileAttributeType(cret)

	return goret
}

// GetAttributeUint32 wraps g_file_info_get_attribute_uint32
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_uint32.g_file_info_get_attribute_uint32.html
//
func (info *FileInfoInstance) GetAttributeUint32(attribute string) uint32 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.guint32    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_uint32(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// GetAttributeUint64 wraps g_file_info_get_attribute_uint64
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_attribute_uint64.g_file_info_get_attribute_uint64.html
//
func (info *FileInfoInstance) GetAttributeUint64(attribute string) uint64 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.guint64    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_uint64(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret uint64

	goret = uint64(cret)

	return goret
}

// GetContentType wraps g_file_info_get_content_type
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_content_type.g_file_info_get_content_type.html
//
func (info *FileInfoInstance) GetContentType() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_content_type(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDisplayName wraps g_file_info_get_display_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_display_name.g_file_info_get_display_name.html
//
func (info *FileInfoInstance) GetDisplayName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_display_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetEditName wraps g_file_info_get_edit_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_edit_name.g_file_info_get_edit_name.html
//
func (info *FileInfoInstance) GetEditName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_edit_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetEtag wraps g_file_info_get_etag
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_etag.g_file_info_get_etag.html
//
func (info *FileInfoInstance) GetEtag() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_etag(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFileType wraps g_file_info_get_file_type
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_file_type.g_file_info_get_file_type.html
//
func (info *FileInfoInstance) GetFileType() FileType {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.GFileType  // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_file_type(carg0)
	runtime.KeepAlive(info)

	var goret FileType

	goret = FileType(cret)

	return goret
}

// GetIcon wraps g_file_info_get_icon
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_icon.g_file_info_get_icon.html
//
func (info *FileInfoInstance) GetIcon() Icon {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GIcon     // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_icon(carg0)
	runtime.KeepAlive(info)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetIsBackup wraps g_file_info_get_is_backup
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_is_backup.g_file_info_get_is_backup.html
//
func (info *FileInfoInstance) GetIsBackup() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_backup(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsHidden wraps g_file_info_get_is_hidden
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_is_hidden.g_file_info_get_is_hidden.html
//
func (info *FileInfoInstance) GetIsHidden() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_hidden(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsSymlink wraps g_file_info_get_is_symlink
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_is_symlink.g_file_info_get_is_symlink.html
//
func (info *FileInfoInstance) GetIsSymlink() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_symlink(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetName wraps g_file_info_get_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_name.g_file_info_get_name.html
//
func (info *FileInfoInstance) GetName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSize wraps g_file_info_get_size
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_size.g_file_info_get_size.html
//
func (info *FileInfoInstance) GetSize() int64 {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.goffset    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_size(carg0)
	runtime.KeepAlive(info)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetSortOrder wraps g_file_info_get_sort_order
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_sort_order.g_file_info_get_sort_order.html
//
func (info *FileInfoInstance) GetSortOrder() int32 {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_sort_order(carg0)
	runtime.KeepAlive(info)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSymbolicIcon wraps g_file_info_get_symbolic_icon
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_symbolic_icon.g_file_info_get_symbolic_icon.html
//
func (info *FileInfoInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GIcon     // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_symbolic_icon(carg0)
	runtime.KeepAlive(info)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetSymlinkTarget wraps g_file_info_get_symlink_target
// 
// see also https://docs.gtk.org/gio/method.g_file_info_get_symlink_target.g_file_info_get_symlink_target.html
//
func (info *FileInfoInstance) GetSymlinkTarget() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_symlink_target(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HasAttribute wraps g_file_info_has_attribute
// 
// see also https://docs.gtk.org/gio/method.g_file_info_has_attribute.g_file_info_has_attribute.html
//
func (info *FileInfoInstance) HasAttribute(attribute string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_has_attribute(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasNamespace wraps g_file_info_has_namespace
// 
// see also https://docs.gtk.org/gio/method.g_file_info_has_namespace.g_file_info_has_namespace.html
//
func (info *FileInfoInstance) HasNamespace(nameSpace string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_has_namespace(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListAttributes wraps g_file_info_list_attributes
// 
// see also https://docs.gtk.org/gio/method.g_file_info_list_attributes.g_file_info_list_attributes.html
//
func (info *FileInfoInstance) ListAttributes(nameSpace string) []string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string, nullable-string
	var cret  **C.char     // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if nameSpace != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_info_list_attributes(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// RemoveAttribute wraps g_file_info_remove_attribute
// 
// see also https://docs.gtk.org/gio/method.g_file_info_remove_attribute.g_file_info_remove_attribute.html
//
func (info *FileInfoInstance) RemoveAttribute(attribute string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_remove_attribute(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
}

// SetAttributeBoolean wraps g_file_info_set_attribute_boolean
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_boolean.g_file_info_set_attribute_boolean.html
//
func (info *FileInfoInstance) SetAttributeBoolean(attribute string, attrValue bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	if attrValue {
		carg2 = C.TRUE
	}

	C.g_file_info_set_attribute_boolean(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeByteString wraps g_file_info_set_attribute_byte_string
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_byte_string.g_file_info_set_attribute_byte_string.html
//
func (info *FileInfoInstance) SetAttributeByteString(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_byte_string(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeFilePath wraps g_file_info_set_attribute_file_path
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_file_path.g_file_info_set_attribute_file_path.html
//
func (info *FileInfoInstance) SetAttributeFilePath(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_file_path(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt32 wraps g_file_info_set_attribute_int32
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_int32.g_file_info_set_attribute_int32.html
//
func (info *FileInfoInstance) SetAttributeInt32(attribute string, attrValue int32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gint32     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt64 wraps g_file_info_set_attribute_int64
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_int64.g_file_info_set_attribute_int64.html
//
func (info *FileInfoInstance) SetAttributeInt64(attribute string, attrValue int64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gint64     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeMask wraps g_file_info_set_attribute_mask
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_mask.g_file_info_set_attribute_mask.html
//
func (info *FileInfoInstance) SetAttributeMask(mask *FileAttributeMatcher) {
	var carg0 *C.GFileInfo             // in, none, converted
	var carg1 *C.GFileAttributeMatcher // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(mask))

	C.g_file_info_set_attribute_mask(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mask)
}

// SetAttributeObject wraps g_file_info_set_attribute_object
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_object.g_file_info_set_attribute_object.html
//
func (info *FileInfoInstance) SetAttributeObject(attribute string, attrValue gobject.Object) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.GObject   // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(attrValue))

	C.g_file_info_set_attribute_object(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStatus wraps g_file_info_set_attribute_status
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_status.g_file_info_set_attribute_status.html
//
func (info *FileInfoInstance) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var carg0 *C.GFileInfo           // in, none, converted
	var carg1 *C.char                // in, none, string
	var carg2 C.GFileAttributeStatus // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileAttributeStatus(status)

	cret = C.g_file_info_set_attribute_status(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(status)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetAttributeString wraps g_file_info_set_attribute_string
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_string.g_file_info_set_attribute_string.html
//
func (info *FileInfoInstance) SetAttributeString(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_string(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStringv wraps g_file_info_set_attribute_stringv
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_stringv.g_file_info_set_attribute_stringv.html
//
func (info *FileInfoInstance) SetAttributeStringv(attribute string, attrValue []string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 **C.char     // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	_ = attrValue
	_ = carg2
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	C.g_file_info_set_attribute_stringv(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint32 wraps g_file_info_set_attribute_uint32
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_uint32.g_file_info_set_attribute_uint32.html
//
func (info *FileInfoInstance) SetAttributeUint32(attribute string, attrValue uint32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.guint32    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint64 wraps g_file_info_set_attribute_uint64
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_attribute_uint64.g_file_info_set_attribute_uint64.html
//
func (info *FileInfoInstance) SetAttributeUint64(attribute string, attrValue uint64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.guint64    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetContentType wraps g_file_info_set_content_type
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_content_type.g_file_info_set_content_type.html
//
func (info *FileInfoInstance) SetContentType(contentType string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_content_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(contentType)
}

// SetDisplayName wraps g_file_info_set_display_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_display_name.g_file_info_set_display_name.html
//
func (info *FileInfoInstance) SetDisplayName(displayName string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_display_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(displayName)
}

// SetEditName wraps g_file_info_set_edit_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_edit_name.g_file_info_set_edit_name.html
//
func (info *FileInfoInstance) SetEditName(editName string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(editName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_edit_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(editName)
}

// SetFileType wraps g_file_info_set_file_type
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_file_type.g_file_info_set_file_type.html
//
func (info *FileInfoInstance) SetFileType(typ FileType) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.GFileType  // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.GFileType(typ)

	C.g_file_info_set_file_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(typ)
}

// SetIcon wraps g_file_info_set_icon
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_icon.g_file_info_set_icon.html
//
func (info *FileInfoInstance) SetIcon(icon Icon) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_file_info_set_icon(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetIsHidden wraps g_file_info_set_is_hidden
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_is_hidden.g_file_info_set_is_hidden.html
//
func (info *FileInfoInstance) SetIsHidden(isHidden bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if isHidden {
		carg1 = C.TRUE
	}

	C.g_file_info_set_is_hidden(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isHidden)
}

// SetIsSymlink wraps g_file_info_set_is_symlink
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_is_symlink.g_file_info_set_is_symlink.html
//
func (info *FileInfoInstance) SetIsSymlink(isSymlink bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if isSymlink {
		carg1 = C.TRUE
	}

	C.g_file_info_set_is_symlink(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isSymlink)
}

// SetName wraps g_file_info_set_name
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_name.g_file_info_set_name.html
//
func (info *FileInfoInstance) SetName(name string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
}

// SetSize wraps g_file_info_set_size
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_size.g_file_info_set_size.html
//
func (info *FileInfoInstance) SetSize(size int64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.goffset    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.goffset(size)

	C.g_file_info_set_size(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(size)
}

// SetSortOrder wraps g_file_info_set_sort_order
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_sort_order.g_file_info_set_sort_order.html
//
func (info *FileInfoInstance) SetSortOrder(sortOrder int32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gint32     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(sortOrder)
}

// SetSymbolicIcon wraps g_file_info_set_symbolic_icon
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_symbolic_icon.g_file_info_set_symbolic_icon.html
//
func (info *FileInfoInstance) SetSymbolicIcon(icon Icon) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_file_info_set_symbolic_icon(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetSymlinkTarget wraps g_file_info_set_symlink_target
// 
// see also https://docs.gtk.org/gio/method.g_file_info_set_symlink_target.g_file_info_set_symlink_target.html
//
func (info *FileInfoInstance) SetSymlinkTarget(symlinkTarget string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkTarget)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_symlink_target(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(symlinkTarget)
}

// UnsetAttributeMask wraps g_file_info_unset_attribute_mask
// 
// see also https://docs.gtk.org/gio/method.g_file_info_unset_attribute_mask.g_file_info_unset_attribute_mask.html
//
func (info *FileInfoInstance) UnsetAttributeMask() {
	var carg0 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	C.g_file_info_unset_attribute_mask(carg0)
	runtime.KeepAlive(info)
}

// FileMonitorInstance is the instance type used by all types extending GFileMonitor. It is used internally by the bindings. Users should use the interface [FileMonitor] instead.
type FileMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileMonitor = (*FileMonitorInstance)(nil)

// FileMonitor wraps GFileMonitor
// 
// see also https://docs.gtk.org/gio/class.FileMonitor.html
//
type FileMonitor interface {
	gobject.Object
	upcastToGFileMonitor() *FileMonitorInstance

	// Cancel wraps g_file_monitor_cancel
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_cancel.g_file_monitor_cancel.html
	//
	Cancel() bool
	// EmitEvent wraps g_file_monitor_emit_event
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_emit_event.g_file_monitor_emit_event.html
	//
	EmitEvent(File, File, FileMonitorEvent)
	// IsCancelled wraps g_file_monitor_is_cancelled
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_is_cancelled.g_file_monitor_is_cancelled.html
	//
	IsCancelled() bool
	// SetRateLimit wraps g_file_monitor_set_rate_limit
	// 
	// see also https://docs.gtk.org/gio/method.g_file_monitor_set_rate_limit.g_file_monitor_set_rate_limit.html
	//
	SetRateLimit(int32)
	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.FileMonitor.changed.html
	//
	ConnectChanged(func(FileMonitor, File, File, FileMonitorEvent)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentCancel calls the default implementations of the `GFileMonitor.cancel` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileMonitor.cancel.html
	ParentCancel() bool
	// ParentChanged calls the default implementations of the `GFileMonitor.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileMonitor.changed.html
	ParentChanged(file File, otherFile File, eventType FileMonitorEvent)
}

func unsafeWrapFileMonitor(base *gobject.ObjectInstance) *FileMonitorInstance {
	return &FileMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileMonitor(inst)
		},
	)
}

func marshalFileMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileMonitorFromGlibNone is used to convert raw GFileMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibNone(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(FileMonitor)
}

// UnsafeFileMonitorFromGlibFull is used to convert raw GFileMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibFull(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(FileMonitor)
}

// UnsafeFileMonitorFromGlibBorrow is used to convert raw GFileMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibBorrow(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileMonitor)
}

func (f *FileMonitorInstance) upcastToGFileMonitor() *FileMonitorInstance {
	return f
}

// UnsafeFileMonitorToGlibNone is used to convert the instance to it's C value GFileMonitor. This is used by the bindings internally.
func UnsafeFileMonitorToGlibNone(c FileMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileMonitorToGlibFull is used to convert the instance to it's C value GFileMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileMonitorToGlibFull(c FileMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Cancel wraps g_file_monitor_cancel
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_cancel.g_file_monitor_cancel.html
//
func (monitor *FileMonitorInstance) Cancel() bool {
	var carg0 *C.GFileMonitor // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C.g_file_monitor_cancel(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// EmitEvent wraps g_file_monitor_emit_event
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_emit_event.g_file_monitor_emit_event.html
//
func (monitor *FileMonitorInstance) EmitEvent(child File, otherFile File, eventType FileMonitorEvent) {
	var carg0 *C.GFileMonitor     // in, none, converted
	var carg1 *C.GFile            // in, none, converted
	var carg2 *C.GFile            // in, none, converted, nullable
	var carg3 C.GFileMonitorEvent // in, none, casted

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(child))
	if otherFile != nil {
		carg2 = (*C.GFile)(UnsafeFileToGlibNone(otherFile))
	}
	carg3 = C.GFileMonitorEvent(eventType)

	C.g_file_monitor_emit_event(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(child)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// IsCancelled wraps g_file_monitor_is_cancelled
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_is_cancelled.g_file_monitor_is_cancelled.html
//
func (monitor *FileMonitorInstance) IsCancelled() bool {
	var carg0 *C.GFileMonitor // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C.g_file_monitor_is_cancelled(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetRateLimit wraps g_file_monitor_set_rate_limit
// 
// see also https://docs.gtk.org/gio/method.g_file_monitor_set_rate_limit.g_file_monitor_set_rate_limit.html
//
func (monitor *FileMonitorInstance) SetRateLimit(limitMsecs int32) {
	var carg0 *C.GFileMonitor // in, none, converted
	var carg1 C.gint          // in, none, casted

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = C.gint(limitMsecs)

	C.g_file_monitor_set_rate_limit(carg0, carg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(limitMsecs)
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.FileMonitor.changed.html
//
func (o *FileMonitorInstance) ConnectChanged(fn func(FileMonitor, File, File, FileMonitorEvent)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// FileMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileMonitorOverrides[Instance FileMonitor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Cancel allows you to override the implementation of the virtual method cancel.
	// 
	// see also https://docs.gtk.org/gio/method.FileMonitor.cancel.html
	Cancel func(Instance) bool
	// // Changed allows you to override the implementation of the virtual method changed.
	// 
	// see also https://docs.gtk.org/gio/method.FileMonitor.changed.html
	Changed func(Instance, File, File, FileMonitorEvent)
}

// UnsafeApplyFileMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileMonitorOverrides[Instance FileMonitor](gclass unsafe.Pointer, overrides FileMonitorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFileMonitorClass)(gclass)

	if overrides.Cancel != nil {
		pclass.cancel = (*[0]byte)(C._goglib_gio2_FileMonitor_cancel)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileMonitor_cancel",
			func(carg0 *C.GFileMonitor) (cret C.gboolean) {
				var monitor Instance // go GFileMonitor subclass
				var goret   bool     // return

				monitor = UnsafeFileMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Cancel(monitor)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_FileMonitor_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileMonitor_changed",
			func(carg0 *C.GFileMonitor, carg1 *C.GFile, carg2 *C.GFile, carg3 C.GFileMonitorEvent) {
				var monitor   Instance         // go GFileMonitor subclass
				var file      File             // in, none, converted
				var otherFile File             // in, none, converted
				var eventType FileMonitorEvent // in, none, casted

				monitor = UnsafeFileMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				file = UnsafeFileFromGlibNone(unsafe.Pointer(carg1))
				otherFile = UnsafeFileFromGlibNone(unsafe.Pointer(carg2))
				eventType = FileMonitorEvent(carg3)

				overrides.Changed(monitor, file, otherFile, eventType)
			},
		)
	}
}

// ParentCancel calls the default implementations of the `GFileMonitor.cancel` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileMonitor.cancel.html
func (monitor *FileMonitorInstance) ParentCancel() bool {
	var carg0 *C.GFileMonitor
	var cret  C.gboolean // return

	parentclass := (*C.GFileMonitorClass)(classdata.PeekParentClass(UnsafeFileMonitorToGlibNone(monitor)))

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C._goglib_gio2_FileMonitor_virtual_cancel(unsafe.Pointer(parentclass.cancel), carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentChanged calls the default implementations of the `GFileMonitor.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileMonitor.changed.html
func (monitor *FileMonitorInstance) ParentChanged(file File, otherFile File, eventType FileMonitorEvent) {
	var carg0 *C.GFileMonitor
	var carg1 *C.GFile            // in, none, converted
	var carg2 *C.GFile            // in, none, converted
	var carg3 C.GFileMonitorEvent // in, none, converted

	parentclass := (*C.GFileMonitorClass)(classdata.PeekParentClass(UnsafeFileMonitorToGlibNone(monitor)))

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg2 = (*C.GFile)(UnsafeFileToGlibNone(otherFile))
	carg3 = C.GFileMonitorEvent(eventType)

	C._goglib_gio2_FileMonitor_virtual_changed(unsafe.Pointer(parentclass.changed), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(file)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// RegisterFileMonitorSubClass is used to register a go subclass of GFileMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileMonitorSubClass[InstanceT FileMonitor](
		name string,
		classInit func(class *FileMonitorClass),
		constructor func() InstanceT,
		overrides FileMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileMonitor,
		UnsafeFileMonitorClassFromGlibBorrow,
		UnsafeApplyFileMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileMonitor(obj)
		},
		interfaceInits...,
	)
}

// FilenameCompleterInstance is the instance type used by all types extending GFilenameCompleter. It is used internally by the bindings. Users should use the interface [FilenameCompleter] instead.
type FilenameCompleterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FilenameCompleter = (*FilenameCompleterInstance)(nil)

// FilenameCompleter wraps GFilenameCompleter
// 
// see also https://docs.gtk.org/gio/class.FilenameCompleter.html
//
type FilenameCompleter interface {
	gobject.Object
	upcastToGFilenameCompleter() *FilenameCompleterInstance

	// GetCompletionSuffix wraps g_filename_completer_get_completion_suffix
	// 
	// see also https://docs.gtk.org/gio/method.g_filename_completer_get_completion_suffix.g_filename_completer_get_completion_suffix.html
	//
	GetCompletionSuffix(string) string
	// GetCompletions wraps g_filename_completer_get_completions
	// 
	// see also https://docs.gtk.org/gio/method.g_filename_completer_get_completions.g_filename_completer_get_completions.html
	//
	GetCompletions(string) []string
	// SetDirsOnly wraps g_filename_completer_set_dirs_only
	// 
	// see also https://docs.gtk.org/gio/method.g_filename_completer_set_dirs_only.g_filename_completer_set_dirs_only.html
	//
	SetDirsOnly(bool)
	// ConnectGotCompletionData connects the provided callback to the "got-completion-data" signal
	// 
	// see also https://docs.gtk.org/gio/signal.FilenameCompleter.got-completion-data.html
	//
	ConnectGotCompletionData(func(FilenameCompleter)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentGotCompletionData calls the default implementations of the `GFilenameCompleter.got_completion_data` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FilenameCompleter.got_completion_data.html
	ParentGotCompletionData()
}

func unsafeWrapFilenameCompleter(base *gobject.ObjectInstance) *FilenameCompleterInstance {
	return &FilenameCompleterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilenameCompleter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilenameCompleter(inst)
		},
	)
}

func marshalFilenameCompleterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilenameCompleterFromGlibNone is used to convert raw GFilenameCompleter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibNone(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibNone(c).(FilenameCompleter)
}

// UnsafeFilenameCompleterFromGlibFull is used to convert raw GFilenameCompleter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibFull(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibFull(c).(FilenameCompleter)
}

// UnsafeFilenameCompleterFromGlibBorrow is used to convert raw GFilenameCompleter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibBorrow(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilenameCompleter)
}

func (f *FilenameCompleterInstance) upcastToGFilenameCompleter() *FilenameCompleterInstance {
	return f
}

// UnsafeFilenameCompleterToGlibNone is used to convert the instance to it's C value GFilenameCompleter. This is used by the bindings internally.
func UnsafeFilenameCompleterToGlibNone(c FilenameCompleter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilenameCompleterToGlibFull is used to convert the instance to it's C value GFilenameCompleter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterToGlibFull(c FilenameCompleter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFilenameCompleter wraps g_filename_completer_new
// 
// see also https://docs.gtk.org/gio/func.g_filename_completer_new.html
//
func NewFilenameCompleter() FilenameCompleter {
	var cret *C.GFilenameCompleter // return, full, converted

	cret = C.g_filename_completer_new()

	var goret FilenameCompleter

	goret = UnsafeFilenameCompleterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetCompletionSuffix wraps g_filename_completer_get_completion_suffix
// 
// see also https://docs.gtk.org/gio/method.g_filename_completer_get_completion_suffix.g_filename_completer_get_completion_suffix.html
//
func (completer *FilenameCompleterInstance) GetCompletionSuffix(initialText string) string {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 *C.char               // in, none, string
	var cret  *C.char               // return, full, string, nullable-string

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_completer_get_completion_suffix(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetCompletions wraps g_filename_completer_get_completions
// 
// see also https://docs.gtk.org/gio/method.g_filename_completer_get_completions.g_filename_completer_get_completions.html
//
func (completer *FilenameCompleterInstance) GetCompletions(initialText string) []string {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 *C.char               // in, none, string
	var cret  **C.char              // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_completer_get_completions(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// SetDirsOnly wraps g_filename_completer_set_dirs_only
// 
// see also https://docs.gtk.org/gio/method.g_filename_completer_set_dirs_only.g_filename_completer_set_dirs_only.html
//
func (completer *FilenameCompleterInstance) SetDirsOnly(dirsOnly bool) {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	if dirsOnly {
		carg1 = C.TRUE
	}

	C.g_filename_completer_set_dirs_only(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(dirsOnly)
}

// ConnectGotCompletionData connects the provided callback to the "got-completion-data" signal
// 
// see also https://docs.gtk.org/gio/signal.FilenameCompleter.got-completion-data.html
//
func (o *FilenameCompleterInstance) ConnectGotCompletionData(fn func(FilenameCompleter)) gobject.SignalHandle {
	return o.Connect("got-completion-data", fn)
}

// FilenameCompleterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilenameCompleterOverrides[Instance FilenameCompleter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GotCompletionData allows you to override the implementation of the virtual method got_completion_data.
	// 
	// see also https://docs.gtk.org/gio/method.FilenameCompleter.got_completion_data.html
	GotCompletionData func(Instance)
}

// UnsafeApplyFilenameCompleterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilenameCompleterOverrides[Instance FilenameCompleter](gclass unsafe.Pointer, overrides FilenameCompleterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFilenameCompleterClass)(gclass)

	if overrides.GotCompletionData != nil {
		pclass.got_completion_data = (*[0]byte)(C._goglib_gio2_FilenameCompleter_got_completion_data)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FilenameCompleter_got_completion_data",
			func(carg0 *C.GFilenameCompleter) {
				var filenameCompleter Instance // go GFilenameCompleter subclass

				filenameCompleter = UnsafeFilenameCompleterFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.GotCompletionData(filenameCompleter)
			},
		)
	}
}

// ParentGotCompletionData calls the default implementations of the `GFilenameCompleter.got_completion_data` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FilenameCompleter.got_completion_data.html
func (filenameCompleter *FilenameCompleterInstance) ParentGotCompletionData() {
	var carg0 *C.GFilenameCompleter

	parentclass := (*C.GFilenameCompleterClass)(classdata.PeekParentClass(UnsafeFilenameCompleterToGlibNone(filenameCompleter)))

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(filenameCompleter))

	C._goglib_gio2_FilenameCompleter_virtual_got_completion_data(unsafe.Pointer(parentclass.got_completion_data), carg0)
	runtime.KeepAlive(filenameCompleter)
}

// RegisterFilenameCompleterSubClass is used to register a go subclass of GFilenameCompleter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilenameCompleterSubClass[InstanceT FilenameCompleter](
		name string,
		classInit func(class *FilenameCompleterClass),
		constructor func() InstanceT,
		overrides FilenameCompleterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilenameCompleter,
		UnsafeFilenameCompleterClassFromGlibBorrow,
		UnsafeApplyFilenameCompleterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilenameCompleter(obj)
		},
		interfaceInits...,
	)
}

// IOStreamInstance is the instance type used by all types extending GIOStream. It is used internally by the bindings. Users should use the interface [IOStream] instead.
type IOStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ IOStream = (*IOStreamInstance)(nil)

// IOStream wraps GIOStream
// 
// see also https://docs.gtk.org/gio/class.IOStream.html
//
type IOStream interface {
	gobject.Object
	upcastToGIOStream() *IOStreamInstance

	// ClearPending wraps g_io_stream_clear_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_clear_pending.g_io_stream_clear_pending.html
	//
	ClearPending()
	// Close wraps g_io_stream_close
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_close.g_io_stream_close.html
	//
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_io_stream_close_async
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_close_async.g_io_stream_close_async.html
	//
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_io_stream_close_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_close_finish.g_io_stream_close_finish.html
	//
	CloseFinish(AsyncResult) (bool, error)
	// GetInputStream wraps g_io_stream_get_input_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_get_input_stream.g_io_stream_get_input_stream.html
	//
	GetInputStream() InputStream
	// GetOutputStream wraps g_io_stream_get_output_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_get_output_stream.g_io_stream_get_output_stream.html
	//
	GetOutputStream() OutputStream
	// HasPending wraps g_io_stream_has_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_has_pending.g_io_stream_has_pending.html
	//
	HasPending() bool
	// IsClosed wraps g_io_stream_is_closed
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_is_closed.g_io_stream_is_closed.html
	//
	IsClosed() bool
	// SetPending wraps g_io_stream_set_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_set_pending.g_io_stream_set_pending.html
	//
	SetPending() (bool, error)
	// SpliceAsync wraps g_io_stream_splice_async
	// 
	// see also https://docs.gtk.org/gio/method.g_io_stream_splice_async.g_io_stream_splice_async.html
	//
	SpliceAsync(IOStream, IOStreamSpliceFlags, int32, Cancellable, AsyncReadyCallback)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GIOStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.close_finish.html
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GIOStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.close_fn.html
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentGetInputStream calls the default implementations of the `GIOStream.get_input_stream` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.get_input_stream.html
	ParentGetInputStream() InputStream
	// ParentGetOutputStream calls the default implementations of the `GIOStream.get_output_stream` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.get_output_stream.html
	ParentGetOutputStream() OutputStream
}

func unsafeWrapIOStream(base *gobject.ObjectInstance) *IOStreamInstance {
	return &IOStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapIOStream(inst)
		},
	)
}

func marshalIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeIOStreamFromGlibNone is used to convert raw GIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeIOStreamFromGlibNone(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(IOStream)
}

// UnsafeIOStreamFromGlibFull is used to convert raw GIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeIOStreamFromGlibFull(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(IOStream)
}

// UnsafeIOStreamFromGlibBorrow is used to convert raw GIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeIOStreamFromGlibBorrow(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(IOStream)
}

func (i *IOStreamInstance) upcastToGIOStream() *IOStreamInstance {
	return i
}

// UnsafeIOStreamToGlibNone is used to convert the instance to it's C value GIOStream. This is used by the bindings internally.
func UnsafeIOStreamToGlibNone(c IOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeIOStreamToGlibFull is used to convert the instance to it's C value GIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeIOStreamToGlibFull(c IOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// IOStreamSpliceFinish wraps g_io_stream_splice_finish
// 
// see also https://docs.gtk.org/gio/func.g_io_stream_splice_finish.html
//
func IOStreamSpliceFinish(result AsyncResult) (bool, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_io_stream_splice_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ClearPending wraps g_io_stream_clear_pending
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_clear_pending.g_io_stream_clear_pending.html
//
func (stream *IOStreamInstance) ClearPending() {
	var carg0 *C.GIOStream // in, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	C.g_io_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_io_stream_close
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_close.g_io_stream_close.html
//
func (stream *IOStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GIOStream    // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_io_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_io_stream_close_async
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_close_async.g_io_stream_close_async.html
//
func (stream *IOStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GIOStream          // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_io_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_io_stream_close_finish
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_close_finish.g_io_stream_close_finish.html
//
func (stream *IOStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GIOStream    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_io_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetInputStream wraps g_io_stream_get_input_stream
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_get_input_stream.g_io_stream_get_input_stream.html
//
func (stream *IOStreamInstance) GetInputStream() InputStream {
	var carg0 *C.GIOStream    // in, none, converted
	var cret  *C.GInputStream // return, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_get_input_stream(carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetOutputStream wraps g_io_stream_get_output_stream
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_get_output_stream.g_io_stream_get_output_stream.html
//
func (stream *IOStreamInstance) GetOutputStream() OutputStream {
	var carg0 *C.GIOStream     // in, none, converted
	var cret  *C.GOutputStream // return, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_get_output_stream(carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// HasPending wraps g_io_stream_has_pending
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_has_pending.g_io_stream_has_pending.html
//
func (stream *IOStreamInstance) HasPending() bool {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_io_stream_is_closed
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_is_closed.g_io_stream_is_closed.html
//
func (stream *IOStreamInstance) IsClosed() bool {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetPending wraps g_io_stream_set_pending
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_set_pending.g_io_stream_set_pending.html
//
func (stream *IOStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return
	var _cerr *C.GError    // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpliceAsync wraps g_io_stream_splice_async
// 
// see also https://docs.gtk.org/gio/method.g_io_stream_splice_async.g_io_stream_splice_async.html
//
func (stream1 *IOStreamInstance) SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GIOStream           // in, none, converted
	var carg1 *C.GIOStream           // in, none, converted
	var carg2 C.GIOStreamSpliceFlags // in, none, casted
	var carg3 C.int                  // in, none, casted
	var carg4 *C.GCancellable        // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback  // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer             // implicit

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream1))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream2))
	carg2 = C.GIOStreamSpliceFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_io_stream_splice_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream1)
	runtime.KeepAlive(stream2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// IOStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type IOStreamOverrides[Instance IOStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.close_finish.html
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.close_fn.html
	CloseFn func(Instance, Cancellable) (bool, error)
	// // GetInputStream allows you to override the implementation of the virtual method get_input_stream.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.get_input_stream.html
	GetInputStream func(Instance) InputStream
	// // GetOutputStream allows you to override the implementation of the virtual method get_output_stream.
	// 
	// see also https://docs.gtk.org/gio/method.IOStream.get_output_stream.html
	GetOutputStream func(Instance) OutputStream
}

// UnsafeApplyIOStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyIOStreamOverrides[Instance IOStream](gclass unsafe.Pointer, overrides IOStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GIOStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_IOStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_close_finish",
			func(carg0 *C.GIOStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GIOStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_IOStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_close_fn",
			func(carg0 *C.GIOStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GIOStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.GetInputStream != nil {
		pclass.get_input_stream = (*[0]byte)(C._goglib_gio2_IOStream_get_input_stream)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_get_input_stream",
			func(carg0 *C.GIOStream) (cret *C.GInputStream) {
				var stream Instance    // go GIOStream subclass
				var goret  InputStream // return, none, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetInputStream(stream)

				cret = (*C.GInputStream)(UnsafeInputStreamToGlibNone(goret))

				return cret
			},
		)
	}

	if overrides.GetOutputStream != nil {
		pclass.get_output_stream = (*[0]byte)(C._goglib_gio2_IOStream_get_output_stream)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_get_output_stream",
			func(carg0 *C.GIOStream) (cret *C.GOutputStream) {
				var stream Instance     // go GIOStream subclass
				var goret  OutputStream // return, none, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetOutputStream(stream)

				cret = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(goret))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GIOStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.IOStream.close_finish.html
func (stream *IOStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GIOStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_IOStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GIOStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.IOStream.close_fn.html
func (stream *IOStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GIOStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_IOStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentGetInputStream calls the default implementations of the `GIOStream.get_input_stream` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.IOStream.get_input_stream.html
func (stream *IOStreamInstance) ParentGetInputStream() InputStream {
	var carg0 *C.GIOStream
	var cret  *C.GInputStream // return, none, converted

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_IOStream_virtual_get_input_stream(unsafe.Pointer(parentclass.get_input_stream), carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ParentGetOutputStream calls the default implementations of the `GIOStream.get_output_stream` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.IOStream.get_output_stream.html
func (stream *IOStreamInstance) ParentGetOutputStream() OutputStream {
	var carg0 *C.GIOStream
	var cret  *C.GOutputStream // return, none, converted

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_IOStream_virtual_get_output_stream(unsafe.Pointer(parentclass.get_output_stream), carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// RegisterIOStreamSubClass is used to register a go subclass of GIOStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterIOStreamSubClass[InstanceT IOStream](
		name string,
		classInit func(class *IOStreamClass),
		constructor func() InstanceT,
		overrides IOStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeIOStream,
		UnsafeIOStreamClassFromGlibBorrow,
		UnsafeApplyIOStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapIOStream(obj)
		},
		interfaceInits...,
	)
}

// InetAddressInstance is the instance type used by all types extending GInetAddress. It is used internally by the bindings. Users should use the interface [InetAddress] instead.
type InetAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InetAddress = (*InetAddressInstance)(nil)

// InetAddress wraps GInetAddress
// 
// see also https://docs.gtk.org/gio/class.InetAddress.html
//
type InetAddress interface {
	gobject.Object
	upcastToGInetAddress() *InetAddressInstance

	// Equal wraps g_inet_address_equal
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_equal.g_inet_address_equal.html
	//
	Equal(InetAddress) bool
	// GetFamily wraps g_inet_address_get_family
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_family.g_inet_address_get_family.html
	//
	GetFamily() SocketFamily
	// GetIsAny wraps g_inet_address_get_is_any
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_any.g_inet_address_get_is_any.html
	//
	GetIsAny() bool
	// GetIsLinkLocal wraps g_inet_address_get_is_link_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_link_local.g_inet_address_get_is_link_local.html
	//
	GetIsLinkLocal() bool
	// GetIsLoopback wraps g_inet_address_get_is_loopback
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_loopback.g_inet_address_get_is_loopback.html
	//
	GetIsLoopback() bool
	// GetIsMcGlobal wraps g_inet_address_get_is_mc_global
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_global.g_inet_address_get_is_mc_global.html
	//
	GetIsMcGlobal() bool
	// GetIsMcLinkLocal wraps g_inet_address_get_is_mc_link_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_link_local.g_inet_address_get_is_mc_link_local.html
	//
	GetIsMcLinkLocal() bool
	// GetIsMcNodeLocal wraps g_inet_address_get_is_mc_node_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_node_local.g_inet_address_get_is_mc_node_local.html
	//
	GetIsMcNodeLocal() bool
	// GetIsMcOrgLocal wraps g_inet_address_get_is_mc_org_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_org_local.g_inet_address_get_is_mc_org_local.html
	//
	GetIsMcOrgLocal() bool
	// GetIsMcSiteLocal wraps g_inet_address_get_is_mc_site_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_site_local.g_inet_address_get_is_mc_site_local.html
	//
	GetIsMcSiteLocal() bool
	// GetIsMulticast wraps g_inet_address_get_is_multicast
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_multicast.g_inet_address_get_is_multicast.html
	//
	GetIsMulticast() bool
	// GetIsSiteLocal wraps g_inet_address_get_is_site_local
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_site_local.g_inet_address_get_is_site_local.html
	//
	GetIsSiteLocal() bool
	// GetNativeSize wraps g_inet_address_get_native_size
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_get_native_size.g_inet_address_get_native_size.html
	//
	GetNativeSize() uint
	// String wraps g_inet_address_to_string
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_to_string.g_inet_address_to_string.html
	//
	String() string

	// chain up virtual methods:

	// ParentToString calls the default implementations of the `GInetAddress.to_string` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InetAddress.to_string.html
	ParentToString() string
}

func unsafeWrapInetAddress(base *gobject.ObjectInstance) *InetAddressInstance {
	return &InetAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddress(inst)
		},
	)
}

func marshalInetAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetAddressFromGlibNone is used to convert raw GInetAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressFromGlibNone(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(InetAddress)
}

// UnsafeInetAddressFromGlibFull is used to convert raw GInetAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressFromGlibFull(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(InetAddress)
}

// UnsafeInetAddressFromGlibBorrow is used to convert raw GInetAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetAddressFromGlibBorrow(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetAddress)
}

func (i *InetAddressInstance) upcastToGInetAddress() *InetAddressInstance {
	return i
}

// UnsafeInetAddressToGlibNone is used to convert the instance to it's C value GInetAddress. This is used by the bindings internally.
func UnsafeInetAddressToGlibNone(c InetAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetAddressToGlibFull is used to convert the instance to it's C value GInetAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetAddressToGlibFull(c InetAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetAddressAny wraps g_inet_address_new_any
// 
// see also https://docs.gtk.org/gio/func.g_inet_address_new_any.html
//
func NewInetAddressAny(family SocketFamily) InetAddress {
	var carg1 C.GSocketFamily // in, none, casted
	var cret  *C.GInetAddress // return, full, converted

	carg1 = C.GSocketFamily(family)

	cret = C.g_inet_address_new_any(carg1)
	runtime.KeepAlive(family)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewInetAddressFromString wraps g_inet_address_new_from_string
// 
// see also https://docs.gtk.org/gio/func.g_inet_address_new_from_string.html
//
func NewInetAddressFromString(str string) InetAddress {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GInetAddress // return, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_inet_address_new_from_string(carg1)
	runtime.KeepAlive(str)

	var goret InetAddress

	if cret != nil {
		goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// NewInetAddressLoopback wraps g_inet_address_new_loopback
// 
// see also https://docs.gtk.org/gio/func.g_inet_address_new_loopback.html
//
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var carg1 C.GSocketFamily // in, none, casted
	var cret  *C.GInetAddress // return, full, converted

	carg1 = C.GSocketFamily(family)

	cret = C.g_inet_address_new_loopback(carg1)
	runtime.KeepAlive(family)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_inet_address_equal
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_equal.g_inet_address_equal.html
//
func (address *InetAddressInstance) Equal(otherAddress InetAddress) bool {
	var carg0 *C.GInetAddress // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(otherAddress))

	cret = C.g_inet_address_equal(carg0, carg1)
	runtime.KeepAlive(address)
	runtime.KeepAlive(otherAddress)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetFamily wraps g_inet_address_get_family
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_family.g_inet_address_get_family.html
//
func (address *InetAddressInstance) GetFamily() SocketFamily {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.GSocketFamily // return, none, casted

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_family(carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetIsAny wraps g_inet_address_get_is_any
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_any.g_inet_address_get_is_any.html
//
func (address *InetAddressInstance) GetIsAny() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_any(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsLinkLocal wraps g_inet_address_get_is_link_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_link_local.g_inet_address_get_is_link_local.html
//
func (address *InetAddressInstance) GetIsLinkLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_link_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsLoopback wraps g_inet_address_get_is_loopback
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_loopback.g_inet_address_get_is_loopback.html
//
func (address *InetAddressInstance) GetIsLoopback() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_loopback(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcGlobal wraps g_inet_address_get_is_mc_global
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_global.g_inet_address_get_is_mc_global.html
//
func (address *InetAddressInstance) GetIsMcGlobal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_global(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcLinkLocal wraps g_inet_address_get_is_mc_link_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_link_local.g_inet_address_get_is_mc_link_local.html
//
func (address *InetAddressInstance) GetIsMcLinkLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_link_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcNodeLocal wraps g_inet_address_get_is_mc_node_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_node_local.g_inet_address_get_is_mc_node_local.html
//
func (address *InetAddressInstance) GetIsMcNodeLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_node_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcOrgLocal wraps g_inet_address_get_is_mc_org_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_org_local.g_inet_address_get_is_mc_org_local.html
//
func (address *InetAddressInstance) GetIsMcOrgLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_org_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcSiteLocal wraps g_inet_address_get_is_mc_site_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_mc_site_local.g_inet_address_get_is_mc_site_local.html
//
func (address *InetAddressInstance) GetIsMcSiteLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_site_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMulticast wraps g_inet_address_get_is_multicast
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_multicast.g_inet_address_get_is_multicast.html
//
func (address *InetAddressInstance) GetIsMulticast() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_multicast(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsSiteLocal wraps g_inet_address_get_is_site_local
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_is_site_local.g_inet_address_get_is_site_local.html
//
func (address *InetAddressInstance) GetIsSiteLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_site_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNativeSize wraps g_inet_address_get_native_size
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_get_native_size.g_inet_address_get_native_size.html
//
func (address *InetAddressInstance) GetNativeSize() uint {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_native_size(carg0)
	runtime.KeepAlive(address)

	var goret uint

	goret = uint(cret)

	return goret
}

// String wraps g_inet_address_to_string
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_to_string.g_inet_address_to_string.html
//
func (address *InetAddressInstance) String() string {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_to_string(carg0)
	runtime.KeepAlive(address)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InetAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetAddressOverrides[Instance InetAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // ToString allows you to override the implementation of the virtual method to_string.
	// 
	// see also https://docs.gtk.org/gio/method.InetAddress.to_string.html
	ToString func(Instance) string
}

// UnsafeApplyInetAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetAddressOverrides[Instance InetAddress](gclass unsafe.Pointer, overrides InetAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GInetAddressClass)(gclass)

	if overrides.ToString != nil {
		pclass.to_string = (*[0]byte)(C._goglib_gio2_InetAddress_to_string)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InetAddress_to_string",
			func(carg0 *C.GInetAddress) (cret *C.gchar) {
				var address Instance // go GInetAddress subclass
				var goret   string   // return, full, string

				address = UnsafeInetAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.ToString(address)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))

				return cret
			},
		)
	}
}

// ParentToString calls the default implementations of the `GInetAddress.to_string` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InetAddress.to_string.html
func (address *InetAddressInstance) ParentToString() string {
	var carg0 *C.GInetAddress
	var cret  *C.gchar // return, full, string

	parentclass := (*C.GInetAddressClass)(classdata.PeekParentClass(UnsafeInetAddressToGlibNone(address)))

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C._goglib_gio2_InetAddress_virtual_to_string(unsafe.Pointer(parentclass.to_string), carg0)
	runtime.KeepAlive(address)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegisterInetAddressSubClass is used to register a go subclass of GInetAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetAddressSubClass[InstanceT InetAddress](
		name string,
		classInit func(class *InetAddressClass),
		constructor func() InstanceT,
		overrides InetAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetAddress,
		UnsafeInetAddressClassFromGlibBorrow,
		UnsafeApplyInetAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddress(obj)
		},
		interfaceInits...,
	)
}

// InetAddressMaskInstance is the instance type used by all types extending GInetAddressMask. It is used internally by the bindings. Users should use the interface [InetAddressMask] instead.
type InetAddressMaskInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InetAddressMask = (*InetAddressMaskInstance)(nil)

// InetAddressMask wraps GInetAddressMask
// 
// see also https://docs.gtk.org/gio/class.InetAddressMask.html
//
type InetAddressMask interface {
	gobject.Object
	upcastToGInetAddressMask() *InetAddressMaskInstance

	// Equal wraps g_inet_address_mask_equal
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_equal.g_inet_address_mask_equal.html
	//
	Equal(InetAddressMask) bool
	// GetAddress wraps g_inet_address_mask_get_address
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_address.g_inet_address_mask_get_address.html
	//
	GetAddress() InetAddress
	// GetFamily wraps g_inet_address_mask_get_family
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_family.g_inet_address_mask_get_family.html
	//
	GetFamily() SocketFamily
	// GetLength wraps g_inet_address_mask_get_length
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_length.g_inet_address_mask_get_length.html
	//
	GetLength() uint
	// Matches wraps g_inet_address_mask_matches
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_matches.g_inet_address_mask_matches.html
	//
	Matches(InetAddress) bool
	// String wraps g_inet_address_mask_to_string
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_address_mask_to_string.g_inet_address_mask_to_string.html
	//
	String() string

	// chain up virtual methods:
}

func unsafeWrapInetAddressMask(base *gobject.ObjectInstance) *InetAddressMaskInstance {
	return &InetAddressMaskInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetAddressMask,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddressMask(inst)
		},
	)
}

func marshalInetAddressMaskInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetAddressMaskFromGlibNone is used to convert raw GInetAddressMask pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibNone(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibNone(c).(InetAddressMask)
}

// UnsafeInetAddressMaskFromGlibFull is used to convert raw GInetAddressMask pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibFull(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibFull(c).(InetAddressMask)
}

// UnsafeInetAddressMaskFromGlibBorrow is used to convert raw GInetAddressMask pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibBorrow(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetAddressMask)
}

func (i *InetAddressMaskInstance) upcastToGInetAddressMask() *InetAddressMaskInstance {
	return i
}

// UnsafeInetAddressMaskToGlibNone is used to convert the instance to it's C value GInetAddressMask. This is used by the bindings internally.
func UnsafeInetAddressMaskToGlibNone(c InetAddressMask) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetAddressMaskToGlibFull is used to convert the instance to it's C value GInetAddressMask, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskToGlibFull(c InetAddressMask) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetAddressMask wraps g_inet_address_mask_new
// 
// see also https://docs.gtk.org/gio/func.g_inet_address_mask_new.html
//
func NewInetAddressMask(addr InetAddress, length uint) (InetAddressMask, error) {
	var carg1 *C.GInetAddress     // in, none, converted
	var carg2 C.guint             // in, none, casted
	var cret  *C.GInetAddressMask // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(addr))
	carg2 = C.guint(length)

	cret = C.g_inet_address_mask_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(addr)
	runtime.KeepAlive(length)

	var goret  InetAddressMask
	var _goerr error

	goret = UnsafeInetAddressMaskFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewInetAddressMaskFromString wraps g_inet_address_mask_new_from_string
// 
// see also https://docs.gtk.org/gio/func.g_inet_address_mask_new_from_string.html
//
func NewInetAddressMaskFromString(maskString string) (InetAddressMask, error) {
	var carg1 *C.gchar            // in, none, string
	var cret  *C.GInetAddressMask // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(maskString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_inet_address_mask_new_from_string(carg1, &_cerr)
	runtime.KeepAlive(maskString)

	var goret  InetAddressMask
	var _goerr error

	goret = UnsafeInetAddressMaskFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_inet_address_mask_equal
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_equal.g_inet_address_mask_equal.html
//
func (mask *InetAddressMaskInstance) Equal(mask2 InetAddressMask) bool {
	var carg0 *C.GInetAddressMask // in, none, converted
	var carg1 *C.GInetAddressMask // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))
	carg1 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask2))

	cret = C.g_inet_address_mask_equal(carg0, carg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(mask2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetAddress wraps g_inet_address_mask_get_address
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_address.g_inet_address_mask_get_address.html
//
func (mask *InetAddressMaskInstance) GetAddress() InetAddress {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  *C.GInetAddress     // return, none, converted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_address(carg0)
	runtime.KeepAlive(mask)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFamily wraps g_inet_address_mask_get_family
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_family.g_inet_address_mask_get_family.html
//
func (mask *InetAddressMaskInstance) GetFamily() SocketFamily {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  C.GSocketFamily     // return, none, casted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_family(carg0)
	runtime.KeepAlive(mask)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetLength wraps g_inet_address_mask_get_length
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_get_length.g_inet_address_mask_get_length.html
//
func (mask *InetAddressMaskInstance) GetLength() uint {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  C.guint             // return, none, casted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_length(carg0)
	runtime.KeepAlive(mask)

	var goret uint

	goret = uint(cret)

	return goret
}

// Matches wraps g_inet_address_mask_matches
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_matches.g_inet_address_mask_matches.html
//
func (mask *InetAddressMaskInstance) Matches(address InetAddress) bool {
	var carg0 *C.GInetAddressMask // in, none, converted
	var carg1 *C.GInetAddress     // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_mask_matches(carg0, carg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// String wraps g_inet_address_mask_to_string
// 
// see also https://docs.gtk.org/gio/method.g_inet_address_mask_to_string.g_inet_address_mask_to_string.html
//
func (mask *InetAddressMaskInstance) String() string {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  *C.gchar            // return, full, string

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_to_string(carg0)
	runtime.KeepAlive(mask)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InetAddressMaskOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetAddressMaskOverrides[Instance InetAddressMask] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyInetAddressMaskOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetAddressMaskOverrides[Instance InetAddressMask](gclass unsafe.Pointer, overrides InetAddressMaskOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterInetAddressMaskSubClass is used to register a go subclass of GInetAddressMask. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetAddressMaskSubClass[InstanceT InetAddressMask](
		name string,
		classInit func(class *InetAddressMaskClass),
		constructor func() InstanceT,
		overrides InetAddressMaskOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetAddressMask,
		UnsafeInetAddressMaskClassFromGlibBorrow,
		UnsafeApplyInetAddressMaskOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddressMask(obj)
		},
		interfaceInits...,
	)
}

// InputStreamInstance is the instance type used by all types extending GInputStream. It is used internally by the bindings. Users should use the interface [InputStream] instead.
type InputStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InputStream = (*InputStreamInstance)(nil)

// InputStream wraps GInputStream
// 
// see also https://docs.gtk.org/gio/class.InputStream.html
//
type InputStream interface {
	gobject.Object
	upcastToGInputStream() *InputStreamInstance

	// ClearPending wraps g_input_stream_clear_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_clear_pending.g_input_stream_clear_pending.html
	//
	ClearPending()
	// Close wraps g_input_stream_close
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_close.g_input_stream_close.html
	//
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_input_stream_close_async
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_close_async.g_input_stream_close_async.html
	//
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_input_stream_close_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_close_finish.g_input_stream_close_finish.html
	//
	CloseFinish(AsyncResult) (bool, error)
	// HasPending wraps g_input_stream_has_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_has_pending.g_input_stream_has_pending.html
	//
	HasPending() bool
	// IsClosed wraps g_input_stream_is_closed
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_is_closed.g_input_stream_is_closed.html
	//
	IsClosed() bool
	// ReadAllFinish wraps g_input_stream_read_all_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_read_all_finish.g_input_stream_read_all_finish.html
	//
	ReadAllFinish(AsyncResult) (uint, bool, error)
	// ReadBytes wraps g_input_stream_read_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes.g_input_stream_read_bytes.html
	//
	ReadBytes(uint, Cancellable) (*glib.Bytes, error)
	// ReadBytesAsync wraps g_input_stream_read_bytes_async
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes_async.g_input_stream_read_bytes_async.html
	//
	ReadBytesAsync(uint, int32, Cancellable, AsyncReadyCallback)
	// ReadBytesFinish wraps g_input_stream_read_bytes_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes_finish.g_input_stream_read_bytes_finish.html
	//
	ReadBytesFinish(AsyncResult) (*glib.Bytes, error)
	// ReadFinish wraps g_input_stream_read_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_read_finish.g_input_stream_read_finish.html
	//
	ReadFinish(AsyncResult) (int, error)
	// SetPending wraps g_input_stream_set_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_set_pending.g_input_stream_set_pending.html
	//
	SetPending() (bool, error)
	// Skip wraps g_input_stream_skip
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_skip.g_input_stream_skip.html
	//
	Skip(uint, Cancellable) (int, error)
	// SkipAsync wraps g_input_stream_skip_async
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_skip_async.g_input_stream_skip_async.html
	//
	SkipAsync(uint, int32, Cancellable, AsyncReadyCallback)
	// SkipFinish wraps g_input_stream_skip_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_input_stream_skip_finish.g_input_stream_skip_finish.html
	//
	SkipFinish(AsyncResult) (int, error)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GInputStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.close_finish.html
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GInputStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.close_fn.html
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentReadFinish calls the default implementations of the `GInputStream.read_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.read_finish.html
	ParentReadFinish(result AsyncResult) (int, error)
	// ParentSkip calls the default implementations of the `GInputStream.skip` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.skip.html
	ParentSkip(count uint, cancellable Cancellable) (int, error)
	// ParentSkipFinish calls the default implementations of the `GInputStream.skip_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.skip_finish.html
	ParentSkipFinish(result AsyncResult) (int, error)
}

func unsafeWrapInputStream(base *gobject.ObjectInstance) *InputStreamInstance {
	return &InputStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInputStream(inst)
		},
	)
}

func marshalInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInputStreamFromGlibNone is used to convert raw GInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInputStreamFromGlibNone(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(InputStream)
}

// UnsafeInputStreamFromGlibFull is used to convert raw GInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInputStreamFromGlibFull(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(InputStream)
}

// UnsafeInputStreamFromGlibBorrow is used to convert raw GInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInputStreamFromGlibBorrow(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InputStream)
}

func (i *InputStreamInstance) upcastToGInputStream() *InputStreamInstance {
	return i
}

// UnsafeInputStreamToGlibNone is used to convert the instance to it's C value GInputStream. This is used by the bindings internally.
func UnsafeInputStreamToGlibNone(c InputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInputStreamToGlibFull is used to convert the instance to it's C value GInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInputStreamToGlibFull(c InputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ClearPending wraps g_input_stream_clear_pending
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_clear_pending.g_input_stream_clear_pending.html
//
func (stream *InputStreamInstance) ClearPending() {
	var carg0 *C.GInputStream // in, none, converted

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	C.g_input_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_input_stream_close
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_close.g_input_stream_close.html
//
func (stream *InputStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_input_stream_close_async
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_close_async.g_input_stream_close_async.html
//
func (stream *InputStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_input_stream_close_finish
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_close_finish.g_input_stream_close_finish.html
//
func (stream *InputStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasPending wraps g_input_stream_has_pending
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_has_pending.g_input_stream_has_pending.html
//
func (stream *InputStreamInstance) HasPending() bool {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_input_stream_is_closed
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_is_closed.g_input_stream_is_closed.html
//
func (stream *InputStreamInstance) IsClosed() bool {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReadAllFinish wraps g_input_stream_read_all_finish
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_read_all_finish.g_input_stream_read_all_finish.html
//
func (stream *InputStreamInstance) ReadAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.gsize         // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesRead uint
	var goret     bool
	var _goerr    error

	bytesRead = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, goret, _goerr
}

// ReadBytes wraps g_input_stream_read_bytes
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes.g_input_stream_read_bytes.html
//
func (stream *InputStreamInstance) ReadBytes(count uint, cancellable Cancellable) (*glib.Bytes, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_read_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadBytesAsync wraps g_input_stream_read_bytes_async
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes_async.g_input_stream_read_bytes_async.html
//
func (stream *InputStreamInstance) ReadBytesAsync(count uint, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.gsize               // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_read_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadBytesFinish wraps g_input_stream_read_bytes_finish
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_read_bytes_finish.g_input_stream_read_bytes_finish.html
//
func (stream *InputStreamInstance) ReadBytesFinish(result AsyncResult) (*glib.Bytes, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_bytes_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadFinish wraps g_input_stream_read_finish
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_read_finish.g_input_stream_read_finish.html
//
func (stream *InputStreamInstance) ReadFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetPending wraps g_input_stream_set_pending
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_set_pending.g_input_stream_set_pending.html
//
func (stream *InputStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Skip wraps g_input_stream_skip
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_skip.g_input_stream_skip.html
//
func (stream *InputStreamInstance) Skip(count uint, cancellable Cancellable) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_skip(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SkipAsync wraps g_input_stream_skip_async
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_skip_async.g_input_stream_skip_async.html
//
func (stream *InputStreamInstance) SkipAsync(count uint, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.gsize               // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_skip_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SkipFinish wraps g_input_stream_skip_finish
// 
// see also https://docs.gtk.org/gio/method.g_input_stream_skip_finish.g_input_stream_skip_finish.html
//
func (stream *InputStreamInstance) SkipFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_skip_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InputStreamOverrides[Instance InputStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.close_finish.html
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.close_fn.html
	CloseFn func(Instance, Cancellable) (bool, error)
	// // ReadFinish allows you to override the implementation of the virtual method read_finish.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.read_finish.html
	ReadFinish func(Instance, AsyncResult) (int, error)
	// // Skip allows you to override the implementation of the virtual method skip.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.skip.html
	Skip func(Instance, uint, Cancellable) (int, error)
	// // SkipFinish allows you to override the implementation of the virtual method skip_finish.
	// 
	// see also https://docs.gtk.org/gio/method.InputStream.skip_finish.html
	SkipFinish func(Instance, AsyncResult) (int, error)
}

// UnsafeApplyInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInputStreamOverrides[Instance InputStream](gclass unsafe.Pointer, overrides InputStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GInputStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_InputStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_close_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_InputStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_close_fn",
			func(carg0 *C.GInputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GInputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ReadFinish != nil {
		pclass.read_finish = (*[0]byte)(C._goglib_gio2_InputStream_read_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_read_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.ReadFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Skip != nil {
		pclass.skip = (*[0]byte)(C._goglib_gio2_InputStream_skip)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_skip",
			func(carg0 *C.GInputStream, carg1 C.gsize, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GInputStream subclass
				var count       uint        // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				count = uint(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.Skip(stream, count, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.SkipFinish != nil {
		pclass.skip_finish = (*[0]byte)(C._goglib_gio2_InputStream_skip_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_skip_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.SkipFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GInputStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InputStream.close_finish.html
func (stream *InputStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GInputStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InputStream.close_fn.html
func (stream *InputStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_InputStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReadFinish calls the default implementations of the `GInputStream.read_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InputStream.read_finish.html
func (stream *InputStreamInstance) ParentReadFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_read_finish(unsafe.Pointer(parentclass.read_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSkip calls the default implementations of the `GInputStream.skip` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InputStream.skip.html
func (stream *InputStreamInstance) ParentSkip(count uint, cancellable Cancellable) (int, error) {
	var carg0 *C.GInputStream
	var carg1 C.gsize         // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_InputStream_virtual_skip(unsafe.Pointer(parentclass.skip), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSkipFinish calls the default implementations of the `GInputStream.skip_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.InputStream.skip_finish.html
func (stream *InputStreamInstance) ParentSkipFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_skip_finish(unsafe.Pointer(parentclass.skip_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterInputStreamSubClass is used to register a go subclass of GInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInputStreamSubClass[InstanceT InputStream](
		name string,
		classInit func(class *InputStreamClass),
		constructor func() InstanceT,
		overrides InputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInputStream,
		UnsafeInputStreamClassFromGlibBorrow,
		UnsafeApplyInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInputStream(obj)
		},
		interfaceInits...,
	)
}

// ListStoreInstance is the instance type used by all types extending GListStore. It is used internally by the bindings. Users should use the interface [ListStore] instead.
type ListStoreInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ListStore = (*ListStoreInstance)(nil)

// ListStore wraps GListStore
// 
// see also https://docs.gtk.org/gio/class.ListStore.html
//
type ListStore interface {
	gobject.Object
	upcastToGListStore() *ListStoreInstance

	// Remove wraps g_list_store_remove
	// 
	// see also https://docs.gtk.org/gio/method.g_list_store_remove.g_list_store_remove.html
	//
	Remove(uint)
	// RemoveAll wraps g_list_store_remove_all
	// 
	// see also https://docs.gtk.org/gio/method.g_list_store_remove_all.g_list_store_remove_all.html
	//
	RemoveAll()

	// chain up virtual methods:
}

func unsafeWrapListStore(base *gobject.ObjectInstance) *ListStoreInstance {
	return &ListStoreInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeListStore,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapListStore(inst)
		},
	)
}

func marshalListStoreInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeListStoreFromGlibNone is used to convert raw GListStore pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeListStoreFromGlibNone(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibNone(c).(ListStore)
}

// UnsafeListStoreFromGlibFull is used to convert raw GListStore pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeListStoreFromGlibFull(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibFull(c).(ListStore)
}

// UnsafeListStoreFromGlibBorrow is used to convert raw GListStore pointers to go without touching any references. This is used by the bindings internally.
func UnsafeListStoreFromGlibBorrow(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ListStore)
}

func (l *ListStoreInstance) upcastToGListStore() *ListStoreInstance {
	return l
}

// UnsafeListStoreToGlibNone is used to convert the instance to it's C value GListStore. This is used by the bindings internally.
func UnsafeListStoreToGlibNone(c ListStore) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeListStoreToGlibFull is used to convert the instance to it's C value GListStore, while removeing the finalizer. This is used by the bindings internally.
func UnsafeListStoreToGlibFull(c ListStore) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewListStore wraps g_list_store_new
// 
// see also https://docs.gtk.org/gio/func.g_list_store_new.html
//
func NewListStore(itemType gobject.Type) ListStore {
	var carg1 C.GType       // in, none, casted, alias
	var cret  *C.GListStore // return, full, converted

	carg1 = C.GType(itemType)

	cret = C.g_list_store_new(carg1)
	runtime.KeepAlive(itemType)

	var goret ListStore

	goret = UnsafeListStoreFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Remove wraps g_list_store_remove
// 
// see also https://docs.gtk.org/gio/method.g_list_store_remove.g_list_store_remove.html
//
func (store *ListStoreInstance) Remove(position uint) {
	var carg0 *C.GListStore // in, none, converted
	var carg1 C.guint       // in, none, casted

	carg0 = (*C.GListStore)(UnsafeListStoreToGlibNone(store))
	carg1 = C.guint(position)

	C.g_list_store_remove(carg0, carg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(position)
}

// RemoveAll wraps g_list_store_remove_all
// 
// see also https://docs.gtk.org/gio/method.g_list_store_remove_all.g_list_store_remove_all.html
//
func (store *ListStoreInstance) RemoveAll() {
	var carg0 *C.GListStore // in, none, converted

	carg0 = (*C.GListStore)(UnsafeListStoreToGlibNone(store))

	C.g_list_store_remove_all(carg0)
	runtime.KeepAlive(store)
}

// ListStoreOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ListStoreOverrides[Instance ListStore] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyListStoreOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyListStoreOverrides[Instance ListStore](gclass unsafe.Pointer, overrides ListStoreOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterListStoreSubClass is used to register a go subclass of GListStore. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterListStoreSubClass[InstanceT ListStore](
		name string,
		classInit func(class *ListStoreClass),
		constructor func() InstanceT,
		overrides ListStoreOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeListStore,
		UnsafeListStoreClassFromGlibBorrow,
		UnsafeApplyListStoreOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapListStore(obj)
		},
		interfaceInits...,
	)
}

// MemoryInputStreamInstance is the instance type used by all types extending GMemoryInputStream. It is used internally by the bindings. Users should use the interface [MemoryInputStream] instead.
type MemoryInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
}

var _ MemoryInputStream = (*MemoryInputStreamInstance)(nil)

// MemoryInputStream wraps GMemoryInputStream
// 
// see also https://docs.gtk.org/gio/class.MemoryInputStream.html
//
type MemoryInputStream interface {
	InputStream
	upcastToGMemoryInputStream() *MemoryInputStreamInstance

	// AddBytes wraps g_memory_input_stream_add_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_memory_input_stream_add_bytes.g_memory_input_stream_add_bytes.html
	//
	AddBytes(*glib.Bytes)

	// chain up virtual methods:
}

func unsafeWrapMemoryInputStream(base *gobject.ObjectInstance) *MemoryInputStreamInstance {
	return &MemoryInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMemoryInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryInputStream(inst)
		},
	)
}

func marshalMemoryInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMemoryInputStreamFromGlibNone is used to convert raw GMemoryInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibNone(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryInputStream)
}

// UnsafeMemoryInputStreamFromGlibFull is used to convert raw GMemoryInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibFull(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryInputStream)
}

// UnsafeMemoryInputStreamFromGlibBorrow is used to convert raw GMemoryInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibBorrow(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryInputStream)
}

func (m *MemoryInputStreamInstance) upcastToGMemoryInputStream() *MemoryInputStreamInstance {
	return m
}

// UnsafeMemoryInputStreamToGlibNone is used to convert the instance to it's C value GMemoryInputStream. This is used by the bindings internally.
func UnsafeMemoryInputStreamToGlibNone(c MemoryInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMemoryInputStreamToGlibFull is used to convert the instance to it's C value GMemoryInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamToGlibFull(c MemoryInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMemoryInputStream wraps g_memory_input_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_memory_input_stream_new.html
//
func NewMemoryInputStream() InputStream {
	var cret *C.GInputStream // return, full, converted

	cret = C.g_memory_input_stream_new()

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMemoryInputStreamFromBytes wraps g_memory_input_stream_new_from_bytes
// 
// see also https://docs.gtk.org/gio/func.g_memory_input_stream_new_from_bytes.html
//
func NewMemoryInputStreamFromBytes(bytes *glib.Bytes) InputStream {
	var carg1 *C.GBytes       // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_memory_input_stream_new_from_bytes(carg1)
	runtime.KeepAlive(bytes)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddBytes wraps g_memory_input_stream_add_bytes
// 
// see also https://docs.gtk.org/gio/method.g_memory_input_stream_add_bytes.g_memory_input_stream_add_bytes.html
//
func (stream *MemoryInputStreamInstance) AddBytes(bytes *glib.Bytes) {
	var carg0 *C.GMemoryInputStream // in, none, converted
	var carg1 *C.GBytes             // in, none, converted

	carg0 = (*C.GMemoryInputStream)(UnsafeMemoryInputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	C.g_memory_input_stream_add_bytes(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
}

// MemoryInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MemoryInputStreamOverrides[Instance MemoryInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

}

// UnsafeApplyMemoryInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMemoryInputStreamOverrides[Instance MemoryInputStream](gclass unsafe.Pointer, overrides MemoryInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)
}

// RegisterMemoryInputStreamSubClass is used to register a go subclass of GMemoryInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMemoryInputStreamSubClass[InstanceT MemoryInputStream](
		name string,
		classInit func(class *MemoryInputStreamClass),
		constructor func() InstanceT,
		overrides MemoryInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMemoryInputStream,
		UnsafeMemoryInputStreamClassFromGlibBorrow,
		UnsafeApplyMemoryInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryInputStream(obj)
		},
		interfaceInits...,
	)
}

// MenuAttributeIterInstance is the instance type used by all types extending GMenuAttributeIter. It is used internally by the bindings. Users should use the interface [MenuAttributeIter] instead.
type MenuAttributeIterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuAttributeIter = (*MenuAttributeIterInstance)(nil)

// MenuAttributeIter wraps GMenuAttributeIter
// 
// see also https://docs.gtk.org/gio/class.MenuAttributeIter.html
//
type MenuAttributeIter interface {
	gobject.Object
	upcastToGMenuAttributeIter() *MenuAttributeIterInstance

	// GetName wraps g_menu_attribute_iter_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_attribute_iter_get_name.g_menu_attribute_iter_get_name.html
	//
	GetName() string
	// Next wraps g_menu_attribute_iter_next
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_attribute_iter_next.g_menu_attribute_iter_next.html
	//
	Next() bool

	// chain up virtual methods:
}

func unsafeWrapMenuAttributeIter(base *gobject.ObjectInstance) *MenuAttributeIterInstance {
	return &MenuAttributeIterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuAttributeIter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuAttributeIter(inst)
		},
	)
}

func marshalMenuAttributeIterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuAttributeIterFromGlibNone is used to convert raw GMenuAttributeIter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibNone(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuAttributeIter)
}

// UnsafeMenuAttributeIterFromGlibFull is used to convert raw GMenuAttributeIter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibFull(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuAttributeIter)
}

// UnsafeMenuAttributeIterFromGlibBorrow is used to convert raw GMenuAttributeIter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibBorrow(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuAttributeIter)
}

func (m *MenuAttributeIterInstance) upcastToGMenuAttributeIter() *MenuAttributeIterInstance {
	return m
}

// UnsafeMenuAttributeIterToGlibNone is used to convert the instance to it's C value GMenuAttributeIter. This is used by the bindings internally.
func UnsafeMenuAttributeIterToGlibNone(c MenuAttributeIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuAttributeIterToGlibFull is used to convert the instance to it's C value GMenuAttributeIter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterToGlibFull(c MenuAttributeIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetName wraps g_menu_attribute_iter_get_name
// 
// see also https://docs.gtk.org/gio/method.g_menu_attribute_iter_get_name.g_menu_attribute_iter_get_name.html
//
func (iter *MenuAttributeIterInstance) GetName() string {
	var carg0 *C.GMenuAttributeIter // in, none, converted
	var cret  *C.gchar              // return, none, string

	carg0 = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibNone(iter))

	cret = C.g_menu_attribute_iter_get_name(carg0)
	runtime.KeepAlive(iter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Next wraps g_menu_attribute_iter_next
// 
// see also https://docs.gtk.org/gio/method.g_menu_attribute_iter_next.g_menu_attribute_iter_next.html
//
func (iter *MenuAttributeIterInstance) Next() bool {
	var carg0 *C.GMenuAttributeIter // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibNone(iter))

	cret = C.g_menu_attribute_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MenuAttributeIterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuAttributeIterOverrides[Instance MenuAttributeIter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyMenuAttributeIterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuAttributeIterOverrides[Instance MenuAttributeIter](gclass unsafe.Pointer, overrides MenuAttributeIterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterMenuAttributeIterSubClass is used to register a go subclass of GMenuAttributeIter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuAttributeIterSubClass[InstanceT MenuAttributeIter](
		name string,
		classInit func(class *MenuAttributeIterClass),
		constructor func() InstanceT,
		overrides MenuAttributeIterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuAttributeIter,
		UnsafeMenuAttributeIterClassFromGlibBorrow,
		UnsafeApplyMenuAttributeIterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuAttributeIter(obj)
		},
		interfaceInits...,
	)
}

// MenuItemInstance is the instance type used by all types extending GMenuItem. It is used internally by the bindings. Users should use the interface [MenuItem] instead.
type MenuItemInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuItem = (*MenuItemInstance)(nil)

// MenuItem wraps GMenuItem
// 
// see also https://docs.gtk.org/gio/class.MenuItem.html
//
type MenuItem interface {
	gobject.Object
	upcastToGMenuItem() *MenuItemInstance

	// GetLink wraps g_menu_item_get_link
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_get_link.g_menu_item_get_link.html
	//
	GetLink(string) MenuModel
	// SetDetailedAction wraps g_menu_item_set_detailed_action
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_detailed_action.g_menu_item_set_detailed_action.html
	//
	SetDetailedAction(string)
	// SetIcon wraps g_menu_item_set_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_icon.g_menu_item_set_icon.html
	//
	SetIcon(Icon)
	// SetLabel wraps g_menu_item_set_label
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_label.g_menu_item_set_label.html
	//
	SetLabel(string)
	// SetLink wraps g_menu_item_set_link
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_link.g_menu_item_set_link.html
	//
	SetLink(string, MenuModel)
	// SetSection wraps g_menu_item_set_section
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_section.g_menu_item_set_section.html
	//
	SetSection(MenuModel)
	// SetSubmenu wraps g_menu_item_set_submenu
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_item_set_submenu.g_menu_item_set_submenu.html
	//
	SetSubmenu(MenuModel)
}

func unsafeWrapMenuItem(base *gobject.ObjectInstance) *MenuItemInstance {
	return &MenuItemInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuItem,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuItem(inst)
		},
	)
}

func marshalMenuItemInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuItemFromGlibNone is used to convert raw GMenuItem pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuItemFromGlibNone(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuItem)
}

// UnsafeMenuItemFromGlibFull is used to convert raw GMenuItem pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuItemFromGlibFull(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuItem)
}

// UnsafeMenuItemFromGlibBorrow is used to convert raw GMenuItem pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuItemFromGlibBorrow(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuItem)
}

func (m *MenuItemInstance) upcastToGMenuItem() *MenuItemInstance {
	return m
}

// UnsafeMenuItemToGlibNone is used to convert the instance to it's C value GMenuItem. This is used by the bindings internally.
func UnsafeMenuItemToGlibNone(c MenuItem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuItemToGlibFull is used to convert the instance to it's C value GMenuItem, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuItemToGlibFull(c MenuItem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMenuItem wraps g_menu_item_new
// 
// see also https://docs.gtk.org/gio/func.g_menu_item_new.html
//
func NewMenuItem(label string, detailedAction string) MenuItem {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var carg2 *C.gchar     // in, none, string, nullable-string
	var cret  *C.GMenuItem // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_menu_item_new(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemFromModel wraps g_menu_item_new_from_model
// 
// see also https://docs.gtk.org/gio/func.g_menu_item_new_from_model.html
//
func NewMenuItemFromModel(model MenuModel, itemIndex int32) MenuItem {
	var carg1 *C.GMenuModel // in, none, converted
	var carg2 C.gint        // in, none, casted
	var cret  *C.GMenuItem  // return, full, converted

	carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg2 = C.gint(itemIndex)

	cret = C.g_menu_item_new_from_model(carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemSection wraps g_menu_item_new_section
// 
// see also https://docs.gtk.org/gio/func.g_menu_item_new_section.html
//
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted
	var cret  *C.GMenuItem  // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	cret = C.g_menu_item_new_section(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemSubmenu wraps g_menu_item_new_submenu
// 
// see also https://docs.gtk.org/gio/func.g_menu_item_new_submenu.html
//
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted
	var cret  *C.GMenuItem  // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	cret = C.g_menu_item_new_submenu(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetLink wraps g_menu_item_get_link
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_get_link.g_menu_item_get_link.html
//
func (menuItem *MenuItemInstance) GetLink(link string) MenuModel {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.GMenuModel // return, full, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_menu_item_get_link(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// SetDetailedAction wraps g_menu_item_set_detailed_action
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_detailed_action.g_menu_item_set_detailed_action.html
//
func (menuItem *MenuItemInstance) SetDetailedAction(detailedAction string) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.gchar     // in, none, string

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_menu_item_set_detailed_action(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(detailedAction)
}

// SetIcon wraps g_menu_item_set_icon
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_icon.g_menu_item_set_icon.html
//
func (menuItem *MenuItemInstance) SetIcon(icon Icon) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_menu_item_set_icon(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(icon)
}

// SetLabel wraps g_menu_item_set_label
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_label.g_menu_item_set_label.html
//
func (menuItem *MenuItemInstance) SetLabel(label string) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.gchar     // in, none, string, nullable-string

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_menu_item_set_label(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(label)
}

// SetLink wraps g_menu_item_set_link
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_link.g_menu_item_set_link.html
//
func (menuItem *MenuItemInstance) SetLink(link string, model MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg1))
	if model != nil {
		carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	}

	C.g_menu_item_set_link(carg0, carg1, carg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)
	runtime.KeepAlive(model)
}

// SetSection wraps g_menu_item_set_section
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_section.g_menu_item_set_section.html
//
func (menuItem *MenuItemInstance) SetSection(section MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if section != nil {
		carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))
	}

	C.g_menu_item_set_section(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(section)
}

// SetSubmenu wraps g_menu_item_set_submenu
// 
// see also https://docs.gtk.org/gio/method.g_menu_item_set_submenu.g_menu_item_set_submenu.html
//
func (menuItem *MenuItemInstance) SetSubmenu(submenu MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if submenu != nil {
		carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))
	}

	C.g_menu_item_set_submenu(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(submenu)
}

// MenuLinkIterInstance is the instance type used by all types extending GMenuLinkIter. It is used internally by the bindings. Users should use the interface [MenuLinkIter] instead.
type MenuLinkIterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuLinkIter = (*MenuLinkIterInstance)(nil)

// MenuLinkIter wraps GMenuLinkIter
// 
// see also https://docs.gtk.org/gio/class.MenuLinkIter.html
//
type MenuLinkIter interface {
	gobject.Object
	upcastToGMenuLinkIter() *MenuLinkIterInstance

	// GetName wraps g_menu_link_iter_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_name.g_menu_link_iter_get_name.html
	//
	GetName() string
	// GetNext wraps g_menu_link_iter_get_next
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_next.g_menu_link_iter_get_next.html
	//
	GetNext() (string, MenuModel, bool)
	// GetValue wraps g_menu_link_iter_get_value
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_value.g_menu_link_iter_get_value.html
	//
	GetValue() MenuModel
	// Next wraps g_menu_link_iter_next
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_link_iter_next.g_menu_link_iter_next.html
	//
	Next() bool

	// chain up virtual methods:

	// ParentGetNext calls the default implementations of the `GMenuLinkIter.get_next` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuLinkIter.get_next.html
	ParentGetNext() (string, MenuModel, bool)
}

func unsafeWrapMenuLinkIter(base *gobject.ObjectInstance) *MenuLinkIterInstance {
	return &MenuLinkIterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuLinkIter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuLinkIter(inst)
		},
	)
}

func marshalMenuLinkIterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuLinkIterFromGlibNone is used to convert raw GMenuLinkIter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibNone(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuLinkIter)
}

// UnsafeMenuLinkIterFromGlibFull is used to convert raw GMenuLinkIter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibFull(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuLinkIter)
}

// UnsafeMenuLinkIterFromGlibBorrow is used to convert raw GMenuLinkIter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibBorrow(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuLinkIter)
}

func (m *MenuLinkIterInstance) upcastToGMenuLinkIter() *MenuLinkIterInstance {
	return m
}

// UnsafeMenuLinkIterToGlibNone is used to convert the instance to it's C value GMenuLinkIter. This is used by the bindings internally.
func UnsafeMenuLinkIterToGlibNone(c MenuLinkIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuLinkIterToGlibFull is used to convert the instance to it's C value GMenuLinkIter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterToGlibFull(c MenuLinkIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetName wraps g_menu_link_iter_get_name
// 
// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_name.g_menu_link_iter_get_name.html
//
func (iter *MenuLinkIterInstance) GetName() string {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_name(carg0)
	runtime.KeepAlive(iter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetNext wraps g_menu_link_iter_get_next
// 
// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_next.g_menu_link_iter_get_next.html
//
func (iter *MenuLinkIterInstance) GetNext() (string, MenuModel, bool) {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var carg1 *C.gchar         // out, none, string
	var carg2 *C.GMenuModel    // out, full, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_next(carg0, &carg1, &carg2)
	runtime.KeepAlive(iter)

	var outLink string
	var value   MenuModel
	var goret   bool

	outLink = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	value = UnsafeMenuModelFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}

	return outLink, value, goret
}

// GetValue wraps g_menu_link_iter_get_value
// 
// see also https://docs.gtk.org/gio/method.g_menu_link_iter_get_value.g_menu_link_iter_get_value.html
//
func (iter *MenuLinkIterInstance) GetValue() MenuModel {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  *C.GMenuModel    // return, full, converted

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_value(carg0)
	runtime.KeepAlive(iter)

	var goret MenuModel

	goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Next wraps g_menu_link_iter_next
// 
// see also https://docs.gtk.org/gio/method.g_menu_link_iter_next.g_menu_link_iter_next.html
//
func (iter *MenuLinkIterInstance) Next() bool {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MenuLinkIterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuLinkIterOverrides[Instance MenuLinkIter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetNext allows you to override the implementation of the virtual method get_next.
	// 
	// see also https://docs.gtk.org/gio/method.MenuLinkIter.get_next.html
	GetNext func(Instance) (string, MenuModel, bool)
}

// UnsafeApplyMenuLinkIterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuLinkIterOverrides[Instance MenuLinkIter](gclass unsafe.Pointer, overrides MenuLinkIterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMenuLinkIterClass)(gclass)

	if overrides.GetNext != nil {
		pclass.get_next = (*[0]byte)(C._goglib_gio2_MenuLinkIter_get_next)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuLinkIter_get_next",
			func(carg0 *C.GMenuLinkIter, carg1 **C.gchar, carg2 **C.GMenuModel) (cret C.gboolean) {
				var iter    Instance  // go GMenuLinkIter subclass
				var outLink string    // out, none, string
				var value   MenuModel // out, full, converted
				var goret   bool      // return

				iter = UnsafeMenuLinkIterFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				outLink, value, goret = overrides.GetNext(iter)

				*carg1 = (*C.gchar)(unsafe.Pointer(C.CString(outLink)))
				defer C.free(unsafe.Pointer(carg1))
				*carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibFull(value))
				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentGetNext calls the default implementations of the `GMenuLinkIter.get_next` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuLinkIter.get_next.html
func (iter *MenuLinkIterInstance) ParentGetNext() (string, MenuModel, bool) {
	var carg0 *C.GMenuLinkIter
	var carg1 *C.gchar      // out, none, string
	var carg2 *C.GMenuModel // out, full, converted
	var cret  C.gboolean    // return

	parentclass := (*C.GMenuLinkIterClass)(classdata.PeekParentClass(UnsafeMenuLinkIterToGlibNone(iter)))

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C._goglib_gio2_MenuLinkIter_virtual_get_next(unsafe.Pointer(parentclass.get_next), carg0, &carg1, &carg2)
	runtime.KeepAlive(iter)

	var outLink string
	var value   MenuModel
	var goret   bool

	outLink = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	value = UnsafeMenuModelFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}

	return outLink, value, goret
}

// RegisterMenuLinkIterSubClass is used to register a go subclass of GMenuLinkIter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuLinkIterSubClass[InstanceT MenuLinkIter](
		name string,
		classInit func(class *MenuLinkIterClass),
		constructor func() InstanceT,
		overrides MenuLinkIterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuLinkIter,
		UnsafeMenuLinkIterClassFromGlibBorrow,
		UnsafeApplyMenuLinkIterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuLinkIter(obj)
		},
		interfaceInits...,
	)
}

// MenuModelInstance is the instance type used by all types extending GMenuModel. It is used internally by the bindings. Users should use the interface [MenuModel] instead.
type MenuModelInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuModel = (*MenuModelInstance)(nil)

// MenuModel wraps GMenuModel
// 
// see also https://docs.gtk.org/gio/class.MenuModel.html
//
type MenuModel interface {
	gobject.Object
	upcastToGMenuModel() *MenuModelInstance

	// GetItemLink wraps g_menu_model_get_item_link
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_get_item_link.g_menu_model_get_item_link.html
	//
	GetItemLink(int32, string) MenuModel
	// GetNItems wraps g_menu_model_get_n_items
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_get_n_items.g_menu_model_get_n_items.html
	//
	GetNItems() int32
	// IsMutable wraps g_menu_model_is_mutable
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_is_mutable.g_menu_model_is_mutable.html
	//
	IsMutable() bool
	// ItemsChanged wraps g_menu_model_items_changed
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_items_changed.g_menu_model_items_changed.html
	//
	ItemsChanged(int32, int32, int32)
	// IterateItemAttributes wraps g_menu_model_iterate_item_attributes
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_iterate_item_attributes.g_menu_model_iterate_item_attributes.html
	//
	IterateItemAttributes(int32) MenuAttributeIter
	// IterateItemLinks wraps g_menu_model_iterate_item_links
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_model_iterate_item_links.g_menu_model_iterate_item_links.html
	//
	IterateItemLinks(int32) MenuLinkIter
	// ConnectItemsChanged connects the provided callback to the "items-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MenuModel.items-changed.html
	//
	ConnectItemsChanged(func(MenuModel, int32, int32, int32)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentGetItemLink calls the default implementations of the `GMenuModel.get_item_link` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.get_item_link.html
	ParentGetItemLink(itemIndex int32, link string) MenuModel
	// ParentGetNItems calls the default implementations of the `GMenuModel.get_n_items` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.get_n_items.html
	ParentGetNItems() int32
	// ParentIsMutable calls the default implementations of the `GMenuModel.is_mutable` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.is_mutable.html
	ParentIsMutable() bool
	// ParentIterateItemAttributes calls the default implementations of the `GMenuModel.iterate_item_attributes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_attributes.html
	ParentIterateItemAttributes(itemIndex int32) MenuAttributeIter
	// ParentIterateItemLinks calls the default implementations of the `GMenuModel.iterate_item_links` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_links.html
	ParentIterateItemLinks(itemIndex int32) MenuLinkIter
}

func unsafeWrapMenuModel(base *gobject.ObjectInstance) *MenuModelInstance {
	return &MenuModelInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuModel,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuModel(inst)
		},
	)
}

func marshalMenuModelInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuModelFromGlibNone is used to convert raw GMenuModel pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuModelFromGlibNone(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuModel)
}

// UnsafeMenuModelFromGlibFull is used to convert raw GMenuModel pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuModelFromGlibFull(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuModel)
}

// UnsafeMenuModelFromGlibBorrow is used to convert raw GMenuModel pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuModelFromGlibBorrow(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuModel)
}

func (m *MenuModelInstance) upcastToGMenuModel() *MenuModelInstance {
	return m
}

// UnsafeMenuModelToGlibNone is used to convert the instance to it's C value GMenuModel. This is used by the bindings internally.
func UnsafeMenuModelToGlibNone(c MenuModel) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuModelToGlibFull is used to convert the instance to it's C value GMenuModel, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuModelToGlibFull(c MenuModel) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetItemLink wraps g_menu_model_get_item_link
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_get_item_link.g_menu_model_get_item_link.html
//
func (model *MenuModelInstance) GetItemLink(itemIndex int32, link string) MenuModel {
	var carg0 *C.GMenuModel // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GMenuModel // return, full, converted, nullable

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_menu_model_get_item_link(carg0, carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetNItems wraps g_menu_model_get_n_items
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_get_n_items.g_menu_model_get_n_items.html
//
func (model *MenuModelInstance) GetNItems() int32 {
	var carg0 *C.GMenuModel // in, none, converted
	var cret  C.gint        // return, none, casted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C.g_menu_model_get_n_items(carg0)
	runtime.KeepAlive(model)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsMutable wraps g_menu_model_is_mutable
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_is_mutable.g_menu_model_is_mutable.html
//
func (model *MenuModelInstance) IsMutable() bool {
	var carg0 *C.GMenuModel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C.g_menu_model_is_mutable(carg0)
	runtime.KeepAlive(model)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ItemsChanged wraps g_menu_model_items_changed
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_items_changed.g_menu_model_items_changed.html
//
func (model *MenuModelInstance) ItemsChanged(position int32, removed int32, added int32) {
	var carg0 *C.GMenuModel // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 C.gint        // in, none, casted
	var carg3 C.gint        // in, none, casted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(position)
	carg2 = C.gint(removed)
	carg3 = C.gint(added)

	C.g_menu_model_items_changed(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// IterateItemAttributes wraps g_menu_model_iterate_item_attributes
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_iterate_item_attributes.g_menu_model_iterate_item_attributes.html
//
func (model *MenuModelInstance) IterateItemAttributes(itemIndex int32) MenuAttributeIter {
	var carg0 *C.GMenuModel         // in, none, converted
	var carg1 C.gint                // in, none, casted
	var cret  *C.GMenuAttributeIter // return, full, converted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C.g_menu_model_iterate_item_attributes(carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuAttributeIter

	goret = UnsafeMenuAttributeIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IterateItemLinks wraps g_menu_model_iterate_item_links
// 
// see also https://docs.gtk.org/gio/method.g_menu_model_iterate_item_links.g_menu_model_iterate_item_links.html
//
func (model *MenuModelInstance) IterateItemLinks(itemIndex int32) MenuLinkIter {
	var carg0 *C.GMenuModel    // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GMenuLinkIter // return, full, converted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C.g_menu_model_iterate_item_links(carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuLinkIter

	goret = UnsafeMenuLinkIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectItemsChanged connects the provided callback to the "items-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.MenuModel.items-changed.html
//
func (o *MenuModelInstance) ConnectItemsChanged(fn func(MenuModel, int32, int32, int32)) gobject.SignalHandle {
	return o.Connect("items-changed", fn)
}

// MenuModelOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuModelOverrides[Instance MenuModel] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetItemLink allows you to override the implementation of the virtual method get_item_link.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.get_item_link.html
	GetItemLink func(Instance, int32, string) MenuModel
	// // GetNItems allows you to override the implementation of the virtual method get_n_items.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.get_n_items.html
	GetNItems func(Instance) int32
	// // IsMutable allows you to override the implementation of the virtual method is_mutable.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.is_mutable.html
	IsMutable func(Instance) bool
	// // IterateItemAttributes allows you to override the implementation of the virtual method iterate_item_attributes.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_attributes.html
	IterateItemAttributes func(Instance, int32) MenuAttributeIter
	// // IterateItemLinks allows you to override the implementation of the virtual method iterate_item_links.
	// 
	// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_links.html
	IterateItemLinks func(Instance, int32) MenuLinkIter
}

// UnsafeApplyMenuModelOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuModelOverrides[Instance MenuModel](gclass unsafe.Pointer, overrides MenuModelOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMenuModelClass)(gclass)

	if overrides.GetItemLink != nil {
		pclass.get_item_link = (*[0]byte)(C._goglib_gio2_MenuModel_get_item_link)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_get_item_link",
			func(carg0 *C.GMenuModel, carg1 C.gint, carg2 *C.gchar) (cret *C.GMenuModel) {
				var model     Instance  // go GMenuModel subclass
				var itemIndex int32     // in, none, casted
				var link      string    // in, none, string
				var goret     MenuModel // return, full, converted, nullable

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)
				link = C.GoString((*C.char)(unsafe.Pointer(carg2)))

				goret = overrides.GetItemLink(model, itemIndex, link)

				if goret != nil {
					cret = (*C.GMenuModel)(UnsafeMenuModelToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetNItems != nil {
		pclass.get_n_items = (*[0]byte)(C._goglib_gio2_MenuModel_get_n_items)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_get_n_items",
			func(carg0 *C.GMenuModel) (cret C.gint) {
				var model Instance // go GMenuModel subclass
				var goret int32    // return, none, casted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNItems(model)

				cret = C.gint(goret)

				return cret
			},
		)
	}

	if overrides.IsMutable != nil {
		pclass.is_mutable = (*[0]byte)(C._goglib_gio2_MenuModel_is_mutable)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_is_mutable",
			func(carg0 *C.GMenuModel) (cret C.gboolean) {
				var model Instance // go GMenuModel subclass
				var goret bool     // return

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.IsMutable(model)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.IterateItemAttributes != nil {
		pclass.iterate_item_attributes = (*[0]byte)(C._goglib_gio2_MenuModel_iterate_item_attributes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_iterate_item_attributes",
			func(carg0 *C.GMenuModel, carg1 C.gint) (cret *C.GMenuAttributeIter) {
				var model     Instance          // go GMenuModel subclass
				var itemIndex int32             // in, none, casted
				var goret     MenuAttributeIter // return, full, converted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)

				goret = overrides.IterateItemAttributes(model, itemIndex)

				cret = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.IterateItemLinks != nil {
		pclass.iterate_item_links = (*[0]byte)(C._goglib_gio2_MenuModel_iterate_item_links)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_iterate_item_links",
			func(carg0 *C.GMenuModel, carg1 C.gint) (cret *C.GMenuLinkIter) {
				var model     Instance     // go GMenuModel subclass
				var itemIndex int32        // in, none, casted
				var goret     MenuLinkIter // return, full, converted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)

				goret = overrides.IterateItemLinks(model, itemIndex)

				cret = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibFull(goret))

				return cret
			},
		)
	}
}

// ParentGetItemLink calls the default implementations of the `GMenuModel.get_item_link` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuModel.get_item_link.html
func (model *MenuModelInstance) ParentGetItemLink(itemIndex int32, link string) MenuModel {
	var carg0 *C.GMenuModel
	var carg1 C.gint        // in, none, converted
	var carg2 *C.gchar      // in, none, casted
	var cret  *C.GMenuModel // return, full, converted, nullable

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C._goglib_gio2_MenuModel_virtual_get_item_link(unsafe.Pointer(parentclass.get_item_link), carg0, carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetNItems calls the default implementations of the `GMenuModel.get_n_items` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuModel.get_n_items.html
func (model *MenuModelInstance) ParentGetNItems() int32 {
	var carg0 *C.GMenuModel
	var cret  C.gint // return, none, casted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C._goglib_gio2_MenuModel_virtual_get_n_items(unsafe.Pointer(parentclass.get_n_items), carg0)
	runtime.KeepAlive(model)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentIsMutable calls the default implementations of the `GMenuModel.is_mutable` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuModel.is_mutable.html
func (model *MenuModelInstance) ParentIsMutable() bool {
	var carg0 *C.GMenuModel
	var cret  C.gboolean // return

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C._goglib_gio2_MenuModel_virtual_is_mutable(unsafe.Pointer(parentclass.is_mutable), carg0)
	runtime.KeepAlive(model)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentIterateItemAttributes calls the default implementations of the `GMenuModel.iterate_item_attributes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_attributes.html
func (model *MenuModelInstance) ParentIterateItemAttributes(itemIndex int32) MenuAttributeIter {
	var carg0 *C.GMenuModel
	var carg1 C.gint                // in, none, converted
	var cret  *C.GMenuAttributeIter // return, full, converted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C._goglib_gio2_MenuModel_virtual_iterate_item_attributes(unsafe.Pointer(parentclass.iterate_item_attributes), carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuAttributeIter

	goret = UnsafeMenuAttributeIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentIterateItemLinks calls the default implementations of the `GMenuModel.iterate_item_links` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MenuModel.iterate_item_links.html
func (model *MenuModelInstance) ParentIterateItemLinks(itemIndex int32) MenuLinkIter {
	var carg0 *C.GMenuModel
	var carg1 C.gint           // in, none, converted
	var cret  *C.GMenuLinkIter // return, full, converted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C._goglib_gio2_MenuModel_virtual_iterate_item_links(unsafe.Pointer(parentclass.iterate_item_links), carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuLinkIter

	goret = UnsafeMenuLinkIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterMenuModelSubClass is used to register a go subclass of GMenuModel. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuModelSubClass[InstanceT MenuModel](
		name string,
		classInit func(class *MenuModelClass),
		constructor func() InstanceT,
		overrides MenuModelOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuModel,
		UnsafeMenuModelClassFromGlibBorrow,
		UnsafeApplyMenuModelOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuModel(obj)
		},
		interfaceInits...,
	)
}

// MountOperationInstance is the instance type used by all types extending GMountOperation. It is used internally by the bindings. Users should use the interface [MountOperation] instead.
type MountOperationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MountOperation = (*MountOperationInstance)(nil)

// MountOperation wraps GMountOperation
// 
// see also https://docs.gtk.org/gio/class.MountOperation.html
//
type MountOperation interface {
	gobject.Object
	upcastToGMountOperation() *MountOperationInstance

	// GetAnonymous wraps g_mount_operation_get_anonymous
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_anonymous.g_mount_operation_get_anonymous.html
	//
	GetAnonymous() bool
	// GetChoice wraps g_mount_operation_get_choice
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_choice.g_mount_operation_get_choice.html
	//
	GetChoice() int32
	// GetDomain wraps g_mount_operation_get_domain
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_domain.g_mount_operation_get_domain.html
	//
	GetDomain() string
	// GetIsTcryptHiddenVolume wraps g_mount_operation_get_is_tcrypt_hidden_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_is_tcrypt_hidden_volume.g_mount_operation_get_is_tcrypt_hidden_volume.html
	//
	GetIsTcryptHiddenVolume() bool
	// GetIsTcryptSystemVolume wraps g_mount_operation_get_is_tcrypt_system_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_is_tcrypt_system_volume.g_mount_operation_get_is_tcrypt_system_volume.html
	//
	GetIsTcryptSystemVolume() bool
	// GetPassword wraps g_mount_operation_get_password
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_password.g_mount_operation_get_password.html
	//
	GetPassword() string
	// GetPasswordSave wraps g_mount_operation_get_password_save
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_password_save.g_mount_operation_get_password_save.html
	//
	GetPasswordSave() PasswordSave
	// GetPim wraps g_mount_operation_get_pim
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_pim.g_mount_operation_get_pim.html
	//
	GetPim() uint
	// GetUsername wraps g_mount_operation_get_username
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_get_username.g_mount_operation_get_username.html
	//
	GetUsername() string
	// Reply wraps g_mount_operation_reply
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_reply.g_mount_operation_reply.html
	//
	Reply(MountOperationResult)
	// SetAnonymous wraps g_mount_operation_set_anonymous
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_anonymous.g_mount_operation_set_anonymous.html
	//
	SetAnonymous(bool)
	// SetChoice wraps g_mount_operation_set_choice
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_choice.g_mount_operation_set_choice.html
	//
	SetChoice(int32)
	// SetDomain wraps g_mount_operation_set_domain
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_domain.g_mount_operation_set_domain.html
	//
	SetDomain(string)
	// SetIsTcryptHiddenVolume wraps g_mount_operation_set_is_tcrypt_hidden_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_is_tcrypt_hidden_volume.g_mount_operation_set_is_tcrypt_hidden_volume.html
	//
	SetIsTcryptHiddenVolume(bool)
	// SetIsTcryptSystemVolume wraps g_mount_operation_set_is_tcrypt_system_volume
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_is_tcrypt_system_volume.g_mount_operation_set_is_tcrypt_system_volume.html
	//
	SetIsTcryptSystemVolume(bool)
	// SetPassword wraps g_mount_operation_set_password
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_password.g_mount_operation_set_password.html
	//
	SetPassword(string)
	// SetPasswordSave wraps g_mount_operation_set_password_save
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_password_save.g_mount_operation_set_password_save.html
	//
	SetPasswordSave(PasswordSave)
	// SetPim wraps g_mount_operation_set_pim
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_pim.g_mount_operation_set_pim.html
	//
	SetPim(uint)
	// SetUsername wraps g_mount_operation_set_username
	// 
	// see also https://docs.gtk.org/gio/method.g_mount_operation_set_username.g_mount_operation_set_username.html
	//
	SetUsername(string)
	// ConnectAborted connects the provided callback to the "aborted" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MountOperation.aborted.html
	//
	ConnectAborted(func(MountOperation)) gobject.SignalHandle
	// ConnectAskPassword connects the provided callback to the "ask-password" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MountOperation.ask-password.html
	//
	ConnectAskPassword(func(MountOperation, string, string, string, AskPasswordFlags)) gobject.SignalHandle
	// ConnectReply connects the provided callback to the "reply" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MountOperation.reply.html
	//
	ConnectReply(func(MountOperation, MountOperationResult)) gobject.SignalHandle
	// ConnectShowUnmountProgress connects the provided callback to the "show-unmount-progress" signal
	// 
	// see also https://docs.gtk.org/gio/signal.MountOperation.show-unmount-progress.html
	//
	ConnectShowUnmountProgress(func(MountOperation, string, int64, int64)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentAborted calls the default implementations of the `GMountOperation.aborted` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.aborted.html
	ParentAborted()
	// ParentAskPassword calls the default implementations of the `GMountOperation.ask_password` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.ask_password.html
	ParentAskPassword(message string, defaultUser string, defaultDomain string, flags AskPasswordFlags)
	// ParentAskQuestion calls the default implementations of the `GMountOperation.ask_question` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.ask_question.html
	ParentAskQuestion(message string, choices []string)
	// ParentReply calls the default implementations of the `GMountOperation.reply` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.reply.html
	ParentReply(result MountOperationResult)
	// ParentShowUnmountProgress calls the default implementations of the `GMountOperation.show_unmount_progress` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.show_unmount_progress.html
	ParentShowUnmountProgress(message string, timeLeft int64, bytesLeft int64)
}

func unsafeWrapMountOperation(base *gobject.ObjectInstance) *MountOperationInstance {
	return &MountOperationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMountOperation,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMountOperation(inst)
		},
	)
}

func marshalMountOperationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMountOperationFromGlibNone is used to convert raw GMountOperation pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMountOperationFromGlibNone(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibNone(c).(MountOperation)
}

// UnsafeMountOperationFromGlibFull is used to convert raw GMountOperation pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMountOperationFromGlibFull(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibFull(c).(MountOperation)
}

// UnsafeMountOperationFromGlibBorrow is used to convert raw GMountOperation pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMountOperationFromGlibBorrow(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MountOperation)
}

func (m *MountOperationInstance) upcastToGMountOperation() *MountOperationInstance {
	return m
}

// UnsafeMountOperationToGlibNone is used to convert the instance to it's C value GMountOperation. This is used by the bindings internally.
func UnsafeMountOperationToGlibNone(c MountOperation) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMountOperationToGlibFull is used to convert the instance to it's C value GMountOperation, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMountOperationToGlibFull(c MountOperation) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMountOperation wraps g_mount_operation_new
// 
// see also https://docs.gtk.org/gio/func.g_mount_operation_new.html
//
func NewMountOperation() MountOperation {
	var cret *C.GMountOperation // return, full, converted

	cret = C.g_mount_operation_new()

	var goret MountOperation

	goret = UnsafeMountOperationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAnonymous wraps g_mount_operation_get_anonymous
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_anonymous.g_mount_operation_get_anonymous.html
//
func (op *MountOperationInstance) GetAnonymous() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_anonymous(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetChoice wraps g_mount_operation_get_choice
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_choice.g_mount_operation_get_choice.html
//
func (op *MountOperationInstance) GetChoice() int32 {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.int              // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_choice(carg0)
	runtime.KeepAlive(op)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetDomain wraps g_mount_operation_get_domain
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_domain.g_mount_operation_get_domain.html
//
func (op *MountOperationInstance) GetDomain() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_domain(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetIsTcryptHiddenVolume wraps g_mount_operation_get_is_tcrypt_hidden_volume
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_is_tcrypt_hidden_volume.g_mount_operation_get_is_tcrypt_hidden_volume.html
//
func (op *MountOperationInstance) GetIsTcryptHiddenVolume() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_is_tcrypt_hidden_volume(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsTcryptSystemVolume wraps g_mount_operation_get_is_tcrypt_system_volume
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_is_tcrypt_system_volume.g_mount_operation_get_is_tcrypt_system_volume.html
//
func (op *MountOperationInstance) GetIsTcryptSystemVolume() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_is_tcrypt_system_volume(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetPassword wraps g_mount_operation_get_password
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_password.g_mount_operation_get_password.html
//
func (op *MountOperationInstance) GetPassword() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_password(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPasswordSave wraps g_mount_operation_get_password_save
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_password_save.g_mount_operation_get_password_save.html
//
func (op *MountOperationInstance) GetPasswordSave() PasswordSave {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.GPasswordSave    // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_password_save(carg0)
	runtime.KeepAlive(op)

	var goret PasswordSave

	goret = PasswordSave(cret)

	return goret
}

// GetPim wraps g_mount_operation_get_pim
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_pim.g_mount_operation_get_pim.html
//
func (op *MountOperationInstance) GetPim() uint {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.guint            // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_pim(carg0)
	runtime.KeepAlive(op)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUsername wraps g_mount_operation_get_username
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_get_username.g_mount_operation_get_username.html
//
func (op *MountOperationInstance) GetUsername() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_username(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Reply wraps g_mount_operation_reply
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_reply.g_mount_operation_reply.html
//
func (op *MountOperationInstance) Reply(result MountOperationResult) {
	var carg0 *C.GMountOperation      // in, none, converted
	var carg1 C.GMountOperationResult // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GMountOperationResult(result)

	C.g_mount_operation_reply(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// SetAnonymous wraps g_mount_operation_set_anonymous
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_anonymous.g_mount_operation_set_anonymous.html
//
func (op *MountOperationInstance) SetAnonymous(anonymous bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if anonymous {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_anonymous(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(anonymous)
}

// SetChoice wraps g_mount_operation_set_choice
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_choice.g_mount_operation_set_choice.html
//
func (op *MountOperationInstance) SetChoice(choice int32) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.int              // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.int(choice)

	C.g_mount_operation_set_choice(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(choice)
}

// SetDomain wraps g_mount_operation_set_domain
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_domain.g_mount_operation_set_domain.html
//
func (op *MountOperationInstance) SetDomain(domain string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if domain != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_domain(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(domain)
}

// SetIsTcryptHiddenVolume wraps g_mount_operation_set_is_tcrypt_hidden_volume
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_is_tcrypt_hidden_volume.g_mount_operation_set_is_tcrypt_hidden_volume.html
//
func (op *MountOperationInstance) SetIsTcryptHiddenVolume(hiddenVolume bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if hiddenVolume {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_hidden_volume(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(hiddenVolume)
}

// SetIsTcryptSystemVolume wraps g_mount_operation_set_is_tcrypt_system_volume
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_is_tcrypt_system_volume.g_mount_operation_set_is_tcrypt_system_volume.html
//
func (op *MountOperationInstance) SetIsTcryptSystemVolume(systemVolume bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if systemVolume {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_system_volume(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(systemVolume)
}

// SetPassword wraps g_mount_operation_set_password
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_password.g_mount_operation_set_password.html
//
func (op *MountOperationInstance) SetPassword(password string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if password != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_password(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(password)
}

// SetPasswordSave wraps g_mount_operation_set_password_save
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_password_save.g_mount_operation_set_password_save.html
//
func (op *MountOperationInstance) SetPasswordSave(save PasswordSave) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.GPasswordSave    // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GPasswordSave(save)

	C.g_mount_operation_set_password_save(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(save)
}

// SetPim wraps g_mount_operation_set_pim
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_pim.g_mount_operation_set_pim.html
//
func (op *MountOperationInstance) SetPim(pim uint) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.guint            // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.guint(pim)

	C.g_mount_operation_set_pim(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(pim)
}

// SetUsername wraps g_mount_operation_set_username
// 
// see also https://docs.gtk.org/gio/method.g_mount_operation_set_username.g_mount_operation_set_username.html
//
func (op *MountOperationInstance) SetUsername(username string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if username != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_username(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(username)
}

// ConnectAborted connects the provided callback to the "aborted" signal
// 
// see also https://docs.gtk.org/gio/signal.MountOperation.aborted.html
//
func (o *MountOperationInstance) ConnectAborted(fn func(MountOperation)) gobject.SignalHandle {
	return o.Connect("aborted", fn)
}

// ConnectAskPassword connects the provided callback to the "ask-password" signal
// 
// see also https://docs.gtk.org/gio/signal.MountOperation.ask-password.html
//
func (o *MountOperationInstance) ConnectAskPassword(fn func(MountOperation, string, string, string, AskPasswordFlags)) gobject.SignalHandle {
	return o.Connect("ask-password", fn)
}

// ConnectReply connects the provided callback to the "reply" signal
// 
// see also https://docs.gtk.org/gio/signal.MountOperation.reply.html
//
func (o *MountOperationInstance) ConnectReply(fn func(MountOperation, MountOperationResult)) gobject.SignalHandle {
	return o.Connect("reply", fn)
}

// ConnectShowUnmountProgress connects the provided callback to the "show-unmount-progress" signal
// 
// see also https://docs.gtk.org/gio/signal.MountOperation.show-unmount-progress.html
//
func (o *MountOperationInstance) ConnectShowUnmountProgress(fn func(MountOperation, string, int64, int64)) gobject.SignalHandle {
	return o.Connect("show-unmount-progress", fn)
}

// MountOperationOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MountOperationOverrides[Instance MountOperation] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Aborted allows you to override the implementation of the virtual method aborted.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.aborted.html
	Aborted func(Instance)
	// // AskPassword allows you to override the implementation of the virtual method ask_password.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.ask_password.html
	AskPassword func(Instance, string, string, string, AskPasswordFlags)
	// // AskQuestion allows you to override the implementation of the virtual method ask_question.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.ask_question.html
	AskQuestion func(Instance, string, []string)
	// // Reply allows you to override the implementation of the virtual method reply.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.reply.html
	Reply func(Instance, MountOperationResult)
	// // ShowUnmountProgress allows you to override the implementation of the virtual method show_unmount_progress.
	// 
	// see also https://docs.gtk.org/gio/method.MountOperation.show_unmount_progress.html
	ShowUnmountProgress func(Instance, string, int64, int64)
}

// UnsafeApplyMountOperationOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMountOperationOverrides[Instance MountOperation](gclass unsafe.Pointer, overrides MountOperationOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMountOperationClass)(gclass)

	if overrides.Aborted != nil {
		pclass.aborted = (*[0]byte)(C._goglib_gio2_MountOperation_aborted)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_aborted",
			func(carg0 *C.GMountOperation) {
				var op Instance // go GMountOperation subclass

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Aborted(op)
			},
		)
	}

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._goglib_gio2_MountOperation_ask_password)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_ask_password",
			func(carg0 *C.GMountOperation, carg1 *C.char, carg2 *C.char, carg3 *C.char, carg4 C.GAskPasswordFlags) {
				var op            Instance         // go GMountOperation subclass
				var message       string           // in, none, string
				var defaultUser   string           // in, none, string
				var defaultDomain string           // in, none, string
				var flags         AskPasswordFlags // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				defaultUser = C.GoString((*C.char)(unsafe.Pointer(carg2)))
				defaultDomain = C.GoString((*C.char)(unsafe.Pointer(carg3)))
				flags = AskPasswordFlags(carg4)

				overrides.AskPassword(op, message, defaultUser, defaultDomain, flags)
			},
		)
	}

	if overrides.AskQuestion != nil {
		pclass.ask_question = (*[0]byte)(C._goglib_gio2_MountOperation_ask_question)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_ask_question",
			func(carg0 *C.GMountOperation, carg1 *C.char, carg2 **C.char) {
				var op      Instance // go GMountOperation subclass
				var message string   // in, none, string
				var choices []string // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				_ = choices
				_ = carg2
				panic("unimplemented conversion of []string (const char**) because of unknown reason")

				overrides.AskQuestion(op, message, choices)
			},
		)
	}

	if overrides.Reply != nil {
		pclass.reply = (*[0]byte)(C._goglib_gio2_MountOperation_reply)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_reply",
			func(carg0 *C.GMountOperation, carg1 C.GMountOperationResult) {
				var op     Instance             // go GMountOperation subclass
				var result MountOperationResult // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = MountOperationResult(carg1)

				overrides.Reply(op, result)
			},
		)
	}

	if overrides.ShowUnmountProgress != nil {
		pclass.show_unmount_progress = (*[0]byte)(C._goglib_gio2_MountOperation_show_unmount_progress)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_show_unmount_progress",
			func(carg0 *C.GMountOperation, carg1 *C.gchar, carg2 C.gint64, carg3 C.gint64) {
				var op        Instance // go GMountOperation subclass
				var message   string   // in, none, string
				var timeLeft  int64    // in, none, casted
				var bytesLeft int64    // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				timeLeft = int64(carg2)
				bytesLeft = int64(carg3)

				overrides.ShowUnmountProgress(op, message, timeLeft, bytesLeft)
			},
		)
	}
}

// ParentAborted calls the default implementations of the `GMountOperation.aborted` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MountOperation.aborted.html
func (op *MountOperationInstance) ParentAborted() {
	var carg0 *C.GMountOperation

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	C._goglib_gio2_MountOperation_virtual_aborted(unsafe.Pointer(parentclass.aborted), carg0)
	runtime.KeepAlive(op)
}

// ParentAskPassword calls the default implementations of the `GMountOperation.ask_password` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MountOperation.ask_password.html
func (op *MountOperationInstance) ParentAskPassword(message string, defaultUser string, defaultDomain string, flags AskPasswordFlags) {
	var carg0 *C.GMountOperation
	var carg1 *C.char             // in, none, converted
	var carg2 *C.char             // in, none, string
	var carg3 *C.char             // in, none, string
	var carg4 C.GAskPasswordFlags // in, none, string

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(defaultUser)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.char)(unsafe.Pointer(C.CString(defaultDomain)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.GAskPasswordFlags(flags)

	C._goglib_gio2_MountOperation_virtual_ask_password(unsafe.Pointer(parentclass.ask_password), carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(defaultUser)
	runtime.KeepAlive(defaultDomain)
	runtime.KeepAlive(flags)
}

// ParentAskQuestion calls the default implementations of the `GMountOperation.ask_question` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MountOperation.ask_question.html
func (op *MountOperationInstance) ParentAskQuestion(message string, choices []string) {
	var carg0 *C.GMountOperation
	var carg1 *C.char  // in, none, converted
	var carg2 **C.char // in, none, string

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	_ = choices
	_ = carg2
	panic("unimplemented conversion of []string (const char**) because of unimplemented: inner pointers in array")

	C._goglib_gio2_MountOperation_virtual_ask_question(unsafe.Pointer(parentclass.ask_question), carg0, carg1, carg2)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(choices)
}

// ParentReply calls the default implementations of the `GMountOperation.reply` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MountOperation.reply.html
func (op *MountOperationInstance) ParentReply(result MountOperationResult) {
	var carg0 *C.GMountOperation
	var carg1 C.GMountOperationResult // in, none, converted

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GMountOperationResult(result)

	C._goglib_gio2_MountOperation_virtual_reply(unsafe.Pointer(parentclass.reply), carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// ParentShowUnmountProgress calls the default implementations of the `GMountOperation.show_unmount_progress` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.MountOperation.show_unmount_progress.html
func (op *MountOperationInstance) ParentShowUnmountProgress(message string, timeLeft int64, bytesLeft int64) {
	var carg0 *C.GMountOperation
	var carg1 *C.gchar // in, none, converted
	var carg2 C.gint64 // in, none, string
	var carg3 C.gint64 // in, none, casted

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(timeLeft)
	carg3 = C.gint64(bytesLeft)

	C._goglib_gio2_MountOperation_virtual_show_unmount_progress(unsafe.Pointer(parentclass.show_unmount_progress), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(timeLeft)
	runtime.KeepAlive(bytesLeft)
}

// RegisterMountOperationSubClass is used to register a go subclass of GMountOperation. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMountOperationSubClass[InstanceT MountOperation](
		name string,
		classInit func(class *MountOperationClass),
		constructor func() InstanceT,
		overrides MountOperationOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMountOperation,
		UnsafeMountOperationClassFromGlibBorrow,
		UnsafeApplyMountOperationOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMountOperation(obj)
		},
		interfaceInits...,
	)
}

// NetworkAddressInstance is the instance type used by all types extending GNetworkAddress. It is used internally by the bindings. Users should use the interface [NetworkAddress] instead.
type NetworkAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ NetworkAddress = (*NetworkAddressInstance)(nil)

// NetworkAddress wraps GNetworkAddress
// 
// see also https://docs.gtk.org/gio/class.NetworkAddress.html
//
type NetworkAddress interface {
	gobject.Object
	upcastToGNetworkAddress() *NetworkAddressInstance

	// GetHostname wraps g_network_address_get_hostname
	// 
	// see also https://docs.gtk.org/gio/method.g_network_address_get_hostname.g_network_address_get_hostname.html
	//
	GetHostname() string
	// GetPort wraps g_network_address_get_port
	// 
	// see also https://docs.gtk.org/gio/method.g_network_address_get_port.g_network_address_get_port.html
	//
	GetPort() uint16
	// GetScheme wraps g_network_address_get_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_network_address_get_scheme.g_network_address_get_scheme.html
	//
	GetScheme() string

	// chain up virtual methods:
}

func unsafeWrapNetworkAddress(base *gobject.ObjectInstance) *NetworkAddressInstance {
	return &NetworkAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNetworkAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkAddress(inst)
		},
	)
}

func marshalNetworkAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNetworkAddressFromGlibNone is used to convert raw GNetworkAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibNone(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkAddress)
}

// UnsafeNetworkAddressFromGlibFull is used to convert raw GNetworkAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibFull(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkAddress)
}

// UnsafeNetworkAddressFromGlibBorrow is used to convert raw GNetworkAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibBorrow(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkAddress)
}

func (n *NetworkAddressInstance) upcastToGNetworkAddress() *NetworkAddressInstance {
	return n
}

// UnsafeNetworkAddressToGlibNone is used to convert the instance to it's C value GNetworkAddress. This is used by the bindings internally.
func UnsafeNetworkAddressToGlibNone(c NetworkAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNetworkAddressToGlibFull is used to convert the instance to it's C value GNetworkAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressToGlibFull(c NetworkAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNetworkAddress wraps g_network_address_new
// 
// see also https://docs.gtk.org/gio/func.g_network_address_new.html
//
func NewNetworkAddress(hostname string, port uint16) NetworkAddress {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(port)

	cret = C.g_network_address_new(carg1, carg2)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)

	var goret NetworkAddress

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewNetworkAddressLoopback wraps g_network_address_new_loopback
// 
// see also https://docs.gtk.org/gio/func.g_network_address_new_loopback.html
//
func NewNetworkAddressLoopback(port uint16) NetworkAddress {
	var carg1 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = C.guint16(port)

	cret = C.g_network_address_new_loopback(carg1)
	runtime.KeepAlive(port)

	var goret NetworkAddress

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NetworkAddressParse wraps g_network_address_parse
// 
// see also https://docs.gtk.org/gio/func.g_network_address_parse.html
//
func NetworkAddressParse(hostAndPort string, defaultPort uint16) (NetworkAddress, error) {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)

	cret = C.g_network_address_parse(carg1, carg2, &_cerr)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)

	var goret  NetworkAddress
	var _goerr error

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NetworkAddressParseURI wraps g_network_address_parse_uri
// 
// see also https://docs.gtk.org/gio/func.g_network_address_parse_uri.html
//
func NetworkAddressParseURI(uri string, defaultPort uint16) (NetworkAddress, error) {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)

	cret = C.g_network_address_parse_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)

	var goret  NetworkAddress
	var _goerr error

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetHostname wraps g_network_address_get_hostname
// 
// see also https://docs.gtk.org/gio/method.g_network_address_get_hostname.g_network_address_get_hostname.html
//
func (addr *NetworkAddressInstance) GetHostname() string {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_hostname(carg0)
	runtime.KeepAlive(addr)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_network_address_get_port
// 
// see also https://docs.gtk.org/gio/method.g_network_address_get_port.g_network_address_get_port.html
//
func (addr *NetworkAddressInstance) GetPort() uint16 {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  C.guint16          // return, none, casted

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_port(carg0)
	runtime.KeepAlive(addr)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetScheme wraps g_network_address_get_scheme
// 
// see also https://docs.gtk.org/gio/method.g_network_address_get_scheme.g_network_address_get_scheme.html
//
func (addr *NetworkAddressInstance) GetScheme() string {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_scheme(carg0)
	runtime.KeepAlive(addr)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// NetworkAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NetworkAddressOverrides[Instance NetworkAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyNetworkAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNetworkAddressOverrides[Instance NetworkAddress](gclass unsafe.Pointer, overrides NetworkAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterNetworkAddressSubClass is used to register a go subclass of GNetworkAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNetworkAddressSubClass[InstanceT NetworkAddress](
		name string,
		classInit func(class *NetworkAddressClass),
		constructor func() InstanceT,
		overrides NetworkAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNetworkAddress,
		UnsafeNetworkAddressClassFromGlibBorrow,
		UnsafeApplyNetworkAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkAddress(obj)
		},
		interfaceInits...,
	)
}

// NetworkServiceInstance is the instance type used by all types extending GNetworkService. It is used internally by the bindings. Users should use the interface [NetworkService] instead.
type NetworkServiceInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ NetworkService = (*NetworkServiceInstance)(nil)

// NetworkService wraps GNetworkService
// 
// see also https://docs.gtk.org/gio/class.NetworkService.html
//
type NetworkService interface {
	gobject.Object
	upcastToGNetworkService() *NetworkServiceInstance

	// GetDomain wraps g_network_service_get_domain
	// 
	// see also https://docs.gtk.org/gio/method.g_network_service_get_domain.g_network_service_get_domain.html
	//
	GetDomain() string
	// GetProtocol wraps g_network_service_get_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_network_service_get_protocol.g_network_service_get_protocol.html
	//
	GetProtocol() string
	// GetScheme wraps g_network_service_get_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_network_service_get_scheme.g_network_service_get_scheme.html
	//
	GetScheme() string
	// GetService wraps g_network_service_get_service
	// 
	// see also https://docs.gtk.org/gio/method.g_network_service_get_service.g_network_service_get_service.html
	//
	GetService() string
	// SetScheme wraps g_network_service_set_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_network_service_set_scheme.g_network_service_set_scheme.html
	//
	SetScheme(string)

	// chain up virtual methods:
}

func unsafeWrapNetworkService(base *gobject.ObjectInstance) *NetworkServiceInstance {
	return &NetworkServiceInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNetworkService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkService(inst)
		},
	)
}

func marshalNetworkServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNetworkServiceFromGlibNone is used to convert raw GNetworkService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibNone(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkService)
}

// UnsafeNetworkServiceFromGlibFull is used to convert raw GNetworkService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibFull(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkService)
}

// UnsafeNetworkServiceFromGlibBorrow is used to convert raw GNetworkService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibBorrow(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkService)
}

func (n *NetworkServiceInstance) upcastToGNetworkService() *NetworkServiceInstance {
	return n
}

// UnsafeNetworkServiceToGlibNone is used to convert the instance to it's C value GNetworkService. This is used by the bindings internally.
func UnsafeNetworkServiceToGlibNone(c NetworkService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNetworkServiceToGlibFull is used to convert the instance to it's C value GNetworkService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceToGlibFull(c NetworkService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNetworkService wraps g_network_service_new
// 
// see also https://docs.gtk.org/gio/func.g_network_service_new.html
//
func NewNetworkService(service string, protocol string, domain string) NetworkService {
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.gchar              // in, none, string
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_network_service_new(carg1, carg2, carg3)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var goret NetworkService

	goret = UnsafeNetworkServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDomain wraps g_network_service_get_domain
// 
// see also https://docs.gtk.org/gio/method.g_network_service_get_domain.g_network_service_get_domain.html
//
func (srv *NetworkServiceInstance) GetDomain() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_domain(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetProtocol wraps g_network_service_get_protocol
// 
// see also https://docs.gtk.org/gio/method.g_network_service_get_protocol.g_network_service_get_protocol.html
//
func (srv *NetworkServiceInstance) GetProtocol() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_protocol(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetScheme wraps g_network_service_get_scheme
// 
// see also https://docs.gtk.org/gio/method.g_network_service_get_scheme.g_network_service_get_scheme.html
//
func (srv *NetworkServiceInstance) GetScheme() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_scheme(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetService wraps g_network_service_get_service
// 
// see also https://docs.gtk.org/gio/method.g_network_service_get_service.g_network_service_get_service.html
//
func (srv *NetworkServiceInstance) GetService() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_service(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetScheme wraps g_network_service_set_scheme
// 
// see also https://docs.gtk.org/gio/method.g_network_service_set_scheme.g_network_service_set_scheme.html
//
func (srv *NetworkServiceInstance) SetScheme(scheme string) {
	var carg0 *C.GNetworkService // in, none, converted
	var carg1 *C.gchar           // in, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_network_service_set_scheme(carg0, carg1)
	runtime.KeepAlive(srv)
	runtime.KeepAlive(scheme)
}

// NetworkServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NetworkServiceOverrides[Instance NetworkService] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyNetworkServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNetworkServiceOverrides[Instance NetworkService](gclass unsafe.Pointer, overrides NetworkServiceOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterNetworkServiceSubClass is used to register a go subclass of GNetworkService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNetworkServiceSubClass[InstanceT NetworkService](
		name string,
		classInit func(class *NetworkServiceClass),
		constructor func() InstanceT,
		overrides NetworkServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNetworkService,
		UnsafeNetworkServiceClassFromGlibBorrow,
		UnsafeApplyNetworkServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkService(obj)
		},
		interfaceInits...,
	)
}

// NotificationInstance is the instance type used by all types extending GNotification. It is used internally by the bindings. Users should use the interface [Notification] instead.
type NotificationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Notification = (*NotificationInstance)(nil)

// Notification wraps GNotification
// 
// see also https://docs.gtk.org/gio/class.Notification.html
//
type Notification interface {
	gobject.Object
	upcastToGNotification() *NotificationInstance

	// AddButton wraps g_notification_add_button
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_add_button.g_notification_add_button.html
	//
	AddButton(string, string)
	// SetBody wraps g_notification_set_body
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_body.g_notification_set_body.html
	//
	SetBody(string)
	// SetCategory wraps g_notification_set_category
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_category.g_notification_set_category.html
	//
	SetCategory(string)
	// SetDefaultAction wraps g_notification_set_default_action
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_default_action.g_notification_set_default_action.html
	//
	SetDefaultAction(string)
	// SetIcon wraps g_notification_set_icon
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_icon.g_notification_set_icon.html
	//
	SetIcon(Icon)
	// SetPriority wraps g_notification_set_priority
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_priority.g_notification_set_priority.html
	//
	SetPriority(NotificationPriority)
	// SetTitle wraps g_notification_set_title
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_title.g_notification_set_title.html
	//
	SetTitle(string)
	// SetUrgent wraps g_notification_set_urgent
	// 
	// see also https://docs.gtk.org/gio/method.g_notification_set_urgent.g_notification_set_urgent.html
	//
	//
	// Deprecated: (since 2.42.0) Since 2.42, this has been deprecated in favour of
	//    g_notification_set_priority().
	SetUrgent(bool)
}

func unsafeWrapNotification(base *gobject.ObjectInstance) *NotificationInstance {
	return &NotificationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNotification,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNotification(inst)
		},
	)
}

func marshalNotificationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNotificationFromGlibNone is used to convert raw GNotification pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNotificationFromGlibNone(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibNone(c).(Notification)
}

// UnsafeNotificationFromGlibFull is used to convert raw GNotification pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNotificationFromGlibFull(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibFull(c).(Notification)
}

// UnsafeNotificationFromGlibBorrow is used to convert raw GNotification pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNotificationFromGlibBorrow(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Notification)
}

func (n *NotificationInstance) upcastToGNotification() *NotificationInstance {
	return n
}

// UnsafeNotificationToGlibNone is used to convert the instance to it's C value GNotification. This is used by the bindings internally.
func UnsafeNotificationToGlibNone(c Notification) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNotificationToGlibFull is used to convert the instance to it's C value GNotification, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNotificationToGlibFull(c Notification) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNotification wraps g_notification_new
// 
// see also https://docs.gtk.org/gio/func.g_notification_new.html
//
func NewNotification(title string) Notification {
	var carg1 *C.gchar         // in, none, string
	var cret  *C.GNotification // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_notification_new(carg1)
	runtime.KeepAlive(title)

	var goret Notification

	goret = UnsafeNotificationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddButton wraps g_notification_add_button
// 
// see also https://docs.gtk.org/gio/method.g_notification_add_button.g_notification_add_button.html
//
func (notification *NotificationInstance) AddButton(label string, detailedAction string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_notification_add_button(carg0, carg1, carg2)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// SetBody wraps g_notification_set_body
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_body.g_notification_set_body.html
//
func (notification *NotificationInstance) SetBody(body string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if body != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(body)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_notification_set_body(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(body)
}

// SetCategory wraps g_notification_set_category
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_category.g_notification_set_category.html
//
func (notification *NotificationInstance) SetCategory(category string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if category != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_notification_set_category(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(category)
}

// SetDefaultAction wraps g_notification_set_default_action
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_default_action.g_notification_set_default_action.html
//
func (notification *NotificationInstance) SetDefaultAction(detailedAction string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_notification_set_default_action(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(detailedAction)
}

// SetIcon wraps g_notification_set_icon
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_icon.g_notification_set_icon.html
//
func (notification *NotificationInstance) SetIcon(icon Icon) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.GIcon         // in, none, converted

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_notification_set_icon(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(icon)
}

// SetPriority wraps g_notification_set_priority
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_priority.g_notification_set_priority.html
//
func (notification *NotificationInstance) SetPriority(priority NotificationPriority) {
	var carg0 *C.GNotification        // in, none, converted
	var carg1 C.GNotificationPriority // in, none, casted

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(priority)
}

// SetTitle wraps g_notification_set_title
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_title.g_notification_set_title.html
//
func (notification *NotificationInstance) SetTitle(title string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_notification_set_title(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(title)
}

// SetUrgent wraps g_notification_set_urgent
// 
// see also https://docs.gtk.org/gio/method.g_notification_set_urgent.g_notification_set_urgent.html
//
//
// Deprecated: (since 2.42.0) Since 2.42, this has been deprecated in favour of
//    g_notification_set_priority().
func (notification *NotificationInstance) SetUrgent(urgent bool) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if urgent {
		carg1 = C.TRUE
	}

	C.g_notification_set_urgent(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(urgent)
}

// OutputStreamInstance is the instance type used by all types extending GOutputStream. It is used internally by the bindings. Users should use the interface [OutputStream] instead.
type OutputStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ OutputStream = (*OutputStreamInstance)(nil)

// OutputStream wraps GOutputStream
// 
// see also https://docs.gtk.org/gio/class.OutputStream.html
//
type OutputStream interface {
	gobject.Object
	upcastToGOutputStream() *OutputStreamInstance

	// ClearPending wraps g_output_stream_clear_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_clear_pending.g_output_stream_clear_pending.html
	//
	ClearPending()
	// Close wraps g_output_stream_close
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_close.g_output_stream_close.html
	//
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_output_stream_close_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_close_async.g_output_stream_close_async.html
	//
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_output_stream_close_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_close_finish.g_output_stream_close_finish.html
	//
	CloseFinish(AsyncResult) (bool, error)
	// Flush wraps g_output_stream_flush
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_flush.g_output_stream_flush.html
	//
	Flush(Cancellable) (bool, error)
	// FlushAsync wraps g_output_stream_flush_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_flush_async.g_output_stream_flush_async.html
	//
	FlushAsync(int32, Cancellable, AsyncReadyCallback)
	// FlushFinish wraps g_output_stream_flush_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_flush_finish.g_output_stream_flush_finish.html
	//
	FlushFinish(AsyncResult) (bool, error)
	// HasPending wraps g_output_stream_has_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_has_pending.g_output_stream_has_pending.html
	//
	HasPending() bool
	// IsClosed wraps g_output_stream_is_closed
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_is_closed.g_output_stream_is_closed.html
	//
	IsClosed() bool
	// IsClosing wraps g_output_stream_is_closing
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_is_closing.g_output_stream_is_closing.html
	//
	IsClosing() bool
	// SetPending wraps g_output_stream_set_pending
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_set_pending.g_output_stream_set_pending.html
	//
	SetPending() (bool, error)
	// Splice wraps g_output_stream_splice
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_splice.g_output_stream_splice.html
	//
	Splice(InputStream, OutputStreamSpliceFlags, Cancellable) (int, error)
	// SpliceAsync wraps g_output_stream_splice_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_splice_async.g_output_stream_splice_async.html
	//
	SpliceAsync(InputStream, OutputStreamSpliceFlags, int32, Cancellable, AsyncReadyCallback)
	// SpliceFinish wraps g_output_stream_splice_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_splice_finish.g_output_stream_splice_finish.html
	//
	SpliceFinish(AsyncResult) (int, error)
	// Write wraps g_output_stream_write
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write.g_output_stream_write.html
	//
	Write([]byte, Cancellable) (int, error)
	// WriteAll wraps g_output_stream_write_all
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_all.g_output_stream_write_all.html
	//
	WriteAll([]byte, Cancellable) (uint, bool, error)
	// WriteAllAsync wraps g_output_stream_write_all_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_all_async.g_output_stream_write_all_async.html
	//
	WriteAllAsync([]byte, int32, Cancellable, AsyncReadyCallback)
	// WriteAllFinish wraps g_output_stream_write_all_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_all_finish.g_output_stream_write_all_finish.html
	//
	WriteAllFinish(AsyncResult) (uint, bool, error)
	// WriteAsync wraps g_output_stream_write_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_async.g_output_stream_write_async.html
	//
	WriteAsync([]byte, int32, Cancellable, AsyncReadyCallback)
	// WriteBytes wraps g_output_stream_write_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes.g_output_stream_write_bytes.html
	//
	WriteBytes(*glib.Bytes, Cancellable) (int, error)
	// WriteBytesAsync wraps g_output_stream_write_bytes_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes_async.g_output_stream_write_bytes_async.html
	//
	WriteBytesAsync(*glib.Bytes, int32, Cancellable, AsyncReadyCallback)
	// WriteBytesFinish wraps g_output_stream_write_bytes_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes_finish.g_output_stream_write_bytes_finish.html
	//
	WriteBytesFinish(AsyncResult) (int, error)
	// WriteFinish wraps g_output_stream_write_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_write_finish.g_output_stream_write_finish.html
	//
	WriteFinish(AsyncResult) (int, error)
	// Writev wraps g_output_stream_writev
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev.g_output_stream_writev.html
	//
	Writev([]OutputVector, Cancellable) (uint, bool, error)
	// WritevAll wraps g_output_stream_writev_all
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all.g_output_stream_writev_all.html
	//
	WritevAll([]OutputVector, Cancellable) (uint, bool, error)
	// WritevAllAsync wraps g_output_stream_writev_all_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all_async.g_output_stream_writev_all_async.html
	//
	WritevAllAsync([]OutputVector, int32, Cancellable, AsyncReadyCallback)
	// WritevAllFinish wraps g_output_stream_writev_all_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all_finish.g_output_stream_writev_all_finish.html
	//
	WritevAllFinish(AsyncResult) (uint, bool, error)
	// WritevAsync wraps g_output_stream_writev_async
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev_async.g_output_stream_writev_async.html
	//
	WritevAsync([]OutputVector, int32, Cancellable, AsyncReadyCallback)
	// WritevFinish wraps g_output_stream_writev_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_output_stream_writev_finish.g_output_stream_writev_finish.html
	//
	WritevFinish(AsyncResult) (uint, bool, error)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GOutputStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.close_finish.html
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GOutputStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.close_fn.html
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentFlush calls the default implementations of the `GOutputStream.flush` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.flush.html
	ParentFlush(cancellable Cancellable) (bool, error)
	// ParentFlushFinish calls the default implementations of the `GOutputStream.flush_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.flush_finish.html
	ParentFlushFinish(result AsyncResult) (bool, error)
	// ParentSplice calls the default implementations of the `GOutputStream.splice` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.splice.html
	ParentSplice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error)
	// ParentSpliceFinish calls the default implementations of the `GOutputStream.splice_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.splice_finish.html
	ParentSpliceFinish(result AsyncResult) (int, error)
	// ParentWriteFinish calls the default implementations of the `GOutputStream.write_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.write_finish.html
	ParentWriteFinish(result AsyncResult) (int, error)
	// ParentWriteFn calls the default implementations of the `GOutputStream.write_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.write_fn.html
	ParentWriteFn(buffer []byte, cancellable Cancellable) (int, error)
	// ParentWritevFinish calls the default implementations of the `GOutputStream.writev_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.writev_finish.html
	ParentWritevFinish(result AsyncResult) (uint, bool, error)
	// ParentWritevFn calls the default implementations of the `GOutputStream.writev_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.writev_fn.html
	ParentWritevFn(vectors []OutputVector, cancellable Cancellable) (uint, bool, error)
}

func unsafeWrapOutputStream(base *gobject.ObjectInstance) *OutputStreamInstance {
	return &OutputStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapOutputStream(inst)
		},
	)
}

func marshalOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeOutputStreamFromGlibNone is used to convert raw GOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibNone(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(OutputStream)
}

// UnsafeOutputStreamFromGlibFull is used to convert raw GOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibFull(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(OutputStream)
}

// UnsafeOutputStreamFromGlibBorrow is used to convert raw GOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibBorrow(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(OutputStream)
}

func (o *OutputStreamInstance) upcastToGOutputStream() *OutputStreamInstance {
	return o
}

// UnsafeOutputStreamToGlibNone is used to convert the instance to it's C value GOutputStream. This is used by the bindings internally.
func UnsafeOutputStreamToGlibNone(c OutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeOutputStreamToGlibFull is used to convert the instance to it's C value GOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeOutputStreamToGlibFull(c OutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ClearPending wraps g_output_stream_clear_pending
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_clear_pending.g_output_stream_clear_pending.html
//
func (stream *OutputStreamInstance) ClearPending() {
	var carg0 *C.GOutputStream // in, none, converted

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	C.g_output_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_output_stream_close
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_close.g_output_stream_close.html
//
func (stream *OutputStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_output_stream_close_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_close_async.g_output_stream_close_async.html
//
func (stream *OutputStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_output_stream_close_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_close_finish.g_output_stream_close_finish.html
//
func (stream *OutputStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Flush wraps g_output_stream_flush
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_flush.g_output_stream_flush.html
//
func (stream *OutputStreamInstance) Flush(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_flush(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FlushAsync wraps g_output_stream_flush_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_flush_async.g_output_stream_flush_async.html
//
func (stream *OutputStreamInstance) FlushAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_flush_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FlushFinish wraps g_output_stream_flush_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_flush_finish.g_output_stream_flush_finish.html
//
func (stream *OutputStreamInstance) FlushFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_flush_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasPending wraps g_output_stream_has_pending
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_has_pending.g_output_stream_has_pending.html
//
func (stream *OutputStreamInstance) HasPending() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_output_stream_is_closed
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_is_closed.g_output_stream_is_closed.html
//
func (stream *OutputStreamInstance) IsClosed() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosing wraps g_output_stream_is_closing
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_is_closing.g_output_stream_is_closing.html
//
func (stream *OutputStreamInstance) IsClosing() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_is_closing(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetPending wraps g_output_stream_set_pending
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_set_pending.g_output_stream_set_pending.html
//
func (stream *OutputStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Splice wraps g_output_stream_splice
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_splice.g_output_stream_splice.html
//
func (stream *OutputStreamInstance) Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream           // in, none, converted
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var cret  C.gssize                   // return, none, casted
	var _cerr *C.GError                  // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_splice(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpliceAsync wraps g_output_stream_splice_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_splice_async.g_output_stream_splice_async.html
//
func (stream *OutputStreamInstance) SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream           // in, none, converted
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, casted
	var carg3 C.int                      // in, none, casted
	var carg4 *C.GCancellable            // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback      // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                 // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_splice_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SpliceFinish wraps g_output_stream_splice_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_splice_finish.g_output_stream_splice_finish.html
//
func (stream *OutputStreamInstance) SpliceFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_splice_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Write wraps g_output_stream_write
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write.g_output_stream_write.html
//
func (stream *OutputStreamInstance) Write(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteAll wraps g_output_stream_write_all
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_all.g_output_stream_write_all.html
//
func (stream *OutputStreamInstance) WriteAll(buffer []byte, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write_all(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WriteAllAsync wraps g_output_stream_write_all_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_all_async.g_output_stream_write_all_async.html
//
func (stream *OutputStreamInstance) WriteAllAsync(buffer []byte, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 unsafe.Pointer        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_all_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteAllFinish wraps g_output_stream_write_all_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_all_finish.g_output_stream_write_all_finish.html
//
func (stream *OutputStreamInstance) WriteAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WriteAsync wraps g_output_stream_write_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_async.g_output_stream_write_async.html
//
func (stream *OutputStreamInstance) WriteAsync(buffer []byte, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 unsafe.Pointer        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteBytes wraps g_output_stream_write_bytes
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes.g_output_stream_write_bytes.html
//
func (stream *OutputStreamInstance) WriteBytes(bytes *glib.Bytes, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GBytes        // in, none, converted
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteBytesAsync wraps g_output_stream_write_bytes_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes_async.g_output_stream_write_bytes_async.html
//
func (stream *OutputStreamInstance) WriteBytesAsync(bytes *glib.Bytes, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GBytes             // in, none, converted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteBytesFinish wraps g_output_stream_write_bytes_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_bytes_finish.g_output_stream_write_bytes_finish.html
//
func (stream *OutputStreamInstance) WriteBytesFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_bytes_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteFinish wraps g_output_stream_write_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_write_finish.g_output_stream_write_finish.html
//
func (stream *OutputStreamInstance) WriteFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Writev wraps g_output_stream_writev
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev.g_output_stream_writev.html
//
func (stream *OutputStreamInstance) Writev(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GOutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_writev(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAll wraps g_output_stream_writev_all
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all.g_output_stream_writev_all.html
//
func (stream *OutputStreamInstance) WritevAll(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GOutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_writev_all(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAllAsync wraps g_output_stream_writev_all_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all_async.g_output_stream_writev_all_async.html
//
func (stream *OutputStreamInstance) WritevAllAsync(vectors []OutputVector, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GOutputVector      // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_writev_all_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WritevAllFinish wraps g_output_stream_writev_all_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev_all_finish.g_output_stream_writev_all_finish.html
//
func (stream *OutputStreamInstance) WritevAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_writev_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAsync wraps g_output_stream_writev_async
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev_async.g_output_stream_writev_async.html
//
func (stream *OutputStreamInstance) WritevAsync(vectors []OutputVector, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GOutputVector      // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_writev_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WritevFinish wraps g_output_stream_writev_finish
// 
// see also https://docs.gtk.org/gio/method.g_output_stream_writev_finish.g_output_stream_writev_finish.html
//
func (stream *OutputStreamInstance) WritevFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_writev_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// OutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type OutputStreamOverrides[Instance OutputStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.close_finish.html
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.close_fn.html
	CloseFn func(Instance, Cancellable) (bool, error)
	// // Flush allows you to override the implementation of the virtual method flush.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.flush.html
	Flush func(Instance, Cancellable) (bool, error)
	// // FlushFinish allows you to override the implementation of the virtual method flush_finish.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.flush_finish.html
	FlushFinish func(Instance, AsyncResult) (bool, error)
	// // Splice allows you to override the implementation of the virtual method splice.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.splice.html
	Splice func(Instance, InputStream, OutputStreamSpliceFlags, Cancellable) (int, error)
	// // SpliceFinish allows you to override the implementation of the virtual method splice_finish.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.splice_finish.html
	SpliceFinish func(Instance, AsyncResult) (int, error)
	// // WriteFinish allows you to override the implementation of the virtual method write_finish.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.write_finish.html
	WriteFinish func(Instance, AsyncResult) (int, error)
	// // WriteFn allows you to override the implementation of the virtual method write_fn.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.write_fn.html
	WriteFn func(Instance, []byte, Cancellable) (int, error)
	// // WritevFinish allows you to override the implementation of the virtual method writev_finish.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.writev_finish.html
	WritevFinish func(Instance, AsyncResult) (uint, bool, error)
	// // WritevFn allows you to override the implementation of the virtual method writev_fn.
	// 
	// see also https://docs.gtk.org/gio/method.OutputStream.writev_fn.html
	WritevFn func(Instance, []OutputVector, Cancellable) (uint, bool, error)
}

// UnsafeApplyOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyOutputStreamOverrides[Instance OutputStream](gclass unsafe.Pointer, overrides OutputStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GOutputStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_OutputStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_close_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_OutputStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_close_fn",
			func(carg0 *C.GOutputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GOutputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._goglib_gio2_OutputStream_flush)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_flush",
			func(carg0 *C.GOutputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GOutputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Flush(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.FlushFinish != nil {
		pclass.flush_finish = (*[0]byte)(C._goglib_gio2_OutputStream_flush_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_flush_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.FlushFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Splice != nil {
		pclass.splice = (*[0]byte)(C._goglib_gio2_OutputStream_splice)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_splice",
			func(carg0 *C.GOutputStream, carg1 *C.GInputStream, carg2 C.GOutputStreamSpliceFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance                // go GOutputStream subclass
				var source      InputStream             // in, none, converted
				var flags       OutputStreamSpliceFlags // in, none, casted
				var cancellable Cancellable             // in, none, converted, nullable
				var goret       int                     // return, none, casted
				var _goerr      error                   // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				source = UnsafeInputStreamFromGlibNone(unsafe.Pointer(carg1))
				flags = OutputStreamSpliceFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Splice(stream, source, flags, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.SpliceFinish != nil {
		pclass.splice_finish = (*[0]byte)(C._goglib_gio2_OutputStream_splice_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_splice_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.SpliceFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WriteFinish != nil {
		pclass.write_finish = (*[0]byte)(C._goglib_gio2_OutputStream_write_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_write_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.WriteFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WriteFn != nil {
		pclass.write_fn = (*[0]byte)(C._goglib_gio2_OutputStream_write_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_write_fn",
			func(carg0 *C.GOutputStream, carg1 unsafe.Pointer, carg2 C.gsize, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GOutputStream subclass
				var buffer      []byte      // in, transfer: none, C Pointers: 1, Name: array[unknown], nullable, array (inner unknown, length-by: carg2)
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = buffer
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []byte (void*) because of unknown reason")
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.WriteFn(stream, buffer, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WritevFinish != nil {
		pclass.writev_finish = (*[0]byte)(C._goglib_gio2_OutputStream_writev_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_writev_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, carg2 *C.gsize, _cerr **C.GError) (cret C.gboolean) {
				var stream       Instance    // go GOutputStream subclass
				var result       AsyncResult // in, none, converted
				var bytesWritten uint        // out, full, casted
				var goret        bool        // return
				var _goerr       error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				bytesWritten, goret, _goerr = overrides.WritevFinish(stream, result)

				*carg2 = C.gsize(bytesWritten)
				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WritevFn != nil {
		pclass.writev_fn = (*[0]byte)(C._goglib_gio2_OutputStream_writev_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_writev_fn",
			func(carg0 *C.GOutputStream, carg1 *C.GOutputVector, carg2 C.gsize, carg3 *C.gsize, carg4 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream       Instance       // go GOutputStream subclass
				var vectors      []OutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
				var cancellable  Cancellable    // in, none, converted, nullable
				var bytesWritten uint           // out, full, casted
				var goret        bool           // return
				var _goerr       error          // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = vectors
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unknown reason")
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				bytesWritten, goret, _goerr = overrides.WritevFn(stream, vectors, cancellable)

				*carg3 = C.gsize(bytesWritten)
				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GOutputStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.close_finish.html
func (stream *OutputStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GOutputStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.close_fn.html
func (stream *OutputStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFlush calls the default implementations of the `GOutputStream.flush` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.flush.html
func (stream *OutputStreamInstance) ParentFlush(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_flush(unsafe.Pointer(parentclass.flush), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFlushFinish calls the default implementations of the `GOutputStream.flush_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.flush_finish.html
func (stream *OutputStreamInstance) ParentFlushFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_flush_finish(unsafe.Pointer(parentclass.flush_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSplice calls the default implementations of the `GOutputStream.splice` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.splice.html
func (stream *OutputStreamInstance) ParentSplice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, converted
	var carg3 *C.GCancellable            // in, none, casted
	var cret  C.gssize                   // return, none, casted
	var _cerr *C.GError                  // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_splice(unsafe.Pointer(parentclass.splice), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSpliceFinish calls the default implementations of the `GOutputStream.splice_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.splice_finish.html
func (stream *OutputStreamInstance) ParentSpliceFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_splice_finish(unsafe.Pointer(parentclass.splice_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWriteFinish calls the default implementations of the `GOutputStream.write_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.write_finish.html
func (stream *OutputStreamInstance) ParentWriteFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_write_finish(unsafe.Pointer(parentclass.write_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWriteFn calls the default implementations of the `GOutputStream.write_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.write_fn.html
func (stream *OutputStreamInstance) ParentWriteFn(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 unsafe.Pointer  // in, none, converted
	var carg2 C.gsize         // in, transfer: none, C Pointers: 1, Name: array[unknown], nullable, array (inner unknown, length-by: carg2)
	var carg3 *C.GCancellable // implicit
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_write_fn(unsafe.Pointer(parentclass.write_fn), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWritevFinish calls the default implementations of the `GOutputStream.writev_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.writev_finish.html
func (stream *OutputStreamInstance) ParentWritevFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.gsize         // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_writev_finish(unsafe.Pointer(parentclass.writev_finish), carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// ParentWritevFn calls the default implementations of the `GOutputStream.writev_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.OutputStream.writev_fn.html
func (stream *OutputStreamInstance) ParentWritevFn(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GOutputVector // in, none, converted
	var carg2 C.gsize          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg4 *C.GCancellable  // implicit
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_writev_fn(unsafe.Pointer(parentclass.writev_fn), carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// RegisterOutputStreamSubClass is used to register a go subclass of GOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterOutputStreamSubClass[InstanceT OutputStream](
		name string,
		classInit func(class *OutputStreamClass),
		constructor func() InstanceT,
		overrides OutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeOutputStream,
		UnsafeOutputStreamClassFromGlibBorrow,
		UnsafeApplyOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapOutputStream(obj)
		},
		interfaceInits...,
	)
}

// PermissionInstance is the instance type used by all types extending GPermission. It is used internally by the bindings. Users should use the interface [Permission] instead.
type PermissionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Permission = (*PermissionInstance)(nil)

// Permission wraps GPermission
// 
// see also https://docs.gtk.org/gio/class.Permission.html
//
type Permission interface {
	gobject.Object
	upcastToGPermission() *PermissionInstance

	// Acquire wraps g_permission_acquire
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_acquire.g_permission_acquire.html
	//
	Acquire(Cancellable) (bool, error)
	// AcquireAsync wraps g_permission_acquire_async
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_acquire_async.g_permission_acquire_async.html
	//
	AcquireAsync(Cancellable, AsyncReadyCallback)
	// AcquireFinish wraps g_permission_acquire_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_acquire_finish.g_permission_acquire_finish.html
	//
	AcquireFinish(AsyncResult) (bool, error)
	// GetAllowed wraps g_permission_get_allowed
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_get_allowed.g_permission_get_allowed.html
	//
	GetAllowed() bool
	// GetCanAcquire wraps g_permission_get_can_acquire
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_get_can_acquire.g_permission_get_can_acquire.html
	//
	GetCanAcquire() bool
	// GetCanRelease wraps g_permission_get_can_release
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_get_can_release.g_permission_get_can_release.html
	//
	GetCanRelease() bool
	// ImplUpdate wraps g_permission_impl_update
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_impl_update.g_permission_impl_update.html
	//
	ImplUpdate(bool, bool, bool)
	// Release wraps g_permission_release
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_release.g_permission_release.html
	//
	Release(Cancellable) (bool, error)
	// ReleaseAsync wraps g_permission_release_async
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_release_async.g_permission_release_async.html
	//
	ReleaseAsync(Cancellable, AsyncReadyCallback)
	// ReleaseFinish wraps g_permission_release_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_permission_release_finish.g_permission_release_finish.html
	//
	ReleaseFinish(AsyncResult) (bool, error)

	// chain up virtual methods:

	// ParentAcquire calls the default implementations of the `GPermission.acquire` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.acquire.html
	ParentAcquire(cancellable Cancellable) (bool, error)
	// ParentAcquireFinish calls the default implementations of the `GPermission.acquire_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.acquire_finish.html
	ParentAcquireFinish(result AsyncResult) (bool, error)
	// ParentRelease calls the default implementations of the `GPermission.release` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.release.html
	ParentRelease(cancellable Cancellable) (bool, error)
	// ParentReleaseFinish calls the default implementations of the `GPermission.release_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.release_finish.html
	ParentReleaseFinish(result AsyncResult) (bool, error)
}

func unsafeWrapPermission(base *gobject.ObjectInstance) *PermissionInstance {
	return &PermissionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypePermission,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPermission(inst)
		},
	)
}

func marshalPermissionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafePermissionFromGlibNone is used to convert raw GPermission pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePermissionFromGlibNone(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibNone(c).(Permission)
}

// UnsafePermissionFromGlibFull is used to convert raw GPermission pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePermissionFromGlibFull(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibFull(c).(Permission)
}

// UnsafePermissionFromGlibBorrow is used to convert raw GPermission pointers to go without touching any references. This is used by the bindings internally.
func UnsafePermissionFromGlibBorrow(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Permission)
}

func (p *PermissionInstance) upcastToGPermission() *PermissionInstance {
	return p
}

// UnsafePermissionToGlibNone is used to convert the instance to it's C value GPermission. This is used by the bindings internally.
func UnsafePermissionToGlibNone(c Permission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafePermissionToGlibFull is used to convert the instance to it's C value GPermission, while removeing the finalizer. This is used by the bindings internally.
func UnsafePermissionToGlibFull(c Permission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Acquire wraps g_permission_acquire
// 
// see also https://docs.gtk.org/gio/method.g_permission_acquire.g_permission_acquire.html
//
func (permission *PermissionInstance) Acquire(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_permission_acquire(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AcquireAsync wraps g_permission_acquire_async
// 
// see also https://docs.gtk.org/gio/method.g_permission_acquire_async.g_permission_acquire_async.html
//
func (permission *PermissionInstance) AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GPermission        // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_permission_acquire_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcquireFinish wraps g_permission_acquire_finish
// 
// see also https://docs.gtk.org/gio/method.g_permission_acquire_finish.g_permission_acquire_finish.html
//
func (permission *PermissionInstance) AcquireFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_permission_acquire_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetAllowed wraps g_permission_get_allowed
// 
// see also https://docs.gtk.org/gio/method.g_permission_get_allowed.g_permission_get_allowed.html
//
func (permission *PermissionInstance) GetAllowed() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_allowed(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCanAcquire wraps g_permission_get_can_acquire
// 
// see also https://docs.gtk.org/gio/method.g_permission_get_can_acquire.g_permission_get_can_acquire.html
//
func (permission *PermissionInstance) GetCanAcquire() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_can_acquire(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCanRelease wraps g_permission_get_can_release
// 
// see also https://docs.gtk.org/gio/method.g_permission_get_can_release.g_permission_get_can_release.html
//
func (permission *PermissionInstance) GetCanRelease() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_can_release(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ImplUpdate wraps g_permission_impl_update
// 
// see also https://docs.gtk.org/gio/method.g_permission_impl_update.g_permission_impl_update.html
//
func (permission *PermissionInstance) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	var carg0 *C.GPermission // in, none, converted
	var carg1 C.gboolean     // in
	var carg2 C.gboolean     // in
	var carg3 C.gboolean     // in

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if allowed {
		carg1 = C.TRUE
	}
	if canAcquire {
		carg2 = C.TRUE
	}
	if canRelease {
		carg3 = C.TRUE
	}

	C.g_permission_impl_update(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(allowed)
	runtime.KeepAlive(canAcquire)
	runtime.KeepAlive(canRelease)
}

// Release wraps g_permission_release
// 
// see also https://docs.gtk.org/gio/method.g_permission_release.g_permission_release.html
//
func (permission *PermissionInstance) Release(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_permission_release(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReleaseAsync wraps g_permission_release_async
// 
// see also https://docs.gtk.org/gio/method.g_permission_release_async.g_permission_release_async.html
//
func (permission *PermissionInstance) ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GPermission        // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_permission_release_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReleaseFinish wraps g_permission_release_finish
// 
// see also https://docs.gtk.org/gio/method.g_permission_release_finish.g_permission_release_finish.html
//
func (permission *PermissionInstance) ReleaseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_permission_release_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PermissionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type PermissionOverrides[Instance Permission] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Acquire allows you to override the implementation of the virtual method acquire.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.acquire.html
	Acquire func(Instance, Cancellable) (bool, error)
	// // AcquireFinish allows you to override the implementation of the virtual method acquire_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.acquire_finish.html
	AcquireFinish func(Instance, AsyncResult) (bool, error)
	// // Release allows you to override the implementation of the virtual method release.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.release.html
	Release func(Instance, Cancellable) (bool, error)
	// // ReleaseFinish allows you to override the implementation of the virtual method release_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Permission.release_finish.html
	ReleaseFinish func(Instance, AsyncResult) (bool, error)
}

// UnsafeApplyPermissionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyPermissionOverrides[Instance Permission](gclass unsafe.Pointer, overrides PermissionOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GPermissionClass)(gclass)

	if overrides.Acquire != nil {
		pclass.acquire = (*[0]byte)(C._goglib_gio2_Permission_acquire)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_acquire",
			func(carg0 *C.GPermission, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var permission  Instance    // go GPermission subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Acquire(permission, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.AcquireFinish != nil {
		pclass.acquire_finish = (*[0]byte)(C._goglib_gio2_Permission_acquire_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_acquire_finish",
			func(carg0 *C.GPermission, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var permission Instance    // go GPermission subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.AcquireFinish(permission, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Release != nil {
		pclass.release = (*[0]byte)(C._goglib_gio2_Permission_release)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_release",
			func(carg0 *C.GPermission, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var permission  Instance    // go GPermission subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Release(permission, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ReleaseFinish != nil {
		pclass.release_finish = (*[0]byte)(C._goglib_gio2_Permission_release_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_release_finish",
			func(carg0 *C.GPermission, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var permission Instance    // go GPermission subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.ReleaseFinish(permission, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAcquire calls the default implementations of the `GPermission.acquire` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Permission.acquire.html
func (permission *PermissionInstance) ParentAcquire(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Permission_virtual_acquire(unsafe.Pointer(parentclass.acquire), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentAcquireFinish calls the default implementations of the `GPermission.acquire_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Permission.acquire_finish.html
func (permission *PermissionInstance) ParentAcquireFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Permission_virtual_acquire_finish(unsafe.Pointer(parentclass.acquire_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRelease calls the default implementations of the `GPermission.release` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Permission.release.html
func (permission *PermissionInstance) ParentRelease(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Permission_virtual_release(unsafe.Pointer(parentclass.release), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReleaseFinish calls the default implementations of the `GPermission.release_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Permission.release_finish.html
func (permission *PermissionInstance) ParentReleaseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Permission_virtual_release_finish(unsafe.Pointer(parentclass.release_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterPermissionSubClass is used to register a go subclass of GPermission. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterPermissionSubClass[InstanceT Permission](
		name string,
		classInit func(class *PermissionClass),
		constructor func() InstanceT,
		overrides PermissionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypePermission,
		UnsafePermissionClassFromGlibBorrow,
		UnsafeApplyPermissionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPermission(obj)
		},
		interfaceInits...,
	)
}

// PropertyActionInstance is the instance type used by all types extending GPropertyAction. It is used internally by the bindings. Users should use the interface [PropertyAction] instead.
type PropertyActionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ PropertyAction = (*PropertyActionInstance)(nil)

// PropertyAction wraps GPropertyAction
// 
// see also https://docs.gtk.org/gio/class.PropertyAction.html
//
type PropertyAction interface {
	gobject.Object
	upcastToGPropertyAction() *PropertyActionInstance
}

func unsafeWrapPropertyAction(base *gobject.ObjectInstance) *PropertyActionInstance {
	return &PropertyActionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypePropertyAction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPropertyAction(inst)
		},
	)
}

func marshalPropertyActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafePropertyActionFromGlibNone is used to convert raw GPropertyAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePropertyActionFromGlibNone(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibNone(c).(PropertyAction)
}

// UnsafePropertyActionFromGlibFull is used to convert raw GPropertyAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePropertyActionFromGlibFull(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibFull(c).(PropertyAction)
}

// UnsafePropertyActionFromGlibBorrow is used to convert raw GPropertyAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafePropertyActionFromGlibBorrow(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PropertyAction)
}

func (p *PropertyActionInstance) upcastToGPropertyAction() *PropertyActionInstance {
	return p
}

// UnsafePropertyActionToGlibNone is used to convert the instance to it's C value GPropertyAction. This is used by the bindings internally.
func UnsafePropertyActionToGlibNone(c PropertyAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafePropertyActionToGlibFull is used to convert the instance to it's C value GPropertyAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafePropertyActionToGlibFull(c PropertyAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ResolverInstance is the instance type used by all types extending GResolver. It is used internally by the bindings. Users should use the interface [Resolver] instead.
type ResolverInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Resolver = (*ResolverInstance)(nil)

// Resolver wraps GResolver
// 
// see also https://docs.gtk.org/gio/class.Resolver.html
//
type Resolver interface {
	gobject.Object
	upcastToGResolver() *ResolverInstance

	// GetTimeout wraps g_resolver_get_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_get_timeout.g_resolver_get_timeout.html
	//
	GetTimeout() uint
	// LookupByAddress wraps g_resolver_lookup_by_address
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address.g_resolver_lookup_by_address.html
	//
	LookupByAddress(InetAddress, Cancellable) (string, error)
	// LookupByAddressAsync wraps g_resolver_lookup_by_address_async
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address_async.g_resolver_lookup_by_address_async.html
	//
	LookupByAddressAsync(InetAddress, Cancellable, AsyncReadyCallback)
	// LookupByAddressFinish wraps g_resolver_lookup_by_address_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address_finish.g_resolver_lookup_by_address_finish.html
	//
	LookupByAddressFinish(AsyncResult) (string, error)
	// LookupByName wraps g_resolver_lookup_by_name
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name.g_resolver_lookup_by_name.html
	//
	LookupByName(string, Cancellable) ([]InetAddress, error)
	// LookupByNameAsync wraps g_resolver_lookup_by_name_async
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_async.g_resolver_lookup_by_name_async.html
	//
	LookupByNameAsync(string, Cancellable, AsyncReadyCallback)
	// LookupByNameFinish wraps g_resolver_lookup_by_name_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_finish.g_resolver_lookup_by_name_finish.html
	//
	LookupByNameFinish(AsyncResult) ([]InetAddress, error)
	// LookupByNameWithFlags wraps g_resolver_lookup_by_name_with_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags.g_resolver_lookup_by_name_with_flags.html
	//
	LookupByNameWithFlags(string, ResolverNameLookupFlags, Cancellable) ([]InetAddress, error)
	// LookupByNameWithFlagsAsync wraps g_resolver_lookup_by_name_with_flags_async
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags_async.g_resolver_lookup_by_name_with_flags_async.html
	//
	LookupByNameWithFlagsAsync(string, ResolverNameLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupByNameWithFlagsFinish wraps g_resolver_lookup_by_name_with_flags_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags_finish.g_resolver_lookup_by_name_with_flags_finish.html
	//
	LookupByNameWithFlagsFinish(AsyncResult) ([]InetAddress, error)
	// LookupRecordsAsync wraps g_resolver_lookup_records_async
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_records_async.g_resolver_lookup_records_async.html
	//
	LookupRecordsAsync(string, ResolverRecordType, Cancellable, AsyncReadyCallback)
	// LookupService wraps g_resolver_lookup_service
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service.g_resolver_lookup_service.html
	//
	LookupService(string, string, string, Cancellable) ([]*SrvTarget, error)
	// LookupServiceAsync wraps g_resolver_lookup_service_async
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service_async.g_resolver_lookup_service_async.html
	//
	LookupServiceAsync(string, string, string, Cancellable, AsyncReadyCallback)
	// LookupServiceFinish wraps g_resolver_lookup_service_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service_finish.g_resolver_lookup_service_finish.html
	//
	LookupServiceFinish(AsyncResult) ([]*SrvTarget, error)
	// SetDefault wraps g_resolver_set_default
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_set_default.g_resolver_set_default.html
	//
	SetDefault()
	// SetTimeout wraps g_resolver_set_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_resolver_set_timeout.g_resolver_set_timeout.html
	//
	SetTimeout(uint)
	// ConnectReload connects the provided callback to the "reload" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Resolver.reload.html
	//
	ConnectReload(func(Resolver)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentLookupByAddress calls the default implementations of the `GResolver.lookup_by_address` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address.html
	ParentLookupByAddress(address InetAddress, cancellable Cancellable) (string, error)
	// ParentLookupByAddressFinish calls the default implementations of the `GResolver.lookup_by_address_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address_finish.html
	ParentLookupByAddressFinish(result AsyncResult) (string, error)
	// ParentLookupByName calls the default implementations of the `GResolver.lookup_by_name` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name.html
	ParentLookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error)
	// ParentLookupByNameFinish calls the default implementations of the `GResolver.lookup_by_name_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_finish.html
	ParentLookupByNameFinish(result AsyncResult) ([]InetAddress, error)
	// ParentLookupByNameWithFlags calls the default implementations of the `GResolver.lookup_by_name_with_flags` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags.html
	ParentLookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error)
	// ParentLookupByNameWithFlagsFinish calls the default implementations of the `GResolver.lookup_by_name_with_flags_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags_finish.html
	ParentLookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error)
	// ParentLookupServiceFinish calls the default implementations of the `GResolver.lookup_service_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_service_finish.html
	ParentLookupServiceFinish(result AsyncResult) ([]*SrvTarget, error)
	// ParentReload calls the default implementations of the `GResolver.reload` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.reload.html
	ParentReload()
}

func unsafeWrapResolver(base *gobject.ObjectInstance) *ResolverInstance {
	return &ResolverInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeResolver,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapResolver(inst)
		},
	)
}

func marshalResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeResolverFromGlibNone is used to convert raw GResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeResolverFromGlibNone(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibNone(c).(Resolver)
}

// UnsafeResolverFromGlibFull is used to convert raw GResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeResolverFromGlibFull(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibFull(c).(Resolver)
}

// UnsafeResolverFromGlibBorrow is used to convert raw GResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeResolverFromGlibBorrow(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Resolver)
}

func (r *ResolverInstance) upcastToGResolver() *ResolverInstance {
	return r
}

// UnsafeResolverToGlibNone is used to convert the instance to it's C value GResolver. This is used by the bindings internally.
func UnsafeResolverToGlibNone(c Resolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeResolverToGlibFull is used to convert the instance to it's C value GResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeResolverToGlibFull(c Resolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ResolverGetDefault wraps g_resolver_get_default
// 
// see also https://docs.gtk.org/gio/func.g_resolver_get_default.html
//
func ResolverGetDefault() Resolver {
	var cret *C.GResolver // return, full, converted

	cret = C.g_resolver_get_default()

	var goret Resolver

	goret = UnsafeResolverFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetTimeout wraps g_resolver_get_timeout
// 
// see also https://docs.gtk.org/gio/method.g_resolver_get_timeout.g_resolver_get_timeout.html
//
func (resolver *ResolverInstance) GetTimeout() uint {
	var carg0 *C.GResolver // in, none, converted
	var cret  C.unsigned   // return, none, casted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	cret = C.g_resolver_get_timeout(carg0)
	runtime.KeepAlive(resolver)

	var goret uint

	goret = uint(cret)

	return goret
}

// LookupByAddress wraps g_resolver_lookup_by_address
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address.g_resolver_lookup_by_address.html
//
func (resolver *ResolverInstance) LookupByAddress(address InetAddress, cancellable Cancellable) (string, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_address(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByAddressAsync wraps g_resolver_lookup_by_address_async
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address_async.g_resolver_lookup_by_address_async.html
//
func (resolver *ResolverInstance) LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.GInetAddress       // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_address_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish wraps g_resolver_lookup_by_address_finish
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_address_finish.g_resolver_lookup_by_address_finish.html
//
func (resolver *ResolverInstance) LookupByAddressFinish(result AsyncResult) (string, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_address_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByName wraps g_resolver_lookup_by_name
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name.g_resolver_lookup_by_name.html
//
func (resolver *ResolverInstance) LookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_name(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameAsync wraps g_resolver_lookup_by_name_async
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_async.g_resolver_lookup_by_name_async.html
//
func (resolver *ResolverInstance) LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_name_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish wraps g_resolver_lookup_by_name_finish
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_finish.g_resolver_lookup_by_name_finish.html
//
func (resolver *ResolverInstance) LookupByNameFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_name_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameWithFlags wraps g_resolver_lookup_by_name_with_flags
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags.g_resolver_lookup_by_name_with_flags.html
//
func (resolver *ResolverInstance) LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver               // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var carg2 C.GResolverNameLookupFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var cret  *C.GList                   // container, transfer: full
	var _cerr *C.GError                  // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_name_with_flags(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameWithFlagsAsync wraps g_resolver_lookup_by_name_with_flags_async
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags_async.g_resolver_lookup_by_name_with_flags_async.html
//
func (resolver *ResolverInstance) LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver               // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var carg2 C.GResolverNameLookupFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback      // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer                 // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_name_with_flags_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByNameWithFlagsFinish wraps g_resolver_lookup_by_name_with_flags_finish
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_by_name_with_flags_finish.g_resolver_lookup_by_name_with_flags_finish.html
//
func (resolver *ResolverInstance) LookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_name_with_flags_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupRecordsAsync wraps g_resolver_lookup_records_async
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_records_async.g_resolver_lookup_records_async.html
//
func (resolver *ResolverInstance) LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.GResolverRecordType // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverRecordType(recordType)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_records_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupService wraps g_resolver_lookup_service
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service.g_resolver_lookup_service.html
//
func (resolver *ResolverInstance) LookupService(service string, protocol string, domain string, cancellable Cancellable) ([]*SrvTarget, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 *C.gchar        // in, none, string
	var carg3 *C.gchar        // in, none, string
	var carg4 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_service(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(cancellable)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupServiceAsync wraps g_resolver_lookup_service_async
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service_async.g_resolver_lookup_service_async.html
//
func (resolver *ResolverInstance) LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.gchar              // in, none, string
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_service_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish wraps g_resolver_lookup_service_finish
// 
// see also https://docs.gtk.org/gio/method.g_resolver_lookup_service_finish.g_resolver_lookup_service_finish.html
//
func (resolver *ResolverInstance) LookupServiceFinish(result AsyncResult) ([]*SrvTarget, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_service_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDefault wraps g_resolver_set_default
// 
// see also https://docs.gtk.org/gio/method.g_resolver_set_default.g_resolver_set_default.html
//
func (resolver *ResolverInstance) SetDefault() {
	var carg0 *C.GResolver // in, none, converted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	C.g_resolver_set_default(carg0)
	runtime.KeepAlive(resolver)
}

// SetTimeout wraps g_resolver_set_timeout
// 
// see also https://docs.gtk.org/gio/method.g_resolver_set_timeout.g_resolver_set_timeout.html
//
func (resolver *ResolverInstance) SetTimeout(timeoutMs uint) {
	var carg0 *C.GResolver // in, none, converted
	var carg1 C.unsigned   // in, none, casted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = C.unsigned(timeoutMs)

	C.g_resolver_set_timeout(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(timeoutMs)
}

// ConnectReload connects the provided callback to the "reload" signal
// 
// see also https://docs.gtk.org/gio/signal.Resolver.reload.html
//
func (o *ResolverInstance) ConnectReload(fn func(Resolver)) gobject.SignalHandle {
	return o.Connect("reload", fn)
}

// ResolverOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ResolverOverrides[Instance Resolver] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // LookupByAddress allows you to override the implementation of the virtual method lookup_by_address.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address.html
	LookupByAddress func(Instance, InetAddress, Cancellable) (string, error)
	// // LookupByAddressFinish allows you to override the implementation of the virtual method lookup_by_address_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address_finish.html
	LookupByAddressFinish func(Instance, AsyncResult) (string, error)
	// // LookupByName allows you to override the implementation of the virtual method lookup_by_name.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name.html
	LookupByName func(Instance, string, Cancellable) ([]InetAddress, error)
	// // LookupByNameFinish allows you to override the implementation of the virtual method lookup_by_name_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_finish.html
	LookupByNameFinish func(Instance, AsyncResult) ([]InetAddress, error)
	// // LookupByNameWithFlags allows you to override the implementation of the virtual method lookup_by_name_with_flags.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags.html
	LookupByNameWithFlags func(Instance, string, ResolverNameLookupFlags, Cancellable) ([]InetAddress, error)
	// // LookupByNameWithFlagsFinish allows you to override the implementation of the virtual method lookup_by_name_with_flags_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags_finish.html
	LookupByNameWithFlagsFinish func(Instance, AsyncResult) ([]InetAddress, error)
	// // LookupServiceFinish allows you to override the implementation of the virtual method lookup_service_finish.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.lookup_service_finish.html
	LookupServiceFinish func(Instance, AsyncResult) ([]*SrvTarget, error)
	// // Reload allows you to override the implementation of the virtual method reload.
	// 
	// see also https://docs.gtk.org/gio/method.Resolver.reload.html
	Reload func(Instance)
}

// UnsafeApplyResolverOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyResolverOverrides[Instance Resolver](gclass unsafe.Pointer, overrides ResolverOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GResolverClass)(gclass)

	if overrides.LookupByAddress != nil {
		pclass.lookup_by_address = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_address)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_address",
			func(carg0 *C.GResolver, carg1 *C.GInetAddress, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.gchar) {
				var resolver    Instance    // go GResolver subclass
				var address     InetAddress // in, none, converted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       string      // return, full, string
				var _goerr      error       // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				address = UnsafeInetAddressFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.LookupByAddress(resolver, address, cancellable)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByAddressFinish != nil {
		pclass.lookup_by_address_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_address_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_address_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.gchar) {
				var resolver Instance    // go GResolver subclass
				var result   AsyncResult // in, none, converted
				var goret    string      // return, full, string
				var _goerr   error       // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByAddressFinish(resolver, result)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByName != nil {
		pclass.lookup_by_name = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name",
			func(carg0 *C.GResolver, carg1 *C.gchar, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
				var resolver    Instance      // go GResolver subclass
				var hostname    string        // in, none, string
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr      error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				hostname = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.LookupByName(resolver, hostname, cancellable)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameFinish != nil {
		pclass.lookup_by_name_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance      // go GResolver subclass
				var result   AsyncResult   // in, none, converted
				var goret    []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByNameFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameWithFlags != nil {
		pclass.lookup_by_name_with_flags = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_with_flags)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_with_flags",
			func(carg0 *C.GResolver, carg1 *C.gchar, carg2 C.GResolverNameLookupFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
				var resolver    Instance                // go GResolver subclass
				var hostname    string                  // in, none, string
				var flags       ResolverNameLookupFlags // in, none, casted
				var cancellable Cancellable             // in, none, converted, nullable
				var goret       []InetAddress           // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr      error                   // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				hostname = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				flags = ResolverNameLookupFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.LookupByNameWithFlags(resolver, hostname, flags, cancellable)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameWithFlagsFinish != nil {
		pclass.lookup_by_name_with_flags_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_with_flags_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_with_flags_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance      // go GResolver subclass
				var result   AsyncResult   // in, none, converted
				var goret    []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByNameWithFlagsFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupServiceFinish != nil {
		pclass.lookup_service_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_service_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_service_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance     // go GResolver subclass
				var result   AsyncResult  // in, none, converted
				var goret    []*SrvTarget // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error        // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupServiceFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []*SrvTarget (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Reload != nil {
		pclass.reload = (*[0]byte)(C._goglib_gio2_Resolver_reload)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_reload",
			func(carg0 *C.GResolver) {
				var resolver Instance // go GResolver subclass

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Reload(resolver)
			},
		)
	}
}

// ParentLookupByAddress calls the default implementations of the `GResolver.lookup_by_address` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address.html
func (resolver *ResolverInstance) ParentLookupByAddress(address InetAddress, cancellable Cancellable) (string, error) {
	var carg0 *C.GResolver
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GCancellable // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_address(unsafe.Pointer(parentclass.lookup_by_address), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByAddressFinish calls the default implementations of the `GResolver.lookup_by_address_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_address_finish.html
func (resolver *ResolverInstance) ParentLookupByAddressFinish(result AsyncResult) (string, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_address_finish(unsafe.Pointer(parentclass.lookup_by_address_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByName calls the default implementations of the `GResolver.lookup_by_name` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name.html
func (resolver *ResolverInstance) ParentLookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.gchar        // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name(unsafe.Pointer(parentclass.lookup_by_name), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameFinish calls the default implementations of the `GResolver.lookup_by_name_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_finish.html
func (resolver *ResolverInstance) ParentLookupByNameFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_finish(unsafe.Pointer(parentclass.lookup_by_name_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameWithFlags calls the default implementations of the `GResolver.lookup_by_name_with_flags` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags.html
func (resolver *ResolverInstance) ParentLookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.gchar                   // in, none, converted
	var carg2 C.GResolverNameLookupFlags // in, none, string
	var carg3 *C.GCancellable            // in, none, casted
	var cret  *C.GList                   // container, transfer: full
	var _cerr *C.GError                  // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_with_flags(unsafe.Pointer(parentclass.lookup_by_name_with_flags), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameWithFlagsFinish calls the default implementations of the `GResolver.lookup_by_name_with_flags_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_by_name_with_flags_finish.html
func (resolver *ResolverInstance) ParentLookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(unsafe.Pointer(parentclass.lookup_by_name_with_flags_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupServiceFinish calls the default implementations of the `GResolver.lookup_service_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.lookup_service_finish.html
func (resolver *ResolverInstance) ParentLookupServiceFinish(result AsyncResult) ([]*SrvTarget, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_service_finish(unsafe.Pointer(parentclass.lookup_service_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReload calls the default implementations of the `GResolver.reload` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Resolver.reload.html
func (resolver *ResolverInstance) ParentReload() {
	var carg0 *C.GResolver

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	C._goglib_gio2_Resolver_virtual_reload(unsafe.Pointer(parentclass.reload), carg0)
	runtime.KeepAlive(resolver)
}

// RegisterResolverSubClass is used to register a go subclass of GResolver. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterResolverSubClass[InstanceT Resolver](
		name string,
		classInit func(class *ResolverClass),
		constructor func() InstanceT,
		overrides ResolverOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeResolver,
		UnsafeResolverClassFromGlibBorrow,
		UnsafeApplyResolverOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapResolver(obj)
		},
		interfaceInits...,
	)
}

// SettingsInstance is the instance type used by all types extending GSettings. It is used internally by the bindings. Users should use the interface [Settings] instead.
type SettingsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Settings = (*SettingsInstance)(nil)

// Settings wraps GSettings
// 
// see also https://docs.gtk.org/gio/class.Settings.html
//
type Settings interface {
	gobject.Object
	upcastToGSettings() *SettingsInstance

	// Apply wraps g_settings_apply
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_apply.g_settings_apply.html
	//
	Apply()
	// CreateAction wraps g_settings_create_action
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_create_action.g_settings_create_action.html
	//
	CreateAction(string) Action
	// Delay wraps g_settings_delay
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_delay.g_settings_delay.html
	//
	Delay()
	// GetBoolean wraps g_settings_get_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_boolean.g_settings_get_boolean.html
	//
	GetBoolean(string) bool
	// GetChild wraps g_settings_get_child
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_child.g_settings_get_child.html
	//
	GetChild(string) Settings
	// GetDouble wraps g_settings_get_double
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_double.g_settings_get_double.html
	//
	GetDouble(string) float64
	// GetEnum wraps g_settings_get_enum
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_enum.g_settings_get_enum.html
	//
	GetEnum(string) int32
	// GetFlags wraps g_settings_get_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_flags.g_settings_get_flags.html
	//
	GetFlags(string) uint
	// GetHasUnapplied wraps g_settings_get_has_unapplied
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_has_unapplied.g_settings_get_has_unapplied.html
	//
	GetHasUnapplied() bool
	// GetInt wraps g_settings_get_int
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_int.g_settings_get_int.html
	//
	GetInt(string) int32
	// GetInt64 wraps g_settings_get_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_int64.g_settings_get_int64.html
	//
	GetInt64(string) int64
	// GetString wraps g_settings_get_string
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_string.g_settings_get_string.html
	//
	GetString(string) string
	// GetStrv wraps g_settings_get_strv
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_strv.g_settings_get_strv.html
	//
	GetStrv(string) []string
	// GetUint wraps g_settings_get_uint
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_uint.g_settings_get_uint.html
	//
	GetUint(string) uint
	// GetUint64 wraps g_settings_get_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_get_uint64.g_settings_get_uint64.html
	//
	GetUint64(string) uint64
	// IsWritable wraps g_settings_is_writable
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_is_writable.g_settings_is_writable.html
	//
	IsWritable(string) bool
	// ListChildren wraps g_settings_list_children
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_list_children.g_settings_list_children.html
	//
	ListChildren() []string
	// ListKeys wraps g_settings_list_keys
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_list_keys.g_settings_list_keys.html
	//
	//
	// Deprecated: (since 2.46.0) Use [method@Gio.SettingsSchema.list_keys] instead.
	ListKeys() []string
	// Reset wraps g_settings_reset
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_reset.g_settings_reset.html
	//
	Reset(string)
	// Revert wraps g_settings_revert
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_revert.g_settings_revert.html
	//
	Revert()
	// SetBoolean wraps g_settings_set_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_boolean.g_settings_set_boolean.html
	//
	SetBoolean(string, bool) bool
	// SetDouble wraps g_settings_set_double
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_double.g_settings_set_double.html
	//
	SetDouble(string, float64) bool
	// SetEnum wraps g_settings_set_enum
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_enum.g_settings_set_enum.html
	//
	SetEnum(string, int32) bool
	// SetFlags wraps g_settings_set_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_flags.g_settings_set_flags.html
	//
	SetFlags(string, uint) bool
	// SetInt wraps g_settings_set_int
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_int.g_settings_set_int.html
	//
	SetInt(string, int32) bool
	// SetInt64 wraps g_settings_set_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_int64.g_settings_set_int64.html
	//
	SetInt64(string, int64) bool
	// SetString wraps g_settings_set_string
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_string.g_settings_set_string.html
	//
	SetString(string, string) bool
	// SetStrv wraps g_settings_set_strv
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_strv.g_settings_set_strv.html
	//
	SetStrv(string, []string) bool
	// SetUint wraps g_settings_set_uint
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_uint.g_settings_set_uint.html
	//
	SetUint(string, uint) bool
	// SetUint64 wraps g_settings_set_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_settings_set_uint64.g_settings_set_uint64.html
	//
	SetUint64(string, uint64) bool
	// ConnectChangeEvent connects the provided callback to the "change-event" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Settings.change-event.html
	//
	ConnectChangeEvent(func(Settings, []byte, int32) bool) gobject.SignalHandle
	// ConnectChanged connects the provided callback to the "changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Settings.changed.html
	//
	ConnectChanged(func(Settings, string)) gobject.SignalHandle
	// ConnectWritableChangeEvent connects the provided callback to the "writable-change-event" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Settings.writable-change-event.html
	//
	ConnectWritableChangeEvent(func(Settings, uint) bool) gobject.SignalHandle
	// ConnectWritableChanged connects the provided callback to the "writable-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.Settings.writable-changed.html
	//
	ConnectWritableChanged(func(Settings, string)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentChangeEvent calls the default implementations of the `GSettings.change_event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.change_event.html
	ParentChangeEvent(keys *glib.Quark, nKeys int32) bool
	// ParentChanged calls the default implementations of the `GSettings.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.changed.html
	ParentChanged(key string)
	// ParentWritableChangeEvent calls the default implementations of the `GSettings.writable_change_event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.writable_change_event.html
	ParentWritableChangeEvent(key glib.Quark) bool
	// ParentWritableChanged calls the default implementations of the `GSettings.writable_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.writable_changed.html
	ParentWritableChanged(key string)
}

func unsafeWrapSettings(base *gobject.ObjectInstance) *SettingsInstance {
	return &SettingsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSettings,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSettings(inst)
		},
	)
}

func marshalSettingsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSettingsFromGlibNone is used to convert raw GSettings pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSettingsFromGlibNone(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibNone(c).(Settings)
}

// UnsafeSettingsFromGlibFull is used to convert raw GSettings pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSettingsFromGlibFull(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibFull(c).(Settings)
}

// UnsafeSettingsFromGlibBorrow is used to convert raw GSettings pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSettingsFromGlibBorrow(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Settings)
}

func (s *SettingsInstance) upcastToGSettings() *SettingsInstance {
	return s
}

// UnsafeSettingsToGlibNone is used to convert the instance to it's C value GSettings. This is used by the bindings internally.
func UnsafeSettingsToGlibNone(c Settings) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSettingsToGlibFull is used to convert the instance to it's C value GSettings, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSettingsToGlibFull(c Settings) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSettings wraps g_settings_new
// 
// see also https://docs.gtk.org/gio/func.g_settings_new.html
//
func NewSettings(schemaId string) Settings {
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_new(carg1)
	runtime.KeepAlive(schemaId)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewSettingsWithPath wraps g_settings_new_with_path
// 
// see also https://docs.gtk.org/gio/func.g_settings_new_with_path.html
//
func NewSettingsWithPath(schemaId string, path string) Settings {
	var carg1 *C.gchar     // in, none, string
	var carg2 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_settings_new_with_path(carg1, carg2)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(path)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SettingsListRelocatableSchemas wraps g_settings_list_relocatable_schemas
// 
// see also https://docs.gtk.org/gio/func.g_settings_list_relocatable_schemas.html
//
//
// Deprecated: (since 2.40.0) Use g_settings_schema_source_list_schemas() instead
func SettingsListRelocatableSchemas() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_settings_list_relocatable_schemas()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// SettingsListSchemas wraps g_settings_list_schemas
// 
// see also https://docs.gtk.org/gio/func.g_settings_list_schemas.html
//
//
// Deprecated: (since 2.40.0) Use g_settings_schema_source_list_schemas() instead.
// If you used g_settings_list_schemas() to check for the presence of
// a particular schema, use g_settings_schema_source_lookup() instead
// of your whole loop.
func SettingsListSchemas() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_settings_list_schemas()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// SettingsSync wraps g_settings_sync
// 
// see also https://docs.gtk.org/gio/func.g_settings_sync.html
//
func SettingsSync() {

	C.g_settings_sync()
}

// Apply wraps g_settings_apply
// 
// see also https://docs.gtk.org/gio/method.g_settings_apply.g_settings_apply.html
//
func (settings *SettingsInstance) Apply() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_apply(carg0)
	runtime.KeepAlive(settings)
}

// CreateAction wraps g_settings_create_action
// 
// see also https://docs.gtk.org/gio/method.g_settings_create_action.g_settings_create_action.html
//
func (settings *SettingsInstance) CreateAction(key string) Action {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GAction   // return, full, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_create_action(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret Action

	goret = UnsafeActionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Delay wraps g_settings_delay
// 
// see also https://docs.gtk.org/gio/method.g_settings_delay.g_settings_delay.html
//
func (settings *SettingsInstance) Delay() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_delay(carg0)
	runtime.KeepAlive(settings)
}

// GetBoolean wraps g_settings_get_boolean
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_boolean.g_settings_get_boolean.html
//
func (settings *SettingsInstance) GetBoolean(key string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_boolean(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetChild wraps g_settings_get_child
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_child.g_settings_get_child.html
//
func (settings *SettingsInstance) GetChild(name string) Settings {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_child(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDouble wraps g_settings_get_double
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_double.g_settings_get_double.html
//
func (settings *SettingsInstance) GetDouble(key string) float64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gdouble    // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_double(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret float64

	goret = float64(cret)

	return goret
}

// GetEnum wraps g_settings_get_enum
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_enum.g_settings_get_enum.html
//
func (settings *SettingsInstance) GetEnum(key string) int32 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_enum(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetFlags wraps g_settings_get_flags
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_flags.g_settings_get_flags.html
//
func (settings *SettingsInstance) GetFlags(key string) uint {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint      // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_flags(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetHasUnapplied wraps g_settings_get_has_unapplied
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_has_unapplied.g_settings_get_has_unapplied.html
//
func (settings *SettingsInstance) GetHasUnapplied() bool {
	var carg0 *C.GSettings // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_get_has_unapplied(carg0)
	runtime.KeepAlive(settings)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetInt wraps g_settings_get_int
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_int.g_settings_get_int.html
//
func (settings *SettingsInstance) GetInt(key string) int32 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_int(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetInt64 wraps g_settings_get_int64
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_int64.g_settings_get_int64.html
//
func (settings *SettingsInstance) GetInt64(key string) int64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint64     // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_int64(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetString wraps g_settings_get_string
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_string.g_settings_get_string.html
//
func (settings *SettingsInstance) GetString(key string) string {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.gchar     // return, full, string

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_string(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetStrv wraps g_settings_get_strv
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_strv.g_settings_get_strv.html
//
func (settings *SettingsInstance) GetStrv(key string) []string {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_strv(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetUint wraps g_settings_get_uint
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_uint.g_settings_get_uint.html
//
func (settings *SettingsInstance) GetUint(key string) uint {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint      // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_uint(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUint64 wraps g_settings_get_uint64
// 
// see also https://docs.gtk.org/gio/method.g_settings_get_uint64.g_settings_get_uint64.html
//
func (settings *SettingsInstance) GetUint64(key string) uint64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint64    // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_uint64(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint64

	goret = uint64(cret)

	return goret
}

// IsWritable wraps g_settings_is_writable
// 
// see also https://docs.gtk.org/gio/method.g_settings_is_writable.g_settings_is_writable.html
//
func (settings *SettingsInstance) IsWritable(name string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_is_writable(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListChildren wraps g_settings_list_children
// 
// see also https://docs.gtk.org/gio/method.g_settings_list_children.g_settings_list_children.html
//
func (settings *SettingsInstance) ListChildren() []string {
	var carg0 *C.GSettings // in, none, converted
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_list_children(carg0)
	runtime.KeepAlive(settings)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ListKeys wraps g_settings_list_keys
// 
// see also https://docs.gtk.org/gio/method.g_settings_list_keys.g_settings_list_keys.html
//
//
// Deprecated: (since 2.46.0) Use [method@Gio.SettingsSchema.list_keys] instead.
func (settings *SettingsInstance) ListKeys() []string {
	var carg0 *C.GSettings // in, none, converted
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_list_keys(carg0)
	runtime.KeepAlive(settings)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// Reset wraps g_settings_reset
// 
// see also https://docs.gtk.org/gio/method.g_settings_reset.g_settings_reset.html
//
func (settings *SettingsInstance) Reset(key string) {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_settings_reset(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// Revert wraps g_settings_revert
// 
// see also https://docs.gtk.org/gio/method.g_settings_revert.g_settings_revert.html
//
func (settings *SettingsInstance) Revert() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_revert(carg0)
	runtime.KeepAlive(settings)
}

// SetBoolean wraps g_settings_set_boolean
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_boolean.g_settings_set_boolean.html
//
func (settings *SettingsInstance) SetBoolean(key string, value bool) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gboolean   // in
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	if value {
		carg2 = C.TRUE
	}

	cret = C.g_settings_set_boolean(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetDouble wraps g_settings_set_double
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_double.g_settings_set_double.html
//
func (settings *SettingsInstance) SetDouble(key string, value float64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gdouble    // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gdouble(value)

	cret = C.g_settings_set_double(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetEnum wraps g_settings_set_enum
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_enum.g_settings_set_enum.html
//
func (settings *SettingsInstance) SetEnum(key string, value int32) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(value)

	cret = C.g_settings_set_enum(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetFlags wraps g_settings_set_flags
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_flags.g_settings_set_flags.html
//
func (settings *SettingsInstance) SetFlags(key string, value uint) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint      // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(value)

	cret = C.g_settings_set_flags(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetInt wraps g_settings_set_int
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_int.g_settings_set_int.html
//
func (settings *SettingsInstance) SetInt(key string, value int32) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(value)

	cret = C.g_settings_set_int(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetInt64 wraps g_settings_set_int64
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_int64.g_settings_set_int64.html
//
func (settings *SettingsInstance) SetInt64(key string, value int64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint64     // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(value)

	cret = C.g_settings_set_int64(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetString wraps g_settings_set_string
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_string.g_settings_set_string.html
//
func (settings *SettingsInstance) SetString(key string, value string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_settings_set_string(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetStrv wraps g_settings_set_strv
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_strv.g_settings_set_strv.html
//
func (settings *SettingsInstance) SetStrv(key string, value []string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 **C.gchar    // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	_ = value
	_ = carg2
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_settings_set_strv(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUint wraps g_settings_set_uint
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_uint.g_settings_set_uint.html
//
func (settings *SettingsInstance) SetUint(key string, value uint) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint      // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(value)

	cret = C.g_settings_set_uint(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUint64 wraps g_settings_set_uint64
// 
// see also https://docs.gtk.org/gio/method.g_settings_set_uint64.g_settings_set_uint64.html
//
func (settings *SettingsInstance) SetUint64(key string, value uint64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint64    // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(value)

	cret = C.g_settings_set_uint64(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectChangeEvent connects the provided callback to the "change-event" signal
// 
// see also https://docs.gtk.org/gio/signal.Settings.change-event.html
//
func (o *SettingsInstance) ConnectChangeEvent(fn func(Settings, []byte, int32) bool) gobject.SignalHandle {
	return o.Connect("change-event", fn)
}

// ConnectChanged connects the provided callback to the "changed" signal
// 
// see also https://docs.gtk.org/gio/signal.Settings.changed.html
//
func (o *SettingsInstance) ConnectChanged(fn func(Settings, string)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// ConnectWritableChangeEvent connects the provided callback to the "writable-change-event" signal
// 
// see also https://docs.gtk.org/gio/signal.Settings.writable-change-event.html
//
func (o *SettingsInstance) ConnectWritableChangeEvent(fn func(Settings, uint) bool) gobject.SignalHandle {
	return o.Connect("writable-change-event", fn)
}

// ConnectWritableChanged connects the provided callback to the "writable-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.Settings.writable-changed.html
//
func (o *SettingsInstance) ConnectWritableChanged(fn func(Settings, string)) gobject.SignalHandle {
	return o.Connect("writable-changed", fn)
}

// SettingsOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SettingsOverrides[Instance Settings] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // ChangeEvent allows you to override the implementation of the virtual method change_event.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.change_event.html
	ChangeEvent func(Instance, *glib.Quark, int32) bool
	// // Changed allows you to override the implementation of the virtual method changed.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.changed.html
	Changed func(Instance, string)
	// // WritableChangeEvent allows you to override the implementation of the virtual method writable_change_event.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.writable_change_event.html
	WritableChangeEvent func(Instance, glib.Quark) bool
	// // WritableChanged allows you to override the implementation of the virtual method writable_changed.
	// 
	// see also https://docs.gtk.org/gio/method.Settings.writable_changed.html
	WritableChanged func(Instance, string)
}

// UnsafeApplySettingsOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySettingsOverrides[Instance Settings](gclass unsafe.Pointer, overrides SettingsOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSettingsClass)(gclass)

	if overrides.ChangeEvent != nil {
		pclass.change_event = (*[0]byte)(C._goglib_gio2_Settings_change_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_change_event",
			func(carg0 *C.GSettings, carg1 *C.GQuark, carg2 C.gint) (cret C.gboolean) {
				var settings Instance    // go GSettings subclass
				var keys     *glib.Quark // in, transfer: none, C Pointers: 1, Name: Quark
				var nKeys    int32       // in, none, casted
				var goret    bool        // return

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = keys
				_ = carg1
				panic("unimplemented conversion of *glib.Quark (const GQuark*) because of unknown reason")
				nKeys = int32(carg2)

				goret = overrides.ChangeEvent(settings, keys, nKeys)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_Settings_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_changed",
			func(carg0 *C.GSettings, carg1 *C.gchar) {
				var settings Instance // go GSettings subclass
				var key      string   // in, none, string

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.Changed(settings, key)
			},
		)
	}

	if overrides.WritableChangeEvent != nil {
		pclass.writable_change_event = (*[0]byte)(C._goglib_gio2_Settings_writable_change_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_writable_change_event",
			func(carg0 *C.GSettings, carg1 C.GQuark) (cret C.gboolean) {
				var settings Instance   // go GSettings subclass
				var key      glib.Quark // in, none, casted, alias
				var goret    bool       // return

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = glib.Quark(carg1)

				goret = overrides.WritableChangeEvent(settings, key)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.WritableChanged != nil {
		pclass.writable_changed = (*[0]byte)(C._goglib_gio2_Settings_writable_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_writable_changed",
			func(carg0 *C.GSettings, carg1 *C.gchar) {
				var settings Instance // go GSettings subclass
				var key      string   // in, none, string

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.WritableChanged(settings, key)
			},
		)
	}
}

// ParentChangeEvent calls the default implementations of the `GSettings.change_event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Settings.change_event.html
func (settings *SettingsInstance) ParentChangeEvent(keys *glib.Quark, nKeys int32) bool {
	var carg0 *C.GSettings
	var carg1 *C.GQuark  // in, none, converted
	var carg2 C.gint     // in, transfer: none, C Pointers: 1, Name: Quark
	var cret  C.gboolean // return

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	_ = keys
	_ = carg1
	panic("unimplemented conversion of *glib.Quark (const GQuark*) because of unsupported aliased type")
	carg2 = C.gint(nKeys)

	cret = C._goglib_gio2_Settings_virtual_change_event(unsafe.Pointer(parentclass.change_event), carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keys)
	runtime.KeepAlive(nKeys)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentChanged calls the default implementations of the `GSettings.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Settings.changed.html
func (settings *SettingsInstance) ParentChanged(key string) {
	var carg0 *C.GSettings
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Settings_virtual_changed(unsafe.Pointer(parentclass.changed), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// ParentWritableChangeEvent calls the default implementations of the `GSettings.writable_change_event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Settings.writable_change_event.html
func (settings *SettingsInstance) ParentWritableChangeEvent(key glib.Quark) bool {
	var carg0 *C.GSettings
	var carg1 C.GQuark   // in, none, converted
	var cret  C.gboolean // return

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = C.GQuark(key)

	cret = C._goglib_gio2_Settings_virtual_writable_change_event(unsafe.Pointer(parentclass.writable_change_event), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentWritableChanged calls the default implementations of the `GSettings.writable_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Settings.writable_changed.html
func (settings *SettingsInstance) ParentWritableChanged(key string) {
	var carg0 *C.GSettings
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Settings_virtual_writable_changed(unsafe.Pointer(parentclass.writable_changed), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// RegisterSettingsSubClass is used to register a go subclass of GSettings. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSettingsSubClass[InstanceT Settings](
		name string,
		classInit func(class *SettingsClass),
		constructor func() InstanceT,
		overrides SettingsOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSettings,
		UnsafeSettingsClassFromGlibBorrow,
		UnsafeApplySettingsOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSettings(obj)
		},
		interfaceInits...,
	)
}

// SimpleActionInstance is the instance type used by all types extending GSimpleAction. It is used internally by the bindings. Users should use the interface [SimpleAction] instead.
type SimpleActionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleAction = (*SimpleActionInstance)(nil)

// SimpleAction wraps GSimpleAction
// 
// see also https://docs.gtk.org/gio/class.SimpleAction.html
//
type SimpleAction interface {
	gobject.Object
	upcastToGSimpleAction() *SimpleActionInstance

	// SetEnabled wraps g_simple_action_set_enabled
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_action_set_enabled.g_simple_action_set_enabled.html
	//
	SetEnabled(bool)
}

func unsafeWrapSimpleAction(base *gobject.ObjectInstance) *SimpleActionInstance {
	return &SimpleActionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleAction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleAction(inst)
		},
	)
}

func marshalSimpleActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleActionFromGlibNone is used to convert raw GSimpleAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibNone(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleAction)
}

// UnsafeSimpleActionFromGlibFull is used to convert raw GSimpleAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibFull(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleAction)
}

// UnsafeSimpleActionFromGlibBorrow is used to convert raw GSimpleAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibBorrow(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleAction)
}

func (s *SimpleActionInstance) upcastToGSimpleAction() *SimpleActionInstance {
	return s
}

// UnsafeSimpleActionToGlibNone is used to convert the instance to it's C value GSimpleAction. This is used by the bindings internally.
func UnsafeSimpleActionToGlibNone(c SimpleAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleActionToGlibFull is used to convert the instance to it's C value GSimpleAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleActionToGlibFull(c SimpleAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleAction wraps g_simple_action_new
// 
// see also https://docs.gtk.org/gio/func.g_simple_action_new.html
//
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.GVariantType  // in, none, converted, nullable
	var cret  *C.GSimpleAction // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if parameterType != nil {
		carg2 = (*C.GVariantType)(glib.UnsafeVariantTypeToGlibNone(parameterType))
	}

	cret = C.g_simple_action_new(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameterType)

	var goret SimpleAction

	goret = UnsafeSimpleActionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetEnabled wraps g_simple_action_set_enabled
// 
// see also https://docs.gtk.org/gio/method.g_simple_action_set_enabled.g_simple_action_set_enabled.html
//
func (simple *SimpleActionInstance) SetEnabled(enabled bool) {
	var carg0 *C.GSimpleAction // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSimpleAction)(UnsafeSimpleActionToGlibNone(simple))
	if enabled {
		carg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(enabled)
}

// SimpleActionGroupInstance is the instance type used by all types extending GSimpleActionGroup. It is used internally by the bindings. Users should use the interface [SimpleActionGroup] instead.
type SimpleActionGroupInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleActionGroup = (*SimpleActionGroupInstance)(nil)

// SimpleActionGroup wraps GSimpleActionGroup
// 
// see also https://docs.gtk.org/gio/class.SimpleActionGroup.html
//
type SimpleActionGroup interface {
	gobject.Object
	upcastToGSimpleActionGroup() *SimpleActionGroupInstance

	// Insert wraps g_simple_action_group_insert
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_action_group_insert.g_simple_action_group_insert.html
	//
	//
	// Deprecated: (since 2.38.0) Use g_action_map_add_action()
	Insert(Action)
	// Lookup wraps g_simple_action_group_lookup
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_action_group_lookup.g_simple_action_group_lookup.html
	//
	//
	// Deprecated: (since 2.38.0) Use g_action_map_lookup_action()
	Lookup(string) Action
	// Remove wraps g_simple_action_group_remove
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_action_group_remove.g_simple_action_group_remove.html
	//
	//
	// Deprecated: (since 2.38.0) Use g_action_map_remove_action()
	Remove(string)

	// chain up virtual methods:
}

func unsafeWrapSimpleActionGroup(base *gobject.ObjectInstance) *SimpleActionGroupInstance {
	return &SimpleActionGroupInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleActionGroup,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleActionGroup(inst)
		},
	)
}

func marshalSimpleActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleActionGroupFromGlibNone is used to convert raw GSimpleActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibNone(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleActionGroup)
}

// UnsafeSimpleActionGroupFromGlibFull is used to convert raw GSimpleActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibFull(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleActionGroup)
}

// UnsafeSimpleActionGroupFromGlibBorrow is used to convert raw GSimpleActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibBorrow(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleActionGroup)
}

func (s *SimpleActionGroupInstance) upcastToGSimpleActionGroup() *SimpleActionGroupInstance {
	return s
}

// UnsafeSimpleActionGroupToGlibNone is used to convert the instance to it's C value GSimpleActionGroup. This is used by the bindings internally.
func UnsafeSimpleActionGroupToGlibNone(c SimpleActionGroup) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleActionGroupToGlibFull is used to convert the instance to it's C value GSimpleActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupToGlibFull(c SimpleActionGroup) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleActionGroup wraps g_simple_action_group_new
// 
// see also https://docs.gtk.org/gio/func.g_simple_action_group_new.html
//
func NewSimpleActionGroup() SimpleActionGroup {
	var cret *C.GSimpleActionGroup // return, full, converted

	cret = C.g_simple_action_group_new()

	var goret SimpleActionGroup

	goret = UnsafeSimpleActionGroupFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Insert wraps g_simple_action_group_insert
// 
// see also https://docs.gtk.org/gio/method.g_simple_action_group_insert.g_simple_action_group_insert.html
//
//
// Deprecated: (since 2.38.0) Use g_action_map_add_action()
func (simple *SimpleActionGroupInstance) Insert(action Action) {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.GAction            // in, none, converted

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.GAction)(UnsafeActionToGlibNone(action))

	C.g_simple_action_group_insert(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(action)
}

// Lookup wraps g_simple_action_group_lookup
// 
// see also https://docs.gtk.org/gio/method.g_simple_action_group_lookup.g_simple_action_group_lookup.html
//
//
// Deprecated: (since 2.38.0) Use g_action_map_lookup_action()
func (simple *SimpleActionGroupInstance) Lookup(actionName string) Action {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var cret  *C.GAction            // return, none, converted

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_simple_action_group_lookup(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)

	var goret Action

	goret = UnsafeActionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Remove wraps g_simple_action_group_remove
// 
// see also https://docs.gtk.org/gio/method.g_simple_action_group_remove.g_simple_action_group_remove.html
//
//
// Deprecated: (since 2.38.0) Use g_action_map_remove_action()
func (simple *SimpleActionGroupInstance) Remove(actionName string) {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.gchar              // in, none, string

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_simple_action_group_remove(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)
}

// SimpleActionGroupOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SimpleActionGroupOverrides[Instance SimpleActionGroup] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySimpleActionGroupOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySimpleActionGroupOverrides[Instance SimpleActionGroup](gclass unsafe.Pointer, overrides SimpleActionGroupOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSimpleActionGroupSubClass is used to register a go subclass of GSimpleActionGroup. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSimpleActionGroupSubClass[InstanceT SimpleActionGroup](
		name string,
		classInit func(class *SimpleActionGroupClass),
		constructor func() InstanceT,
		overrides SimpleActionGroupOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSimpleActionGroup,
		UnsafeSimpleActionGroupClassFromGlibBorrow,
		UnsafeApplySimpleActionGroupOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleActionGroup(obj)
		},
		interfaceInits...,
	)
}

// SimpleAsyncResultInstance is the instance type used by all types extending GSimpleAsyncResult. It is used internally by the bindings. Users should use the interface [SimpleAsyncResult] instead.
type SimpleAsyncResultInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleAsyncResult = (*SimpleAsyncResultInstance)(nil)

// SimpleAsyncResult wraps GSimpleAsyncResult
// 
// see also https://docs.gtk.org/gio/class.SimpleAsyncResult.html
//
type SimpleAsyncResult interface {
	gobject.Object
	upcastToGSimpleAsyncResult() *SimpleAsyncResultInstance

	// Complete wraps g_simple_async_result_complete
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_complete.g_simple_async_result_complete.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	Complete()
	// CompleteInIdle wraps g_simple_async_result_complete_in_idle
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_complete_in_idle.g_simple_async_result_complete_in_idle.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	CompleteInIdle()
	// GetOpResGboolean wraps g_simple_async_result_get_op_res_gboolean
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_get_op_res_gboolean.g_simple_async_result_get_op_res_gboolean.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_boolean() instead.
	GetOpResGboolean() bool
	// GetOpResGssize wraps g_simple_async_result_get_op_res_gssize
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_get_op_res_gssize.g_simple_async_result_get_op_res_gssize.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_int() instead.
	GetOpResGssize() int
	// PropagateError wraps g_simple_async_result_propagate_error
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_propagate_error.g_simple_async_result_propagate_error.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	PropagateError() (bool, error)
	// SetCheckCancellable wraps g_simple_async_result_set_check_cancellable
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_check_cancellable.g_simple_async_result_set_check_cancellable.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	SetCheckCancellable(Cancellable)
	// SetHandleCancellation wraps g_simple_async_result_set_handle_cancellation
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_handle_cancellation.g_simple_async_result_set_handle_cancellation.html
	//
	//
	// Deprecated: (since 2.46.0) 
	SetHandleCancellation(bool)
	// SetOpResGboolean wraps g_simple_async_result_set_op_res_gboolean
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_op_res_gboolean.g_simple_async_result_set_op_res_gboolean.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_return_boolean() instead.
	SetOpResGboolean(bool)
	// SetOpResGssize wraps g_simple_async_result_set_op_res_gssize
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_op_res_gssize.g_simple_async_result_set_op_res_gssize.html
	//
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_return_int() instead.
	SetOpResGssize(int)
}

func unsafeWrapSimpleAsyncResult(base *gobject.ObjectInstance) *SimpleAsyncResultInstance {
	return &SimpleAsyncResultInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleAsyncResult,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleAsyncResult(inst)
		},
	)
}

func marshalSimpleAsyncResultInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleAsyncResultFromGlibNone is used to convert raw GSimpleAsyncResult pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibNone(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleAsyncResult)
}

// UnsafeSimpleAsyncResultFromGlibFull is used to convert raw GSimpleAsyncResult pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibFull(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleAsyncResult)
}

// UnsafeSimpleAsyncResultFromGlibBorrow is used to convert raw GSimpleAsyncResult pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibBorrow(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleAsyncResult)
}

func (s *SimpleAsyncResultInstance) upcastToGSimpleAsyncResult() *SimpleAsyncResultInstance {
	return s
}

// UnsafeSimpleAsyncResultToGlibNone is used to convert the instance to it's C value GSimpleAsyncResult. This is used by the bindings internally.
func UnsafeSimpleAsyncResultToGlibNone(c SimpleAsyncResult) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleAsyncResultToGlibFull is used to convert the instance to it's C value GSimpleAsyncResult, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultToGlibFull(c SimpleAsyncResult) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Complete wraps g_simple_async_result_complete
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_complete.g_simple_async_result_complete.html
//
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) Complete() {
	var carg0 *C.GSimpleAsyncResult // in, none, converted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	C.g_simple_async_result_complete(carg0)
	runtime.KeepAlive(simple)
}

// CompleteInIdle wraps g_simple_async_result_complete_in_idle
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_complete_in_idle.g_simple_async_result_complete_in_idle.html
//
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) CompleteInIdle() {
	var carg0 *C.GSimpleAsyncResult // in, none, converted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	C.g_simple_async_result_complete_in_idle(carg0)
	runtime.KeepAlive(simple)
}

// GetOpResGboolean wraps g_simple_async_result_get_op_res_gboolean
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_get_op_res_gboolean.g_simple_async_result_get_op_res_gboolean.html
//
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_boolean() instead.
func (simple *SimpleAsyncResultInstance) GetOpResGboolean() bool {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_get_op_res_gboolean(carg0)
	runtime.KeepAlive(simple)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetOpResGssize wraps g_simple_async_result_get_op_res_gssize
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_get_op_res_gssize.g_simple_async_result_get_op_res_gssize.html
//
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_int() instead.
func (simple *SimpleAsyncResultInstance) GetOpResGssize() int {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gssize              // return, none, casted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_get_op_res_gssize(carg0)
	runtime.KeepAlive(simple)

	var goret int

	goret = int(cret)

	return goret
}

// PropagateError wraps g_simple_async_result_propagate_error
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_propagate_error.g_simple_async_result_propagate_error.html
//
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) PropagateError() (bool, error) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_propagate_error(carg0, &_cerr)
	runtime.KeepAlive(simple)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetCheckCancellable wraps g_simple_async_result_set_check_cancellable
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_check_cancellable.g_simple_async_result_set_check_cancellable.html
//
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) SetCheckCancellable(checkCancellable Cancellable) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if checkCancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(checkCancellable))
	}

	C.g_simple_async_result_set_check_cancellable(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(checkCancellable)
}

// SetHandleCancellation wraps g_simple_async_result_set_handle_cancellation
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_handle_cancellation.g_simple_async_result_set_handle_cancellation.html
//
//
// Deprecated: (since 2.46.0) 
func (simple *SimpleAsyncResultInstance) SetHandleCancellation(handleCancellation bool) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if handleCancellation {
		carg1 = C.TRUE
	}

	C.g_simple_async_result_set_handle_cancellation(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(handleCancellation)
}

// SetOpResGboolean wraps g_simple_async_result_set_op_res_gboolean
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_op_res_gboolean.g_simple_async_result_set_op_res_gboolean.html
//
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_return_boolean() instead.
func (simple *SimpleAsyncResultInstance) SetOpResGboolean(opRes bool) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if opRes {
		carg1 = C.TRUE
	}

	C.g_simple_async_result_set_op_res_gboolean(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SetOpResGssize wraps g_simple_async_result_set_op_res_gssize
// 
// see also https://docs.gtk.org/gio/method.g_simple_async_result_set_op_res_gssize.g_simple_async_result_set_op_res_gssize.html
//
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_return_int() instead.
func (simple *SimpleAsyncResultInstance) SetOpResGssize(opRes int) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gssize              // in, none, casted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	carg1 = C.gssize(opRes)

	C.g_simple_async_result_set_op_res_gssize(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SimpleIOStreamInstance is the instance type used by all types extending GSimpleIOStream. It is used internally by the bindings. Users should use the interface [SimpleIOStream] instead.
type SimpleIOStreamInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ SimpleIOStream = (*SimpleIOStreamInstance)(nil)

// SimpleIOStream wraps GSimpleIOStream
// 
// see also https://docs.gtk.org/gio/class.SimpleIOStream.html
//
type SimpleIOStream interface {
	IOStream
	upcastToGSimpleIOStream() *SimpleIOStreamInstance
}

func unsafeWrapSimpleIOStream(base *gobject.ObjectInstance) *SimpleIOStreamInstance {
	return &SimpleIOStreamInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleIOStream(inst)
		},
	)
}

func marshalSimpleIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleIOStreamFromGlibNone is used to convert raw GSimpleIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibNone(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleIOStream)
}

// UnsafeSimpleIOStreamFromGlibFull is used to convert raw GSimpleIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibFull(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleIOStream)
}

// UnsafeSimpleIOStreamFromGlibBorrow is used to convert raw GSimpleIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibBorrow(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleIOStream)
}

func (s *SimpleIOStreamInstance) upcastToGSimpleIOStream() *SimpleIOStreamInstance {
	return s
}

// UnsafeSimpleIOStreamToGlibNone is used to convert the instance to it's C value GSimpleIOStream. This is used by the bindings internally.
func UnsafeSimpleIOStreamToGlibNone(c SimpleIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleIOStreamToGlibFull is used to convert the instance to it's C value GSimpleIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamToGlibFull(c SimpleIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleIOStream wraps g_simple_io_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_simple_io_stream_new.html
//
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) IOStream {
	var carg1 *C.GInputStream  // in, none, converted
	var carg2 *C.GOutputStream // in, none, converted
	var cret  *C.GIOStream     // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(inputStream))
	carg2 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(outputStream))

	cret = C.g_simple_io_stream_new(carg1, carg2)
	runtime.KeepAlive(inputStream)
	runtime.KeepAlive(outputStream)

	var goret IOStream

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SimplePermissionInstance is the instance type used by all types extending GSimplePermission. It is used internally by the bindings. Users should use the interface [SimplePermission] instead.
type SimplePermissionInstance struct {
	_ [0]func() // equal guard
	PermissionInstance
}

var _ SimplePermission = (*SimplePermissionInstance)(nil)

// SimplePermission wraps GSimplePermission
// 
// see also https://docs.gtk.org/gio/class.SimplePermission.html
//
type SimplePermission interface {
	Permission
	upcastToGSimplePermission() *SimplePermissionInstance
}

func unsafeWrapSimplePermission(base *gobject.ObjectInstance) *SimplePermissionInstance {
	return &SimplePermissionInstance{
		PermissionInstance: PermissionInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimplePermission,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimplePermission(inst)
		},
	)
}

func marshalSimplePermissionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimplePermissionFromGlibNone is used to convert raw GSimplePermission pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibNone(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibNone(c).(SimplePermission)
}

// UnsafeSimplePermissionFromGlibFull is used to convert raw GSimplePermission pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibFull(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibFull(c).(SimplePermission)
}

// UnsafeSimplePermissionFromGlibBorrow is used to convert raw GSimplePermission pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibBorrow(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimplePermission)
}

func (s *SimplePermissionInstance) upcastToGSimplePermission() *SimplePermissionInstance {
	return s
}

// UnsafeSimplePermissionToGlibNone is used to convert the instance to it's C value GSimplePermission. This is used by the bindings internally.
func UnsafeSimplePermissionToGlibNone(c SimplePermission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimplePermissionToGlibFull is used to convert the instance to it's C value GSimplePermission, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionToGlibFull(c SimplePermission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimplePermission wraps g_simple_permission_new
// 
// see also https://docs.gtk.org/gio/func.g_simple_permission_new.html
//
func NewSimplePermission(allowed bool) Permission {
	var carg1 C.gboolean     // in
	var cret  *C.GPermission // return, full, converted

	if allowed {
		carg1 = C.TRUE
	}

	cret = C.g_simple_permission_new(carg1)
	runtime.KeepAlive(allowed)

	var goret Permission

	goret = UnsafePermissionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SimpleProxyResolverInstance is the instance type used by all types extending GSimpleProxyResolver. It is used internally by the bindings. Users should use the interface [SimpleProxyResolver] instead.
type SimpleProxyResolverInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleProxyResolver = (*SimpleProxyResolverInstance)(nil)

// SimpleProxyResolver wraps GSimpleProxyResolver
// 
// see also https://docs.gtk.org/gio/class.SimpleProxyResolver.html
//
type SimpleProxyResolver interface {
	gobject.Object
	upcastToGSimpleProxyResolver() *SimpleProxyResolverInstance

	// SetDefaultProxy wraps g_simple_proxy_resolver_set_default_proxy
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_default_proxy.g_simple_proxy_resolver_set_default_proxy.html
	//
	SetDefaultProxy(string)
	// SetIgnoreHosts wraps g_simple_proxy_resolver_set_ignore_hosts
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_ignore_hosts.g_simple_proxy_resolver_set_ignore_hosts.html
	//
	SetIgnoreHosts([]string)
	// SetURIProxy wraps g_simple_proxy_resolver_set_uri_proxy
	// 
	// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_uri_proxy.g_simple_proxy_resolver_set_uri_proxy.html
	//
	SetURIProxy(string, string)

	// chain up virtual methods:
}

func unsafeWrapSimpleProxyResolver(base *gobject.ObjectInstance) *SimpleProxyResolverInstance {
	return &SimpleProxyResolverInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleProxyResolver,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleProxyResolver(inst)
		},
	)
}

func marshalSimpleProxyResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleProxyResolverFromGlibNone is used to convert raw GSimpleProxyResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibNone(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleProxyResolver)
}

// UnsafeSimpleProxyResolverFromGlibFull is used to convert raw GSimpleProxyResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibFull(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleProxyResolver)
}

// UnsafeSimpleProxyResolverFromGlibBorrow is used to convert raw GSimpleProxyResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibBorrow(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleProxyResolver)
}

func (s *SimpleProxyResolverInstance) upcastToGSimpleProxyResolver() *SimpleProxyResolverInstance {
	return s
}

// UnsafeSimpleProxyResolverToGlibNone is used to convert the instance to it's C value GSimpleProxyResolver. This is used by the bindings internally.
func UnsafeSimpleProxyResolverToGlibNone(c SimpleProxyResolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleProxyResolverToGlibFull is used to convert the instance to it's C value GSimpleProxyResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverToGlibFull(c SimpleProxyResolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleProxyResolver wraps g_simple_proxy_resolver_new
// 
// see also https://docs.gtk.org/gio/func.g_simple_proxy_resolver_new.html
//
func NewSimpleProxyResolver(defaultProxy string, ignoreHosts []string) ProxyResolver {
	var carg1 *C.gchar          // in, none, string, nullable-string
	var carg2 **C.gchar         // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.GProxyResolver // return, full, converted

	if defaultProxy != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = ignoreHosts
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_simple_proxy_resolver_new(carg1, carg2)
	runtime.KeepAlive(defaultProxy)
	runtime.KeepAlive(ignoreHosts)

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetDefaultProxy wraps g_simple_proxy_resolver_set_default_proxy
// 
// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_default_proxy.g_simple_proxy_resolver_set_default_proxy.html
//
func (resolver *SimpleProxyResolverInstance) SetDefaultProxy(defaultProxy string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 *C.gchar                // in, none, string, nullable-string

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	if defaultProxy != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_simple_proxy_resolver_set_default_proxy(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(defaultProxy)
}

// SetIgnoreHosts wraps g_simple_proxy_resolver_set_ignore_hosts
// 
// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_ignore_hosts.g_simple_proxy_resolver_set_ignore_hosts.html
//
func (resolver *SimpleProxyResolverInstance) SetIgnoreHosts(ignoreHosts []string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 **C.gchar               // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	_ = ignoreHosts
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	C.g_simple_proxy_resolver_set_ignore_hosts(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ignoreHosts)
}

// SetURIProxy wraps g_simple_proxy_resolver_set_uri_proxy
// 
// see also https://docs.gtk.org/gio/method.g_simple_proxy_resolver_set_uri_proxy.g_simple_proxy_resolver_set_uri_proxy.html
//
func (resolver *SimpleProxyResolverInstance) SetURIProxy(uriScheme string, proxy string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 *C.gchar                // in, none, string
	var carg2 *C.gchar                // in, none, string

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(proxy)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_simple_proxy_resolver_set_uri_proxy(carg0, carg1, carg2)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(proxy)
}

// SimpleProxyResolverOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SimpleProxyResolverOverrides[Instance SimpleProxyResolver] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySimpleProxyResolverOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySimpleProxyResolverOverrides[Instance SimpleProxyResolver](gclass unsafe.Pointer, overrides SimpleProxyResolverOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSimpleProxyResolverSubClass is used to register a go subclass of GSimpleProxyResolver. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSimpleProxyResolverSubClass[InstanceT SimpleProxyResolver](
		name string,
		classInit func(class *SimpleProxyResolverClass),
		constructor func() InstanceT,
		overrides SimpleProxyResolverOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSimpleProxyResolver,
		UnsafeSimpleProxyResolverClassFromGlibBorrow,
		UnsafeApplySimpleProxyResolverOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleProxyResolver(obj)
		},
		interfaceInits...,
	)
}

// SocketInstance is the instance type used by all types extending GSocket. It is used internally by the bindings. Users should use the interface [Socket] instead.
type SocketInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Socket = (*SocketInstance)(nil)

// Socket wraps GSocket
// 
// see also https://docs.gtk.org/gio/class.Socket.html
//
type Socket interface {
	gobject.Object
	upcastToGSocket() *SocketInstance

	// Accept wraps g_socket_accept
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_accept.g_socket_accept.html
	//
	Accept(Cancellable) (Socket, error)
	// Bind wraps g_socket_bind
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_bind.g_socket_bind.html
	//
	Bind(SocketAddress, bool) (bool, error)
	// CheckConnectResult wraps g_socket_check_connect_result
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_check_connect_result.g_socket_check_connect_result.html
	//
	CheckConnectResult() (bool, error)
	// Close wraps g_socket_close
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_close.g_socket_close.html
	//
	Close() (bool, error)
	// ConditionCheck wraps g_socket_condition_check
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_condition_check.g_socket_condition_check.html
	//
	ConditionCheck(glib.IOCondition) glib.IOCondition
	// ConditionTimedWait wraps g_socket_condition_timed_wait
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_condition_timed_wait.g_socket_condition_timed_wait.html
	//
	ConditionTimedWait(glib.IOCondition, int64, Cancellable) (bool, error)
	// ConditionWait wraps g_socket_condition_wait
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_condition_wait.g_socket_condition_wait.html
	//
	ConditionWait(glib.IOCondition, Cancellable) (bool, error)
	// ConnectSocket wraps g_socket_connect
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connect.g_socket_connect.html
	//
	ConnectSocket(SocketAddress, Cancellable) (bool, error)
	// ConnectionFactoryCreateConnection wraps g_socket_connection_factory_create_connection
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_factory_create_connection.g_socket_connection_factory_create_connection.html
	//
	ConnectionFactoryCreateConnection() SocketConnection
	// GetAvailableBytes wraps g_socket_get_available_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_available_bytes.g_socket_get_available_bytes.html
	//
	GetAvailableBytes() int
	// GetBlocking wraps g_socket_get_blocking
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_blocking.g_socket_get_blocking.html
	//
	GetBlocking() bool
	// GetBroadcast wraps g_socket_get_broadcast
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_broadcast.g_socket_get_broadcast.html
	//
	GetBroadcast() bool
	// GetCredentials wraps g_socket_get_credentials
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_credentials.g_socket_get_credentials.html
	//
	GetCredentials() (Credentials, error)
	// GetFamily wraps g_socket_get_family
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_family.g_socket_get_family.html
	//
	GetFamily() SocketFamily
	// GetFd wraps g_socket_get_fd
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_fd.g_socket_get_fd.html
	//
	GetFd() int32
	// GetKeepalive wraps g_socket_get_keepalive
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_keepalive.g_socket_get_keepalive.html
	//
	GetKeepalive() bool
	// GetListenBacklog wraps g_socket_get_listen_backlog
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_listen_backlog.g_socket_get_listen_backlog.html
	//
	GetListenBacklog() int32
	// GetLocalAddress wraps g_socket_get_local_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_local_address.g_socket_get_local_address.html
	//
	GetLocalAddress() (SocketAddress, error)
	// GetMulticastLoopback wraps g_socket_get_multicast_loopback
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_multicast_loopback.g_socket_get_multicast_loopback.html
	//
	GetMulticastLoopback() bool
	// GetMulticastTtl wraps g_socket_get_multicast_ttl
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_multicast_ttl.g_socket_get_multicast_ttl.html
	//
	GetMulticastTtl() uint
	// GetOption wraps g_socket_get_option
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_option.g_socket_get_option.html
	//
	GetOption(int32, int32) (int32, bool, error)
	// GetProtocol wraps g_socket_get_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_protocol.g_socket_get_protocol.html
	//
	GetProtocol() SocketProtocol
	// GetRemoteAddress wraps g_socket_get_remote_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_remote_address.g_socket_get_remote_address.html
	//
	GetRemoteAddress() (SocketAddress, error)
	// GetSocketType wraps g_socket_get_socket_type
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_socket_type.g_socket_get_socket_type.html
	//
	GetSocketType() SocketType
	// GetTimeout wraps g_socket_get_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_timeout.g_socket_get_timeout.html
	//
	GetTimeout() uint
	// GetTtl wraps g_socket_get_ttl
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_get_ttl.g_socket_get_ttl.html
	//
	GetTtl() uint
	// IsClosed wraps g_socket_is_closed
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_is_closed.g_socket_is_closed.html
	//
	IsClosed() bool
	// IsConnected wraps g_socket_is_connected
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_is_connected.g_socket_is_connected.html
	//
	IsConnected() bool
	// JoinMulticastGroup wraps g_socket_join_multicast_group
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_join_multicast_group.g_socket_join_multicast_group.html
	//
	JoinMulticastGroup(InetAddress, bool, string) (bool, error)
	// JoinMulticastGroupSsm wraps g_socket_join_multicast_group_ssm
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_join_multicast_group_ssm.g_socket_join_multicast_group_ssm.html
	//
	JoinMulticastGroupSsm(InetAddress, InetAddress, string) (bool, error)
	// LeaveMulticastGroup wraps g_socket_leave_multicast_group
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_leave_multicast_group.g_socket_leave_multicast_group.html
	//
	LeaveMulticastGroup(InetAddress, bool, string) (bool, error)
	// LeaveMulticastGroupSsm wraps g_socket_leave_multicast_group_ssm
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_leave_multicast_group_ssm.g_socket_leave_multicast_group_ssm.html
	//
	LeaveMulticastGroupSsm(InetAddress, InetAddress, string) (bool, error)
	// Listen wraps g_socket_listen
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listen.g_socket_listen.html
	//
	Listen() (bool, error)
	// ReceiveBytes wraps g_socket_receive_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_receive_bytes.g_socket_receive_bytes.html
	//
	ReceiveBytes(uint, int64, Cancellable) (*glib.Bytes, error)
	// ReceiveBytesFrom wraps g_socket_receive_bytes_from
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_receive_bytes_from.g_socket_receive_bytes_from.html
	//
	ReceiveBytesFrom(uint, int64, Cancellable) (SocketAddress, *glib.Bytes, error)
	// ReceiveMessages wraps g_socket_receive_messages
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_receive_messages.g_socket_receive_messages.html
	//
	ReceiveMessages([]InputMessage, int32, Cancellable) (int32, error)
	// Send wraps g_socket_send
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send.g_socket_send.html
	//
	Send(string, Cancellable) (int, error)
	// SendMessage wraps g_socket_send_message
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send_message.g_socket_send_message.html
	//
	SendMessage(SocketAddress, []OutputVector, []SocketControlMessage, int32, Cancellable) (int, error)
	// SendMessageWithTimeout wraps g_socket_send_message_with_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send_message_with_timeout.g_socket_send_message_with_timeout.html
	//
	SendMessageWithTimeout(SocketAddress, []OutputVector, []SocketControlMessage, int32, int64, Cancellable) (uint, PollableReturn, error)
	// SendMessages wraps g_socket_send_messages
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send_messages.g_socket_send_messages.html
	//
	SendMessages([]OutputMessage, int32, Cancellable) (int32, error)
	// SendTo wraps g_socket_send_to
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send_to.g_socket_send_to.html
	//
	SendTo(SocketAddress, string, Cancellable) (int, error)
	// SendWithBlocking wraps g_socket_send_with_blocking
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_send_with_blocking.g_socket_send_with_blocking.html
	//
	SendWithBlocking(string, bool, Cancellable) (int, error)
	// SetBlocking wraps g_socket_set_blocking
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_blocking.g_socket_set_blocking.html
	//
	SetBlocking(bool)
	// SetBroadcast wraps g_socket_set_broadcast
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_broadcast.g_socket_set_broadcast.html
	//
	SetBroadcast(bool)
	// SetKeepalive wraps g_socket_set_keepalive
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_keepalive.g_socket_set_keepalive.html
	//
	SetKeepalive(bool)
	// SetListenBacklog wraps g_socket_set_listen_backlog
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_listen_backlog.g_socket_set_listen_backlog.html
	//
	SetListenBacklog(int32)
	// SetMulticastLoopback wraps g_socket_set_multicast_loopback
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_multicast_loopback.g_socket_set_multicast_loopback.html
	//
	SetMulticastLoopback(bool)
	// SetMulticastTtl wraps g_socket_set_multicast_ttl
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_multicast_ttl.g_socket_set_multicast_ttl.html
	//
	SetMulticastTtl(uint)
	// SetOption wraps g_socket_set_option
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_option.g_socket_set_option.html
	//
	SetOption(int32, int32, int32) (bool, error)
	// SetTimeout wraps g_socket_set_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_timeout.g_socket_set_timeout.html
	//
	SetTimeout(uint)
	// SetTtl wraps g_socket_set_ttl
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_set_ttl.g_socket_set_ttl.html
	//
	SetTtl(uint)
	// Shutdown wraps g_socket_shutdown
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_shutdown.g_socket_shutdown.html
	//
	Shutdown(bool, bool) (bool, error)
	// SpeaksIpv4 wraps g_socket_speaks_ipv4
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_speaks_ipv4.g_socket_speaks_ipv4.html
	//
	SpeaksIpv4() bool

	// chain up virtual methods:
}

func unsafeWrapSocket(base *gobject.ObjectInstance) *SocketInstance {
	return &SocketInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocket,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocket(inst)
		},
	)
}

func marshalSocketInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketFromGlibNone is used to convert raw GSocket pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketFromGlibNone(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibNone(c).(Socket)
}

// UnsafeSocketFromGlibFull is used to convert raw GSocket pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketFromGlibFull(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibFull(c).(Socket)
}

// UnsafeSocketFromGlibBorrow is used to convert raw GSocket pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketFromGlibBorrow(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Socket)
}

func (s *SocketInstance) upcastToGSocket() *SocketInstance {
	return s
}

// UnsafeSocketToGlibNone is used to convert the instance to it's C value GSocket. This is used by the bindings internally.
func UnsafeSocketToGlibNone(c Socket) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketToGlibFull is used to convert the instance to it's C value GSocket, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketToGlibFull(c Socket) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocket wraps g_socket_new
// 
// see also https://docs.gtk.org/gio/func.g_socket_new.html
//
func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (Socket, error) {
	var carg1 C.GSocketFamily   // in, none, casted
	var carg2 C.GSocketType     // in, none, casted
	var carg3 C.GSocketProtocol // in, none, casted
	var cret  *C.GSocket        // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg1 = C.GSocketFamily(family)
	carg2 = C.GSocketType(typ)
	carg3 = C.GSocketProtocol(protocol)

	cret = C.g_socket_new(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewSocketFromFd wraps g_socket_new_from_fd
// 
// see also https://docs.gtk.org/gio/func.g_socket_new_from_fd.html
//
func NewSocketFromFd(fd int32) (Socket, error) {
	var carg1 C.gint     // in, none, casted
	var cret  *C.GSocket // return, full, converted
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = C.gint(fd)

	cret = C.g_socket_new_from_fd(carg1, &_cerr)
	runtime.KeepAlive(fd)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Accept wraps g_socket_accept
// 
// see also https://docs.gtk.org/gio/method.g_socket_accept.g_socket_accept.html
//
func (socket *SocketInstance) Accept(cancellable Cancellable) (Socket, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GSocket      // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_accept(carg0, carg1, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(cancellable)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Bind wraps g_socket_bind
// 
// see also https://docs.gtk.org/gio/method.g_socket_bind.g_socket_bind.html
//
func (socket *SocketInstance) Bind(address SocketAddress, allowReuse bool) (bool, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted
	var carg2 C.gboolean        // in
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if allowReuse {
		carg2 = C.TRUE
	}

	cret = C.g_socket_bind(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(allowReuse)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CheckConnectResult wraps g_socket_check_connect_result
// 
// see also https://docs.gtk.org/gio/method.g_socket_check_connect_result.g_socket_check_connect_result.html
//
func (socket *SocketInstance) CheckConnectResult() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_check_connect_result(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_socket_close
// 
// see also https://docs.gtk.org/gio/method.g_socket_close.g_socket_close.html
//
func (socket *SocketInstance) Close() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_close(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConditionCheck wraps g_socket_condition_check
// 
// see also https://docs.gtk.org/gio/method.g_socket_condition_check.g_socket_condition_check.html
//
func (socket *SocketInstance) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var carg0 *C.GSocket     // in, none, converted
	var carg1 C.GIOCondition // in, none, casted
	var cret  C.GIOCondition // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)

	cret = C.g_socket_condition_check(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)

	var goret glib.IOCondition

	goret = glib.IOCondition(cret)

	return goret
}

// ConditionTimedWait wraps g_socket_condition_timed_wait
// 
// see also https://docs.gtk.org/gio/method.g_socket_condition_timed_wait.g_socket_condition_timed_wait.html
//
func (socket *SocketInstance) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.GIOCondition  // in, none, casted
	var carg2 C.gint64        // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)
	carg2 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_condition_timed_wait(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConditionWait wraps g_socket_condition_wait
// 
// see also https://docs.gtk.org/gio/method.g_socket_condition_wait.g_socket_condition_wait.html
//
func (socket *SocketInstance) ConditionWait(condition glib.IOCondition, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.GIOCondition  // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_condition_wait(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectSocket wraps g_socket_connect
// 
// see also https://docs.gtk.org/gio/method.g_socket_connect.g_socket_connect.html
//
func (socket *SocketInstance) ConnectSocket(address SocketAddress, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted
	var carg2 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectionFactoryCreateConnection wraps g_socket_connection_factory_create_connection
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_factory_create_connection.g_socket_connection_factory_create_connection.html
//
func (socket *SocketInstance) ConnectionFactoryCreateConnection() SocketConnection {
	var carg0 *C.GSocket           // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_connection_factory_create_connection(carg0)
	runtime.KeepAlive(socket)

	var goret SocketConnection

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAvailableBytes wraps g_socket_get_available_bytes
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_available_bytes.g_socket_get_available_bytes.html
//
func (socket *SocketInstance) GetAvailableBytes() int {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gssize   // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_available_bytes(carg0)
	runtime.KeepAlive(socket)

	var goret int

	goret = int(cret)

	return goret
}

// GetBlocking wraps g_socket_get_blocking
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_blocking.g_socket_get_blocking.html
//
func (socket *SocketInstance) GetBlocking() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_blocking(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetBroadcast wraps g_socket_get_broadcast
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_broadcast.g_socket_get_broadcast.html
//
func (socket *SocketInstance) GetBroadcast() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_broadcast(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCredentials wraps g_socket_get_credentials
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_credentials.g_socket_get_credentials.html
//
func (socket *SocketInstance) GetCredentials() (Credentials, error) {
	var carg0 *C.GSocket      // in, none, converted
	var cret  *C.GCredentials // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_credentials(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  Credentials
	var _goerr error

	goret = UnsafeCredentialsFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetFamily wraps g_socket_get_family
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_family.g_socket_get_family.html
//
func (socket *SocketInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocket      // in, none, converted
	var cret  C.GSocketFamily // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_family(carg0)
	runtime.KeepAlive(socket)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetFd wraps g_socket_get_fd
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_fd.g_socket_get_fd.html
//
func (socket *SocketInstance) GetFd() int32 {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.int      // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_fd(carg0)
	runtime.KeepAlive(socket)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetKeepalive wraps g_socket_get_keepalive
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_keepalive.g_socket_get_keepalive.html
//
func (socket *SocketInstance) GetKeepalive() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_keepalive(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetListenBacklog wraps g_socket_get_listen_backlog
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_listen_backlog.g_socket_get_listen_backlog.html
//
func (socket *SocketInstance) GetListenBacklog() int32 {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gint     // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_listen_backlog(carg0)
	runtime.KeepAlive(socket)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetLocalAddress wraps g_socket_get_local_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_local_address.g_socket_get_local_address.html
//
func (socket *SocketInstance) GetLocalAddress() (SocketAddress, error) {
	var carg0 *C.GSocket        // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_local_address(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetMulticastLoopback wraps g_socket_get_multicast_loopback
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_multicast_loopback.g_socket_get_multicast_loopback.html
//
func (socket *SocketInstance) GetMulticastLoopback() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_multicast_loopback(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMulticastTtl wraps g_socket_get_multicast_ttl
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_multicast_ttl.g_socket_get_multicast_ttl.html
//
func (socket *SocketInstance) GetMulticastTtl() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_multicast_ttl(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetOption wraps g_socket_get_option
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_option.g_socket_get_option.html
//
func (socket *SocketInstance) GetOption(level int32, optname int32) (int32, bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted
	var carg2 C.gint     // in, none, casted
	var carg3 C.gint     // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(level)
	carg2 = C.gint(optname)

	cret = C.g_socket_get_option(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)

	var value  int32
	var goret  bool
	var _goerr error

	value = int32(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return value, goret, _goerr
}

// GetProtocol wraps g_socket_get_protocol
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_protocol.g_socket_get_protocol.html
//
func (socket *SocketInstance) GetProtocol() SocketProtocol {
	var carg0 *C.GSocket        // in, none, converted
	var cret  C.GSocketProtocol // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_protocol(carg0)
	runtime.KeepAlive(socket)

	var goret SocketProtocol

	goret = SocketProtocol(cret)

	return goret
}

// GetRemoteAddress wraps g_socket_get_remote_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_remote_address.g_socket_get_remote_address.html
//
func (socket *SocketInstance) GetRemoteAddress() (SocketAddress, error) {
	var carg0 *C.GSocket        // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_remote_address(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSocketType wraps g_socket_get_socket_type
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_socket_type.g_socket_get_socket_type.html
//
func (socket *SocketInstance) GetSocketType() SocketType {
	var carg0 *C.GSocket    // in, none, converted
	var cret  C.GSocketType // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_socket_type(carg0)
	runtime.KeepAlive(socket)

	var goret SocketType

	goret = SocketType(cret)

	return goret
}

// GetTimeout wraps g_socket_get_timeout
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_timeout.g_socket_get_timeout.html
//
func (socket *SocketInstance) GetTimeout() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_timeout(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetTtl wraps g_socket_get_ttl
// 
// see also https://docs.gtk.org/gio/method.g_socket_get_ttl.g_socket_get_ttl.html
//
func (socket *SocketInstance) GetTtl() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_ttl(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsClosed wraps g_socket_is_closed
// 
// see also https://docs.gtk.org/gio/method.g_socket_is_closed.g_socket_is_closed.html
//
func (socket *SocketInstance) IsClosed() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_is_closed(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsConnected wraps g_socket_is_connected
// 
// see also https://docs.gtk.org/gio/method.g_socket_is_connected.g_socket_is_connected.html
//
func (socket *SocketInstance) IsConnected() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_is_connected(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// JoinMulticastGroup wraps g_socket_join_multicast_group
// 
// see also https://docs.gtk.org/gio/method.g_socket_join_multicast_group.g_socket_join_multicast_group.html
//
func (socket *SocketInstance) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 C.gboolean      // in
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific {
		carg2 = C.TRUE
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_join_multicast_group(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// JoinMulticastGroupSsm wraps g_socket_join_multicast_group_ssm
// 
// see also https://docs.gtk.org/gio/method.g_socket_join_multicast_group_ssm.g_socket_join_multicast_group_ssm.html
//
func (socket *SocketInstance) JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GInetAddress // in, none, converted, nullable
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific != nil {
		carg2 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(sourceSpecific))
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_join_multicast_group_ssm(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LeaveMulticastGroup wraps g_socket_leave_multicast_group
// 
// see also https://docs.gtk.org/gio/method.g_socket_leave_multicast_group.g_socket_leave_multicast_group.html
//
func (socket *SocketInstance) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 C.gboolean      // in
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific {
		carg2 = C.TRUE
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_leave_multicast_group(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LeaveMulticastGroupSsm wraps g_socket_leave_multicast_group_ssm
// 
// see also https://docs.gtk.org/gio/method.g_socket_leave_multicast_group_ssm.g_socket_leave_multicast_group_ssm.html
//
func (socket *SocketInstance) LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GInetAddress // in, none, converted, nullable
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific != nil {
		carg2 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(sourceSpecific))
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_leave_multicast_group_ssm(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Listen wraps g_socket_listen
// 
// see also https://docs.gtk.org/gio/method.g_socket_listen.g_socket_listen.html
//
func (socket *SocketInstance) Listen() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_listen(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveBytes wraps g_socket_receive_bytes
// 
// see also https://docs.gtk.org/gio/method.g_socket_receive_bytes.g_socket_receive_bytes.html
//
func (socket *SocketInstance) ReceiveBytes(size uint, timeoutUs int64, cancellable Cancellable) (*glib.Bytes, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 C.gint64        // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gsize(size)
	carg2 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_bytes(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveBytesFrom wraps g_socket_receive_bytes_from
// 
// see also https://docs.gtk.org/gio/method.g_socket_receive_bytes_from.g_socket_receive_bytes_from.html
//
func (socket *SocketInstance) ReceiveBytesFrom(size uint, timeoutUs int64, cancellable Cancellable) (SocketAddress, *glib.Bytes, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg2 C.gsize           // in, none, casted
	var carg3 C.gint64          // in, none, casted
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var carg1 *C.GSocketAddress // out, full, converted
	var cret  *C.GBytes         // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg2 = C.gsize(size)
	carg3 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_bytes_from(carg0, &carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var address SocketAddress
	var goret   *glib.Bytes
	var _goerr  error

	address = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(carg1))
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return address, goret, _goerr
}

// ReceiveMessages wraps g_socket_receive_messages
// 
// see also https://docs.gtk.org/gio/method.g_socket_receive_messages.g_socket_receive_messages.html
//
func (socket *SocketInstance) ReceiveMessages(messages []InputMessage, flags int32, cancellable Cancellable) (int32, error) {
	var carg0 *C.GSocket       // in, none, converted
	var carg1 *C.GInputMessage // in, transfer: none, C Pointers: 1, Name: array[InputMessage], array (inner GInputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint          // implicit
	var carg3 C.gint           // in, none, casted
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gint           // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []InputMessage (GInputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_messages(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Send wraps g_socket_send
// 
// see also https://docs.gtk.org/gio/method.g_socket_send.g_socket_send.html
//
func (socket *SocketInstance) Send(buffer string, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.gchar        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize         // implicit
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessage wraps g_socket_send_message
// 
// see also https://docs.gtk.org/gio/method.g_socket_send_message.g_socket_send_message.html
//
func (socket *SocketInstance) SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int32, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket                // in, none, converted
	var carg1 *C.GSocketAddress         // in, none, converted, nullable
	var carg2 *C.GOutputVector          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg3)
	var carg3 C.gint                    // implicit
	var carg4 **C.GSocketControlMessage // in, transfer: none, C Pointers: 2, Name: array[SocketControlMessage], nullable, array (inner GSocketControlMessage* (*typesystem.Class), length-by: carg5)
	var carg5 C.gint                    // implicit
	var carg6 C.gint                    // in, none, casted
	var carg7 *C.GCancellable           // in, none, converted, nullable
	var cret  C.gssize                  // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = vectors
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	_ = messages
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []SocketControlMessage (GSocketControlMessage**) because of unimplemented: inner pointers in array")
	carg6 = C.gint(flags)
	if cancellable != nil {
		carg7 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_message(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessageWithTimeout wraps g_socket_send_message_with_timeout
// 
// see also https://docs.gtk.org/gio/method.g_socket_send_message_with_timeout.g_socket_send_message_with_timeout.html
//
func (socket *SocketInstance) SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int32, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error) {
	var carg0 *C.GSocket                // in, none, converted
	var carg1 *C.GSocketAddress         // in, none, converted, nullable
	var carg2 *C.GOutputVector          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg3)
	var carg3 C.gint                    // implicit
	var carg4 **C.GSocketControlMessage // in, transfer: none, C Pointers: 2, Name: array[SocketControlMessage], nullable, array (inner GSocketControlMessage* (*typesystem.Class), length-by: carg5)
	var carg5 C.gint                    // implicit
	var carg6 C.gint                    // in, none, casted
	var carg7 C.gint64                  // in, none, casted
	var carg9 *C.GCancellable           // in, none, converted, nullable
	var carg8 C.gsize                   // out, full, casted
	var cret  C.GPollableReturn         // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = vectors
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	_ = messages
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []SocketControlMessage (GSocketControlMessage**) because of unimplemented: inner pointers in array")
	carg6 = C.gint(flags)
	carg7 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg9 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_message_with_timeout(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, &carg8, carg9, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        PollableReturn
	var _goerr       error

	bytesWritten = uint(carg8)
	goret = PollableReturn(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// SendMessages wraps g_socket_send_messages
// 
// see also https://docs.gtk.org/gio/method.g_socket_send_messages.g_socket_send_messages.html
//
func (socket *SocketInstance) SendMessages(messages []OutputMessage, flags int32, cancellable Cancellable) (int32, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GOutputMessage // in, transfer: none, C Pointers: 1, Name: array[OutputMessage], array (inner GOutputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputMessage (GOutputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_messages(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendTo wraps g_socket_send_to
// 
// see also https://docs.gtk.org/gio/method.g_socket_send_to.g_socket_send_to.html
//
func (socket *SocketInstance) SendTo(address SocketAddress, buffer string, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted, nullable
	var carg2 *C.gchar          // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize           // implicit
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gssize          // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_to(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendWithBlocking wraps g_socket_send_with_blocking
// 
// see also https://docs.gtk.org/gio/method.g_socket_send_with_blocking.g_socket_send_with_blocking.html
//
func (socket *SocketInstance) SendWithBlocking(buffer string, blocking bool, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.gchar        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize         // implicit
	var carg3 C.gboolean      // in
	var carg4 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if blocking {
		carg3 = C.TRUE
	}
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_with_blocking(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBlocking wraps g_socket_set_blocking
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_blocking.g_socket_set_blocking.html
//
func (socket *SocketInstance) SetBlocking(blocking bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if blocking {
		carg1 = C.TRUE
	}

	C.g_socket_set_blocking(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(blocking)
}

// SetBroadcast wraps g_socket_set_broadcast
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_broadcast.g_socket_set_broadcast.html
//
func (socket *SocketInstance) SetBroadcast(broadcast bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if broadcast {
		carg1 = C.TRUE
	}

	C.g_socket_set_broadcast(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(broadcast)
}

// SetKeepalive wraps g_socket_set_keepalive
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_keepalive.g_socket_set_keepalive.html
//
func (socket *SocketInstance) SetKeepalive(keepalive bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if keepalive {
		carg1 = C.TRUE
	}

	C.g_socket_set_keepalive(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(keepalive)
}

// SetListenBacklog wraps g_socket_set_listen_backlog
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_listen_backlog.g_socket_set_listen_backlog.html
//
func (socket *SocketInstance) SetListenBacklog(backlog int32) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(backlog)
}

// SetMulticastLoopback wraps g_socket_set_multicast_loopback
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_multicast_loopback.g_socket_set_multicast_loopback.html
//
func (socket *SocketInstance) SetMulticastLoopback(loopback bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if loopback {
		carg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(loopback)
}

// SetMulticastTtl wraps g_socket_set_multicast_ttl
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_multicast_ttl.g_socket_set_multicast_ttl.html
//
func (socket *SocketInstance) SetMulticastTtl(ttl uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// SetOption wraps g_socket_set_option
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_option.g_socket_set_option.html
//
func (socket *SocketInstance) SetOption(level int32, optname int32, value int32) (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted
	var carg2 C.gint     // in, none, casted
	var carg3 C.gint     // in, none, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(level)
	carg2 = C.gint(optname)
	carg3 = C.gint(value)

	cret = C.g_socket_set_option(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)
	runtime.KeepAlive(value)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetTimeout wraps g_socket_set_timeout
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_timeout.g_socket_set_timeout.html
//
func (socket *SocketInstance) SetTimeout(timeout uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(timeout)

	C.g_socket_set_timeout(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(timeout)
}

// SetTtl wraps g_socket_set_ttl
// 
// see also https://docs.gtk.org/gio/method.g_socket_set_ttl.g_socket_set_ttl.html
//
func (socket *SocketInstance) SetTtl(ttl uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(ttl)

	C.g_socket_set_ttl(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// Shutdown wraps g_socket_shutdown
// 
// see also https://docs.gtk.org/gio/method.g_socket_shutdown.g_socket_shutdown.html
//
func (socket *SocketInstance) Shutdown(shutdownRead bool, shutdownWrite bool) (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in
	var carg2 C.gboolean // in
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}

	cret = C.g_socket_shutdown(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpeaksIpv4 wraps g_socket_speaks_ipv4
// 
// see also https://docs.gtk.org/gio/method.g_socket_speaks_ipv4.g_socket_speaks_ipv4.html
//
func (socket *SocketInstance) SpeaksIpv4() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_speaks_ipv4(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SocketOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketOverrides[Instance Socket] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySocketOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketOverrides[Instance Socket](gclass unsafe.Pointer, overrides SocketOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSocketSubClass is used to register a go subclass of GSocket. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketSubClass[InstanceT Socket](
		name string,
		classInit func(class *SocketClass),
		constructor func() InstanceT,
		overrides SocketOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocket,
		UnsafeSocketClassFromGlibBorrow,
		UnsafeApplySocketOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocket(obj)
		},
		interfaceInits...,
	)
}

// SocketAddressInstance is the instance type used by all types extending GSocketAddress. It is used internally by the bindings. Users should use the interface [SocketAddress] instead.
type SocketAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketAddress = (*SocketAddressInstance)(nil)

// SocketAddress wraps GSocketAddress
// 
// see also https://docs.gtk.org/gio/class.SocketAddress.html
//
type SocketAddress interface {
	gobject.Object
	upcastToGSocketAddress() *SocketAddressInstance

	// GetFamily wraps g_socket_address_get_family
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_address_get_family.g_socket_address_get_family.html
	//
	GetFamily() SocketFamily
	// GetNativeSize wraps g_socket_address_get_native_size
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_address_get_native_size.g_socket_address_get_native_size.html
	//
	GetNativeSize() int

	// chain up virtual methods:

	// ParentGetFamily calls the default implementations of the `GSocketAddress.get_family` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddress.get_family.html
	ParentGetFamily() SocketFamily
	// ParentGetNativeSize calls the default implementations of the `GSocketAddress.get_native_size` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddress.get_native_size.html
	ParentGetNativeSize() int
}

func unsafeWrapSocketAddress(base *gobject.ObjectInstance) *SocketAddressInstance {
	return &SocketAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddress(inst)
		},
	)
}

func marshalSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketAddressFromGlibNone is used to convert raw GSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibNone(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketAddress)
}

// UnsafeSocketAddressFromGlibFull is used to convert raw GSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibFull(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketAddress)
}

// UnsafeSocketAddressFromGlibBorrow is used to convert raw GSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibBorrow(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketAddress)
}

func (s *SocketAddressInstance) upcastToGSocketAddress() *SocketAddressInstance {
	return s
}

// UnsafeSocketAddressToGlibNone is used to convert the instance to it's C value GSocketAddress. This is used by the bindings internally.
func UnsafeSocketAddressToGlibNone(c SocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketAddressToGlibFull is used to convert the instance to it's C value GSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketAddressToGlibFull(c SocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetFamily wraps g_socket_address_get_family
// 
// see also https://docs.gtk.org/gio/method.g_socket_address_get_family.g_socket_address_get_family.html
//
func (address *SocketAddressInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocketAddress // in, none, converted
	var cret  C.GSocketFamily   // return, none, casted

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C.g_socket_address_get_family(carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetNativeSize wraps g_socket_address_get_native_size
// 
// see also https://docs.gtk.org/gio/method.g_socket_address_get_native_size.g_socket_address_get_native_size.html
//
func (address *SocketAddressInstance) GetNativeSize() int {
	var carg0 *C.GSocketAddress // in, none, converted
	var cret  C.gssize          // return, none, casted

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C.g_socket_address_get_native_size(carg0)
	runtime.KeepAlive(address)

	var goret int

	goret = int(cret)

	return goret
}

// SocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketAddressOverrides[Instance SocketAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetFamily allows you to override the implementation of the virtual method get_family.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddress.get_family.html
	GetFamily func(Instance) SocketFamily
	// // GetNativeSize allows you to override the implementation of the virtual method get_native_size.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddress.get_native_size.html
	GetNativeSize func(Instance) int
}

// UnsafeApplySocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketAddressOverrides[Instance SocketAddress](gclass unsafe.Pointer, overrides SocketAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketAddressClass)(gclass)

	if overrides.GetFamily != nil {
		pclass.get_family = (*[0]byte)(C._goglib_gio2_SocketAddress_get_family)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddress_get_family",
			func(carg0 *C.GSocketAddress) (cret C.GSocketFamily) {
				var address Instance     // go GSocketAddress subclass
				var goret   SocketFamily // return, none, casted

				address = UnsafeSocketAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetFamily(address)

				cret = C.GSocketFamily(goret)

				return cret
			},
		)
	}

	if overrides.GetNativeSize != nil {
		pclass.get_native_size = (*[0]byte)(C._goglib_gio2_SocketAddress_get_native_size)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddress_get_native_size",
			func(carg0 *C.GSocketAddress) (cret C.gssize) {
				var address Instance // go GSocketAddress subclass
				var goret   int      // return, none, casted

				address = UnsafeSocketAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNativeSize(address)

				cret = C.gssize(goret)

				return cret
			},
		)
	}
}

// ParentGetFamily calls the default implementations of the `GSocketAddress.get_family` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketAddress.get_family.html
func (address *SocketAddressInstance) ParentGetFamily() SocketFamily {
	var carg0 *C.GSocketAddress
	var cret  C.GSocketFamily // return, none, casted

	parentclass := (*C.GSocketAddressClass)(classdata.PeekParentClass(UnsafeSocketAddressToGlibNone(address)))

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C._goglib_gio2_SocketAddress_virtual_get_family(unsafe.Pointer(parentclass.get_family), carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// ParentGetNativeSize calls the default implementations of the `GSocketAddress.get_native_size` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketAddress.get_native_size.html
func (address *SocketAddressInstance) ParentGetNativeSize() int {
	var carg0 *C.GSocketAddress
	var cret  C.gssize // return, none, casted

	parentclass := (*C.GSocketAddressClass)(classdata.PeekParentClass(UnsafeSocketAddressToGlibNone(address)))

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C._goglib_gio2_SocketAddress_virtual_get_native_size(unsafe.Pointer(parentclass.get_native_size), carg0)
	runtime.KeepAlive(address)

	var goret int

	goret = int(cret)

	return goret
}

// RegisterSocketAddressSubClass is used to register a go subclass of GSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketAddressSubClass[InstanceT SocketAddress](
		name string,
		classInit func(class *SocketAddressClass),
		constructor func() InstanceT,
		overrides SocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketAddress,
		UnsafeSocketAddressClassFromGlibBorrow,
		UnsafeApplySocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// SocketAddressEnumeratorInstance is the instance type used by all types extending GSocketAddressEnumerator. It is used internally by the bindings. Users should use the interface [SocketAddressEnumerator] instead.
type SocketAddressEnumeratorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketAddressEnumerator = (*SocketAddressEnumeratorInstance)(nil)

// SocketAddressEnumerator wraps GSocketAddressEnumerator
// 
// see also https://docs.gtk.org/gio/class.SocketAddressEnumerator.html
//
type SocketAddressEnumerator interface {
	gobject.Object
	upcastToGSocketAddressEnumerator() *SocketAddressEnumeratorInstance

	// Next wraps g_socket_address_enumerator_next
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next.g_socket_address_enumerator_next.html
	//
	Next(Cancellable) (SocketAddress, error)
	// NextAsync wraps g_socket_address_enumerator_next_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next_async.g_socket_address_enumerator_next_async.html
	//
	NextAsync(Cancellable, AsyncReadyCallback)
	// NextFinish wraps g_socket_address_enumerator_next_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next_finish.g_socket_address_enumerator_next_finish.html
	//
	NextFinish(AsyncResult) (SocketAddress, error)

	// chain up virtual methods:

	// ParentNext calls the default implementations of the `GSocketAddressEnumerator.next` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next.html
	ParentNext(cancellable Cancellable) (SocketAddress, error)
	// ParentNextFinish calls the default implementations of the `GSocketAddressEnumerator.next_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next_finish.html
	ParentNextFinish(result AsyncResult) (SocketAddress, error)
}

func unsafeWrapSocketAddressEnumerator(base *gobject.ObjectInstance) *SocketAddressEnumeratorInstance {
	return &SocketAddressEnumeratorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketAddressEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddressEnumerator(inst)
		},
	)
}

func marshalSocketAddressEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketAddressEnumeratorFromGlibNone is used to convert raw GSocketAddressEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibNone(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketAddressEnumerator)
}

// UnsafeSocketAddressEnumeratorFromGlibFull is used to convert raw GSocketAddressEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibFull(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketAddressEnumerator)
}

// UnsafeSocketAddressEnumeratorFromGlibBorrow is used to convert raw GSocketAddressEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibBorrow(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketAddressEnumerator)
}

func (s *SocketAddressEnumeratorInstance) upcastToGSocketAddressEnumerator() *SocketAddressEnumeratorInstance {
	return s
}

// UnsafeSocketAddressEnumeratorToGlibNone is used to convert the instance to it's C value GSocketAddressEnumerator. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorToGlibNone(c SocketAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketAddressEnumeratorToGlibFull is used to convert the instance to it's C value GSocketAddressEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorToGlibFull(c SocketAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Next wraps g_socket_address_enumerator_next
// 
// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next.g_socket_address_enumerator_next.html
//
func (enumerator *SocketAddressEnumeratorInstance) Next(cancellable Cancellable) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GCancellable             // in, none, converted, nullable
	var cret  *C.GSocketAddress           // return, full, converted, nullable
	var _cerr *C.GError                   // out, full, converted, nullable

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_address_enumerator_next(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NextAsync wraps g_socket_address_enumerator_next_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next_async.g_socket_address_enumerator_next_async.html
//
func (enumerator *SocketAddressEnumeratorInstance) NextAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GCancellable             // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback       // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer                  // implicit

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_address_enumerator_next_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NextFinish wraps g_socket_address_enumerator_next_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_address_enumerator_next_finish.g_socket_address_enumerator_next_finish.html
//
func (enumerator *SocketAddressEnumeratorInstance) NextFinish(result AsyncResult) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GAsyncResult             // in, none, converted
	var cret  *C.GSocketAddress           // return, full, converted, nullable
	var _cerr *C.GError                   // out, full, converted, nullable

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_address_enumerator_next_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SocketAddressEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketAddressEnumeratorOverrides[Instance SocketAddressEnumerator] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Next allows you to override the implementation of the virtual method next.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next.html
	Next func(Instance, Cancellable) (SocketAddress, error)
	// // NextFinish allows you to override the implementation of the virtual method next_finish.
	// 
	// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next_finish.html
	NextFinish func(Instance, AsyncResult) (SocketAddress, error)
}

// UnsafeApplySocketAddressEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketAddressEnumeratorOverrides[Instance SocketAddressEnumerator](gclass unsafe.Pointer, overrides SocketAddressEnumeratorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketAddressEnumeratorClass)(gclass)

	if overrides.Next != nil {
		pclass.next = (*[0]byte)(C._goglib_gio2_SocketAddressEnumerator_next)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddressEnumerator_next",
			func(carg0 *C.GSocketAddressEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret *C.GSocketAddress) {
				var enumerator  Instance      // go GSocketAddressEnumerator subclass
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       SocketAddress // return, full, converted, nullable
				var _goerr      error         // out, full, converted

				enumerator = UnsafeSocketAddressEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Next(enumerator, cancellable)

				if goret != nil {
					cret = (*C.GSocketAddress)(UnsafeSocketAddressToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFinish != nil {
		pclass.next_finish = (*[0]byte)(C._goglib_gio2_SocketAddressEnumerator_next_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddressEnumerator_next_finish",
			func(carg0 *C.GSocketAddressEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GSocketAddress) {
				var enumerator Instance      // go GSocketAddressEnumerator subclass
				var result     AsyncResult   // in, none, converted
				var goret      SocketAddress // return, full, converted, nullable
				var _goerr     error         // out, full, converted

				enumerator = UnsafeSocketAddressEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.NextFinish(enumerator, result)

				if goret != nil {
					cret = (*C.GSocketAddress)(UnsafeSocketAddressToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentNext calls the default implementations of the `GSocketAddressEnumerator.next` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next.html
func (enumerator *SocketAddressEnumeratorInstance) ParentNext(cancellable Cancellable) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator
	var carg1 *C.GCancellable   // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted, nullable
	var _cerr *C.GError         // out, full, converted, nullable

	parentclass := (*C.GSocketAddressEnumeratorClass)(classdata.PeekParentClass(UnsafeSocketAddressEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_SocketAddressEnumerator_virtual_next(unsafe.Pointer(parentclass.next), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFinish calls the default implementations of the `GSocketAddressEnumerator.next_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketAddressEnumerator.next_finish.html
func (enumerator *SocketAddressEnumeratorInstance) ParentNextFinish(result AsyncResult) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted, nullable
	var _cerr *C.GError         // out, full, converted, nullable

	parentclass := (*C.GSocketAddressEnumeratorClass)(classdata.PeekParentClass(UnsafeSocketAddressEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_SocketAddressEnumerator_virtual_next_finish(unsafe.Pointer(parentclass.next_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterSocketAddressEnumeratorSubClass is used to register a go subclass of GSocketAddressEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketAddressEnumeratorSubClass[InstanceT SocketAddressEnumerator](
		name string,
		classInit func(class *SocketAddressEnumeratorClass),
		constructor func() InstanceT,
		overrides SocketAddressEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketAddressEnumerator,
		UnsafeSocketAddressEnumeratorClassFromGlibBorrow,
		UnsafeApplySocketAddressEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddressEnumerator(obj)
		},
		interfaceInits...,
	)
}

// SocketClientInstance is the instance type used by all types extending GSocketClient. It is used internally by the bindings. Users should use the interface [SocketClient] instead.
type SocketClientInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketClient = (*SocketClientInstance)(nil)

// SocketClient wraps GSocketClient
// 
// see also https://docs.gtk.org/gio/class.SocketClient.html
//
type SocketClient interface {
	gobject.Object
	upcastToGSocketClient() *SocketClientInstance

	// AddApplicationProxy wraps g_socket_client_add_application_proxy
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_add_application_proxy.g_socket_client_add_application_proxy.html
	//
	AddApplicationProxy(string)
	// ConnectSocketClient wraps g_socket_client_connect
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect.g_socket_client_connect.html
	//
	ConnectSocketClient(SocketConnectable, Cancellable) (SocketConnection, error)
	// ConnectAsync wraps g_socket_client_connect_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_async.g_socket_client_connect_async.html
	//
	ConnectAsync(SocketConnectable, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_socket_client_connect_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_finish.g_socket_client_connect_finish.html
	//
	ConnectFinish(AsyncResult) (SocketConnection, error)
	// ConnectToHost wraps g_socket_client_connect_to_host
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host.g_socket_client_connect_to_host.html
	//
	ConnectToHost(string, uint16, Cancellable) (SocketConnection, error)
	// ConnectToHostAsync wraps g_socket_client_connect_to_host_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host_async.g_socket_client_connect_to_host_async.html
	//
	ConnectToHostAsync(string, uint16, Cancellable, AsyncReadyCallback)
	// ConnectToHostFinish wraps g_socket_client_connect_to_host_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host_finish.g_socket_client_connect_to_host_finish.html
	//
	ConnectToHostFinish(AsyncResult) (SocketConnection, error)
	// ConnectToService wraps g_socket_client_connect_to_service
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service.g_socket_client_connect_to_service.html
	//
	ConnectToService(string, string, Cancellable) (SocketConnection, error)
	// ConnectToServiceAsync wraps g_socket_client_connect_to_service_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service_async.g_socket_client_connect_to_service_async.html
	//
	ConnectToServiceAsync(string, string, Cancellable, AsyncReadyCallback)
	// ConnectToServiceFinish wraps g_socket_client_connect_to_service_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service_finish.g_socket_client_connect_to_service_finish.html
	//
	ConnectToServiceFinish(AsyncResult) (SocketConnection, error)
	// ConnectToURI wraps g_socket_client_connect_to_uri
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri.g_socket_client_connect_to_uri.html
	//
	ConnectToURI(string, uint16, Cancellable) (SocketConnection, error)
	// ConnectToURIAsync wraps g_socket_client_connect_to_uri_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri_async.g_socket_client_connect_to_uri_async.html
	//
	ConnectToURIAsync(string, uint16, Cancellable, AsyncReadyCallback)
	// ConnectToURIFinish wraps g_socket_client_connect_to_uri_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri_finish.g_socket_client_connect_to_uri_finish.html
	//
	ConnectToURIFinish(AsyncResult) (SocketConnection, error)
	// GetEnableProxy wraps g_socket_client_get_enable_proxy
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_enable_proxy.g_socket_client_get_enable_proxy.html
	//
	GetEnableProxy() bool
	// GetFamily wraps g_socket_client_get_family
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_family.g_socket_client_get_family.html
	//
	GetFamily() SocketFamily
	// GetLocalAddress wraps g_socket_client_get_local_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_local_address.g_socket_client_get_local_address.html
	//
	GetLocalAddress() SocketAddress
	// GetProtocol wraps g_socket_client_get_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_protocol.g_socket_client_get_protocol.html
	//
	GetProtocol() SocketProtocol
	// GetProxyResolver wraps g_socket_client_get_proxy_resolver
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_proxy_resolver.g_socket_client_get_proxy_resolver.html
	//
	GetProxyResolver() ProxyResolver
	// GetSocketType wraps g_socket_client_get_socket_type
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_socket_type.g_socket_client_get_socket_type.html
	//
	GetSocketType() SocketType
	// GetTimeout wraps g_socket_client_get_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_timeout.g_socket_client_get_timeout.html
	//
	GetTimeout() uint
	// GetTls wraps g_socket_client_get_tls
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_tls.g_socket_client_get_tls.html
	//
	GetTls() bool
	// GetTlsValidationFlags wraps g_socket_client_get_tls_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_get_tls_validation_flags.g_socket_client_get_tls_validation_flags.html
	//
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	GetTlsValidationFlags() TlsCertificateFlags
	// SetEnableProxy wraps g_socket_client_set_enable_proxy
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_enable_proxy.g_socket_client_set_enable_proxy.html
	//
	SetEnableProxy(bool)
	// SetFamily wraps g_socket_client_set_family
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_family.g_socket_client_set_family.html
	//
	SetFamily(SocketFamily)
	// SetLocalAddress wraps g_socket_client_set_local_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_local_address.g_socket_client_set_local_address.html
	//
	SetLocalAddress(SocketAddress)
	// SetProtocol wraps g_socket_client_set_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_protocol.g_socket_client_set_protocol.html
	//
	SetProtocol(SocketProtocol)
	// SetProxyResolver wraps g_socket_client_set_proxy_resolver
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_proxy_resolver.g_socket_client_set_proxy_resolver.html
	//
	SetProxyResolver(ProxyResolver)
	// SetSocketType wraps g_socket_client_set_socket_type
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_socket_type.g_socket_client_set_socket_type.html
	//
	SetSocketType(SocketType)
	// SetTimeout wraps g_socket_client_set_timeout
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_timeout.g_socket_client_set_timeout.html
	//
	SetTimeout(uint)
	// SetTls wraps g_socket_client_set_tls
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_tls.g_socket_client_set_tls.html
	//
	SetTls(bool)
	// SetTlsValidationFlags wraps g_socket_client_set_tls_validation_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_client_set_tls_validation_flags.g_socket_client_set_tls_validation_flags.html
	//
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	SetTlsValidationFlags(TlsCertificateFlags)
	// ConnectEvent connects the provided callback to the "event" signal
	// 
	// see also https://docs.gtk.org/gio/signal.SocketClient.event.html
	//
	ConnectEvent(func(SocketClient, SocketClientEvent, SocketConnectable, IOStream)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentEvent calls the default implementations of the `GSocketClient.event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketClient.event.html
	ParentEvent(event SocketClientEvent, connectable SocketConnectable, connection IOStream)
}

func unsafeWrapSocketClient(base *gobject.ObjectInstance) *SocketClientInstance {
	return &SocketClientInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketClient,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketClient(inst)
		},
	)
}

func marshalSocketClientInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketClientFromGlibNone is used to convert raw GSocketClient pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketClientFromGlibNone(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketClient)
}

// UnsafeSocketClientFromGlibFull is used to convert raw GSocketClient pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketClientFromGlibFull(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketClient)
}

// UnsafeSocketClientFromGlibBorrow is used to convert raw GSocketClient pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketClientFromGlibBorrow(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketClient)
}

func (s *SocketClientInstance) upcastToGSocketClient() *SocketClientInstance {
	return s
}

// UnsafeSocketClientToGlibNone is used to convert the instance to it's C value GSocketClient. This is used by the bindings internally.
func UnsafeSocketClientToGlibNone(c SocketClient) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketClientToGlibFull is used to convert the instance to it's C value GSocketClient, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketClientToGlibFull(c SocketClient) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketClient wraps g_socket_client_new
// 
// see also https://docs.gtk.org/gio/func.g_socket_client_new.html
//
func NewSocketClient() SocketClient {
	var cret *C.GSocketClient // return, full, converted

	cret = C.g_socket_client_new()

	var goret SocketClient

	goret = UnsafeSocketClientFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddApplicationProxy wraps g_socket_client_add_application_proxy
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_add_application_proxy.g_socket_client_add_application_proxy.html
//
func (client *SocketClientInstance) AddApplicationProxy(protocol string) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_socket_client_add_application_proxy(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// ConnectSocketClient wraps g_socket_client_connect
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect.g_socket_client_connect.html
//
func (client *SocketClientInstance) ConnectSocketClient(connectable SocketConnectable, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GSocketConnection  // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_socket_client_connect_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_async.g_socket_client_connect_async.html
//
func (client *SocketClientInstance) ConnectAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(client)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_socket_client_connect_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_finish.g_socket_client_connect_finish.html
//
func (client *SocketClientInstance) ConnectFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToHost wraps g_socket_client_connect_to_host
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host.g_socket_client_connect_to_host.html
//
func (client *SocketClientInstance) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 C.guint16            // in, none, casted
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_host(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToHostAsync wraps g_socket_client_connect_to_host_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host_async.g_socket_client_connect_to_host_async.html
//
func (client *SocketClientInstance) ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_host_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToHostFinish wraps g_socket_client_connect_to_host_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_host_finish.g_socket_client_connect_to_host_finish.html
//
func (client *SocketClientInstance) ConnectToHostFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_host_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToService wraps g_socket_client_connect_to_service
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service.g_socket_client_connect_to_service.html
//
func (client *SocketClientInstance) ConnectToService(domain string, service string, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg2))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_service(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToServiceAsync wraps g_socket_client_connect_to_service_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service_async.g_socket_client_connect_to_service_async.html
//
func (client *SocketClientInstance) ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg2))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_service_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToServiceFinish wraps g_socket_client_connect_to_service_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_service_finish.g_socket_client_connect_to_service_finish.html
//
func (client *SocketClientInstance) ConnectToServiceFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_service_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToURI wraps g_socket_client_connect_to_uri
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri.g_socket_client_connect_to_uri.html
//
func (client *SocketClientInstance) ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 C.guint16            // in, none, casted
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_uri(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToURIAsync wraps g_socket_client_connect_to_uri_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri_async.g_socket_client_connect_to_uri_async.html
//
func (client *SocketClientInstance) ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_uri_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToURIFinish wraps g_socket_client_connect_to_uri_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_connect_to_uri_finish.g_socket_client_connect_to_uri_finish.html
//
func (client *SocketClientInstance) ConnectToURIFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_uri_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetEnableProxy wraps g_socket_client_get_enable_proxy
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_enable_proxy.g_socket_client_get_enable_proxy.html
//
func (client *SocketClientInstance) GetEnableProxy() bool {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_enable_proxy(carg0)
	runtime.KeepAlive(client)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetFamily wraps g_socket_client_get_family
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_family.g_socket_client_get_family.html
//
func (client *SocketClientInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.GSocketFamily  // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_family(carg0)
	runtime.KeepAlive(client)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetLocalAddress wraps g_socket_client_get_local_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_local_address.g_socket_client_get_local_address.html
//
func (client *SocketClientInstance) GetLocalAddress() SocketAddress {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  *C.GSocketAddress // return, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_local_address(carg0)
	runtime.KeepAlive(client)

	var goret SocketAddress

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetProtocol wraps g_socket_client_get_protocol
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_protocol.g_socket_client_get_protocol.html
//
func (client *SocketClientInstance) GetProtocol() SocketProtocol {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  C.GSocketProtocol // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_protocol(carg0)
	runtime.KeepAlive(client)

	var goret SocketProtocol

	goret = SocketProtocol(cret)

	return goret
}

// GetProxyResolver wraps g_socket_client_get_proxy_resolver
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_proxy_resolver.g_socket_client_get_proxy_resolver.html
//
func (client *SocketClientInstance) GetProxyResolver() ProxyResolver {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  *C.GProxyResolver // return, none, converted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_proxy_resolver(carg0)
	runtime.KeepAlive(client)

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetSocketType wraps g_socket_client_get_socket_type
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_socket_type.g_socket_client_get_socket_type.html
//
func (client *SocketClientInstance) GetSocketType() SocketType {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.GSocketType    // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_socket_type(carg0)
	runtime.KeepAlive(client)

	var goret SocketType

	goret = SocketType(cret)

	return goret
}

// GetTimeout wraps g_socket_client_get_timeout
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_timeout.g_socket_client_get_timeout.html
//
func (client *SocketClientInstance) GetTimeout() uint {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.guint          // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_timeout(carg0)
	runtime.KeepAlive(client)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetTls wraps g_socket_client_get_tls
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_tls.g_socket_client_get_tls.html
//
func (client *SocketClientInstance) GetTls() bool {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_tls(carg0)
	runtime.KeepAlive(client)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetTlsValidationFlags wraps g_socket_client_get_tls_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_get_tls_validation_flags.g_socket_client_get_tls_validation_flags.html
//
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (client *SocketClientInstance) GetTlsValidationFlags() TlsCertificateFlags {
	var carg0 *C.GSocketClient       // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_tls_validation_flags(carg0)
	runtime.KeepAlive(client)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetEnableProxy wraps g_socket_client_set_enable_proxy
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_enable_proxy.g_socket_client_set_enable_proxy.html
//
func (client *SocketClientInstance) SetEnableProxy(enable bool) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if enable {
		carg1 = C.TRUE
	}

	C.g_socket_client_set_enable_proxy(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(enable)
}

// SetFamily wraps g_socket_client_set_family
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_family.g_socket_client_set_family.html
//
func (client *SocketClientInstance) SetFamily(family SocketFamily) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.GSocketFamily  // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketFamily(family)

	C.g_socket_client_set_family(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(family)
}

// SetLocalAddress wraps g_socket_client_set_local_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_local_address.g_socket_client_set_local_address.html
//
func (client *SocketClientInstance) SetLocalAddress(address SocketAddress) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}

	C.g_socket_client_set_local_address(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(address)
}

// SetProtocol wraps g_socket_client_set_protocol
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_protocol.g_socket_client_set_protocol.html
//
func (client *SocketClientInstance) SetProtocol(protocol SocketProtocol) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 C.GSocketProtocol // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketProtocol(protocol)

	C.g_socket_client_set_protocol(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// SetProxyResolver wraps g_socket_client_set_proxy_resolver
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_proxy_resolver.g_socket_client_set_proxy_resolver.html
//
func (client *SocketClientInstance) SetProxyResolver(proxyResolver ProxyResolver) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 *C.GProxyResolver // in, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if proxyResolver != nil {
		carg1 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(proxyResolver))
	}

	C.g_socket_client_set_proxy_resolver(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(proxyResolver)
}

// SetSocketType wraps g_socket_client_set_socket_type
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_socket_type.g_socket_client_set_socket_type.html
//
func (client *SocketClientInstance) SetSocketType(typ SocketType) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.GSocketType    // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketType(typ)

	C.g_socket_client_set_socket_type(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(typ)
}

// SetTimeout wraps g_socket_client_set_timeout
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_timeout.g_socket_client_set_timeout.html
//
func (client *SocketClientInstance) SetTimeout(timeout uint) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.guint          // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.guint(timeout)

	C.g_socket_client_set_timeout(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(timeout)
}

// SetTls wraps g_socket_client_set_tls
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_tls.g_socket_client_set_tls.html
//
func (client *SocketClientInstance) SetTls(tls bool) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if tls {
		carg1 = C.TRUE
	}

	C.g_socket_client_set_tls(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(tls)
}

// SetTlsValidationFlags wraps g_socket_client_set_tls_validation_flags
// 
// see also https://docs.gtk.org/gio/method.g_socket_client_set_tls_validation_flags.g_socket_client_set_tls_validation_flags.html
//
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (client *SocketClientInstance) SetTlsValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GSocketClient       // in, none, converted
	var carg1 C.GTlsCertificateFlags // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_socket_client_set_tls_validation_flags(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(flags)
}

// ConnectEvent connects the provided callback to the "event" signal
// 
// see also https://docs.gtk.org/gio/signal.SocketClient.event.html
//
func (o *SocketClientInstance) ConnectEvent(fn func(SocketClient, SocketClientEvent, SocketConnectable, IOStream)) gobject.SignalHandle {
	return o.Connect("event", fn)
}

// SocketClientOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketClientOverrides[Instance SocketClient] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Event allows you to override the implementation of the virtual method event.
	// 
	// see also https://docs.gtk.org/gio/method.SocketClient.event.html
	Event func(Instance, SocketClientEvent, SocketConnectable, IOStream)
}

// UnsafeApplySocketClientOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketClientOverrides[Instance SocketClient](gclass unsafe.Pointer, overrides SocketClientOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketClientClass)(gclass)

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._goglib_gio2_SocketClient_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketClient_event",
			func(carg0 *C.GSocketClient, carg1 C.GSocketClientEvent, carg2 *C.GSocketConnectable, carg3 *C.GIOStream) {
				var client      Instance          // go GSocketClient subclass
				var event       SocketClientEvent // in, none, casted
				var connectable SocketConnectable // in, none, converted
				var connection  IOStream          // in, none, converted

				client = UnsafeSocketClientFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				event = SocketClientEvent(carg1)
				connectable = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg2))
				connection = UnsafeIOStreamFromGlibNone(unsafe.Pointer(carg3))

				overrides.Event(client, event, connectable, connection)
			},
		)
	}
}

// ParentEvent calls the default implementations of the `GSocketClient.event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketClient.event.html
func (client *SocketClientInstance) ParentEvent(event SocketClientEvent, connectable SocketConnectable, connection IOStream) {
	var carg0 *C.GSocketClient
	var carg1 C.GSocketClientEvent  // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, casted
	var carg3 *C.GIOStream          // in, none, converted

	parentclass := (*C.GSocketClientClass)(classdata.PeekParentClass(UnsafeSocketClientToGlibNone(client)))

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketClientEvent(event)
	carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	carg3 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))

	C._goglib_gio2_SocketClient_virtual_event(unsafe.Pointer(parentclass.event), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(client)
	runtime.KeepAlive(event)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(connection)
}

// RegisterSocketClientSubClass is used to register a go subclass of GSocketClient. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketClientSubClass[InstanceT SocketClient](
		name string,
		classInit func(class *SocketClientClass),
		constructor func() InstanceT,
		overrides SocketClientOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketClient,
		UnsafeSocketClientClassFromGlibBorrow,
		UnsafeApplySocketClientOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketClient(obj)
		},
		interfaceInits...,
	)
}

// SocketConnectionInstance is the instance type used by all types extending GSocketConnection. It is used internally by the bindings. Users should use the interface [SocketConnection] instead.
type SocketConnectionInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ SocketConnection = (*SocketConnectionInstance)(nil)

// SocketConnection wraps GSocketConnection
// 
// see also https://docs.gtk.org/gio/class.SocketConnection.html
//
type SocketConnection interface {
	IOStream
	upcastToGSocketConnection() *SocketConnectionInstance

	// ConnectSocketConnection wraps g_socket_connection_connect
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_connect.g_socket_connection_connect.html
	//
	ConnectSocketConnection(SocketAddress, Cancellable) (bool, error)
	// ConnectAsync wraps g_socket_connection_connect_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_connect_async.g_socket_connection_connect_async.html
	//
	ConnectAsync(SocketAddress, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_socket_connection_connect_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_connect_finish.g_socket_connection_connect_finish.html
	//
	ConnectFinish(AsyncResult) (bool, error)
	// GetLocalAddress wraps g_socket_connection_get_local_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_get_local_address.g_socket_connection_get_local_address.html
	//
	GetLocalAddress() (SocketAddress, error)
	// GetRemoteAddress wraps g_socket_connection_get_remote_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_get_remote_address.g_socket_connection_get_remote_address.html
	//
	GetRemoteAddress() (SocketAddress, error)
	// GetSocket wraps g_socket_connection_get_socket
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_get_socket.g_socket_connection_get_socket.html
	//
	GetSocket() Socket
	// IsConnected wraps g_socket_connection_is_connected
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_connection_is_connected.g_socket_connection_is_connected.html
	//
	IsConnected() bool

	// chain up virtual methods:
}

func unsafeWrapSocketConnection(base *gobject.ObjectInstance) *SocketConnectionInstance {
	return &SocketConnectionInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketConnection(inst)
		},
	)
}

func marshalSocketConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketConnectionFromGlibNone is used to convert raw GSocketConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibNone(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketConnection)
}

// UnsafeSocketConnectionFromGlibFull is used to convert raw GSocketConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibFull(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketConnection)
}

// UnsafeSocketConnectionFromGlibBorrow is used to convert raw GSocketConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibBorrow(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketConnection)
}

func (s *SocketConnectionInstance) upcastToGSocketConnection() *SocketConnectionInstance {
	return s
}

// UnsafeSocketConnectionToGlibNone is used to convert the instance to it's C value GSocketConnection. This is used by the bindings internally.
func UnsafeSocketConnectionToGlibNone(c SocketConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketConnectionToGlibFull is used to convert the instance to it's C value GSocketConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionToGlibFull(c SocketConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// SocketConnectionFactoryLookupType wraps g_socket_connection_factory_lookup_type
// 
// see also https://docs.gtk.org/gio/func.g_socket_connection_factory_lookup_type.html
//
func SocketConnectionFactoryLookupType(family SocketFamily, typ SocketType, protocolId int32) gobject.Type {
	var carg1 C.GSocketFamily // in, none, casted
	var carg2 C.GSocketType   // in, none, casted
	var carg3 C.gint          // in, none, casted
	var cret  C.GType         // return, none, casted, alias

	carg1 = C.GSocketFamily(family)
	carg2 = C.GSocketType(typ)
	carg3 = C.gint(protocolId)

	cret = C.g_socket_connection_factory_lookup_type(carg1, carg2, carg3)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocolId)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SocketConnectionFactoryRegisterType wraps g_socket_connection_factory_register_type
// 
// see also https://docs.gtk.org/gio/func.g_socket_connection_factory_register_type.html
//
func SocketConnectionFactoryRegisterType(gType gobject.Type, family SocketFamily, typ SocketType, protocol int32) {
	var carg1 C.GType         // in, none, casted, alias
	var carg2 C.GSocketFamily // in, none, casted
	var carg3 C.GSocketType   // in, none, casted
	var carg4 C.gint          // in, none, casted

	carg1 = C.GType(gType)
	carg2 = C.GSocketFamily(family)
	carg3 = C.GSocketType(typ)
	carg4 = C.gint(protocol)

	C.g_socket_connection_factory_register_type(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(gType)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
}

// ConnectSocketConnection wraps g_socket_connection_connect
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_connect.g_socket_connection_connect.html
//
func (connection *SocketConnectionInstance) ConnectSocketConnection(address SocketAddress, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var carg1 *C.GSocketAddress    // in, none, converted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_connection_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_socket_connection_connect_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_connect_async.g_socket_connection_connect_async.html
//
func (connection *SocketConnectionInstance) ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketConnection  // in, none, converted
	var carg1 *C.GSocketAddress     // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_connection_connect_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_socket_connection_connect_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_connect_finish.g_socket_connection_connect_finish.html
//
func (connection *SocketConnectionInstance) ConnectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_connection_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetLocalAddress wraps g_socket_connection_get_local_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_get_local_address.g_socket_connection_get_local_address.html
//
func (connection *SocketConnectionInstance) GetLocalAddress() (SocketAddress, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocketAddress    // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_local_address(carg0, &_cerr)
	runtime.KeepAlive(connection)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetRemoteAddress wraps g_socket_connection_get_remote_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_get_remote_address.g_socket_connection_get_remote_address.html
//
func (connection *SocketConnectionInstance) GetRemoteAddress() (SocketAddress, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocketAddress    // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_remote_address(carg0, &_cerr)
	runtime.KeepAlive(connection)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSocket wraps g_socket_connection_get_socket
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_get_socket.g_socket_connection_get_socket.html
//
func (connection *SocketConnectionInstance) GetSocket() Socket {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocket           // return, none, converted

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_socket(carg0)
	runtime.KeepAlive(connection)

	var goret Socket

	goret = UnsafeSocketFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsConnected wraps g_socket_connection_is_connected
// 
// see also https://docs.gtk.org/gio/method.g_socket_connection_is_connected.g_socket_connection_is_connected.html
//
func (connection *SocketConnectionInstance) IsConnected() bool {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  C.gboolean           // return

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_is_connected(carg0)
	runtime.KeepAlive(connection)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SocketConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketConnectionOverrides[Instance SocketConnection] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

}

// UnsafeApplySocketConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketConnectionOverrides[Instance SocketConnection](gclass unsafe.Pointer, overrides SocketConnectionOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)
}

// RegisterSocketConnectionSubClass is used to register a go subclass of GSocketConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketConnectionSubClass[InstanceT SocketConnection](
		name string,
		classInit func(class *SocketConnectionClass),
		constructor func() InstanceT,
		overrides SocketConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketConnection,
		UnsafeSocketConnectionClassFromGlibBorrow,
		UnsafeApplySocketConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketConnection(obj)
		},
		interfaceInits...,
	)
}

// SocketControlMessageInstance is the instance type used by all types extending GSocketControlMessage. It is used internally by the bindings. Users should use the interface [SocketControlMessage] instead.
type SocketControlMessageInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketControlMessage = (*SocketControlMessageInstance)(nil)

// SocketControlMessage wraps GSocketControlMessage
// 
// see also https://docs.gtk.org/gio/class.SocketControlMessage.html
//
type SocketControlMessage interface {
	gobject.Object
	upcastToGSocketControlMessage() *SocketControlMessageInstance

	// GetLevel wraps g_socket_control_message_get_level
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_level.g_socket_control_message_get_level.html
	//
	GetLevel() int32
	// GetMsgType wraps g_socket_control_message_get_msg_type
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_msg_type.g_socket_control_message_get_msg_type.html
	//
	GetMsgType() int32
	// GetSize wraps g_socket_control_message_get_size
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_size.g_socket_control_message_get_size.html
	//
	GetSize() uint

	// chain up virtual methods:

	// ParentGetLevel calls the default implementations of the `GSocketControlMessage.get_level` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_level.html
	ParentGetLevel() int32
	// ParentGetSize calls the default implementations of the `GSocketControlMessage.get_size` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_size.html
	ParentGetSize() uint
	// ParentGetType calls the default implementations of the `GSocketControlMessage.get_type` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_type.html
	ParentGetType() int32
}

func unsafeWrapSocketControlMessage(base *gobject.ObjectInstance) *SocketControlMessageInstance {
	return &SocketControlMessageInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketControlMessage,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketControlMessage(inst)
		},
	)
}

func marshalSocketControlMessageInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketControlMessageFromGlibNone is used to convert raw GSocketControlMessage pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibNone(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketControlMessage)
}

// UnsafeSocketControlMessageFromGlibFull is used to convert raw GSocketControlMessage pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibFull(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketControlMessage)
}

// UnsafeSocketControlMessageFromGlibBorrow is used to convert raw GSocketControlMessage pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibBorrow(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketControlMessage)
}

func (s *SocketControlMessageInstance) upcastToGSocketControlMessage() *SocketControlMessageInstance {
	return s
}

// UnsafeSocketControlMessageToGlibNone is used to convert the instance to it's C value GSocketControlMessage. This is used by the bindings internally.
func UnsafeSocketControlMessageToGlibNone(c SocketControlMessage) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketControlMessageToGlibFull is used to convert the instance to it's C value GSocketControlMessage, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageToGlibFull(c SocketControlMessage) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetLevel wraps g_socket_control_message_get_level
// 
// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_level.g_socket_control_message_get_level.html
//
func (message *SocketControlMessageInstance) GetLevel() int32 {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.int                    // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_level(carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetMsgType wraps g_socket_control_message_get_msg_type
// 
// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_msg_type.g_socket_control_message_get_msg_type.html
//
func (message *SocketControlMessageInstance) GetMsgType() int32 {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.int                    // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_msg_type(carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSize wraps g_socket_control_message_get_size
// 
// see also https://docs.gtk.org/gio/method.g_socket_control_message_get_size.g_socket_control_message_get_size.html
//
func (message *SocketControlMessageInstance) GetSize() uint {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.gsize                  // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_size(carg0)
	runtime.KeepAlive(message)

	var goret uint

	goret = uint(cret)

	return goret
}

// SocketControlMessageOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketControlMessageOverrides[Instance SocketControlMessage] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetLevel allows you to override the implementation of the virtual method get_level.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_level.html
	GetLevel func(Instance) int32
	// // GetSize allows you to override the implementation of the virtual method get_size.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_size.html
	GetSize func(Instance) uint
	// // GetType allows you to override the implementation of the virtual method get_type.
	// 
	// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_type.html
	GetType func(Instance) int32
}

// UnsafeApplySocketControlMessageOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketControlMessageOverrides[Instance SocketControlMessage](gclass unsafe.Pointer, overrides SocketControlMessageOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketControlMessageClass)(gclass)

	if overrides.GetLevel != nil {
		pclass.get_level = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_level)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_level",
			func(carg0 *C.GSocketControlMessage) (cret C.int) {
				var message Instance // go GSocketControlMessage subclass
				var goret   int32    // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetLevel(message)

				cret = C.int(goret)

				return cret
			},
		)
	}

	if overrides.GetSize != nil {
		pclass.get_size = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_size)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_size",
			func(carg0 *C.GSocketControlMessage) (cret C.gsize) {
				var message Instance // go GSocketControlMessage subclass
				var goret   uint     // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetSize(message)

				cret = C.gsize(goret)

				return cret
			},
		)
	}

	if overrides.GetType != nil {
		pclass.get_type = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_type)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_type",
			func(carg0 *C.GSocketControlMessage) (cret C.int) {
				var message Instance // go GSocketControlMessage subclass
				var goret   int32    // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetType(message)

				cret = C.int(goret)

				return cret
			},
		)
	}
}

// ParentGetLevel calls the default implementations of the `GSocketControlMessage.get_level` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_level.html
func (message *SocketControlMessageInstance) ParentGetLevel() int32 {
	var carg0 *C.GSocketControlMessage
	var cret  C.int // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_level(unsafe.Pointer(parentclass.get_level), carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentGetSize calls the default implementations of the `GSocketControlMessage.get_size` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_size.html
func (message *SocketControlMessageInstance) ParentGetSize() uint {
	var carg0 *C.GSocketControlMessage
	var cret  C.gsize // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_size(unsafe.Pointer(parentclass.get_size), carg0)
	runtime.KeepAlive(message)

	var goret uint

	goret = uint(cret)

	return goret
}

// ParentGetType calls the default implementations of the `GSocketControlMessage.get_type` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketControlMessage.get_type.html
func (message *SocketControlMessageInstance) ParentGetType() int32 {
	var carg0 *C.GSocketControlMessage
	var cret  C.int // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_type(unsafe.Pointer(parentclass.get_type), carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// RegisterSocketControlMessageSubClass is used to register a go subclass of GSocketControlMessage. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketControlMessageSubClass[InstanceT SocketControlMessage](
		name string,
		classInit func(class *SocketControlMessageClass),
		constructor func() InstanceT,
		overrides SocketControlMessageOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketControlMessage,
		UnsafeSocketControlMessageClassFromGlibBorrow,
		UnsafeApplySocketControlMessageOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketControlMessage(obj)
		},
		interfaceInits...,
	)
}

// SocketListenerInstance is the instance type used by all types extending GSocketListener. It is used internally by the bindings. Users should use the interface [SocketListener] instead.
type SocketListenerInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketListener = (*SocketListenerInstance)(nil)

// SocketListener wraps GSocketListener
// 
// see also https://docs.gtk.org/gio/class.SocketListener.html
//
type SocketListener interface {
	gobject.Object
	upcastToGSocketListener() *SocketListenerInstance

	// Accept wraps g_socket_listener_accept
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept.g_socket_listener_accept.html
	//
	Accept(Cancellable) (gobject.Object, SocketConnection, error)
	// AcceptAsync wraps g_socket_listener_accept_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_async.g_socket_listener_accept_async.html
	//
	AcceptAsync(Cancellable, AsyncReadyCallback)
	// AcceptFinish wraps g_socket_listener_accept_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_finish.g_socket_listener_accept_finish.html
	//
	AcceptFinish(AsyncResult) (gobject.Object, SocketConnection, error)
	// AcceptSocket wraps g_socket_listener_accept_socket
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket.g_socket_listener_accept_socket.html
	//
	AcceptSocket(Cancellable) (gobject.Object, Socket, error)
	// AcceptSocketAsync wraps g_socket_listener_accept_socket_async
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket_async.g_socket_listener_accept_socket_async.html
	//
	AcceptSocketAsync(Cancellable, AsyncReadyCallback)
	// AcceptSocketFinish wraps g_socket_listener_accept_socket_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket_finish.g_socket_listener_accept_socket_finish.html
	//
	AcceptSocketFinish(AsyncResult) (gobject.Object, Socket, error)
	// AddAddress wraps g_socket_listener_add_address
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_add_address.g_socket_listener_add_address.html
	//
	AddAddress(SocketAddress, SocketType, SocketProtocol, gobject.Object) (SocketAddress, bool, error)
	// AddAnyInetPort wraps g_socket_listener_add_any_inet_port
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_add_any_inet_port.g_socket_listener_add_any_inet_port.html
	//
	AddAnyInetPort(gobject.Object) (uint16, error)
	// AddInetPort wraps g_socket_listener_add_inet_port
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_add_inet_port.g_socket_listener_add_inet_port.html
	//
	AddInetPort(uint16, gobject.Object) (bool, error)
	// AddSocket wraps g_socket_listener_add_socket
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_add_socket.g_socket_listener_add_socket.html
	//
	AddSocket(Socket, gobject.Object) (bool, error)
	// Close wraps g_socket_listener_close
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_close.g_socket_listener_close.html
	//
	Close()
	// SetBacklog wraps g_socket_listener_set_backlog
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_listener_set_backlog.g_socket_listener_set_backlog.html
	//
	SetBacklog(int32)
	// ConnectEvent connects the provided callback to the "event" signal
	// 
	// see also https://docs.gtk.org/gio/signal.SocketListener.event.html
	//
	ConnectEvent(func(SocketListener, SocketListenerEvent, Socket)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentChanged calls the default implementations of the `GSocketListener.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketListener.changed.html
	ParentChanged()
	// ParentEvent calls the default implementations of the `GSocketListener.event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketListener.event.html
	ParentEvent(event SocketListenerEvent, socket Socket)
}

func unsafeWrapSocketListener(base *gobject.ObjectInstance) *SocketListenerInstance {
	return &SocketListenerInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketListener,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketListener(inst)
		},
	)
}

func marshalSocketListenerInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketListenerFromGlibNone is used to convert raw GSocketListener pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibNone(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketListener)
}

// UnsafeSocketListenerFromGlibFull is used to convert raw GSocketListener pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibFull(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketListener)
}

// UnsafeSocketListenerFromGlibBorrow is used to convert raw GSocketListener pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibBorrow(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketListener)
}

func (s *SocketListenerInstance) upcastToGSocketListener() *SocketListenerInstance {
	return s
}

// UnsafeSocketListenerToGlibNone is used to convert the instance to it's C value GSocketListener. This is used by the bindings internally.
func UnsafeSocketListenerToGlibNone(c SocketListener) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketListenerToGlibFull is used to convert the instance to it's C value GSocketListener, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketListenerToGlibFull(c SocketListener) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketListener wraps g_socket_listener_new
// 
// see also https://docs.gtk.org/gio/func.g_socket_listener_new.html
//
func NewSocketListener() SocketListener {
	var cret *C.GSocketListener // return, full, converted

	cret = C.g_socket_listener_new()

	var goret SocketListener

	goret = UnsafeSocketListenerFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Accept wraps g_socket_listener_accept
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept.g_socket_listener_accept.html
//
func (listener *SocketListenerInstance) Accept(cancellable Cancellable) (gobject.Object, SocketConnection, error) {
	var carg0 *C.GSocketListener   // in, none, converted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var carg1 *C.GObject           // out, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_listener_accept(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)

	var sourceObject gobject.Object
	var goret        SocketConnection
	var _goerr       error

	if carg1 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg1))
	}
	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptAsync wraps g_socket_listener_accept_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_async.g_socket_listener_accept_async.html
//
func (listener *SocketListenerInstance) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketListener    // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_listener_accept_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcceptFinish wraps g_socket_listener_accept_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_finish.g_socket_listener_accept_finish.html
//
func (listener *SocketListenerInstance) AcceptFinish(result AsyncResult) (gobject.Object, SocketConnection, error) {
	var carg0 *C.GSocketListener   // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var carg2 *C.GObject           // out, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_listener_accept_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var sourceObject gobject.Object
	var goret        SocketConnection
	var _goerr       error

	if carg2 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))
	}
	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptSocket wraps g_socket_listener_accept_socket
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket.g_socket_listener_accept_socket.html
//
func (listener *SocketListenerInstance) AcceptSocket(cancellable Cancellable) (gobject.Object, Socket, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg2 *C.GCancellable    // in, none, converted, nullable
	var carg1 *C.GObject         // out, none, converted, nullable
	var cret  *C.GSocket         // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_listener_accept_socket(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)

	var sourceObject gobject.Object
	var goret        Socket
	var _goerr       error

	if carg1 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg1))
	}
	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptSocketAsync wraps g_socket_listener_accept_socket_async
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket_async.g_socket_listener_accept_socket_async.html
//
func (listener *SocketListenerInstance) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketListener    // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_listener_accept_socket_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcceptSocketFinish wraps g_socket_listener_accept_socket_finish
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_accept_socket_finish.g_socket_listener_accept_socket_finish.html
//
func (listener *SocketListenerInstance) AcceptSocketFinish(result AsyncResult) (gobject.Object, Socket, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var carg2 *C.GObject         // out, none, converted, nullable
	var cret  *C.GSocket         // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_listener_accept_socket_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var sourceObject gobject.Object
	var goret        Socket
	var _goerr       error

	if carg2 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))
	}
	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AddAddress wraps g_socket_listener_add_address
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_add_address.g_socket_listener_add_address.html
//
func (listener *SocketListenerInstance) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gobject.Object) (SocketAddress, bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GSocketAddress  // in, none, converted
	var carg2 C.GSocketType      // in, none, casted
	var carg3 C.GSocketProtocol  // in, none, casted
	var carg4 *C.GObject         // in, none, converted, nullable
	var carg5 *C.GSocketAddress  // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	carg2 = C.GSocketType(typ)
	carg3 = C.GSocketProtocol(protocol)
	if sourceObject != nil {
		carg4 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_address(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(address)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(sourceObject)

	var effectiveAddress SocketAddress
	var goret            bool
	var _goerr           error

	effectiveAddress = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return effectiveAddress, goret, _goerr
}

// AddAnyInetPort wraps g_socket_listener_add_any_inet_port
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_add_any_inet_port.g_socket_listener_add_any_inet_port.html
//
func (listener *SocketListenerInstance) AddAnyInetPort(sourceObject gobject.Object) (uint16, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GObject         // in, none, converted, nullable
	var cret  C.guint16          // return, none, casted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if sourceObject != nil {
		carg1 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_any_inet_port(carg0, carg1, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(sourceObject)

	var goret  uint16
	var _goerr error

	goret = uint16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AddInetPort wraps g_socket_listener_add_inet_port
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_add_inet_port.g_socket_listener_add_inet_port.html
//
func (listener *SocketListenerInstance) AddInetPort(port uint16, sourceObject gobject.Object) (bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 C.guint16          // in, none, casted
	var carg2 *C.GObject         // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.guint16(port)
	if sourceObject != nil {
		carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_inet_port(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(port)
	runtime.KeepAlive(sourceObject)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AddSocket wraps g_socket_listener_add_socket
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_add_socket.g_socket_listener_add_socket.html
//
func (listener *SocketListenerInstance) AddSocket(socket Socket, sourceObject gobject.Object) (bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GSocket         // in, none, converted
	var carg2 *C.GObject         // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if sourceObject != nil {
		carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_socket(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(sourceObject)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_socket_listener_close
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_close.g_socket_listener_close.html
//
func (listener *SocketListenerInstance) Close() {
	var carg0 *C.GSocketListener // in, none, converted

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))

	C.g_socket_listener_close(carg0)
	runtime.KeepAlive(listener)
}

// SetBacklog wraps g_socket_listener_set_backlog
// 
// see also https://docs.gtk.org/gio/method.g_socket_listener_set_backlog.g_socket_listener_set_backlog.html
//
func (listener *SocketListenerInstance) SetBacklog(listenBacklog int32) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 C.int              // in, none, casted

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.int(listenBacklog)

	C.g_socket_listener_set_backlog(carg0, carg1)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(listenBacklog)
}

// ConnectEvent connects the provided callback to the "event" signal
// 
// see also https://docs.gtk.org/gio/signal.SocketListener.event.html
//
func (o *SocketListenerInstance) ConnectEvent(fn func(SocketListener, SocketListenerEvent, Socket)) gobject.SignalHandle {
	return o.Connect("event", fn)
}

// SocketListenerOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketListenerOverrides[Instance SocketListener] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Changed allows you to override the implementation of the virtual method changed.
	// 
	// see also https://docs.gtk.org/gio/method.SocketListener.changed.html
	Changed func(Instance)
	// // Event allows you to override the implementation of the virtual method event.
	// 
	// see also https://docs.gtk.org/gio/method.SocketListener.event.html
	Event func(Instance, SocketListenerEvent, Socket)
}

// UnsafeApplySocketListenerOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketListenerOverrides[Instance SocketListener](gclass unsafe.Pointer, overrides SocketListenerOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketListenerClass)(gclass)

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_SocketListener_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketListener_changed",
			func(carg0 *C.GSocketListener) {
				var listener Instance // go GSocketListener subclass

				listener = UnsafeSocketListenerFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Changed(listener)
			},
		)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._goglib_gio2_SocketListener_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketListener_event",
			func(carg0 *C.GSocketListener, carg1 C.GSocketListenerEvent, carg2 *C.GSocket) {
				var listener Instance            // go GSocketListener subclass
				var event    SocketListenerEvent // in, none, casted
				var socket   Socket              // in, none, converted

				listener = UnsafeSocketListenerFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				event = SocketListenerEvent(carg1)
				socket = UnsafeSocketFromGlibNone(unsafe.Pointer(carg2))

				overrides.Event(listener, event, socket)
			},
		)
	}
}

// ParentChanged calls the default implementations of the `GSocketListener.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketListener.changed.html
func (listener *SocketListenerInstance) ParentChanged() {
	var carg0 *C.GSocketListener

	parentclass := (*C.GSocketListenerClass)(classdata.PeekParentClass(UnsafeSocketListenerToGlibNone(listener)))

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))

	C._goglib_gio2_SocketListener_virtual_changed(unsafe.Pointer(parentclass.changed), carg0)
	runtime.KeepAlive(listener)
}

// ParentEvent calls the default implementations of the `GSocketListener.event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketListener.event.html
func (listener *SocketListenerInstance) ParentEvent(event SocketListenerEvent, socket Socket) {
	var carg0 *C.GSocketListener
	var carg1 C.GSocketListenerEvent // in, none, converted
	var carg2 *C.GSocket             // in, none, casted

	parentclass := (*C.GSocketListenerClass)(classdata.PeekParentClass(UnsafeSocketListenerToGlibNone(listener)))

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.GSocketListenerEvent(event)
	carg2 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	C._goglib_gio2_SocketListener_virtual_event(unsafe.Pointer(parentclass.event), carg0, carg1, carg2)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(event)
	runtime.KeepAlive(socket)
}

// RegisterSocketListenerSubClass is used to register a go subclass of GSocketListener. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketListenerSubClass[InstanceT SocketListener](
		name string,
		classInit func(class *SocketListenerClass),
		constructor func() InstanceT,
		overrides SocketListenerOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketListener,
		UnsafeSocketListenerClassFromGlibBorrow,
		UnsafeApplySocketListenerOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketListener(obj)
		},
		interfaceInits...,
	)
}

// SocketServiceInstance is the instance type used by all types extending GSocketService. It is used internally by the bindings. Users should use the interface [SocketService] instead.
type SocketServiceInstance struct {
	_ [0]func() // equal guard
	SocketListenerInstance
}

var _ SocketService = (*SocketServiceInstance)(nil)

// SocketService wraps GSocketService
// 
// see also https://docs.gtk.org/gio/class.SocketService.html
//
type SocketService interface {
	SocketListener
	upcastToGSocketService() *SocketServiceInstance

	// IsActive wraps g_socket_service_is_active
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_service_is_active.g_socket_service_is_active.html
	//
	IsActive() bool
	// Start wraps g_socket_service_start
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_service_start.g_socket_service_start.html
	//
	Start()
	// Stop wraps g_socket_service_stop
	// 
	// see also https://docs.gtk.org/gio/method.g_socket_service_stop.g_socket_service_stop.html
	//
	Stop()
	// ConnectIncoming connects the provided callback to the "incoming" signal
	// 
	// see also https://docs.gtk.org/gio/signal.SocketService.incoming.html
	//
	ConnectIncoming(func(SocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentIncoming calls the default implementations of the `GSocketService.incoming` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.SocketService.incoming.html
	ParentIncoming(connection SocketConnection, sourceObject gobject.Object) bool
}

func unsafeWrapSocketService(base *gobject.ObjectInstance) *SocketServiceInstance {
	return &SocketServiceInstance{
		SocketListenerInstance: SocketListenerInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketService(inst)
		},
	)
}

func marshalSocketServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketServiceFromGlibNone is used to convert raw GSocketService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibNone(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketService)
}

// UnsafeSocketServiceFromGlibFull is used to convert raw GSocketService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibFull(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketService)
}

// UnsafeSocketServiceFromGlibBorrow is used to convert raw GSocketService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibBorrow(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketService)
}

func (s *SocketServiceInstance) upcastToGSocketService() *SocketServiceInstance {
	return s
}

// UnsafeSocketServiceToGlibNone is used to convert the instance to it's C value GSocketService. This is used by the bindings internally.
func UnsafeSocketServiceToGlibNone(c SocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketServiceToGlibFull is used to convert the instance to it's C value GSocketService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketServiceToGlibFull(c SocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketService wraps g_socket_service_new
// 
// see also https://docs.gtk.org/gio/func.g_socket_service_new.html
//
func NewSocketService() SocketService {
	var cret *C.GSocketService // return, full, converted

	cret = C.g_socket_service_new()

	var goret SocketService

	goret = UnsafeSocketServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IsActive wraps g_socket_service_is_active
// 
// see also https://docs.gtk.org/gio/method.g_socket_service_is_active.g_socket_service_is_active.html
//
func (service *SocketServiceInstance) IsActive() bool {
	var carg0 *C.GSocketService // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	cret = C.g_socket_service_is_active(carg0)
	runtime.KeepAlive(service)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Start wraps g_socket_service_start
// 
// see also https://docs.gtk.org/gio/method.g_socket_service_start.g_socket_service_start.html
//
func (service *SocketServiceInstance) Start() {
	var carg0 *C.GSocketService // in, none, converted

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	C.g_socket_service_start(carg0)
	runtime.KeepAlive(service)
}

// Stop wraps g_socket_service_stop
// 
// see also https://docs.gtk.org/gio/method.g_socket_service_stop.g_socket_service_stop.html
//
func (service *SocketServiceInstance) Stop() {
	var carg0 *C.GSocketService // in, none, converted

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	C.g_socket_service_stop(carg0)
	runtime.KeepAlive(service)
}

// ConnectIncoming connects the provided callback to the "incoming" signal
// 
// see also https://docs.gtk.org/gio/signal.SocketService.incoming.html
//
func (o *SocketServiceInstance) ConnectIncoming(fn func(SocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle {
	return o.Connect("incoming", fn)
}

// SocketServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketServiceOverrides[Instance SocketService] struct {
	// SocketListenerOverrides allows you to override virtual methods from the parent class SocketListener
	SocketListenerOverrides[Instance]

	// // Incoming allows you to override the implementation of the virtual method incoming.
	// 
	// see also https://docs.gtk.org/gio/method.SocketService.incoming.html
	Incoming func(Instance, SocketConnection, gobject.Object) bool
}

// UnsafeApplySocketServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketServiceOverrides[Instance SocketService](gclass unsafe.Pointer, overrides SocketServiceOverrides[Instance]) {
	UnsafeApplySocketListenerOverrides(gclass, overrides.SocketListenerOverrides)

	pclass := (*C.GSocketServiceClass)(gclass)

	if overrides.Incoming != nil {
		pclass.incoming = (*[0]byte)(C._goglib_gio2_SocketService_incoming)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketService_incoming",
			func(carg0 *C.GSocketService, carg1 *C.GSocketConnection, carg2 *C.GObject) (cret C.gboolean) {
				var service      Instance         // go GSocketService subclass
				var connection   SocketConnection // in, none, converted
				var sourceObject gobject.Object   // in, none, converted
				var goret        bool             // return

				service = UnsafeSocketServiceFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeSocketConnectionFromGlibNone(unsafe.Pointer(carg1))
				sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))

				goret = overrides.Incoming(service, connection, sourceObject)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentIncoming calls the default implementations of the `GSocketService.incoming` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.SocketService.incoming.html
func (service *SocketServiceInstance) ParentIncoming(connection SocketConnection, sourceObject gobject.Object) bool {
	var carg0 *C.GSocketService
	var carg1 *C.GSocketConnection // in, none, converted
	var carg2 *C.GObject           // in, none, converted
	var cret  C.gboolean           // return

	parentclass := (*C.GSocketServiceClass)(classdata.PeekParentClass(UnsafeSocketServiceToGlibNone(service)))

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))
	carg1 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))

	cret = C._goglib_gio2_SocketService_virtual_incoming(unsafe.Pointer(parentclass.incoming), carg0, carg1, carg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegisterSocketServiceSubClass is used to register a go subclass of GSocketService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketServiceSubClass[InstanceT SocketService](
		name string,
		classInit func(class *SocketServiceClass),
		constructor func() InstanceT,
		overrides SocketServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketService,
		UnsafeSocketServiceClassFromGlibBorrow,
		UnsafeApplySocketServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketService(obj)
		},
		interfaceInits...,
	)
}

// TaskInstance is the instance type used by all types extending GTask. It is used internally by the bindings. Users should use the interface [Task] instead.
type TaskInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Task = (*TaskInstance)(nil)

// Task wraps GTask
// 
// see also https://docs.gtk.org/gio/class.Task.html
//
type Task interface {
	gobject.Object
	upcastToGTask() *TaskInstance

	// GetCancellable wraps g_task_get_cancellable
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_cancellable.g_task_get_cancellable.html
	//
	GetCancellable() Cancellable
	// GetCheckCancellable wraps g_task_get_check_cancellable
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_check_cancellable.g_task_get_check_cancellable.html
	//
	GetCheckCancellable() bool
	// GetCompleted wraps g_task_get_completed
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_completed.g_task_get_completed.html
	//
	GetCompleted() bool
	// GetContext wraps g_task_get_context
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_context.g_task_get_context.html
	//
	GetContext() *glib.MainContext
	// GetName wraps g_task_get_name
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_name.g_task_get_name.html
	//
	GetName() string
	// GetPriority wraps g_task_get_priority
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_priority.g_task_get_priority.html
	//
	GetPriority() int32
	// GetReturnOnCancel wraps g_task_get_return_on_cancel
	// 
	// see also https://docs.gtk.org/gio/method.g_task_get_return_on_cancel.g_task_get_return_on_cancel.html
	//
	GetReturnOnCancel() bool
	// HadError wraps g_task_had_error
	// 
	// see also https://docs.gtk.org/gio/method.g_task_had_error.g_task_had_error.html
	//
	HadError() bool
	// PropagateBoolean wraps g_task_propagate_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_task_propagate_boolean.g_task_propagate_boolean.html
	//
	PropagateBoolean() (bool, error)
	// PropagateInt wraps g_task_propagate_int
	// 
	// see also https://docs.gtk.org/gio/method.g_task_propagate_int.g_task_propagate_int.html
	//
	PropagateInt() (int, error)
	// PropagateValue wraps g_task_propagate_value
	// 
	// see also https://docs.gtk.org/gio/method.g_task_propagate_value.g_task_propagate_value.html
	//
	PropagateValue() (gobject.Value, bool, error)
	// ReturnBoolean wraps g_task_return_boolean
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_boolean.g_task_return_boolean.html
	//
	ReturnBoolean(bool)
	// ReturnError wraps g_task_return_error
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_error.g_task_return_error.html
	//
	ReturnError(error)
	// ReturnErrorIfCancelled wraps g_task_return_error_if_cancelled
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_error_if_cancelled.g_task_return_error_if_cancelled.html
	//
	ReturnErrorIfCancelled() bool
	// ReturnInt wraps g_task_return_int
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_int.g_task_return_int.html
	//
	ReturnInt(int)
	// ReturnNewErrorLiteral wraps g_task_return_new_error_literal
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_new_error_literal.g_task_return_new_error_literal.html
	//
	ReturnNewErrorLiteral(glib.Quark, int32, string)
	// ReturnValue wraps g_task_return_value
	// 
	// see also https://docs.gtk.org/gio/method.g_task_return_value.g_task_return_value.html
	//
	ReturnValue(*gobject.Value)
	// SetCheckCancellable wraps g_task_set_check_cancellable
	// 
	// see also https://docs.gtk.org/gio/method.g_task_set_check_cancellable.g_task_set_check_cancellable.html
	//
	SetCheckCancellable(bool)
	// SetName wraps g_task_set_name
	// 
	// see also https://docs.gtk.org/gio/method.g_task_set_name.g_task_set_name.html
	//
	SetName(string)
	// SetPriority wraps g_task_set_priority
	// 
	// see also https://docs.gtk.org/gio/method.g_task_set_priority.g_task_set_priority.html
	//
	SetPriority(int32)
	// SetReturnOnCancel wraps g_task_set_return_on_cancel
	// 
	// see also https://docs.gtk.org/gio/method.g_task_set_return_on_cancel.g_task_set_return_on_cancel.html
	//
	SetReturnOnCancel(bool) bool
	// SetStaticName wraps g_task_set_static_name
	// 
	// see also https://docs.gtk.org/gio/method.g_task_set_static_name.g_task_set_static_name.html
	//
	SetStaticName(string)
}

func unsafeWrapTask(base *gobject.ObjectInstance) *TaskInstance {
	return &TaskInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTask,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTask(inst)
		},
	)
}

func marshalTaskInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTaskFromGlibNone is used to convert raw GTask pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTaskFromGlibNone(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibNone(c).(Task)
}

// UnsafeTaskFromGlibFull is used to convert raw GTask pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTaskFromGlibFull(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibFull(c).(Task)
}

// UnsafeTaskFromGlibBorrow is used to convert raw GTask pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTaskFromGlibBorrow(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Task)
}

func (t *TaskInstance) upcastToGTask() *TaskInstance {
	return t
}

// UnsafeTaskToGlibNone is used to convert the instance to it's C value GTask. This is used by the bindings internally.
func UnsafeTaskToGlibNone(c Task) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTaskToGlibFull is used to convert the instance to it's C value GTask, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTaskToGlibFull(c Task) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetCancellable wraps g_task_get_cancellable
// 
// see also https://docs.gtk.org/gio/method.g_task_get_cancellable.g_task_get_cancellable.html
//
func (task *TaskInstance) GetCancellable() Cancellable {
	var carg0 *C.GTask        // in, none, converted
	var cret  *C.GCancellable // return, none, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_cancellable(carg0)
	runtime.KeepAlive(task)

	var goret Cancellable

	if cret != nil {
		goret = UnsafeCancellableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCheckCancellable wraps g_task_get_check_cancellable
// 
// see also https://docs.gtk.org/gio/method.g_task_get_check_cancellable.g_task_get_check_cancellable.html
//
func (task *TaskInstance) GetCheckCancellable() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_check_cancellable(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCompleted wraps g_task_get_completed
// 
// see also https://docs.gtk.org/gio/method.g_task_get_completed.g_task_get_completed.html
//
func (task *TaskInstance) GetCompleted() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_completed(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetContext wraps g_task_get_context
// 
// see also https://docs.gtk.org/gio/method.g_task_get_context.g_task_get_context.html
//
func (task *TaskInstance) GetContext() *glib.MainContext {
	var carg0 *C.GTask        // in, none, converted
	var cret  *C.GMainContext // return, none, converted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_context(carg0)
	runtime.KeepAlive(task)

	var goret *glib.MainContext

	goret = glib.UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetName wraps g_task_get_name
// 
// see also https://docs.gtk.org/gio/method.g_task_get_name.g_task_get_name.html
//
func (task *TaskInstance) GetName() string {
	var carg0 *C.GTask // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_name(carg0)
	runtime.KeepAlive(task)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPriority wraps g_task_get_priority
// 
// see also https://docs.gtk.org/gio/method.g_task_get_priority.g_task_get_priority.html
//
func (task *TaskInstance) GetPriority() int32 {
	var carg0 *C.GTask // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_priority(carg0)
	runtime.KeepAlive(task)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetReturnOnCancel wraps g_task_get_return_on_cancel
// 
// see also https://docs.gtk.org/gio/method.g_task_get_return_on_cancel.g_task_get_return_on_cancel.html
//
func (task *TaskInstance) GetReturnOnCancel() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_return_on_cancel(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HadError wraps g_task_had_error
// 
// see also https://docs.gtk.org/gio/method.g_task_had_error.g_task_had_error.html
//
func (task *TaskInstance) HadError() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_had_error(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PropagateBoolean wraps g_task_propagate_boolean
// 
// see also https://docs.gtk.org/gio/method.g_task_propagate_boolean.g_task_propagate_boolean.html
//
func (task *TaskInstance) PropagateBoolean() (bool, error) {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_boolean(carg0, &_cerr)
	runtime.KeepAlive(task)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PropagateInt wraps g_task_propagate_int
// 
// see also https://docs.gtk.org/gio/method.g_task_propagate_int.g_task_propagate_int.html
//
func (task *TaskInstance) PropagateInt() (int, error) {
	var carg0 *C.GTask  // in, none, converted
	var cret  C.gssize  // return, none, casted
	var _cerr *C.GError // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_int(carg0, &_cerr)
	runtime.KeepAlive(task)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PropagateValue wraps g_task_propagate_value
// 
// see also https://docs.gtk.org/gio/method.g_task_propagate_value.g_task_propagate_value.html
//
func (task *TaskInstance) PropagateValue() (gobject.Value, bool, error) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.GValue   // out, transfer: none, C Pointers: 0, Name: Value, caller-allocates
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_value(carg0, &carg1, &_cerr)
	runtime.KeepAlive(task)

	var value  gobject.Value
	var goret  bool
	var _goerr error

	_ = value
	_ = carg1
	panic("unimplemented conversion of gobject.Value (GValue) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return value, goret, _goerr
}

// ReturnBoolean wraps g_task_return_boolean
// 
// see also https://docs.gtk.org/gio/method.g_task_return_boolean.g_task_return_boolean.html
//
func (task *TaskInstance) ReturnBoolean(result bool) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if result {
		carg1 = C.TRUE
	}

	C.g_task_return_boolean(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnError wraps g_task_return_error
// 
// see also https://docs.gtk.org/gio/method.g_task_return_error.g_task_return_error.html
//
func (task *TaskInstance) ReturnError(err error) {
	var carg0 *C.GTask  // in, none, converted
	var carg1 *C.GError // in, full, converted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = (*C.GError)(glib.UnsafeErrorToGlibFull(err))

	C.g_task_return_error(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(err)
}

// ReturnErrorIfCancelled wraps g_task_return_error_if_cancelled
// 
// see also https://docs.gtk.org/gio/method.g_task_return_error_if_cancelled.g_task_return_error_if_cancelled.html
//
func (task *TaskInstance) ReturnErrorIfCancelled() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_return_error_if_cancelled(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReturnInt wraps g_task_return_int
// 
// see also https://docs.gtk.org/gio/method.g_task_return_int.g_task_return_int.html
//
func (task *TaskInstance) ReturnInt(result int) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.gssize // in, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.gssize(result)

	C.g_task_return_int(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnNewErrorLiteral wraps g_task_return_new_error_literal
// 
// see also https://docs.gtk.org/gio/method.g_task_return_new_error_literal.g_task_return_new_error_literal.html
//
func (task *TaskInstance) ReturnNewErrorLiteral(domain glib.Quark, code int32, message string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.GQuark // in, none, casted, alias
	var carg2 C.gint   // in, none, casted
	var carg3 *C.char  // in, none, string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.GQuark(domain)
	carg2 = C.gint(code)
	carg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_task_return_new_error_literal(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(task)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)
}

// ReturnValue wraps g_task_return_value
// 
// see also https://docs.gtk.org/gio/method.g_task_return_value.g_task_return_value.html
//
func (task *TaskInstance) ReturnValue(result *gobject.Value) {
	var carg0 *C.GTask  // in, none, converted
	var carg1 *C.GValue // in, none, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if result != nil {
		carg1 = (*C.GValue)(gobject.UnsafeValueToGlibUseAnyInstead(result))
	}

	C.g_task_return_value(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// SetCheckCancellable wraps g_task_set_check_cancellable
// 
// see also https://docs.gtk.org/gio/method.g_task_set_check_cancellable.g_task_set_check_cancellable.html
//
func (task *TaskInstance) SetCheckCancellable(checkCancellable bool) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if checkCancellable {
		carg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(checkCancellable)
}

// SetName wraps g_task_set_name
// 
// see also https://docs.gtk.org/gio/method.g_task_set_name.g_task_set_name.html
//
func (task *TaskInstance) SetName(name string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if name != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_task_set_name(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// SetPriority wraps g_task_set_priority
// 
// see also https://docs.gtk.org/gio/method.g_task_set_priority.g_task_set_priority.html
//
func (task *TaskInstance) SetPriority(priority int32) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.gint   // in, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.gint(priority)

	C.g_task_set_priority(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(priority)
}

// SetReturnOnCancel wraps g_task_set_return_on_cancel
// 
// see also https://docs.gtk.org/gio/method.g_task_set_return_on_cancel.g_task_set_return_on_cancel.html
//
func (task *TaskInstance) SetReturnOnCancel(returnOnCancel bool) bool {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if returnOnCancel {
		carg1 = C.TRUE
	}

	cret = C.g_task_set_return_on_cancel(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(returnOnCancel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetStaticName wraps g_task_set_static_name
// 
// see also https://docs.gtk.org/gio/method.g_task_set_static_name.g_task_set_static_name.html
//
func (task *TaskInstance) SetStaticName(name string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if name != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_task_set_static_name(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// TcpConnectionInstance is the instance type used by all types extending GTcpConnection. It is used internally by the bindings. Users should use the interface [TcpConnection] instead.
type TcpConnectionInstance struct {
	_ [0]func() // equal guard
	SocketConnectionInstance
}

var _ TcpConnection = (*TcpConnectionInstance)(nil)

// TcpConnection wraps GTcpConnection
// 
// see also https://docs.gtk.org/gio/class.TcpConnection.html
//
type TcpConnection interface {
	SocketConnection
	upcastToGTcpConnection() *TcpConnectionInstance

	// GetGracefulDisconnect wraps g_tcp_connection_get_graceful_disconnect
	// 
	// see also https://docs.gtk.org/gio/method.g_tcp_connection_get_graceful_disconnect.g_tcp_connection_get_graceful_disconnect.html
	//
	GetGracefulDisconnect() bool
	// SetGracefulDisconnect wraps g_tcp_connection_set_graceful_disconnect
	// 
	// see also https://docs.gtk.org/gio/method.g_tcp_connection_set_graceful_disconnect.g_tcp_connection_set_graceful_disconnect.html
	//
	SetGracefulDisconnect(bool)

	// chain up virtual methods:
}

func unsafeWrapTcpConnection(base *gobject.ObjectInstance) *TcpConnectionInstance {
	return &TcpConnectionInstance{
		SocketConnectionInstance: SocketConnectionInstance{
			IOStreamInstance: IOStreamInstance{
				ObjectInstance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTcpConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpConnection(inst)
		},
	)
}

func marshalTcpConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTcpConnectionFromGlibNone is used to convert raw GTcpConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibNone(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TcpConnection)
}

// UnsafeTcpConnectionFromGlibFull is used to convert raw GTcpConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibFull(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TcpConnection)
}

// UnsafeTcpConnectionFromGlibBorrow is used to convert raw GTcpConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibBorrow(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TcpConnection)
}

func (t *TcpConnectionInstance) upcastToGTcpConnection() *TcpConnectionInstance {
	return t
}

// UnsafeTcpConnectionToGlibNone is used to convert the instance to it's C value GTcpConnection. This is used by the bindings internally.
func UnsafeTcpConnectionToGlibNone(c TcpConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTcpConnectionToGlibFull is used to convert the instance to it's C value GTcpConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionToGlibFull(c TcpConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetGracefulDisconnect wraps g_tcp_connection_get_graceful_disconnect
// 
// see also https://docs.gtk.org/gio/method.g_tcp_connection_get_graceful_disconnect.g_tcp_connection_get_graceful_disconnect.html
//
func (connection *TcpConnectionInstance) GetGracefulDisconnect() bool {
	var carg0 *C.GTcpConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTcpConnection)(UnsafeTcpConnectionToGlibNone(connection))

	cret = C.g_tcp_connection_get_graceful_disconnect(carg0)
	runtime.KeepAlive(connection)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetGracefulDisconnect wraps g_tcp_connection_set_graceful_disconnect
// 
// see also https://docs.gtk.org/gio/method.g_tcp_connection_set_graceful_disconnect.g_tcp_connection_set_graceful_disconnect.html
//
func (connection *TcpConnectionInstance) SetGracefulDisconnect(gracefulDisconnect bool) {
	var carg0 *C.GTcpConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTcpConnection)(UnsafeTcpConnectionToGlibNone(connection))
	if gracefulDisconnect {
		carg1 = C.TRUE
	}

	C.g_tcp_connection_set_graceful_disconnect(carg0, carg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(gracefulDisconnect)
}

// TcpConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TcpConnectionOverrides[Instance TcpConnection] struct {
	// SocketConnectionOverrides allows you to override virtual methods from the parent class SocketConnection
	SocketConnectionOverrides[Instance]

}

// UnsafeApplyTcpConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTcpConnectionOverrides[Instance TcpConnection](gclass unsafe.Pointer, overrides TcpConnectionOverrides[Instance]) {
	UnsafeApplySocketConnectionOverrides(gclass, overrides.SocketConnectionOverrides)
}

// RegisterTcpConnectionSubClass is used to register a go subclass of GTcpConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTcpConnectionSubClass[InstanceT TcpConnection](
		name string,
		classInit func(class *TcpConnectionClass),
		constructor func() InstanceT,
		overrides TcpConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTcpConnection,
		UnsafeTcpConnectionClassFromGlibBorrow,
		UnsafeApplyTcpConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpConnection(obj)
		},
		interfaceInits...,
	)
}

// TcpWrapperConnectionInstance is the instance type used by all types extending GTcpWrapperConnection. It is used internally by the bindings. Users should use the interface [TcpWrapperConnection] instead.
type TcpWrapperConnectionInstance struct {
	_ [0]func() // equal guard
	TcpConnectionInstance
}

var _ TcpWrapperConnection = (*TcpWrapperConnectionInstance)(nil)

// TcpWrapperConnection wraps GTcpWrapperConnection
// 
// see also https://docs.gtk.org/gio/class.TcpWrapperConnection.html
//
type TcpWrapperConnection interface {
	TcpConnection
	upcastToGTcpWrapperConnection() *TcpWrapperConnectionInstance

	// GetBaseIOStream wraps g_tcp_wrapper_connection_get_base_io_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_tcp_wrapper_connection_get_base_io_stream.g_tcp_wrapper_connection_get_base_io_stream.html
	//
	GetBaseIOStream() IOStream

	// chain up virtual methods:
}

func unsafeWrapTcpWrapperConnection(base *gobject.ObjectInstance) *TcpWrapperConnectionInstance {
	return &TcpWrapperConnectionInstance{
		TcpConnectionInstance: TcpConnectionInstance{
			SocketConnectionInstance: SocketConnectionInstance{
				IOStreamInstance: IOStreamInstance{
					ObjectInstance: *base,
				},
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTcpWrapperConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpWrapperConnection(inst)
		},
	)
}

func marshalTcpWrapperConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTcpWrapperConnectionFromGlibNone is used to convert raw GTcpWrapperConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibNone(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TcpWrapperConnection)
}

// UnsafeTcpWrapperConnectionFromGlibFull is used to convert raw GTcpWrapperConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibFull(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TcpWrapperConnection)
}

// UnsafeTcpWrapperConnectionFromGlibBorrow is used to convert raw GTcpWrapperConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibBorrow(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TcpWrapperConnection)
}

func (t *TcpWrapperConnectionInstance) upcastToGTcpWrapperConnection() *TcpWrapperConnectionInstance {
	return t
}

// UnsafeTcpWrapperConnectionToGlibNone is used to convert the instance to it's C value GTcpWrapperConnection. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionToGlibNone(c TcpWrapperConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTcpWrapperConnectionToGlibFull is used to convert the instance to it's C value GTcpWrapperConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionToGlibFull(c TcpWrapperConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTcpWrapperConnection wraps g_tcp_wrapper_connection_new
// 
// see also https://docs.gtk.org/gio/func.g_tcp_wrapper_connection_new.html
//
func NewTcpWrapperConnection(baseIoStream IOStream, socket Socket) SocketConnection {
	var carg1 *C.GIOStream         // in, none, converted
	var carg2 *C.GSocket           // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	carg2 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_tcp_wrapper_connection_new(carg1, carg2)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(socket)

	var goret SocketConnection

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetBaseIOStream wraps g_tcp_wrapper_connection_get_base_io_stream
// 
// see also https://docs.gtk.org/gio/method.g_tcp_wrapper_connection_get_base_io_stream.g_tcp_wrapper_connection_get_base_io_stream.html
//
func (conn *TcpWrapperConnectionInstance) GetBaseIOStream() IOStream {
	var carg0 *C.GTcpWrapperConnection // in, none, converted
	var cret  *C.GIOStream             // return, none, converted

	carg0 = (*C.GTcpWrapperConnection)(UnsafeTcpWrapperConnectionToGlibNone(conn))

	cret = C.g_tcp_wrapper_connection_get_base_io_stream(carg0)
	runtime.KeepAlive(conn)

	var goret IOStream

	goret = UnsafeIOStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// TcpWrapperConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TcpWrapperConnectionOverrides[Instance TcpWrapperConnection] struct {
	// TcpConnectionOverrides allows you to override virtual methods from the parent class TcpConnection
	TcpConnectionOverrides[Instance]

}

// UnsafeApplyTcpWrapperConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTcpWrapperConnectionOverrides[Instance TcpWrapperConnection](gclass unsafe.Pointer, overrides TcpWrapperConnectionOverrides[Instance]) {
	UnsafeApplyTcpConnectionOverrides(gclass, overrides.TcpConnectionOverrides)
}

// RegisterTcpWrapperConnectionSubClass is used to register a go subclass of GTcpWrapperConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTcpWrapperConnectionSubClass[InstanceT TcpWrapperConnection](
		name string,
		classInit func(class *TcpWrapperConnectionClass),
		constructor func() InstanceT,
		overrides TcpWrapperConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTcpWrapperConnection,
		UnsafeTcpWrapperConnectionClassFromGlibBorrow,
		UnsafeApplyTcpWrapperConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpWrapperConnection(obj)
		},
		interfaceInits...,
	)
}

// ThemedIconInstance is the instance type used by all types extending GThemedIcon. It is used internally by the bindings. Users should use the interface [ThemedIcon] instead.
type ThemedIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ThemedIcon = (*ThemedIconInstance)(nil)

// ThemedIcon wraps GThemedIcon
// 
// see also https://docs.gtk.org/gio/class.ThemedIcon.html
//
type ThemedIcon interface {
	gobject.Object
	upcastToGThemedIcon() *ThemedIconInstance

	// AppendName wraps g_themed_icon_append_name
	// 
	// see also https://docs.gtk.org/gio/method.g_themed_icon_append_name.g_themed_icon_append_name.html
	//
	AppendName(string)
	// GetNames wraps g_themed_icon_get_names
	// 
	// see also https://docs.gtk.org/gio/method.g_themed_icon_get_names.g_themed_icon_get_names.html
	//
	GetNames() []string
	// PrependName wraps g_themed_icon_prepend_name
	// 
	// see also https://docs.gtk.org/gio/method.g_themed_icon_prepend_name.g_themed_icon_prepend_name.html
	//
	PrependName(string)
}

func unsafeWrapThemedIcon(base *gobject.ObjectInstance) *ThemedIconInstance {
	return &ThemedIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeThemedIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThemedIcon(inst)
		},
	)
}

func marshalThemedIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeThemedIconFromGlibNone is used to convert raw GThemedIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeThemedIconFromGlibNone(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(ThemedIcon)
}

// UnsafeThemedIconFromGlibFull is used to convert raw GThemedIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeThemedIconFromGlibFull(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(ThemedIcon)
}

// UnsafeThemedIconFromGlibBorrow is used to convert raw GThemedIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeThemedIconFromGlibBorrow(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ThemedIcon)
}

func (t *ThemedIconInstance) upcastToGThemedIcon() *ThemedIconInstance {
	return t
}

// UnsafeThemedIconToGlibNone is used to convert the instance to it's C value GThemedIcon. This is used by the bindings internally.
func UnsafeThemedIconToGlibNone(c ThemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeThemedIconToGlibFull is used to convert the instance to it's C value GThemedIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeThemedIconToGlibFull(c ThemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewThemedIcon wraps g_themed_icon_new
// 
// see also https://docs.gtk.org/gio/func.g_themed_icon_new.html
//
func NewThemedIcon(iconname string) ThemedIcon {
	var carg1 *C.char  // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_themed_icon_new(carg1)
	runtime.KeepAlive(iconname)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewThemedIconFromNames wraps g_themed_icon_new_from_names
// 
// see also https://docs.gtk.org/gio/func.g_themed_icon_new_from_names.html
//
func NewThemedIconFromNames(iconnames []string) ThemedIcon {
	var carg1 **C.char // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), length-by: carg2)
	var carg2 C.int    // implicit
	var cret  *C.GIcon // return, full, converted

	_ = iconnames
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	cret = C.g_themed_icon_new_from_names(carg1, carg2)
	runtime.KeepAlive(iconnames)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewThemedIconWithDefaultFallbacks wraps g_themed_icon_new_with_default_fallbacks
// 
// see also https://docs.gtk.org/gio/func.g_themed_icon_new_with_default_fallbacks.html
//
func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon {
	var carg1 *C.char  // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_themed_icon_new_with_default_fallbacks(carg1)
	runtime.KeepAlive(iconname)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AppendName wraps g_themed_icon_append_name
// 
// see also https://docs.gtk.org/gio/method.g_themed_icon_append_name.g_themed_icon_append_name.html
//
func (icon *ThemedIconInstance) AppendName(iconname string) {
	var carg0 *C.GThemedIcon // in, none, converted
	var carg1 *C.char        // in, none, string

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_themed_icon_append_name(carg0, carg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// GetNames wraps g_themed_icon_get_names
// 
// see also https://docs.gtk.org/gio/method.g_themed_icon_get_names.g_themed_icon_get_names.html
//
func (icon *ThemedIconInstance) GetNames() []string {
	var carg0 *C.GThemedIcon // in, none, converted
	var cret  **C.gchar      // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))

	cret = C.g_themed_icon_get_names(carg0)
	runtime.KeepAlive(icon)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// PrependName wraps g_themed_icon_prepend_name
// 
// see also https://docs.gtk.org/gio/method.g_themed_icon_prepend_name.g_themed_icon_prepend_name.html
//
func (icon *ThemedIconInstance) PrependName(iconname string) {
	var carg0 *C.GThemedIcon // in, none, converted
	var carg1 *C.char        // in, none, string

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_themed_icon_prepend_name(carg0, carg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// ThreadedSocketServiceInstance is the instance type used by all types extending GThreadedSocketService. It is used internally by the bindings. Users should use the interface [ThreadedSocketService] instead.
type ThreadedSocketServiceInstance struct {
	_ [0]func() // equal guard
	SocketServiceInstance
}

var _ ThreadedSocketService = (*ThreadedSocketServiceInstance)(nil)

// ThreadedSocketService wraps GThreadedSocketService
// 
// see also https://docs.gtk.org/gio/class.ThreadedSocketService.html
//
type ThreadedSocketService interface {
	SocketService
	upcastToGThreadedSocketService() *ThreadedSocketServiceInstance

	// ConnectRun connects the provided callback to the "run" signal
	// 
	// see also https://docs.gtk.org/gio/signal.ThreadedSocketService.run.html
	//
	ConnectRun(func(ThreadedSocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentRun calls the default implementations of the `GThreadedSocketService.run` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.ThreadedSocketService.run.html
	ParentRun(connection SocketConnection, sourceObject gobject.Object) bool
}

func unsafeWrapThreadedSocketService(base *gobject.ObjectInstance) *ThreadedSocketServiceInstance {
	return &ThreadedSocketServiceInstance{
		SocketServiceInstance: SocketServiceInstance{
			SocketListenerInstance: SocketListenerInstance{
				ObjectInstance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeThreadedSocketService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThreadedSocketService(inst)
		},
	)
}

func marshalThreadedSocketServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeThreadedSocketServiceFromGlibNone is used to convert raw GThreadedSocketService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibNone(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibNone(c).(ThreadedSocketService)
}

// UnsafeThreadedSocketServiceFromGlibFull is used to convert raw GThreadedSocketService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibFull(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibFull(c).(ThreadedSocketService)
}

// UnsafeThreadedSocketServiceFromGlibBorrow is used to convert raw GThreadedSocketService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibBorrow(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ThreadedSocketService)
}

func (t *ThreadedSocketServiceInstance) upcastToGThreadedSocketService() *ThreadedSocketServiceInstance {
	return t
}

// UnsafeThreadedSocketServiceToGlibNone is used to convert the instance to it's C value GThreadedSocketService. This is used by the bindings internally.
func UnsafeThreadedSocketServiceToGlibNone(c ThreadedSocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeThreadedSocketServiceToGlibFull is used to convert the instance to it's C value GThreadedSocketService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceToGlibFull(c ThreadedSocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewThreadedSocketService wraps g_threaded_socket_service_new
// 
// see also https://docs.gtk.org/gio/func.g_threaded_socket_service_new.html
//
func NewThreadedSocketService(maxThreads int32) SocketService {
	var carg1 C.int             // in, none, casted
	var cret  *C.GSocketService // return, full, converted

	carg1 = C.int(maxThreads)

	cret = C.g_threaded_socket_service_new(carg1)
	runtime.KeepAlive(maxThreads)

	var goret SocketService

	goret = UnsafeSocketServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectRun connects the provided callback to the "run" signal
// 
// see also https://docs.gtk.org/gio/signal.ThreadedSocketService.run.html
//
func (o *ThreadedSocketServiceInstance) ConnectRun(fn func(ThreadedSocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle {
	return o.Connect("run", fn)
}

// ThreadedSocketServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ThreadedSocketServiceOverrides[Instance ThreadedSocketService] struct {
	// SocketServiceOverrides allows you to override virtual methods from the parent class SocketService
	SocketServiceOverrides[Instance]

	// // Run allows you to override the implementation of the virtual method run.
	// 
	// see also https://docs.gtk.org/gio/method.ThreadedSocketService.run.html
	Run func(Instance, SocketConnection, gobject.Object) bool
}

// UnsafeApplyThreadedSocketServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyThreadedSocketServiceOverrides[Instance ThreadedSocketService](gclass unsafe.Pointer, overrides ThreadedSocketServiceOverrides[Instance]) {
	UnsafeApplySocketServiceOverrides(gclass, overrides.SocketServiceOverrides)

	pclass := (*C.GThreadedSocketServiceClass)(gclass)

	if overrides.Run != nil {
		pclass.run = (*[0]byte)(C._goglib_gio2_ThreadedSocketService_run)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ThreadedSocketService_run",
			func(carg0 *C.GThreadedSocketService, carg1 *C.GSocketConnection, carg2 *C.GObject) (cret C.gboolean) {
				var service      Instance         // go GThreadedSocketService subclass
				var connection   SocketConnection // in, none, converted
				var sourceObject gobject.Object   // in, none, converted
				var goret        bool             // return

				service = UnsafeThreadedSocketServiceFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeSocketConnectionFromGlibNone(unsafe.Pointer(carg1))
				sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))

				goret = overrides.Run(service, connection, sourceObject)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentRun calls the default implementations of the `GThreadedSocketService.run` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.ThreadedSocketService.run.html
func (service *ThreadedSocketServiceInstance) ParentRun(connection SocketConnection, sourceObject gobject.Object) bool {
	var carg0 *C.GThreadedSocketService
	var carg1 *C.GSocketConnection // in, none, converted
	var carg2 *C.GObject           // in, none, converted
	var cret  C.gboolean           // return

	parentclass := (*C.GThreadedSocketServiceClass)(classdata.PeekParentClass(UnsafeThreadedSocketServiceToGlibNone(service)))

	carg0 = (*C.GThreadedSocketService)(UnsafeThreadedSocketServiceToGlibNone(service))
	carg1 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))

	cret = C._goglib_gio2_ThreadedSocketService_virtual_run(unsafe.Pointer(parentclass.run), carg0, carg1, carg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegisterThreadedSocketServiceSubClass is used to register a go subclass of GThreadedSocketService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterThreadedSocketServiceSubClass[InstanceT ThreadedSocketService](
		name string,
		classInit func(class *ThreadedSocketServiceClass),
		constructor func() InstanceT,
		overrides ThreadedSocketServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeThreadedSocketService,
		UnsafeThreadedSocketServiceClassFromGlibBorrow,
		UnsafeApplyThreadedSocketServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThreadedSocketService(obj)
		},
		interfaceInits...,
	)
}

// TlsCertificateInstance is the instance type used by all types extending GTlsCertificate. It is used internally by the bindings. Users should use the interface [TlsCertificate] instead.
type TlsCertificateInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsCertificate = (*TlsCertificateInstance)(nil)

// TlsCertificate wraps GTlsCertificate
// 
// see also https://docs.gtk.org/gio/class.TlsCertificate.html
//
type TlsCertificate interface {
	gobject.Object
	upcastToGTlsCertificate() *TlsCertificateInstance

	// GetIssuer wraps g_tls_certificate_get_issuer
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_issuer.g_tls_certificate_get_issuer.html
	//
	GetIssuer() TlsCertificate
	// GetIssuerName wraps g_tls_certificate_get_issuer_name
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_issuer_name.g_tls_certificate_get_issuer_name.html
	//
	GetIssuerName() string
	// GetSubjectName wraps g_tls_certificate_get_subject_name
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_subject_name.g_tls_certificate_get_subject_name.html
	//
	GetSubjectName() string
	// IsSame wraps g_tls_certificate_is_same
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_certificate_is_same.g_tls_certificate_is_same.html
	//
	IsSame(TlsCertificate) bool
	// Verify wraps g_tls_certificate_verify
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_certificate_verify.g_tls_certificate_verify.html
	//
	Verify(SocketConnectable, TlsCertificate) TlsCertificateFlags

	// chain up virtual methods:

	// ParentVerify calls the default implementations of the `GTlsCertificate.verify` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsCertificate.verify.html
	ParentVerify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags
}

func unsafeWrapTlsCertificate(base *gobject.ObjectInstance) *TlsCertificateInstance {
	return &TlsCertificateInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsCertificate,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsCertificate(inst)
		},
	)
}

func marshalTlsCertificateInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsCertificateFromGlibNone is used to convert raw GTlsCertificate pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibNone(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsCertificate)
}

// UnsafeTlsCertificateFromGlibFull is used to convert raw GTlsCertificate pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibFull(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsCertificate)
}

// UnsafeTlsCertificateFromGlibBorrow is used to convert raw GTlsCertificate pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibBorrow(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsCertificate)
}

func (t *TlsCertificateInstance) upcastToGTlsCertificate() *TlsCertificateInstance {
	return t
}

// UnsafeTlsCertificateToGlibNone is used to convert the instance to it's C value GTlsCertificate. This is used by the bindings internally.
func UnsafeTlsCertificateToGlibNone(c TlsCertificate) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsCertificateToGlibFull is used to convert the instance to it's C value GTlsCertificate, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateToGlibFull(c TlsCertificate) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTlsCertificateFromFile wraps g_tls_certificate_new_from_file
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_file.html
//
func NewTlsCertificateFromFile(file string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_certificate_new_from_file(carg1, &_cerr)
	runtime.KeepAlive(file)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromFileWithPassword wraps g_tls_certificate_new_from_file_with_password
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_file_with_password.html
//
func NewTlsCertificateFromFileWithPassword(file string, password string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_certificate_new_from_file_with_password(carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(password)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromFiles wraps g_tls_certificate_new_from_files
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_files.html
//
func NewTlsCertificateFromFiles(certFile string, keyFile string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(certFile)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(keyFile)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_certificate_new_from_files(carg1, carg2, &_cerr)
	runtime.KeepAlive(certFile)
	runtime.KeepAlive(keyFile)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPem wraps g_tls_certificate_new_from_pem
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_pem.html
//
func NewTlsCertificateFromPem(data string, length int) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 C.gssize           // in, none, casted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(data)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)

	cret = C.g_tls_certificate_new_from_pem(carg1, carg2, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPkcs11Uris wraps g_tls_certificate_new_from_pkcs11_uris
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_pkcs11_uris.html
//
func NewTlsCertificateFromPkcs11Uris(pkcs11Uri string, privateKeyPkcs11Uri string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string, nullable-string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pkcs11Uri)))
	defer C.free(unsafe.Pointer(carg1))
	if privateKeyPkcs11Uri != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(privateKeyPkcs11Uri)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_tls_certificate_new_from_pkcs11_uris(carg1, carg2, &_cerr)
	runtime.KeepAlive(pkcs11Uri)
	runtime.KeepAlive(privateKeyPkcs11Uri)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPkcs12 wraps g_tls_certificate_new_from_pkcs12
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_new_from_pkcs12.html
//
func NewTlsCertificateFromPkcs12(data []uint8, password string) (TlsCertificate, error) {
	var carg1 *C.guint8          // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 *C.gchar           // in, none, string, nullable-string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")
	if password != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_tls_certificate_new_from_pkcs12(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(password)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsCertificateListNewFromFile wraps g_tls_certificate_list_new_from_file
// 
// see also https://docs.gtk.org/gio/func.g_tls_certificate_list_new_from_file.html
//
func TlsCertificateListNewFromFile(file string) ([]TlsCertificate, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GList  // container, transfer: full
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_certificate_list_new_from_file(carg1, &_cerr)
	runtime.KeepAlive(file)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetIssuer wraps g_tls_certificate_get_issuer
// 
// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_issuer.g_tls_certificate_get_issuer.html
//
func (cert *TlsCertificateInstance) GetIssuer() TlsCertificate {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_issuer(carg0)
	runtime.KeepAlive(cert)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetIssuerName wraps g_tls_certificate_get_issuer_name
// 
// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_issuer_name.g_tls_certificate_get_issuer_name.html
//
func (cert *TlsCertificateInstance) GetIssuerName() string {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_issuer_name(carg0)
	runtime.KeepAlive(cert)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetSubjectName wraps g_tls_certificate_get_subject_name
// 
// see also https://docs.gtk.org/gio/method.g_tls_certificate_get_subject_name.g_tls_certificate_get_subject_name.html
//
func (cert *TlsCertificateInstance) GetSubjectName() string {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_subject_name(carg0)
	runtime.KeepAlive(cert)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// IsSame wraps g_tls_certificate_is_same
// 
// see also https://docs.gtk.org/gio/method.g_tls_certificate_is_same.g_tls_certificate_is_same.html
//
func (certOne *TlsCertificateInstance) IsSame(certTwo TlsCertificate) bool {
	var carg0 *C.GTlsCertificate // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certOne))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certTwo))

	cret = C.g_tls_certificate_is_same(carg0, carg1)
	runtime.KeepAlive(certOne)
	runtime.KeepAlive(certTwo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Verify wraps g_tls_certificate_verify
// 
// see also https://docs.gtk.org/gio/method.g_tls_certificate_verify.g_tls_certificate_verify.html
//
func (cert *TlsCertificateInstance) Verify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags {
	var carg0 *C.GTlsCertificate     // in, none, converted
	var carg1 *C.GSocketConnectable  // in, none, converted, nullable
	var carg2 *C.GTlsCertificate     // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))
	if identity != nil {
		carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if trustedCa != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(trustedCa))
	}

	cret = C.g_tls_certificate_verify(carg0, carg1, carg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// TlsCertificateOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsCertificateOverrides[Instance TlsCertificate] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Verify allows you to override the implementation of the virtual method verify.
	// 
	// see also https://docs.gtk.org/gio/method.TlsCertificate.verify.html
	Verify func(Instance, SocketConnectable, TlsCertificate) TlsCertificateFlags
}

// UnsafeApplyTlsCertificateOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsCertificateOverrides[Instance TlsCertificate](gclass unsafe.Pointer, overrides TlsCertificateOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsCertificateClass)(gclass)

	if overrides.Verify != nil {
		pclass.verify = (*[0]byte)(C._goglib_gio2_TlsCertificate_verify)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsCertificate_verify",
			func(carg0 *C.GTlsCertificate, carg1 *C.GSocketConnectable, carg2 *C.GTlsCertificate) (cret C.GTlsCertificateFlags) {
				var cert      Instance            // go GTlsCertificate subclass
				var identity  SocketConnectable   // in, none, converted, nullable
				var trustedCa TlsCertificate      // in, none, converted, nullable
				var goret     TlsCertificateFlags // return, none, casted

				cert = UnsafeTlsCertificateFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					identity = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg1))
				}
				if carg2 != nil {
					trustedCa = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg2))
				}

				goret = overrides.Verify(cert, identity, trustedCa)

				cret = C.GTlsCertificateFlags(goret)

				return cret
			},
		)
	}
}

// ParentVerify calls the default implementations of the `GTlsCertificate.verify` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsCertificate.verify.html
func (cert *TlsCertificateInstance) ParentVerify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags {
	var carg0 *C.GTlsCertificate
	var carg1 *C.GSocketConnectable  // in, none, converted
	var carg2 *C.GTlsCertificate     // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags // return, none, casted

	parentclass := (*C.GTlsCertificateClass)(classdata.PeekParentClass(UnsafeTlsCertificateToGlibNone(cert)))

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))
	if identity != nil {
		carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if trustedCa != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(trustedCa))
	}

	cret = C._goglib_gio2_TlsCertificate_virtual_verify(unsafe.Pointer(parentclass.verify), carg0, carg1, carg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// RegisterTlsCertificateSubClass is used to register a go subclass of GTlsCertificate. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsCertificateSubClass[InstanceT TlsCertificate](
		name string,
		classInit func(class *TlsCertificateClass),
		constructor func() InstanceT,
		overrides TlsCertificateOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsCertificate,
		UnsafeTlsCertificateClassFromGlibBorrow,
		UnsafeApplyTlsCertificateOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsCertificate(obj)
		},
		interfaceInits...,
	)
}

// TlsConnectionInstance is the instance type used by all types extending GTlsConnection. It is used internally by the bindings. Users should use the interface [TlsConnection] instead.
type TlsConnectionInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ TlsConnection = (*TlsConnectionInstance)(nil)

// TlsConnection wraps GTlsConnection
// 
// see also https://docs.gtk.org/gio/class.TlsConnection.html
//
type TlsConnection interface {
	IOStream
	upcastToGTlsConnection() *TlsConnectionInstance

	// EmitAcceptCertificate wraps g_tls_connection_emit_accept_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_emit_accept_certificate.g_tls_connection_emit_accept_certificate.html
	//
	EmitAcceptCertificate(TlsCertificate, TlsCertificateFlags) bool
	// GetCertificate wraps g_tls_connection_get_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_certificate.g_tls_connection_get_certificate.html
	//
	GetCertificate() TlsCertificate
	// GetCiphersuiteName wraps g_tls_connection_get_ciphersuite_name
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_ciphersuite_name.g_tls_connection_get_ciphersuite_name.html
	//
	GetCiphersuiteName() string
	// GetDatabase wraps g_tls_connection_get_database
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_database.g_tls_connection_get_database.html
	//
	GetDatabase() TlsDatabase
	// GetInteraction wraps g_tls_connection_get_interaction
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_interaction.g_tls_connection_get_interaction.html
	//
	GetInteraction() TlsInteraction
	// GetNegotiatedProtocol wraps g_tls_connection_get_negotiated_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_negotiated_protocol.g_tls_connection_get_negotiated_protocol.html
	//
	GetNegotiatedProtocol() string
	// GetPeerCertificate wraps g_tls_connection_get_peer_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_peer_certificate.g_tls_connection_get_peer_certificate.html
	//
	GetPeerCertificate() TlsCertificate
	// GetPeerCertificateErrors wraps g_tls_connection_get_peer_certificate_errors
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_peer_certificate_errors.g_tls_connection_get_peer_certificate_errors.html
	//
	GetPeerCertificateErrors() TlsCertificateFlags
	// GetProtocolVersion wraps g_tls_connection_get_protocol_version
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_protocol_version.g_tls_connection_get_protocol_version.html
	//
	GetProtocolVersion() TlsProtocolVersion
	// GetRehandshakeMode wraps g_tls_connection_get_rehandshake_mode
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_rehandshake_mode.g_tls_connection_get_rehandshake_mode.html
	//
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	GetRehandshakeMode() TlsRehandshakeMode
	// GetRequireCloseNotify wraps g_tls_connection_get_require_close_notify
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_require_close_notify.g_tls_connection_get_require_close_notify.html
	//
	GetRequireCloseNotify() bool
	// GetUseSystemCertdb wraps g_tls_connection_get_use_system_certdb
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_get_use_system_certdb.g_tls_connection_get_use_system_certdb.html
	//
	//
	// Deprecated: (since 2.30.0) Use g_tls_connection_get_database() instead
	GetUseSystemCertdb() bool
	// Handshake wraps g_tls_connection_handshake
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake.g_tls_connection_handshake.html
	//
	Handshake(Cancellable) (bool, error)
	// HandshakeAsync wraps g_tls_connection_handshake_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake_async.g_tls_connection_handshake_async.html
	//
	HandshakeAsync(int32, Cancellable, AsyncReadyCallback)
	// HandshakeFinish wraps g_tls_connection_handshake_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake_finish.g_tls_connection_handshake_finish.html
	//
	HandshakeFinish(AsyncResult) (bool, error)
	// SetAdvertisedProtocols wraps g_tls_connection_set_advertised_protocols
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_advertised_protocols.g_tls_connection_set_advertised_protocols.html
	//
	SetAdvertisedProtocols([]string)
	// SetCertificate wraps g_tls_connection_set_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_certificate.g_tls_connection_set_certificate.html
	//
	SetCertificate(TlsCertificate)
	// SetDatabase wraps g_tls_connection_set_database
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_database.g_tls_connection_set_database.html
	//
	SetDatabase(TlsDatabase)
	// SetInteraction wraps g_tls_connection_set_interaction
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_interaction.g_tls_connection_set_interaction.html
	//
	SetInteraction(TlsInteraction)
	// SetRehandshakeMode wraps g_tls_connection_set_rehandshake_mode
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_rehandshake_mode.g_tls_connection_set_rehandshake_mode.html
	//
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	SetRehandshakeMode(TlsRehandshakeMode)
	// SetRequireCloseNotify wraps g_tls_connection_set_require_close_notify
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_require_close_notify.g_tls_connection_set_require_close_notify.html
	//
	SetRequireCloseNotify(bool)
	// SetUseSystemCertdb wraps g_tls_connection_set_use_system_certdb
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_connection_set_use_system_certdb.g_tls_connection_set_use_system_certdb.html
	//
	//
	// Deprecated: (since 2.30.0) Use g_tls_connection_set_database() instead
	SetUseSystemCertdb(bool)
	// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
	// 
	// see also https://docs.gtk.org/gio/signal.TlsConnection.accept-certificate.html
	//
	ConnectAcceptCertificate(func(TlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentAcceptCertificate calls the default implementations of the `GTlsConnection.accept_certificate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.accept_certificate.html
	ParentAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool
	// ParentGetNegotiatedProtocol calls the default implementations of the `GTlsConnection.get_negotiated_protocol` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.get_negotiated_protocol.html
	ParentGetNegotiatedProtocol() string
	// ParentHandshake calls the default implementations of the `GTlsConnection.handshake` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.handshake.html
	ParentHandshake(cancellable Cancellable) (bool, error)
	// ParentHandshakeFinish calls the default implementations of the `GTlsConnection.handshake_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.handshake_finish.html
	ParentHandshakeFinish(result AsyncResult) (bool, error)
}

func unsafeWrapTlsConnection(base *gobject.ObjectInstance) *TlsConnectionInstance {
	return &TlsConnectionInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsConnection(inst)
		},
	)
}

func marshalTlsConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsConnectionFromGlibNone is used to convert raw GTlsConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibNone(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsConnection)
}

// UnsafeTlsConnectionFromGlibFull is used to convert raw GTlsConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibFull(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsConnection)
}

// UnsafeTlsConnectionFromGlibBorrow is used to convert raw GTlsConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibBorrow(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsConnection)
}

func (t *TlsConnectionInstance) upcastToGTlsConnection() *TlsConnectionInstance {
	return t
}

// UnsafeTlsConnectionToGlibNone is used to convert the instance to it's C value GTlsConnection. This is used by the bindings internally.
func UnsafeTlsConnectionToGlibNone(c TlsConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsConnectionToGlibFull is used to convert the instance to it's C value GTlsConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionToGlibFull(c TlsConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// EmitAcceptCertificate wraps g_tls_connection_emit_accept_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_emit_accept_certificate.g_tls_connection_emit_accept_certificate.html
//
func (conn *TlsConnectionInstance) EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GTlsConnection      // in, none, converted
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C.g_tls_connection_emit_accept_certificate(carg0, carg1, carg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCertificate wraps g_tls_connection_get_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_certificate.g_tls_connection_get_certificate.html
//
func (conn *TlsConnectionInstance) GetCertificate() TlsCertificate {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCiphersuiteName wraps g_tls_connection_get_ciphersuite_name
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_ciphersuite_name.g_tls_connection_get_ciphersuite_name.html
//
func (conn *TlsConnectionInstance) GetCiphersuiteName() string {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.gchar          // return, full, string, nullable-string

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_ciphersuite_name(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetDatabase wraps g_tls_connection_get_database
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_database.g_tls_connection_get_database.html
//
func (conn *TlsConnectionInstance) GetDatabase() TlsDatabase {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.GTlsDatabase   // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_database(carg0)
	runtime.KeepAlive(conn)

	var goret TlsDatabase

	if cret != nil {
		goret = UnsafeTlsDatabaseFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetInteraction wraps g_tls_connection_get_interaction
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_interaction.g_tls_connection_get_interaction.html
//
func (conn *TlsConnectionInstance) GetInteraction() TlsInteraction {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsInteraction // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_interaction(carg0)
	runtime.KeepAlive(conn)

	var goret TlsInteraction

	if cret != nil {
		goret = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetNegotiatedProtocol wraps g_tls_connection_get_negotiated_protocol
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_negotiated_protocol.g_tls_connection_get_negotiated_protocol.html
//
func (conn *TlsConnectionInstance) GetNegotiatedProtocol() string {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.gchar          // return, none, string, nullable-string

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_negotiated_protocol(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPeerCertificate wraps g_tls_connection_get_peer_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_peer_certificate.g_tls_connection_get_peer_certificate.html
//
func (conn *TlsConnectionInstance) GetPeerCertificate() TlsCertificate {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_peer_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetPeerCertificateErrors wraps g_tls_connection_get_peer_certificate_errors
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_peer_certificate_errors.g_tls_connection_get_peer_certificate_errors.html
//
func (conn *TlsConnectionInstance) GetPeerCertificateErrors() TlsCertificateFlags {
	var carg0 *C.GTlsConnection      // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_peer_certificate_errors(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// GetProtocolVersion wraps g_tls_connection_get_protocol_version
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_protocol_version.g_tls_connection_get_protocol_version.html
//
func (conn *TlsConnectionInstance) GetProtocolVersion() TlsProtocolVersion {
	var carg0 *C.GTlsConnection     // in, none, converted
	var cret  C.GTlsProtocolVersion // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_protocol_version(carg0)
	runtime.KeepAlive(conn)

	var goret TlsProtocolVersion

	goret = TlsProtocolVersion(cret)

	return goret
}

// GetRehandshakeMode wraps g_tls_connection_get_rehandshake_mode
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_rehandshake_mode.g_tls_connection_get_rehandshake_mode.html
//
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *TlsConnectionInstance) GetRehandshakeMode() TlsRehandshakeMode {
	var carg0 *C.GTlsConnection     // in, none, converted
	var cret  C.GTlsRehandshakeMode // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_rehandshake_mode(carg0)
	runtime.KeepAlive(conn)

	var goret TlsRehandshakeMode

	goret = TlsRehandshakeMode(cret)

	return goret
}

// GetRequireCloseNotify wraps g_tls_connection_get_require_close_notify
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_require_close_notify.g_tls_connection_get_require_close_notify.html
//
func (conn *TlsConnectionInstance) GetRequireCloseNotify() bool {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_require_close_notify(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetUseSystemCertdb wraps g_tls_connection_get_use_system_certdb
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_get_use_system_certdb.g_tls_connection_get_use_system_certdb.html
//
//
// Deprecated: (since 2.30.0) Use g_tls_connection_get_database() instead
func (conn *TlsConnectionInstance) GetUseSystemCertdb() bool {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_use_system_certdb(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Handshake wraps g_tls_connection_handshake
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake.g_tls_connection_handshake.html
//
func (conn *TlsConnectionInstance) Handshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_connection_handshake(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HandshakeAsync wraps g_tls_connection_handshake_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake_async.g_tls_connection_handshake_async.html
//
func (conn *TlsConnectionInstance) HandshakeAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsConnection     // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_connection_handshake_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// HandshakeFinish wraps g_tls_connection_handshake_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_handshake_finish.g_tls_connection_handshake_finish.html
//
func (conn *TlsConnectionInstance) HandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_connection_handshake_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAdvertisedProtocols wraps g_tls_connection_set_advertised_protocols
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_advertised_protocols.g_tls_connection_set_advertised_protocols.html
//
func (conn *TlsConnectionInstance) SetAdvertisedProtocols(protocols []string) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 **C.gchar         // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	_ = protocols
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_tls_connection_set_advertised_protocols(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate wraps g_tls_connection_set_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_certificate.g_tls_connection_set_certificate.html
//
func (conn *TlsConnectionInstance) SetCertificate(certificate TlsCertificate) {
	var carg0 *C.GTlsConnection  // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	C.g_tls_connection_set_certificate(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase wraps g_tls_connection_set_database
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_database.g_tls_connection_set_database.html
//
func (conn *TlsConnectionInstance) SetDatabase(database TlsDatabase) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GTlsDatabase   // in, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_tls_connection_set_database(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction wraps g_tls_connection_set_interaction
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_interaction.g_tls_connection_set_interaction.html
//
func (conn *TlsConnectionInstance) SetInteraction(interaction TlsInteraction) {
	var carg0 *C.GTlsConnection  // in, none, converted
	var carg1 *C.GTlsInteraction // in, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if interaction != nil {
		carg1 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}

	C.g_tls_connection_set_interaction(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode wraps g_tls_connection_set_rehandshake_mode
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_rehandshake_mode.g_tls_connection_set_rehandshake_mode.html
//
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *TlsConnectionInstance) SetRehandshakeMode(mode TlsRehandshakeMode) {
	var carg0 *C.GTlsConnection     // in, none, converted
	var carg1 C.GTlsRehandshakeMode // in, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = C.GTlsRehandshakeMode(mode)

	C.g_tls_connection_set_rehandshake_mode(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify wraps g_tls_connection_set_require_close_notify
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_require_close_notify.g_tls_connection_set_require_close_notify.html
//
func (conn *TlsConnectionInstance) SetRequireCloseNotify(requireCloseNotify bool) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if requireCloseNotify {
		carg1 = C.TRUE
	}

	C.g_tls_connection_set_require_close_notify(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// SetUseSystemCertdb wraps g_tls_connection_set_use_system_certdb
// 
// see also https://docs.gtk.org/gio/method.g_tls_connection_set_use_system_certdb.g_tls_connection_set_use_system_certdb.html
//
//
// Deprecated: (since 2.30.0) Use g_tls_connection_set_database() instead
func (conn *TlsConnectionInstance) SetUseSystemCertdb(useSystemCertdb bool) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if useSystemCertdb {
		carg1 = C.TRUE
	}

	C.g_tls_connection_set_use_system_certdb(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSystemCertdb)
}

// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
// 
// see also https://docs.gtk.org/gio/signal.TlsConnection.accept-certificate.html
//
func (o *TlsConnectionInstance) ConnectAcceptCertificate(fn func(TlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle {
	return o.Connect("accept-certificate", fn)
}

// TlsConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsConnectionOverrides[Instance TlsConnection] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

	// // AcceptCertificate allows you to override the implementation of the virtual method accept_certificate.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.accept_certificate.html
	AcceptCertificate func(Instance, TlsCertificate, TlsCertificateFlags) bool
	// // GetNegotiatedProtocol allows you to override the implementation of the virtual method get_negotiated_protocol.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.get_negotiated_protocol.html
	GetNegotiatedProtocol func(Instance) string
	// // Handshake allows you to override the implementation of the virtual method handshake.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.handshake.html
	Handshake func(Instance, Cancellable) (bool, error)
	// // HandshakeFinish allows you to override the implementation of the virtual method handshake_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsConnection.handshake_finish.html
	HandshakeFinish func(Instance, AsyncResult) (bool, error)
}

// UnsafeApplyTlsConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsConnectionOverrides[Instance TlsConnection](gclass unsafe.Pointer, overrides TlsConnectionOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)

	pclass := (*C.GTlsConnectionClass)(gclass)

	if overrides.AcceptCertificate != nil {
		pclass.accept_certificate = (*[0]byte)(C._goglib_gio2_TlsConnection_accept_certificate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_accept_certificate",
			func(carg0 *C.GTlsConnection, carg1 *C.GTlsCertificate, carg2 C.GTlsCertificateFlags) (cret C.gboolean) {
				var connection Instance            // go GTlsConnection subclass
				var peerCert   TlsCertificate      // in, none, converted
				var errors     TlsCertificateFlags // in, none, casted
				var goret      bool                // return

				connection = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				peerCert = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				errors = TlsCertificateFlags(carg2)

				goret = overrides.AcceptCertificate(connection, peerCert, errors)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetNegotiatedProtocol != nil {
		pclass.get_negotiated_protocol = (*[0]byte)(C._goglib_gio2_TlsConnection_get_negotiated_protocol)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_get_negotiated_protocol",
			func(carg0 *C.GTlsConnection) (cret *C.gchar) {
				var conn  Instance // go GTlsConnection subclass
				var goret string   // return, none, string, nullable-string

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNegotiatedProtocol(conn)

				if goret != "" {
					cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
					defer C.free(unsafe.Pointer(cret))
				}

				return cret
			},
		)
	}

	if overrides.Handshake != nil {
		pclass.handshake = (*[0]byte)(C._goglib_gio2_TlsConnection_handshake)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_handshake",
			func(carg0 *C.GTlsConnection, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var conn        Instance    // go GTlsConnection subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Handshake(conn, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.HandshakeFinish != nil {
		pclass.handshake_finish = (*[0]byte)(C._goglib_gio2_TlsConnection_handshake_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_handshake_finish",
			func(carg0 *C.GTlsConnection, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var conn   Instance    // go GTlsConnection subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.HandshakeFinish(conn, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAcceptCertificate calls the default implementations of the `GTlsConnection.accept_certificate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsConnection.accept_certificate.html
func (connection *TlsConnectionInstance) ParentAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GTlsConnection
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, converted
	var cret  C.gboolean             // return

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(connection)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C._goglib_gio2_TlsConnection_virtual_accept_certificate(unsafe.Pointer(parentclass.accept_certificate), carg0, carg1, carg2)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetNegotiatedProtocol calls the default implementations of the `GTlsConnection.get_negotiated_protocol` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsConnection.get_negotiated_protocol.html
func (conn *TlsConnectionInstance) ParentGetNegotiatedProtocol() string {
	var carg0 *C.GTlsConnection
	var cret  *C.gchar // return, none, string, nullable-string

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C._goglib_gio2_TlsConnection_virtual_get_negotiated_protocol(unsafe.Pointer(parentclass.get_negotiated_protocol), carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ParentHandshake calls the default implementations of the `GTlsConnection.handshake` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsConnection.handshake.html
func (conn *TlsConnectionInstance) ParentHandshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GTlsConnection
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsConnection_virtual_handshake(unsafe.Pointer(parentclass.handshake), carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentHandshakeFinish calls the default implementations of the `GTlsConnection.handshake_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsConnection.handshake_finish.html
func (conn *TlsConnectionInstance) ParentHandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GTlsConnection
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsConnection_virtual_handshake_finish(unsafe.Pointer(parentclass.handshake_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsConnectionSubClass is used to register a go subclass of GTlsConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsConnectionSubClass[InstanceT TlsConnection](
		name string,
		classInit func(class *TlsConnectionClass),
		constructor func() InstanceT,
		overrides TlsConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsConnection,
		UnsafeTlsConnectionClassFromGlibBorrow,
		UnsafeApplyTlsConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsConnection(obj)
		},
		interfaceInits...,
	)
}

// TlsDatabaseInstance is the instance type used by all types extending GTlsDatabase. It is used internally by the bindings. Users should use the interface [TlsDatabase] instead.
type TlsDatabaseInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsDatabase = (*TlsDatabaseInstance)(nil)

// TlsDatabase wraps GTlsDatabase
// 
// see also https://docs.gtk.org/gio/class.TlsDatabase.html
//
type TlsDatabase interface {
	gobject.Object
	upcastToGTlsDatabase() *TlsDatabaseInstance

	// CreateCertificateHandle wraps g_tls_database_create_certificate_handle
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_create_certificate_handle.g_tls_database_create_certificate_handle.html
	//
	CreateCertificateHandle(TlsCertificate) string
	// LookupCertificateForHandle wraps g_tls_database_lookup_certificate_for_handle
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle.g_tls_database_lookup_certificate_for_handle.html
	//
	LookupCertificateForHandle(string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// LookupCertificateForHandleAsync wraps g_tls_database_lookup_certificate_for_handle_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle_async.g_tls_database_lookup_certificate_for_handle_async.html
	//
	LookupCertificateForHandleAsync(string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupCertificateForHandleFinish wraps g_tls_database_lookup_certificate_for_handle_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle_finish.g_tls_database_lookup_certificate_for_handle_finish.html
	//
	LookupCertificateForHandleFinish(AsyncResult) (TlsCertificate, error)
	// LookupCertificateIssuer wraps g_tls_database_lookup_certificate_issuer
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer.g_tls_database_lookup_certificate_issuer.html
	//
	LookupCertificateIssuer(TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// LookupCertificateIssuerAsync wraps g_tls_database_lookup_certificate_issuer_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer_async.g_tls_database_lookup_certificate_issuer_async.html
	//
	LookupCertificateIssuerAsync(TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupCertificateIssuerFinish wraps g_tls_database_lookup_certificate_issuer_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer_finish.g_tls_database_lookup_certificate_issuer_finish.html
	//
	LookupCertificateIssuerFinish(AsyncResult) (TlsCertificate, error)
	// LookupCertificatesIssuedByFinish wraps g_tls_database_lookup_certificates_issued_by_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificates_issued_by_finish.g_tls_database_lookup_certificates_issued_by_finish.html
	//
	LookupCertificatesIssuedByFinish(AsyncResult) ([]TlsCertificate, error)
	// VerifyChain wraps g_tls_database_verify_chain
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain.g_tls_database_verify_chain.html
	//
	VerifyChain(TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable) (TlsCertificateFlags, error)
	// VerifyChainAsync wraps g_tls_database_verify_chain_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain_async.g_tls_database_verify_chain_async.html
	//
	VerifyChainAsync(TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable, AsyncReadyCallback)
	// VerifyChainFinish wraps g_tls_database_verify_chain_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain_finish.g_tls_database_verify_chain_finish.html
	//
	VerifyChainFinish(AsyncResult) (TlsCertificateFlags, error)

	// chain up virtual methods:

	// ParentCreateCertificateHandle calls the default implementations of the `GTlsDatabase.create_certificate_handle` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.create_certificate_handle.html
	ParentCreateCertificateHandle(certificate TlsCertificate) string
	// ParentLookupCertificateForHandle calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle.html
	ParentLookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error)
	// ParentLookupCertificateForHandleFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle_finish.html
	ParentLookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error)
	// ParentLookupCertificateIssuer calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer.html
	ParentLookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error)
	// ParentLookupCertificateIssuerFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer_finish.html
	ParentLookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error)
	// ParentLookupCertificatesIssuedByFinish calls the default implementations of the `GTlsDatabase.lookup_certificates_issued_by_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificates_issued_by_finish.html
	ParentLookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error)
	// ParentVerifyChain calls the default implementations of the `GTlsDatabase.verify_chain` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain.html
	ParentVerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error)
	// ParentVerifyChainFinish calls the default implementations of the `GTlsDatabase.verify_chain_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain_finish.html
	ParentVerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error)
}

func unsafeWrapTlsDatabase(base *gobject.ObjectInstance) *TlsDatabaseInstance {
	return &TlsDatabaseInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsDatabase,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsDatabase(inst)
		},
	)
}

func marshalTlsDatabaseInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsDatabaseFromGlibNone is used to convert raw GTlsDatabase pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibNone(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsDatabase)
}

// UnsafeTlsDatabaseFromGlibFull is used to convert raw GTlsDatabase pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibFull(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsDatabase)
}

// UnsafeTlsDatabaseFromGlibBorrow is used to convert raw GTlsDatabase pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibBorrow(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsDatabase)
}

func (t *TlsDatabaseInstance) upcastToGTlsDatabase() *TlsDatabaseInstance {
	return t
}

// UnsafeTlsDatabaseToGlibNone is used to convert the instance to it's C value GTlsDatabase. This is used by the bindings internally.
func UnsafeTlsDatabaseToGlibNone(c TlsDatabase) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsDatabaseToGlibFull is used to convert the instance to it's C value GTlsDatabase, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseToGlibFull(c TlsDatabase) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// CreateCertificateHandle wraps g_tls_database_create_certificate_handle
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_create_certificate_handle.g_tls_database_create_certificate_handle.html
//
func (self *TlsDatabaseInstance) CreateCertificateHandle(certificate TlsCertificate) string {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	cret = C.g_tls_database_create_certificate_handle(carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// LookupCertificateForHandle wraps g_tls_database_lookup_certificate_for_handle
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle.g_tls_database_lookup_certificate_for_handle.html
//
func (self *TlsDatabaseInstance) LookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.gchar                  // in, none, string
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GTlsCertificate        // return, full, converted, nullable
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_lookup_certificate_for_handle(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateForHandleAsync wraps g_tls_database_lookup_certificate_for_handle_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle_async.g_tls_database_lookup_certificate_for_handle_async.html
//
func (self *TlsDatabaseInstance) LookupCertificateForHandleAsync(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.gchar                  // in, none, string
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback     // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_lookup_certificate_for_handle_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupCertificateForHandleFinish wraps g_tls_database_lookup_certificate_for_handle_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_for_handle_finish.g_tls_database_lookup_certificate_for_handle_finish.html
//
func (self *TlsDatabaseInstance) LookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificate_for_handle_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateIssuer wraps g_tls_database_lookup_certificate_issuer
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer.g_tls_database_lookup_certificate_issuer.html
//
func (self *TlsDatabaseInstance) LookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GTlsCertificate        // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_lookup_certificate_issuer(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateIssuerAsync wraps g_tls_database_lookup_certificate_issuer_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer_async.g_tls_database_lookup_certificate_issuer_async.html
//
func (self *TlsDatabaseInstance) LookupCertificateIssuerAsync(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback     // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_lookup_certificate_issuer_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupCertificateIssuerFinish wraps g_tls_database_lookup_certificate_issuer_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificate_issuer_finish.g_tls_database_lookup_certificate_issuer_finish.html
//
func (self *TlsDatabaseInstance) LookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificate_issuer_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificatesIssuedByFinish wraps g_tls_database_lookup_certificates_issued_by_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_lookup_certificates_issued_by_finish.g_tls_database_lookup_certificates_issued_by_finish.html
//
func (self *TlsDatabaseInstance) LookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error) {
	var carg0 *C.GTlsDatabase // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificates_issued_by_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VerifyChain wraps g_tls_database_verify_chain
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain.g_tls_database_verify_chain.html
//
func (self *TlsDatabaseInstance) VerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, string
	var carg3 *C.GSocketConnectable     // in, none, converted, nullable
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, casted
	var carg6 *C.GCancellable           // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags    // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_verify_chain(carg0, carg1, carg2, carg3, carg4, carg5, carg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VerifyChainAsync wraps g_tls_database_verify_chain_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain_async.g_tls_database_verify_chain_async.html
//
func (self *TlsDatabaseInstance) VerifyChainAsync(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, string
	var carg3 *C.GSocketConnectable     // in, none, converted, nullable
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, casted
	var carg6 *C.GCancellable           // in, none, converted, nullable
	var carg7 C.GAsyncReadyCallback     // callback, scope: async, closure: carg8, nullable
	var carg8 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg7 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg8 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_verify_chain_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// VerifyChainFinish wraps g_tls_database_verify_chain_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_database_verify_chain_finish.g_tls_database_verify_chain_finish.html
//
func (self *TlsDatabaseInstance) VerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase        // in, none, converted
	var carg1 *C.GAsyncResult        // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_verify_chain_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsDatabaseOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsDatabaseOverrides[Instance TlsDatabase] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CreateCertificateHandle allows you to override the implementation of the virtual method create_certificate_handle.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.create_certificate_handle.html
	CreateCertificateHandle func(Instance, TlsCertificate) string
	// // LookupCertificateForHandle allows you to override the implementation of the virtual method lookup_certificate_for_handle.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle.html
	LookupCertificateForHandle func(Instance, string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// // LookupCertificateForHandleFinish allows you to override the implementation of the virtual method lookup_certificate_for_handle_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle_finish.html
	LookupCertificateForHandleFinish func(Instance, AsyncResult) (TlsCertificate, error)
	// // LookupCertificateIssuer allows you to override the implementation of the virtual method lookup_certificate_issuer.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer.html
	LookupCertificateIssuer func(Instance, TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// // LookupCertificateIssuerFinish allows you to override the implementation of the virtual method lookup_certificate_issuer_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer_finish.html
	LookupCertificateIssuerFinish func(Instance, AsyncResult) (TlsCertificate, error)
	// // LookupCertificatesIssuedByFinish allows you to override the implementation of the virtual method lookup_certificates_issued_by_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificates_issued_by_finish.html
	LookupCertificatesIssuedByFinish func(Instance, AsyncResult) ([]TlsCertificate, error)
	// // VerifyChain allows you to override the implementation of the virtual method verify_chain.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain.html
	VerifyChain func(Instance, TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable) (TlsCertificateFlags, error)
	// // VerifyChainFinish allows you to override the implementation of the virtual method verify_chain_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain_finish.html
	VerifyChainFinish func(Instance, AsyncResult) (TlsCertificateFlags, error)
}

// UnsafeApplyTlsDatabaseOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsDatabaseOverrides[Instance TlsDatabase](gclass unsafe.Pointer, overrides TlsDatabaseOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsDatabaseClass)(gclass)

	if overrides.CreateCertificateHandle != nil {
		pclass.create_certificate_handle = (*[0]byte)(C._goglib_gio2_TlsDatabase_create_certificate_handle)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_create_certificate_handle",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate) (cret *C.gchar) {
				var self        Instance       // go GTlsDatabase subclass
				var certificate TlsCertificate // in, none, converted
				var goret       string         // return, full, string, nullable-string

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				certificate = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.CreateCertificateHandle(self, certificate)

				if goret != "" {
					cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.LookupCertificateForHandle != nil {
		pclass.lookup_certificate_for_handle = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_for_handle)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_for_handle",
			func(carg0 *C.GTlsDatabase, carg1 *C.gchar, carg2 *C.GTlsInteraction, carg3 C.GTlsDatabaseLookupFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self        Instance               // go GTlsDatabase subclass
				var handle      string                 // in, none, string
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseLookupFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificate         // return, full, converted, nullable
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				handle = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg2))
				}
				flags = TlsDatabaseLookupFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LookupCertificateForHandle(self, handle, interaction, flags, cancellable)

				if goret != nil {
					cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateForHandleFinish != nil {
		pclass.lookup_certificate_for_handle_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self   Instance       // go GTlsDatabase subclass
				var result AsyncResult    // in, none, converted
				var goret  TlsCertificate // return, full, converted
				var _goerr error          // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificateForHandleFinish(self, result)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateIssuer != nil {
		pclass.lookup_certificate_issuer = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_issuer)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_issuer",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate, carg2 *C.GTlsInteraction, carg3 C.GTlsDatabaseLookupFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self        Instance               // go GTlsDatabase subclass
				var certificate TlsCertificate         // in, none, converted
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseLookupFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificate         // return, full, converted
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				certificate = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg2))
				}
				flags = TlsDatabaseLookupFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LookupCertificateIssuer(self, certificate, interaction, flags, cancellable)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateIssuerFinish != nil {
		pclass.lookup_certificate_issuer_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self   Instance       // go GTlsDatabase subclass
				var result AsyncResult    // in, none, converted
				var goret  TlsCertificate // return, full, converted
				var _goerr error          // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificateIssuerFinish(self, result)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificatesIssuedByFinish != nil {
		pclass.lookup_certificates_issued_by_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var self   Instance         // go GTlsDatabase subclass
				var result AsyncResult      // in, none, converted
				var goret  []TlsCertificate // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr error            // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificatesIssuedByFinish(self, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []TlsCertificate (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.VerifyChain != nil {
		pclass.verify_chain = (*[0]byte)(C._goglib_gio2_TlsDatabase_verify_chain)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_verify_chain",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate, carg2 *C.gchar, carg3 *C.GSocketConnectable, carg4 *C.GTlsInteraction, carg5 C.GTlsDatabaseVerifyFlags, carg6 *C.GCancellable, _cerr **C.GError) (cret C.GTlsCertificateFlags) {
				var self        Instance               // go GTlsDatabase subclass
				var chain       TlsCertificate         // in, none, converted
				var purpose     string                 // in, none, string
				var identity    SocketConnectable      // in, none, converted, nullable
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseVerifyFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificateFlags    // return, none, casted
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				chain = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				purpose = C.GoString((*C.char)(unsafe.Pointer(carg2)))
				if carg3 != nil {
					identity = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg3))
				}
				if carg4 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg4))
				}
				flags = TlsDatabaseVerifyFlags(carg5)
				if carg6 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg6))
				}

				goret, _goerr = overrides.VerifyChain(self, chain, purpose, identity, interaction, flags, cancellable)

				cret = C.GTlsCertificateFlags(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.VerifyChainFinish != nil {
		pclass.verify_chain_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_verify_chain_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_verify_chain_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsCertificateFlags) {
				var self   Instance            // go GTlsDatabase subclass
				var result AsyncResult         // in, none, converted
				var goret  TlsCertificateFlags // return, none, casted
				var _goerr error               // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.VerifyChainFinish(self, result)

				cret = C.GTlsCertificateFlags(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCreateCertificateHandle calls the default implementations of the `GTlsDatabase.create_certificate_handle` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.create_certificate_handle.html
func (self *TlsDatabaseInstance) ParentCreateCertificateHandle(certificate TlsCertificate) string {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	cret = C._goglib_gio2_TlsDatabase_virtual_create_certificate_handle(unsafe.Pointer(parentclass.create_certificate_handle), carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentLookupCertificateForHandle calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle.html
func (self *TlsDatabaseInstance) ParentLookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.gchar                  // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, string
	var carg3 C.GTlsDatabaseLookupFlags // in, none, converted, nullable
	var carg4 *C.GCancellable           // in, none, casted
	var cret  *C.GTlsCertificate        // return, full, converted, nullable
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle(unsafe.Pointer(parentclass.lookup_certificate_for_handle), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateForHandleFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_for_handle_finish.html
func (self *TlsDatabaseInstance) ParentLookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle_finish(unsafe.Pointer(parentclass.lookup_certificate_for_handle_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateIssuer calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer.html
func (self *TlsDatabaseInstance) ParentLookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted
	var carg3 C.GTlsDatabaseLookupFlags // in, none, converted, nullable
	var carg4 *C.GCancellable           // in, none, casted
	var cret  *C.GTlsCertificate        // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer(unsafe.Pointer(parentclass.lookup_certificate_issuer), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateIssuerFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificate_issuer_finish.html
func (self *TlsDatabaseInstance) ParentLookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer_finish(unsafe.Pointer(parentclass.lookup_certificate_issuer_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificatesIssuedByFinish calls the default implementations of the `GTlsDatabase.lookup_certificates_issued_by_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.lookup_certificates_issued_by_finish.html
func (self *TlsDatabaseInstance) ParentLookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificates_issued_by_finish(unsafe.Pointer(parentclass.lookup_certificates_issued_by_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentVerifyChain calls the default implementations of the `GTlsDatabase.verify_chain` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain.html
func (self *TlsDatabaseInstance) ParentVerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, converted
	var carg3 *C.GSocketConnectable     // in, none, string
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, converted, nullable
	var carg6 *C.GCancellable           // in, none, casted
	var cret  C.GTlsCertificateFlags    // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_verify_chain(unsafe.Pointer(parentclass.verify_chain), carg0, carg1, carg2, carg3, carg4, carg5, carg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentVerifyChainFinish calls the default implementations of the `GTlsDatabase.verify_chain_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsDatabase.verify_chain_finish.html
func (self *TlsDatabaseInstance) ParentVerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult        // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted
	var _cerr *C.GError              // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_verify_chain_finish(unsafe.Pointer(parentclass.verify_chain_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsDatabaseSubClass is used to register a go subclass of GTlsDatabase. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsDatabaseSubClass[InstanceT TlsDatabase](
		name string,
		classInit func(class *TlsDatabaseClass),
		constructor func() InstanceT,
		overrides TlsDatabaseOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsDatabase,
		UnsafeTlsDatabaseClassFromGlibBorrow,
		UnsafeApplyTlsDatabaseOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsDatabase(obj)
		},
		interfaceInits...,
	)
}

// TlsInteractionInstance is the instance type used by all types extending GTlsInteraction. It is used internally by the bindings. Users should use the interface [TlsInteraction] instead.
type TlsInteractionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsInteraction = (*TlsInteractionInstance)(nil)

// TlsInteraction wraps GTlsInteraction
// 
// see also https://docs.gtk.org/gio/class.TlsInteraction.html
//
type TlsInteraction interface {
	gobject.Object
	upcastToGTlsInteraction() *TlsInteractionInstance

	// AskPassword wraps g_tls_interaction_ask_password
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password.g_tls_interaction_ask_password.html
	//
	AskPassword(TlsPassword, Cancellable) (TlsInteractionResult, error)
	// AskPasswordAsync wraps g_tls_interaction_ask_password_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password_async.g_tls_interaction_ask_password_async.html
	//
	AskPasswordAsync(TlsPassword, Cancellable, AsyncReadyCallback)
	// AskPasswordFinish wraps g_tls_interaction_ask_password_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password_finish.g_tls_interaction_ask_password_finish.html
	//
	AskPasswordFinish(AsyncResult) (TlsInteractionResult, error)
	// InvokeAskPassword wraps g_tls_interaction_invoke_ask_password
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_invoke_ask_password.g_tls_interaction_invoke_ask_password.html
	//
	InvokeAskPassword(TlsPassword, Cancellable) (TlsInteractionResult, error)
	// InvokeRequestCertificate wraps g_tls_interaction_invoke_request_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_invoke_request_certificate.g_tls_interaction_invoke_request_certificate.html
	//
	InvokeRequestCertificate(TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// RequestCertificate wraps g_tls_interaction_request_certificate
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate.g_tls_interaction_request_certificate.html
	//
	RequestCertificate(TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// RequestCertificateAsync wraps g_tls_interaction_request_certificate_async
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate_async.g_tls_interaction_request_certificate_async.html
	//
	RequestCertificateAsync(TlsConnection, TlsCertificateRequestFlags, Cancellable, AsyncReadyCallback)
	// RequestCertificateFinish wraps g_tls_interaction_request_certificate_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate_finish.g_tls_interaction_request_certificate_finish.html
	//
	RequestCertificateFinish(AsyncResult) (TlsInteractionResult, error)

	// chain up virtual methods:

	// ParentAskPassword calls the default implementations of the `GTlsInteraction.ask_password` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password.html
	ParentAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error)
	// ParentAskPasswordFinish calls the default implementations of the `GTlsInteraction.ask_password_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password_finish.html
	ParentAskPasswordFinish(result AsyncResult) (TlsInteractionResult, error)
	// ParentRequestCertificate calls the default implementations of the `GTlsInteraction.request_certificate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate.html
	ParentRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error)
	// ParentRequestCertificateFinish calls the default implementations of the `GTlsInteraction.request_certificate_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate_finish.html
	ParentRequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error)
}

func unsafeWrapTlsInteraction(base *gobject.ObjectInstance) *TlsInteractionInstance {
	return &TlsInteractionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsInteraction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsInteraction(inst)
		},
	)
}

func marshalTlsInteractionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsInteractionFromGlibNone is used to convert raw GTlsInteraction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibNone(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsInteraction)
}

// UnsafeTlsInteractionFromGlibFull is used to convert raw GTlsInteraction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibFull(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsInteraction)
}

// UnsafeTlsInteractionFromGlibBorrow is used to convert raw GTlsInteraction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibBorrow(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsInteraction)
}

func (t *TlsInteractionInstance) upcastToGTlsInteraction() *TlsInteractionInstance {
	return t
}

// UnsafeTlsInteractionToGlibNone is used to convert the instance to it's C value GTlsInteraction. This is used by the bindings internally.
func UnsafeTlsInteractionToGlibNone(c TlsInteraction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsInteractionToGlibFull is used to convert the instance to it's C value GTlsInteraction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionToGlibFull(c TlsInteraction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// AskPassword wraps g_tls_interaction_ask_password
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password.g_tls_interaction_ask_password.html
//
func (interaction *TlsInteractionInstance) AskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_ask_password(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AskPasswordAsync wraps g_tls_interaction_ask_password_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password_async.g_tls_interaction_ask_password_async.html
//
func (interaction *TlsInteractionInstance) AskPasswordAsync(password TlsPassword, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsInteraction    // in, none, converted
	var carg1 *C.GTlsPassword       // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_interaction_ask_password_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AskPasswordFinish wraps g_tls_interaction_ask_password_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_ask_password_finish.g_tls_interaction_ask_password_finish.html
//
func (interaction *TlsInteractionInstance) AskPasswordFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_interaction_ask_password_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InvokeAskPassword wraps g_tls_interaction_invoke_ask_password
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_invoke_ask_password.g_tls_interaction_invoke_ask_password.html
//
func (interaction *TlsInteractionInstance) InvokeAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_invoke_ask_password(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InvokeRequestCertificate wraps g_tls_interaction_invoke_request_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_invoke_request_certificate.g_tls_interaction_invoke_request_certificate.html
//
func (interaction *TlsInteractionInstance) InvokeRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_invoke_request_certificate(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RequestCertificate wraps g_tls_interaction_request_certificate
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate.g_tls_interaction_request_certificate.html
//
func (interaction *TlsInteractionInstance) RequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_request_certificate(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RequestCertificateAsync wraps g_tls_interaction_request_certificate_async
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate_async.g_tls_interaction_request_certificate_async.html
//
func (interaction *TlsInteractionInstance) RequestCertificateAsync(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback         // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer                    // implicit

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_interaction_request_certificate_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// RequestCertificateFinish wraps g_tls_interaction_request_certificate_finish
// 
// see also https://docs.gtk.org/gio/method.g_tls_interaction_request_certificate_finish.g_tls_interaction_request_certificate_finish.html
//
func (interaction *TlsInteractionInstance) RequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_interaction_request_certificate_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsInteractionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsInteractionOverrides[Instance TlsInteraction] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // AskPassword allows you to override the implementation of the virtual method ask_password.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password.html
	AskPassword func(Instance, TlsPassword, Cancellable) (TlsInteractionResult, error)
	// // AskPasswordFinish allows you to override the implementation of the virtual method ask_password_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password_finish.html
	AskPasswordFinish func(Instance, AsyncResult) (TlsInteractionResult, error)
	// // RequestCertificate allows you to override the implementation of the virtual method request_certificate.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate.html
	RequestCertificate func(Instance, TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// // RequestCertificateFinish allows you to override the implementation of the virtual method request_certificate_finish.
	// 
	// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate_finish.html
	RequestCertificateFinish func(Instance, AsyncResult) (TlsInteractionResult, error)
}

// UnsafeApplyTlsInteractionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsInteractionOverrides[Instance TlsInteraction](gclass unsafe.Pointer, overrides TlsInteractionOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsInteractionClass)(gclass)

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._goglib_gio2_TlsInteraction_ask_password)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_ask_password",
			func(carg0 *C.GTlsInteraction, carg1 *C.GTlsPassword, carg2 *C.GCancellable, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var password    TlsPassword          // in, none, converted
				var cancellable Cancellable          // in, none, converted, nullable
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				password = UnsafeTlsPasswordFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.AskPassword(interaction, password, cancellable)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.AskPasswordFinish != nil {
		pclass.ask_password_finish = (*[0]byte)(C._goglib_gio2_TlsInteraction_ask_password_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_ask_password_finish",
			func(carg0 *C.GTlsInteraction, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var result      AsyncResult          // in, none, converted
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.AskPasswordFinish(interaction, result)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.RequestCertificate != nil {
		pclass.request_certificate = (*[0]byte)(C._goglib_gio2_TlsInteraction_request_certificate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_request_certificate",
			func(carg0 *C.GTlsInteraction, carg1 *C.GTlsConnection, carg2 C.GTlsCertificateRequestFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance                   // go GTlsInteraction subclass
				var connection  TlsConnection              // in, none, converted
				var flags       TlsCertificateRequestFlags // in, none, casted
				var cancellable Cancellable                // in, none, converted, nullable
				var goret       TlsInteractionResult       // return, none, casted
				var _goerr      error                      // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeTlsConnectionFromGlibNone(unsafe.Pointer(carg1))
				flags = TlsCertificateRequestFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.RequestCertificate(interaction, connection, flags, cancellable)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.RequestCertificateFinish != nil {
		pclass.request_certificate_finish = (*[0]byte)(C._goglib_gio2_TlsInteraction_request_certificate_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_request_certificate_finish",
			func(carg0 *C.GTlsInteraction, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var result      AsyncResult          // in, none, converted
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.RequestCertificateFinish(interaction, result)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAskPassword calls the default implementations of the `GTlsInteraction.ask_password` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password.html
func (interaction *TlsInteractionInstance) ParentAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsInteraction_virtual_ask_password(unsafe.Pointer(parentclass.ask_password), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentAskPasswordFinish calls the default implementations of the `GTlsInteraction.ask_password_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsInteraction.ask_password_finish.html
func (interaction *TlsInteractionInstance) ParentAskPasswordFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsInteraction_virtual_ask_password_finish(unsafe.Pointer(parentclass.ask_password_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRequestCertificate calls the default implementations of the `GTlsInteraction.request_certificate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate.html
func (interaction *TlsInteractionInstance) ParentRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, converted
	var carg3 *C.GCancellable               // in, none, casted
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsInteraction_virtual_request_certificate(unsafe.Pointer(parentclass.request_certificate), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRequestCertificateFinish calls the default implementations of the `GTlsInteraction.request_certificate_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsInteraction.request_certificate_finish.html
func (interaction *TlsInteractionInstance) ParentRequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsInteraction_virtual_request_certificate_finish(unsafe.Pointer(parentclass.request_certificate_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsInteractionSubClass is used to register a go subclass of GTlsInteraction. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsInteractionSubClass[InstanceT TlsInteraction](
		name string,
		classInit func(class *TlsInteractionClass),
		constructor func() InstanceT,
		overrides TlsInteractionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsInteraction,
		UnsafeTlsInteractionClassFromGlibBorrow,
		UnsafeApplyTlsInteractionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsInteraction(obj)
		},
		interfaceInits...,
	)
}

// TlsPasswordInstance is the instance type used by all types extending GTlsPassword. It is used internally by the bindings. Users should use the interface [TlsPassword] instead.
type TlsPasswordInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsPassword = (*TlsPasswordInstance)(nil)

// TlsPassword wraps GTlsPassword
// 
// see also https://docs.gtk.org/gio/class.TlsPassword.html
//
type TlsPassword interface {
	gobject.Object
	upcastToGTlsPassword() *TlsPasswordInstance

	// GetDescription wraps g_tls_password_get_description
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_get_description.g_tls_password_get_description.html
	//
	GetDescription() string
	// GetFlags wraps g_tls_password_get_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_get_flags.g_tls_password_get_flags.html
	//
	GetFlags() TlsPasswordFlags
	// GetValue wraps g_tls_password_get_value
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_get_value.g_tls_password_get_value.html
	//
	GetValue() (uint, []byte)
	// GetWarning wraps g_tls_password_get_warning
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_get_warning.g_tls_password_get_warning.html
	//
	GetWarning() string
	// SetDescription wraps g_tls_password_set_description
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_set_description.g_tls_password_set_description.html
	//
	SetDescription(string)
	// SetFlags wraps g_tls_password_set_flags
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_set_flags.g_tls_password_set_flags.html
	//
	SetFlags(TlsPasswordFlags)
	// SetValue wraps g_tls_password_set_value
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_set_value.g_tls_password_set_value.html
	//
	SetValue([]byte)
	// SetWarning wraps g_tls_password_set_warning
	// 
	// see also https://docs.gtk.org/gio/method.g_tls_password_set_warning.g_tls_password_set_warning.html
	//
	SetWarning(string)

	// chain up virtual methods:

	// ParentGetDefaultWarning calls the default implementations of the `GTlsPassword.get_default_warning` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsPassword.get_default_warning.html
	ParentGetDefaultWarning() string
	// ParentGetValue calls the default implementations of the `GTlsPassword.get_value` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.TlsPassword.get_value.html
	ParentGetValue() (uint, []byte)
}

func unsafeWrapTlsPassword(base *gobject.ObjectInstance) *TlsPasswordInstance {
	return &TlsPasswordInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsPassword,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsPassword(inst)
		},
	)
}

func marshalTlsPasswordInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsPasswordFromGlibNone is used to convert raw GTlsPassword pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibNone(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsPassword)
}

// UnsafeTlsPasswordFromGlibFull is used to convert raw GTlsPassword pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibFull(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsPassword)
}

// UnsafeTlsPasswordFromGlibBorrow is used to convert raw GTlsPassword pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibBorrow(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsPassword)
}

func (t *TlsPasswordInstance) upcastToGTlsPassword() *TlsPasswordInstance {
	return t
}

// UnsafeTlsPasswordToGlibNone is used to convert the instance to it's C value GTlsPassword. This is used by the bindings internally.
func UnsafeTlsPasswordToGlibNone(c TlsPassword) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsPasswordToGlibFull is used to convert the instance to it's C value GTlsPassword, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordToGlibFull(c TlsPassword) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTlsPassword wraps g_tls_password_new
// 
// see also https://docs.gtk.org/gio/func.g_tls_password_new.html
//
func NewTlsPassword(flags TlsPasswordFlags, description string) TlsPassword {
	var carg1 C.GTlsPasswordFlags // in, none, casted
	var carg2 *C.gchar            // in, none, string
	var cret  *C.GTlsPassword     // return, full, converted

	carg1 = C.GTlsPasswordFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_password_new(carg1, carg2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(description)

	var goret TlsPassword

	goret = UnsafeTlsPasswordFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDescription wraps g_tls_password_get_description
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_get_description.g_tls_password_get_description.html
//
func (password *TlsPasswordInstance) GetDescription() string {
	var carg0 *C.GTlsPassword // in, none, converted
	var cret  *C.gchar        // return, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_description(carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetFlags wraps g_tls_password_get_flags
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_get_flags.g_tls_password_get_flags.html
//
func (password *TlsPasswordInstance) GetFlags() TlsPasswordFlags {
	var carg0 *C.GTlsPassword     // in, none, converted
	var cret  C.GTlsPasswordFlags // return, none, casted

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_flags(carg0)
	runtime.KeepAlive(password)

	var goret TlsPasswordFlags

	goret = TlsPasswordFlags(cret)

	return goret
}

// GetValue wraps g_tls_password_get_value
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_get_value.g_tls_password_get_value.html
//
func (password *TlsPasswordInstance) GetValue() (uint, []byte) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 C.gsize         // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
	var cret  *C.guchar       // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_value(carg0, &carg1)
	runtime.KeepAlive(password)

	var length uint
	var goret  []byte

	_ = length
	_ = carg1
	panic("unimplemented conversion of uint (gsize) because of unknown reason")
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (const guchar*) because of unknown reason")

	return length, goret
}

// GetWarning wraps g_tls_password_get_warning
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_get_warning.g_tls_password_get_warning.html
//
func (password *TlsPasswordInstance) GetWarning() string {
	var carg0 *C.GTlsPassword // in, none, converted
	var cret  *C.gchar        // return, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_warning(carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetDescription wraps g_tls_password_set_description
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_set_description.g_tls_password_set_description.html
//
func (password *TlsPasswordInstance) SetDescription(description string) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_tls_password_set_description(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(description)
}

// SetFlags wraps g_tls_password_set_flags
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_set_flags.g_tls_password_set_flags.html
//
func (password *TlsPasswordInstance) SetFlags(flags TlsPasswordFlags) {
	var carg0 *C.GTlsPassword     // in, none, converted
	var carg1 C.GTlsPasswordFlags // in, none, casted

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = C.GTlsPasswordFlags(flags)

	C.g_tls_password_set_flags(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(flags)
}

// SetValue wraps g_tls_password_set_value
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_set_value.g_tls_password_set_value.html
//
func (password *TlsPasswordInstance) SetValue(value []byte) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize        // implicit

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	_ = value
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	C.g_tls_password_set_value(carg0, carg1, carg2)
	runtime.KeepAlive(password)
	runtime.KeepAlive(value)
}

// SetWarning wraps g_tls_password_set_warning
// 
// see also https://docs.gtk.org/gio/method.g_tls_password_set_warning.g_tls_password_set_warning.html
//
func (password *TlsPasswordInstance) SetWarning(warning string) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(warning)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_tls_password_set_warning(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(warning)
}

// TlsPasswordOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsPasswordOverrides[Instance TlsPassword] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetDefaultWarning allows you to override the implementation of the virtual method get_default_warning.
	// 
	// see also https://docs.gtk.org/gio/method.TlsPassword.get_default_warning.html
	GetDefaultWarning func(Instance) string
	// // GetValue allows you to override the implementation of the virtual method get_value.
	// 
	// see also https://docs.gtk.org/gio/method.TlsPassword.get_value.html
	GetValue func(Instance) (uint, []byte)
}

// UnsafeApplyTlsPasswordOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsPasswordOverrides[Instance TlsPassword](gclass unsafe.Pointer, overrides TlsPasswordOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsPasswordClass)(gclass)

	if overrides.GetDefaultWarning != nil {
		pclass.get_default_warning = (*[0]byte)(C._goglib_gio2_TlsPassword_get_default_warning)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsPassword_get_default_warning",
			func(carg0 *C.GTlsPassword) (cret *C.gchar) {
				var password Instance // go GTlsPassword subclass
				var goret    string   // return, none, string

				password = UnsafeTlsPasswordFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetDefaultWarning(password)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				defer C.free(unsafe.Pointer(cret))

				return cret
			},
		)
	}

	if overrides.GetValue != nil {
		pclass.get_value = (*[0]byte)(C._goglib_gio2_TlsPassword_get_value)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsPassword_get_value",
			func(carg0 *C.GTlsPassword, carg1 *C.gsize) (cret *C.guchar) {
				var password Instance // go GTlsPassword subclass
				var length   uint     // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
				var goret    []byte   // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

				password = UnsafeTlsPasswordFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				length, goret = overrides.GetValue(password)

				_ = length
				_ = carg1
				panic("unimplemented conversion of uint (gsize) because of caller-allocates not implemented")
				_ = goret
				_ = cret
				panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

				return cret
			},
		)
	}
}

// ParentGetDefaultWarning calls the default implementations of the `GTlsPassword.get_default_warning` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsPassword.get_default_warning.html
func (password *TlsPasswordInstance) ParentGetDefaultWarning() string {
	var carg0 *C.GTlsPassword
	var cret  *C.gchar // return, none, string

	parentclass := (*C.GTlsPasswordClass)(classdata.PeekParentClass(UnsafeTlsPasswordToGlibNone(password)))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C._goglib_gio2_TlsPassword_virtual_get_default_warning(unsafe.Pointer(parentclass.get_default_warning), carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// ParentGetValue calls the default implementations of the `GTlsPassword.get_value` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.TlsPassword.get_value.html
func (password *TlsPasswordInstance) ParentGetValue() (uint, []byte) {
	var carg0 *C.GTlsPassword
	var carg1 C.gsize   // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
	var cret  *C.guchar // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

	parentclass := (*C.GTlsPasswordClass)(classdata.PeekParentClass(UnsafeTlsPasswordToGlibNone(password)))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C._goglib_gio2_TlsPassword_virtual_get_value(unsafe.Pointer(parentclass.get_value), carg0, &carg1)
	runtime.KeepAlive(password)

	var length uint
	var goret  []byte

	_ = length
	_ = carg1
	panic("unimplemented conversion of uint (gsize) because of unknown reason")
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (const guchar*) because of unknown reason")

	return length, goret
}

// RegisterTlsPasswordSubClass is used to register a go subclass of GTlsPassword. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsPasswordSubClass[InstanceT TlsPassword](
		name string,
		classInit func(class *TlsPasswordClass),
		constructor func() InstanceT,
		overrides TlsPasswordOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsPassword,
		UnsafeTlsPasswordClassFromGlibBorrow,
		UnsafeApplyTlsPasswordOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsPassword(obj)
		},
		interfaceInits...,
	)
}

// VfsInstance is the instance type used by all types extending GVfs. It is used internally by the bindings. Users should use the interface [Vfs] instead.
type VfsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Vfs = (*VfsInstance)(nil)

// Vfs wraps GVfs
// 
// see also https://docs.gtk.org/gio/class.Vfs.html
//
type Vfs interface {
	gobject.Object
	upcastToGVfs() *VfsInstance

	// GetFileForPath wraps g_vfs_get_file_for_path
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_get_file_for_path.g_vfs_get_file_for_path.html
	//
	GetFileForPath(string) File
	// GetFileForURI wraps g_vfs_get_file_for_uri
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_get_file_for_uri.g_vfs_get_file_for_uri.html
	//
	GetFileForURI(string) File
	// GetSupportedURISchemes wraps g_vfs_get_supported_uri_schemes
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_get_supported_uri_schemes.g_vfs_get_supported_uri_schemes.html
	//
	GetSupportedURISchemes() []string
	// IsActive wraps g_vfs_is_active
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_is_active.g_vfs_is_active.html
	//
	IsActive() bool
	// ParseName wraps g_vfs_parse_name
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_parse_name.g_vfs_parse_name.html
	//
	ParseName(string) File
	// RegisterURIScheme wraps g_vfs_register_uri_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_register_uri_scheme.g_vfs_register_uri_scheme.html
	//
	RegisterURIScheme(string, VfsFileLookupFunc, VfsFileLookupFunc) bool
	// UnregisterURIScheme wraps g_vfs_unregister_uri_scheme
	// 
	// see also https://docs.gtk.org/gio/method.g_vfs_unregister_uri_scheme.g_vfs_unregister_uri_scheme.html
	//
	UnregisterURIScheme(string) bool

	// chain up virtual methods:

	// ParentAddWritableNamespaces calls the default implementations of the `GVfs.add_writable_namespaces` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.add_writable_namespaces.html
	ParentAddWritableNamespaces(list *FileAttributeInfoList)
	// ParentGetFileForPath calls the default implementations of the `GVfs.get_file_for_path` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_path.html
	ParentGetFileForPath(path string) File
	// ParentGetFileForURI calls the default implementations of the `GVfs.get_file_for_uri` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_uri.html
	ParentGetFileForURI(uri string) File
	// ParentGetSupportedURISchemes calls the default implementations of the `GVfs.get_supported_uri_schemes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_supported_uri_schemes.html
	ParentGetSupportedURISchemes() []string
	// ParentIsActive calls the default implementations of the `GVfs.is_active` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.is_active.html
	ParentIsActive() bool
	// ParentLocalFileMoved calls the default implementations of the `GVfs.local_file_moved` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_moved.html
	ParentLocalFileMoved(source string, dest string)
	// ParentLocalFileRemoved calls the default implementations of the `GVfs.local_file_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_removed.html
	ParentLocalFileRemoved(filename string)
	// ParentLocalFileSetAttributes calls the default implementations of the `GVfs.local_file_set_attributes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_set_attributes.html
	ParentLocalFileSetAttributes(filename string, info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error)
	// ParentParseName calls the default implementations of the `GVfs.parse_name` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.parse_name.html
	ParentParseName(parseName string) File
}

func unsafeWrapVfs(base *gobject.ObjectInstance) *VfsInstance {
	return &VfsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeVfs,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVfs(inst)
		},
	)
}

func marshalVfsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeVfsFromGlibNone is used to convert raw GVfs pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVfsFromGlibNone(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibNone(c).(Vfs)
}

// UnsafeVfsFromGlibFull is used to convert raw GVfs pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVfsFromGlibFull(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibFull(c).(Vfs)
}

// UnsafeVfsFromGlibBorrow is used to convert raw GVfs pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVfsFromGlibBorrow(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Vfs)
}

func (v *VfsInstance) upcastToGVfs() *VfsInstance {
	return v
}

// UnsafeVfsToGlibNone is used to convert the instance to it's C value GVfs. This is used by the bindings internally.
func UnsafeVfsToGlibNone(c Vfs) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeVfsToGlibFull is used to convert the instance to it's C value GVfs, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVfsToGlibFull(c Vfs) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// VfsGetDefault wraps g_vfs_get_default
// 
// see also https://docs.gtk.org/gio/func.g_vfs_get_default.html
//
func VfsGetDefault() Vfs {
	var cret *C.GVfs // return, none, converted

	cret = C.g_vfs_get_default()

	var goret Vfs

	goret = UnsafeVfsFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// VfsGetLocal wraps g_vfs_get_local
// 
// see also https://docs.gtk.org/gio/func.g_vfs_get_local.html
//
func VfsGetLocal() Vfs {
	var cret *C.GVfs // return, none, converted

	cret = C.g_vfs_get_local()

	var goret Vfs

	goret = UnsafeVfsFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFileForPath wraps g_vfs_get_file_for_path
// 
// see also https://docs.gtk.org/gio/method.g_vfs_get_file_for_path.g_vfs_get_file_for_path.html
//
func (vfs *VfsInstance) GetFileForPath(path string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_get_file_for_path(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFileForURI wraps g_vfs_get_file_for_uri
// 
// see also https://docs.gtk.org/gio/method.g_vfs_get_file_for_uri.g_vfs_get_file_for_uri.html
//
func (vfs *VfsInstance) GetFileForURI(uri string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_get_file_for_uri(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetSupportedURISchemes wraps g_vfs_get_supported_uri_schemes
// 
// see also https://docs.gtk.org/gio/method.g_vfs_get_supported_uri_schemes.g_vfs_get_supported_uri_schemes.html
//
func (vfs *VfsInstance) GetSupportedURISchemes() []string {
	var carg0 *C.GVfs   // in, none, converted
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C.g_vfs_get_supported_uri_schemes(carg0)
	runtime.KeepAlive(vfs)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// IsActive wraps g_vfs_is_active
// 
// see also https://docs.gtk.org/gio/method.g_vfs_is_active.g_vfs_is_active.html
//
func (vfs *VfsInstance) IsActive() bool {
	var carg0 *C.GVfs    // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C.g_vfs_is_active(carg0)
	runtime.KeepAlive(vfs)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParseName wraps g_vfs_parse_name
// 
// see also https://docs.gtk.org/gio/method.g_vfs_parse_name.g_vfs_parse_name.html
//
func (vfs *VfsInstance) ParseName(parseName string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_parse_name(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterURIScheme wraps g_vfs_register_uri_scheme
// 
// see also https://docs.gtk.org/gio/method.g_vfs_register_uri_scheme.g_vfs_register_uri_scheme.html
//
func (vfs *VfsInstance) RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool {
	var carg0 *C.GVfs              // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 C.GVfsFileLookupFunc // callback, scope: notified, closure: carg3, destroy: carg4, nullable
	var carg3 C.gpointer           // implicit
	var carg4 C.GDestroyNotify     // implicit
	var carg5 C.GVfsFileLookupFunc // callback, scope: notified, closure: carg6, destroy: carg7, nullable
	var carg6 C.gpointer           // implicit
	var carg7 C.GDestroyNotify     // implicit
	var cret  C.gboolean           // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))
	if uriFunc != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_VfsFileLookupFunc)
		carg3 = C.gpointer(userdata.Register(uriFunc))
		carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))
	}
	if parseNameFunc != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_VfsFileLookupFunc)
		carg6 = C.gpointer(userdata.Register(parseNameFunc))
		carg7 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))
	}

	cret = C.g_vfs_register_uri_scheme(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(uriFunc)
	runtime.KeepAlive(parseNameFunc)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnregisterURIScheme wraps g_vfs_unregister_uri_scheme
// 
// see also https://docs.gtk.org/gio/method.g_vfs_unregister_uri_scheme.g_vfs_unregister_uri_scheme.html
//
func (vfs *VfsInstance) UnregisterURIScheme(scheme string) bool {
	var carg0 *C.GVfs    // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  C.gboolean // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_unregister_uri_scheme(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VfsOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type VfsOverrides[Instance Vfs] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // AddWritableNamespaces allows you to override the implementation of the virtual method add_writable_namespaces.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.add_writable_namespaces.html
	AddWritableNamespaces func(Instance, *FileAttributeInfoList)
	// // GetFileForPath allows you to override the implementation of the virtual method get_file_for_path.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_path.html
	GetFileForPath func(Instance, string) File
	// // GetFileForURI allows you to override the implementation of the virtual method get_file_for_uri.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_uri.html
	GetFileForURI func(Instance, string) File
	// // GetSupportedURISchemes allows you to override the implementation of the virtual method get_supported_uri_schemes.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.get_supported_uri_schemes.html
	GetSupportedURISchemes func(Instance) []string
	// // IsActive allows you to override the implementation of the virtual method is_active.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.is_active.html
	IsActive func(Instance) bool
	// // LocalFileMoved allows you to override the implementation of the virtual method local_file_moved.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_moved.html
	LocalFileMoved func(Instance, string, string)
	// // LocalFileRemoved allows you to override the implementation of the virtual method local_file_removed.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_removed.html
	LocalFileRemoved func(Instance, string)
	// // LocalFileSetAttributes allows you to override the implementation of the virtual method local_file_set_attributes.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.local_file_set_attributes.html
	LocalFileSetAttributes func(Instance, string, FileInfo, FileQueryInfoFlags, Cancellable) (bool, error)
	// // ParseName allows you to override the implementation of the virtual method parse_name.
	// 
	// see also https://docs.gtk.org/gio/method.Vfs.parse_name.html
	ParseName func(Instance, string) File
}

// UnsafeApplyVfsOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyVfsOverrides[Instance Vfs](gclass unsafe.Pointer, overrides VfsOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GVfsClass)(gclass)

	if overrides.AddWritableNamespaces != nil {
		pclass.add_writable_namespaces = (*[0]byte)(C._goglib_gio2_Vfs_add_writable_namespaces)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_add_writable_namespaces",
			func(carg0 *C.GVfs, carg1 *C.GFileAttributeInfoList) {
				var vfs  Instance               // go GVfs subclass
				var list *FileAttributeInfoList // in, none, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				list = UnsafeFileAttributeInfoListFromGlibNone(unsafe.Pointer(carg1))

				overrides.AddWritableNamespaces(vfs, list)
			},
		)
	}

	if overrides.GetFileForPath != nil {
		pclass.get_file_for_path = (*[0]byte)(C._goglib_gio2_Vfs_get_file_for_path)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_file_for_path",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs   Instance // go GVfs subclass
				var path  string   // in, none, string
				var goret File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				path = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetFileForPath(vfs, path)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.GetFileForURI != nil {
		pclass.get_file_for_uri = (*[0]byte)(C._goglib_gio2_Vfs_get_file_for_uri)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_file_for_uri",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs   Instance // go GVfs subclass
				var uri   string   // in, none, string
				var goret File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uri = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetFileForURI(vfs, uri)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.GetSupportedURISchemes != nil {
		pclass.get_supported_uri_schemes = (*[0]byte)(C._goglib_gio2_Vfs_get_supported_uri_schemes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_supported_uri_schemes",
			func(carg0 *C.GVfs) (cret **C.gchar) {
				var vfs   Instance // go GVfs subclass
				var goret []string // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetSupportedURISchemes(vfs)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

				return cret
			},
		)
	}

	if overrides.IsActive != nil {
		pclass.is_active = (*[0]byte)(C._goglib_gio2_Vfs_is_active)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_is_active",
			func(carg0 *C.GVfs) (cret C.gboolean) {
				var vfs   Instance // go GVfs subclass
				var goret bool     // return

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.IsActive(vfs)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.LocalFileMoved != nil {
		pclass.local_file_moved = (*[0]byte)(C._goglib_gio2_Vfs_local_file_moved)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_moved",
			func(carg0 *C.GVfs, carg1 *C.char, carg2 *C.char) {
				var vfs    Instance // go GVfs subclass
				var source string   // in, none, string
				var dest   string   // in, none, string

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				source = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				dest = C.GoString((*C.char)(unsafe.Pointer(carg2)))

				overrides.LocalFileMoved(vfs, source, dest)
			},
		)
	}

	if overrides.LocalFileRemoved != nil {
		pclass.local_file_removed = (*[0]byte)(C._goglib_gio2_Vfs_local_file_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_removed",
			func(carg0 *C.GVfs, carg1 *C.char) {
				var vfs      Instance // go GVfs subclass
				var filename string   // in, none, string

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				filename = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.LocalFileRemoved(vfs, filename)
			},
		)
	}

	if overrides.LocalFileSetAttributes != nil {
		pclass.local_file_set_attributes = (*[0]byte)(C._goglib_gio2_Vfs_local_file_set_attributes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_set_attributes",
			func(carg0 *C.GVfs, carg1 *C.char, carg2 *C.GFileInfo, carg3 C.GFileQueryInfoFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var vfs         Instance           // go GVfs subclass
				var filename    string             // in, none, string
				var info        FileInfo           // in, none, converted
				var flags       FileQueryInfoFlags // in, none, casted
				var cancellable Cancellable        // in, none, converted, nullable
				var goret       bool               // return
				var _goerr      error              // out, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				filename = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				info = UnsafeFileInfoFromGlibNone(unsafe.Pointer(carg2))
				flags = FileQueryInfoFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LocalFileSetAttributes(vfs, filename, info, flags, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ParseName != nil {
		pclass.parse_name = (*[0]byte)(C._goglib_gio2_Vfs_parse_name)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_parse_name",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs       Instance // go GVfs subclass
				var parseName string   // in, none, string
				var goret     File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				parseName = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.ParseName(vfs, parseName)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}
}

// ParentAddWritableNamespaces calls the default implementations of the `GVfs.add_writable_namespaces` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.add_writable_namespaces.html
func (vfs *VfsInstance) ParentAddWritableNamespaces(list *FileAttributeInfoList) {
	var carg0 *C.GVfs
	var carg1 *C.GFileAttributeInfoList // in, none, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))

	C._goglib_gio2_Vfs_virtual_add_writable_namespaces(unsafe.Pointer(parentclass.add_writable_namespaces), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(list)
}

// ParentGetFileForPath calls the default implementations of the `GVfs.get_file_for_path` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_path.html
func (vfs *VfsInstance) ParentGetFileForPath(path string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_get_file_for_path(unsafe.Pointer(parentclass.get_file_for_path), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentGetFileForURI calls the default implementations of the `GVfs.get_file_for_uri` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.get_file_for_uri.html
func (vfs *VfsInstance) ParentGetFileForURI(uri string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_get_file_for_uri(unsafe.Pointer(parentclass.get_file_for_uri), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentGetSupportedURISchemes calls the default implementations of the `GVfs.get_supported_uri_schemes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.get_supported_uri_schemes.html
func (vfs *VfsInstance) ParentGetSupportedURISchemes() []string {
	var carg0 *C.GVfs
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C._goglib_gio2_Vfs_virtual_get_supported_uri_schemes(unsafe.Pointer(parentclass.get_supported_uri_schemes), carg0)
	runtime.KeepAlive(vfs)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// ParentIsActive calls the default implementations of the `GVfs.is_active` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.is_active.html
func (vfs *VfsInstance) ParentIsActive() bool {
	var carg0 *C.GVfs
	var cret  C.gboolean // return

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C._goglib_gio2_Vfs_virtual_is_active(unsafe.Pointer(parentclass.is_active), carg0)
	runtime.KeepAlive(vfs)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentLocalFileMoved calls the default implementations of the `GVfs.local_file_moved` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.local_file_moved.html
func (vfs *VfsInstance) ParentLocalFileMoved(source string, dest string) {
	var carg0 *C.GVfs
	var carg1 *C.char // in, none, converted
	var carg2 *C.char // in, none, string

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg2))

	C._goglib_gio2_Vfs_virtual_local_file_moved(unsafe.Pointer(parentclass.local_file_moved), carg0, carg1, carg2)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(source)
	runtime.KeepAlive(dest)
}

// ParentLocalFileRemoved calls the default implementations of the `GVfs.local_file_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.local_file_removed.html
func (vfs *VfsInstance) ParentLocalFileRemoved(filename string) {
	var carg0 *C.GVfs
	var carg1 *C.char // in, none, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Vfs_virtual_local_file_removed(unsafe.Pointer(parentclass.local_file_removed), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(filename)
}

// ParentLocalFileSetAttributes calls the default implementations of the `GVfs.local_file_set_attributes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.local_file_set_attributes.html
func (vfs *VfsInstance) ParentLocalFileSetAttributes(filename string, info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GVfs
	var carg1 *C.char               // in, none, converted
	var carg2 *C.GFileInfo          // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, converted
	var carg4 *C.GCancellable       // in, none, casted
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Vfs_virtual_local_file_set_attributes(unsafe.Pointer(parentclass.local_file_set_attributes), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentParseName calls the default implementations of the `GVfs.parse_name` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.Vfs.parse_name.html
func (vfs *VfsInstance) ParentParseName(parseName string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_parse_name(unsafe.Pointer(parentclass.parse_name), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterVfsSubClass is used to register a go subclass of GVfs. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterVfsSubClass[InstanceT Vfs](
		name string,
		classInit func(class *VfsClass),
		constructor func() InstanceT,
		overrides VfsOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeVfs,
		UnsafeVfsClassFromGlibBorrow,
		UnsafeApplyVfsOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVfs(obj)
		},
		interfaceInits...,
	)
}

// VolumeMonitorInstance is the instance type used by all types extending GVolumeMonitor. It is used internally by the bindings. Users should use the interface [VolumeMonitor] instead.
type VolumeMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ VolumeMonitor = (*VolumeMonitorInstance)(nil)

// VolumeMonitor wraps GVolumeMonitor
// 
// see also https://docs.gtk.org/gio/class.VolumeMonitor.html
//
type VolumeMonitor interface {
	gobject.Object
	upcastToGVolumeMonitor() *VolumeMonitorInstance

	// GetConnectedDrives wraps g_volume_monitor_get_connected_drives
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_connected_drives.g_volume_monitor_get_connected_drives.html
	//
	GetConnectedDrives() []Drive
	// GetMountForUuid wraps g_volume_monitor_get_mount_for_uuid
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_mount_for_uuid.g_volume_monitor_get_mount_for_uuid.html
	//
	GetMountForUuid(string) Mount
	// GetMounts wraps g_volume_monitor_get_mounts
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_mounts.g_volume_monitor_get_mounts.html
	//
	GetMounts() []Mount
	// GetVolumeForUuid wraps g_volume_monitor_get_volume_for_uuid
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_volume_for_uuid.g_volume_monitor_get_volume_for_uuid.html
	//
	GetVolumeForUuid(string) Volume
	// GetVolumes wraps g_volume_monitor_get_volumes
	// 
	// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_volumes.g_volume_monitor_get_volumes.html
	//
	GetVolumes() []Volume
	// ConnectDriveChanged connects the provided callback to the "drive-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-changed.html
	//
	ConnectDriveChanged(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveConnected connects the provided callback to the "drive-connected" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-connected.html
	//
	ConnectDriveConnected(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveDisconnected connects the provided callback to the "drive-disconnected" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-disconnected.html
	//
	ConnectDriveDisconnected(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveEjectButton connects the provided callback to the "drive-eject-button" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-eject-button.html
	//
	ConnectDriveEjectButton(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveStopButton connects the provided callback to the "drive-stop-button" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-stop-button.html
	//
	ConnectDriveStopButton(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectMountAdded connects the provided callback to the "mount-added" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-added.html
	//
	ConnectMountAdded(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountChanged connects the provided callback to the "mount-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-changed.html
	//
	ConnectMountChanged(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountPreUnmount connects the provided callback to the "mount-pre-unmount" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-pre-unmount.html
	//
	ConnectMountPreUnmount(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountRemoved connects the provided callback to the "mount-removed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-removed.html
	//
	ConnectMountRemoved(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectVolumeAdded connects the provided callback to the "volume-added" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-added.html
	//
	ConnectVolumeAdded(func(VolumeMonitor, Volume)) gobject.SignalHandle
	// ConnectVolumeChanged connects the provided callback to the "volume-changed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-changed.html
	//
	ConnectVolumeChanged(func(VolumeMonitor, Volume)) gobject.SignalHandle
	// ConnectVolumeRemoved connects the provided callback to the "volume-removed" signal
	// 
	// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-removed.html
	//
	ConnectVolumeRemoved(func(VolumeMonitor, Volume)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentDriveChanged calls the default implementations of the `GVolumeMonitor.drive_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_changed.html
	ParentDriveChanged(drive Drive)
	// ParentDriveConnected calls the default implementations of the `GVolumeMonitor.drive_connected` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_connected.html
	ParentDriveConnected(drive Drive)
	// ParentDriveDisconnected calls the default implementations of the `GVolumeMonitor.drive_disconnected` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_disconnected.html
	ParentDriveDisconnected(drive Drive)
	// ParentDriveEjectButton calls the default implementations of the `GVolumeMonitor.drive_eject_button` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_eject_button.html
	ParentDriveEjectButton(drive Drive)
	// ParentDriveStopButton calls the default implementations of the `GVolumeMonitor.drive_stop_button` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_stop_button.html
	ParentDriveStopButton(drive Drive)
	// ParentGetConnectedDrives calls the default implementations of the `GVolumeMonitor.get_connected_drives` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_connected_drives.html
	ParentGetConnectedDrives() []Drive
	// ParentGetMountForUuid calls the default implementations of the `GVolumeMonitor.get_mount_for_uuid` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mount_for_uuid.html
	ParentGetMountForUuid(uuid string) Mount
	// ParentGetMounts calls the default implementations of the `GVolumeMonitor.get_mounts` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mounts.html
	ParentGetMounts() []Mount
	// ParentGetVolumeForUuid calls the default implementations of the `GVolumeMonitor.get_volume_for_uuid` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volume_for_uuid.html
	ParentGetVolumeForUuid(uuid string) Volume
	// ParentGetVolumes calls the default implementations of the `GVolumeMonitor.get_volumes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volumes.html
	ParentGetVolumes() []Volume
	// ParentMountAdded calls the default implementations of the `GVolumeMonitor.mount_added` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_added.html
	ParentMountAdded(mount Mount)
	// ParentMountChanged calls the default implementations of the `GVolumeMonitor.mount_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_changed.html
	ParentMountChanged(mount Mount)
	// ParentMountPreUnmount calls the default implementations of the `GVolumeMonitor.mount_pre_unmount` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_pre_unmount.html
	ParentMountPreUnmount(mount Mount)
	// ParentMountRemoved calls the default implementations of the `GVolumeMonitor.mount_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_removed.html
	ParentMountRemoved(mount Mount)
	// ParentVolumeAdded calls the default implementations of the `GVolumeMonitor.volume_added` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_added.html
	ParentVolumeAdded(volume Volume)
	// ParentVolumeChanged calls the default implementations of the `GVolumeMonitor.volume_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_changed.html
	ParentVolumeChanged(volume Volume)
	// ParentVolumeRemoved calls the default implementations of the `GVolumeMonitor.volume_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_removed.html
	ParentVolumeRemoved(volume Volume)
}

func unsafeWrapVolumeMonitor(base *gobject.ObjectInstance) *VolumeMonitorInstance {
	return &VolumeMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeVolumeMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVolumeMonitor(inst)
		},
	)
}

func marshalVolumeMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeVolumeMonitorFromGlibNone is used to convert raw GVolumeMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibNone(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(VolumeMonitor)
}

// UnsafeVolumeMonitorFromGlibFull is used to convert raw GVolumeMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibFull(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(VolumeMonitor)
}

// UnsafeVolumeMonitorFromGlibBorrow is used to convert raw GVolumeMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibBorrow(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(VolumeMonitor)
}

func (v *VolumeMonitorInstance) upcastToGVolumeMonitor() *VolumeMonitorInstance {
	return v
}

// UnsafeVolumeMonitorToGlibNone is used to convert the instance to it's C value GVolumeMonitor. This is used by the bindings internally.
func UnsafeVolumeMonitorToGlibNone(c VolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeVolumeMonitorToGlibFull is used to convert the instance to it's C value GVolumeMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorToGlibFull(c VolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// VolumeMonitorAdoptOrphanMount wraps g_volume_monitor_adopt_orphan_mount
// 
// see also https://docs.gtk.org/gio/func.g_volume_monitor_adopt_orphan_mount.html
//
//
// Deprecated: (since 2.20.0) Instead of using this function, #GVolumeMonitor
// implementations should instead create shadow mounts with the URI of
// the mount they intend to adopt. See the proxy volume monitor in
// gvfs for an example of this. Also see g_mount_is_shadowed(),
// g_mount_shadow() and g_mount_unshadow() functions.
func VolumeMonitorAdoptOrphanMount(mount Mount) Volume {
	var carg1 *C.GMount  // in, none, converted
	var cret  *C.GVolume // return, full, converted

	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_volume_monitor_adopt_orphan_mount(carg1)
	runtime.KeepAlive(mount)

	var goret Volume

	goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// VolumeMonitorGet wraps g_volume_monitor_get
// 
// see also https://docs.gtk.org/gio/func.g_volume_monitor_get.html
//
func VolumeMonitorGet() VolumeMonitor {
	var cret *C.GVolumeMonitor // return, full, converted

	cret = C.g_volume_monitor_get()

	var goret VolumeMonitor

	goret = UnsafeVolumeMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConnectedDrives wraps g_volume_monitor_get_connected_drives
// 
// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_connected_drives.g_volume_monitor_get_connected_drives.html
//
func (volumeMonitor *VolumeMonitorInstance) GetConnectedDrives() []Drive {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_connected_drives(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Drive

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Drive {
			var dst Drive // converted
			dst = UnsafeDriveFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// GetMountForUuid wraps g_volume_monitor_get_mount_for_uuid
// 
// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_mount_for_uuid.g_volume_monitor_get_mount_for_uuid.html
//
func (volumeMonitor *VolumeMonitorInstance) GetMountForUuid(uuid string) Mount {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var carg1 *C.char           // in, none, string
	var cret  *C.GMount         // return, full, converted, nullable

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_monitor_get_mount_for_uuid(carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetMounts wraps g_volume_monitor_get_mounts
// 
// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_mounts.g_volume_monitor_get_mounts.html
//
func (volumeMonitor *VolumeMonitorInstance) GetMounts() []Mount {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_mounts(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Mount

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Mount {
			var dst Mount // converted
			dst = UnsafeMountFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// GetVolumeForUuid wraps g_volume_monitor_get_volume_for_uuid
// 
// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_volume_for_uuid.g_volume_monitor_get_volume_for_uuid.html
//
func (volumeMonitor *VolumeMonitorInstance) GetVolumeForUuid(uuid string) Volume {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var carg1 *C.char           // in, none, string
	var cret  *C.GVolume        // return, full, converted, nullable

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_monitor_get_volume_for_uuid(carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetVolumes wraps g_volume_monitor_get_volumes
// 
// see also https://docs.gtk.org/gio/method.g_volume_monitor_get_volumes.g_volume_monitor_get_volumes.html
//
func (volumeMonitor *VolumeMonitorInstance) GetVolumes() []Volume {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_volumes(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ConnectDriveChanged connects the provided callback to the "drive-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-changed.html
//
func (o *VolumeMonitorInstance) ConnectDriveChanged(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-changed", fn)
}

// ConnectDriveConnected connects the provided callback to the "drive-connected" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-connected.html
//
func (o *VolumeMonitorInstance) ConnectDriveConnected(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-connected", fn)
}

// ConnectDriveDisconnected connects the provided callback to the "drive-disconnected" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-disconnected.html
//
func (o *VolumeMonitorInstance) ConnectDriveDisconnected(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-disconnected", fn)
}

// ConnectDriveEjectButton connects the provided callback to the "drive-eject-button" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-eject-button.html
//
func (o *VolumeMonitorInstance) ConnectDriveEjectButton(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-eject-button", fn)
}

// ConnectDriveStopButton connects the provided callback to the "drive-stop-button" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.drive-stop-button.html
//
func (o *VolumeMonitorInstance) ConnectDriveStopButton(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-stop-button", fn)
}

// ConnectMountAdded connects the provided callback to the "mount-added" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-added.html
//
func (o *VolumeMonitorInstance) ConnectMountAdded(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-added", fn)
}

// ConnectMountChanged connects the provided callback to the "mount-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-changed.html
//
func (o *VolumeMonitorInstance) ConnectMountChanged(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-changed", fn)
}

// ConnectMountPreUnmount connects the provided callback to the "mount-pre-unmount" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-pre-unmount.html
//
func (o *VolumeMonitorInstance) ConnectMountPreUnmount(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-pre-unmount", fn)
}

// ConnectMountRemoved connects the provided callback to the "mount-removed" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.mount-removed.html
//
func (o *VolumeMonitorInstance) ConnectMountRemoved(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-removed", fn)
}

// ConnectVolumeAdded connects the provided callback to the "volume-added" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-added.html
//
func (o *VolumeMonitorInstance) ConnectVolumeAdded(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-added", fn)
}

// ConnectVolumeChanged connects the provided callback to the "volume-changed" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-changed.html
//
func (o *VolumeMonitorInstance) ConnectVolumeChanged(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-changed", fn)
}

// ConnectVolumeRemoved connects the provided callback to the "volume-removed" signal
// 
// see also https://docs.gtk.org/gio/signal.VolumeMonitor.volume-removed.html
//
func (o *VolumeMonitorInstance) ConnectVolumeRemoved(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-removed", fn)
}

// VolumeMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type VolumeMonitorOverrides[Instance VolumeMonitor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // DriveChanged allows you to override the implementation of the virtual method drive_changed.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_changed.html
	DriveChanged func(Instance, Drive)
	// // DriveConnected allows you to override the implementation of the virtual method drive_connected.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_connected.html
	DriveConnected func(Instance, Drive)
	// // DriveDisconnected allows you to override the implementation of the virtual method drive_disconnected.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_disconnected.html
	DriveDisconnected func(Instance, Drive)
	// // DriveEjectButton allows you to override the implementation of the virtual method drive_eject_button.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_eject_button.html
	DriveEjectButton func(Instance, Drive)
	// // DriveStopButton allows you to override the implementation of the virtual method drive_stop_button.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_stop_button.html
	DriveStopButton func(Instance, Drive)
	// // GetConnectedDrives allows you to override the implementation of the virtual method get_connected_drives.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_connected_drives.html
	GetConnectedDrives func(Instance) []Drive
	// // GetMountForUuid allows you to override the implementation of the virtual method get_mount_for_uuid.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mount_for_uuid.html
	GetMountForUuid func(Instance, string) Mount
	// // GetMounts allows you to override the implementation of the virtual method get_mounts.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mounts.html
	GetMounts func(Instance) []Mount
	// // GetVolumeForUuid allows you to override the implementation of the virtual method get_volume_for_uuid.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volume_for_uuid.html
	GetVolumeForUuid func(Instance, string) Volume
	// // GetVolumes allows you to override the implementation of the virtual method get_volumes.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volumes.html
	GetVolumes func(Instance) []Volume
	// // MountAdded allows you to override the implementation of the virtual method mount_added.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_added.html
	MountAdded func(Instance, Mount)
	// // MountChanged allows you to override the implementation of the virtual method mount_changed.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_changed.html
	MountChanged func(Instance, Mount)
	// // MountPreUnmount allows you to override the implementation of the virtual method mount_pre_unmount.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_pre_unmount.html
	MountPreUnmount func(Instance, Mount)
	// // MountRemoved allows you to override the implementation of the virtual method mount_removed.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_removed.html
	MountRemoved func(Instance, Mount)
	// // VolumeAdded allows you to override the implementation of the virtual method volume_added.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_added.html
	VolumeAdded func(Instance, Volume)
	// // VolumeChanged allows you to override the implementation of the virtual method volume_changed.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_changed.html
	VolumeChanged func(Instance, Volume)
	// // VolumeRemoved allows you to override the implementation of the virtual method volume_removed.
	// 
	// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_removed.html
	VolumeRemoved func(Instance, Volume)
}

// UnsafeApplyVolumeMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyVolumeMonitorOverrides[Instance VolumeMonitor](gclass unsafe.Pointer, overrides VolumeMonitorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GVolumeMonitorClass)(gclass)

	if overrides.DriveChanged != nil {
		pclass.drive_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveChanged(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveConnected != nil {
		pclass.drive_connected = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_connected)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_connected",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveConnected(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveDisconnected != nil {
		pclass.drive_disconnected = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_disconnected)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_disconnected",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveDisconnected(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveEjectButton != nil {
		pclass.drive_eject_button = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_eject_button)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_eject_button",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveEjectButton(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveStopButton != nil {
		pclass.drive_stop_button = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_stop_button)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_stop_button",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveStopButton(volumeMonitor, drive)
			},
		)
	}

	if overrides.GetConnectedDrives != nil {
		pclass.get_connected_drives = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_connected_drives)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_connected_drives",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Drive  // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetConnectedDrives(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Drive (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.GetMountForUuid != nil {
		pclass.get_mount_for_uuid = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_mount_for_uuid)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_mount_for_uuid",
			func(carg0 *C.GVolumeMonitor, carg1 *C.char) (cret *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var uuid          string   // in, none, string
				var goret         Mount    // return, full, converted, nullable

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uuid = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetMountForUuid(volumeMonitor, uuid)

				if goret != nil {
					cret = (*C.GMount)(UnsafeMountToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetMounts != nil {
		pclass.get_mounts = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_mounts)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_mounts",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Mount  // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetMounts(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Mount (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.GetVolumeForUuid != nil {
		pclass.get_volume_for_uuid = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_volume_for_uuid)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_volume_for_uuid",
			func(carg0 *C.GVolumeMonitor, carg1 *C.char) (cret *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var uuid          string   // in, none, string
				var goret         Volume   // return, full, converted, nullable

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uuid = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetVolumeForUuid(volumeMonitor, uuid)

				if goret != nil {
					cret = (*C.GVolume)(UnsafeVolumeToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetVolumes != nil {
		pclass.get_volumes = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_volumes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_volumes",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Volume // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetVolumes(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Volume (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.MountAdded != nil {
		pclass.mount_added = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_added)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_added",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountAdded(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountChanged != nil {
		pclass.mount_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountChanged(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountPreUnmount != nil {
		pclass.mount_pre_unmount = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_pre_unmount)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_pre_unmount",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountPreUnmount(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountRemoved != nil {
		pclass.mount_removed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_removed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountRemoved(volumeMonitor, mount)
			},
		)
	}

	if overrides.VolumeAdded != nil {
		pclass.volume_added = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_added)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_added",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeAdded(volumeMonitor, volume)
			},
		)
	}

	if overrides.VolumeChanged != nil {
		pclass.volume_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeChanged(volumeMonitor, volume)
			},
		)
	}

	if overrides.VolumeRemoved != nil {
		pclass.volume_removed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_removed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeRemoved(volumeMonitor, volume)
			},
		)
	}
}

// ParentDriveChanged calls the default implementations of the `GVolumeMonitor.drive_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_changed.html
func (volumeMonitor *VolumeMonitorInstance) ParentDriveChanged(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_changed(unsafe.Pointer(parentclass.drive_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveConnected calls the default implementations of the `GVolumeMonitor.drive_connected` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_connected.html
func (volumeMonitor *VolumeMonitorInstance) ParentDriveConnected(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_connected(unsafe.Pointer(parentclass.drive_connected), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveDisconnected calls the default implementations of the `GVolumeMonitor.drive_disconnected` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_disconnected.html
func (volumeMonitor *VolumeMonitorInstance) ParentDriveDisconnected(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_disconnected(unsafe.Pointer(parentclass.drive_disconnected), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveEjectButton calls the default implementations of the `GVolumeMonitor.drive_eject_button` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_eject_button.html
func (volumeMonitor *VolumeMonitorInstance) ParentDriveEjectButton(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_eject_button(unsafe.Pointer(parentclass.drive_eject_button), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveStopButton calls the default implementations of the `GVolumeMonitor.drive_stop_button` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.drive_stop_button.html
func (volumeMonitor *VolumeMonitorInstance) ParentDriveStopButton(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_stop_button(unsafe.Pointer(parentclass.drive_stop_button), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentGetConnectedDrives calls the default implementations of the `GVolumeMonitor.get_connected_drives` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_connected_drives.html
func (volumeMonitor *VolumeMonitorInstance) ParentGetConnectedDrives() []Drive {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_connected_drives(unsafe.Pointer(parentclass.get_connected_drives), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Drive

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Drive {
			var dst Drive // converted
			dst = UnsafeDriveFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentGetMountForUuid calls the default implementations of the `GVolumeMonitor.get_mount_for_uuid` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mount_for_uuid.html
func (volumeMonitor *VolumeMonitorInstance) ParentGetMountForUuid(uuid string) Mount {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.char   // in, none, converted
	var cret  *C.GMount // return, full, converted, nullable

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_mount_for_uuid(unsafe.Pointer(parentclass.get_mount_for_uuid), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetMounts calls the default implementations of the `GVolumeMonitor.get_mounts` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_mounts.html
func (volumeMonitor *VolumeMonitorInstance) ParentGetMounts() []Mount {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_mounts(unsafe.Pointer(parentclass.get_mounts), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Mount

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Mount {
			var dst Mount // converted
			dst = UnsafeMountFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentGetVolumeForUuid calls the default implementations of the `GVolumeMonitor.get_volume_for_uuid` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volume_for_uuid.html
func (volumeMonitor *VolumeMonitorInstance) ParentGetVolumeForUuid(uuid string) Volume {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.char    // in, none, converted
	var cret  *C.GVolume // return, full, converted, nullable

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_volume_for_uuid(unsafe.Pointer(parentclass.get_volume_for_uuid), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetVolumes calls the default implementations of the `GVolumeMonitor.get_volumes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.get_volumes.html
func (volumeMonitor *VolumeMonitorInstance) ParentGetVolumes() []Volume {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_volumes(unsafe.Pointer(parentclass.get_volumes), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentMountAdded calls the default implementations of the `GVolumeMonitor.mount_added` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_added.html
func (volumeMonitor *VolumeMonitorInstance) ParentMountAdded(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_added(unsafe.Pointer(parentclass.mount_added), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountChanged calls the default implementations of the `GVolumeMonitor.mount_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_changed.html
func (volumeMonitor *VolumeMonitorInstance) ParentMountChanged(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_changed(unsafe.Pointer(parentclass.mount_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountPreUnmount calls the default implementations of the `GVolumeMonitor.mount_pre_unmount` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_pre_unmount.html
func (volumeMonitor *VolumeMonitorInstance) ParentMountPreUnmount(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_pre_unmount(unsafe.Pointer(parentclass.mount_pre_unmount), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountRemoved calls the default implementations of the `GVolumeMonitor.mount_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.mount_removed.html
func (volumeMonitor *VolumeMonitorInstance) ParentMountRemoved(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_removed(unsafe.Pointer(parentclass.mount_removed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentVolumeAdded calls the default implementations of the `GVolumeMonitor.volume_added` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_added.html
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeAdded(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_added(unsafe.Pointer(parentclass.volume_added), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// ParentVolumeChanged calls the default implementations of the `GVolumeMonitor.volume_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_changed.html
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeChanged(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_changed(unsafe.Pointer(parentclass.volume_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// ParentVolumeRemoved calls the default implementations of the `GVolumeMonitor.volume_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.VolumeMonitor.volume_removed.html
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeRemoved(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_removed(unsafe.Pointer(parentclass.volume_removed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// RegisterVolumeMonitorSubClass is used to register a go subclass of GVolumeMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterVolumeMonitorSubClass[InstanceT VolumeMonitor](
		name string,
		classInit func(class *VolumeMonitorClass),
		constructor func() InstanceT,
		overrides VolumeMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeVolumeMonitor,
		UnsafeVolumeMonitorClassFromGlibBorrow,
		UnsafeApplyVolumeMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVolumeMonitor(obj)
		},
		interfaceInits...,
	)
}

// ZlibDecompressorInstance is the instance type used by all types extending GZlibDecompressor. It is used internally by the bindings. Users should use the interface [ZlibDecompressor] instead.
type ZlibDecompressorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ZlibDecompressor = (*ZlibDecompressorInstance)(nil)

// ZlibDecompressor wraps GZlibDecompressor
// 
// see also https://docs.gtk.org/gio/class.ZlibDecompressor.html
//
type ZlibDecompressor interface {
	gobject.Object
	upcastToGZlibDecompressor() *ZlibDecompressorInstance

	// GetFileInfo wraps g_zlib_decompressor_get_file_info
	// 
	// see also https://docs.gtk.org/gio/method.g_zlib_decompressor_get_file_info.g_zlib_decompressor_get_file_info.html
	//
	GetFileInfo() FileInfo

	// chain up virtual methods:
}

func unsafeWrapZlibDecompressor(base *gobject.ObjectInstance) *ZlibDecompressorInstance {
	return &ZlibDecompressorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeZlibDecompressor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapZlibDecompressor(inst)
		},
	)
}

func marshalZlibDecompressorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeZlibDecompressorFromGlibNone is used to convert raw GZlibDecompressor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibNone(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibNone(c).(ZlibDecompressor)
}

// UnsafeZlibDecompressorFromGlibFull is used to convert raw GZlibDecompressor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibFull(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibFull(c).(ZlibDecompressor)
}

// UnsafeZlibDecompressorFromGlibBorrow is used to convert raw GZlibDecompressor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibBorrow(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ZlibDecompressor)
}

func (z *ZlibDecompressorInstance) upcastToGZlibDecompressor() *ZlibDecompressorInstance {
	return z
}

// UnsafeZlibDecompressorToGlibNone is used to convert the instance to it's C value GZlibDecompressor. This is used by the bindings internally.
func UnsafeZlibDecompressorToGlibNone(c ZlibDecompressor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeZlibDecompressorToGlibFull is used to convert the instance to it's C value GZlibDecompressor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorToGlibFull(c ZlibDecompressor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewZlibDecompressor wraps g_zlib_decompressor_new
// 
// see also https://docs.gtk.org/gio/func.g_zlib_decompressor_new.html
//
func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor {
	var carg1 C.GZlibCompressorFormat // in, none, casted
	var cret  *C.GZlibDecompressor    // return, full, converted

	carg1 = C.GZlibCompressorFormat(format)

	cret = C.g_zlib_decompressor_new(carg1)
	runtime.KeepAlive(format)

	var goret ZlibDecompressor

	goret = UnsafeZlibDecompressorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFileInfo wraps g_zlib_decompressor_get_file_info
// 
// see also https://docs.gtk.org/gio/method.g_zlib_decompressor_get_file_info.g_zlib_decompressor_get_file_info.html
//
func (decompressor *ZlibDecompressorInstance) GetFileInfo() FileInfo {
	var carg0 *C.GZlibDecompressor // in, none, converted
	var cret  *C.GFileInfo         // return, none, converted, nullable

	carg0 = (*C.GZlibDecompressor)(UnsafeZlibDecompressorToGlibNone(decompressor))

	cret = C.g_zlib_decompressor_get_file_info(carg0)
	runtime.KeepAlive(decompressor)

	var goret FileInfo

	if cret != nil {
		goret = UnsafeFileInfoFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ZlibDecompressorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ZlibDecompressorOverrides[Instance ZlibDecompressor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyZlibDecompressorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyZlibDecompressorOverrides[Instance ZlibDecompressor](gclass unsafe.Pointer, overrides ZlibDecompressorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterZlibDecompressorSubClass is used to register a go subclass of GZlibDecompressor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterZlibDecompressorSubClass[InstanceT ZlibDecompressor](
		name string,
		classInit func(class *ZlibDecompressorClass),
		constructor func() InstanceT,
		overrides ZlibDecompressorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeZlibDecompressor,
		UnsafeZlibDecompressorClassFromGlibBorrow,
		UnsafeApplyZlibDecompressorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapZlibDecompressor(obj)
		},
		interfaceInits...,
	)
}

// FileIOStreamInstance is the instance type used by all types extending GFileIOStream. It is used internally by the bindings. Users should use the interface [FileIOStream] instead.
type FileIOStreamInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileIOStream = (*FileIOStreamInstance)(nil)

// FileIOStream wraps GFileIOStream
// 
// see also https://docs.gtk.org/gio/class.FileIOStream.html
//
type FileIOStream interface {
	IOStream
	Seekable
	upcastToGFileIOStream() *FileIOStreamInstance

	// GetEtag wraps g_file_io_stream_get_etag
	// 
	// see also https://docs.gtk.org/gio/method.g_file_io_stream_get_etag.g_file_io_stream_get_etag.html
	//
	GetEtag() string
	// QueryInfo wraps g_file_io_stream_query_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info.g_file_io_stream_query_info.html
	//
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_io_stream_query_info_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info_async.g_file_io_stream_query_info_async.html
	//
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_io_stream_query_info_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info_finish.g_file_io_stream_query_info_finish.html
	//
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileIOStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.can_seek.html
	ParentCanSeek() bool
	// ParentCanTruncate calls the default implementations of the `GFileIOStream.can_truncate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.can_truncate.html
	ParentCanTruncate() bool
	// ParentGetEtag calls the default implementations of the `GFileIOStream.get_etag` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.get_etag.html
	ParentGetEtag() string
	// ParentQueryInfo calls the default implementations of the `GFileIOStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.query_info.html
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileIOStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.query_info_finish.html
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileIOStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.seek.html
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileIOStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.tell.html
	ParentTell() int64
	// ParentTruncateFn calls the default implementations of the `GFileIOStream.truncate_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.truncate_fn.html
	ParentTruncateFn(size int64, cancellable Cancellable) (bool, error)
}

func unsafeWrapFileIOStream(base *gobject.ObjectInstance) *FileIOStreamInstance {
	return &FileIOStreamInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIOStream(inst)
		},
	)
}

func marshalFileIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileIOStreamFromGlibNone is used to convert raw GFileIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibNone(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileIOStream)
}

// UnsafeFileIOStreamFromGlibFull is used to convert raw GFileIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibFull(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileIOStream)
}

// UnsafeFileIOStreamFromGlibBorrow is used to convert raw GFileIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibBorrow(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileIOStream)
}

func (f *FileIOStreamInstance) upcastToGFileIOStream() *FileIOStreamInstance {
	return f
}

// UnsafeFileIOStreamToGlibNone is used to convert the instance to it's C value GFileIOStream. This is used by the bindings internally.
func UnsafeFileIOStreamToGlibNone(c FileIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileIOStreamToGlibFull is used to convert the instance to it's C value GFileIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamToGlibFull(c FileIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetEtag wraps g_file_io_stream_get_etag
// 
// see also https://docs.gtk.org/gio/method.g_file_io_stream_get_etag.g_file_io_stream_get_etag.html
//
func (stream *FileIOStreamInstance) GetEtag() string {
	var carg0 *C.GFileIOStream // in, none, converted
	var cret  *C.char          // return, full, string, nullable-string

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C.g_file_io_stream_get_etag(carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// QueryInfo wraps g_file_io_stream_query_info
// 
// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info.g_file_io_stream_query_info.html
//
func (stream *FileIOStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileIOStream // in, none, converted
	var carg1 *C.char          // in, none, string
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GFileInfo     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_io_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_io_stream_query_info_async
// 
// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info_async.g_file_io_stream_query_info_async.html
//
func (stream *FileIOStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileIOStream      // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_io_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_io_stream_query_info_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_io_stream_query_info_finish.g_file_io_stream_query_info_finish.html
//
func (stream *FileIOStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileIOStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileInfo     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_io_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileIOStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileIOStreamOverrides[Instance FileIOStream] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.can_seek.html
	CanSeek func(Instance) bool
	// // CanTruncate allows you to override the implementation of the virtual method can_truncate.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.can_truncate.html
	CanTruncate func(Instance) bool
	// // GetEtag allows you to override the implementation of the virtual method get_etag.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.get_etag.html
	GetEtag func(Instance) string
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.query_info.html
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.query_info_finish.html
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.seek.html
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.tell.html
	Tell func(Instance) int64
	// // TruncateFn allows you to override the implementation of the virtual method truncate_fn.
	// 
	// see also https://docs.gtk.org/gio/method.FileIOStream.truncate_fn.html
	TruncateFn func(Instance, int64, Cancellable) (bool, error)
}

// UnsafeApplyFileIOStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileIOStreamOverrides[Instance FileIOStream](gclass unsafe.Pointer, overrides FileIOStreamOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)

	pclass := (*C.GFileIOStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileIOStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_can_seek",
			func(carg0 *C.GFileIOStream) (cret C.gboolean) {
				var stream Instance // go GFileIOStream subclass
				var goret  bool     // return

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._goglib_gio2_FileIOStream_can_truncate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_can_truncate",
			func(carg0 *C.GFileIOStream) (cret C.gboolean) {
				var stream Instance // go GFileIOStream subclass
				var goret  bool     // return

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanTruncate(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetEtag != nil {
		pclass.get_etag = (*[0]byte)(C._goglib_gio2_FileIOStream_get_etag)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_get_etag",
			func(carg0 *C.GFileIOStream) (cret *C.char) {
				var stream Instance // go GFileIOStream subclass
				var goret  string   // return, full, string, nullable-string

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetEtag(stream)

				if goret != "" {
					cret = (*C.char)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileIOStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_query_info",
			func(carg0 *C.GFileIOStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileIOStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileIOStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_query_info_finish",
			func(carg0 *C.GFileIOStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileIOStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileIOStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_seek",
			func(carg0 *C.GFileIOStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileIOStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileIOStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_tell",
			func(carg0 *C.GFileIOStream) (cret C.goffset) {
				var stream Instance // go GFileIOStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._goglib_gio2_FileIOStream_truncate_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_truncate_fn",
			func(carg0 *C.GFileIOStream, carg1 C.goffset, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GFileIOStream subclass
				var size        int64       // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				size = int64(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.TruncateFn(stream, size, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileIOStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.can_seek.html
func (stream *FileIOStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileIOStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentCanTruncate calls the default implementations of the `GFileIOStream.can_truncate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.can_truncate.html
func (stream *FileIOStreamInstance) ParentCanTruncate() bool {
	var carg0 *C.GFileIOStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_can_truncate(unsafe.Pointer(parentclass.can_truncate), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetEtag calls the default implementations of the `GFileIOStream.get_etag` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.get_etag.html
func (stream *FileIOStreamInstance) ParentGetEtag() string {
	var carg0 *C.GFileIOStream
	var cret  *C.char // return, full, string, nullable-string

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_get_etag(unsafe.Pointer(parentclass.get_etag), carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileIOStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.query_info.html
func (stream *FileIOStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileIOStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileIOStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.query_info_finish.html
func (stream *FileIOStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileIOStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileIOStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileIOStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.seek.html
func (stream *FileIOStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileIOStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileIOStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.tell.html
func (stream *FileIOStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileIOStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// ParentTruncateFn calls the default implementations of the `GFileIOStream.truncate_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileIOStream.truncate_fn.html
func (stream *FileIOStreamInstance) ParentTruncateFn(size int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileIOStream
	var carg1 C.goffset       // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = C.goffset(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_truncate_fn(unsafe.Pointer(parentclass.truncate_fn), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileIOStreamSubClass is used to register a go subclass of GFileIOStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileIOStreamSubClass[InstanceT FileIOStream](
		name string,
		classInit func(class *FileIOStreamClass),
		constructor func() InstanceT,
		overrides FileIOStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileIOStream,
		UnsafeFileIOStreamClassFromGlibBorrow,
		UnsafeApplyFileIOStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIOStream(obj)
		},
		interfaceInits...,
	)
}

// FileInputStreamInstance is the instance type used by all types extending GFileInputStream. It is used internally by the bindings. Users should use the interface [FileInputStream] instead.
type FileInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileInputStream = (*FileInputStreamInstance)(nil)

// FileInputStream wraps GFileInputStream
// 
// see also https://docs.gtk.org/gio/class.FileInputStream.html
//
type FileInputStream interface {
	InputStream
	Seekable
	upcastToGFileInputStream() *FileInputStreamInstance

	// QueryInfo wraps g_file_input_stream_query_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info.g_file_input_stream_query_info.html
	//
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_input_stream_query_info_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info_async.g_file_input_stream_query_info_async.html
	//
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_input_stream_query_info_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info_finish.g_file_input_stream_query_info_finish.html
	//
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileInputStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.can_seek.html
	ParentCanSeek() bool
	// ParentQueryInfo calls the default implementations of the `GFileInputStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.query_info.html
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileInputStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.query_info_finish.html
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileInputStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.seek.html
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileInputStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.tell.html
	ParentTell() int64
}

func unsafeWrapFileInputStream(base *gobject.ObjectInstance) *FileInputStreamInstance {
	return &FileInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInputStream(inst)
		},
	)
}

func marshalFileInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileInputStreamFromGlibNone is used to convert raw GFileInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibNone(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileInputStream)
}

// UnsafeFileInputStreamFromGlibFull is used to convert raw GFileInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibFull(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileInputStream)
}

// UnsafeFileInputStreamFromGlibBorrow is used to convert raw GFileInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibBorrow(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileInputStream)
}

func (f *FileInputStreamInstance) upcastToGFileInputStream() *FileInputStreamInstance {
	return f
}

// UnsafeFileInputStreamToGlibNone is used to convert the instance to it's C value GFileInputStream. This is used by the bindings internally.
func UnsafeFileInputStreamToGlibNone(c FileInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileInputStreamToGlibFull is used to convert the instance to it's C value GFileInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamToGlibFull(c FileInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// QueryInfo wraps g_file_input_stream_query_info
// 
// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info.g_file_input_stream_query_info.html
//
func (stream *FileInputStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileInputStream // in, none, converted
	var carg1 *C.char             // in, none, string
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileInfo        // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_input_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_input_stream_query_info_async
// 
// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info_async.g_file_input_stream_query_info_async.html
//
func (stream *FileInputStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileInputStream   // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_input_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_input_stream_query_info_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_input_stream_query_info_finish.g_file_input_stream_query_info_finish.html
//
func (stream *FileInputStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var cret  *C.GFileInfo        // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_input_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileInputStreamOverrides[Instance FileInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.can_seek.html
	CanSeek func(Instance) bool
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.query_info.html
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.query_info_finish.html
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.seek.html
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// see also https://docs.gtk.org/gio/method.FileInputStream.tell.html
	Tell func(Instance) int64
}

// UnsafeApplyFileInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileInputStreamOverrides[Instance FileInputStream](gclass unsafe.Pointer, overrides FileInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)

	pclass := (*C.GFileInputStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileInputStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_can_seek",
			func(carg0 *C.GFileInputStream) (cret C.gboolean) {
				var stream Instance // go GFileInputStream subclass
				var goret  bool     // return

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileInputStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_query_info",
			func(carg0 *C.GFileInputStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileInputStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileInputStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_query_info_finish",
			func(carg0 *C.GFileInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileInputStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_seek",
			func(carg0 *C.GFileInputStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileInputStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileInputStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_tell",
			func(carg0 *C.GFileInputStream) (cret C.goffset) {
				var stream Instance // go GFileInputStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileInputStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileInputStream.can_seek.html
func (stream *FileInputStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileInputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileInputStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileInputStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileInputStream.query_info.html
func (stream *FileInputStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileInputStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileInputStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileInputStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileInputStream.query_info_finish.html
func (stream *FileInputStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileInputStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileInputStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileInputStream.seek.html
func (stream *FileInputStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileInputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileInputStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileInputStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileInputStream.tell.html
func (stream *FileInputStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileInputStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileInputStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// RegisterFileInputStreamSubClass is used to register a go subclass of GFileInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileInputStreamSubClass[InstanceT FileInputStream](
		name string,
		classInit func(class *FileInputStreamClass),
		constructor func() InstanceT,
		overrides FileInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileInputStream,
		UnsafeFileInputStreamClassFromGlibBorrow,
		UnsafeApplyFileInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInputStream(obj)
		},
		interfaceInits...,
	)
}

// FileOutputStreamInstance is the instance type used by all types extending GFileOutputStream. It is used internally by the bindings. Users should use the interface [FileOutputStream] instead.
type FileOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileOutputStream = (*FileOutputStreamInstance)(nil)

// FileOutputStream wraps GFileOutputStream
// 
// see also https://docs.gtk.org/gio/class.FileOutputStream.html
//
type FileOutputStream interface {
	OutputStream
	Seekable
	upcastToGFileOutputStream() *FileOutputStreamInstance

	// GetEtag wraps g_file_output_stream_get_etag
	// 
	// see also https://docs.gtk.org/gio/method.g_file_output_stream_get_etag.g_file_output_stream_get_etag.html
	//
	GetEtag() string
	// QueryInfo wraps g_file_output_stream_query_info
	// 
	// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info.g_file_output_stream_query_info.html
	//
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_output_stream_query_info_async
	// 
	// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info_async.g_file_output_stream_query_info_async.html
	//
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_output_stream_query_info_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info_finish.g_file_output_stream_query_info_finish.html
	//
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileOutputStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.can_seek.html
	ParentCanSeek() bool
	// ParentCanTruncate calls the default implementations of the `GFileOutputStream.can_truncate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.can_truncate.html
	ParentCanTruncate() bool
	// ParentGetEtag calls the default implementations of the `GFileOutputStream.get_etag` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.get_etag.html
	ParentGetEtag() string
	// ParentQueryInfo calls the default implementations of the `GFileOutputStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info.html
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileOutputStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info_finish.html
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileOutputStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.seek.html
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileOutputStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.tell.html
	ParentTell() int64
	// ParentTruncateFn calls the default implementations of the `GFileOutputStream.truncate_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.truncate_fn.html
	ParentTruncateFn(size int64, cancellable Cancellable) (bool, error)
}

func unsafeWrapFileOutputStream(base *gobject.ObjectInstance) *FileOutputStreamInstance {
	return &FileOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileOutputStream(inst)
		},
	)
}

func marshalFileOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileOutputStreamFromGlibNone is used to convert raw GFileOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibNone(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileOutputStream)
}

// UnsafeFileOutputStreamFromGlibFull is used to convert raw GFileOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibFull(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileOutputStream)
}

// UnsafeFileOutputStreamFromGlibBorrow is used to convert raw GFileOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibBorrow(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileOutputStream)
}

func (f *FileOutputStreamInstance) upcastToGFileOutputStream() *FileOutputStreamInstance {
	return f
}

// UnsafeFileOutputStreamToGlibNone is used to convert the instance to it's C value GFileOutputStream. This is used by the bindings internally.
func UnsafeFileOutputStreamToGlibNone(c FileOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileOutputStreamToGlibFull is used to convert the instance to it's C value GFileOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamToGlibFull(c FileOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetEtag wraps g_file_output_stream_get_etag
// 
// see also https://docs.gtk.org/gio/method.g_file_output_stream_get_etag.g_file_output_stream_get_etag.html
//
func (stream *FileOutputStreamInstance) GetEtag() string {
	var carg0 *C.GFileOutputStream // in, none, converted
	var cret  *C.char              // return, full, string, nullable-string

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C.g_file_output_stream_get_etag(carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// QueryInfo wraps g_file_output_stream_query_info
// 
// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info.g_file_output_stream_query_info.html
//
func (stream *FileOutputStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileOutputStream // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileInfo         // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_output_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_output_stream_query_info_async
// 
// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info_async.g_file_output_stream_query_info_async.html
//
func (stream *FileOutputStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileOutputStream  // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_output_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_output_stream_query_info_finish
// 
// see also https://docs.gtk.org/gio/method.g_file_output_stream_query_info_finish.g_file_output_stream_query_info_finish.html
//
func (stream *FileOutputStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileOutputStream // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileInfo         // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_output_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileOutputStreamOverrides[Instance FileOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.can_seek.html
	CanSeek func(Instance) bool
	// // CanTruncate allows you to override the implementation of the virtual method can_truncate.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.can_truncate.html
	CanTruncate func(Instance) bool
	// // GetEtag allows you to override the implementation of the virtual method get_etag.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.get_etag.html
	GetEtag func(Instance) string
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info.html
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info_finish.html
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.seek.html
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.tell.html
	Tell func(Instance) int64
	// // TruncateFn allows you to override the implementation of the virtual method truncate_fn.
	// 
	// see also https://docs.gtk.org/gio/method.FileOutputStream.truncate_fn.html
	TruncateFn func(Instance, int64, Cancellable) (bool, error)
}

// UnsafeApplyFileOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileOutputStreamOverrides[Instance FileOutputStream](gclass unsafe.Pointer, overrides FileOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)

	pclass := (*C.GFileOutputStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileOutputStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_can_seek",
			func(carg0 *C.GFileOutputStream) (cret C.gboolean) {
				var stream Instance // go GFileOutputStream subclass
				var goret  bool     // return

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._goglib_gio2_FileOutputStream_can_truncate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_can_truncate",
			func(carg0 *C.GFileOutputStream) (cret C.gboolean) {
				var stream Instance // go GFileOutputStream subclass
				var goret  bool     // return

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanTruncate(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetEtag != nil {
		pclass.get_etag = (*[0]byte)(C._goglib_gio2_FileOutputStream_get_etag)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_get_etag",
			func(carg0 *C.GFileOutputStream) (cret *C.char) {
				var stream Instance // go GFileOutputStream subclass
				var goret  string   // return, full, string, nullable-string

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetEtag(stream)

				if goret != "" {
					cret = (*C.char)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileOutputStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_query_info",
			func(carg0 *C.GFileOutputStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileOutputStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileOutputStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_query_info_finish",
			func(carg0 *C.GFileOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileOutputStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_seek",
			func(carg0 *C.GFileOutputStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileOutputStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileOutputStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_tell",
			func(carg0 *C.GFileOutputStream) (cret C.goffset) {
				var stream Instance // go GFileOutputStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._goglib_gio2_FileOutputStream_truncate_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_truncate_fn",
			func(carg0 *C.GFileOutputStream, carg1 C.goffset, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GFileOutputStream subclass
				var size        int64       // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				size = int64(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.TruncateFn(stream, size, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileOutputStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.can_seek.html
func (stream *FileOutputStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileOutputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentCanTruncate calls the default implementations of the `GFileOutputStream.can_truncate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.can_truncate.html
func (stream *FileOutputStreamInstance) ParentCanTruncate() bool {
	var carg0 *C.GFileOutputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_can_truncate(unsafe.Pointer(parentclass.can_truncate), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetEtag calls the default implementations of the `GFileOutputStream.get_etag` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.get_etag.html
func (stream *FileOutputStreamInstance) ParentGetEtag() string {
	var carg0 *C.GFileOutputStream
	var cret  *C.char // return, full, string, nullable-string

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_get_etag(unsafe.Pointer(parentclass.get_etag), carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileOutputStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info.html
func (stream *FileOutputStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileOutputStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileOutputStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.query_info_finish.html
func (stream *FileOutputStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileOutputStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileOutputStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.seek.html
func (stream *FileOutputStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileOutputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileOutputStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.tell.html
func (stream *FileOutputStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileOutputStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// ParentTruncateFn calls the default implementations of the `GFileOutputStream.truncate_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.FileOutputStream.truncate_fn.html
func (stream *FileOutputStreamInstance) ParentTruncateFn(size int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileOutputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = C.goffset(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_truncate_fn(unsafe.Pointer(parentclass.truncate_fn), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileOutputStreamSubClass is used to register a go subclass of GFileOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileOutputStreamSubClass[InstanceT FileOutputStream](
		name string,
		classInit func(class *FileOutputStreamClass),
		constructor func() InstanceT,
		overrides FileOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileOutputStream,
		UnsafeFileOutputStreamClassFromGlibBorrow,
		UnsafeApplyFileOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileOutputStream(obj)
		},
		interfaceInits...,
	)
}

// FilterInputStreamInstance is the instance type used by all types extending GFilterInputStream. It is used internally by the bindings. Users should use the interface [FilterInputStream] instead.
type FilterInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
}

var _ FilterInputStream = (*FilterInputStreamInstance)(nil)

// FilterInputStream wraps GFilterInputStream
// 
// see also https://docs.gtk.org/gio/class.FilterInputStream.html
//
type FilterInputStream interface {
	InputStream
	upcastToGFilterInputStream() *FilterInputStreamInstance

	// GetBaseStream wraps g_filter_input_stream_get_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_input_stream_get_base_stream.g_filter_input_stream_get_base_stream.html
	//
	GetBaseStream() InputStream
	// GetCloseBaseStream wraps g_filter_input_stream_get_close_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_input_stream_get_close_base_stream.g_filter_input_stream_get_close_base_stream.html
	//
	GetCloseBaseStream() bool
	// SetCloseBaseStream wraps g_filter_input_stream_set_close_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_input_stream_set_close_base_stream.g_filter_input_stream_set_close_base_stream.html
	//
	SetCloseBaseStream(bool)

	// chain up virtual methods:
}

func unsafeWrapFilterInputStream(base *gobject.ObjectInstance) *FilterInputStreamInstance {
	return &FilterInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilterInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterInputStream(inst)
		},
	)
}

func marshalFilterInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilterInputStreamFromGlibNone is used to convert raw GFilterInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibNone(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FilterInputStream)
}

// UnsafeFilterInputStreamFromGlibFull is used to convert raw GFilterInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibFull(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FilterInputStream)
}

// UnsafeFilterInputStreamFromGlibBorrow is used to convert raw GFilterInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibBorrow(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilterInputStream)
}

func (f *FilterInputStreamInstance) upcastToGFilterInputStream() *FilterInputStreamInstance {
	return f
}

// UnsafeFilterInputStreamToGlibNone is used to convert the instance to it's C value GFilterInputStream. This is used by the bindings internally.
func UnsafeFilterInputStreamToGlibNone(c FilterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilterInputStreamToGlibFull is used to convert the instance to it's C value GFilterInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamToGlibFull(c FilterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetBaseStream wraps g_filter_input_stream_get_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_input_stream_get_base_stream.g_filter_input_stream_get_base_stream.html
//
func (stream *FilterInputStreamInstance) GetBaseStream() InputStream {
	var carg0 *C.GFilterInputStream // in, none, converted
	var cret  *C.GInputStream       // return, none, converted

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))

	cret = C.g_filter_input_stream_get_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCloseBaseStream wraps g_filter_input_stream_get_close_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_input_stream_get_close_base_stream.g_filter_input_stream_get_close_base_stream.html
//
func (stream *FilterInputStreamInstance) GetCloseBaseStream() bool {
	var carg0 *C.GFilterInputStream // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))

	cret = C.g_filter_input_stream_get_close_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetCloseBaseStream wraps g_filter_input_stream_set_close_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_input_stream_set_close_base_stream.g_filter_input_stream_set_close_base_stream.html
//
func (stream *FilterInputStreamInstance) SetCloseBaseStream(closeBase bool) {
	var carg0 *C.GFilterInputStream // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))
	if closeBase {
		carg1 = C.TRUE
	}

	C.g_filter_input_stream_set_close_base_stream(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// FilterInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilterInputStreamOverrides[Instance FilterInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

}

// UnsafeApplyFilterInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilterInputStreamOverrides[Instance FilterInputStream](gclass unsafe.Pointer, overrides FilterInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)
}

// RegisterFilterInputStreamSubClass is used to register a go subclass of GFilterInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilterInputStreamSubClass[InstanceT FilterInputStream](
		name string,
		classInit func(class *FilterInputStreamClass),
		constructor func() InstanceT,
		overrides FilterInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilterInputStream,
		UnsafeFilterInputStreamClassFromGlibBorrow,
		UnsafeApplyFilterInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterInputStream(obj)
		},
		interfaceInits...,
	)
}

// FilterOutputStreamInstance is the instance type used by all types extending GFilterOutputStream. It is used internally by the bindings. Users should use the interface [FilterOutputStream] instead.
type FilterOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
}

var _ FilterOutputStream = (*FilterOutputStreamInstance)(nil)

// FilterOutputStream wraps GFilterOutputStream
// 
// see also https://docs.gtk.org/gio/class.FilterOutputStream.html
//
type FilterOutputStream interface {
	OutputStream
	upcastToGFilterOutputStream() *FilterOutputStreamInstance

	// GetBaseStream wraps g_filter_output_stream_get_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_output_stream_get_base_stream.g_filter_output_stream_get_base_stream.html
	//
	GetBaseStream() OutputStream
	// GetCloseBaseStream wraps g_filter_output_stream_get_close_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_output_stream_get_close_base_stream.g_filter_output_stream_get_close_base_stream.html
	//
	GetCloseBaseStream() bool
	// SetCloseBaseStream wraps g_filter_output_stream_set_close_base_stream
	// 
	// see also https://docs.gtk.org/gio/method.g_filter_output_stream_set_close_base_stream.g_filter_output_stream_set_close_base_stream.html
	//
	SetCloseBaseStream(bool)

	// chain up virtual methods:
}

func unsafeWrapFilterOutputStream(base *gobject.ObjectInstance) *FilterOutputStreamInstance {
	return &FilterOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilterOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterOutputStream(inst)
		},
	)
}

func marshalFilterOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilterOutputStreamFromGlibNone is used to convert raw GFilterOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibNone(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FilterOutputStream)
}

// UnsafeFilterOutputStreamFromGlibFull is used to convert raw GFilterOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibFull(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FilterOutputStream)
}

// UnsafeFilterOutputStreamFromGlibBorrow is used to convert raw GFilterOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibBorrow(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilterOutputStream)
}

func (f *FilterOutputStreamInstance) upcastToGFilterOutputStream() *FilterOutputStreamInstance {
	return f
}

// UnsafeFilterOutputStreamToGlibNone is used to convert the instance to it's C value GFilterOutputStream. This is used by the bindings internally.
func UnsafeFilterOutputStreamToGlibNone(c FilterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilterOutputStreamToGlibFull is used to convert the instance to it's C value GFilterOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamToGlibFull(c FilterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetBaseStream wraps g_filter_output_stream_get_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_output_stream_get_base_stream.g_filter_output_stream_get_base_stream.html
//
func (stream *FilterOutputStreamInstance) GetBaseStream() OutputStream {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var cret  *C.GOutputStream       // return, none, converted

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))

	cret = C.g_filter_output_stream_get_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCloseBaseStream wraps g_filter_output_stream_get_close_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_output_stream_get_close_base_stream.g_filter_output_stream_get_close_base_stream.html
//
func (stream *FilterOutputStreamInstance) GetCloseBaseStream() bool {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var cret  C.gboolean             // return

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))

	cret = C.g_filter_output_stream_get_close_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetCloseBaseStream wraps g_filter_output_stream_set_close_base_stream
// 
// see also https://docs.gtk.org/gio/method.g_filter_output_stream_set_close_base_stream.g_filter_output_stream_set_close_base_stream.html
//
func (stream *FilterOutputStreamInstance) SetCloseBaseStream(closeBase bool) {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var carg1 C.gboolean             // in

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))
	if closeBase {
		carg1 = C.TRUE
	}

	C.g_filter_output_stream_set_close_base_stream(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// FilterOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilterOutputStreamOverrides[Instance FilterOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

}

// UnsafeApplyFilterOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilterOutputStreamOverrides[Instance FilterOutputStream](gclass unsafe.Pointer, overrides FilterOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)
}

// RegisterFilterOutputStreamSubClass is used to register a go subclass of GFilterOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilterOutputStreamSubClass[InstanceT FilterOutputStream](
		name string,
		classInit func(class *FilterOutputStreamClass),
		constructor func() InstanceT,
		overrides FilterOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilterOutputStream,
		UnsafeFilterOutputStreamClassFromGlibBorrow,
		UnsafeApplyFilterOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterOutputStream(obj)
		},
		interfaceInits...,
	)
}

// InetSocketAddressInstance is the instance type used by all types extending GInetSocketAddress. It is used internally by the bindings. Users should use the interface [InetSocketAddress] instead.
type InetSocketAddressInstance struct {
	_ [0]func() // equal guard
	SocketAddressInstance
	// implemented interfaces:
	SocketConnectableInstance
}

var _ InetSocketAddress = (*InetSocketAddressInstance)(nil)

// InetSocketAddress wraps GInetSocketAddress
// 
// see also https://docs.gtk.org/gio/class.InetSocketAddress.html
//
type InetSocketAddress interface {
	SocketAddress
	SocketConnectable
	upcastToGInetSocketAddress() *InetSocketAddressInstance

	// GetAddress wraps g_inet_socket_address_get_address
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_address.g_inet_socket_address_get_address.html
	//
	GetAddress() InetAddress
	// GetFlowinfo wraps g_inet_socket_address_get_flowinfo
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_flowinfo.g_inet_socket_address_get_flowinfo.html
	//
	GetFlowinfo() uint32
	// GetPort wraps g_inet_socket_address_get_port
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_port.g_inet_socket_address_get_port.html
	//
	GetPort() uint16
	// GetScopeID wraps g_inet_socket_address_get_scope_id
	// 
	// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_scope_id.g_inet_socket_address_get_scope_id.html
	//
	GetScopeID() uint32

	// chain up virtual methods:
}

func unsafeWrapInetSocketAddress(base *gobject.ObjectInstance) *InetSocketAddressInstance {
	return &InetSocketAddressInstance{
		SocketAddressInstance: SocketAddressInstance{
			ObjectInstance: *base,
		},
		SocketConnectableInstance: SocketConnectableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetSocketAddress(inst)
		},
	)
}

func marshalInetSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetSocketAddressFromGlibNone is used to convert raw GInetSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibNone(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(InetSocketAddress)
}

// UnsafeInetSocketAddressFromGlibFull is used to convert raw GInetSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibFull(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(InetSocketAddress)
}

// UnsafeInetSocketAddressFromGlibBorrow is used to convert raw GInetSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibBorrow(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetSocketAddress)
}

func (i *InetSocketAddressInstance) upcastToGInetSocketAddress() *InetSocketAddressInstance {
	return i
}

// UnsafeInetSocketAddressToGlibNone is used to convert the instance to it's C value GInetSocketAddress. This is used by the bindings internally.
func UnsafeInetSocketAddressToGlibNone(c InetSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetSocketAddressToGlibFull is used to convert the instance to it's C value GInetSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressToGlibFull(c InetSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetSocketAddress wraps g_inet_socket_address_new
// 
// see also https://docs.gtk.org/gio/func.g_inet_socket_address_new.html
//
func NewInetSocketAddress(address InetAddress, port uint16) SocketAddress {
	var carg1 *C.GInetAddress   // in, none, converted
	var carg2 C.guint16         // in, none, casted
	var cret  *C.GSocketAddress // return, full, converted

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	carg2 = C.guint16(port)

	cret = C.g_inet_socket_address_new(carg1, carg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var goret SocketAddress

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewInetSocketAddressFromString wraps g_inet_socket_address_new_from_string
// 
// see also https://docs.gtk.org/gio/func.g_inet_socket_address_new_from_string.html
//
func NewInetSocketAddressFromString(address string, port uint) SocketAddress {
	var carg1 *C.char           // in, none, string
	var carg2 C.guint           // in, none, casted
	var cret  *C.GSocketAddress // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(port)

	cret = C.g_inet_socket_address_new_from_string(carg1, carg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var goret SocketAddress

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetAddress wraps g_inet_socket_address_get_address
// 
// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_address.g_inet_socket_address_get_address.html
//
func (address *InetSocketAddressInstance) GetAddress() InetAddress {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  *C.GInetAddress       // return, none, converted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_address(carg0)
	runtime.KeepAlive(address)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFlowinfo wraps g_inet_socket_address_get_flowinfo
// 
// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_flowinfo.g_inet_socket_address_get_flowinfo.html
//
func (address *InetSocketAddressInstance) GetFlowinfo() uint32 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint32             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_flowinfo(carg0)
	runtime.KeepAlive(address)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// GetPort wraps g_inet_socket_address_get_port
// 
// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_port.g_inet_socket_address_get_port.html
//
func (address *InetSocketAddressInstance) GetPort() uint16 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint16             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_port(carg0)
	runtime.KeepAlive(address)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetScopeID wraps g_inet_socket_address_get_scope_id
// 
// see also https://docs.gtk.org/gio/method.g_inet_socket_address_get_scope_id.g_inet_socket_address_get_scope_id.html
//
func (address *InetSocketAddressInstance) GetScopeID() uint32 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint32             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_scope_id(carg0)
	runtime.KeepAlive(address)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// InetSocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetSocketAddressOverrides[Instance InetSocketAddress] struct {
	// SocketAddressOverrides allows you to override virtual methods from the parent class SocketAddress
	SocketAddressOverrides[Instance]

}

// UnsafeApplyInetSocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetSocketAddressOverrides[Instance InetSocketAddress](gclass unsafe.Pointer, overrides InetSocketAddressOverrides[Instance]) {
	UnsafeApplySocketAddressOverrides(gclass, overrides.SocketAddressOverrides)
}

// RegisterInetSocketAddressSubClass is used to register a go subclass of GInetSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetSocketAddressSubClass[InstanceT InetSocketAddress](
		name string,
		classInit func(class *InetSocketAddressClass),
		constructor func() InstanceT,
		overrides InetSocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetSocketAddress,
		UnsafeInetSocketAddressClassFromGlibBorrow,
		UnsafeApplyInetSocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// MemoryOutputStreamInstance is the instance type used by all types extending GMemoryOutputStream. It is used internally by the bindings. Users should use the interface [MemoryOutputStream] instead.
type MemoryOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
	// implemented interfaces:
	PollableOutputStreamInstance
	SeekableInstance
}

var _ MemoryOutputStream = (*MemoryOutputStreamInstance)(nil)

// MemoryOutputStream wraps GMemoryOutputStream
// 
// see also https://docs.gtk.org/gio/class.MemoryOutputStream.html
//
type MemoryOutputStream interface {
	OutputStream
	PollableOutputStream
	Seekable
	upcastToGMemoryOutputStream() *MemoryOutputStreamInstance

	// GetDataSize wraps g_memory_output_stream_get_data_size
	// 
	// see also https://docs.gtk.org/gio/method.g_memory_output_stream_get_data_size.g_memory_output_stream_get_data_size.html
	//
	GetDataSize() uint
	// GetSize wraps g_memory_output_stream_get_size
	// 
	// see also https://docs.gtk.org/gio/method.g_memory_output_stream_get_size.g_memory_output_stream_get_size.html
	//
	GetSize() uint
	// StealAsBytes wraps g_memory_output_stream_steal_as_bytes
	// 
	// see also https://docs.gtk.org/gio/method.g_memory_output_stream_steal_as_bytes.g_memory_output_stream_steal_as_bytes.html
	//
	StealAsBytes() *glib.Bytes

	// chain up virtual methods:
}

func unsafeWrapMemoryOutputStream(base *gobject.ObjectInstance) *MemoryOutputStreamInstance {
	return &MemoryOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
		PollableOutputStreamInstance: PollableOutputStreamInstance{
			Instance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMemoryOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryOutputStream(inst)
		},
	)
}

func marshalMemoryOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMemoryOutputStreamFromGlibNone is used to convert raw GMemoryOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibNone(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryOutputStream)
}

// UnsafeMemoryOutputStreamFromGlibFull is used to convert raw GMemoryOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibFull(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryOutputStream)
}

// UnsafeMemoryOutputStreamFromGlibBorrow is used to convert raw GMemoryOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibBorrow(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryOutputStream)
}

func (m *MemoryOutputStreamInstance) upcastToGMemoryOutputStream() *MemoryOutputStreamInstance {
	return m
}

// UnsafeMemoryOutputStreamToGlibNone is used to convert the instance to it's C value GMemoryOutputStream. This is used by the bindings internally.
func UnsafeMemoryOutputStreamToGlibNone(c MemoryOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMemoryOutputStreamToGlibFull is used to convert the instance to it's C value GMemoryOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamToGlibFull(c MemoryOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMemoryOutputStreamResizable wraps g_memory_output_stream_new_resizable
// 
// see also https://docs.gtk.org/gio/func.g_memory_output_stream_new_resizable.html
//
func NewMemoryOutputStreamResizable() OutputStream {
	var cret *C.GOutputStream // return, full, converted

	cret = C.g_memory_output_stream_new_resizable()

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDataSize wraps g_memory_output_stream_get_data_size
// 
// see also https://docs.gtk.org/gio/method.g_memory_output_stream_get_data_size.g_memory_output_stream_get_data_size.html
//
func (ostream *MemoryOutputStreamInstance) GetDataSize() uint {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  C.gsize                // return, none, casted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_get_data_size(carg0)
	runtime.KeepAlive(ostream)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetSize wraps g_memory_output_stream_get_size
// 
// see also https://docs.gtk.org/gio/method.g_memory_output_stream_get_size.g_memory_output_stream_get_size.html
//
func (ostream *MemoryOutputStreamInstance) GetSize() uint {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  C.gsize                // return, none, casted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_get_size(carg0)
	runtime.KeepAlive(ostream)

	var goret uint

	goret = uint(cret)

	return goret
}

// StealAsBytes wraps g_memory_output_stream_steal_as_bytes
// 
// see also https://docs.gtk.org/gio/method.g_memory_output_stream_steal_as_bytes.g_memory_output_stream_steal_as_bytes.html
//
func (ostream *MemoryOutputStreamInstance) StealAsBytes() *glib.Bytes {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  *C.GBytes              // return, full, converted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_steal_as_bytes(carg0)
	runtime.KeepAlive(ostream)

	var goret *glib.Bytes

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// MemoryOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MemoryOutputStreamOverrides[Instance MemoryOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

}

// UnsafeApplyMemoryOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMemoryOutputStreamOverrides[Instance MemoryOutputStream](gclass unsafe.Pointer, overrides MemoryOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)
}

// RegisterMemoryOutputStreamSubClass is used to register a go subclass of GMemoryOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMemoryOutputStreamSubClass[InstanceT MemoryOutputStream](
		name string,
		classInit func(class *MemoryOutputStreamClass),
		constructor func() InstanceT,
		overrides MemoryOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMemoryOutputStream,
		UnsafeMemoryOutputStreamClassFromGlibBorrow,
		UnsafeApplyMemoryOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryOutputStream(obj)
		},
		interfaceInits...,
	)
}

// MenuInstance is the instance type used by all types extending GMenu. It is used internally by the bindings. Users should use the interface [Menu] instead.
type MenuInstance struct {
	_ [0]func() // equal guard
	MenuModelInstance
}

var _ Menu = (*MenuInstance)(nil)

// Menu wraps GMenu
// 
// see also https://docs.gtk.org/gio/class.Menu.html
//
type Menu interface {
	MenuModel
	upcastToGMenu() *MenuInstance

	// Append wraps g_menu_append
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_append.g_menu_append.html
	//
	Append(string, string)
	// AppendItem wraps g_menu_append_item
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_append_item.g_menu_append_item.html
	//
	AppendItem(MenuItem)
	// AppendSection wraps g_menu_append_section
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_append_section.g_menu_append_section.html
	//
	AppendSection(string, MenuModel)
	// AppendSubmenu wraps g_menu_append_submenu
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_append_submenu.g_menu_append_submenu.html
	//
	AppendSubmenu(string, MenuModel)
	// Freeze wraps g_menu_freeze
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_freeze.g_menu_freeze.html
	//
	Freeze()
	// Insert wraps g_menu_insert
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_insert.g_menu_insert.html
	//
	Insert(int32, string, string)
	// InsertItem wraps g_menu_insert_item
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_insert_item.g_menu_insert_item.html
	//
	InsertItem(int32, MenuItem)
	// InsertSection wraps g_menu_insert_section
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_insert_section.g_menu_insert_section.html
	//
	InsertSection(int32, string, MenuModel)
	// InsertSubmenu wraps g_menu_insert_submenu
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_insert_submenu.g_menu_insert_submenu.html
	//
	InsertSubmenu(int32, string, MenuModel)
	// Prepend wraps g_menu_prepend
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_prepend.g_menu_prepend.html
	//
	Prepend(string, string)
	// PrependItem wraps g_menu_prepend_item
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_prepend_item.g_menu_prepend_item.html
	//
	PrependItem(MenuItem)
	// PrependSection wraps g_menu_prepend_section
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_prepend_section.g_menu_prepend_section.html
	//
	PrependSection(string, MenuModel)
	// PrependSubmenu wraps g_menu_prepend_submenu
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_prepend_submenu.g_menu_prepend_submenu.html
	//
	PrependSubmenu(string, MenuModel)
	// Remove wraps g_menu_remove
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_remove.g_menu_remove.html
	//
	Remove(int32)
	// RemoveAll wraps g_menu_remove_all
	// 
	// see also https://docs.gtk.org/gio/method.g_menu_remove_all.g_menu_remove_all.html
	//
	RemoveAll()
}

func unsafeWrapMenu(base *gobject.ObjectInstance) *MenuInstance {
	return &MenuInstance{
		MenuModelInstance: MenuModelInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenu,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenu(inst)
		},
	)
}

func marshalMenuInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuFromGlibNone is used to convert raw GMenu pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuFromGlibNone(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibNone(c).(Menu)
}

// UnsafeMenuFromGlibFull is used to convert raw GMenu pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuFromGlibFull(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibFull(c).(Menu)
}

// UnsafeMenuFromGlibBorrow is used to convert raw GMenu pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuFromGlibBorrow(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Menu)
}

func (m *MenuInstance) upcastToGMenu() *MenuInstance {
	return m
}

// UnsafeMenuToGlibNone is used to convert the instance to it's C value GMenu. This is used by the bindings internally.
func UnsafeMenuToGlibNone(c Menu) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuToGlibFull is used to convert the instance to it's C value GMenu, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuToGlibFull(c Menu) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMenu wraps g_menu_new
// 
// see also https://docs.gtk.org/gio/func.g_menu_new.html
//
func NewMenu() Menu {
	var cret *C.GMenu // return, full, converted

	cret = C.g_menu_new()

	var goret Menu

	goret = UnsafeMenuFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Append wraps g_menu_append
// 
// see also https://docs.gtk.org/gio/method.g_menu_append.g_menu_append.html
//
func (menu *MenuInstance) Append(label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_menu_append(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// AppendItem wraps g_menu_append_item
// 
// see also https://docs.gtk.org/gio/method.g_menu_append_item.g_menu_append_item.html
//
func (menu *MenuInstance) AppendItem(item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_append_item(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// AppendSection wraps g_menu_append_section
// 
// see also https://docs.gtk.org/gio/method.g_menu_append_section.g_menu_append_section.html
//
func (menu *MenuInstance) AppendSection(label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_append_section(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// AppendSubmenu wraps g_menu_append_submenu
// 
// see also https://docs.gtk.org/gio/method.g_menu_append_submenu.g_menu_append_submenu.html
//
func (menu *MenuInstance) AppendSubmenu(label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_append_submenu(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Freeze wraps g_menu_freeze
// 
// see also https://docs.gtk.org/gio/method.g_menu_freeze.g_menu_freeze.html
//
func (menu *MenuInstance) Freeze() {
	var carg0 *C.GMenu // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))

	C.g_menu_freeze(carg0)
	runtime.KeepAlive(menu)
}

// Insert wraps g_menu_insert
// 
// see also https://docs.gtk.org/gio/method.g_menu_insert.g_menu_insert.html
//
func (menu *MenuInstance) Insert(position int32, label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 C.gint   // in, none, casted
	var carg2 *C.gchar // in, none, string, nullable-string
	var carg3 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if detailedAction != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg3))
	}

	C.g_menu_insert(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// InsertItem wraps g_menu_insert_item
// 
// see also https://docs.gtk.org/gio/method.g_menu_insert_item.g_menu_insert_item.html
//
func (menu *MenuInstance) InsertItem(position int32, item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 C.gint       // in, none, casted
	var carg2 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	carg2 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_insert_item(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(item)
}

// InsertSection wraps g_menu_insert_section
// 
// see also https://docs.gtk.org/gio/method.g_menu_insert_section.g_menu_insert_section.html
//
func (menu *MenuInstance) InsertSection(position int32, label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_insert_section(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// InsertSubmenu wraps g_menu_insert_submenu
// 
// see also https://docs.gtk.org/gio/method.g_menu_insert_submenu.g_menu_insert_submenu.html
//
func (menu *MenuInstance) InsertSubmenu(position int32, label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_insert_submenu(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Prepend wraps g_menu_prepend
// 
// see also https://docs.gtk.org/gio/method.g_menu_prepend.g_menu_prepend.html
//
func (menu *MenuInstance) Prepend(label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_menu_prepend(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// PrependItem wraps g_menu_prepend_item
// 
// see also https://docs.gtk.org/gio/method.g_menu_prepend_item.g_menu_prepend_item.html
//
func (menu *MenuInstance) PrependItem(item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_prepend_item(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// PrependSection wraps g_menu_prepend_section
// 
// see also https://docs.gtk.org/gio/method.g_menu_prepend_section.g_menu_prepend_section.html
//
func (menu *MenuInstance) PrependSection(label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_prepend_section(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// PrependSubmenu wraps g_menu_prepend_submenu
// 
// see also https://docs.gtk.org/gio/method.g_menu_prepend_submenu.g_menu_prepend_submenu.html
//
func (menu *MenuInstance) PrependSubmenu(label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_prepend_submenu(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Remove wraps g_menu_remove
// 
// see also https://docs.gtk.org/gio/method.g_menu_remove.g_menu_remove.html
//
func (menu *MenuInstance) Remove(position int32) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 C.gint   // in, none, casted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)

	C.g_menu_remove(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
}

// RemoveAll wraps g_menu_remove_all
// 
// see also https://docs.gtk.org/gio/method.g_menu_remove_all.g_menu_remove_all.html
//
func (menu *MenuInstance) RemoveAll() {
	var carg0 *C.GMenu // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))

	C.g_menu_remove_all(carg0)
	runtime.KeepAlive(menu)
}

// NativeSocketAddressInstance is the instance type used by all types extending GNativeSocketAddress. It is used internally by the bindings. Users should use the interface [NativeSocketAddress] instead.
type NativeSocketAddressInstance struct {
	_ [0]func() // equal guard
	SocketAddressInstance
	// implemented interfaces:
	SocketConnectableInstance
}

var _ NativeSocketAddress = (*NativeSocketAddressInstance)(nil)

// NativeSocketAddress wraps GNativeSocketAddress
// 
// see also https://docs.gtk.org/gio/class.NativeSocketAddress.html
//
type NativeSocketAddress interface {
	SocketAddress
	SocketConnectable
	upcastToGNativeSocketAddress() *NativeSocketAddressInstance

	// chain up virtual methods:
}

func unsafeWrapNativeSocketAddress(base *gobject.ObjectInstance) *NativeSocketAddressInstance {
	return &NativeSocketAddressInstance{
		SocketAddressInstance: SocketAddressInstance{
			ObjectInstance: *base,
		},
		SocketConnectableInstance: SocketConnectableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNativeSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeSocketAddress(inst)
		},
	)
}

func marshalNativeSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNativeSocketAddressFromGlibNone is used to convert raw GNativeSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibNone(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(NativeSocketAddress)
}

// UnsafeNativeSocketAddressFromGlibFull is used to convert raw GNativeSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibFull(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(NativeSocketAddress)
}

// UnsafeNativeSocketAddressFromGlibBorrow is used to convert raw GNativeSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibBorrow(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NativeSocketAddress)
}

func (n *NativeSocketAddressInstance) upcastToGNativeSocketAddress() *NativeSocketAddressInstance {
	return n
}

// UnsafeNativeSocketAddressToGlibNone is used to convert the instance to it's C value GNativeSocketAddress. This is used by the bindings internally.
func UnsafeNativeSocketAddressToGlibNone(c NativeSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNativeSocketAddressToGlibFull is used to convert the instance to it's C value GNativeSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressToGlibFull(c NativeSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NativeSocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NativeSocketAddressOverrides[Instance NativeSocketAddress] struct {
	// SocketAddressOverrides allows you to override virtual methods from the parent class SocketAddress
	SocketAddressOverrides[Instance]

}

// UnsafeApplyNativeSocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNativeSocketAddressOverrides[Instance NativeSocketAddress](gclass unsafe.Pointer, overrides NativeSocketAddressOverrides[Instance]) {
	UnsafeApplySocketAddressOverrides(gclass, overrides.SocketAddressOverrides)
}

// RegisterNativeSocketAddressSubClass is used to register a go subclass of GNativeSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNativeSocketAddressSubClass[InstanceT NativeSocketAddress](
		name string,
		classInit func(class *NativeSocketAddressClass),
		constructor func() InstanceT,
		overrides NativeSocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNativeSocketAddress,
		UnsafeNativeSocketAddressClassFromGlibBorrow,
		UnsafeApplyNativeSocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// NativeVolumeMonitorInstance is the instance type used by all types extending GNativeVolumeMonitor. It is used internally by the bindings. Users should use the interface [NativeVolumeMonitor] instead.
type NativeVolumeMonitorInstance struct {
	_ [0]func() // equal guard
	VolumeMonitorInstance
}

var _ NativeVolumeMonitor = (*NativeVolumeMonitorInstance)(nil)

// NativeVolumeMonitor wraps GNativeVolumeMonitor
// 
// see also https://docs.gtk.org/gio/class.NativeVolumeMonitor.html
type NativeVolumeMonitor interface {
	VolumeMonitor
	upcastToGNativeVolumeMonitor() *NativeVolumeMonitorInstance

	// chain up virtual methods:
}

func unsafeWrapNativeVolumeMonitor(base *gobject.ObjectInstance) *NativeVolumeMonitorInstance {
	return &NativeVolumeMonitorInstance{
		VolumeMonitorInstance: VolumeMonitorInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNativeVolumeMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeVolumeMonitor(inst)
		},
	)
}

func marshalNativeVolumeMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNativeVolumeMonitorFromGlibNone is used to convert raw GNativeVolumeMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibNone(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(NativeVolumeMonitor)
}

// UnsafeNativeVolumeMonitorFromGlibFull is used to convert raw GNativeVolumeMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibFull(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(NativeVolumeMonitor)
}

// UnsafeNativeVolumeMonitorFromGlibBorrow is used to convert raw GNativeVolumeMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibBorrow(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NativeVolumeMonitor)
}

func (n *NativeVolumeMonitorInstance) upcastToGNativeVolumeMonitor() *NativeVolumeMonitorInstance {
	return n
}

// UnsafeNativeVolumeMonitorToGlibNone is used to convert the instance to it's C value GNativeVolumeMonitor. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorToGlibNone(c NativeVolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNativeVolumeMonitorToGlibFull is used to convert the instance to it's C value GNativeVolumeMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorToGlibFull(c NativeVolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NativeVolumeMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NativeVolumeMonitorOverrides[Instance NativeVolumeMonitor] struct {
	// VolumeMonitorOverrides allows you to override virtual methods from the parent class VolumeMonitor
	VolumeMonitorOverrides[Instance]

}

// UnsafeApplyNativeVolumeMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNativeVolumeMonitorOverrides[Instance NativeVolumeMonitor](gclass unsafe.Pointer, overrides NativeVolumeMonitorOverrides[Instance]) {
	UnsafeApplyVolumeMonitorOverrides(gclass, overrides.VolumeMonitorOverrides)
}

// RegisterNativeVolumeMonitorSubClass is used to register a go subclass of GNativeVolumeMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNativeVolumeMonitorSubClass[InstanceT NativeVolumeMonitor](
		name string,
		classInit func(class *NativeVolumeMonitorClass),
		constructor func() InstanceT,
		overrides NativeVolumeMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNativeVolumeMonitor,
		UnsafeNativeVolumeMonitorClassFromGlibBorrow,
		UnsafeApplyNativeVolumeMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeVolumeMonitor(obj)
		},
		interfaceInits...,
	)
}

// ProxyAddressInstance is the instance type used by all types extending GProxyAddress. It is used internally by the bindings. Users should use the interface [ProxyAddress] instead.
type ProxyAddressInstance struct {
	_ [0]func() // equal guard
	InetSocketAddressInstance
}

var _ ProxyAddress = (*ProxyAddressInstance)(nil)

// ProxyAddress wraps GProxyAddress
// 
// see also https://docs.gtk.org/gio/class.ProxyAddress.html
//
type ProxyAddress interface {
	InetSocketAddress
	upcastToGProxyAddress() *ProxyAddressInstance

	// GetDestinationHostname wraps g_proxy_address_get_destination_hostname
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_hostname.g_proxy_address_get_destination_hostname.html
	//
	GetDestinationHostname() string
	// GetDestinationPort wraps g_proxy_address_get_destination_port
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_port.g_proxy_address_get_destination_port.html
	//
	GetDestinationPort() uint16
	// GetDestinationProtocol wraps g_proxy_address_get_destination_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_protocol.g_proxy_address_get_destination_protocol.html
	//
	GetDestinationProtocol() string
	// GetPassword wraps g_proxy_address_get_password
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_password.g_proxy_address_get_password.html
	//
	GetPassword() string
	// GetProtocol wraps g_proxy_address_get_protocol
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_protocol.g_proxy_address_get_protocol.html
	//
	GetProtocol() string
	// GetURI wraps g_proxy_address_get_uri
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_uri.g_proxy_address_get_uri.html
	//
	GetURI() string
	// GetUsername wraps g_proxy_address_get_username
	// 
	// see also https://docs.gtk.org/gio/method.g_proxy_address_get_username.g_proxy_address_get_username.html
	//
	GetUsername() string

	// chain up virtual methods:
}

func unsafeWrapProxyAddress(base *gobject.ObjectInstance) *ProxyAddressInstance {
	return &ProxyAddressInstance{
		InetSocketAddressInstance: InetSocketAddressInstance{
			SocketAddressInstance: SocketAddressInstance{
				ObjectInstance: *base,
			},
			SocketConnectableInstance: SocketConnectableInstance{
				Instance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeProxyAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddress(inst)
		},
	)
}

func marshalProxyAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeProxyAddressFromGlibNone is used to convert raw GProxyAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibNone(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyAddress)
}

// UnsafeProxyAddressFromGlibFull is used to convert raw GProxyAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibFull(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyAddress)
}

// UnsafeProxyAddressFromGlibBorrow is used to convert raw GProxyAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibBorrow(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyAddress)
}

func (p *ProxyAddressInstance) upcastToGProxyAddress() *ProxyAddressInstance {
	return p
}

// UnsafeProxyAddressToGlibNone is used to convert the instance to it's C value GProxyAddress. This is used by the bindings internally.
func UnsafeProxyAddressToGlibNone(c ProxyAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeProxyAddressToGlibFull is used to convert the instance to it's C value GProxyAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyAddressToGlibFull(c ProxyAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewProxyAddress wraps g_proxy_address_new
// 
// see also https://docs.gtk.org/gio/func.g_proxy_address_new.html
//
func NewProxyAddress(inetaddr InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) SocketAddress {
	var carg1 *C.GInetAddress   // in, none, converted
	var carg2 C.guint16         // in, none, casted
	var carg3 *C.gchar          // in, none, string
	var carg4 *C.gchar          // in, none, string
	var carg5 C.guint16         // in, none, casted
	var carg6 *C.gchar          // in, none, string, nullable-string
	var carg7 *C.gchar          // in, none, string, nullable-string
	var cret  *C.GSocketAddress // return, full, converted

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(inetaddr))
	carg2 = C.guint16(port)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(destHostname)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.guint16(destPort)
	if username != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if password != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg7))
	}

	cret = C.g_proxy_address_new(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(inetaddr)
	runtime.KeepAlive(port)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(destHostname)
	runtime.KeepAlive(destPort)
	runtime.KeepAlive(username)
	runtime.KeepAlive(password)

	var goret SocketAddress

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDestinationHostname wraps g_proxy_address_get_destination_hostname
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_hostname.g_proxy_address_get_destination_hostname.html
//
func (proxy *ProxyAddressInstance) GetDestinationHostname() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_hostname(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetDestinationPort wraps g_proxy_address_get_destination_port
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_port.g_proxy_address_get_destination_port.html
//
func (proxy *ProxyAddressInstance) GetDestinationPort() uint16 {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  C.guint16        // return, none, casted

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_port(carg0)
	runtime.KeepAlive(proxy)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetDestinationProtocol wraps g_proxy_address_get_destination_protocol
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_destination_protocol.g_proxy_address_get_destination_protocol.html
//
func (proxy *ProxyAddressInstance) GetDestinationProtocol() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_protocol(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPassword wraps g_proxy_address_get_password
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_password.g_proxy_address_get_password.html
//
func (proxy *ProxyAddressInstance) GetPassword() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_password(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetProtocol wraps g_proxy_address_get_protocol
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_protocol.g_proxy_address_get_protocol.html
//
func (proxy *ProxyAddressInstance) GetProtocol() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_protocol(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetURI wraps g_proxy_address_get_uri
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_uri.g_proxy_address_get_uri.html
//
func (proxy *ProxyAddressInstance) GetURI() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_uri(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUsername wraps g_proxy_address_get_username
// 
// see also https://docs.gtk.org/gio/method.g_proxy_address_get_username.g_proxy_address_get_username.html
//
func (proxy *ProxyAddressInstance) GetUsername() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_username(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ProxyAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ProxyAddressOverrides[Instance ProxyAddress] struct {
	// InetSocketAddressOverrides allows you to override virtual methods from the parent class InetSocketAddress
	InetSocketAddressOverrides[Instance]

}

// UnsafeApplyProxyAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyProxyAddressOverrides[Instance ProxyAddress](gclass unsafe.Pointer, overrides ProxyAddressOverrides[Instance]) {
	UnsafeApplyInetSocketAddressOverrides(gclass, overrides.InetSocketAddressOverrides)
}

// RegisterProxyAddressSubClass is used to register a go subclass of GProxyAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterProxyAddressSubClass[InstanceT ProxyAddress](
		name string,
		classInit func(class *ProxyAddressClass),
		constructor func() InstanceT,
		overrides ProxyAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeProxyAddress,
		UnsafeProxyAddressClassFromGlibBorrow,
		UnsafeApplyProxyAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddress(obj)
		},
		interfaceInits...,
	)
}

// ProxyAddressEnumeratorInstance is the instance type used by all types extending GProxyAddressEnumerator. It is used internally by the bindings. Users should use the interface [ProxyAddressEnumerator] instead.
type ProxyAddressEnumeratorInstance struct {
	_ [0]func() // equal guard
	SocketAddressEnumeratorInstance
}

var _ ProxyAddressEnumerator = (*ProxyAddressEnumeratorInstance)(nil)

// ProxyAddressEnumerator wraps GProxyAddressEnumerator
// 
// see also https://docs.gtk.org/gio/class.ProxyAddressEnumerator.html
//
type ProxyAddressEnumerator interface {
	SocketAddressEnumerator
	upcastToGProxyAddressEnumerator() *ProxyAddressEnumeratorInstance

	// chain up virtual methods:
}

func unsafeWrapProxyAddressEnumerator(base *gobject.ObjectInstance) *ProxyAddressEnumeratorInstance {
	return &ProxyAddressEnumeratorInstance{
		SocketAddressEnumeratorInstance: SocketAddressEnumeratorInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeProxyAddressEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddressEnumerator(inst)
		},
	)
}

func marshalProxyAddressEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeProxyAddressEnumeratorFromGlibNone is used to convert raw GProxyAddressEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibNone(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyAddressEnumerator)
}

// UnsafeProxyAddressEnumeratorFromGlibFull is used to convert raw GProxyAddressEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibFull(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyAddressEnumerator)
}

// UnsafeProxyAddressEnumeratorFromGlibBorrow is used to convert raw GProxyAddressEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibBorrow(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyAddressEnumerator)
}

func (p *ProxyAddressEnumeratorInstance) upcastToGProxyAddressEnumerator() *ProxyAddressEnumeratorInstance {
	return p
}

// UnsafeProxyAddressEnumeratorToGlibNone is used to convert the instance to it's C value GProxyAddressEnumerator. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorToGlibNone(c ProxyAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeProxyAddressEnumeratorToGlibFull is used to convert the instance to it's C value GProxyAddressEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorToGlibFull(c ProxyAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ProxyAddressEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ProxyAddressEnumeratorOverrides[Instance ProxyAddressEnumerator] struct {
	// SocketAddressEnumeratorOverrides allows you to override virtual methods from the parent class SocketAddressEnumerator
	SocketAddressEnumeratorOverrides[Instance]

}

// UnsafeApplyProxyAddressEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyProxyAddressEnumeratorOverrides[Instance ProxyAddressEnumerator](gclass unsafe.Pointer, overrides ProxyAddressEnumeratorOverrides[Instance]) {
	UnsafeApplySocketAddressEnumeratorOverrides(gclass, overrides.SocketAddressEnumeratorOverrides)
}

// RegisterProxyAddressEnumeratorSubClass is used to register a go subclass of GProxyAddressEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterProxyAddressEnumeratorSubClass[InstanceT ProxyAddressEnumerator](
		name string,
		classInit func(class *ProxyAddressEnumeratorClass),
		constructor func() InstanceT,
		overrides ProxyAddressEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeProxyAddressEnumerator,
		UnsafeProxyAddressEnumeratorClassFromGlibBorrow,
		UnsafeApplyProxyAddressEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddressEnumerator(obj)
		},
		interfaceInits...,
	)
}

// BufferedInputStreamInstance is the instance type used by all types extending GBufferedInputStream. It is used internally by the bindings. Users should use the interface [BufferedInputStream] instead.
type BufferedInputStreamInstance struct {
	_ [0]func() // equal guard
	FilterInputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ BufferedInputStream = (*BufferedInputStreamInstance)(nil)

// BufferedInputStream wraps GBufferedInputStream
// 
// see also https://docs.gtk.org/gio/class.BufferedInputStream.html
//
type BufferedInputStream interface {
	FilterInputStream
	Seekable
	upcastToGBufferedInputStream() *BufferedInputStreamInstance

	// Fill wraps g_buffered_input_stream_fill
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill.g_buffered_input_stream_fill.html
	//
	Fill(int, Cancellable) (int, error)
	// FillAsync wraps g_buffered_input_stream_fill_async
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill_async.g_buffered_input_stream_fill_async.html
	//
	FillAsync(int, int32, Cancellable, AsyncReadyCallback)
	// FillFinish wraps g_buffered_input_stream_fill_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill_finish.g_buffered_input_stream_fill_finish.html
	//
	FillFinish(AsyncResult) (int, error)
	// GetAvailable wraps g_buffered_input_stream_get_available
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_get_available.g_buffered_input_stream_get_available.html
	//
	GetAvailable() uint
	// GetBufferSize wraps g_buffered_input_stream_get_buffer_size
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_get_buffer_size.g_buffered_input_stream_get_buffer_size.html
	//
	GetBufferSize() uint
	// Peek wraps g_buffered_input_stream_peek
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_peek.g_buffered_input_stream_peek.html
	//
	Peek([]byte, uint) uint
	// PeekBuffer wraps g_buffered_input_stream_peek_buffer
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_peek_buffer.g_buffered_input_stream_peek_buffer.html
	//
	PeekBuffer() (uint, []byte)
	// ReadByte wraps g_buffered_input_stream_read_byte
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_read_byte.g_buffered_input_stream_read_byte.html
	//
	ReadByte(Cancellable) (int32, error)
	// SetBufferSize wraps g_buffered_input_stream_set_buffer_size
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_set_buffer_size.g_buffered_input_stream_set_buffer_size.html
	//
	SetBufferSize(uint)

	// chain up virtual methods:

	// ParentFill calls the default implementations of the `GBufferedInputStream.fill` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill.html
	ParentFill(count int, cancellable Cancellable) (int, error)
	// ParentFillFinish calls the default implementations of the `GBufferedInputStream.fill_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill_finish.html
	ParentFillFinish(result AsyncResult) (int, error)
}

func unsafeWrapBufferedInputStream(base *gobject.ObjectInstance) *BufferedInputStreamInstance {
	return &BufferedInputStreamInstance{
		FilterInputStreamInstance: FilterInputStreamInstance{
			InputStreamInstance: InputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBufferedInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedInputStream(inst)
		},
	)
}

func marshalBufferedInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBufferedInputStreamFromGlibNone is used to convert raw GBufferedInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibNone(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(BufferedInputStream)
}

// UnsafeBufferedInputStreamFromGlibFull is used to convert raw GBufferedInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibFull(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(BufferedInputStream)
}

// UnsafeBufferedInputStreamFromGlibBorrow is used to convert raw GBufferedInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibBorrow(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BufferedInputStream)
}

func (b *BufferedInputStreamInstance) upcastToGBufferedInputStream() *BufferedInputStreamInstance {
	return b
}

// UnsafeBufferedInputStreamToGlibNone is used to convert the instance to it's C value GBufferedInputStream. This is used by the bindings internally.
func UnsafeBufferedInputStreamToGlibNone(c BufferedInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBufferedInputStreamToGlibFull is used to convert the instance to it's C value GBufferedInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamToGlibFull(c BufferedInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBufferedInputStream wraps g_buffered_input_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_buffered_input_stream_new.html
//
func NewBufferedInputStream(baseStream InputStream) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))

	cret = C.g_buffered_input_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewBufferedInputStreamSized wraps g_buffered_input_stream_new_sized
// 
// see also https://docs.gtk.org/gio/func.g_buffered_input_stream_new_sized.html
//
func NewBufferedInputStreamSized(baseStream InputStream, size uint) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 C.gsize         // in, none, casted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))
	carg2 = C.gsize(size)

	cret = C.g_buffered_input_stream_new_sized(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Fill wraps g_buffered_input_stream_fill
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill.g_buffered_input_stream_fill.html
//
func (stream *BufferedInputStreamInstance) Fill(count int, cancellable Cancellable) (int, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gssize                // in, none, casted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.gssize                // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_buffered_input_stream_fill(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FillAsync wraps g_buffered_input_stream_fill_async
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill_async.g_buffered_input_stream_fill_async.html
//
func (stream *BufferedInputStreamInstance) FillAsync(count int, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gssize                // in, none, casted
	var carg2 C.int                   // in, none, casted
	var carg3 *C.GCancellable         // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback   // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer              // implicit

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_buffered_input_stream_fill_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FillFinish wraps g_buffered_input_stream_fill_finish
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_fill_finish.g_buffered_input_stream_fill_finish.html
//
func (stream *BufferedInputStreamInstance) FillFinish(result AsyncResult) (int, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.gssize                // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_buffered_input_stream_fill_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetAvailable wraps g_buffered_input_stream_get_available
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_get_available.g_buffered_input_stream_get_available.html
//
func (stream *BufferedInputStreamInstance) GetAvailable() uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_get_available(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetBufferSize wraps g_buffered_input_stream_get_buffer_size
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_get_buffer_size.g_buffered_input_stream_get_buffer_size.html
//
func (stream *BufferedInputStreamInstance) GetBufferSize() uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_get_buffer_size(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// Peek wraps g_buffered_input_stream_peek
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_peek.g_buffered_input_stream_peek.html
//
func (stream *BufferedInputStreamInstance) Peek(buffer []byte, offset uint) uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 unsafe.Pointer          // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg2 C.gsize                 // in, none, casted
	var carg3 C.gsize                 // implicit
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg2 = C.gsize(offset)

	cret = C.g_buffered_input_stream_peek(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)

	var goret uint

	goret = uint(cret)

	return goret
}

// PeekBuffer wraps g_buffered_input_stream_peek_buffer
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_peek_buffer.g_buffered_input_stream_peek_buffer.html
//
func (stream *BufferedInputStreamInstance) PeekBuffer() (uint, []byte) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gsize                 // out, full, casted
	var cret  unsafe.Pointer          // return, transfer: none, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_peek_buffer(carg0, &carg1)
	runtime.KeepAlive(stream)

	var count uint
	var goret []byte

	count = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (void*) because of unknown reason")

	return count, goret
}

// ReadByte wraps g_buffered_input_stream_read_byte
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_read_byte.g_buffered_input_stream_read_byte.html
//
func (stream *BufferedInputStreamInstance) ReadByte(cancellable Cancellable) (int32, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 *C.GCancellable         // in, none, converted, nullable
	var cret  C.int                   // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_buffered_input_stream_read_byte(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBufferSize wraps g_buffered_input_stream_set_buffer_size
// 
// see also https://docs.gtk.org/gio/method.g_buffered_input_stream_set_buffer_size.g_buffered_input_stream_set_buffer_size.html
//
func (stream *BufferedInputStreamInstance) SetBufferSize(size uint) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gsize                 // in, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gsize(size)

	C.g_buffered_input_stream_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// BufferedInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type BufferedInputStreamOverrides[Instance BufferedInputStream] struct {
	// FilterInputStreamOverrides allows you to override virtual methods from the parent class FilterInputStream
	FilterInputStreamOverrides[Instance]

	// // Fill allows you to override the implementation of the virtual method fill.
	// 
	// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill.html
	Fill func(Instance, int, Cancellable) (int, error)
	// // FillFinish allows you to override the implementation of the virtual method fill_finish.
	// 
	// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill_finish.html
	FillFinish func(Instance, AsyncResult) (int, error)
}

// UnsafeApplyBufferedInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyBufferedInputStreamOverrides[Instance BufferedInputStream](gclass unsafe.Pointer, overrides BufferedInputStreamOverrides[Instance]) {
	UnsafeApplyFilterInputStreamOverrides(gclass, overrides.FilterInputStreamOverrides)

	pclass := (*C.GBufferedInputStreamClass)(gclass)

	if overrides.Fill != nil {
		pclass.fill = (*[0]byte)(C._goglib_gio2_BufferedInputStream_fill)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_BufferedInputStream_fill",
			func(carg0 *C.GBufferedInputStream, carg1 C.gssize, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GBufferedInputStream subclass
				var count       int         // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeBufferedInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				count = int(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.Fill(stream, count, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.FillFinish != nil {
		pclass.fill_finish = (*[0]byte)(C._goglib_gio2_BufferedInputStream_fill_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_BufferedInputStream_fill_finish",
			func(carg0 *C.GBufferedInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GBufferedInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeBufferedInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.FillFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentFill calls the default implementations of the `GBufferedInputStream.fill` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill.html
func (stream *BufferedInputStreamInstance) ParentFill(count int, cancellable Cancellable) (int, error) {
	var carg0 *C.GBufferedInputStream
	var carg1 C.gssize        // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GBufferedInputStreamClass)(classdata.PeekParentClass(UnsafeBufferedInputStreamToGlibNone(stream)))

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_BufferedInputStream_virtual_fill(unsafe.Pointer(parentclass.fill), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFillFinish calls the default implementations of the `GBufferedInputStream.fill_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// see also https://docs.gtk.org/gio/method.BufferedInputStream.fill_finish.html
func (stream *BufferedInputStreamInstance) ParentFillFinish(result AsyncResult) (int, error) {
	var carg0 *C.GBufferedInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GBufferedInputStreamClass)(classdata.PeekParentClass(UnsafeBufferedInputStreamToGlibNone(stream)))

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_BufferedInputStream_virtual_fill_finish(unsafe.Pointer(parentclass.fill_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterBufferedInputStreamSubClass is used to register a go subclass of GBufferedInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterBufferedInputStreamSubClass[InstanceT BufferedInputStream](
		name string,
		classInit func(class *BufferedInputStreamClass),
		constructor func() InstanceT,
		overrides BufferedInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeBufferedInputStream,
		UnsafeBufferedInputStreamClassFromGlibBorrow,
		UnsafeApplyBufferedInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedInputStream(obj)
		},
		interfaceInits...,
	)
}

// BufferedOutputStreamInstance is the instance type used by all types extending GBufferedOutputStream. It is used internally by the bindings. Users should use the interface [BufferedOutputStream] instead.
type BufferedOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ BufferedOutputStream = (*BufferedOutputStreamInstance)(nil)

// BufferedOutputStream wraps GBufferedOutputStream
// 
// see also https://docs.gtk.org/gio/class.BufferedOutputStream.html
//
type BufferedOutputStream interface {
	FilterOutputStream
	Seekable
	upcastToGBufferedOutputStream() *BufferedOutputStreamInstance

	// GetAutoGrow wraps g_buffered_output_stream_get_auto_grow
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_get_auto_grow.g_buffered_output_stream_get_auto_grow.html
	//
	GetAutoGrow() bool
	// GetBufferSize wraps g_buffered_output_stream_get_buffer_size
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_get_buffer_size.g_buffered_output_stream_get_buffer_size.html
	//
	GetBufferSize() uint
	// SetAutoGrow wraps g_buffered_output_stream_set_auto_grow
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_set_auto_grow.g_buffered_output_stream_set_auto_grow.html
	//
	SetAutoGrow(bool)
	// SetBufferSize wraps g_buffered_output_stream_set_buffer_size
	// 
	// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_set_buffer_size.g_buffered_output_stream_set_buffer_size.html
	//
	SetBufferSize(uint)

	// chain up virtual methods:
}

func unsafeWrapBufferedOutputStream(base *gobject.ObjectInstance) *BufferedOutputStreamInstance {
	return &BufferedOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBufferedOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedOutputStream(inst)
		},
	)
}

func marshalBufferedOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBufferedOutputStreamFromGlibNone is used to convert raw GBufferedOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibNone(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(BufferedOutputStream)
}

// UnsafeBufferedOutputStreamFromGlibFull is used to convert raw GBufferedOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibFull(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(BufferedOutputStream)
}

// UnsafeBufferedOutputStreamFromGlibBorrow is used to convert raw GBufferedOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibBorrow(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BufferedOutputStream)
}

func (b *BufferedOutputStreamInstance) upcastToGBufferedOutputStream() *BufferedOutputStreamInstance {
	return b
}

// UnsafeBufferedOutputStreamToGlibNone is used to convert the instance to it's C value GBufferedOutputStream. This is used by the bindings internally.
func UnsafeBufferedOutputStreamToGlibNone(c BufferedOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBufferedOutputStreamToGlibFull is used to convert the instance to it's C value GBufferedOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamToGlibFull(c BufferedOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBufferedOutputStream wraps g_buffered_output_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_buffered_output_stream_new.html
//
func NewBufferedOutputStream(baseStream OutputStream) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))

	cret = C.g_buffered_output_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewBufferedOutputStreamSized wraps g_buffered_output_stream_new_sized
// 
// see also https://docs.gtk.org/gio/func.g_buffered_output_stream_new_sized.html
//
func NewBufferedOutputStreamSized(baseStream OutputStream, size uint) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 C.gsize          // in, none, casted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))
	carg2 = C.gsize(size)

	cret = C.g_buffered_output_stream_new_sized(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAutoGrow wraps g_buffered_output_stream_get_auto_grow
// 
// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_get_auto_grow.g_buffered_output_stream_get_auto_grow.html
//
func (stream *BufferedOutputStreamInstance) GetAutoGrow() bool {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))

	cret = C.g_buffered_output_stream_get_auto_grow(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetBufferSize wraps g_buffered_output_stream_get_buffer_size
// 
// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_get_buffer_size.g_buffered_output_stream_get_buffer_size.html
//
func (stream *BufferedOutputStreamInstance) GetBufferSize() uint {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var cret  C.gsize                  // return, none, casted

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))

	cret = C.g_buffered_output_stream_get_buffer_size(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// SetAutoGrow wraps g_buffered_output_stream_set_auto_grow
// 
// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_set_auto_grow.g_buffered_output_stream_set_auto_grow.html
//
func (stream *BufferedOutputStreamInstance) SetAutoGrow(autoGrow bool) {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var carg1 C.gboolean               // in

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))
	if autoGrow {
		carg1 = C.TRUE
	}

	C.g_buffered_output_stream_set_auto_grow(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(autoGrow)
}

// SetBufferSize wraps g_buffered_output_stream_set_buffer_size
// 
// see also https://docs.gtk.org/gio/method.g_buffered_output_stream_set_buffer_size.g_buffered_output_stream_set_buffer_size.html
//
func (stream *BufferedOutputStreamInstance) SetBufferSize(size uint) {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var carg1 C.gsize                  // in, none, casted

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))
	carg1 = C.gsize(size)

	C.g_buffered_output_stream_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// BufferedOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type BufferedOutputStreamOverrides[Instance BufferedOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyBufferedOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyBufferedOutputStreamOverrides[Instance BufferedOutputStream](gclass unsafe.Pointer, overrides BufferedOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterBufferedOutputStreamSubClass is used to register a go subclass of GBufferedOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterBufferedOutputStreamSubClass[InstanceT BufferedOutputStream](
		name string,
		classInit func(class *BufferedOutputStreamClass),
		constructor func() InstanceT,
		overrides BufferedOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeBufferedOutputStream,
		UnsafeBufferedOutputStreamClassFromGlibBorrow,
		UnsafeApplyBufferedOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedOutputStream(obj)
		},
		interfaceInits...,
	)
}

// ConverterInputStreamInstance is the instance type used by all types extending GConverterInputStream. It is used internally by the bindings. Users should use the interface [ConverterInputStream] instead.
type ConverterInputStreamInstance struct {
	_ [0]func() // equal guard
	FilterInputStreamInstance
	// implemented interfaces:
	PollableInputStreamInstance
}

var _ ConverterInputStream = (*ConverterInputStreamInstance)(nil)

// ConverterInputStream wraps GConverterInputStream
// 
// see also https://docs.gtk.org/gio/class.ConverterInputStream.html
//
type ConverterInputStream interface {
	FilterInputStream
	PollableInputStream
	upcastToGConverterInputStream() *ConverterInputStreamInstance

	// GetConverter wraps g_converter_input_stream_get_converter
	// 
	// see also https://docs.gtk.org/gio/method.g_converter_input_stream_get_converter.g_converter_input_stream_get_converter.html
	//
	GetConverter() Converter

	// chain up virtual methods:
}

func unsafeWrapConverterInputStream(base *gobject.ObjectInstance) *ConverterInputStreamInstance {
	return &ConverterInputStreamInstance{
		FilterInputStreamInstance: FilterInputStreamInstance{
			InputStreamInstance: InputStreamInstance{
				ObjectInstance: *base,
			},
		},
		PollableInputStreamInstance: PollableInputStreamInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeConverterInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterInputStream(inst)
		},
	)
}

func marshalConverterInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeConverterInputStreamFromGlibNone is used to convert raw GConverterInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibNone(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(ConverterInputStream)
}

// UnsafeConverterInputStreamFromGlibFull is used to convert raw GConverterInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibFull(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(ConverterInputStream)
}

// UnsafeConverterInputStreamFromGlibBorrow is used to convert raw GConverterInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibBorrow(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ConverterInputStream)
}

func (c *ConverterInputStreamInstance) upcastToGConverterInputStream() *ConverterInputStreamInstance {
	return c
}

// UnsafeConverterInputStreamToGlibNone is used to convert the instance to it's C value GConverterInputStream. This is used by the bindings internally.
func UnsafeConverterInputStreamToGlibNone(c ConverterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeConverterInputStreamToGlibFull is used to convert the instance to it's C value GConverterInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamToGlibFull(c ConverterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewConverterInputStream wraps g_converter_input_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_converter_input_stream_new.html
//
func NewConverterInputStream(baseStream InputStream, converter Converter) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 *C.GConverter   // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))
	carg2 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	cret = C.g_converter_input_stream_new(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConverter wraps g_converter_input_stream_get_converter
// 
// see also https://docs.gtk.org/gio/method.g_converter_input_stream_get_converter.g_converter_input_stream_get_converter.html
//
func (converterStream *ConverterInputStreamInstance) GetConverter() Converter {
	var carg0 *C.GConverterInputStream // in, none, converted
	var cret  *C.GConverter            // return, none, converted

	carg0 = (*C.GConverterInputStream)(UnsafeConverterInputStreamToGlibNone(converterStream))

	cret = C.g_converter_input_stream_get_converter(carg0)
	runtime.KeepAlive(converterStream)

	var goret Converter

	goret = UnsafeConverterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ConverterInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ConverterInputStreamOverrides[Instance ConverterInputStream] struct {
	// FilterInputStreamOverrides allows you to override virtual methods from the parent class FilterInputStream
	FilterInputStreamOverrides[Instance]

}

// UnsafeApplyConverterInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyConverterInputStreamOverrides[Instance ConverterInputStream](gclass unsafe.Pointer, overrides ConverterInputStreamOverrides[Instance]) {
	UnsafeApplyFilterInputStreamOverrides(gclass, overrides.FilterInputStreamOverrides)
}

// RegisterConverterInputStreamSubClass is used to register a go subclass of GConverterInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterConverterInputStreamSubClass[InstanceT ConverterInputStream](
		name string,
		classInit func(class *ConverterInputStreamClass),
		constructor func() InstanceT,
		overrides ConverterInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeConverterInputStream,
		UnsafeConverterInputStreamClassFromGlibBorrow,
		UnsafeApplyConverterInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterInputStream(obj)
		},
		interfaceInits...,
	)
}

// ConverterOutputStreamInstance is the instance type used by all types extending GConverterOutputStream. It is used internally by the bindings. Users should use the interface [ConverterOutputStream] instead.
type ConverterOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	PollableOutputStreamInstance
}

var _ ConverterOutputStream = (*ConverterOutputStreamInstance)(nil)

// ConverterOutputStream wraps GConverterOutputStream
// 
// see also https://docs.gtk.org/gio/class.ConverterOutputStream.html
//
type ConverterOutputStream interface {
	FilterOutputStream
	PollableOutputStream
	upcastToGConverterOutputStream() *ConverterOutputStreamInstance

	// GetConverter wraps g_converter_output_stream_get_converter
	// 
	// see also https://docs.gtk.org/gio/method.g_converter_output_stream_get_converter.g_converter_output_stream_get_converter.html
	//
	GetConverter() Converter

	// chain up virtual methods:
}

func unsafeWrapConverterOutputStream(base *gobject.ObjectInstance) *ConverterOutputStreamInstance {
	return &ConverterOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		PollableOutputStreamInstance: PollableOutputStreamInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeConverterOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterOutputStream(inst)
		},
	)
}

func marshalConverterOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeConverterOutputStreamFromGlibNone is used to convert raw GConverterOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibNone(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(ConverterOutputStream)
}

// UnsafeConverterOutputStreamFromGlibFull is used to convert raw GConverterOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibFull(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(ConverterOutputStream)
}

// UnsafeConverterOutputStreamFromGlibBorrow is used to convert raw GConverterOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibBorrow(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ConverterOutputStream)
}

func (c *ConverterOutputStreamInstance) upcastToGConverterOutputStream() *ConverterOutputStreamInstance {
	return c
}

// UnsafeConverterOutputStreamToGlibNone is used to convert the instance to it's C value GConverterOutputStream. This is used by the bindings internally.
func UnsafeConverterOutputStreamToGlibNone(c ConverterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeConverterOutputStreamToGlibFull is used to convert the instance to it's C value GConverterOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamToGlibFull(c ConverterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewConverterOutputStream wraps g_converter_output_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_converter_output_stream_new.html
//
func NewConverterOutputStream(baseStream OutputStream, converter Converter) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 *C.GConverter    // in, none, converted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))
	carg2 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	cret = C.g_converter_output_stream_new(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConverter wraps g_converter_output_stream_get_converter
// 
// see also https://docs.gtk.org/gio/method.g_converter_output_stream_get_converter.g_converter_output_stream_get_converter.html
//
func (converterStream *ConverterOutputStreamInstance) GetConverter() Converter {
	var carg0 *C.GConverterOutputStream // in, none, converted
	var cret  *C.GConverter             // return, none, converted

	carg0 = (*C.GConverterOutputStream)(UnsafeConverterOutputStreamToGlibNone(converterStream))

	cret = C.g_converter_output_stream_get_converter(carg0)
	runtime.KeepAlive(converterStream)

	var goret Converter

	goret = UnsafeConverterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ConverterOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ConverterOutputStreamOverrides[Instance ConverterOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyConverterOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyConverterOutputStreamOverrides[Instance ConverterOutputStream](gclass unsafe.Pointer, overrides ConverterOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterConverterOutputStreamSubClass is used to register a go subclass of GConverterOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterConverterOutputStreamSubClass[InstanceT ConverterOutputStream](
		name string,
		classInit func(class *ConverterOutputStreamClass),
		constructor func() InstanceT,
		overrides ConverterOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeConverterOutputStream,
		UnsafeConverterOutputStreamClassFromGlibBorrow,
		UnsafeApplyConverterOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterOutputStream(obj)
		},
		interfaceInits...,
	)
}

// DataInputStreamInstance is the instance type used by all types extending GDataInputStream. It is used internally by the bindings. Users should use the interface [DataInputStream] instead.
type DataInputStreamInstance struct {
	_ [0]func() // equal guard
	BufferedInputStreamInstance
}

var _ DataInputStream = (*DataInputStreamInstance)(nil)

// DataInputStream wraps GDataInputStream
// 
// see also https://docs.gtk.org/gio/class.DataInputStream.html
//
type DataInputStream interface {
	BufferedInputStream
	upcastToGDataInputStream() *DataInputStreamInstance

	// GetByteOrder wraps g_data_input_stream_get_byte_order
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_get_byte_order.g_data_input_stream_get_byte_order.html
	//
	GetByteOrder() DataStreamByteOrder
	// GetNewlineType wraps g_data_input_stream_get_newline_type
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_get_newline_type.g_data_input_stream_get_newline_type.html
	//
	GetNewlineType() DataStreamNewlineType
	// ReadInt16 wraps g_data_input_stream_read_int16
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int16.g_data_input_stream_read_int16.html
	//
	ReadInt16(Cancellable) (int16, error)
	// ReadInt32 wraps g_data_input_stream_read_int32
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int32.g_data_input_stream_read_int32.html
	//
	ReadInt32(Cancellable) (int32, error)
	// ReadInt64 wraps g_data_input_stream_read_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int64.g_data_input_stream_read_int64.html
	//
	ReadInt64(Cancellable) (int64, error)
	// ReadLine wraps g_data_input_stream_read_line
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line.g_data_input_stream_read_line.html
	//
	ReadLine(Cancellable) (uint, string, error)
	// ReadLineAsync wraps g_data_input_stream_read_line_async
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_async.g_data_input_stream_read_line_async.html
	//
	ReadLineAsync(int32, Cancellable, AsyncReadyCallback)
	// ReadLineFinish wraps g_data_input_stream_read_line_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_finish.g_data_input_stream_read_line_finish.html
	//
	ReadLineFinish(AsyncResult) (uint, string, error)
	// ReadLineFinishUTF8 wraps g_data_input_stream_read_line_finish_utf8
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_finish_utf8.g_data_input_stream_read_line_finish_utf8.html
	//
	ReadLineFinishUTF8(AsyncResult) (uint, string, error)
	// ReadLineUTF8 wraps g_data_input_stream_read_line_utf8
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_utf8.g_data_input_stream_read_line_utf8.html
	//
	ReadLineUTF8(Cancellable) (uint, string, error)
	// ReadUint16 wraps g_data_input_stream_read_uint16
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint16.g_data_input_stream_read_uint16.html
	//
	ReadUint16(Cancellable) (uint16, error)
	// ReadUint32 wraps g_data_input_stream_read_uint32
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint32.g_data_input_stream_read_uint32.html
	//
	ReadUint32(Cancellable) (uint32, error)
	// ReadUint64 wraps g_data_input_stream_read_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint64.g_data_input_stream_read_uint64.html
	//
	ReadUint64(Cancellable) (uint64, error)
	// ReadUntil wraps g_data_input_stream_read_until
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until.g_data_input_stream_read_until.html
	//
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto() instead, which has more
	//     consistent behaviour regarding the stop character.
	ReadUntil(string, Cancellable) (uint, string, error)
	// ReadUntilAsync wraps g_data_input_stream_read_until_async
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until_async.g_data_input_stream_read_until_async.html
	//
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_async() instead, which
	//     has more consistent behaviour regarding the stop character.
	ReadUntilAsync(string, int32, Cancellable, AsyncReadyCallback)
	// ReadUntilFinish wraps g_data_input_stream_read_until_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until_finish.g_data_input_stream_read_until_finish.html
	//
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_finish() instead, which
	//     has more consistent behaviour regarding the stop character.
	ReadUntilFinish(AsyncResult) (uint, string, error)
	// ReadUpto wraps g_data_input_stream_read_upto
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto.g_data_input_stream_read_upto.html
	//
	ReadUpto(string, int, Cancellable) (uint, string, error)
	// ReadUptoAsync wraps g_data_input_stream_read_upto_async
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto_async.g_data_input_stream_read_upto_async.html
	//
	ReadUptoAsync(string, int, int32, Cancellable, AsyncReadyCallback)
	// ReadUptoFinish wraps g_data_input_stream_read_upto_finish
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto_finish.g_data_input_stream_read_upto_finish.html
	//
	ReadUptoFinish(AsyncResult) (uint, string, error)
	// SetByteOrder wraps g_data_input_stream_set_byte_order
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_set_byte_order.g_data_input_stream_set_byte_order.html
	//
	SetByteOrder(DataStreamByteOrder)
	// SetNewlineType wraps g_data_input_stream_set_newline_type
	// 
	// see also https://docs.gtk.org/gio/method.g_data_input_stream_set_newline_type.g_data_input_stream_set_newline_type.html
	//
	SetNewlineType(DataStreamNewlineType)

	// chain up virtual methods:
}

func unsafeWrapDataInputStream(base *gobject.ObjectInstance) *DataInputStreamInstance {
	return &DataInputStreamInstance{
		BufferedInputStreamInstance: BufferedInputStreamInstance{
			FilterInputStreamInstance: FilterInputStreamInstance{
				InputStreamInstance: InputStreamInstance{
					ObjectInstance: *base,
				},
			},
			SeekableInstance: SeekableInstance{
				Instance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeDataInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataInputStream(inst)
		},
	)
}

func marshalDataInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeDataInputStreamFromGlibNone is used to convert raw GDataInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibNone(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(DataInputStream)
}

// UnsafeDataInputStreamFromGlibFull is used to convert raw GDataInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibFull(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(DataInputStream)
}

// UnsafeDataInputStreamFromGlibBorrow is used to convert raw GDataInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibBorrow(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DataInputStream)
}

func (d *DataInputStreamInstance) upcastToGDataInputStream() *DataInputStreamInstance {
	return d
}

// UnsafeDataInputStreamToGlibNone is used to convert the instance to it's C value GDataInputStream. This is used by the bindings internally.
func UnsafeDataInputStreamToGlibNone(c DataInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeDataInputStreamToGlibFull is used to convert the instance to it's C value GDataInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamToGlibFull(c DataInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewDataInputStream wraps g_data_input_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_data_input_stream_new.html
//
func NewDataInputStream(baseStream InputStream) DataInputStream {
	var carg1 *C.GInputStream     // in, none, converted
	var cret  *C.GDataInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))

	cret = C.g_data_input_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret DataInputStream

	goret = UnsafeDataInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetByteOrder wraps g_data_input_stream_get_byte_order
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_get_byte_order.g_data_input_stream_get_byte_order.html
//
func (stream *DataInputStreamInstance) GetByteOrder() DataStreamByteOrder {
	var carg0 *C.GDataInputStream    // in, none, converted
	var cret  C.GDataStreamByteOrder // return, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))

	cret = C.g_data_input_stream_get_byte_order(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamByteOrder

	goret = DataStreamByteOrder(cret)

	return goret
}

// GetNewlineType wraps g_data_input_stream_get_newline_type
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_get_newline_type.g_data_input_stream_get_newline_type.html
//
func (stream *DataInputStreamInstance) GetNewlineType() DataStreamNewlineType {
	var carg0 *C.GDataInputStream      // in, none, converted
	var cret  C.GDataStreamNewlineType // return, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))

	cret = C.g_data_input_stream_get_newline_type(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamNewlineType

	goret = DataStreamNewlineType(cret)

	return goret
}

// ReadInt16 wraps g_data_input_stream_read_int16
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int16.g_data_input_stream_read_int16.html
//
func (stream *DataInputStreamInstance) ReadInt16(cancellable Cancellable) (int16, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint16            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int16(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int16
	var _goerr error

	goret = int16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadInt32 wraps g_data_input_stream_read_int32
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int32.g_data_input_stream_read_int32.html
//
func (stream *DataInputStreamInstance) ReadInt32(cancellable Cancellable) (int32, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint32            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int32(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadInt64 wraps g_data_input_stream_read_int64
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_int64.g_data_input_stream_read_int64.html
//
func (stream *DataInputStreamInstance) ReadInt64(cancellable Cancellable) (int64, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint64            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int64(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int64
	var _goerr error

	goret = int64(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadLine wraps g_data_input_stream_read_line
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line.g_data_input_stream_read_line.html
//
func (stream *DataInputStreamInstance) ReadLine(cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var carg1 C.gsize             // out, full, casted
	var cret  *C.char             // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , nullable, array (inner unknown, zero-terminated)
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_line(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineAsync wraps g_data_input_stream_read_line_async
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_async.g_data_input_stream_read_line_async.html
//
func (stream *DataInputStreamInstance) ReadLineAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 C.gint                // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.gint(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_line_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadLineFinish wraps g_data_input_stream_read_line_finish
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_finish.g_data_input_stream_read_line_finish.html
//
func (stream *DataInputStreamInstance) ReadLineFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , nullable, array (inner unknown, zero-terminated)
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_line_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineFinishUTF8 wraps g_data_input_stream_read_line_finish_utf8
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_finish_utf8.g_data_input_stream_read_line_finish_utf8.html
//
func (stream *DataInputStreamInstance) ReadLineFinishUTF8(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string, nullable-string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_line_finish_utf8(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineUTF8 wraps g_data_input_stream_read_line_utf8
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_line_utf8.g_data_input_stream_read_line_utf8.html
//
func (stream *DataInputStreamInstance) ReadLineUTF8(cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var carg1 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string, nullable-string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_line_utf8(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUint16 wraps g_data_input_stream_read_uint16
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint16.g_data_input_stream_read_uint16.html
//
func (stream *DataInputStreamInstance) ReadUint16(cancellable Cancellable) (uint16, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint16           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint16(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint16
	var _goerr error

	goret = uint16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUint32 wraps g_data_input_stream_read_uint32
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint32.g_data_input_stream_read_uint32.html
//
func (stream *DataInputStreamInstance) ReadUint32(cancellable Cancellable) (uint32, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint32           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint32(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint32
	var _goerr error

	goret = uint32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUint64 wraps g_data_input_stream_read_uint64
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_uint64.g_data_input_stream_read_uint64.html
//
func (stream *DataInputStreamInstance) ReadUint64(cancellable Cancellable) (uint64, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint64           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint64(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint64
	var _goerr error

	goret = uint64(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUntil wraps g_data_input_stream_read_until
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until.g_data_input_stream_read_until.html
//
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto() instead, which has more
//     consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntil(stopChars string, cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.gchar            // in, none, string
	var carg3 *C.GCancellable     // in, none, converted, nullable
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_until(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUntilAsync wraps g_data_input_stream_read_until_async
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until_async.g_data_input_stream_read_until_async.html
//
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_async() instead, which
//     has more consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntilAsync(stopChars string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.gint                // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_until_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadUntilFinish wraps g_data_input_stream_read_until_finish
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_until_finish.g_data_input_stream_read_until_finish.html
//
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_finish() instead, which
//     has more consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntilFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_until_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUpto wraps g_data_input_stream_read_upto
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto.g_data_input_stream_read_upto.html
//
func (stream *DataInputStreamInstance) ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.gchar            // in, none, string
	var carg2 C.gssize            // in, none, casted
	var carg4 *C.GCancellable     // in, none, converted, nullable
	var carg3 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(stopCharsLen)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_upto(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(stopCharsLen)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg3)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUptoAsync wraps g_data_input_stream_read_upto_async
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto_async.g_data_input_stream_read_upto_async.html
//
func (stream *DataInputStreamInstance) ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.gssize              // in, none, casted
	var carg3 C.gint                // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(stopCharsLen)
	carg3 = C.gint(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_upto_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(stopCharsLen)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadUptoFinish wraps g_data_input_stream_read_upto_finish
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_read_upto_finish.g_data_input_stream_read_upto_finish.html
//
func (stream *DataInputStreamInstance) ReadUptoFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_upto_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// SetByteOrder wraps g_data_input_stream_set_byte_order
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_set_byte_order.g_data_input_stream_set_byte_order.html
//
func (stream *DataInputStreamInstance) SetByteOrder(order DataStreamByteOrder) {
	var carg0 *C.GDataInputStream    // in, none, converted
	var carg1 C.GDataStreamByteOrder // in, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.GDataStreamByteOrder(order)

	C.g_data_input_stream_set_byte_order(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// SetNewlineType wraps g_data_input_stream_set_newline_type
// 
// see also https://docs.gtk.org/gio/method.g_data_input_stream_set_newline_type.g_data_input_stream_set_newline_type.html
//
func (stream *DataInputStreamInstance) SetNewlineType(typ DataStreamNewlineType) {
	var carg0 *C.GDataInputStream      // in, none, converted
	var carg1 C.GDataStreamNewlineType // in, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.GDataStreamNewlineType(typ)

	C.g_data_input_stream_set_newline_type(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(typ)
}

// DataInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type DataInputStreamOverrides[Instance DataInputStream] struct {
	// BufferedInputStreamOverrides allows you to override virtual methods from the parent class BufferedInputStream
	BufferedInputStreamOverrides[Instance]

}

// UnsafeApplyDataInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyDataInputStreamOverrides[Instance DataInputStream](gclass unsafe.Pointer, overrides DataInputStreamOverrides[Instance]) {
	UnsafeApplyBufferedInputStreamOverrides(gclass, overrides.BufferedInputStreamOverrides)
}

// RegisterDataInputStreamSubClass is used to register a go subclass of GDataInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterDataInputStreamSubClass[InstanceT DataInputStream](
		name string,
		classInit func(class *DataInputStreamClass),
		constructor func() InstanceT,
		overrides DataInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeDataInputStream,
		UnsafeDataInputStreamClassFromGlibBorrow,
		UnsafeApplyDataInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataInputStream(obj)
		},
		interfaceInits...,
	)
}

// DataOutputStreamInstance is the instance type used by all types extending GDataOutputStream. It is used internally by the bindings. Users should use the interface [DataOutputStream] instead.
type DataOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ DataOutputStream = (*DataOutputStreamInstance)(nil)

// DataOutputStream wraps GDataOutputStream
// 
// see also https://docs.gtk.org/gio/class.DataOutputStream.html
//
type DataOutputStream interface {
	FilterOutputStream
	Seekable
	upcastToGDataOutputStream() *DataOutputStreamInstance

	// GetByteOrder wraps g_data_output_stream_get_byte_order
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_get_byte_order.g_data_output_stream_get_byte_order.html
	//
	GetByteOrder() DataStreamByteOrder
	// PutByte wraps g_data_output_stream_put_byte
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_byte.g_data_output_stream_put_byte.html
	//
	PutByte(byte, Cancellable) (bool, error)
	// PutInt16 wraps g_data_output_stream_put_int16
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int16.g_data_output_stream_put_int16.html
	//
	PutInt16(int16, Cancellable) (bool, error)
	// PutInt32 wraps g_data_output_stream_put_int32
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int32.g_data_output_stream_put_int32.html
	//
	PutInt32(int32, Cancellable) (bool, error)
	// PutInt64 wraps g_data_output_stream_put_int64
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int64.g_data_output_stream_put_int64.html
	//
	PutInt64(int64, Cancellable) (bool, error)
	// PutString wraps g_data_output_stream_put_string
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_string.g_data_output_stream_put_string.html
	//
	PutString(string, Cancellable) (bool, error)
	// PutUint16 wraps g_data_output_stream_put_uint16
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint16.g_data_output_stream_put_uint16.html
	//
	PutUint16(uint16, Cancellable) (bool, error)
	// PutUint32 wraps g_data_output_stream_put_uint32
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint32.g_data_output_stream_put_uint32.html
	//
	PutUint32(uint32, Cancellable) (bool, error)
	// PutUint64 wraps g_data_output_stream_put_uint64
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint64.g_data_output_stream_put_uint64.html
	//
	PutUint64(uint64, Cancellable) (bool, error)
	// SetByteOrder wraps g_data_output_stream_set_byte_order
	// 
	// see also https://docs.gtk.org/gio/method.g_data_output_stream_set_byte_order.g_data_output_stream_set_byte_order.html
	//
	SetByteOrder(DataStreamByteOrder)

	// chain up virtual methods:
}

func unsafeWrapDataOutputStream(base *gobject.ObjectInstance) *DataOutputStreamInstance {
	return &DataOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeDataOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataOutputStream(inst)
		},
	)
}

func marshalDataOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeDataOutputStreamFromGlibNone is used to convert raw GDataOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibNone(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(DataOutputStream)
}

// UnsafeDataOutputStreamFromGlibFull is used to convert raw GDataOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibFull(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(DataOutputStream)
}

// UnsafeDataOutputStreamFromGlibBorrow is used to convert raw GDataOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibBorrow(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DataOutputStream)
}

func (d *DataOutputStreamInstance) upcastToGDataOutputStream() *DataOutputStreamInstance {
	return d
}

// UnsafeDataOutputStreamToGlibNone is used to convert the instance to it's C value GDataOutputStream. This is used by the bindings internally.
func UnsafeDataOutputStreamToGlibNone(c DataOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeDataOutputStreamToGlibFull is used to convert the instance to it's C value GDataOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamToGlibFull(c DataOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewDataOutputStream wraps g_data_output_stream_new
// 
// see also https://docs.gtk.org/gio/func.g_data_output_stream_new.html
//
func NewDataOutputStream(baseStream OutputStream) DataOutputStream {
	var carg1 *C.GOutputStream     // in, none, converted
	var cret  *C.GDataOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))

	cret = C.g_data_output_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret DataOutputStream

	goret = UnsafeDataOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetByteOrder wraps g_data_output_stream_get_byte_order
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_get_byte_order.g_data_output_stream_get_byte_order.html
//
func (stream *DataOutputStreamInstance) GetByteOrder() DataStreamByteOrder {
	var carg0 *C.GDataOutputStream   // in, none, converted
	var cret  C.GDataStreamByteOrder // return, none, casted

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))

	cret = C.g_data_output_stream_get_byte_order(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamByteOrder

	goret = DataStreamByteOrder(cret)

	return goret
}

// PutByte wraps g_data_output_stream_put_byte
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_byte.g_data_output_stream_put_byte.html
//
func (stream *DataOutputStreamInstance) PutByte(data byte, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guchar             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guchar(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_byte(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt16 wraps g_data_output_stream_put_int16
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int16.g_data_output_stream_put_int16.html
//
func (stream *DataOutputStreamInstance) PutInt16(data int16, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint16             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint16(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int16(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt32 wraps g_data_output_stream_put_int32
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int32.g_data_output_stream_put_int32.html
//
func (stream *DataOutputStreamInstance) PutInt32(data int32, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint32             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint32(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int32(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt64 wraps g_data_output_stream_put_int64
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_int64.g_data_output_stream_put_int64.html
//
func (stream *DataOutputStreamInstance) PutInt64(data int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint64             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint64(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutString wraps g_data_output_stream_put_string
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_string.g_data_output_stream_put_string.html
//
func (stream *DataOutputStreamInstance) PutString(str string, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_string(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint16 wraps g_data_output_stream_put_uint16
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint16.g_data_output_stream_put_uint16.html
//
func (stream *DataOutputStreamInstance) PutUint16(data uint16, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint16            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint16(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint16(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint32 wraps g_data_output_stream_put_uint32
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint32.g_data_output_stream_put_uint32.html
//
func (stream *DataOutputStreamInstance) PutUint32(data uint32, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint32            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint32(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint32(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint64 wraps g_data_output_stream_put_uint64
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_put_uint64.g_data_output_stream_put_uint64.html
//
func (stream *DataOutputStreamInstance) PutUint64(data uint64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint64            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint64(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetByteOrder wraps g_data_output_stream_set_byte_order
// 
// see also https://docs.gtk.org/gio/method.g_data_output_stream_set_byte_order.g_data_output_stream_set_byte_order.html
//
func (stream *DataOutputStreamInstance) SetByteOrder(order DataStreamByteOrder) {
	var carg0 *C.GDataOutputStream   // in, none, converted
	var carg1 C.GDataStreamByteOrder // in, none, casted

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.GDataStreamByteOrder(order)

	C.g_data_output_stream_set_byte_order(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// DataOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type DataOutputStreamOverrides[Instance DataOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyDataOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyDataOutputStreamOverrides[Instance DataOutputStream](gclass unsafe.Pointer, overrides DataOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterDataOutputStreamSubClass is used to register a go subclass of GDataOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterDataOutputStreamSubClass[InstanceT DataOutputStream](
		name string,
		classInit func(class *DataOutputStreamClass),
		constructor func() InstanceT,
		overrides DataOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeDataOutputStream,
		UnsafeDataOutputStreamClassFromGlibBorrow,
		UnsafeApplyDataOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataOutputStream(obj)
		},
		interfaceInits...,
	)
}

// ActionEntry wraps GActionEntry
// 
// see also https://docs.gtk.org/gio/struct.ActionEntry.html
//
type ActionEntry struct {
	*actionEntry
}

// actionEntry is the struct that's finalized
type actionEntry struct {
	native *C.GActionEntry
}

// UnsafeActionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionEntry) instance() *C.GActionEntry {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionEntryFromGlibBorrow is used to convert raw C.GActionEntry pointers to go. This is used by the bindings internally.
func UnsafeActionEntryFromGlibBorrow(p unsafe.Pointer) *ActionEntry {
	if p == nil {
		return nil
	}
	return &ActionEntry{&actionEntry{(*C.GActionEntry)(p)}}
}

// UnsafeActionEntryFromGlibNone is used to convert raw C.GActionEntry pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionEntryFromGlibNone(p unsafe.Pointer) *ActionEntry {
	wrapped := UnsafeActionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionEntry because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionEntryFromGlibFull is used to convert raw C.GActionEntry pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionEntryFromGlibFull(p unsafe.Pointer) *ActionEntry {
	wrapped := UnsafeActionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionEntry,
		func (intern *actionEntry) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionEntryFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionEntry] is expected to work anymore.
func UnsafeActionEntryFree(a *ActionEntry) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionEntryToGlibNone(a *ActionEntry) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionEntryToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionEntryToGlibFull(a *ActionEntry) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionEntry, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionEntry is invalid from here on
	return _p
}

// ActionGroupInterface wraps GActionGroupInterface
// 
// see also https://docs.gtk.org/gio/struct.ActionGroupInterface.html
//
type ActionGroupInterface struct {
	*actionGroupInterface
}

// actionGroupInterface is the struct that's finalized
type actionGroupInterface struct {
	native *C.GActionGroupInterface
}

// UnsafeActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionGroupInterface) instance() *C.GActionGroupInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionGroupInterfaceFromGlibBorrow is used to convert raw C.GActionGroupInterface pointers to go. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionGroupInterface {
	if p == nil {
		return nil
	}
	return &ActionGroupInterface{&actionGroupInterface{(*C.GActionGroupInterface)(p)}}
}

// UnsafeActionGroupInterfaceFromGlibNone is used to convert raw C.GActionGroupInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibNone(p unsafe.Pointer) *ActionGroupInterface {
	wrapped := UnsafeActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionGroupInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionGroupInterfaceFromGlibFull is used to convert raw C.GActionGroupInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibFull(p unsafe.Pointer) *ActionGroupInterface {
	wrapped := UnsafeActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionGroupInterface,
		func (intern *actionGroupInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionGroupInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionGroupInterface] is expected to work anymore.
func UnsafeActionGroupInterfaceFree(a *ActionGroupInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionGroupInterfaceToGlibNone(a *ActionGroupInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionGroupInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionGroupInterfaceToGlibFull(a *ActionGroupInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionGroupInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionGroupInterface is invalid from here on
	return _p
}

// ActionInterface wraps GActionInterface
// 
// see also https://docs.gtk.org/gio/struct.ActionInterface.html
//
type ActionInterface struct {
	*actionInterface
}

// actionInterface is the struct that's finalized
type actionInterface struct {
	native *C.GActionInterface
}

// UnsafeActionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionInterface) instance() *C.GActionInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionInterfaceFromGlibBorrow is used to convert raw C.GActionInterface pointers to go. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionInterface {
	if p == nil {
		return nil
	}
	return &ActionInterface{&actionInterface{(*C.GActionInterface)(p)}}
}

// UnsafeActionInterfaceFromGlibNone is used to convert raw C.GActionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibNone(p unsafe.Pointer) *ActionInterface {
	wrapped := UnsafeActionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionInterfaceFromGlibFull is used to convert raw C.GActionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibFull(p unsafe.Pointer) *ActionInterface {
	wrapped := UnsafeActionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionInterface,
		func (intern *actionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionInterface] is expected to work anymore.
func UnsafeActionInterfaceFree(a *ActionInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionInterfaceToGlibNone(a *ActionInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionInterfaceToGlibFull(a *ActionInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionInterface is invalid from here on
	return _p
}

// ActionMapInterface wraps GActionMapInterface
// 
// see also https://docs.gtk.org/gio/struct.ActionMapInterface.html
//
type ActionMapInterface struct {
	*actionMapInterface
}

// actionMapInterface is the struct that's finalized
type actionMapInterface struct {
	native *C.GActionMapInterface
}

// UnsafeActionMapInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionMapInterface) instance() *C.GActionMapInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionMapInterfaceFromGlibBorrow is used to convert raw C.GActionMapInterface pointers to go. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionMapInterface {
	if p == nil {
		return nil
	}
	return &ActionMapInterface{&actionMapInterface{(*C.GActionMapInterface)(p)}}
}

// UnsafeActionMapInterfaceFromGlibNone is used to convert raw C.GActionMapInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibNone(p unsafe.Pointer) *ActionMapInterface {
	wrapped := UnsafeActionMapInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionMapInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionMapInterfaceFromGlibFull is used to convert raw C.GActionMapInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibFull(p unsafe.Pointer) *ActionMapInterface {
	wrapped := UnsafeActionMapInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionMapInterface,
		func (intern *actionMapInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionMapInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionMapInterface] is expected to work anymore.
func UnsafeActionMapInterfaceFree(a *ActionMapInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionMapInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionMapInterfaceToGlibNone(a *ActionMapInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionMapInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionMapInterfaceToGlibFull(a *ActionMapInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionMapInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionMapInterface is invalid from here on
	return _p
}

// AppInfoIface wraps GAppInfoIface
// 
// see also https://docs.gtk.org/gio/struct.AppInfoIface.html
//
type AppInfoIface struct {
	*appInfoIface
}

// appInfoIface is the struct that's finalized
type appInfoIface struct {
	native *C.GAppInfoIface
}

// UnsafeAppInfoIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AppInfoIface) instance() *C.GAppInfoIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAppInfoIfaceFromGlibBorrow is used to convert raw C.GAppInfoIface pointers to go. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibBorrow(p unsafe.Pointer) *AppInfoIface {
	if p == nil {
		return nil
	}
	return &AppInfoIface{&appInfoIface{(*C.GAppInfoIface)(p)}}
}

// UnsafeAppInfoIfaceFromGlibNone is used to convert raw C.GAppInfoIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibNone(p unsafe.Pointer) *AppInfoIface {
	wrapped := UnsafeAppInfoIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AppInfoIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAppInfoIfaceFromGlibFull is used to convert raw C.GAppInfoIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibFull(p unsafe.Pointer) *AppInfoIface {
	wrapped := UnsafeAppInfoIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.appInfoIface,
		func (intern *appInfoIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAppInfoIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AppInfoIface] is expected to work anymore.
func UnsafeAppInfoIfaceFree(a *AppInfoIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAppInfoIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAppInfoIfaceToGlibNone(a *AppInfoIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAppInfoIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAppInfoIfaceToGlibFull(a *AppInfoIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.appInfoIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AppInfoIface is invalid from here on
	return _p
}

// AppLaunchContextClass wraps GAppLaunchContextClass
// 
// see also https://docs.gtk.org/gio/struct.AppLaunchContextClass.html
// 
// AppLaunchContextClass is the type struct for [AppLaunchContext]
type AppLaunchContextClass struct {
	*appLaunchContextClass
}

// appLaunchContextClass is the struct that's finalized
type appLaunchContextClass struct {
	native *C.GAppLaunchContextClass
}

// UnsafeAppLaunchContextClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AppLaunchContextClass) instance() *C.GAppLaunchContextClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAppLaunchContextClassFromGlibBorrow is used to convert raw C.GAppLaunchContextClass pointers to go. This is used by the bindings internally.
func UnsafeAppLaunchContextClassFromGlibBorrow(p unsafe.Pointer) *AppLaunchContextClass {
	if p == nil {
		return nil
	}
	return &AppLaunchContextClass{&appLaunchContextClass{(*C.GAppLaunchContextClass)(p)}}
}

// UnsafeAppLaunchContextClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AppLaunchContextClass] is expected to work anymore.
func UnsafeAppLaunchContextClassFree(a *AppLaunchContextClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAppLaunchContextClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAppLaunchContextClassToGlibNone(a *AppLaunchContextClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *AppLaunchContextClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeAppLaunchContextClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *AppLaunchContextClass) {}, a)
	return parent
}

// ApplicationClass wraps GApplicationClass
// 
// see also https://docs.gtk.org/gio/struct.ApplicationClass.html
//
// 
// ApplicationClass is the type struct for [Application]
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized
type applicationClass struct {
	native *C.GApplicationClass
}

// UnsafeApplicationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ApplicationClass) instance() *C.GApplicationClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeApplicationClassFromGlibBorrow is used to convert raw C.GApplicationClass pointers to go. This is used by the bindings internally.
func UnsafeApplicationClassFromGlibBorrow(p unsafe.Pointer) *ApplicationClass {
	if p == nil {
		return nil
	}
	return &ApplicationClass{&applicationClass{(*C.GApplicationClass)(p)}}
}

// UnsafeApplicationClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ApplicationClass] is expected to work anymore.
func UnsafeApplicationClassFree(a *ApplicationClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeApplicationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeApplicationClassToGlibNone(a *ApplicationClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *ApplicationClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeApplicationClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ApplicationClass) {}, a)
	return parent
}

// ApplicationCommandLineClass wraps GApplicationCommandLineClass
// 
// see also https://docs.gtk.org/gio/struct.ApplicationCommandLineClass.html
//
// 
// ApplicationCommandLineClass is the type struct for [ApplicationCommandLine]
type ApplicationCommandLineClass struct {
	*applicationCommandLineClass
}

// applicationCommandLineClass is the struct that's finalized
type applicationCommandLineClass struct {
	native *C.GApplicationCommandLineClass
}

// UnsafeApplicationCommandLineClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ApplicationCommandLineClass) instance() *C.GApplicationCommandLineClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeApplicationCommandLineClassFromGlibBorrow is used to convert raw C.GApplicationCommandLineClass pointers to go. This is used by the bindings internally.
func UnsafeApplicationCommandLineClassFromGlibBorrow(p unsafe.Pointer) *ApplicationCommandLineClass {
	if p == nil {
		return nil
	}
	return &ApplicationCommandLineClass{&applicationCommandLineClass{(*C.GApplicationCommandLineClass)(p)}}
}

// UnsafeApplicationCommandLineClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ApplicationCommandLineClass] is expected to work anymore.
func UnsafeApplicationCommandLineClassFree(a *ApplicationCommandLineClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeApplicationCommandLineClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeApplicationCommandLineClassToGlibNone(a *ApplicationCommandLineClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *ApplicationCommandLineClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeApplicationCommandLineClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ApplicationCommandLineClass) {}, a)
	return parent
}

// AsyncInitableIface wraps GAsyncInitableIface
// 
// see also https://docs.gtk.org/gio/struct.AsyncInitableIface.html
//
type AsyncInitableIface struct {
	*asyncInitableIface
}

// asyncInitableIface is the struct that's finalized
type asyncInitableIface struct {
	native *C.GAsyncInitableIface
}

// UnsafeAsyncInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncInitableIface) instance() *C.GAsyncInitableIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncInitableIfaceFromGlibBorrow is used to convert raw C.GAsyncInitableIface pointers to go. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibBorrow(p unsafe.Pointer) *AsyncInitableIface {
	if p == nil {
		return nil
	}
	return &AsyncInitableIface{&asyncInitableIface{(*C.GAsyncInitableIface)(p)}}
}

// UnsafeAsyncInitableIfaceFromGlibNone is used to convert raw C.GAsyncInitableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibNone(p unsafe.Pointer) *AsyncInitableIface {
	wrapped := UnsafeAsyncInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AsyncInitableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAsyncInitableIfaceFromGlibFull is used to convert raw C.GAsyncInitableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibFull(p unsafe.Pointer) *AsyncInitableIface {
	wrapped := UnsafeAsyncInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncInitableIface,
		func (intern *asyncInitableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAsyncInitableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncInitableIface] is expected to work anymore.
func UnsafeAsyncInitableIfaceFree(a *AsyncInitableIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAsyncInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceToGlibNone(a *AsyncInitableIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncInitableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncInitableIfaceToGlibFull(a *AsyncInitableIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncInitableIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncInitableIface is invalid from here on
	return _p
}

// AsyncResultIface wraps GAsyncResultIface
// 
// see also https://docs.gtk.org/gio/struct.AsyncResultIface.html
//
type AsyncResultIface struct {
	*asyncResultIface
}

// asyncResultIface is the struct that's finalized
type asyncResultIface struct {
	native *C.GAsyncResultIface
}

// UnsafeAsyncResultIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncResultIface) instance() *C.GAsyncResultIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncResultIfaceFromGlibBorrow is used to convert raw C.GAsyncResultIface pointers to go. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibBorrow(p unsafe.Pointer) *AsyncResultIface {
	if p == nil {
		return nil
	}
	return &AsyncResultIface{&asyncResultIface{(*C.GAsyncResultIface)(p)}}
}

// UnsafeAsyncResultIfaceFromGlibNone is used to convert raw C.GAsyncResultIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibNone(p unsafe.Pointer) *AsyncResultIface {
	wrapped := UnsafeAsyncResultIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AsyncResultIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAsyncResultIfaceFromGlibFull is used to convert raw C.GAsyncResultIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibFull(p unsafe.Pointer) *AsyncResultIface {
	wrapped := UnsafeAsyncResultIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncResultIface,
		func (intern *asyncResultIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAsyncResultIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncResultIface] is expected to work anymore.
func UnsafeAsyncResultIfaceFree(a *AsyncResultIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAsyncResultIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncResultIfaceToGlibNone(a *AsyncResultIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncResultIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncResultIfaceToGlibFull(a *AsyncResultIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncResultIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncResultIface is invalid from here on
	return _p
}

// BufferedInputStreamClass wraps GBufferedInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.BufferedInputStreamClass.html
// 
// BufferedInputStreamClass is the type struct for [BufferedInputStream]
type BufferedInputStreamClass struct {
	*bufferedInputStreamClass
}

// bufferedInputStreamClass is the struct that's finalized
type bufferedInputStreamClass struct {
	native *C.GBufferedInputStreamClass
}

// UnsafeBufferedInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BufferedInputStreamClass) instance() *C.GBufferedInputStreamClass {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBufferedInputStreamClassFromGlibBorrow is used to convert raw C.GBufferedInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeBufferedInputStreamClassFromGlibBorrow(p unsafe.Pointer) *BufferedInputStreamClass {
	if p == nil {
		return nil
	}
	return &BufferedInputStreamClass{&bufferedInputStreamClass{(*C.GBufferedInputStreamClass)(p)}}
}

// UnsafeBufferedInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BufferedInputStreamClass] is expected to work anymore.
func UnsafeBufferedInputStreamClassFree(b *BufferedInputStreamClass) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeBufferedInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBufferedInputStreamClassToGlibNone(b *BufferedInputStreamClass) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (b *BufferedInputStreamClass) ParentClass() *FilterInputStreamClass {
	parent := UnsafeFilterInputStreamClassFromGlibBorrow(UnsafeBufferedInputStreamClassToGlibNone(b))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *BufferedInputStreamClass) {}, b)
	return parent
}

// BufferedOutputStreamClass wraps GBufferedOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.BufferedOutputStreamClass.html
// 
// BufferedOutputStreamClass is the type struct for [BufferedOutputStream]
type BufferedOutputStreamClass struct {
	*bufferedOutputStreamClass
}

// bufferedOutputStreamClass is the struct that's finalized
type bufferedOutputStreamClass struct {
	native *C.GBufferedOutputStreamClass
}

// UnsafeBufferedOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BufferedOutputStreamClass) instance() *C.GBufferedOutputStreamClass {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBufferedOutputStreamClassFromGlibBorrow is used to convert raw C.GBufferedOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeBufferedOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *BufferedOutputStreamClass {
	if p == nil {
		return nil
	}
	return &BufferedOutputStreamClass{&bufferedOutputStreamClass{(*C.GBufferedOutputStreamClass)(p)}}
}

// UnsafeBufferedOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BufferedOutputStreamClass] is expected to work anymore.
func UnsafeBufferedOutputStreamClassFree(b *BufferedOutputStreamClass) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeBufferedOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamClassToGlibNone(b *BufferedOutputStreamClass) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (b *BufferedOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeBufferedOutputStreamClassToGlibNone(b))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *BufferedOutputStreamClass) {}, b)
	return parent
}

// CancellableClass wraps GCancellableClass
// 
// see also https://docs.gtk.org/gio/struct.CancellableClass.html
// 
// CancellableClass is the type struct for [Cancellable]
type CancellableClass struct {
	*cancellableClass
}

// cancellableClass is the struct that's finalized
type cancellableClass struct {
	native *C.GCancellableClass
}

// UnsafeCancellableClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CancellableClass) instance() *C.GCancellableClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCancellableClassFromGlibBorrow is used to convert raw C.GCancellableClass pointers to go. This is used by the bindings internally.
func UnsafeCancellableClassFromGlibBorrow(p unsafe.Pointer) *CancellableClass {
	if p == nil {
		return nil
	}
	return &CancellableClass{&cancellableClass{(*C.GCancellableClass)(p)}}
}

// UnsafeCancellableClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CancellableClass] is expected to work anymore.
func UnsafeCancellableClassFree(c *CancellableClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCancellableClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCancellableClassToGlibNone(c *CancellableClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CancellableClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCancellableClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CancellableClass) {}, c)
	return parent
}

// CharsetConverterClass wraps GCharsetConverterClass
// 
// see also https://docs.gtk.org/gio/struct.CharsetConverterClass.html
// 
// CharsetConverterClass is the type struct for [CharsetConverter]
type CharsetConverterClass struct {
	*charsetConverterClass
}

// charsetConverterClass is the struct that's finalized
type charsetConverterClass struct {
	native *C.GCharsetConverterClass
}

// UnsafeCharsetConverterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CharsetConverterClass) instance() *C.GCharsetConverterClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCharsetConverterClassFromGlibBorrow is used to convert raw C.GCharsetConverterClass pointers to go. This is used by the bindings internally.
func UnsafeCharsetConverterClassFromGlibBorrow(p unsafe.Pointer) *CharsetConverterClass {
	if p == nil {
		return nil
	}
	return &CharsetConverterClass{&charsetConverterClass{(*C.GCharsetConverterClass)(p)}}
}

// UnsafeCharsetConverterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CharsetConverterClass] is expected to work anymore.
func UnsafeCharsetConverterClassFree(c *CharsetConverterClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCharsetConverterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCharsetConverterClassToGlibNone(c *CharsetConverterClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CharsetConverterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCharsetConverterClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CharsetConverterClass) {}, c)
	return parent
}

// ConverterIface wraps GConverterIface
// 
// see also https://docs.gtk.org/gio/struct.ConverterIface.html
//
type ConverterIface struct {
	*converterIface
}

// converterIface is the struct that's finalized
type converterIface struct {
	native *C.GConverterIface
}

// UnsafeConverterIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterIface) instance() *C.GConverterIface {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterIfaceFromGlibBorrow is used to convert raw C.GConverterIface pointers to go. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibBorrow(p unsafe.Pointer) *ConverterIface {
	if p == nil {
		return nil
	}
	return &ConverterIface{&converterIface{(*C.GConverterIface)(p)}}
}

// UnsafeConverterIfaceFromGlibNone is used to convert raw C.GConverterIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibNone(p unsafe.Pointer) *ConverterIface {
	wrapped := UnsafeConverterIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ConverterIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeConverterIfaceFromGlibFull is used to convert raw C.GConverterIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibFull(p unsafe.Pointer) *ConverterIface {
	wrapped := UnsafeConverterIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.converterIface,
		func (intern *converterIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeConverterIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterIface] is expected to work anymore.
func UnsafeConverterIfaceFree(c *ConverterIface) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterIfaceToGlibNone(c *ConverterIface) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeConverterIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeConverterIfaceToGlibFull(c *ConverterIface) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.converterIface, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // ConverterIface is invalid from here on
	return _p
}

// ConverterInputStreamClass wraps GConverterInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.ConverterInputStreamClass.html
// 
// ConverterInputStreamClass is the type struct for [ConverterInputStream]
type ConverterInputStreamClass struct {
	*converterInputStreamClass
}

// converterInputStreamClass is the struct that's finalized
type converterInputStreamClass struct {
	native *C.GConverterInputStreamClass
}

// UnsafeConverterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterInputStreamClass) instance() *C.GConverterInputStreamClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterInputStreamClassFromGlibBorrow is used to convert raw C.GConverterInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeConverterInputStreamClassFromGlibBorrow(p unsafe.Pointer) *ConverterInputStreamClass {
	if p == nil {
		return nil
	}
	return &ConverterInputStreamClass{&converterInputStreamClass{(*C.GConverterInputStreamClass)(p)}}
}

// UnsafeConverterInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterInputStreamClass] is expected to work anymore.
func UnsafeConverterInputStreamClassFree(c *ConverterInputStreamClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterInputStreamClassToGlibNone(c *ConverterInputStreamClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *ConverterInputStreamClass) ParentClass() *FilterInputStreamClass {
	parent := UnsafeFilterInputStreamClassFromGlibBorrow(UnsafeConverterInputStreamClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ConverterInputStreamClass) {}, c)
	return parent
}

// ConverterOutputStreamClass wraps GConverterOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.ConverterOutputStreamClass.html
// 
// ConverterOutputStreamClass is the type struct for [ConverterOutputStream]
type ConverterOutputStreamClass struct {
	*converterOutputStreamClass
}

// converterOutputStreamClass is the struct that's finalized
type converterOutputStreamClass struct {
	native *C.GConverterOutputStreamClass
}

// UnsafeConverterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterOutputStreamClass) instance() *C.GConverterOutputStreamClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterOutputStreamClassFromGlibBorrow is used to convert raw C.GConverterOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeConverterOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *ConverterOutputStreamClass {
	if p == nil {
		return nil
	}
	return &ConverterOutputStreamClass{&converterOutputStreamClass{(*C.GConverterOutputStreamClass)(p)}}
}

// UnsafeConverterOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterOutputStreamClass] is expected to work anymore.
func UnsafeConverterOutputStreamClassFree(c *ConverterOutputStreamClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterOutputStreamClassToGlibNone(c *ConverterOutputStreamClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *ConverterOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeConverterOutputStreamClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ConverterOutputStreamClass) {}, c)
	return parent
}

// CredentialsClass wraps GCredentialsClass
// 
// see also https://docs.gtk.org/gio/struct.CredentialsClass.html
//
// 
// CredentialsClass is the type struct for [Credentials]
type CredentialsClass struct {
	*credentialsClass
}

// credentialsClass is the struct that's finalized
type credentialsClass struct {
	native *C.GCredentialsClass
}

// UnsafeCredentialsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CredentialsClass) instance() *C.GCredentialsClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCredentialsClassFromGlibBorrow is used to convert raw C.GCredentialsClass pointers to go. This is used by the bindings internally.
func UnsafeCredentialsClassFromGlibBorrow(p unsafe.Pointer) *CredentialsClass {
	if p == nil {
		return nil
	}
	return &CredentialsClass{&credentialsClass{(*C.GCredentialsClass)(p)}}
}

// UnsafeCredentialsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CredentialsClass] is expected to work anymore.
func UnsafeCredentialsClassFree(c *CredentialsClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCredentialsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCredentialsClassToGlibNone(c *CredentialsClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CredentialsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCredentialsClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CredentialsClass) {}, c)
	return parent
}

// DataInputStreamClass wraps GDataInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.DataInputStreamClass.html
// 
// DataInputStreamClass is the type struct for [DataInputStream]
type DataInputStreamClass struct {
	*dataInputStreamClass
}

// dataInputStreamClass is the struct that's finalized
type dataInputStreamClass struct {
	native *C.GDataInputStreamClass
}

// UnsafeDataInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DataInputStreamClass) instance() *C.GDataInputStreamClass {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataInputStreamClassFromGlibBorrow is used to convert raw C.GDataInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeDataInputStreamClassFromGlibBorrow(p unsafe.Pointer) *DataInputStreamClass {
	if p == nil {
		return nil
	}
	return &DataInputStreamClass{&dataInputStreamClass{(*C.GDataInputStreamClass)(p)}}
}

// UnsafeDataInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DataInputStreamClass] is expected to work anymore.
func UnsafeDataInputStreamClassFree(d *DataInputStreamClass) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataInputStreamClassToGlibNone(d *DataInputStreamClass) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (d *DataInputStreamClass) ParentClass() *BufferedInputStreamClass {
	parent := UnsafeBufferedInputStreamClassFromGlibBorrow(UnsafeDataInputStreamClassToGlibNone(d))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *DataInputStreamClass) {}, d)
	return parent
}

// DataOutputStreamClass wraps GDataOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.DataOutputStreamClass.html
// 
// DataOutputStreamClass is the type struct for [DataOutputStream]
type DataOutputStreamClass struct {
	*dataOutputStreamClass
}

// dataOutputStreamClass is the struct that's finalized
type dataOutputStreamClass struct {
	native *C.GDataOutputStreamClass
}

// UnsafeDataOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DataOutputStreamClass) instance() *C.GDataOutputStreamClass {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataOutputStreamClassFromGlibBorrow is used to convert raw C.GDataOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeDataOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *DataOutputStreamClass {
	if p == nil {
		return nil
	}
	return &DataOutputStreamClass{&dataOutputStreamClass{(*C.GDataOutputStreamClass)(p)}}
}

// UnsafeDataOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DataOutputStreamClass] is expected to work anymore.
func UnsafeDataOutputStreamClassFree(d *DataOutputStreamClass) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataOutputStreamClassToGlibNone(d *DataOutputStreamClass) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (d *DataOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeDataOutputStreamClassToGlibNone(d))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *DataOutputStreamClass) {}, d)
	return parent
}

// DatagramBasedInterface wraps GDatagramBasedInterface
// 
// see also https://docs.gtk.org/gio/struct.DatagramBasedInterface.html
//
type DatagramBasedInterface struct {
	*datagramBasedInterface
}

// datagramBasedInterface is the struct that's finalized
type datagramBasedInterface struct {
	native *C.GDatagramBasedInterface
}

// UnsafeDatagramBasedInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DatagramBasedInterface) instance() *C.GDatagramBasedInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDatagramBasedInterfaceFromGlibBorrow is used to convert raw C.GDatagramBasedInterface pointers to go. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibBorrow(p unsafe.Pointer) *DatagramBasedInterface {
	if p == nil {
		return nil
	}
	return &DatagramBasedInterface{&datagramBasedInterface{(*C.GDatagramBasedInterface)(p)}}
}

// UnsafeDatagramBasedInterfaceFromGlibNone is used to convert raw C.GDatagramBasedInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibNone(p unsafe.Pointer) *DatagramBasedInterface {
	wrapped := UnsafeDatagramBasedInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DatagramBasedInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDatagramBasedInterfaceFromGlibFull is used to convert raw C.GDatagramBasedInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibFull(p unsafe.Pointer) *DatagramBasedInterface {
	wrapped := UnsafeDatagramBasedInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.datagramBasedInterface,
		func (intern *datagramBasedInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDatagramBasedInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DatagramBasedInterface] is expected to work anymore.
func UnsafeDatagramBasedInterfaceFree(d *DatagramBasedInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDatagramBasedInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceToGlibNone(d *DatagramBasedInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDatagramBasedInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceToGlibFull(d *DatagramBasedInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.datagramBasedInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DatagramBasedInterface is invalid from here on
	return _p
}

// DebugControllerInterface wraps GDebugControllerInterface
// 
// see also https://docs.gtk.org/gio/struct.DebugControllerInterface.html
//
type DebugControllerInterface struct {
	*debugControllerInterface
}

// debugControllerInterface is the struct that's finalized
type debugControllerInterface struct {
	native *C.GDebugControllerInterface
}

// UnsafeDebugControllerInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DebugControllerInterface) instance() *C.GDebugControllerInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDebugControllerInterfaceFromGlibBorrow is used to convert raw C.GDebugControllerInterface pointers to go. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibBorrow(p unsafe.Pointer) *DebugControllerInterface {
	if p == nil {
		return nil
	}
	return &DebugControllerInterface{&debugControllerInterface{(*C.GDebugControllerInterface)(p)}}
}

// UnsafeDebugControllerInterfaceFromGlibNone is used to convert raw C.GDebugControllerInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibNone(p unsafe.Pointer) *DebugControllerInterface {
	wrapped := UnsafeDebugControllerInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DebugControllerInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDebugControllerInterfaceFromGlibFull is used to convert raw C.GDebugControllerInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibFull(p unsafe.Pointer) *DebugControllerInterface {
	wrapped := UnsafeDebugControllerInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.debugControllerInterface,
		func (intern *debugControllerInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDebugControllerInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DebugControllerInterface] is expected to work anymore.
func UnsafeDebugControllerInterfaceFree(d *DebugControllerInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDebugControllerInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceToGlibNone(d *DebugControllerInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDebugControllerInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDebugControllerInterfaceToGlibFull(d *DebugControllerInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.debugControllerInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DebugControllerInterface is invalid from here on
	return _p
}

// DriveIface wraps GDriveIface
// 
// see also https://docs.gtk.org/gio/struct.DriveIface.html
//
type DriveIface struct {
	*driveIface
}

// driveIface is the struct that's finalized
type driveIface struct {
	native *C.GDriveIface
}

// UnsafeDriveIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DriveIface) instance() *C.GDriveIface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDriveIfaceFromGlibBorrow is used to convert raw C.GDriveIface pointers to go. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibBorrow(p unsafe.Pointer) *DriveIface {
	if p == nil {
		return nil
	}
	return &DriveIface{&driveIface{(*C.GDriveIface)(p)}}
}

// UnsafeDriveIfaceFromGlibNone is used to convert raw C.GDriveIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibNone(p unsafe.Pointer) *DriveIface {
	wrapped := UnsafeDriveIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DriveIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDriveIfaceFromGlibFull is used to convert raw C.GDriveIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibFull(p unsafe.Pointer) *DriveIface {
	wrapped := UnsafeDriveIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.driveIface,
		func (intern *driveIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDriveIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DriveIface] is expected to work anymore.
func UnsafeDriveIfaceFree(d *DriveIface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDriveIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDriveIfaceToGlibNone(d *DriveIface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDriveIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDriveIfaceToGlibFull(d *DriveIface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.driveIface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DriveIface is invalid from here on
	return _p
}

// DtlsClientConnectionInterface wraps GDtlsClientConnectionInterface
// 
// see also https://docs.gtk.org/gio/struct.DtlsClientConnectionInterface.html
//
type DtlsClientConnectionInterface struct {
	*dtlsClientConnectionInterface
}

// dtlsClientConnectionInterface is the struct that's finalized
type dtlsClientConnectionInterface struct {
	native *C.GDtlsClientConnectionInterface
}

// UnsafeDtlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsClientConnectionInterface) instance() *C.GDtlsClientConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsClientConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsClientConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsClientConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsClientConnectionInterface{&dtlsClientConnectionInterface{(*C.GDtlsClientConnectionInterface)(p)}}
}

// UnsafeDtlsClientConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsClientConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsClientConnectionInterface {
	wrapped := UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsClientConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsClientConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsClientConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsClientConnectionInterface {
	wrapped := UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsClientConnectionInterface,
		func (intern *dtlsClientConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsClientConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsClientConnectionInterface] is expected to work anymore.
func UnsafeDtlsClientConnectionInterfaceFree(d *DtlsClientConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceToGlibNone(d *DtlsClientConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsClientConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceToGlibFull(d *DtlsClientConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsClientConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsClientConnectionInterface is invalid from here on
	return _p
}

// DtlsConnectionInterface wraps GDtlsConnectionInterface
// 
// see also https://docs.gtk.org/gio/struct.DtlsConnectionInterface.html
//
type DtlsConnectionInterface struct {
	*dtlsConnectionInterface
}

// dtlsConnectionInterface is the struct that's finalized
type dtlsConnectionInterface struct {
	native *C.GDtlsConnectionInterface
}

// UnsafeDtlsConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsConnectionInterface) instance() *C.GDtlsConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsConnectionInterface{&dtlsConnectionInterface{(*C.GDtlsConnectionInterface)(p)}}
}

// UnsafeDtlsConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsConnectionInterface {
	wrapped := UnsafeDtlsConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsConnectionInterface {
	wrapped := UnsafeDtlsConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsConnectionInterface,
		func (intern *dtlsConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsConnectionInterface] is expected to work anymore.
func UnsafeDtlsConnectionInterfaceFree(d *DtlsConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceToGlibNone(d *DtlsConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceToGlibFull(d *DtlsConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsConnectionInterface is invalid from here on
	return _p
}

// DtlsServerConnectionInterface wraps GDtlsServerConnectionInterface
// 
// see also https://docs.gtk.org/gio/struct.DtlsServerConnectionInterface.html
//
type DtlsServerConnectionInterface struct {
	*dtlsServerConnectionInterface
}

// dtlsServerConnectionInterface is the struct that's finalized
type dtlsServerConnectionInterface struct {
	native *C.GDtlsServerConnectionInterface
}

// UnsafeDtlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsServerConnectionInterface) instance() *C.GDtlsServerConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsServerConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsServerConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsServerConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsServerConnectionInterface{&dtlsServerConnectionInterface{(*C.GDtlsServerConnectionInterface)(p)}}
}

// UnsafeDtlsServerConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsServerConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsServerConnectionInterface {
	wrapped := UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsServerConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsServerConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsServerConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsServerConnectionInterface {
	wrapped := UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsServerConnectionInterface,
		func (intern *dtlsServerConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsServerConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsServerConnectionInterface] is expected to work anymore.
func UnsafeDtlsServerConnectionInterfaceFree(d *DtlsServerConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceToGlibNone(d *DtlsServerConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsServerConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceToGlibFull(d *DtlsServerConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsServerConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsServerConnectionInterface is invalid from here on
	return _p
}

// EmblemClass wraps GEmblemClass
// 
// see also https://docs.gtk.org/gio/struct.EmblemClass.html
// 
// EmblemClass is the type struct for [Emblem]
type EmblemClass struct {
	*emblemClass
}

// emblemClass is the struct that's finalized
type emblemClass struct {
	native *C.GEmblemClass
}

// UnsafeEmblemClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EmblemClass) instance() *C.GEmblemClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEmblemClassFromGlibBorrow is used to convert raw C.GEmblemClass pointers to go. This is used by the bindings internally.
func UnsafeEmblemClassFromGlibBorrow(p unsafe.Pointer) *EmblemClass {
	if p == nil {
		return nil
	}
	return &EmblemClass{&emblemClass{(*C.GEmblemClass)(p)}}
}

// UnsafeEmblemClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EmblemClass] is expected to work anymore.
func UnsafeEmblemClassFree(e *EmblemClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEmblemClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEmblemClassToGlibNone(e *EmblemClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (e *EmblemClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeEmblemClassToGlibNone(e))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *EmblemClass) {}, e)
	return parent
}

// EmblemedIconClass wraps GEmblemedIconClass
// 
// see also https://docs.gtk.org/gio/struct.EmblemedIconClass.html
// 
// EmblemedIconClass is the type struct for [EmblemedIcon]
type EmblemedIconClass struct {
	*emblemedIconClass
}

// emblemedIconClass is the struct that's finalized
type emblemedIconClass struct {
	native *C.GEmblemedIconClass
}

// UnsafeEmblemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EmblemedIconClass) instance() *C.GEmblemedIconClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEmblemedIconClassFromGlibBorrow is used to convert raw C.GEmblemedIconClass pointers to go. This is used by the bindings internally.
func UnsafeEmblemedIconClassFromGlibBorrow(p unsafe.Pointer) *EmblemedIconClass {
	if p == nil {
		return nil
	}
	return &EmblemedIconClass{&emblemedIconClass{(*C.GEmblemedIconClass)(p)}}
}

// UnsafeEmblemedIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EmblemedIconClass] is expected to work anymore.
func UnsafeEmblemedIconClassFree(e *EmblemedIconClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEmblemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEmblemedIconClassToGlibNone(e *EmblemedIconClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (e *EmblemedIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeEmblemedIconClassToGlibNone(e))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *EmblemedIconClass) {}, e)
	return parent
}

// FileAttributeInfo wraps GFileAttributeInfo
// 
// see also https://docs.gtk.org/gio/struct.FileAttributeInfo.html
//
type FileAttributeInfo struct {
	*fileAttributeInfo
}

// fileAttributeInfo is the struct that's finalized
type fileAttributeInfo struct {
	native *C.GFileAttributeInfo
}

// UnsafeFileAttributeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeInfo) instance() *C.GFileAttributeInfo {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileAttributeInfoFromGlibBorrow is used to convert raw C.GFileAttributeInfo pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibBorrow(p unsafe.Pointer) *FileAttributeInfo {
	if p == nil {
		return nil
	}
	return &FileAttributeInfo{&fileAttributeInfo{(*C.GFileAttributeInfo)(p)}}
}

// UnsafeFileAttributeInfoFromGlibNone is used to convert raw C.GFileAttributeInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibNone(p unsafe.Pointer) *FileAttributeInfo {
	wrapped := UnsafeFileAttributeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FileAttributeInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFileAttributeInfoFromGlibFull is used to convert raw C.GFileAttributeInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibFull(p unsafe.Pointer) *FileAttributeInfo {
	wrapped := UnsafeFileAttributeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeInfo,
		func (intern *fileAttributeInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeInfo] is expected to work anymore.
func UnsafeFileAttributeInfoFree(f *FileAttributeInfo) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileAttributeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeInfoToGlibNone(f *FileAttributeInfo) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeInfoToGlibFull(f *FileAttributeInfo) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeInfo, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeInfo is invalid from here on
	return _p
}

// FileAttributeInfoList wraps GFileAttributeInfoList
// 
// see also https://docs.gtk.org/gio/struct.FileAttributeInfoList.html
//
type FileAttributeInfoList struct {
	*fileAttributeInfoList
}

// fileAttributeInfoList is the struct that's finalized
type fileAttributeInfoList struct {
	native *C.GFileAttributeInfoList
}

// UnsafeFileAttributeInfoListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeInfoList) instance() *C.GFileAttributeInfoList {
	if f == nil {
		return nil
	}
	return f.native
}

var _ gobject.GoValueInitializer = (*FileAttributeInfoList)(nil)

func marshalFileAttributeInfoList(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeFileAttributeInfoListFromGlibNone(b), nil
}

func (r *FileAttributeInfoList) GoValueType() gobject.Type {
	return TypeFileAttributeInfoList
}

func (r *FileAttributeInfoList) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeFileAttributeInfoListFromGlibBorrow is used to convert raw C.GFileAttributeInfoList pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibBorrow(p unsafe.Pointer) *FileAttributeInfoList {
	if p == nil {
		return nil
	}
	return &FileAttributeInfoList{&fileAttributeInfoList{(*C.GFileAttributeInfoList)(p)}}
}

// UnsafeFileAttributeInfoListFromGlibNone is used to convert raw C.GFileAttributeInfoList pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibNone(p unsafe.Pointer) *FileAttributeInfoList {
	C.g_file_attribute_info_list_ref((*C.GFileAttributeInfoList)(p))
	wrapped := UnsafeFileAttributeInfoListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.fileAttributeInfoList,
		func (intern *fileAttributeInfoList) {
			C.g_file_attribute_info_list_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoListFromGlibFull is used to convert raw C.GFileAttributeInfoList pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibFull(p unsafe.Pointer) *FileAttributeInfoList {
	wrapped := UnsafeFileAttributeInfoListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeInfoList,
		func (intern *fileAttributeInfoList) {
			C.g_file_attribute_info_list_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoListRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [FileAttributeInfoList.UnsafeFileAttributeInfoListUnref], then [FileAttributeInfoList] will leak memory.
func UnsafeFileAttributeInfoListRef(f *FileAttributeInfoList) {
	C.g_file_attribute_info_list_ref((*C.GFileAttributeInfoList)(f.native))
}

// UnsafeFileAttributeInfoListUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeInfoList] is expected to work anymore.
func UnsafeFileAttributeInfoListUnref(f *FileAttributeInfoList) {
	C.g_file_attribute_info_list_unref(f.native)
}

// UnsafeFileAttributeInfoListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeInfoListToGlibNone(f *FileAttributeInfoList) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeInfoListToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeInfoListToGlibFull(f *FileAttributeInfoList) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeInfoList, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeInfoList is invalid from here on
	return _p
}

// NewFileAttributeInfoList wraps g_file_attribute_info_list_new
// 
// see also https://docs.gtk.org/gio/func.g_file_attribute_info_list_new.html
//
func NewFileAttributeInfoList() *FileAttributeInfoList {
	var cret *C.GFileAttributeInfoList // return, full, converted

	cret = C.g_file_attribute_info_list_new()

	var goret *FileAttributeInfoList

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Add wraps g_file_attribute_info_list_add
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_info_list_add.g_file_attribute_info_list_add.html
//
func (list *FileAttributeInfoList) Add(name string, typ FileAttributeType, flags FileAttributeInfoFlags) {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var carg1 *C.char                   // in, none, string
	var carg2 C.GFileAttributeType      // in, none, casted
	var carg3 C.GFileAttributeInfoFlags // in, none, casted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileAttributeType(typ)
	carg3 = C.GFileAttributeInfoFlags(flags)

	C.g_file_attribute_info_list_add(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)
}

// Dup wraps g_file_attribute_info_list_dup
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_info_list_dup.g_file_attribute_info_list_dup.html
//
func (list *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var cret  *C.GFileAttributeInfoList // return, full, converted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))

	cret = C.g_file_attribute_info_list_dup(carg0)
	runtime.KeepAlive(list)

	var goret *FileAttributeInfoList

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Lookup wraps g_file_attribute_info_list_lookup
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_info_list_lookup.g_file_attribute_info_list_lookup.html
//
func (list *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var carg1 *C.char                   // in, none, string
	var cret  *C.GFileAttributeInfo     // return, none, converted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_info_list_lookup(carg0, carg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)

	var goret *FileAttributeInfo

	goret = UnsafeFileAttributeInfoFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// FileAttributeMatcher wraps GFileAttributeMatcher
// 
// see also https://docs.gtk.org/gio/struct.FileAttributeMatcher.html
//
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized
type fileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

// UnsafeFileAttributeMatcherToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeMatcher) instance() *C.GFileAttributeMatcher {
	if f == nil {
		return nil
	}
	return f.native
}

var _ gobject.GoValueInitializer = (*FileAttributeMatcher)(nil)

func marshalFileAttributeMatcher(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeFileAttributeMatcherFromGlibNone(b), nil
}

func (r *FileAttributeMatcher) GoValueType() gobject.Type {
	return TypeFileAttributeMatcher
}

func (r *FileAttributeMatcher) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeFileAttributeMatcherFromGlibBorrow is used to convert raw C.GFileAttributeMatcher pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibBorrow(p unsafe.Pointer) *FileAttributeMatcher {
	if p == nil {
		return nil
	}
	return &FileAttributeMatcher{&fileAttributeMatcher{(*C.GFileAttributeMatcher)(p)}}
}

// UnsafeFileAttributeMatcherFromGlibNone is used to convert raw C.GFileAttributeMatcher pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibNone(p unsafe.Pointer) *FileAttributeMatcher {
	C.g_file_attribute_matcher_ref((*C.GFileAttributeMatcher)(p))
	wrapped := UnsafeFileAttributeMatcherFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.fileAttributeMatcher,
		func (intern *fileAttributeMatcher) {
			C.g_file_attribute_matcher_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeMatcherFromGlibFull is used to convert raw C.GFileAttributeMatcher pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibFull(p unsafe.Pointer) *FileAttributeMatcher {
	wrapped := UnsafeFileAttributeMatcherFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeMatcher,
		func (intern *fileAttributeMatcher) {
			C.g_file_attribute_matcher_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeMatcherRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [FileAttributeMatcher.UnsafeFileAttributeMatcherUnref], then [FileAttributeMatcher] will leak memory.
func UnsafeFileAttributeMatcherRef(f *FileAttributeMatcher) {
	C.g_file_attribute_matcher_ref((*C.GFileAttributeMatcher)(f.native))
}

// UnsafeFileAttributeMatcherUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeMatcher] is expected to work anymore.
func UnsafeFileAttributeMatcherUnref(f *FileAttributeMatcher) {
	C.g_file_attribute_matcher_unref(f.native)
}

// UnsafeFileAttributeMatcherToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeMatcherToGlibNone(f *FileAttributeMatcher) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeMatcherToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeMatcherToGlibFull(f *FileAttributeMatcher) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeMatcher, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeMatcher is invalid from here on
	return _p
}

// NewFileAttributeMatcher wraps g_file_attribute_matcher_new
// 
// see also https://docs.gtk.org/gio/func.g_file_attribute_matcher_new.html
//
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var carg1 *C.char                  // in, none, string
	var cret  *C.GFileAttributeMatcher // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_new(carg1)
	runtime.KeepAlive(attributes)

	var goret *FileAttributeMatcher

	goret = UnsafeFileAttributeMatcherFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// EnumerateNamespace wraps g_file_attribute_matcher_enumerate_namespace
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_enumerate_namespace.g_file_attribute_matcher_enumerate_namespace.html
//
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(ns)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_enumerate_namespace(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(ns)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// EnumerateNext wraps g_file_attribute_matcher_enumerate_next
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_enumerate_next.g_file_attribute_matcher_enumerate_next.html
//
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var cret  *C.char                  // return, none, string, nullable-string

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))

	cret = C.g_file_attribute_matcher_enumerate_next(carg0)
	runtime.KeepAlive(matcher)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Matches wraps g_file_attribute_matcher_matches
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_matches.g_file_attribute_matcher_matches.html
//
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_matches(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MatchesOnly wraps g_file_attribute_matcher_matches_only
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_matches_only.g_file_attribute_matcher_matches_only.html
//
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_matches_only(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Subtract wraps g_file_attribute_matcher_subtract
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_subtract.g_file_attribute_matcher_subtract.html
//
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.GFileAttributeMatcher // in, none, converted, nullable
	var cret  *C.GFileAttributeMatcher // return, full, converted, nullable

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	if subtract != nil {
		carg1 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(subtract))
	}

	cret = C.g_file_attribute_matcher_subtract(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(subtract)

	var goret *FileAttributeMatcher

	if cret != nil {
		goret = UnsafeFileAttributeMatcherFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// String wraps g_file_attribute_matcher_to_string
// 
// see also https://docs.gtk.org/gio/method.g_file_attribute_matcher_to_string.g_file_attribute_matcher_to_string.html
//
func (matcher *FileAttributeMatcher) String() string {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var cret  *C.char                  // return, full, string

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))

	cret = C.g_file_attribute_matcher_to_string(carg0)
	runtime.KeepAlive(matcher)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FileEnumeratorClass wraps GFileEnumeratorClass
// 
// see also https://docs.gtk.org/gio/struct.FileEnumeratorClass.html
// 
// FileEnumeratorClass is the type struct for [FileEnumerator]
type FileEnumeratorClass struct {
	*fileEnumeratorClass
}

// fileEnumeratorClass is the struct that's finalized
type fileEnumeratorClass struct {
	native *C.GFileEnumeratorClass
}

// UnsafeFileEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileEnumeratorClass) instance() *C.GFileEnumeratorClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileEnumeratorClassFromGlibBorrow is used to convert raw C.GFileEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeFileEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *FileEnumeratorClass {
	if p == nil {
		return nil
	}
	return &FileEnumeratorClass{&fileEnumeratorClass{(*C.GFileEnumeratorClass)(p)}}
}

// UnsafeFileEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileEnumeratorClass] is expected to work anymore.
func UnsafeFileEnumeratorClassFree(f *FileEnumeratorClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileEnumeratorClassToGlibNone(f *FileEnumeratorClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileEnumeratorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileEnumeratorClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileEnumeratorClass) {}, f)
	return parent
}

// FileIOStreamClass wraps GFileIOStreamClass
// 
// see also https://docs.gtk.org/gio/struct.FileIOStreamClass.html
// 
// FileIOStreamClass is the type struct for [FileIOStream]
type FileIOStreamClass struct {
	*fileIOStreamClass
}

// fileIOStreamClass is the struct that's finalized
type fileIOStreamClass struct {
	native *C.GFileIOStreamClass
}

// UnsafeFileIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIOStreamClass) instance() *C.GFileIOStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIOStreamClassFromGlibBorrow is used to convert raw C.GFileIOStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileIOStreamClassFromGlibBorrow(p unsafe.Pointer) *FileIOStreamClass {
	if p == nil {
		return nil
	}
	return &FileIOStreamClass{&fileIOStreamClass{(*C.GFileIOStreamClass)(p)}}
}

// UnsafeFileIOStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIOStreamClass] is expected to work anymore.
func UnsafeFileIOStreamClassFree(f *FileIOStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIOStreamClassToGlibNone(f *FileIOStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileIOStreamClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeFileIOStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileIOStreamClass) {}, f)
	return parent
}

// FileIconClass wraps GFileIconClass
// 
// see also https://docs.gtk.org/gio/struct.FileIconClass.html
// 
// FileIconClass is the type struct for [FileIcon]
type FileIconClass struct {
	*fileIconClass
}

// fileIconClass is the struct that's finalized
type fileIconClass struct {
	native *C.GFileIconClass
}

// UnsafeFileIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIconClass) instance() *C.GFileIconClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIconClassFromGlibBorrow is used to convert raw C.GFileIconClass pointers to go. This is used by the bindings internally.
func UnsafeFileIconClassFromGlibBorrow(p unsafe.Pointer) *FileIconClass {
	if p == nil {
		return nil
	}
	return &FileIconClass{&fileIconClass{(*C.GFileIconClass)(p)}}
}

// UnsafeFileIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIconClass] is expected to work anymore.
func UnsafeFileIconClassFree(f *FileIconClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIconClassToGlibNone(f *FileIconClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileIconClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileIconClass) {}, f)
	return parent
}

// FileIface wraps GFileIface
// 
// see also https://docs.gtk.org/gio/struct.FileIface.html
//
type FileIface struct {
	*fileIface
}

// fileIface is the struct that's finalized
type fileIface struct {
	native *C.GFileIface
}

// UnsafeFileIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIface) instance() *C.GFileIface {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIfaceFromGlibBorrow is used to convert raw C.GFileIface pointers to go. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibBorrow(p unsafe.Pointer) *FileIface {
	if p == nil {
		return nil
	}
	return &FileIface{&fileIface{(*C.GFileIface)(p)}}
}

// UnsafeFileIfaceFromGlibNone is used to convert raw C.GFileIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibNone(p unsafe.Pointer) *FileIface {
	wrapped := UnsafeFileIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FileIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFileIfaceFromGlibFull is used to convert raw C.GFileIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibFull(p unsafe.Pointer) *FileIface {
	wrapped := UnsafeFileIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileIface,
		func (intern *fileIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFileIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIface] is expected to work anymore.
func UnsafeFileIfaceFree(f *FileIface) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIfaceToGlibNone(f *FileIface) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileIfaceToGlibFull(f *FileIface) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileIface, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileIface is invalid from here on
	return _p
}

// FileInfoClass wraps GFileInfoClass
// 
// see also https://docs.gtk.org/gio/struct.FileInfoClass.html
// 
// FileInfoClass is the type struct for [FileInfo]
type FileInfoClass struct {
	*fileInfoClass
}

// fileInfoClass is the struct that's finalized
type fileInfoClass struct {
	native *C.GFileInfoClass
}

// UnsafeFileInfoClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileInfoClass) instance() *C.GFileInfoClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileInfoClassFromGlibBorrow is used to convert raw C.GFileInfoClass pointers to go. This is used by the bindings internally.
func UnsafeFileInfoClassFromGlibBorrow(p unsafe.Pointer) *FileInfoClass {
	if p == nil {
		return nil
	}
	return &FileInfoClass{&fileInfoClass{(*C.GFileInfoClass)(p)}}
}

// UnsafeFileInfoClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileInfoClass] is expected to work anymore.
func UnsafeFileInfoClassFree(f *FileInfoClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileInfoClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileInfoClassToGlibNone(f *FileInfoClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileInfoClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileInfoClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileInfoClass) {}, f)
	return parent
}

// FileInputStreamClass wraps GFileInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.FileInputStreamClass.html
// 
// FileInputStreamClass is the type struct for [FileInputStream]
type FileInputStreamClass struct {
	*fileInputStreamClass
}

// fileInputStreamClass is the struct that's finalized
type fileInputStreamClass struct {
	native *C.GFileInputStreamClass
}

// UnsafeFileInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileInputStreamClass) instance() *C.GFileInputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileInputStreamClassFromGlibBorrow is used to convert raw C.GFileInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileInputStreamClassFromGlibBorrow(p unsafe.Pointer) *FileInputStreamClass {
	if p == nil {
		return nil
	}
	return &FileInputStreamClass{&fileInputStreamClass{(*C.GFileInputStreamClass)(p)}}
}

// UnsafeFileInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileInputStreamClass] is expected to work anymore.
func UnsafeFileInputStreamClassFree(f *FileInputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileInputStreamClassToGlibNone(f *FileInputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeFileInputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileInputStreamClass) {}, f)
	return parent
}

// FileMonitorClass wraps GFileMonitorClass
// 
// see also https://docs.gtk.org/gio/struct.FileMonitorClass.html
// 
// FileMonitorClass is the type struct for [FileMonitor]
type FileMonitorClass struct {
	*fileMonitorClass
}

// fileMonitorClass is the struct that's finalized
type fileMonitorClass struct {
	native *C.GFileMonitorClass
}

// UnsafeFileMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileMonitorClass) instance() *C.GFileMonitorClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileMonitorClassFromGlibBorrow is used to convert raw C.GFileMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeFileMonitorClassFromGlibBorrow(p unsafe.Pointer) *FileMonitorClass {
	if p == nil {
		return nil
	}
	return &FileMonitorClass{&fileMonitorClass{(*C.GFileMonitorClass)(p)}}
}

// UnsafeFileMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileMonitorClass] is expected to work anymore.
func UnsafeFileMonitorClassFree(f *FileMonitorClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileMonitorClassToGlibNone(f *FileMonitorClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileMonitorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileMonitorClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileMonitorClass) {}, f)
	return parent
}

// FileOutputStreamClass wraps GFileOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.FileOutputStreamClass.html
// 
// FileOutputStreamClass is the type struct for [FileOutputStream]
type FileOutputStreamClass struct {
	*fileOutputStreamClass
}

// fileOutputStreamClass is the struct that's finalized
type fileOutputStreamClass struct {
	native *C.GFileOutputStreamClass
}

// UnsafeFileOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileOutputStreamClass) instance() *C.GFileOutputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileOutputStreamClassFromGlibBorrow is used to convert raw C.GFileOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *FileOutputStreamClass {
	if p == nil {
		return nil
	}
	return &FileOutputStreamClass{&fileOutputStreamClass{(*C.GFileOutputStreamClass)(p)}}
}

// UnsafeFileOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileOutputStreamClass] is expected to work anymore.
func UnsafeFileOutputStreamClassFree(f *FileOutputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileOutputStreamClassToGlibNone(f *FileOutputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeFileOutputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileOutputStreamClass) {}, f)
	return parent
}

// FilenameCompleterClass wraps GFilenameCompleterClass
// 
// see also https://docs.gtk.org/gio/struct.FilenameCompleterClass.html
// 
// FilenameCompleterClass is the type struct for [FilenameCompleter]
type FilenameCompleterClass struct {
	*filenameCompleterClass
}

// filenameCompleterClass is the struct that's finalized
type filenameCompleterClass struct {
	native *C.GFilenameCompleterClass
}

// UnsafeFilenameCompleterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilenameCompleterClass) instance() *C.GFilenameCompleterClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilenameCompleterClassFromGlibBorrow is used to convert raw C.GFilenameCompleterClass pointers to go. This is used by the bindings internally.
func UnsafeFilenameCompleterClassFromGlibBorrow(p unsafe.Pointer) *FilenameCompleterClass {
	if p == nil {
		return nil
	}
	return &FilenameCompleterClass{&filenameCompleterClass{(*C.GFilenameCompleterClass)(p)}}
}

// UnsafeFilenameCompleterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilenameCompleterClass] is expected to work anymore.
func UnsafeFilenameCompleterClassFree(f *FilenameCompleterClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilenameCompleterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilenameCompleterClassToGlibNone(f *FilenameCompleterClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilenameCompleterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFilenameCompleterClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilenameCompleterClass) {}, f)
	return parent
}

// FilterInputStreamClass wraps GFilterInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.FilterInputStreamClass.html
// 
// FilterInputStreamClass is the type struct for [FilterInputStream]
type FilterInputStreamClass struct {
	*filterInputStreamClass
}

// filterInputStreamClass is the struct that's finalized
type filterInputStreamClass struct {
	native *C.GFilterInputStreamClass
}

// UnsafeFilterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilterInputStreamClass) instance() *C.GFilterInputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilterInputStreamClassFromGlibBorrow is used to convert raw C.GFilterInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFilterInputStreamClassFromGlibBorrow(p unsafe.Pointer) *FilterInputStreamClass {
	if p == nil {
		return nil
	}
	return &FilterInputStreamClass{&filterInputStreamClass{(*C.GFilterInputStreamClass)(p)}}
}

// UnsafeFilterInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilterInputStreamClass] is expected to work anymore.
func UnsafeFilterInputStreamClassFree(f *FilterInputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilterInputStreamClassToGlibNone(f *FilterInputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilterInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeFilterInputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilterInputStreamClass) {}, f)
	return parent
}

// FilterOutputStreamClass wraps GFilterOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.FilterOutputStreamClass.html
// 
// FilterOutputStreamClass is the type struct for [FilterOutputStream]
type FilterOutputStreamClass struct {
	*filterOutputStreamClass
}

// filterOutputStreamClass is the struct that's finalized
type filterOutputStreamClass struct {
	native *C.GFilterOutputStreamClass
}

// UnsafeFilterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilterOutputStreamClass) instance() *C.GFilterOutputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilterOutputStreamClassFromGlibBorrow is used to convert raw C.GFilterOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFilterOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *FilterOutputStreamClass {
	if p == nil {
		return nil
	}
	return &FilterOutputStreamClass{&filterOutputStreamClass{(*C.GFilterOutputStreamClass)(p)}}
}

// UnsafeFilterOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilterOutputStreamClass] is expected to work anymore.
func UnsafeFilterOutputStreamClassFree(f *FilterOutputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilterOutputStreamClassToGlibNone(f *FilterOutputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilterOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeFilterOutputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilterOutputStreamClass) {}, f)
	return parent
}

// IOExtension wraps GIOExtension
// 
// see also https://docs.gtk.org/gio/struct.IOExtension.html
//
type IOExtension struct {
	*iOExtension
}

// iOExtension is the struct that's finalized
type iOExtension struct {
	native *C.GIOExtension
}

// UnsafeIOExtensionToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOExtension) instance() *C.GIOExtension {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOExtensionFromGlibBorrow is used to convert raw C.GIOExtension pointers to go. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibBorrow(p unsafe.Pointer) *IOExtension {
	if p == nil {
		return nil
	}
	return &IOExtension{&iOExtension{(*C.GIOExtension)(p)}}
}

// UnsafeIOExtensionFromGlibNone is used to convert raw C.GIOExtension pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibNone(p unsafe.Pointer) *IOExtension {
	wrapped := UnsafeIOExtensionFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOExtension because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOExtensionFromGlibFull is used to convert raw C.GIOExtension pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibFull(p unsafe.Pointer) *IOExtension {
	wrapped := UnsafeIOExtensionFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOExtension,
		func (intern *iOExtension) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOExtensionFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOExtension] is expected to work anymore.
func UnsafeIOExtensionFree(i *IOExtension) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOExtensionToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOExtensionToGlibNone(i *IOExtension) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOExtensionToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOExtensionToGlibFull(i *IOExtension) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOExtension, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOExtension is invalid from here on
	return _p
}

// GetName wraps g_io_extension_get_name
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_get_name.g_io_extension_get_name.html
//
func (extension *IOExtension) GetName() string {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  *C.char         // return, none, string

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_name(carg0)
	runtime.KeepAlive(extension)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPriority wraps g_io_extension_get_priority
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_get_priority.g_io_extension_get_priority.html
//
func (extension *IOExtension) GetPriority() int32 {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  C.gint          // return, none, casted

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_priority(carg0)
	runtime.KeepAlive(extension)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetType wraps g_io_extension_get_type
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_get_type.g_io_extension_get_type.html
//
func (extension *IOExtension) GetType() gobject.Type {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  C.GType         // return, none, casted, alias

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_type(carg0)
	runtime.KeepAlive(extension)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// IOExtensionPoint wraps GIOExtensionPoint
// 
// see also https://docs.gtk.org/gio/struct.IOExtensionPoint.html
//
type IOExtensionPoint struct {
	*iOExtensionPoint
}

// iOExtensionPoint is the struct that's finalized
type iOExtensionPoint struct {
	native *C.GIOExtensionPoint
}

// UnsafeIOExtensionPointToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOExtensionPoint) instance() *C.GIOExtensionPoint {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOExtensionPointFromGlibBorrow is used to convert raw C.GIOExtensionPoint pointers to go. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibBorrow(p unsafe.Pointer) *IOExtensionPoint {
	if p == nil {
		return nil
	}
	return &IOExtensionPoint{&iOExtensionPoint{(*C.GIOExtensionPoint)(p)}}
}

// UnsafeIOExtensionPointFromGlibNone is used to convert raw C.GIOExtensionPoint pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibNone(p unsafe.Pointer) *IOExtensionPoint {
	wrapped := UnsafeIOExtensionPointFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOExtensionPoint because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOExtensionPointFromGlibFull is used to convert raw C.GIOExtensionPoint pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibFull(p unsafe.Pointer) *IOExtensionPoint {
	wrapped := UnsafeIOExtensionPointFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOExtensionPoint,
		func (intern *iOExtensionPoint) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOExtensionPointFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOExtensionPoint] is expected to work anymore.
func UnsafeIOExtensionPointFree(i *IOExtensionPoint) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOExtensionPointToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOExtensionPointToGlibNone(i *IOExtensionPoint) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOExtensionPointToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOExtensionPointToGlibFull(i *IOExtensionPoint) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOExtensionPoint, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOExtensionPoint is invalid from here on
	return _p
}

// IOExtensionPointImplement wraps g_io_extension_point_implement
// 
// see also https://docs.gtk.org/gio/func.g_io_extension_point_implement.html
//
func IOExtensionPointImplement(extensionPointName string, typ gobject.Type, extensionName string, priority int32) *IOExtension {
	var carg1 *C.char         // in, none, string
	var carg2 C.GType         // in, none, casted, alias
	var carg3 *C.char         // in, none, string
	var carg4 C.gint          // in, none, casted
	var cret  *C.GIOExtension // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(extensionPointName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(typ)
	carg3 = (*C.char)(unsafe.Pointer(C.CString(extensionName)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gint(priority)

	cret = C.g_io_extension_point_implement(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(extensionPointName)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(extensionName)
	runtime.KeepAlive(priority)

	var goret *IOExtension

	goret = UnsafeIOExtensionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IOExtensionPointLookup wraps g_io_extension_point_lookup
// 
// see also https://docs.gtk.org/gio/func.g_io_extension_point_lookup.html
//
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtensionPoint // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_lookup(carg1)
	runtime.KeepAlive(name)

	var goret *IOExtensionPoint

	goret = UnsafeIOExtensionPointFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IOExtensionPointRegister wraps g_io_extension_point_register
// 
// see also https://docs.gtk.org/gio/func.g_io_extension_point_register.html
//
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtensionPoint // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_register(carg1)
	runtime.KeepAlive(name)

	var goret *IOExtensionPoint

	goret = UnsafeIOExtensionPointFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetExtensionByName wraps g_io_extension_point_get_extension_by_name
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_point_get_extension_by_name.g_io_extension_point_get_extension_by_name.html
//
func (extensionPoint *IOExtensionPoint) GetExtensionByName(name string) *IOExtension {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtension      // return, none, converted

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_get_extension_by_name(carg0, carg1)
	runtime.KeepAlive(extensionPoint)
	runtime.KeepAlive(name)

	var goret *IOExtension

	goret = UnsafeIOExtensionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetExtensions wraps g_io_extension_point_get_extensions
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_point_get_extensions.g_io_extension_point_get_extensions.html
//
func (extensionPoint *IOExtensionPoint) GetExtensions() []*IOExtension {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var cret  *C.GList             // container, transfer: none

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))

	cret = C.g_io_extension_point_get_extensions(carg0)
	runtime.KeepAlive(extensionPoint)

	var goret []*IOExtension

	goret = glib.UnsafeListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *IOExtension {
			var dst *IOExtension // converted
			dst = UnsafeIOExtensionFromGlibNone(v)
			return dst
		},
	)

	return goret
}

// GetRequiredType wraps g_io_extension_point_get_required_type
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_point_get_required_type.g_io_extension_point_get_required_type.html
//
func (extensionPoint *IOExtensionPoint) GetRequiredType() gobject.Type {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var cret  C.GType              // return, none, casted, alias

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))

	cret = C.g_io_extension_point_get_required_type(carg0)
	runtime.KeepAlive(extensionPoint)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SetRequiredType wraps g_io_extension_point_set_required_type
// 
// see also https://docs.gtk.org/gio/method.g_io_extension_point_set_required_type.g_io_extension_point_set_required_type.html
//
func (extensionPoint *IOExtensionPoint) SetRequiredType(typ gobject.Type) {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var carg1 C.GType              // in, none, casted, alias

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))
	carg1 = C.GType(typ)

	C.g_io_extension_point_set_required_type(carg0, carg1)
	runtime.KeepAlive(extensionPoint)
	runtime.KeepAlive(typ)
}

// IOModuleClass wraps GIOModuleClass
// 
// see also https://docs.gtk.org/gio/struct.IOModuleClass.html
// 
// IOModuleClass is the type struct for [IOModule]
type IOModuleClass struct {
	*iOModuleClass
}

// iOModuleClass is the struct that's finalized
type iOModuleClass struct {
	native *C.GIOModuleClass
}

// UnsafeIOModuleClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOModuleClass) instance() *C.GIOModuleClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOModuleClassFromGlibBorrow is used to convert raw C.GIOModuleClass pointers to go. This is used by the bindings internally.
func UnsafeIOModuleClassFromGlibBorrow(p unsafe.Pointer) *IOModuleClass {
	if p == nil {
		return nil
	}
	return &IOModuleClass{&iOModuleClass{(*C.GIOModuleClass)(p)}}
}

// UnsafeIOModuleClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOModuleClass] is expected to work anymore.
func UnsafeIOModuleClassFree(i *IOModuleClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOModuleClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOModuleClassToGlibNone(i *IOModuleClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// IOModuleScope wraps GIOModuleScope
// 
// see also https://docs.gtk.org/gio/struct.IOModuleScope.html
//
type IOModuleScope struct {
	*iOModuleScope
}

// iOModuleScope is the struct that's finalized
type iOModuleScope struct {
	native *C.GIOModuleScope
}

// UnsafeIOModuleScopeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOModuleScope) instance() *C.GIOModuleScope {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOModuleScopeFromGlibBorrow is used to convert raw C.GIOModuleScope pointers to go. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibBorrow(p unsafe.Pointer) *IOModuleScope {
	if p == nil {
		return nil
	}
	return &IOModuleScope{&iOModuleScope{(*C.GIOModuleScope)(p)}}
}

// UnsafeIOModuleScopeFromGlibNone is used to convert raw C.GIOModuleScope pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibNone(p unsafe.Pointer) *IOModuleScope {
	wrapped := UnsafeIOModuleScopeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOModuleScope because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOModuleScopeFromGlibFull is used to convert raw C.GIOModuleScope pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibFull(p unsafe.Pointer) *IOModuleScope {
	wrapped := UnsafeIOModuleScopeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOModuleScope,
		func (intern *iOModuleScope) {
			C.g_io_module_scope_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOModuleScopeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOModuleScope] is expected to work anymore.
func UnsafeIOModuleScopeFree(i *IOModuleScope) {
	C.g_io_module_scope_free(i.native)
}

// UnsafeIOModuleScopeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOModuleScopeToGlibNone(i *IOModuleScope) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOModuleScopeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOModuleScopeToGlibFull(i *IOModuleScope) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOModuleScope, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOModuleScope is invalid from here on
	return _p
}

// Block wraps g_io_module_scope_block
// 
// see also https://docs.gtk.org/gio/method.g_io_module_scope_block.g_io_module_scope_block.html
//
func (scope *IOModuleScope) Block(basename string) {
	var carg0 *C.GIOModuleScope // in, none, converted
	var carg1 *C.gchar          // in, none, string

	carg0 = (*C.GIOModuleScope)(UnsafeIOModuleScopeToGlibNone(scope))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(basename)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_io_module_scope_block(carg0, carg1)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(basename)
}

// IOSchedulerJob wraps GIOSchedulerJob
// 
// see also https://docs.gtk.org/gio/struct.IOSchedulerJob.html
//
//
// Deprecated: (since 2.36.0) Use [struct@GLib.ThreadPool] or
//   [method@Gio.Task.run_in_thread]
type IOSchedulerJob struct {
	*iOSchedulerJob
}

// iOSchedulerJob is the struct that's finalized
type iOSchedulerJob struct {
	native *C.GIOSchedulerJob
}

// UnsafeIOSchedulerJobToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOSchedulerJob) instance() *C.GIOSchedulerJob {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOSchedulerJobFromGlibBorrow is used to convert raw C.GIOSchedulerJob pointers to go. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibBorrow(p unsafe.Pointer) *IOSchedulerJob {
	if p == nil {
		return nil
	}
	return &IOSchedulerJob{&iOSchedulerJob{(*C.GIOSchedulerJob)(p)}}
}

// UnsafeIOSchedulerJobFromGlibNone is used to convert raw C.GIOSchedulerJob pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibNone(p unsafe.Pointer) *IOSchedulerJob {
	wrapped := UnsafeIOSchedulerJobFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOSchedulerJob because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOSchedulerJobFromGlibFull is used to convert raw C.GIOSchedulerJob pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibFull(p unsafe.Pointer) *IOSchedulerJob {
	wrapped := UnsafeIOSchedulerJobFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOSchedulerJob,
		func (intern *iOSchedulerJob) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOSchedulerJobFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOSchedulerJob] is expected to work anymore.
func UnsafeIOSchedulerJobFree(i *IOSchedulerJob) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOSchedulerJobToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOSchedulerJobToGlibNone(i *IOSchedulerJob) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOSchedulerJobToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOSchedulerJobToGlibFull(i *IOSchedulerJob) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOSchedulerJob, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOSchedulerJob is invalid from here on
	return _p
}

// SendToMainloop wraps g_io_scheduler_job_send_to_mainloop
// 
// see also https://docs.gtk.org/gio/method.g_io_scheduler_job_send_to_mainloop.g_io_scheduler_job_send_to_mainloop.html
//
//
// Deprecated: (since 2.36.0) Use g_main_context_invoke().
func (job *IOSchedulerJob) SendToMainloop(fn glib.SourceFunc) bool {
	var carg0 *C.GIOSchedulerJob // in, none, converted
	var carg1 C.GSourceFunc      // callback, scope: notified, closure: carg2, destroy: carg3
	var carg2 C.gpointer         // implicit
	var carg3 C.GDestroyNotify   // implicit
	var cret  C.gboolean         // return

	carg0 = (*C.GIOSchedulerJob)(UnsafeIOSchedulerJobToGlibNone(job))
	carg1 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg2 = C.gpointer(userdata.Register(fn))
	carg3 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_io_scheduler_job_send_to_mainloop(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(job)
	runtime.KeepAlive(fn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SendToMainloopAsync wraps g_io_scheduler_job_send_to_mainloop_async
// 
// see also https://docs.gtk.org/gio/method.g_io_scheduler_job_send_to_mainloop_async.g_io_scheduler_job_send_to_mainloop_async.html
//
//
// Deprecated: (since 2.36.0) Use g_main_context_invoke().
func (job *IOSchedulerJob) SendToMainloopAsync(fn glib.SourceFunc) {
	var carg0 *C.GIOSchedulerJob // in, none, converted
	var carg1 C.GSourceFunc      // callback, scope: notified, closure: carg2, destroy: carg3
	var carg2 C.gpointer         // implicit
	var carg3 C.GDestroyNotify   // implicit

	carg0 = (*C.GIOSchedulerJob)(UnsafeIOSchedulerJobToGlibNone(job))
	carg1 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg2 = C.gpointer(userdata.Register(fn))
	carg3 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	C.g_io_scheduler_job_send_to_mainloop_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(job)
	runtime.KeepAlive(fn)
}

// IOStreamAdapter wraps GIOStreamAdapter
// 
// see also https://docs.gtk.org/gio/struct.IOStreamAdapter.html
type IOStreamAdapter struct {
	*iOStreamAdapter
}

// iOStreamAdapter is the struct that's finalized
type iOStreamAdapter struct {
	native *C.GIOStreamAdapter
}

// UnsafeIOStreamAdapterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOStreamAdapter) instance() *C.GIOStreamAdapter {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOStreamAdapterFromGlibBorrow is used to convert raw C.GIOStreamAdapter pointers to go. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibBorrow(p unsafe.Pointer) *IOStreamAdapter {
	if p == nil {
		return nil
	}
	return &IOStreamAdapter{&iOStreamAdapter{(*C.GIOStreamAdapter)(p)}}
}

// UnsafeIOStreamAdapterFromGlibNone is used to convert raw C.GIOStreamAdapter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibNone(p unsafe.Pointer) *IOStreamAdapter {
	wrapped := UnsafeIOStreamAdapterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOStreamAdapter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOStreamAdapterFromGlibFull is used to convert raw C.GIOStreamAdapter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibFull(p unsafe.Pointer) *IOStreamAdapter {
	wrapped := UnsafeIOStreamAdapterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOStreamAdapter,
		func (intern *iOStreamAdapter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOStreamAdapterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOStreamAdapter] is expected to work anymore.
func UnsafeIOStreamAdapterFree(i *IOStreamAdapter) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOStreamAdapterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOStreamAdapterToGlibNone(i *IOStreamAdapter) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOStreamAdapterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOStreamAdapterToGlibFull(i *IOStreamAdapter) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOStreamAdapter, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOStreamAdapter is invalid from here on
	return _p
}

// IOStreamClass wraps GIOStreamClass
// 
// see also https://docs.gtk.org/gio/struct.IOStreamClass.html
// 
// IOStreamClass is the type struct for [IOStream]
type IOStreamClass struct {
	*iOStreamClass
}

// iOStreamClass is the struct that's finalized
type iOStreamClass struct {
	native *C.GIOStreamClass
}

// UnsafeIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOStreamClass) instance() *C.GIOStreamClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOStreamClassFromGlibBorrow is used to convert raw C.GIOStreamClass pointers to go. This is used by the bindings internally.
func UnsafeIOStreamClassFromGlibBorrow(p unsafe.Pointer) *IOStreamClass {
	if p == nil {
		return nil
	}
	return &IOStreamClass{&iOStreamClass{(*C.GIOStreamClass)(p)}}
}

// UnsafeIOStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOStreamClass] is expected to work anymore.
func UnsafeIOStreamClassFree(i *IOStreamClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOStreamClassToGlibNone(i *IOStreamClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *IOStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeIOStreamClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *IOStreamClass) {}, i)
	return parent
}

// IconIface wraps GIconIface
// 
// see also https://docs.gtk.org/gio/struct.IconIface.html
//
type IconIface struct {
	*iconIface
}

// iconIface is the struct that's finalized
type iconIface struct {
	native *C.GIconIface
}

// UnsafeIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IconIface) instance() *C.GIconIface {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIconIfaceFromGlibBorrow is used to convert raw C.GIconIface pointers to go. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibBorrow(p unsafe.Pointer) *IconIface {
	if p == nil {
		return nil
	}
	return &IconIface{&iconIface{(*C.GIconIface)(p)}}
}

// UnsafeIconIfaceFromGlibNone is used to convert raw C.GIconIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibNone(p unsafe.Pointer) *IconIface {
	wrapped := UnsafeIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IconIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIconIfaceFromGlibFull is used to convert raw C.GIconIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibFull(p unsafe.Pointer) *IconIface {
	wrapped := UnsafeIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iconIface,
		func (intern *iconIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIconIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IconIface] is expected to work anymore.
func UnsafeIconIfaceFree(i *IconIface) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIconIfaceToGlibNone(i *IconIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIconIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIconIfaceToGlibFull(i *IconIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iconIface, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IconIface is invalid from here on
	return _p
}

// InetAddressClass wraps GInetAddressClass
// 
// see also https://docs.gtk.org/gio/struct.InetAddressClass.html
// 
// InetAddressClass is the type struct for [InetAddress]
type InetAddressClass struct {
	*inetAddressClass
}

// inetAddressClass is the struct that's finalized
type inetAddressClass struct {
	native *C.GInetAddressClass
}

// UnsafeInetAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetAddressClass) instance() *C.GInetAddressClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetAddressClassFromGlibBorrow is used to convert raw C.GInetAddressClass pointers to go. This is used by the bindings internally.
func UnsafeInetAddressClassFromGlibBorrow(p unsafe.Pointer) *InetAddressClass {
	if p == nil {
		return nil
	}
	return &InetAddressClass{&inetAddressClass{(*C.GInetAddressClass)(p)}}
}

// UnsafeInetAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetAddressClass] is expected to work anymore.
func UnsafeInetAddressClassFree(i *InetAddressClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetAddressClassToGlibNone(i *InetAddressClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInetAddressClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetAddressClass) {}, i)
	return parent
}

// InetAddressMaskClass wraps GInetAddressMaskClass
// 
// see also https://docs.gtk.org/gio/struct.InetAddressMaskClass.html
// 
// InetAddressMaskClass is the type struct for [InetAddressMask]
type InetAddressMaskClass struct {
	*inetAddressMaskClass
}

// inetAddressMaskClass is the struct that's finalized
type inetAddressMaskClass struct {
	native *C.GInetAddressMaskClass
}

// UnsafeInetAddressMaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetAddressMaskClass) instance() *C.GInetAddressMaskClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetAddressMaskClassFromGlibBorrow is used to convert raw C.GInetAddressMaskClass pointers to go. This is used by the bindings internally.
func UnsafeInetAddressMaskClassFromGlibBorrow(p unsafe.Pointer) *InetAddressMaskClass {
	if p == nil {
		return nil
	}
	return &InetAddressMaskClass{&inetAddressMaskClass{(*C.GInetAddressMaskClass)(p)}}
}

// UnsafeInetAddressMaskClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetAddressMaskClass] is expected to work anymore.
func UnsafeInetAddressMaskClassFree(i *InetAddressMaskClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetAddressMaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetAddressMaskClassToGlibNone(i *InetAddressMaskClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetAddressMaskClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInetAddressMaskClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetAddressMaskClass) {}, i)
	return parent
}

// InetSocketAddressClass wraps GInetSocketAddressClass
// 
// see also https://docs.gtk.org/gio/struct.InetSocketAddressClass.html
// 
// InetSocketAddressClass is the type struct for [InetSocketAddress]
type InetSocketAddressClass struct {
	*inetSocketAddressClass
}

// inetSocketAddressClass is the struct that's finalized
type inetSocketAddressClass struct {
	native *C.GInetSocketAddressClass
}

// UnsafeInetSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetSocketAddressClass) instance() *C.GInetSocketAddressClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetSocketAddressClassFromGlibBorrow is used to convert raw C.GInetSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeInetSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *InetSocketAddressClass {
	if p == nil {
		return nil
	}
	return &InetSocketAddressClass{&inetSocketAddressClass{(*C.GInetSocketAddressClass)(p)}}
}

// UnsafeInetSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetSocketAddressClass] is expected to work anymore.
func UnsafeInetSocketAddressClassFree(i *InetSocketAddressClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetSocketAddressClassToGlibNone(i *InetSocketAddressClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetSocketAddressClass) ParentClass() *SocketAddressClass {
	parent := UnsafeSocketAddressClassFromGlibBorrow(UnsafeInetSocketAddressClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetSocketAddressClass) {}, i)
	return parent
}

// InitableIface wraps GInitableIface
// 
// see also https://docs.gtk.org/gio/struct.InitableIface.html
//
type InitableIface struct {
	*initableIface
}

// initableIface is the struct that's finalized
type initableIface struct {
	native *C.GInitableIface
}

// UnsafeInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InitableIface) instance() *C.GInitableIface {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInitableIfaceFromGlibBorrow is used to convert raw C.GInitableIface pointers to go. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibBorrow(p unsafe.Pointer) *InitableIface {
	if p == nil {
		return nil
	}
	return &InitableIface{&initableIface{(*C.GInitableIface)(p)}}
}

// UnsafeInitableIfaceFromGlibNone is used to convert raw C.GInitableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibNone(p unsafe.Pointer) *InitableIface {
	wrapped := UnsafeInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InitableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInitableIfaceFromGlibFull is used to convert raw C.GInitableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibFull(p unsafe.Pointer) *InitableIface {
	wrapped := UnsafeInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.initableIface,
		func (intern *initableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInitableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InitableIface] is expected to work anymore.
func UnsafeInitableIfaceFree(i *InitableIface) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInitableIfaceToGlibNone(i *InitableIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInitableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInitableIfaceToGlibFull(i *InitableIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.initableIface, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InitableIface is invalid from here on
	return _p
}

// InputMessage wraps GInputMessage
// 
// see also https://docs.gtk.org/gio/struct.InputMessage.html
//
type InputMessage struct {
	*inputMessage
}

// inputMessage is the struct that's finalized
type inputMessage struct {
	native *C.GInputMessage
}

// UnsafeInputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputMessage) instance() *C.GInputMessage {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputMessageFromGlibBorrow is used to convert raw C.GInputMessage pointers to go. This is used by the bindings internally.
func UnsafeInputMessageFromGlibBorrow(p unsafe.Pointer) *InputMessage {
	if p == nil {
		return nil
	}
	return &InputMessage{&inputMessage{(*C.GInputMessage)(p)}}
}

// UnsafeInputMessageFromGlibNone is used to convert raw C.GInputMessage pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInputMessageFromGlibNone(p unsafe.Pointer) *InputMessage {
	wrapped := UnsafeInputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InputMessage because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInputMessageFromGlibFull is used to convert raw C.GInputMessage pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInputMessageFromGlibFull(p unsafe.Pointer) *InputMessage {
	wrapped := UnsafeInputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.inputMessage,
		func (intern *inputMessage) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInputMessageFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputMessage] is expected to work anymore.
func UnsafeInputMessageFree(i *InputMessage) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputMessageToGlibNone(i *InputMessage) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInputMessageToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInputMessageToGlibFull(i *InputMessage) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.inputMessage, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InputMessage is invalid from here on
	return _p
}

// InputStreamClass wraps GInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.InputStreamClass.html
// 
// InputStreamClass is the type struct for [InputStream]
type InputStreamClass struct {
	*inputStreamClass
}

// inputStreamClass is the struct that's finalized
type inputStreamClass struct {
	native *C.GInputStreamClass
}

// UnsafeInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputStreamClass) instance() *C.GInputStreamClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputStreamClassFromGlibBorrow is used to convert raw C.GInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeInputStreamClassFromGlibBorrow(p unsafe.Pointer) *InputStreamClass {
	if p == nil {
		return nil
	}
	return &InputStreamClass{&inputStreamClass{(*C.GInputStreamClass)(p)}}
}

// UnsafeInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputStreamClass] is expected to work anymore.
func UnsafeInputStreamClassFree(i *InputStreamClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputStreamClassToGlibNone(i *InputStreamClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InputStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInputStreamClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InputStreamClass) {}, i)
	return parent
}

// InputVector wraps GInputVector
// 
// see also https://docs.gtk.org/gio/struct.InputVector.html
//
type InputVector struct {
	*inputVector
}

// inputVector is the struct that's finalized
type inputVector struct {
	native *C.GInputVector
}

// UnsafeInputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputVector) instance() *C.GInputVector {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputVectorFromGlibBorrow is used to convert raw C.GInputVector pointers to go. This is used by the bindings internally.
func UnsafeInputVectorFromGlibBorrow(p unsafe.Pointer) *InputVector {
	if p == nil {
		return nil
	}
	return &InputVector{&inputVector{(*C.GInputVector)(p)}}
}

// UnsafeInputVectorFromGlibNone is used to convert raw C.GInputVector pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInputVectorFromGlibNone(p unsafe.Pointer) *InputVector {
	wrapped := UnsafeInputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InputVector because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInputVectorFromGlibFull is used to convert raw C.GInputVector pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInputVectorFromGlibFull(p unsafe.Pointer) *InputVector {
	wrapped := UnsafeInputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.inputVector,
		func (intern *inputVector) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInputVectorFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputVector] is expected to work anymore.
func UnsafeInputVectorFree(i *InputVector) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputVectorToGlibNone(i *InputVector) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInputVectorToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInputVectorToGlibFull(i *InputVector) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.inputVector, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InputVector is invalid from here on
	return _p
}

// ListModelInterface wraps GListModelInterface
// 
// see also https://docs.gtk.org/gio/struct.ListModelInterface.html
//
type ListModelInterface struct {
	*listModelInterface
}

// listModelInterface is the struct that's finalized
type listModelInterface struct {
	native *C.GListModelInterface
}

// UnsafeListModelInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *ListModelInterface) instance() *C.GListModelInterface {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeListModelInterfaceFromGlibBorrow is used to convert raw C.GListModelInterface pointers to go. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibBorrow(p unsafe.Pointer) *ListModelInterface {
	if p == nil {
		return nil
	}
	return &ListModelInterface{&listModelInterface{(*C.GListModelInterface)(p)}}
}

// UnsafeListModelInterfaceFromGlibNone is used to convert raw C.GListModelInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibNone(p unsafe.Pointer) *ListModelInterface {
	wrapped := UnsafeListModelInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ListModelInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeListModelInterfaceFromGlibFull is used to convert raw C.GListModelInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibFull(p unsafe.Pointer) *ListModelInterface {
	wrapped := UnsafeListModelInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.listModelInterface,
		func (intern *listModelInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeListModelInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ListModelInterface] is expected to work anymore.
func UnsafeListModelInterfaceFree(l *ListModelInterface) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeListModelInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeListModelInterfaceToGlibNone(l *ListModelInterface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeListModelInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeListModelInterfaceToGlibFull(l *ListModelInterface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.listModelInterface, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // ListModelInterface is invalid from here on
	return _p
}

// ListStoreClass wraps GListStoreClass
// 
// see also https://docs.gtk.org/gio/struct.ListStoreClass.html
// 
// ListStoreClass is the type struct for [ListStore]
type ListStoreClass struct {
	*listStoreClass
}

// listStoreClass is the struct that's finalized
type listStoreClass struct {
	native *C.GListStoreClass
}

// UnsafeListStoreClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *ListStoreClass) instance() *C.GListStoreClass {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeListStoreClassFromGlibBorrow is used to convert raw C.GListStoreClass pointers to go. This is used by the bindings internally.
func UnsafeListStoreClassFromGlibBorrow(p unsafe.Pointer) *ListStoreClass {
	if p == nil {
		return nil
	}
	return &ListStoreClass{&listStoreClass{(*C.GListStoreClass)(p)}}
}

// UnsafeListStoreClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ListStoreClass] is expected to work anymore.
func UnsafeListStoreClassFree(l *ListStoreClass) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeListStoreClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeListStoreClassToGlibNone(l *ListStoreClass) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (l *ListStoreClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeListStoreClassToGlibNone(l))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ListStoreClass) {}, l)
	return parent
}

// LoadableIconIface wraps GLoadableIconIface
// 
// see also https://docs.gtk.org/gio/struct.LoadableIconIface.html
//
type LoadableIconIface struct {
	*loadableIconIface
}

// loadableIconIface is the struct that's finalized
type loadableIconIface struct {
	native *C.GLoadableIconIface
}

// UnsafeLoadableIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *LoadableIconIface) instance() *C.GLoadableIconIface {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeLoadableIconIfaceFromGlibBorrow is used to convert raw C.GLoadableIconIface pointers to go. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibBorrow(p unsafe.Pointer) *LoadableIconIface {
	if p == nil {
		return nil
	}
	return &LoadableIconIface{&loadableIconIface{(*C.GLoadableIconIface)(p)}}
}

// UnsafeLoadableIconIfaceFromGlibNone is used to convert raw C.GLoadableIconIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibNone(p unsafe.Pointer) *LoadableIconIface {
	wrapped := UnsafeLoadableIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to LoadableIconIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeLoadableIconIfaceFromGlibFull is used to convert raw C.GLoadableIconIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibFull(p unsafe.Pointer) *LoadableIconIface {
	wrapped := UnsafeLoadableIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.loadableIconIface,
		func (intern *loadableIconIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeLoadableIconIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [LoadableIconIface] is expected to work anymore.
func UnsafeLoadableIconIfaceFree(l *LoadableIconIface) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeLoadableIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeLoadableIconIfaceToGlibNone(l *LoadableIconIface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeLoadableIconIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeLoadableIconIfaceToGlibFull(l *LoadableIconIface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.loadableIconIface, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // LoadableIconIface is invalid from here on
	return _p
}

// MemoryInputStreamClass wraps GMemoryInputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.MemoryInputStreamClass.html
// 
// MemoryInputStreamClass is the type struct for [MemoryInputStream]
type MemoryInputStreamClass struct {
	*memoryInputStreamClass
}

// memoryInputStreamClass is the struct that's finalized
type memoryInputStreamClass struct {
	native *C.GMemoryInputStreamClass
}

// UnsafeMemoryInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryInputStreamClass) instance() *C.GMemoryInputStreamClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryInputStreamClassFromGlibBorrow is used to convert raw C.GMemoryInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeMemoryInputStreamClassFromGlibBorrow(p unsafe.Pointer) *MemoryInputStreamClass {
	if p == nil {
		return nil
	}
	return &MemoryInputStreamClass{&memoryInputStreamClass{(*C.GMemoryInputStreamClass)(p)}}
}

// UnsafeMemoryInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryInputStreamClass] is expected to work anymore.
func UnsafeMemoryInputStreamClassFree(m *MemoryInputStreamClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryInputStreamClassToGlibNone(m *MemoryInputStreamClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MemoryInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeMemoryInputStreamClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MemoryInputStreamClass) {}, m)
	return parent
}

// MemoryMonitorInterface wraps GMemoryMonitorInterface
// 
// see also https://docs.gtk.org/gio/struct.MemoryMonitorInterface.html
//
type MemoryMonitorInterface struct {
	*memoryMonitorInterface
}

// memoryMonitorInterface is the struct that's finalized
type memoryMonitorInterface struct {
	native *C.GMemoryMonitorInterface
}

// UnsafeMemoryMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryMonitorInterface) instance() *C.GMemoryMonitorInterface {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryMonitorInterfaceFromGlibBorrow is used to convert raw C.GMemoryMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *MemoryMonitorInterface {
	if p == nil {
		return nil
	}
	return &MemoryMonitorInterface{&memoryMonitorInterface{(*C.GMemoryMonitorInterface)(p)}}
}

// UnsafeMemoryMonitorInterfaceFromGlibNone is used to convert raw C.GMemoryMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibNone(p unsafe.Pointer) *MemoryMonitorInterface {
	wrapped := UnsafeMemoryMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MemoryMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMemoryMonitorInterfaceFromGlibFull is used to convert raw C.GMemoryMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibFull(p unsafe.Pointer) *MemoryMonitorInterface {
	wrapped := UnsafeMemoryMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.memoryMonitorInterface,
		func (intern *memoryMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMemoryMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryMonitorInterface] is expected to work anymore.
func UnsafeMemoryMonitorInterfaceFree(m *MemoryMonitorInterface) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceToGlibNone(m *MemoryMonitorInterface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMemoryMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceToGlibFull(m *MemoryMonitorInterface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.memoryMonitorInterface, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MemoryMonitorInterface is invalid from here on
	return _p
}

// MemoryOutputStreamClass wraps GMemoryOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.MemoryOutputStreamClass.html
// 
// MemoryOutputStreamClass is the type struct for [MemoryOutputStream]
type MemoryOutputStreamClass struct {
	*memoryOutputStreamClass
}

// memoryOutputStreamClass is the struct that's finalized
type memoryOutputStreamClass struct {
	native *C.GMemoryOutputStreamClass
}

// UnsafeMemoryOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryOutputStreamClass) instance() *C.GMemoryOutputStreamClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryOutputStreamClassFromGlibBorrow is used to convert raw C.GMemoryOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeMemoryOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *MemoryOutputStreamClass {
	if p == nil {
		return nil
	}
	return &MemoryOutputStreamClass{&memoryOutputStreamClass{(*C.GMemoryOutputStreamClass)(p)}}
}

// UnsafeMemoryOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryOutputStreamClass] is expected to work anymore.
func UnsafeMemoryOutputStreamClassFree(m *MemoryOutputStreamClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamClassToGlibNone(m *MemoryOutputStreamClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MemoryOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeMemoryOutputStreamClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MemoryOutputStreamClass) {}, m)
	return parent
}

// MenuAttributeIterClass wraps GMenuAttributeIterClass
// 
// see also https://docs.gtk.org/gio/struct.MenuAttributeIterClass.html
// 
// MenuAttributeIterClass is the type struct for [MenuAttributeIter]
type MenuAttributeIterClass struct {
	*menuAttributeIterClass
}

// menuAttributeIterClass is the struct that's finalized
type menuAttributeIterClass struct {
	native *C.GMenuAttributeIterClass
}

// UnsafeMenuAttributeIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuAttributeIterClass) instance() *C.GMenuAttributeIterClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuAttributeIterClassFromGlibBorrow is used to convert raw C.GMenuAttributeIterClass pointers to go. This is used by the bindings internally.
func UnsafeMenuAttributeIterClassFromGlibBorrow(p unsafe.Pointer) *MenuAttributeIterClass {
	if p == nil {
		return nil
	}
	return &MenuAttributeIterClass{&menuAttributeIterClass{(*C.GMenuAttributeIterClass)(p)}}
}

// UnsafeMenuAttributeIterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuAttributeIterClass] is expected to work anymore.
func UnsafeMenuAttributeIterClassFree(m *MenuAttributeIterClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuAttributeIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuAttributeIterClassToGlibNone(m *MenuAttributeIterClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuAttributeIterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuAttributeIterClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuAttributeIterClass) {}, m)
	return parent
}

// MenuLinkIterClass wraps GMenuLinkIterClass
// 
// see also https://docs.gtk.org/gio/struct.MenuLinkIterClass.html
// 
// MenuLinkIterClass is the type struct for [MenuLinkIter]
type MenuLinkIterClass struct {
	*menuLinkIterClass
}

// menuLinkIterClass is the struct that's finalized
type menuLinkIterClass struct {
	native *C.GMenuLinkIterClass
}

// UnsafeMenuLinkIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuLinkIterClass) instance() *C.GMenuLinkIterClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuLinkIterClassFromGlibBorrow is used to convert raw C.GMenuLinkIterClass pointers to go. This is used by the bindings internally.
func UnsafeMenuLinkIterClassFromGlibBorrow(p unsafe.Pointer) *MenuLinkIterClass {
	if p == nil {
		return nil
	}
	return &MenuLinkIterClass{&menuLinkIterClass{(*C.GMenuLinkIterClass)(p)}}
}

// UnsafeMenuLinkIterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuLinkIterClass] is expected to work anymore.
func UnsafeMenuLinkIterClassFree(m *MenuLinkIterClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuLinkIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuLinkIterClassToGlibNone(m *MenuLinkIterClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuLinkIterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuLinkIterClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuLinkIterClass) {}, m)
	return parent
}

// MenuModelClass wraps GMenuModelClass
// 
// see also https://docs.gtk.org/gio/struct.MenuModelClass.html
// 
// MenuModelClass is the type struct for [MenuModel]
type MenuModelClass struct {
	*menuModelClass
}

// menuModelClass is the struct that's finalized
type menuModelClass struct {
	native *C.GMenuModelClass
}

// UnsafeMenuModelClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuModelClass) instance() *C.GMenuModelClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuModelClassFromGlibBorrow is used to convert raw C.GMenuModelClass pointers to go. This is used by the bindings internally.
func UnsafeMenuModelClassFromGlibBorrow(p unsafe.Pointer) *MenuModelClass {
	if p == nil {
		return nil
	}
	return &MenuModelClass{&menuModelClass{(*C.GMenuModelClass)(p)}}
}

// UnsafeMenuModelClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuModelClass] is expected to work anymore.
func UnsafeMenuModelClassFree(m *MenuModelClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuModelClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuModelClassToGlibNone(m *MenuModelClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuModelClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuModelClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuModelClass) {}, m)
	return parent
}

// MountIface wraps GMountIface
// 
// see also https://docs.gtk.org/gio/struct.MountIface.html
//
type MountIface struct {
	*mountIface
}

// mountIface is the struct that's finalized
type mountIface struct {
	native *C.GMountIface
}

// UnsafeMountIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MountIface) instance() *C.GMountIface {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMountIfaceFromGlibBorrow is used to convert raw C.GMountIface pointers to go. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibBorrow(p unsafe.Pointer) *MountIface {
	if p == nil {
		return nil
	}
	return &MountIface{&mountIface{(*C.GMountIface)(p)}}
}

// UnsafeMountIfaceFromGlibNone is used to convert raw C.GMountIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibNone(p unsafe.Pointer) *MountIface {
	wrapped := UnsafeMountIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MountIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMountIfaceFromGlibFull is used to convert raw C.GMountIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibFull(p unsafe.Pointer) *MountIface {
	wrapped := UnsafeMountIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mountIface,
		func (intern *mountIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMountIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MountIface] is expected to work anymore.
func UnsafeMountIfaceFree(m *MountIface) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMountIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMountIfaceToGlibNone(m *MountIface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMountIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMountIfaceToGlibFull(m *MountIface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mountIface, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MountIface is invalid from here on
	return _p
}

// MountOperationClass wraps GMountOperationClass
// 
// see also https://docs.gtk.org/gio/struct.MountOperationClass.html
// 
// MountOperationClass is the type struct for [MountOperation]
type MountOperationClass struct {
	*mountOperationClass
}

// mountOperationClass is the struct that's finalized
type mountOperationClass struct {
	native *C.GMountOperationClass
}

// UnsafeMountOperationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MountOperationClass) instance() *C.GMountOperationClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMountOperationClassFromGlibBorrow is used to convert raw C.GMountOperationClass pointers to go. This is used by the bindings internally.
func UnsafeMountOperationClassFromGlibBorrow(p unsafe.Pointer) *MountOperationClass {
	if p == nil {
		return nil
	}
	return &MountOperationClass{&mountOperationClass{(*C.GMountOperationClass)(p)}}
}

// UnsafeMountOperationClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MountOperationClass] is expected to work anymore.
func UnsafeMountOperationClassFree(m *MountOperationClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMountOperationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMountOperationClassToGlibNone(m *MountOperationClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MountOperationClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMountOperationClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MountOperationClass) {}, m)
	return parent
}

// NativeSocketAddressClass wraps GNativeSocketAddressClass
// 
// see also https://docs.gtk.org/gio/struct.NativeSocketAddressClass.html
// 
// NativeSocketAddressClass is the type struct for [NativeSocketAddress]
type NativeSocketAddressClass struct {
	*nativeSocketAddressClass
}

// nativeSocketAddressClass is the struct that's finalized
type nativeSocketAddressClass struct {
	native *C.GNativeSocketAddressClass
}

// UnsafeNativeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NativeSocketAddressClass) instance() *C.GNativeSocketAddressClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNativeSocketAddressClassFromGlibBorrow is used to convert raw C.GNativeSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeNativeSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *NativeSocketAddressClass {
	if p == nil {
		return nil
	}
	return &NativeSocketAddressClass{&nativeSocketAddressClass{(*C.GNativeSocketAddressClass)(p)}}
}

// UnsafeNativeSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NativeSocketAddressClass] is expected to work anymore.
func UnsafeNativeSocketAddressClassFree(n *NativeSocketAddressClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNativeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNativeSocketAddressClassToGlibNone(n *NativeSocketAddressClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NativeSocketAddressClass) ParentClass() *SocketAddressClass {
	parent := UnsafeSocketAddressClassFromGlibBorrow(UnsafeNativeSocketAddressClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NativeSocketAddressClass) {}, n)
	return parent
}

// NativeVolumeMonitorClass wraps GNativeVolumeMonitorClass
// 
// see also https://docs.gtk.org/gio/struct.NativeVolumeMonitorClass.html
// 
// NativeVolumeMonitorClass is the type struct for [NativeVolumeMonitor]
type NativeVolumeMonitorClass struct {
	*nativeVolumeMonitorClass
}

// nativeVolumeMonitorClass is the struct that's finalized
type nativeVolumeMonitorClass struct {
	native *C.GNativeVolumeMonitorClass
}

// UnsafeNativeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NativeVolumeMonitorClass) instance() *C.GNativeVolumeMonitorClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNativeVolumeMonitorClassFromGlibBorrow is used to convert raw C.GNativeVolumeMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorClassFromGlibBorrow(p unsafe.Pointer) *NativeVolumeMonitorClass {
	if p == nil {
		return nil
	}
	return &NativeVolumeMonitorClass{&nativeVolumeMonitorClass{(*C.GNativeVolumeMonitorClass)(p)}}
}

// UnsafeNativeVolumeMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NativeVolumeMonitorClass] is expected to work anymore.
func UnsafeNativeVolumeMonitorClassFree(n *NativeVolumeMonitorClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNativeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorClassToGlibNone(n *NativeVolumeMonitorClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NativeVolumeMonitorClass) ParentClass() *VolumeMonitorClass {
	parent := UnsafeVolumeMonitorClassFromGlibBorrow(UnsafeNativeVolumeMonitorClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NativeVolumeMonitorClass) {}, n)
	return parent
}

// NetworkAddressClass wraps GNetworkAddressClass
// 
// see also https://docs.gtk.org/gio/struct.NetworkAddressClass.html
// 
// NetworkAddressClass is the type struct for [NetworkAddress]
type NetworkAddressClass struct {
	*networkAddressClass
}

// networkAddressClass is the struct that's finalized
type networkAddressClass struct {
	native *C.GNetworkAddressClass
}

// UnsafeNetworkAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkAddressClass) instance() *C.GNetworkAddressClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkAddressClassFromGlibBorrow is used to convert raw C.GNetworkAddressClass pointers to go. This is used by the bindings internally.
func UnsafeNetworkAddressClassFromGlibBorrow(p unsafe.Pointer) *NetworkAddressClass {
	if p == nil {
		return nil
	}
	return &NetworkAddressClass{&networkAddressClass{(*C.GNetworkAddressClass)(p)}}
}

// UnsafeNetworkAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkAddressClass] is expected to work anymore.
func UnsafeNetworkAddressClassFree(n *NetworkAddressClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkAddressClassToGlibNone(n *NetworkAddressClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NetworkAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeNetworkAddressClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NetworkAddressClass) {}, n)
	return parent
}

// NetworkMonitorInterface wraps GNetworkMonitorInterface
// 
// see also https://docs.gtk.org/gio/struct.NetworkMonitorInterface.html
//
type NetworkMonitorInterface struct {
	*networkMonitorInterface
}

// networkMonitorInterface is the struct that's finalized
type networkMonitorInterface struct {
	native *C.GNetworkMonitorInterface
}

// UnsafeNetworkMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkMonitorInterface) instance() *C.GNetworkMonitorInterface {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkMonitorInterfaceFromGlibBorrow is used to convert raw C.GNetworkMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *NetworkMonitorInterface {
	if p == nil {
		return nil
	}
	return &NetworkMonitorInterface{&networkMonitorInterface{(*C.GNetworkMonitorInterface)(p)}}
}

// UnsafeNetworkMonitorInterfaceFromGlibNone is used to convert raw C.GNetworkMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibNone(p unsafe.Pointer) *NetworkMonitorInterface {
	wrapped := UnsafeNetworkMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to NetworkMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeNetworkMonitorInterfaceFromGlibFull is used to convert raw C.GNetworkMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibFull(p unsafe.Pointer) *NetworkMonitorInterface {
	wrapped := UnsafeNetworkMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.networkMonitorInterface,
		func (intern *networkMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeNetworkMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkMonitorInterface] is expected to work anymore.
func UnsafeNetworkMonitorInterfaceFree(n *NetworkMonitorInterface) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceToGlibNone(n *NetworkMonitorInterface) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// UnsafeNetworkMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceToGlibFull(n *NetworkMonitorInterface) unsafe.Pointer {
	if n == nil {
		return nil
	}
	runtime.SetFinalizer(n.networkMonitorInterface, nil)
	_p := unsafe.Pointer(n.native)
	n.native = nil // NetworkMonitorInterface is invalid from here on
	return _p
}

// NetworkServiceClass wraps GNetworkServiceClass
// 
// see also https://docs.gtk.org/gio/struct.NetworkServiceClass.html
// 
// NetworkServiceClass is the type struct for [NetworkService]
type NetworkServiceClass struct {
	*networkServiceClass
}

// networkServiceClass is the struct that's finalized
type networkServiceClass struct {
	native *C.GNetworkServiceClass
}

// UnsafeNetworkServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkServiceClass) instance() *C.GNetworkServiceClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkServiceClassFromGlibBorrow is used to convert raw C.GNetworkServiceClass pointers to go. This is used by the bindings internally.
func UnsafeNetworkServiceClassFromGlibBorrow(p unsafe.Pointer) *NetworkServiceClass {
	if p == nil {
		return nil
	}
	return &NetworkServiceClass{&networkServiceClass{(*C.GNetworkServiceClass)(p)}}
}

// UnsafeNetworkServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkServiceClass] is expected to work anymore.
func UnsafeNetworkServiceClassFree(n *NetworkServiceClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkServiceClassToGlibNone(n *NetworkServiceClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NetworkServiceClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeNetworkServiceClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NetworkServiceClass) {}, n)
	return parent
}

// OutputMessage wraps GOutputMessage
// 
// see also https://docs.gtk.org/gio/struct.OutputMessage.html
//
type OutputMessage struct {
	*outputMessage
}

// outputMessage is the struct that's finalized
type outputMessage struct {
	native *C.GOutputMessage
}

// UnsafeOutputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputMessage) instance() *C.GOutputMessage {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputMessageFromGlibBorrow is used to convert raw C.GOutputMessage pointers to go. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibBorrow(p unsafe.Pointer) *OutputMessage {
	if p == nil {
		return nil
	}
	return &OutputMessage{&outputMessage{(*C.GOutputMessage)(p)}}
}

// UnsafeOutputMessageFromGlibNone is used to convert raw C.GOutputMessage pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibNone(p unsafe.Pointer) *OutputMessage {
	wrapped := UnsafeOutputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OutputMessage because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOutputMessageFromGlibFull is used to convert raw C.GOutputMessage pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibFull(p unsafe.Pointer) *OutputMessage {
	wrapped := UnsafeOutputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.outputMessage,
		func (intern *outputMessage) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOutputMessageFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputMessage] is expected to work anymore.
func UnsafeOutputMessageFree(o *OutputMessage) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputMessageToGlibNone(o *OutputMessage) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOutputMessageToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOutputMessageToGlibFull(o *OutputMessage) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.outputMessage, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OutputMessage is invalid from here on
	return _p
}

// OutputStreamClass wraps GOutputStreamClass
// 
// see also https://docs.gtk.org/gio/struct.OutputStreamClass.html
// 
// OutputStreamClass is the type struct for [OutputStream]
type OutputStreamClass struct {
	*outputStreamClass
}

// outputStreamClass is the struct that's finalized
type outputStreamClass struct {
	native *C.GOutputStreamClass
}

// UnsafeOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputStreamClass) instance() *C.GOutputStreamClass {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputStreamClassFromGlibBorrow is used to convert raw C.GOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *OutputStreamClass {
	if p == nil {
		return nil
	}
	return &OutputStreamClass{&outputStreamClass{(*C.GOutputStreamClass)(p)}}
}

// UnsafeOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputStreamClass] is expected to work anymore.
func UnsafeOutputStreamClassFree(o *OutputStreamClass) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputStreamClassToGlibNone(o *OutputStreamClass) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (o *OutputStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeOutputStreamClassToGlibNone(o))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *OutputStreamClass) {}, o)
	return parent
}

// OutputVector wraps GOutputVector
// 
// see also https://docs.gtk.org/gio/struct.OutputVector.html
//
type OutputVector struct {
	*outputVector
}

// outputVector is the struct that's finalized
type outputVector struct {
	native *C.GOutputVector
}

// UnsafeOutputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputVector) instance() *C.GOutputVector {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputVectorFromGlibBorrow is used to convert raw C.GOutputVector pointers to go. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibBorrow(p unsafe.Pointer) *OutputVector {
	if p == nil {
		return nil
	}
	return &OutputVector{&outputVector{(*C.GOutputVector)(p)}}
}

// UnsafeOutputVectorFromGlibNone is used to convert raw C.GOutputVector pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibNone(p unsafe.Pointer) *OutputVector {
	wrapped := UnsafeOutputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OutputVector because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOutputVectorFromGlibFull is used to convert raw C.GOutputVector pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibFull(p unsafe.Pointer) *OutputVector {
	wrapped := UnsafeOutputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.outputVector,
		func (intern *outputVector) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOutputVectorFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputVector] is expected to work anymore.
func UnsafeOutputVectorFree(o *OutputVector) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputVectorToGlibNone(o *OutputVector) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOutputVectorToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOutputVectorToGlibFull(o *OutputVector) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.outputVector, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OutputVector is invalid from here on
	return _p
}

// PermissionClass wraps GPermissionClass
// 
// see also https://docs.gtk.org/gio/struct.PermissionClass.html
// 
// PermissionClass is the type struct for [Permission]
type PermissionClass struct {
	*permissionClass
}

// permissionClass is the struct that's finalized
type permissionClass struct {
	native *C.GPermissionClass
}

// UnsafePermissionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PermissionClass) instance() *C.GPermissionClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePermissionClassFromGlibBorrow is used to convert raw C.GPermissionClass pointers to go. This is used by the bindings internally.
func UnsafePermissionClassFromGlibBorrow(p unsafe.Pointer) *PermissionClass {
	if p == nil {
		return nil
	}
	return &PermissionClass{&permissionClass{(*C.GPermissionClass)(p)}}
}

// UnsafePermissionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PermissionClass] is expected to work anymore.
func UnsafePermissionClassFree(p *PermissionClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePermissionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePermissionClassToGlibNone(p *PermissionClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *PermissionClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafePermissionClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *PermissionClass) {}, p)
	return parent
}

// PollableInputStreamInterface wraps GPollableInputStreamInterface
// 
// see also https://docs.gtk.org/gio/struct.PollableInputStreamInterface.html
//
type PollableInputStreamInterface struct {
	*pollableInputStreamInterface
}

// pollableInputStreamInterface is the struct that's finalized
type pollableInputStreamInterface struct {
	native *C.GPollableInputStreamInterface
}

// UnsafePollableInputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollableInputStreamInterface) instance() *C.GPollableInputStreamInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollableInputStreamInterfaceFromGlibBorrow is used to convert raw C.GPollableInputStreamInterface pointers to go. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibBorrow(p unsafe.Pointer) *PollableInputStreamInterface {
	if p == nil {
		return nil
	}
	return &PollableInputStreamInterface{&pollableInputStreamInterface{(*C.GPollableInputStreamInterface)(p)}}
}

// UnsafePollableInputStreamInterfaceFromGlibNone is used to convert raw C.GPollableInputStreamInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibNone(p unsafe.Pointer) *PollableInputStreamInterface {
	wrapped := UnsafePollableInputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollableInputStreamInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollableInputStreamInterfaceFromGlibFull is used to convert raw C.GPollableInputStreamInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibFull(p unsafe.Pointer) *PollableInputStreamInterface {
	wrapped := UnsafePollableInputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollableInputStreamInterface,
		func (intern *pollableInputStreamInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollableInputStreamInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollableInputStreamInterface] is expected to work anymore.
func UnsafePollableInputStreamInterfaceFree(p *PollableInputStreamInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollableInputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceToGlibNone(p *PollableInputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollableInputStreamInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceToGlibFull(p *PollableInputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollableInputStreamInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollableInputStreamInterface is invalid from here on
	return _p
}

// PollableOutputStreamInterface wraps GPollableOutputStreamInterface
// 
// see also https://docs.gtk.org/gio/struct.PollableOutputStreamInterface.html
//
type PollableOutputStreamInterface struct {
	*pollableOutputStreamInterface
}

// pollableOutputStreamInterface is the struct that's finalized
type pollableOutputStreamInterface struct {
	native *C.GPollableOutputStreamInterface
}

// UnsafePollableOutputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollableOutputStreamInterface) instance() *C.GPollableOutputStreamInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollableOutputStreamInterfaceFromGlibBorrow is used to convert raw C.GPollableOutputStreamInterface pointers to go. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibBorrow(p unsafe.Pointer) *PollableOutputStreamInterface {
	if p == nil {
		return nil
	}
	return &PollableOutputStreamInterface{&pollableOutputStreamInterface{(*C.GPollableOutputStreamInterface)(p)}}
}

// UnsafePollableOutputStreamInterfaceFromGlibNone is used to convert raw C.GPollableOutputStreamInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibNone(p unsafe.Pointer) *PollableOutputStreamInterface {
	wrapped := UnsafePollableOutputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollableOutputStreamInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollableOutputStreamInterfaceFromGlibFull is used to convert raw C.GPollableOutputStreamInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibFull(p unsafe.Pointer) *PollableOutputStreamInterface {
	wrapped := UnsafePollableOutputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollableOutputStreamInterface,
		func (intern *pollableOutputStreamInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollableOutputStreamInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollableOutputStreamInterface] is expected to work anymore.
func UnsafePollableOutputStreamInterfaceFree(p *PollableOutputStreamInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollableOutputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceToGlibNone(p *PollableOutputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollableOutputStreamInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceToGlibFull(p *PollableOutputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollableOutputStreamInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollableOutputStreamInterface is invalid from here on
	return _p
}

// PowerProfileMonitorInterface wraps GPowerProfileMonitorInterface
// 
// see also https://docs.gtk.org/gio/struct.PowerProfileMonitorInterface.html
//
type PowerProfileMonitorInterface struct {
	*powerProfileMonitorInterface
}

// powerProfileMonitorInterface is the struct that's finalized
type powerProfileMonitorInterface struct {
	native *C.GPowerProfileMonitorInterface
}

// UnsafePowerProfileMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PowerProfileMonitorInterface) instance() *C.GPowerProfileMonitorInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePowerProfileMonitorInterfaceFromGlibBorrow is used to convert raw C.GPowerProfileMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *PowerProfileMonitorInterface {
	if p == nil {
		return nil
	}
	return &PowerProfileMonitorInterface{&powerProfileMonitorInterface{(*C.GPowerProfileMonitorInterface)(p)}}
}

// UnsafePowerProfileMonitorInterfaceFromGlibNone is used to convert raw C.GPowerProfileMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibNone(p unsafe.Pointer) *PowerProfileMonitorInterface {
	wrapped := UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PowerProfileMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePowerProfileMonitorInterfaceFromGlibFull is used to convert raw C.GPowerProfileMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibFull(p unsafe.Pointer) *PowerProfileMonitorInterface {
	wrapped := UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.powerProfileMonitorInterface,
		func (intern *powerProfileMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePowerProfileMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PowerProfileMonitorInterface] is expected to work anymore.
func UnsafePowerProfileMonitorInterfaceFree(p *PowerProfileMonitorInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePowerProfileMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceToGlibNone(p *PowerProfileMonitorInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePowerProfileMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceToGlibFull(p *PowerProfileMonitorInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.powerProfileMonitorInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PowerProfileMonitorInterface is invalid from here on
	return _p
}

// ProxyAddressClass wraps GProxyAddressClass
// 
// see also https://docs.gtk.org/gio/struct.ProxyAddressClass.html
//
// 
// ProxyAddressClass is the type struct for [ProxyAddress]
type ProxyAddressClass struct {
	*proxyAddressClass
}

// proxyAddressClass is the struct that's finalized
type proxyAddressClass struct {
	native *C.GProxyAddressClass
}

// UnsafeProxyAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyAddressClass) instance() *C.GProxyAddressClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyAddressClassFromGlibBorrow is used to convert raw C.GProxyAddressClass pointers to go. This is used by the bindings internally.
func UnsafeProxyAddressClassFromGlibBorrow(p unsafe.Pointer) *ProxyAddressClass {
	if p == nil {
		return nil
	}
	return &ProxyAddressClass{&proxyAddressClass{(*C.GProxyAddressClass)(p)}}
}

// UnsafeProxyAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyAddressClass] is expected to work anymore.
func UnsafeProxyAddressClassFree(p *ProxyAddressClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyAddressClassToGlibNone(p *ProxyAddressClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *ProxyAddressClass) ParentClass() *InetSocketAddressClass {
	parent := UnsafeInetSocketAddressClassFromGlibBorrow(UnsafeProxyAddressClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ProxyAddressClass) {}, p)
	return parent
}

// ProxyAddressEnumeratorClass wraps GProxyAddressEnumeratorClass
// 
// see also https://docs.gtk.org/gio/struct.ProxyAddressEnumeratorClass.html
//
// 
// ProxyAddressEnumeratorClass is the type struct for [ProxyAddressEnumerator]
type ProxyAddressEnumeratorClass struct {
	*proxyAddressEnumeratorClass
}

// proxyAddressEnumeratorClass is the struct that's finalized
type proxyAddressEnumeratorClass struct {
	native *C.GProxyAddressEnumeratorClass
}

// UnsafeProxyAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyAddressEnumeratorClass) instance() *C.GProxyAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyAddressEnumeratorClassFromGlibBorrow is used to convert raw C.GProxyAddressEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *ProxyAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return &ProxyAddressEnumeratorClass{&proxyAddressEnumeratorClass{(*C.GProxyAddressEnumeratorClass)(p)}}
}

// UnsafeProxyAddressEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyAddressEnumeratorClass] is expected to work anymore.
func UnsafeProxyAddressEnumeratorClassFree(p *ProxyAddressEnumeratorClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorClassToGlibNone(p *ProxyAddressEnumeratorClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *ProxyAddressEnumeratorClass) ParentClass() *SocketAddressEnumeratorClass {
	parent := UnsafeSocketAddressEnumeratorClassFromGlibBorrow(UnsafeProxyAddressEnumeratorClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ProxyAddressEnumeratorClass) {}, p)
	return parent
}

// ProxyInterface wraps GProxyInterface
// 
// see also https://docs.gtk.org/gio/struct.ProxyInterface.html
//
type ProxyInterface struct {
	*proxyInterface
}

// proxyInterface is the struct that's finalized
type proxyInterface struct {
	native *C.GProxyInterface
}

// UnsafeProxyInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyInterface) instance() *C.GProxyInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyInterfaceFromGlibBorrow is used to convert raw C.GProxyInterface pointers to go. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibBorrow(p unsafe.Pointer) *ProxyInterface {
	if p == nil {
		return nil
	}
	return &ProxyInterface{&proxyInterface{(*C.GProxyInterface)(p)}}
}

// UnsafeProxyInterfaceFromGlibNone is used to convert raw C.GProxyInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibNone(p unsafe.Pointer) *ProxyInterface {
	wrapped := UnsafeProxyInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ProxyInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeProxyInterfaceFromGlibFull is used to convert raw C.GProxyInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibFull(p unsafe.Pointer) *ProxyInterface {
	wrapped := UnsafeProxyInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.proxyInterface,
		func (intern *proxyInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeProxyInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyInterface] is expected to work anymore.
func UnsafeProxyInterfaceFree(p *ProxyInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyInterfaceToGlibNone(p *ProxyInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafeProxyInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeProxyInterfaceToGlibFull(p *ProxyInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.proxyInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // ProxyInterface is invalid from here on
	return _p
}

// ProxyResolverInterface wraps GProxyResolverInterface
// 
// see also https://docs.gtk.org/gio/struct.ProxyResolverInterface.html
//
type ProxyResolverInterface struct {
	*proxyResolverInterface
}

// proxyResolverInterface is the struct that's finalized
type proxyResolverInterface struct {
	native *C.GProxyResolverInterface
}

// UnsafeProxyResolverInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyResolverInterface) instance() *C.GProxyResolverInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyResolverInterfaceFromGlibBorrow is used to convert raw C.GProxyResolverInterface pointers to go. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibBorrow(p unsafe.Pointer) *ProxyResolverInterface {
	if p == nil {
		return nil
	}
	return &ProxyResolverInterface{&proxyResolverInterface{(*C.GProxyResolverInterface)(p)}}
}

// UnsafeProxyResolverInterfaceFromGlibNone is used to convert raw C.GProxyResolverInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibNone(p unsafe.Pointer) *ProxyResolverInterface {
	wrapped := UnsafeProxyResolverInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ProxyResolverInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeProxyResolverInterfaceFromGlibFull is used to convert raw C.GProxyResolverInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibFull(p unsafe.Pointer) *ProxyResolverInterface {
	wrapped := UnsafeProxyResolverInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.proxyResolverInterface,
		func (intern *proxyResolverInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeProxyResolverInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyResolverInterface] is expected to work anymore.
func UnsafeProxyResolverInterfaceFree(p *ProxyResolverInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyResolverInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceToGlibNone(p *ProxyResolverInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafeProxyResolverInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeProxyResolverInterfaceToGlibFull(p *ProxyResolverInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.proxyResolverInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // ProxyResolverInterface is invalid from here on
	return _p
}

// RemoteActionGroupInterface wraps GRemoteActionGroupInterface
// 
// see also https://docs.gtk.org/gio/struct.RemoteActionGroupInterface.html
//
type RemoteActionGroupInterface struct {
	*remoteActionGroupInterface
}

// remoteActionGroupInterface is the struct that's finalized
type remoteActionGroupInterface struct {
	native *C.GRemoteActionGroupInterface
}

// UnsafeRemoteActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RemoteActionGroupInterface) instance() *C.GRemoteActionGroupInterface {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRemoteActionGroupInterfaceFromGlibBorrow is used to convert raw C.GRemoteActionGroupInterface pointers to go. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p unsafe.Pointer) *RemoteActionGroupInterface {
	if p == nil {
		return nil
	}
	return &RemoteActionGroupInterface{&remoteActionGroupInterface{(*C.GRemoteActionGroupInterface)(p)}}
}

// UnsafeRemoteActionGroupInterfaceFromGlibNone is used to convert raw C.GRemoteActionGroupInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibNone(p unsafe.Pointer) *RemoteActionGroupInterface {
	wrapped := UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RemoteActionGroupInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRemoteActionGroupInterfaceFromGlibFull is used to convert raw C.GRemoteActionGroupInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibFull(p unsafe.Pointer) *RemoteActionGroupInterface {
	wrapped := UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.remoteActionGroupInterface,
		func (intern *remoteActionGroupInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRemoteActionGroupInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RemoteActionGroupInterface] is expected to work anymore.
func UnsafeRemoteActionGroupInterfaceFree(r *RemoteActionGroupInterface) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRemoteActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceToGlibNone(r *RemoteActionGroupInterface) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRemoteActionGroupInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceToGlibFull(r *RemoteActionGroupInterface) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.remoteActionGroupInterface, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RemoteActionGroupInterface is invalid from here on
	return _p
}

// ResolverClass wraps GResolverClass
// 
// see also https://docs.gtk.org/gio/struct.ResolverClass.html
// 
// ResolverClass is the type struct for [Resolver]
type ResolverClass struct {
	*resolverClass
}

// resolverClass is the struct that's finalized
type resolverClass struct {
	native *C.GResolverClass
}

// UnsafeResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *ResolverClass) instance() *C.GResolverClass {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeResolverClassFromGlibBorrow is used to convert raw C.GResolverClass pointers to go. This is used by the bindings internally.
func UnsafeResolverClassFromGlibBorrow(p unsafe.Pointer) *ResolverClass {
	if p == nil {
		return nil
	}
	return &ResolverClass{&resolverClass{(*C.GResolverClass)(p)}}
}

// UnsafeResolverClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ResolverClass] is expected to work anymore.
func UnsafeResolverClassFree(r *ResolverClass) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeResolverClassToGlibNone(r *ResolverClass) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (r *ResolverClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeResolverClassToGlibNone(r))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ResolverClass) {}, r)
	return parent
}

// SeekableIface wraps GSeekableIface
// 
// see also https://docs.gtk.org/gio/struct.SeekableIface.html
//
type SeekableIface struct {
	*seekableIface
}

// seekableIface is the struct that's finalized
type seekableIface struct {
	native *C.GSeekableIface
}

// UnsafeSeekableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SeekableIface) instance() *C.GSeekableIface {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSeekableIfaceFromGlibBorrow is used to convert raw C.GSeekableIface pointers to go. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibBorrow(p unsafe.Pointer) *SeekableIface {
	if p == nil {
		return nil
	}
	return &SeekableIface{&seekableIface{(*C.GSeekableIface)(p)}}
}

// UnsafeSeekableIfaceFromGlibNone is used to convert raw C.GSeekableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibNone(p unsafe.Pointer) *SeekableIface {
	wrapped := UnsafeSeekableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SeekableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSeekableIfaceFromGlibFull is used to convert raw C.GSeekableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibFull(p unsafe.Pointer) *SeekableIface {
	wrapped := UnsafeSeekableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.seekableIface,
		func (intern *seekableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSeekableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SeekableIface] is expected to work anymore.
func UnsafeSeekableIfaceFree(s *SeekableIface) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSeekableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSeekableIfaceToGlibNone(s *SeekableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSeekableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSeekableIfaceToGlibFull(s *SeekableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.seekableIface, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SeekableIface is invalid from here on
	return _p
}

// SettingsClass wraps GSettingsClass
// 
// see also https://docs.gtk.org/gio/struct.SettingsClass.html
// 
// SettingsClass is the type struct for [Settings]
type SettingsClass struct {
	*settingsClass
}

// settingsClass is the struct that's finalized
type settingsClass struct {
	native *C.GSettingsClass
}

// UnsafeSettingsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsClass) instance() *C.GSettingsClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSettingsClassFromGlibBorrow is used to convert raw C.GSettingsClass pointers to go. This is used by the bindings internally.
func UnsafeSettingsClassFromGlibBorrow(p unsafe.Pointer) *SettingsClass {
	if p == nil {
		return nil
	}
	return &SettingsClass{&settingsClass{(*C.GSettingsClass)(p)}}
}

// UnsafeSettingsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsClass] is expected to work anymore.
func UnsafeSettingsClassFree(s *SettingsClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSettingsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsClassToGlibNone(s *SettingsClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SettingsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSettingsClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SettingsClass) {}, s)
	return parent
}

// SettingsSchema wraps GSettingsSchema
// 
// see also https://docs.gtk.org/gio/struct.SettingsSchema.html
//
type SettingsSchema struct {
	*settingsSchema
}

// settingsSchema is the struct that's finalized
type settingsSchema struct {
	native *C.GSettingsSchema
}

// UnsafeSettingsSchemaToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchema) instance() *C.GSettingsSchema {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchema)(nil)

func marshalSettingsSchema(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaFromGlibNone(b), nil
}

func (r *SettingsSchema) GoValueType() gobject.Type {
	return TypeSettingsSchema
}

func (r *SettingsSchema) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaFromGlibBorrow is used to convert raw C.GSettingsSchema pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibBorrow(p unsafe.Pointer) *SettingsSchema {
	if p == nil {
		return nil
	}
	return &SettingsSchema{&settingsSchema{(*C.GSettingsSchema)(p)}}
}

// UnsafeSettingsSchemaFromGlibNone is used to convert raw C.GSettingsSchema pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibNone(p unsafe.Pointer) *SettingsSchema {
	C.g_settings_schema_ref((*C.GSettingsSchema)(p))
	wrapped := UnsafeSettingsSchemaFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchema,
		func (intern *settingsSchema) {
			C.g_settings_schema_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaFromGlibFull is used to convert raw C.GSettingsSchema pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibFull(p unsafe.Pointer) *SettingsSchema {
	wrapped := UnsafeSettingsSchemaFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchema,
		func (intern *settingsSchema) {
			C.g_settings_schema_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchema.UnsafeSettingsSchemaUnref], then [SettingsSchema] will leak memory.
func UnsafeSettingsSchemaRef(s *SettingsSchema) {
	C.g_settings_schema_ref((*C.GSettingsSchema)(s.native))
}

// UnsafeSettingsSchemaUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchema] is expected to work anymore.
func UnsafeSettingsSchemaUnref(s *SettingsSchema) {
	C.g_settings_schema_unref(s.native)
}

// UnsafeSettingsSchemaToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaToGlibNone(s *SettingsSchema) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaToGlibFull(s *SettingsSchema) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchema, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchema is invalid from here on
	return _p
}

// GetID wraps g_settings_schema_get_id
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_get_id.g_settings_schema_get_id.html
//
func (schema *SettingsSchema) GetID() string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_get_id(carg0)
	runtime.KeepAlive(schema)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetKey wraps g_settings_schema_get_key
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_get_key.g_settings_schema_get_key.html
//
func (schema *SettingsSchema) GetKey(name string) *SettingsSchemaKey {
	var carg0 *C.GSettingsSchema    // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var cret  *C.GSettingsSchemaKey // return, full, converted

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_schema_get_key(carg0, carg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var goret *SettingsSchemaKey

	goret = UnsafeSettingsSchemaKeyFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetPath wraps g_settings_schema_get_path
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_get_path.g_settings_schema_get_path.html
//
func (schema *SettingsSchema) GetPath() string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_get_path(carg0)
	runtime.KeepAlive(schema)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HasKey wraps g_settings_schema_has_key
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_has_key.g_settings_schema_has_key.html
//
func (schema *SettingsSchema) HasKey(name string) bool {
	var carg0 *C.GSettingsSchema // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var cret  C.gboolean         // return

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_schema_has_key(carg0, carg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListChildren wraps g_settings_schema_list_children
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_list_children.g_settings_schema_list_children.html
//
func (schema *SettingsSchema) ListChildren() []string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_list_children(carg0)
	runtime.KeepAlive(schema)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ListKeys wraps g_settings_schema_list_keys
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_list_keys.g_settings_schema_list_keys.html
//
func (schema *SettingsSchema) ListKeys() []string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_list_keys(carg0)
	runtime.KeepAlive(schema)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// SettingsSchemaKey wraps GSettingsSchemaKey
// 
// see also https://docs.gtk.org/gio/struct.SettingsSchemaKey.html
//
type SettingsSchemaKey struct {
	*settingsSchemaKey
}

// settingsSchemaKey is the struct that's finalized
type settingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

// UnsafeSettingsSchemaKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchemaKey) instance() *C.GSettingsSchemaKey {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchemaKey)(nil)

func marshalSettingsSchemaKey(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaKeyFromGlibNone(b), nil
}

func (r *SettingsSchemaKey) GoValueType() gobject.Type {
	return TypeSettingsSchemaKey
}

func (r *SettingsSchemaKey) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaKeyFromGlibBorrow is used to convert raw C.GSettingsSchemaKey pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibBorrow(p unsafe.Pointer) *SettingsSchemaKey {
	if p == nil {
		return nil
	}
	return &SettingsSchemaKey{&settingsSchemaKey{(*C.GSettingsSchemaKey)(p)}}
}

// UnsafeSettingsSchemaKeyFromGlibNone is used to convert raw C.GSettingsSchemaKey pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibNone(p unsafe.Pointer) *SettingsSchemaKey {
	C.g_settings_schema_key_ref((*C.GSettingsSchemaKey)(p))
	wrapped := UnsafeSettingsSchemaKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchemaKey,
		func (intern *settingsSchemaKey) {
			C.g_settings_schema_key_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaKeyFromGlibFull is used to convert raw C.GSettingsSchemaKey pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibFull(p unsafe.Pointer) *SettingsSchemaKey {
	wrapped := UnsafeSettingsSchemaKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchemaKey,
		func (intern *settingsSchemaKey) {
			C.g_settings_schema_key_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaKeyRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchemaKey.UnsafeSettingsSchemaKeyUnref], then [SettingsSchemaKey] will leak memory.
func UnsafeSettingsSchemaKeyRef(s *SettingsSchemaKey) {
	C.g_settings_schema_key_ref((*C.GSettingsSchemaKey)(s.native))
}

// UnsafeSettingsSchemaKeyUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchemaKey] is expected to work anymore.
func UnsafeSettingsSchemaKeyUnref(s *SettingsSchemaKey) {
	C.g_settings_schema_key_unref(s.native)
}

// UnsafeSettingsSchemaKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyToGlibNone(s *SettingsSchemaKey) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaKeyToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaKeyToGlibFull(s *SettingsSchemaKey) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchemaKey, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchemaKey is invalid from here on
	return _p
}

// GetDescription wraps g_settings_schema_key_get_description
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_key_get_description.g_settings_schema_key_get_description.html
//
func (key *SettingsSchemaKey) GetDescription() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_description(carg0)
	runtime.KeepAlive(key)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetName wraps g_settings_schema_key_get_name
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_key_get_name.g_settings_schema_key_get_name.html
//
func (key *SettingsSchemaKey) GetName() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_name(carg0)
	runtime.KeepAlive(key)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSummary wraps g_settings_schema_key_get_summary
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_key_get_summary.g_settings_schema_key_get_summary.html
//
func (key *SettingsSchemaKey) GetSummary() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_summary(carg0)
	runtime.KeepAlive(key)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetValueType wraps g_settings_schema_key_get_value_type
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_key_get_value_type.g_settings_schema_key_get_value_type.html
//
func (key *SettingsSchemaKey) GetValueType() *glib.VariantType {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.GVariantType       // return, none, converted

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_value_type(carg0)
	runtime.KeepAlive(key)

	var goret *glib.VariantType

	goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SettingsSchemaSource wraps GSettingsSchemaSource
// 
// see also https://docs.gtk.org/gio/struct.SettingsSchemaSource.html
//
type SettingsSchemaSource struct {
	*settingsSchemaSource
}

// settingsSchemaSource is the struct that's finalized
type settingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

// UnsafeSettingsSchemaSourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchemaSource) instance() *C.GSettingsSchemaSource {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchemaSource)(nil)

func marshalSettingsSchemaSource(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaSourceFromGlibNone(b), nil
}

func (r *SettingsSchemaSource) GoValueType() gobject.Type {
	return TypeSettingsSchemaSource
}

func (r *SettingsSchemaSource) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaSourceFromGlibBorrow is used to convert raw C.GSettingsSchemaSource pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibBorrow(p unsafe.Pointer) *SettingsSchemaSource {
	if p == nil {
		return nil
	}
	return &SettingsSchemaSource{&settingsSchemaSource{(*C.GSettingsSchemaSource)(p)}}
}

// UnsafeSettingsSchemaSourceFromGlibNone is used to convert raw C.GSettingsSchemaSource pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibNone(p unsafe.Pointer) *SettingsSchemaSource {
	C.g_settings_schema_source_ref((*C.GSettingsSchemaSource)(p))
	wrapped := UnsafeSettingsSchemaSourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchemaSource,
		func (intern *settingsSchemaSource) {
			C.g_settings_schema_source_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaSourceFromGlibFull is used to convert raw C.GSettingsSchemaSource pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibFull(p unsafe.Pointer) *SettingsSchemaSource {
	wrapped := UnsafeSettingsSchemaSourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchemaSource,
		func (intern *settingsSchemaSource) {
			C.g_settings_schema_source_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaSourceRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchemaSource.UnsafeSettingsSchemaSourceUnref], then [SettingsSchemaSource] will leak memory.
func UnsafeSettingsSchemaSourceRef(s *SettingsSchemaSource) {
	C.g_settings_schema_source_ref((*C.GSettingsSchemaSource)(s.native))
}

// UnsafeSettingsSchemaSourceUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchemaSource] is expected to work anymore.
func UnsafeSettingsSchemaSourceUnref(s *SettingsSchemaSource) {
	C.g_settings_schema_source_unref(s.native)
}

// UnsafeSettingsSchemaSourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceToGlibNone(s *SettingsSchemaSource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaSourceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaSourceToGlibFull(s *SettingsSchemaSource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchemaSource, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchemaSource is invalid from here on
	return _p
}

// NewSettingsSchemaSourceFromDirectory wraps g_settings_schema_source_new_from_directory
// 
// see also https://docs.gtk.org/gio/func.g_settings_schema_source_new_from_directory.html
//
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	var carg1 *C.gchar                 // in, none, string
	var carg2 *C.GSettingsSchemaSource // in, none, converted, nullable
	var carg3 C.gboolean               // in
	var cret  *C.GSettingsSchemaSource // return, full, converted
	var _cerr *C.GError                // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(carg1))
	if parent != nil {
		carg2 = (*C.GSettingsSchemaSource)(UnsafeSettingsSchemaSourceToGlibNone(parent))
	}
	if trusted {
		carg3 = C.TRUE
	}

	cret = C.g_settings_schema_source_new_from_directory(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(directory)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(trusted)

	var goret  *SettingsSchemaSource
	var _goerr error

	goret = UnsafeSettingsSchemaSourceFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SettingsSchemaSourceGetDefault wraps g_settings_schema_source_get_default
// 
// see also https://docs.gtk.org/gio/func.g_settings_schema_source_get_default.html
//
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {
	var cret *C.GSettingsSchemaSource // return, none, converted, nullable

	cret = C.g_settings_schema_source_get_default()

	var goret *SettingsSchemaSource

	if cret != nil {
		goret = UnsafeSettingsSchemaSourceFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Lookup wraps g_settings_schema_source_lookup
// 
// see also https://docs.gtk.org/gio/method.g_settings_schema_source_lookup.g_settings_schema_source_lookup.html
//
func (source *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	var carg0 *C.GSettingsSchemaSource // in, none, converted
	var carg1 *C.gchar                 // in, none, string
	var carg2 C.gboolean               // in
	var cret  *C.GSettingsSchema       // return, full, converted, nullable

	carg0 = (*C.GSettingsSchemaSource)(UnsafeSettingsSchemaSourceToGlibNone(source))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))
	if recursive {
		carg2 = C.TRUE
	}

	cret = C.g_settings_schema_source_lookup(carg0, carg1, carg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(recursive)

	var goret *SettingsSchema

	if cret != nil {
		goret = UnsafeSettingsSchemaFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// SimpleActionGroupClass wraps GSimpleActionGroupClass
// 
// see also https://docs.gtk.org/gio/struct.SimpleActionGroupClass.html
// 
// SimpleActionGroupClass is the type struct for [SimpleActionGroup]
type SimpleActionGroupClass struct {
	*simpleActionGroupClass
}

// simpleActionGroupClass is the struct that's finalized
type simpleActionGroupClass struct {
	native *C.GSimpleActionGroupClass
}

// UnsafeSimpleActionGroupClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleActionGroupClass) instance() *C.GSimpleActionGroupClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleActionGroupClassFromGlibBorrow is used to convert raw C.GSimpleActionGroupClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleActionGroupClassFromGlibBorrow(p unsafe.Pointer) *SimpleActionGroupClass {
	if p == nil {
		return nil
	}
	return &SimpleActionGroupClass{&simpleActionGroupClass{(*C.GSimpleActionGroupClass)(p)}}
}

// UnsafeSimpleActionGroupClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleActionGroupClass] is expected to work anymore.
func UnsafeSimpleActionGroupClassFree(s *SimpleActionGroupClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleActionGroupClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleActionGroupClassToGlibNone(s *SimpleActionGroupClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleActionGroupClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleActionGroupClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleActionGroupClass) {}, s)
	return parent
}

// SimpleAsyncResultClass wraps GSimpleAsyncResultClass
// 
// see also https://docs.gtk.org/gio/struct.SimpleAsyncResultClass.html
// 
// SimpleAsyncResultClass is the type struct for [SimpleAsyncResult]
type SimpleAsyncResultClass struct {
	*simpleAsyncResultClass
}

// simpleAsyncResultClass is the struct that's finalized
type simpleAsyncResultClass struct {
	native *C.GSimpleAsyncResultClass
}

// UnsafeSimpleAsyncResultClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleAsyncResultClass) instance() *C.GSimpleAsyncResultClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleAsyncResultClassFromGlibBorrow is used to convert raw C.GSimpleAsyncResultClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleAsyncResultClassFromGlibBorrow(p unsafe.Pointer) *SimpleAsyncResultClass {
	if p == nil {
		return nil
	}
	return &SimpleAsyncResultClass{&simpleAsyncResultClass{(*C.GSimpleAsyncResultClass)(p)}}
}

// UnsafeSimpleAsyncResultClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleAsyncResultClass] is expected to work anymore.
func UnsafeSimpleAsyncResultClassFree(s *SimpleAsyncResultClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleAsyncResultClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultClassToGlibNone(s *SimpleAsyncResultClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleAsyncResultClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleAsyncResultClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleAsyncResultClass) {}, s)
	return parent
}

// SimpleProxyResolverClass wraps GSimpleProxyResolverClass
// 
// see also https://docs.gtk.org/gio/struct.SimpleProxyResolverClass.html
// 
// SimpleProxyResolverClass is the type struct for [SimpleProxyResolver]
type SimpleProxyResolverClass struct {
	*simpleProxyResolverClass
}

// simpleProxyResolverClass is the struct that's finalized
type simpleProxyResolverClass struct {
	native *C.GSimpleProxyResolverClass
}

// UnsafeSimpleProxyResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleProxyResolverClass) instance() *C.GSimpleProxyResolverClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleProxyResolverClassFromGlibBorrow is used to convert raw C.GSimpleProxyResolverClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleProxyResolverClassFromGlibBorrow(p unsafe.Pointer) *SimpleProxyResolverClass {
	if p == nil {
		return nil
	}
	return &SimpleProxyResolverClass{&simpleProxyResolverClass{(*C.GSimpleProxyResolverClass)(p)}}
}

// UnsafeSimpleProxyResolverClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleProxyResolverClass] is expected to work anymore.
func UnsafeSimpleProxyResolverClassFree(s *SimpleProxyResolverClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleProxyResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverClassToGlibNone(s *SimpleProxyResolverClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleProxyResolverClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleProxyResolverClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleProxyResolverClass) {}, s)
	return parent
}

// SocketAddressClass wraps GSocketAddressClass
// 
// see also https://docs.gtk.org/gio/struct.SocketAddressClass.html
// 
// SocketAddressClass is the type struct for [SocketAddress]
type SocketAddressClass struct {
	*socketAddressClass
}

// socketAddressClass is the struct that's finalized
type socketAddressClass struct {
	native *C.GSocketAddressClass
}

// UnsafeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketAddressClass) instance() *C.GSocketAddressClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketAddressClassFromGlibBorrow is used to convert raw C.GSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *SocketAddressClass {
	if p == nil {
		return nil
	}
	return &SocketAddressClass{&socketAddressClass{(*C.GSocketAddressClass)(p)}}
}

// UnsafeSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketAddressClass] is expected to work anymore.
func UnsafeSocketAddressClassFree(s *SocketAddressClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketAddressClassToGlibNone(s *SocketAddressClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketAddressClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketAddressClass) {}, s)
	return parent
}

// SocketAddressEnumeratorClass wraps GSocketAddressEnumeratorClass
// 
// see also https://docs.gtk.org/gio/struct.SocketAddressEnumeratorClass.html
//
// 
// SocketAddressEnumeratorClass is the type struct for [SocketAddressEnumerator]
type SocketAddressEnumeratorClass struct {
	*socketAddressEnumeratorClass
}

// socketAddressEnumeratorClass is the struct that's finalized
type socketAddressEnumeratorClass struct {
	native *C.GSocketAddressEnumeratorClass
}

// UnsafeSocketAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketAddressEnumeratorClass) instance() *C.GSocketAddressEnumeratorClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketAddressEnumeratorClassFromGlibBorrow is used to convert raw C.GSocketAddressEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *SocketAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return &SocketAddressEnumeratorClass{&socketAddressEnumeratorClass{(*C.GSocketAddressEnumeratorClass)(p)}}
}

// UnsafeSocketAddressEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketAddressEnumeratorClass] is expected to work anymore.
func UnsafeSocketAddressEnumeratorClassFree(s *SocketAddressEnumeratorClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorClassToGlibNone(s *SocketAddressEnumeratorClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketAddressEnumeratorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketAddressEnumeratorClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketAddressEnumeratorClass) {}, s)
	return parent
}

// SocketClass wraps GSocketClass
// 
// see also https://docs.gtk.org/gio/struct.SocketClass.html
// 
// SocketClass is the type struct for [Socket]
type SocketClass struct {
	*socketClass
}

// socketClass is the struct that's finalized
type socketClass struct {
	native *C.GSocketClass
}

// UnsafeSocketClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketClass) instance() *C.GSocketClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketClassFromGlibBorrow is used to convert raw C.GSocketClass pointers to go. This is used by the bindings internally.
func UnsafeSocketClassFromGlibBorrow(p unsafe.Pointer) *SocketClass {
	if p == nil {
		return nil
	}
	return &SocketClass{&socketClass{(*C.GSocketClass)(p)}}
}

// UnsafeSocketClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketClass] is expected to work anymore.
func UnsafeSocketClassFree(s *SocketClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketClassToGlibNone(s *SocketClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketClass) {}, s)
	return parent
}

// SocketClientClass wraps GSocketClientClass
// 
// see also https://docs.gtk.org/gio/struct.SocketClientClass.html
// 
// SocketClientClass is the type struct for [SocketClient]
type SocketClientClass struct {
	*socketClientClass
}

// socketClientClass is the struct that's finalized
type socketClientClass struct {
	native *C.GSocketClientClass
}

// UnsafeSocketClientClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketClientClass) instance() *C.GSocketClientClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketClientClassFromGlibBorrow is used to convert raw C.GSocketClientClass pointers to go. This is used by the bindings internally.
func UnsafeSocketClientClassFromGlibBorrow(p unsafe.Pointer) *SocketClientClass {
	if p == nil {
		return nil
	}
	return &SocketClientClass{&socketClientClass{(*C.GSocketClientClass)(p)}}
}

// UnsafeSocketClientClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketClientClass] is expected to work anymore.
func UnsafeSocketClientClassFree(s *SocketClientClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketClientClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketClientClassToGlibNone(s *SocketClientClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketClientClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketClientClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketClientClass) {}, s)
	return parent
}

// SocketConnectableIface wraps GSocketConnectableIface
// 
// see also https://docs.gtk.org/gio/struct.SocketConnectableIface.html
//
type SocketConnectableIface struct {
	*socketConnectableIface
}

// socketConnectableIface is the struct that's finalized
type socketConnectableIface struct {
	native *C.GSocketConnectableIface
}

// UnsafeSocketConnectableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketConnectableIface) instance() *C.GSocketConnectableIface {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketConnectableIfaceFromGlibBorrow is used to convert raw C.GSocketConnectableIface pointers to go. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibBorrow(p unsafe.Pointer) *SocketConnectableIface {
	if p == nil {
		return nil
	}
	return &SocketConnectableIface{&socketConnectableIface{(*C.GSocketConnectableIface)(p)}}
}

// UnsafeSocketConnectableIfaceFromGlibNone is used to convert raw C.GSocketConnectableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibNone(p unsafe.Pointer) *SocketConnectableIface {
	wrapped := UnsafeSocketConnectableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SocketConnectableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSocketConnectableIfaceFromGlibFull is used to convert raw C.GSocketConnectableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibFull(p unsafe.Pointer) *SocketConnectableIface {
	wrapped := UnsafeSocketConnectableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.socketConnectableIface,
		func (intern *socketConnectableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSocketConnectableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketConnectableIface] is expected to work anymore.
func UnsafeSocketConnectableIfaceFree(s *SocketConnectableIface) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketConnectableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceToGlibNone(s *SocketConnectableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSocketConnectableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSocketConnectableIfaceToGlibFull(s *SocketConnectableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.socketConnectableIface, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SocketConnectableIface is invalid from here on
	return _p
}

// SocketConnectionClass wraps GSocketConnectionClass
// 
// see also https://docs.gtk.org/gio/struct.SocketConnectionClass.html
// 
// SocketConnectionClass is the type struct for [SocketConnection]
type SocketConnectionClass struct {
	*socketConnectionClass
}

// socketConnectionClass is the struct that's finalized
type socketConnectionClass struct {
	native *C.GSocketConnectionClass
}

// UnsafeSocketConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketConnectionClass) instance() *C.GSocketConnectionClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketConnectionClassFromGlibBorrow is used to convert raw C.GSocketConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeSocketConnectionClassFromGlibBorrow(p unsafe.Pointer) *SocketConnectionClass {
	if p == nil {
		return nil
	}
	return &SocketConnectionClass{&socketConnectionClass{(*C.GSocketConnectionClass)(p)}}
}

// UnsafeSocketConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketConnectionClass] is expected to work anymore.
func UnsafeSocketConnectionClassFree(s *SocketConnectionClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketConnectionClassToGlibNone(s *SocketConnectionClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketConnectionClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeSocketConnectionClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketConnectionClass) {}, s)
	return parent
}

// SocketControlMessageClass wraps GSocketControlMessageClass
// 
// see also https://docs.gtk.org/gio/struct.SocketControlMessageClass.html
//
// 
// SocketControlMessageClass is the type struct for [SocketControlMessage]
type SocketControlMessageClass struct {
	*socketControlMessageClass
}

// socketControlMessageClass is the struct that's finalized
type socketControlMessageClass struct {
	native *C.GSocketControlMessageClass
}

// UnsafeSocketControlMessageClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketControlMessageClass) instance() *C.GSocketControlMessageClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketControlMessageClassFromGlibBorrow is used to convert raw C.GSocketControlMessageClass pointers to go. This is used by the bindings internally.
func UnsafeSocketControlMessageClassFromGlibBorrow(p unsafe.Pointer) *SocketControlMessageClass {
	if p == nil {
		return nil
	}
	return &SocketControlMessageClass{&socketControlMessageClass{(*C.GSocketControlMessageClass)(p)}}
}

// UnsafeSocketControlMessageClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketControlMessageClass] is expected to work anymore.
func UnsafeSocketControlMessageClassFree(s *SocketControlMessageClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketControlMessageClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketControlMessageClassToGlibNone(s *SocketControlMessageClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketControlMessageClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketControlMessageClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketControlMessageClass) {}, s)
	return parent
}

// SocketListenerClass wraps GSocketListenerClass
// 
// see also https://docs.gtk.org/gio/struct.SocketListenerClass.html
//
// 
// SocketListenerClass is the type struct for [SocketListener]
type SocketListenerClass struct {
	*socketListenerClass
}

// socketListenerClass is the struct that's finalized
type socketListenerClass struct {
	native *C.GSocketListenerClass
}

// UnsafeSocketListenerClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketListenerClass) instance() *C.GSocketListenerClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketListenerClassFromGlibBorrow is used to convert raw C.GSocketListenerClass pointers to go. This is used by the bindings internally.
func UnsafeSocketListenerClassFromGlibBorrow(p unsafe.Pointer) *SocketListenerClass {
	if p == nil {
		return nil
	}
	return &SocketListenerClass{&socketListenerClass{(*C.GSocketListenerClass)(p)}}
}

// UnsafeSocketListenerClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketListenerClass] is expected to work anymore.
func UnsafeSocketListenerClassFree(s *SocketListenerClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketListenerClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketListenerClassToGlibNone(s *SocketListenerClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketListenerClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketListenerClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketListenerClass) {}, s)
	return parent
}

// SocketServiceClass wraps GSocketServiceClass
// 
// see also https://docs.gtk.org/gio/struct.SocketServiceClass.html
//
// 
// SocketServiceClass is the type struct for [SocketService]
type SocketServiceClass struct {
	*socketServiceClass
}

// socketServiceClass is the struct that's finalized
type socketServiceClass struct {
	native *C.GSocketServiceClass
}

// UnsafeSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketServiceClass) instance() *C.GSocketServiceClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketServiceClassFromGlibBorrow is used to convert raw C.GSocketServiceClass pointers to go. This is used by the bindings internally.
func UnsafeSocketServiceClassFromGlibBorrow(p unsafe.Pointer) *SocketServiceClass {
	if p == nil {
		return nil
	}
	return &SocketServiceClass{&socketServiceClass{(*C.GSocketServiceClass)(p)}}
}

// UnsafeSocketServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketServiceClass] is expected to work anymore.
func UnsafeSocketServiceClassFree(s *SocketServiceClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketServiceClassToGlibNone(s *SocketServiceClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketServiceClass) ParentClass() *SocketListenerClass {
	parent := UnsafeSocketListenerClassFromGlibBorrow(UnsafeSocketServiceClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketServiceClass) {}, s)
	return parent
}

// SrvTarget wraps GSrvTarget
// 
// see also https://docs.gtk.org/gio/struct.SrvTarget.html
//
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized
type srvTarget struct {
	native *C.GSrvTarget
}

// UnsafeSrvTargetToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SrvTarget) instance() *C.GSrvTarget {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SrvTarget)(nil)

func marshalSrvTarget(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSrvTargetFromGlibNone(b), nil
}

func (r *SrvTarget) GoValueType() gobject.Type {
	return TypeSrvTarget
}

func (r *SrvTarget) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSrvTargetFromGlibBorrow is used to convert raw C.GSrvTarget pointers to go. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibBorrow(p unsafe.Pointer) *SrvTarget {
	if p == nil {
		return nil
	}
	return &SrvTarget{&srvTarget{(*C.GSrvTarget)(p)}}
}

// UnsafeSrvTargetFromGlibNone is used to convert raw C.GSrvTarget pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibNone(p unsafe.Pointer) *SrvTarget {
	wrapped := UnsafeSrvTargetFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeSrvTargetFromGlibFull is used to convert raw C.GSrvTarget pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibFull(p unsafe.Pointer) *SrvTarget {
	wrapped := UnsafeSrvTargetFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.srvTarget,
		func (intern *srvTarget) {
			C.g_srv_target_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeSrvTargetFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SrvTarget] is expected to work anymore.
func UnsafeSrvTargetFree(s *SrvTarget) {
	C.g_srv_target_free(s.native)
}

// UnsafeSrvTargetToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSrvTargetToGlibNone(s *SrvTarget) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSrvTargetToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSrvTargetToGlibFull(s *SrvTarget) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.srvTarget, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SrvTarget is invalid from here on
	return _p
}

// NewSrvTarget wraps g_srv_target_new
// 
// see also https://docs.gtk.org/gio/func.g_srv_target_new.html
//
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var carg1 *C.gchar      // in, none, string
	var carg2 C.guint16     // in, none, casted
	var carg3 C.guint16     // in, none, casted
	var carg4 C.guint16     // in, none, casted
	var cret  *C.GSrvTarget // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(port)
	carg3 = C.guint16(priority)
	carg4 = C.guint16(weight)

	cret = C.g_srv_target_new(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(weight)

	var goret *SrvTarget

	goret = UnsafeSrvTargetFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_srv_target_copy
// 
// see also https://docs.gtk.org/gio/method.g_srv_target_copy.g_srv_target_copy.html
//
func (target *SrvTarget) Copy() *SrvTarget {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  *C.GSrvTarget // return, full, converted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_copy(carg0)
	runtime.KeepAlive(target)

	var goret *SrvTarget

	goret = UnsafeSrvTargetFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetHostname wraps g_srv_target_get_hostname
// 
// see also https://docs.gtk.org/gio/method.g_srv_target_get_hostname.g_srv_target_get_hostname.html
//
func (target *SrvTarget) GetHostname() string {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_hostname(carg0)
	runtime.KeepAlive(target)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_srv_target_get_port
// 
// see also https://docs.gtk.org/gio/method.g_srv_target_get_port.g_srv_target_get_port.html
//
func (target *SrvTarget) GetPort() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_port(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetPriority wraps g_srv_target_get_priority
// 
// see also https://docs.gtk.org/gio/method.g_srv_target_get_priority.g_srv_target_get_priority.html
//
func (target *SrvTarget) GetPriority() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_priority(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetWeight wraps g_srv_target_get_weight
// 
// see also https://docs.gtk.org/gio/method.g_srv_target_get_weight.g_srv_target_get_weight.html
//
func (target *SrvTarget) GetWeight() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_weight(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// StaticResource wraps GStaticResource
// 
// see also https://docs.gtk.org/gio/struct.StaticResource.html
//
type StaticResource struct {
	*staticResource
}

// staticResource is the struct that's finalized
type staticResource struct {
	native *C.GStaticResource
}

// UnsafeStaticResourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StaticResource) instance() *C.GStaticResource {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStaticResourceFromGlibBorrow is used to convert raw C.GStaticResource pointers to go. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibBorrow(p unsafe.Pointer) *StaticResource {
	if p == nil {
		return nil
	}
	return &StaticResource{&staticResource{(*C.GStaticResource)(p)}}
}

// UnsafeStaticResourceFromGlibNone is used to convert raw C.GStaticResource pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibNone(p unsafe.Pointer) *StaticResource {
	wrapped := UnsafeStaticResourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to StaticResource because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeStaticResourceFromGlibFull is used to convert raw C.GStaticResource pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibFull(p unsafe.Pointer) *StaticResource {
	wrapped := UnsafeStaticResourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.staticResource,
		func (intern *staticResource) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeStaticResourceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StaticResource] is expected to work anymore.
func UnsafeStaticResourceFree(s *StaticResource) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeStaticResourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStaticResourceToGlibNone(s *StaticResource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStaticResourceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStaticResourceToGlibFull(s *StaticResource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.staticResource, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StaticResource is invalid from here on
	return _p
}

// Fini wraps g_static_resource_fini
// 
// see also https://docs.gtk.org/gio/method.g_static_resource_fini.g_static_resource_fini.html
//
func (staticResource *StaticResource) Fini() {
	var carg0 *C.GStaticResource // in, none, converted

	carg0 = (*C.GStaticResource)(UnsafeStaticResourceToGlibNone(staticResource))

	C.g_static_resource_fini(carg0)
	runtime.KeepAlive(staticResource)
}

// Init wraps g_static_resource_init
// 
// see also https://docs.gtk.org/gio/method.g_static_resource_init.g_static_resource_init.html
//
func (staticResource *StaticResource) Init() {
	var carg0 *C.GStaticResource // in, none, converted

	carg0 = (*C.GStaticResource)(UnsafeStaticResourceToGlibNone(staticResource))

	C.g_static_resource_init(carg0)
	runtime.KeepAlive(staticResource)
}

// TaskClass wraps GTaskClass
// 
// see also https://docs.gtk.org/gio/struct.TaskClass.html
// 
// TaskClass is the type struct for [Task]
type TaskClass struct {
	*taskClass
}

// taskClass is the struct that's finalized
type taskClass struct {
	native *C.GTaskClass
}

// UnsafeTaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TaskClass) instance() *C.GTaskClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTaskClassFromGlibBorrow is used to convert raw C.GTaskClass pointers to go. This is used by the bindings internally.
func UnsafeTaskClassFromGlibBorrow(p unsafe.Pointer) *TaskClass {
	if p == nil {
		return nil
	}
	return &TaskClass{&taskClass{(*C.GTaskClass)(p)}}
}

// UnsafeTaskClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TaskClass] is expected to work anymore.
func UnsafeTaskClassFree(t *TaskClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTaskClassToGlibNone(t *TaskClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TaskClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTaskClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TaskClass) {}, t)
	return parent
}

// TcpConnectionClass wraps GTcpConnectionClass
// 
// see also https://docs.gtk.org/gio/struct.TcpConnectionClass.html
// 
// TcpConnectionClass is the type struct for [TcpConnection]
type TcpConnectionClass struct {
	*tcpConnectionClass
}

// tcpConnectionClass is the struct that's finalized
type tcpConnectionClass struct {
	native *C.GTcpConnectionClass
}

// UnsafeTcpConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TcpConnectionClass) instance() *C.GTcpConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTcpConnectionClassFromGlibBorrow is used to convert raw C.GTcpConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTcpConnectionClassFromGlibBorrow(p unsafe.Pointer) *TcpConnectionClass {
	if p == nil {
		return nil
	}
	return &TcpConnectionClass{&tcpConnectionClass{(*C.GTcpConnectionClass)(p)}}
}

// UnsafeTcpConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TcpConnectionClass] is expected to work anymore.
func UnsafeTcpConnectionClassFree(t *TcpConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTcpConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTcpConnectionClassToGlibNone(t *TcpConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TcpConnectionClass) ParentClass() *SocketConnectionClass {
	parent := UnsafeSocketConnectionClassFromGlibBorrow(UnsafeTcpConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TcpConnectionClass) {}, t)
	return parent
}

// TcpWrapperConnectionClass wraps GTcpWrapperConnectionClass
// 
// see also https://docs.gtk.org/gio/struct.TcpWrapperConnectionClass.html
// 
// TcpWrapperConnectionClass is the type struct for [TcpWrapperConnection]
type TcpWrapperConnectionClass struct {
	*tcpWrapperConnectionClass
}

// tcpWrapperConnectionClass is the struct that's finalized
type tcpWrapperConnectionClass struct {
	native *C.GTcpWrapperConnectionClass
}

// UnsafeTcpWrapperConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TcpWrapperConnectionClass) instance() *C.GTcpWrapperConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTcpWrapperConnectionClassFromGlibBorrow is used to convert raw C.GTcpWrapperConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionClassFromGlibBorrow(p unsafe.Pointer) *TcpWrapperConnectionClass {
	if p == nil {
		return nil
	}
	return &TcpWrapperConnectionClass{&tcpWrapperConnectionClass{(*C.GTcpWrapperConnectionClass)(p)}}
}

// UnsafeTcpWrapperConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TcpWrapperConnectionClass] is expected to work anymore.
func UnsafeTcpWrapperConnectionClassFree(t *TcpWrapperConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTcpWrapperConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionClassToGlibNone(t *TcpWrapperConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TcpWrapperConnectionClass) ParentClass() *TcpConnectionClass {
	parent := UnsafeTcpConnectionClassFromGlibBorrow(UnsafeTcpWrapperConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TcpWrapperConnectionClass) {}, t)
	return parent
}

// ThemedIconClass wraps GThemedIconClass
// 
// see also https://docs.gtk.org/gio/struct.ThemedIconClass.html
// 
// ThemedIconClass is the type struct for [ThemedIcon]
type ThemedIconClass struct {
	*themedIconClass
}

// themedIconClass is the struct that's finalized
type themedIconClass struct {
	native *C.GThemedIconClass
}

// UnsafeThemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *ThemedIconClass) instance() *C.GThemedIconClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeThemedIconClassFromGlibBorrow is used to convert raw C.GThemedIconClass pointers to go. This is used by the bindings internally.
func UnsafeThemedIconClassFromGlibBorrow(p unsafe.Pointer) *ThemedIconClass {
	if p == nil {
		return nil
	}
	return &ThemedIconClass{&themedIconClass{(*C.GThemedIconClass)(p)}}
}

// UnsafeThemedIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ThemedIconClass] is expected to work anymore.
func UnsafeThemedIconClassFree(t *ThemedIconClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeThemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeThemedIconClassToGlibNone(t *ThemedIconClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *ThemedIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeThemedIconClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ThemedIconClass) {}, t)
	return parent
}

// ThreadedSocketServiceClass wraps GThreadedSocketServiceClass
// 
// see also https://docs.gtk.org/gio/struct.ThreadedSocketServiceClass.html
// 
// ThreadedSocketServiceClass is the type struct for [ThreadedSocketService]
type ThreadedSocketServiceClass struct {
	*threadedSocketServiceClass
}

// threadedSocketServiceClass is the struct that's finalized
type threadedSocketServiceClass struct {
	native *C.GThreadedSocketServiceClass
}

// UnsafeThreadedSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *ThreadedSocketServiceClass) instance() *C.GThreadedSocketServiceClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeThreadedSocketServiceClassFromGlibBorrow is used to convert raw C.GThreadedSocketServiceClass pointers to go. This is used by the bindings internally.
func UnsafeThreadedSocketServiceClassFromGlibBorrow(p unsafe.Pointer) *ThreadedSocketServiceClass {
	if p == nil {
		return nil
	}
	return &ThreadedSocketServiceClass{&threadedSocketServiceClass{(*C.GThreadedSocketServiceClass)(p)}}
}

// UnsafeThreadedSocketServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ThreadedSocketServiceClass] is expected to work anymore.
func UnsafeThreadedSocketServiceClassFree(t *ThreadedSocketServiceClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeThreadedSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceClassToGlibNone(t *ThreadedSocketServiceClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *ThreadedSocketServiceClass) ParentClass() *SocketServiceClass {
	parent := UnsafeSocketServiceClassFromGlibBorrow(UnsafeThreadedSocketServiceClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ThreadedSocketServiceClass) {}, t)
	return parent
}

// TlsBackendInterface wraps GTlsBackendInterface
// 
// see also https://docs.gtk.org/gio/struct.TlsBackendInterface.html
//
type TlsBackendInterface struct {
	*tlsBackendInterface
}

// tlsBackendInterface is the struct that's finalized
type tlsBackendInterface struct {
	native *C.GTlsBackendInterface
}

// UnsafeTlsBackendInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsBackendInterface) instance() *C.GTlsBackendInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsBackendInterfaceFromGlibBorrow is used to convert raw C.GTlsBackendInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsBackendInterface {
	if p == nil {
		return nil
	}
	return &TlsBackendInterface{&tlsBackendInterface{(*C.GTlsBackendInterface)(p)}}
}

// UnsafeTlsBackendInterfaceFromGlibNone is used to convert raw C.GTlsBackendInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibNone(p unsafe.Pointer) *TlsBackendInterface {
	wrapped := UnsafeTlsBackendInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsBackendInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsBackendInterfaceFromGlibFull is used to convert raw C.GTlsBackendInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibFull(p unsafe.Pointer) *TlsBackendInterface {
	wrapped := UnsafeTlsBackendInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsBackendInterface,
		func (intern *tlsBackendInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsBackendInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsBackendInterface] is expected to work anymore.
func UnsafeTlsBackendInterfaceFree(t *TlsBackendInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsBackendInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceToGlibNone(t *TlsBackendInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsBackendInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsBackendInterfaceToGlibFull(t *TlsBackendInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsBackendInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsBackendInterface is invalid from here on
	return _p
}

// TlsCertificateClass wraps GTlsCertificateClass
// 
// see also https://docs.gtk.org/gio/struct.TlsCertificateClass.html
// 
// TlsCertificateClass is the type struct for [TlsCertificate]
type TlsCertificateClass struct {
	*tlsCertificateClass
}

// tlsCertificateClass is the struct that's finalized
type tlsCertificateClass struct {
	native *C.GTlsCertificateClass
}

// UnsafeTlsCertificateClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsCertificateClass) instance() *C.GTlsCertificateClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsCertificateClassFromGlibBorrow is used to convert raw C.GTlsCertificateClass pointers to go. This is used by the bindings internally.
func UnsafeTlsCertificateClassFromGlibBorrow(p unsafe.Pointer) *TlsCertificateClass {
	if p == nil {
		return nil
	}
	return &TlsCertificateClass{&tlsCertificateClass{(*C.GTlsCertificateClass)(p)}}
}

// UnsafeTlsCertificateClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsCertificateClass] is expected to work anymore.
func UnsafeTlsCertificateClassFree(t *TlsCertificateClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsCertificateClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsCertificateClassToGlibNone(t *TlsCertificateClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsCertificateClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsCertificateClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsCertificateClass) {}, t)
	return parent
}

// TlsClientConnectionInterface wraps GTlsClientConnectionInterface
// 
// see also https://docs.gtk.org/gio/struct.TlsClientConnectionInterface.html
//
type TlsClientConnectionInterface struct {
	*tlsClientConnectionInterface
}

// tlsClientConnectionInterface is the struct that's finalized
type tlsClientConnectionInterface struct {
	native *C.GTlsClientConnectionInterface
}

// UnsafeTlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsClientConnectionInterface) instance() *C.GTlsClientConnectionInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsClientConnectionInterfaceFromGlibBorrow is used to convert raw C.GTlsClientConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsClientConnectionInterface {
	if p == nil {
		return nil
	}
	return &TlsClientConnectionInterface{&tlsClientConnectionInterface{(*C.GTlsClientConnectionInterface)(p)}}
}

// UnsafeTlsClientConnectionInterfaceFromGlibNone is used to convert raw C.GTlsClientConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibNone(p unsafe.Pointer) *TlsClientConnectionInterface {
	wrapped := UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsClientConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsClientConnectionInterfaceFromGlibFull is used to convert raw C.GTlsClientConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibFull(p unsafe.Pointer) *TlsClientConnectionInterface {
	wrapped := UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsClientConnectionInterface,
		func (intern *tlsClientConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsClientConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsClientConnectionInterface] is expected to work anymore.
func UnsafeTlsClientConnectionInterfaceFree(t *TlsClientConnectionInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceToGlibNone(t *TlsClientConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsClientConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceToGlibFull(t *TlsClientConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsClientConnectionInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsClientConnectionInterface is invalid from here on
	return _p
}

// TlsConnectionClass wraps GTlsConnectionClass
// 
// see also https://docs.gtk.org/gio/struct.TlsConnectionClass.html
//
// 
// TlsConnectionClass is the type struct for [TlsConnection]
type TlsConnectionClass struct {
	*tlsConnectionClass
}

// tlsConnectionClass is the struct that's finalized
type tlsConnectionClass struct {
	native *C.GTlsConnectionClass
}

// UnsafeTlsConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsConnectionClass) instance() *C.GTlsConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsConnectionClassFromGlibBorrow is used to convert raw C.GTlsConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTlsConnectionClassFromGlibBorrow(p unsafe.Pointer) *TlsConnectionClass {
	if p == nil {
		return nil
	}
	return &TlsConnectionClass{&tlsConnectionClass{(*C.GTlsConnectionClass)(p)}}
}

// UnsafeTlsConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsConnectionClass] is expected to work anymore.
func UnsafeTlsConnectionClassFree(t *TlsConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsConnectionClassToGlibNone(t *TlsConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsConnectionClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeTlsConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsConnectionClass) {}, t)
	return parent
}

// TlsDatabaseClass wraps GTlsDatabaseClass
// 
// see also https://docs.gtk.org/gio/struct.TlsDatabaseClass.html
//
// 
// TlsDatabaseClass is the type struct for [TlsDatabase]
type TlsDatabaseClass struct {
	*tlsDatabaseClass
}

// tlsDatabaseClass is the struct that's finalized
type tlsDatabaseClass struct {
	native *C.GTlsDatabaseClass
}

// UnsafeTlsDatabaseClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsDatabaseClass) instance() *C.GTlsDatabaseClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsDatabaseClassFromGlibBorrow is used to convert raw C.GTlsDatabaseClass pointers to go. This is used by the bindings internally.
func UnsafeTlsDatabaseClassFromGlibBorrow(p unsafe.Pointer) *TlsDatabaseClass {
	if p == nil {
		return nil
	}
	return &TlsDatabaseClass{&tlsDatabaseClass{(*C.GTlsDatabaseClass)(p)}}
}

// UnsafeTlsDatabaseClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsDatabaseClass] is expected to work anymore.
func UnsafeTlsDatabaseClassFree(t *TlsDatabaseClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsDatabaseClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsDatabaseClassToGlibNone(t *TlsDatabaseClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsDatabaseClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsDatabaseClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsDatabaseClass) {}, t)
	return parent
}

// TlsFileDatabaseInterface wraps GTlsFileDatabaseInterface
// 
// see also https://docs.gtk.org/gio/struct.TlsFileDatabaseInterface.html
//
type TlsFileDatabaseInterface struct {
	*tlsFileDatabaseInterface
}

// tlsFileDatabaseInterface is the struct that's finalized
type tlsFileDatabaseInterface struct {
	native *C.GTlsFileDatabaseInterface
}

// UnsafeTlsFileDatabaseInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsFileDatabaseInterface) instance() *C.GTlsFileDatabaseInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsFileDatabaseInterfaceFromGlibBorrow is used to convert raw C.GTlsFileDatabaseInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsFileDatabaseInterface {
	if p == nil {
		return nil
	}
	return &TlsFileDatabaseInterface{&tlsFileDatabaseInterface{(*C.GTlsFileDatabaseInterface)(p)}}
}

// UnsafeTlsFileDatabaseInterfaceFromGlibNone is used to convert raw C.GTlsFileDatabaseInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibNone(p unsafe.Pointer) *TlsFileDatabaseInterface {
	wrapped := UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsFileDatabaseInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsFileDatabaseInterfaceFromGlibFull is used to convert raw C.GTlsFileDatabaseInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibFull(p unsafe.Pointer) *TlsFileDatabaseInterface {
	wrapped := UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsFileDatabaseInterface,
		func (intern *tlsFileDatabaseInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsFileDatabaseInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsFileDatabaseInterface] is expected to work anymore.
func UnsafeTlsFileDatabaseInterfaceFree(t *TlsFileDatabaseInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsFileDatabaseInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceToGlibNone(t *TlsFileDatabaseInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsFileDatabaseInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceToGlibFull(t *TlsFileDatabaseInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsFileDatabaseInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsFileDatabaseInterface is invalid from here on
	return _p
}

// TlsInteractionClass wraps GTlsInteractionClass
// 
// see also https://docs.gtk.org/gio/struct.TlsInteractionClass.html
//
// 
// TlsInteractionClass is the type struct for [TlsInteraction]
type TlsInteractionClass struct {
	*tlsInteractionClass
}

// tlsInteractionClass is the struct that's finalized
type tlsInteractionClass struct {
	native *C.GTlsInteractionClass
}

// UnsafeTlsInteractionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsInteractionClass) instance() *C.GTlsInteractionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsInteractionClassFromGlibBorrow is used to convert raw C.GTlsInteractionClass pointers to go. This is used by the bindings internally.
func UnsafeTlsInteractionClassFromGlibBorrow(p unsafe.Pointer) *TlsInteractionClass {
	if p == nil {
		return nil
	}
	return &TlsInteractionClass{&tlsInteractionClass{(*C.GTlsInteractionClass)(p)}}
}

// UnsafeTlsInteractionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsInteractionClass] is expected to work anymore.
func UnsafeTlsInteractionClassFree(t *TlsInteractionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsInteractionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsInteractionClassToGlibNone(t *TlsInteractionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsInteractionClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsInteractionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsInteractionClass) {}, t)
	return parent
}

// TlsPasswordClass wraps GTlsPasswordClass
// 
// see also https://docs.gtk.org/gio/struct.TlsPasswordClass.html
//
// 
// TlsPasswordClass is the type struct for [TlsPassword]
type TlsPasswordClass struct {
	*tlsPasswordClass
}

// tlsPasswordClass is the struct that's finalized
type tlsPasswordClass struct {
	native *C.GTlsPasswordClass
}

// UnsafeTlsPasswordClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsPasswordClass) instance() *C.GTlsPasswordClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsPasswordClassFromGlibBorrow is used to convert raw C.GTlsPasswordClass pointers to go. This is used by the bindings internally.
func UnsafeTlsPasswordClassFromGlibBorrow(p unsafe.Pointer) *TlsPasswordClass {
	if p == nil {
		return nil
	}
	return &TlsPasswordClass{&tlsPasswordClass{(*C.GTlsPasswordClass)(p)}}
}

// UnsafeTlsPasswordClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsPasswordClass] is expected to work anymore.
func UnsafeTlsPasswordClassFree(t *TlsPasswordClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsPasswordClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsPasswordClassToGlibNone(t *TlsPasswordClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsPasswordClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsPasswordClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsPasswordClass) {}, t)
	return parent
}

// TlsServerConnectionInterface wraps GTlsServerConnectionInterface
// 
// see also https://docs.gtk.org/gio/struct.TlsServerConnectionInterface.html
//
type TlsServerConnectionInterface struct {
	*tlsServerConnectionInterface
}

// tlsServerConnectionInterface is the struct that's finalized
type tlsServerConnectionInterface struct {
	native *C.GTlsServerConnectionInterface
}

// UnsafeTlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsServerConnectionInterface) instance() *C.GTlsServerConnectionInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsServerConnectionInterfaceFromGlibBorrow is used to convert raw C.GTlsServerConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsServerConnectionInterface {
	if p == nil {
		return nil
	}
	return &TlsServerConnectionInterface{&tlsServerConnectionInterface{(*C.GTlsServerConnectionInterface)(p)}}
}

// UnsafeTlsServerConnectionInterfaceFromGlibNone is used to convert raw C.GTlsServerConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibNone(p unsafe.Pointer) *TlsServerConnectionInterface {
	wrapped := UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsServerConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsServerConnectionInterfaceFromGlibFull is used to convert raw C.GTlsServerConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibFull(p unsafe.Pointer) *TlsServerConnectionInterface {
	wrapped := UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsServerConnectionInterface,
		func (intern *tlsServerConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsServerConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsServerConnectionInterface] is expected to work anymore.
func UnsafeTlsServerConnectionInterfaceFree(t *TlsServerConnectionInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceToGlibNone(t *TlsServerConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsServerConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceToGlibFull(t *TlsServerConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsServerConnectionInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsServerConnectionInterface is invalid from here on
	return _p
}

// VfsClass wraps GVfsClass
// 
// see also https://docs.gtk.org/gio/struct.VfsClass.html
// 
// VfsClass is the type struct for [Vfs]
type VfsClass struct {
	*vfsClass
}

// vfsClass is the struct that's finalized
type vfsClass struct {
	native *C.GVfsClass
}

// UnsafeVfsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VfsClass) instance() *C.GVfsClass {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVfsClassFromGlibBorrow is used to convert raw C.GVfsClass pointers to go. This is used by the bindings internally.
func UnsafeVfsClassFromGlibBorrow(p unsafe.Pointer) *VfsClass {
	if p == nil {
		return nil
	}
	return &VfsClass{&vfsClass{(*C.GVfsClass)(p)}}
}

// UnsafeVfsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VfsClass] is expected to work anymore.
func UnsafeVfsClassFree(v *VfsClass) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVfsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVfsClassToGlibNone(v *VfsClass) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (v *VfsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeVfsClassToGlibNone(v))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *VfsClass) {}, v)
	return parent
}

// VolumeIface wraps GVolumeIface
// 
// see also https://docs.gtk.org/gio/struct.VolumeIface.html
//
type VolumeIface struct {
	*volumeIface
}

// volumeIface is the struct that's finalized
type volumeIface struct {
	native *C.GVolumeIface
}

// UnsafeVolumeIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VolumeIface) instance() *C.GVolumeIface {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVolumeIfaceFromGlibBorrow is used to convert raw C.GVolumeIface pointers to go. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibBorrow(p unsafe.Pointer) *VolumeIface {
	if p == nil {
		return nil
	}
	return &VolumeIface{&volumeIface{(*C.GVolumeIface)(p)}}
}

// UnsafeVolumeIfaceFromGlibNone is used to convert raw C.GVolumeIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibNone(p unsafe.Pointer) *VolumeIface {
	wrapped := UnsafeVolumeIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to VolumeIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeVolumeIfaceFromGlibFull is used to convert raw C.GVolumeIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibFull(p unsafe.Pointer) *VolumeIface {
	wrapped := UnsafeVolumeIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.volumeIface,
		func (intern *volumeIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeVolumeIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VolumeIface] is expected to work anymore.
func UnsafeVolumeIfaceFree(v *VolumeIface) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVolumeIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVolumeIfaceToGlibNone(v *VolumeIface) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVolumeIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVolumeIfaceToGlibFull(v *VolumeIface) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.volumeIface, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VolumeIface is invalid from here on
	return _p
}

// VolumeMonitorClass wraps GVolumeMonitorClass
// 
// see also https://docs.gtk.org/gio/struct.VolumeMonitorClass.html
// 
// VolumeMonitorClass is the type struct for [VolumeMonitor]
type VolumeMonitorClass struct {
	*volumeMonitorClass
}

// volumeMonitorClass is the struct that's finalized
type volumeMonitorClass struct {
	native *C.GVolumeMonitorClass
}

// UnsafeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VolumeMonitorClass) instance() *C.GVolumeMonitorClass {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVolumeMonitorClassFromGlibBorrow is used to convert raw C.GVolumeMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeVolumeMonitorClassFromGlibBorrow(p unsafe.Pointer) *VolumeMonitorClass {
	if p == nil {
		return nil
	}
	return &VolumeMonitorClass{&volumeMonitorClass{(*C.GVolumeMonitorClass)(p)}}
}

// UnsafeVolumeMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VolumeMonitorClass] is expected to work anymore.
func UnsafeVolumeMonitorClassFree(v *VolumeMonitorClass) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVolumeMonitorClassToGlibNone(v *VolumeMonitorClass) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (v *VolumeMonitorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeVolumeMonitorClassToGlibNone(v))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *VolumeMonitorClass) {}, v)
	return parent
}

// ZlibCompressorClass wraps GZlibCompressorClass
// 
// see also https://docs.gtk.org/gio/struct.ZlibCompressorClass.html
type ZlibCompressorClass struct {
	*zlibCompressorClass
}

// zlibCompressorClass is the struct that's finalized
type zlibCompressorClass struct {
	native *C.GZlibCompressorClass
}

// UnsafeZlibCompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (z *ZlibCompressorClass) instance() *C.GZlibCompressorClass {
	if z == nil {
		return nil
	}
	return z.native
}

// UnsafeZlibCompressorClassFromGlibBorrow is used to convert raw C.GZlibCompressorClass pointers to go. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibBorrow(p unsafe.Pointer) *ZlibCompressorClass {
	if p == nil {
		return nil
	}
	return &ZlibCompressorClass{&zlibCompressorClass{(*C.GZlibCompressorClass)(p)}}
}

// UnsafeZlibCompressorClassFromGlibNone is used to convert raw C.GZlibCompressorClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibNone(p unsafe.Pointer) *ZlibCompressorClass {
	wrapped := UnsafeZlibCompressorClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ZlibCompressorClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeZlibCompressorClassFromGlibFull is used to convert raw C.GZlibCompressorClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibFull(p unsafe.Pointer) *ZlibCompressorClass {
	wrapped := UnsafeZlibCompressorClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.zlibCompressorClass,
		func (intern *zlibCompressorClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeZlibCompressorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ZlibCompressorClass] is expected to work anymore.
func UnsafeZlibCompressorClassFree(z *ZlibCompressorClass) {
	C.free(unsafe.Pointer(z.native))
}

// UnsafeZlibCompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeZlibCompressorClassToGlibNone(z *ZlibCompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	return unsafe.Pointer(z.native)
}

// UnsafeZlibCompressorClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeZlibCompressorClassToGlibFull(z *ZlibCompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	runtime.SetFinalizer(z.zlibCompressorClass, nil)
	_p := unsafe.Pointer(z.native)
	z.native = nil // ZlibCompressorClass is invalid from here on
	return _p
}

// ZlibDecompressorClass wraps GZlibDecompressorClass
// 
// see also https://docs.gtk.org/gio/struct.ZlibDecompressorClass.html
// 
// ZlibDecompressorClass is the type struct for [ZlibDecompressor]
type ZlibDecompressorClass struct {
	*zlibDecompressorClass
}

// zlibDecompressorClass is the struct that's finalized
type zlibDecompressorClass struct {
	native *C.GZlibDecompressorClass
}

// UnsafeZlibDecompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (z *ZlibDecompressorClass) instance() *C.GZlibDecompressorClass {
	if z == nil {
		return nil
	}
	return z.native
}

// UnsafeZlibDecompressorClassFromGlibBorrow is used to convert raw C.GZlibDecompressorClass pointers to go. This is used by the bindings internally.
func UnsafeZlibDecompressorClassFromGlibBorrow(p unsafe.Pointer) *ZlibDecompressorClass {
	if p == nil {
		return nil
	}
	return &ZlibDecompressorClass{&zlibDecompressorClass{(*C.GZlibDecompressorClass)(p)}}
}

// UnsafeZlibDecompressorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ZlibDecompressorClass] is expected to work anymore.
func UnsafeZlibDecompressorClassFree(z *ZlibDecompressorClass) {
	C.free(unsafe.Pointer(z.native))
}

// UnsafeZlibDecompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeZlibDecompressorClassToGlibNone(z *ZlibDecompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	return unsafe.Pointer(z.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (z *ZlibDecompressorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeZlibDecompressorClassToGlibNone(z))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ZlibDecompressorClass) {}, z)
	return parent
}

