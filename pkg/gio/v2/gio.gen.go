// Code generated by girgen for Gio-2. DO NOT EDIT.

package gio

import (
	"fmt"
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/core/classdata"
	"github.com/go-gst/go-glib/pkg/core/userdata"
	"github.com/go-gst/go-glib/pkg/glib/v2"
	"github.com/go-gst/go-glib/pkg/gobject/v2"
)

// #cgo pkg-config: gio-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gio.h>
// extern GFile* _goglib_gio2_VfsFileLookupFunc(GVfs*, const char*, gpointer);
// extern gboolean _goglib_glib2_SourceFunc(gpointer);
// extern void _goglib_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void destroyUserdata(gpointer);
// extern void _goglib_gio2_AppLaunchContext_launch_failed(GAppLaunchContext*, const char*);
// void _goglib_gio2_AppLaunchContext_virtual_launch_failed(void* fnptr, GAppLaunchContext* carg0, const char* carg1) {
// 	return ((void (*) (GAppLaunchContext*, const char*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Application_activate(GApplication*);
// extern void _goglib_gio2_Application_add_platform_data(GApplication*, GVariantBuilder*);
// extern int _goglib_gio2_Application_command_line(GApplication*, GApplicationCommandLine*);
// extern gint _goglib_gio2_Application_handle_local_options(GApplication*, GVariantDict*);
// extern gboolean _goglib_gio2_Application_name_lost(GApplication*);
// extern void _goglib_gio2_Application_open(GApplication*, GFile**, gint, const gchar*);
// extern void _goglib_gio2_Application_quit_mainloop(GApplication*);
// extern void _goglib_gio2_Application_run_mainloop(GApplication*);
// extern void _goglib_gio2_Application_shutdown(GApplication*);
// extern void _goglib_gio2_Application_startup(GApplication*);
// void _goglib_gio2_Application_virtual_activate(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_add_platform_data(void* fnptr, GApplication* carg0, GVariantBuilder* carg1) {
// 	return ((void (*) (GApplication*, GVariantBuilder*))(fnptr))(carg0, carg1);
// }
// int _goglib_gio2_Application_virtual_command_line(void* fnptr, GApplication* carg0, GApplicationCommandLine* carg1) {
// 	return ((int (*) (GApplication*, GApplicationCommandLine*))(fnptr))(carg0, carg1);
// }
// gint _goglib_gio2_Application_virtual_handle_local_options(void* fnptr, GApplication* carg0, GVariantDict* carg1) {
// 	return ((gint (*) (GApplication*, GVariantDict*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Application_virtual_name_lost(void* fnptr, GApplication* carg0) {
// 	return ((gboolean (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_open(void* fnptr, GApplication* carg0, GFile** carg1, gint carg2, const gchar* carg3) {
// 	return ((void (*) (GApplication*, GFile**, gint, const gchar*))(fnptr))(carg0, carg1, carg2, carg3);
// }
// void _goglib_gio2_Application_virtual_quit_mainloop(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_run_mainloop(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_shutdown(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// void _goglib_gio2_Application_virtual_startup(void* fnptr, GApplication* carg0) {
// 	return ((void (*) (GApplication*))(fnptr))(carg0);
// }
// extern void _goglib_gio2_ApplicationCommandLine_done(GApplicationCommandLine*);
// extern GInputStream* _goglib_gio2_ApplicationCommandLine_get_stdin(GApplicationCommandLine*);
// extern void _goglib_gio2_ApplicationCommandLine_print_literal(GApplicationCommandLine*, const gchar*);
// extern void _goglib_gio2_ApplicationCommandLine_printerr_literal(GApplicationCommandLine*, const gchar*);
// void _goglib_gio2_ApplicationCommandLine_virtual_done(void* fnptr, GApplicationCommandLine* carg0) {
// 	return ((void (*) (GApplicationCommandLine*))(fnptr))(carg0);
// }
// GInputStream* _goglib_gio2_ApplicationCommandLine_virtual_get_stdin(void* fnptr, GApplicationCommandLine* carg0) {
// 	return ((GInputStream* (*) (GApplicationCommandLine*))(fnptr))(carg0);
// }
// void _goglib_gio2_ApplicationCommandLine_virtual_print_literal(void* fnptr, GApplicationCommandLine* carg0, const gchar* carg1) {
// 	return ((void (*) (GApplicationCommandLine*, const gchar*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_ApplicationCommandLine_virtual_printerr_literal(void* fnptr, GApplicationCommandLine* carg0, const gchar* carg1) {
// 	return ((void (*) (GApplicationCommandLine*, const gchar*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Cancellable_cancelled(GCancellable*);
// void _goglib_gio2_Cancellable_virtual_cancelled(void* fnptr, GCancellable* carg0) {
// 	return ((void (*) (GCancellable*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_FileEnumerator_close_finish(GFileEnumerator*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileEnumerator_close_fn(GFileEnumerator*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileEnumerator_next_file(GFileEnumerator*, GCancellable*, GError*);
// extern GList* _goglib_gio2_FileEnumerator_next_files_finish(GFileEnumerator*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_FileEnumerator_virtual_close_finish(void* fnptr, GFileEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileEnumerator_virtual_close_fn(void* fnptr, GFileEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GFileEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GFileInfo* _goglib_gio2_FileEnumerator_virtual_next_file(void* fnptr, GFileEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_FileEnumerator_virtual_next_files_finish(void* fnptr, GFileEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GFileEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gboolean _goglib_gio2_FileMonitor_cancel(GFileMonitor*);
// extern void _goglib_gio2_FileMonitor_changed(GFileMonitor*, GFile*, GFile*, GFileMonitorEvent);
// gboolean _goglib_gio2_FileMonitor_virtual_cancel(void* fnptr, GFileMonitor* carg0) {
// 	return ((gboolean (*) (GFileMonitor*))(fnptr))(carg0);
// }
// void _goglib_gio2_FileMonitor_virtual_changed(void* fnptr, GFileMonitor* carg0, GFile* carg1, GFile* carg2, GFileMonitorEvent carg3) {
// 	return ((void (*) (GFileMonitor*, GFile*, GFile*, GFileMonitorEvent))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern void _goglib_gio2_FilenameCompleter_got_completion_data(GFilenameCompleter*);
// void _goglib_gio2_FilenameCompleter_virtual_got_completion_data(void* fnptr, GFilenameCompleter* carg0) {
// 	return ((void (*) (GFilenameCompleter*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_IOStream_close_finish(GIOStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_IOStream_close_fn(GIOStream*, GCancellable*, GError*);
// extern GInputStream* _goglib_gio2_IOStream_get_input_stream(GIOStream*);
// extern GOutputStream* _goglib_gio2_IOStream_get_output_stream(GIOStream*);
// gboolean _goglib_gio2_IOStream_virtual_close_finish(void* fnptr, GIOStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GIOStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_IOStream_virtual_close_fn(void* fnptr, GIOStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GIOStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GInputStream* _goglib_gio2_IOStream_virtual_get_input_stream(void* fnptr, GIOStream* carg0) {
// 	return ((GInputStream* (*) (GIOStream*))(fnptr))(carg0);
// }
// GOutputStream* _goglib_gio2_IOStream_virtual_get_output_stream(void* fnptr, GIOStream* carg0) {
// 	return ((GOutputStream* (*) (GIOStream*))(fnptr))(carg0);
// }
// extern gchar* _goglib_gio2_InetAddress_to_string(GInetAddress*);
// gchar* _goglib_gio2_InetAddress_virtual_to_string(void* fnptr, GInetAddress* carg0) {
// 	return ((gchar* (*) (GInetAddress*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_InputStream_close_finish(GInputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_InputStream_close_fn(GInputStream*, GCancellable*, GError*);
// extern gssize _goglib_gio2_InputStream_read_finish(GInputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_InputStream_skip(GInputStream*, gsize, GCancellable*, GError*);
// extern gssize _goglib_gio2_InputStream_skip_finish(GInputStream*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_InputStream_virtual_close_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_InputStream_virtual_close_fn(void* fnptr, GInputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GInputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_read_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_skip(void* fnptr, GInputStream* carg0, gsize carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, gsize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gssize _goglib_gio2_InputStream_virtual_skip_finish(void* fnptr, GInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gboolean _goglib_gio2_MenuLinkIter_get_next(GMenuLinkIter*, const gchar*, GMenuModel*);
// gboolean _goglib_gio2_MenuLinkIter_virtual_get_next(void* fnptr, GMenuLinkIter* carg0, const gchar** carg1, GMenuModel** carg2) {
// 	return ((gboolean (*) (GMenuLinkIter*, const gchar**, GMenuModel**))(fnptr))(carg0, carg1, carg2);
// }
// extern GMenuModel* _goglib_gio2_MenuModel_get_item_link(GMenuModel*, gint, const gchar*);
// extern gint _goglib_gio2_MenuModel_get_n_items(GMenuModel*);
// extern gboolean _goglib_gio2_MenuModel_is_mutable(GMenuModel*);
// extern GMenuAttributeIter* _goglib_gio2_MenuModel_iterate_item_attributes(GMenuModel*, gint);
// extern GMenuLinkIter* _goglib_gio2_MenuModel_iterate_item_links(GMenuModel*, gint);
// GMenuModel* _goglib_gio2_MenuModel_virtual_get_item_link(void* fnptr, GMenuModel* carg0, gint carg1, const gchar* carg2) {
// 	return ((GMenuModel* (*) (GMenuModel*, gint, const gchar*))(fnptr))(carg0, carg1, carg2);
// }
// gint _goglib_gio2_MenuModel_virtual_get_n_items(void* fnptr, GMenuModel* carg0) {
// 	return ((gint (*) (GMenuModel*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_MenuModel_virtual_is_mutable(void* fnptr, GMenuModel* carg0) {
// 	return ((gboolean (*) (GMenuModel*))(fnptr))(carg0);
// }
// GMenuAttributeIter* _goglib_gio2_MenuModel_virtual_iterate_item_attributes(void* fnptr, GMenuModel* carg0, gint carg1) {
// 	return ((GMenuAttributeIter* (*) (GMenuModel*, gint))(fnptr))(carg0, carg1);
// }
// GMenuLinkIter* _goglib_gio2_MenuModel_virtual_iterate_item_links(void* fnptr, GMenuModel* carg0, gint carg1) {
// 	return ((GMenuLinkIter* (*) (GMenuModel*, gint))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_MountOperation_aborted(GMountOperation*);
// extern void _goglib_gio2_MountOperation_ask_password(GMountOperation*, const char*, const char*, const char*, GAskPasswordFlags);
// extern void _goglib_gio2_MountOperation_ask_question(GMountOperation*, const char*, const char**);
// extern void _goglib_gio2_MountOperation_reply(GMountOperation*, GMountOperationResult);
// extern void _goglib_gio2_MountOperation_show_unmount_progress(GMountOperation*, const gchar*, gint64, gint64);
// void _goglib_gio2_MountOperation_virtual_aborted(void* fnptr, GMountOperation* carg0) {
// 	return ((void (*) (GMountOperation*))(fnptr))(carg0);
// }
// void _goglib_gio2_MountOperation_virtual_ask_password(void* fnptr, GMountOperation* carg0, const char* carg1, const char* carg2, const char* carg3, GAskPasswordFlags carg4) {
// 	return ((void (*) (GMountOperation*, const char*, const char*, const char*, GAskPasswordFlags))(fnptr))(carg0, carg1, carg2, carg3, carg4);
// }
// void _goglib_gio2_MountOperation_virtual_ask_question(void* fnptr, GMountOperation* carg0, const char* carg1, const char** carg2) {
// 	return ((void (*) (GMountOperation*, const char*, const char**))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_MountOperation_virtual_reply(void* fnptr, GMountOperation* carg0, GMountOperationResult carg1) {
// 	return ((void (*) (GMountOperation*, GMountOperationResult))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_MountOperation_virtual_show_unmount_progress(void* fnptr, GMountOperation* carg0, const gchar* carg1, gint64 carg2, gint64 carg3) {
// 	return ((void (*) (GMountOperation*, const gchar*, gint64, gint64))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern gboolean _goglib_gio2_OutputStream_close_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_OutputStream_close_fn(GOutputStream*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_flush(GOutputStream*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_flush_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_splice(GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError*);
// extern gssize _goglib_gio2_OutputStream_splice_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_write_finish(GOutputStream*, GAsyncResult*, GError*);
// extern gssize _goglib_gio2_OutputStream_write_fn(GOutputStream*, void*, gsize, GCancellable*, GError*);
// extern gboolean _goglib_gio2_OutputStream_writev_finish(GOutputStream*, GAsyncResult*, gsize, GError*);
// extern gboolean _goglib_gio2_OutputStream_writev_fn(GOutputStream*, const GOutputVector*, gsize, gsize, GCancellable*, GError*);
// gboolean _goglib_gio2_OutputStream_virtual_close_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_close_fn(void* fnptr, GOutputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_flush(void* fnptr, GOutputStream* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_flush_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_splice(void* fnptr, GOutputStream* carg0, GInputStream* carg1, GOutputStreamSpliceFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GInputStream*, GOutputStreamSpliceFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_splice_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_write_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gssize _goglib_gio2_OutputStream_virtual_write_fn(void* fnptr, GOutputStream* carg0, void* carg1, gsize carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gssize (*) (GOutputStream*, void*, gsize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_writev_finish(void* fnptr, GOutputStream* carg0, GAsyncResult* carg1, gsize* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, GAsyncResult*, gsize*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gboolean _goglib_gio2_OutputStream_virtual_writev_fn(void* fnptr, GOutputStream* carg0, const GOutputVector* carg1, gsize carg2, gsize* carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((gboolean (*) (GOutputStream*, const GOutputVector*, gsize, gsize*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// extern gboolean _goglib_gio2_Permission_acquire(GPermission*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_Permission_acquire_finish(GPermission*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_Permission_release(GPermission*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_Permission_release_finish(GPermission*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_Permission_virtual_acquire(void* fnptr, GPermission* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_acquire_finish(void* fnptr, GPermission* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_release(void* fnptr, GPermission* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_Permission_virtual_release_finish(void* fnptr, GPermission* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GPermission*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gchar* _goglib_gio2_Resolver_lookup_by_address(GResolver*, GInetAddress*, GCancellable*, GError*);
// extern gchar* _goglib_gio2_Resolver_lookup_by_address_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name(GResolver*, const gchar*, GCancellable*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_with_flags(GResolver*, const gchar*, GResolverNameLookupFlags, GCancellable*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_by_name_with_flags_finish(GResolver*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_Resolver_lookup_service_finish(GResolver*, GAsyncResult*, GError*);
// extern void _goglib_gio2_Resolver_reload(GResolver*);
// gchar* _goglib_gio2_Resolver_virtual_lookup_by_address(void* fnptr, GResolver* carg0, GInetAddress* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gchar* (*) (GResolver*, GInetAddress*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gchar* _goglib_gio2_Resolver_virtual_lookup_by_address_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gchar* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name(void* fnptr, GResolver* carg0, const gchar* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, const gchar*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_with_flags(void* fnptr, GResolver* carg0, const gchar* carg1, GResolverNameLookupFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, const gchar*, GResolverNameLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_Resolver_virtual_lookup_service_finish(void* fnptr, GResolver* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GResolver*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// void _goglib_gio2_Resolver_virtual_reload(void* fnptr, GResolver* carg0) {
// 	return ((void (*) (GResolver*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_Settings_change_event(GSettings*, const GQuark*, gint);
// extern void _goglib_gio2_Settings_changed(GSettings*, const gchar*);
// extern gboolean _goglib_gio2_Settings_writable_change_event(GSettings*, GQuark);
// extern void _goglib_gio2_Settings_writable_changed(GSettings*, const gchar*);
// gboolean _goglib_gio2_Settings_virtual_change_event(void* fnptr, GSettings* carg0, const GQuark* carg1, gint carg2) {
// 	return ((gboolean (*) (GSettings*, const GQuark*, gint))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_Settings_virtual_changed(void* fnptr, GSettings* carg0, const gchar* carg1) {
// 	return ((void (*) (GSettings*, const gchar*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Settings_virtual_writable_change_event(void* fnptr, GSettings* carg0, GQuark carg1) {
// 	return ((gboolean (*) (GSettings*, GQuark))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_Settings_virtual_writable_changed(void* fnptr, GSettings* carg0, const gchar* carg1) {
// 	return ((void (*) (GSettings*, const gchar*))(fnptr))(carg0, carg1);
// }
// extern GSocketFamily _goglib_gio2_SocketAddress_get_family(GSocketAddress*);
// extern gssize _goglib_gio2_SocketAddress_get_native_size(GSocketAddress*);
// GSocketFamily _goglib_gio2_SocketAddress_virtual_get_family(void* fnptr, GSocketAddress* carg0) {
// 	return ((GSocketFamily (*) (GSocketAddress*))(fnptr))(carg0);
// }
// gssize _goglib_gio2_SocketAddress_virtual_get_native_size(void* fnptr, GSocketAddress* carg0) {
// 	return ((gssize (*) (GSocketAddress*))(fnptr))(carg0);
// }
// extern GSocketAddress* _goglib_gio2_SocketAddressEnumerator_next(GSocketAddressEnumerator*, GCancellable*, GError*);
// extern GSocketAddress* _goglib_gio2_SocketAddressEnumerator_next_finish(GSocketAddressEnumerator*, GAsyncResult*, GError*);
// GSocketAddress* _goglib_gio2_SocketAddressEnumerator_virtual_next(void* fnptr, GSocketAddressEnumerator* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((GSocketAddress* (*) (GSocketAddressEnumerator*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GSocketAddress* _goglib_gio2_SocketAddressEnumerator_virtual_next_finish(void* fnptr, GSocketAddressEnumerator* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GSocketAddress* (*) (GSocketAddressEnumerator*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern void _goglib_gio2_SocketClient_event(GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*);
// void _goglib_gio2_SocketClient_virtual_event(void* fnptr, GSocketClient* carg0, GSocketClientEvent carg1, GSocketConnectable* carg2, GIOStream* carg3) {
// 	return ((void (*) (GSocketClient*, GSocketClientEvent, GSocketConnectable*, GIOStream*))(fnptr))(carg0, carg1, carg2, carg3);
// }
// extern int _goglib_gio2_SocketControlMessage_get_level(GSocketControlMessage*);
// extern gsize _goglib_gio2_SocketControlMessage_get_size(GSocketControlMessage*);
// extern int _goglib_gio2_SocketControlMessage_get_type(GSocketControlMessage*);
// int _goglib_gio2_SocketControlMessage_virtual_get_level(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((int (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// gsize _goglib_gio2_SocketControlMessage_virtual_get_size(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((gsize (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// int _goglib_gio2_SocketControlMessage_virtual_get_type(void* fnptr, GSocketControlMessage* carg0) {
// 	return ((int (*) (GSocketControlMessage*))(fnptr))(carg0);
// }
// extern void _goglib_gio2_SocketListener_changed(GSocketListener*);
// extern void _goglib_gio2_SocketListener_event(GSocketListener*, GSocketListenerEvent, GSocket*);
// void _goglib_gio2_SocketListener_virtual_changed(void* fnptr, GSocketListener* carg0) {
// 	return ((void (*) (GSocketListener*))(fnptr))(carg0);
// }
// void _goglib_gio2_SocketListener_virtual_event(void* fnptr, GSocketListener* carg0, GSocketListenerEvent carg1, GSocket* carg2) {
// 	return ((void (*) (GSocketListener*, GSocketListenerEvent, GSocket*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_SocketService_incoming(GSocketService*, GSocketConnection*, GObject*);
// gboolean _goglib_gio2_SocketService_virtual_incoming(void* fnptr, GSocketService* carg0, GSocketConnection* carg1, GObject* carg2) {
// 	return ((gboolean (*) (GSocketService*, GSocketConnection*, GObject*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_ThreadedSocketService_run(GThreadedSocketService*, GSocketConnection*, GObject*);
// gboolean _goglib_gio2_ThreadedSocketService_virtual_run(void* fnptr, GThreadedSocketService* carg0, GSocketConnection* carg1, GObject* carg2) {
// 	return ((gboolean (*) (GThreadedSocketService*, GSocketConnection*, GObject*))(fnptr))(carg0, carg1, carg2);
// }
// extern GTlsCertificateFlags _goglib_gio2_TlsCertificate_verify(GTlsCertificate*, GSocketConnectable*, GTlsCertificate*);
// GTlsCertificateFlags _goglib_gio2_TlsCertificate_virtual_verify(void* fnptr, GTlsCertificate* carg0, GSocketConnectable* carg1, GTlsCertificate* carg2) {
// 	return ((GTlsCertificateFlags (*) (GTlsCertificate*, GSocketConnectable*, GTlsCertificate*))(fnptr))(carg0, carg1, carg2);
// }
// extern gboolean _goglib_gio2_TlsConnection_accept_certificate(GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags);
// extern const gchar* _goglib_gio2_TlsConnection_get_negotiated_protocol(GTlsConnection*);
// extern gboolean _goglib_gio2_TlsConnection_handshake(GTlsConnection*, GCancellable*, GError*);
// extern gboolean _goglib_gio2_TlsConnection_handshake_finish(GTlsConnection*, GAsyncResult*, GError*);
// gboolean _goglib_gio2_TlsConnection_virtual_accept_certificate(void* fnptr, GTlsConnection* carg0, GTlsCertificate* carg1, GTlsCertificateFlags carg2) {
// 	return ((gboolean (*) (GTlsConnection*, GTlsCertificate*, GTlsCertificateFlags))(fnptr))(carg0, carg1, carg2);
// }
// const gchar* _goglib_gio2_TlsConnection_virtual_get_negotiated_protocol(void* fnptr, GTlsConnection* carg0) {
// 	return ((const gchar* (*) (GTlsConnection*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_TlsConnection_virtual_handshake(void* fnptr, GTlsConnection* carg0, GCancellable* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GTlsConnection*, GCancellable*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_TlsConnection_virtual_handshake_finish(void* fnptr, GTlsConnection* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gboolean (*) (GTlsConnection*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern gchar* _goglib_gio2_TlsDatabase_create_certificate_handle(GTlsDatabase*, GTlsCertificate*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_for_handle(GTlsDatabase*, const gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_issuer(GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError*);
// extern GTlsCertificate* _goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GList* _goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish(GTlsDatabase*, GAsyncResult*, GError*);
// extern GTlsCertificateFlags _goglib_gio2_TlsDatabase_verify_chain(GTlsDatabase*, GTlsCertificate*, const gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError*);
// extern GTlsCertificateFlags _goglib_gio2_TlsDatabase_verify_chain_finish(GTlsDatabase*, GAsyncResult*, GError*);
// gchar* _goglib_gio2_TlsDatabase_virtual_create_certificate_handle(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1) {
// 	return ((gchar* (*) (GTlsDatabase*, GTlsCertificate*))(fnptr))(carg0, carg1);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle(void* fnptr, GTlsDatabase* carg0, const gchar* carg1, GTlsInteraction* carg2, GTlsDatabaseLookupFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, const gchar*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1, GTlsInteraction* carg2, GTlsDatabaseLookupFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GTlsCertificate*, GTlsInteraction*, GTlsDatabaseLookupFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GTlsCertificate* _goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificate* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GList* _goglib_gio2_TlsDatabase_virtual_lookup_certificates_issued_by_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GList* (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsCertificateFlags _goglib_gio2_TlsDatabase_virtual_verify_chain(void* fnptr, GTlsDatabase* carg0, GTlsCertificate* carg1, const gchar* carg2, GSocketConnectable* carg3, GTlsInteraction* carg4, GTlsDatabaseVerifyFlags carg5, GCancellable* carg6, GError** _cerr) {
// 	return ((GTlsCertificateFlags (*) (GTlsDatabase*, GTlsCertificate*, const gchar*, GSocketConnectable*, GTlsInteraction*, GTlsDatabaseVerifyFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, carg5, carg6, _cerr);
// }
// GTlsCertificateFlags _goglib_gio2_TlsDatabase_virtual_verify_chain_finish(void* fnptr, GTlsDatabase* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsCertificateFlags (*) (GTlsDatabase*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_ask_password(GTlsInteraction*, GTlsPassword*, GCancellable*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_ask_password_finish(GTlsInteraction*, GAsyncResult*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_request_certificate(GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError*);
// extern GTlsInteractionResult _goglib_gio2_TlsInteraction_request_certificate_finish(GTlsInteraction*, GAsyncResult*, GError*);
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_ask_password(void* fnptr, GTlsInteraction* carg0, GTlsPassword* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GTlsPassword*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_ask_password_finish(void* fnptr, GTlsInteraction* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_request_certificate(void* fnptr, GTlsInteraction* carg0, GTlsConnection* carg1, GTlsCertificateRequestFlags carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GTlsConnection*, GTlsCertificateRequestFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// GTlsInteractionResult _goglib_gio2_TlsInteraction_virtual_request_certificate_finish(void* fnptr, GTlsInteraction* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GTlsInteractionResult (*) (GTlsInteraction*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// extern const gchar* _goglib_gio2_TlsPassword_get_default_warning(GTlsPassword*);
// extern const guchar* _goglib_gio2_TlsPassword_get_value(GTlsPassword*, gsize);
// const gchar* _goglib_gio2_TlsPassword_virtual_get_default_warning(void* fnptr, GTlsPassword* carg0) {
// 	return ((const gchar* (*) (GTlsPassword*))(fnptr))(carg0);
// }
// const guchar* _goglib_gio2_TlsPassword_virtual_get_value(void* fnptr, GTlsPassword* carg0, gsize* carg1) {
// 	return ((const guchar* (*) (GTlsPassword*, gsize*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_Vfs_add_writable_namespaces(GVfs*, GFileAttributeInfoList*);
// extern GFile* _goglib_gio2_Vfs_get_file_for_path(GVfs*, const char*);
// extern GFile* _goglib_gio2_Vfs_get_file_for_uri(GVfs*, const char*);
// extern const gchar* const* _goglib_gio2_Vfs_get_supported_uri_schemes(GVfs*);
// extern gboolean _goglib_gio2_Vfs_is_active(GVfs*);
// extern void _goglib_gio2_Vfs_local_file_moved(GVfs*, const char*, const char*);
// extern void _goglib_gio2_Vfs_local_file_removed(GVfs*, const char*);
// extern gboolean _goglib_gio2_Vfs_local_file_set_attributes(GVfs*, const char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError*);
// extern GFile* _goglib_gio2_Vfs_parse_name(GVfs*, const char*);
// void _goglib_gio2_Vfs_virtual_add_writable_namespaces(void* fnptr, GVfs* carg0, GFileAttributeInfoList* carg1) {
// 	return ((void (*) (GVfs*, GFileAttributeInfoList*))(fnptr))(carg0, carg1);
// }
// GFile* _goglib_gio2_Vfs_virtual_get_file_for_path(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// GFile* _goglib_gio2_Vfs_virtual_get_file_for_uri(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// const gchar* const* _goglib_gio2_Vfs_virtual_get_supported_uri_schemes(void* fnptr, GVfs* carg0) {
// 	return ((const gchar* const* (*) (GVfs*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_Vfs_virtual_is_active(void* fnptr, GVfs* carg0) {
// 	return ((gboolean (*) (GVfs*))(fnptr))(carg0);
// }
// void _goglib_gio2_Vfs_virtual_local_file_moved(void* fnptr, GVfs* carg0, const char* carg1, const char* carg2) {
// 	return ((void (*) (GVfs*, const char*, const char*))(fnptr))(carg0, carg1, carg2);
// }
// void _goglib_gio2_Vfs_virtual_local_file_removed(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((void (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// gboolean _goglib_gio2_Vfs_virtual_local_file_set_attributes(void* fnptr, GVfs* carg0, const char* carg1, GFileInfo* carg2, GFileQueryInfoFlags carg3, GCancellable* carg4, GError** _cerr) {
// 	return ((gboolean (*) (GVfs*, const char*, GFileInfo*, GFileQueryInfoFlags, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, carg4, _cerr);
// }
// GFile* _goglib_gio2_Vfs_virtual_parse_name(void* fnptr, GVfs* carg0, const char* carg1) {
// 	return ((GFile* (*) (GVfs*, const char*))(fnptr))(carg0, carg1);
// }
// extern void _goglib_gio2_VolumeMonitor_drive_changed(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_connected(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_disconnected(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_eject_button(GVolumeMonitor*, GDrive*);
// extern void _goglib_gio2_VolumeMonitor_drive_stop_button(GVolumeMonitor*, GDrive*);
// extern GList* _goglib_gio2_VolumeMonitor_get_connected_drives(GVolumeMonitor*);
// extern GMount* _goglib_gio2_VolumeMonitor_get_mount_for_uuid(GVolumeMonitor*, const char*);
// extern GList* _goglib_gio2_VolumeMonitor_get_mounts(GVolumeMonitor*);
// extern GVolume* _goglib_gio2_VolumeMonitor_get_volume_for_uuid(GVolumeMonitor*, const char*);
// extern GList* _goglib_gio2_VolumeMonitor_get_volumes(GVolumeMonitor*);
// extern void _goglib_gio2_VolumeMonitor_mount_added(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_changed(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_pre_unmount(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_mount_removed(GVolumeMonitor*, GMount*);
// extern void _goglib_gio2_VolumeMonitor_volume_added(GVolumeMonitor*, GVolume*);
// extern void _goglib_gio2_VolumeMonitor_volume_changed(GVolumeMonitor*, GVolume*);
// extern void _goglib_gio2_VolumeMonitor_volume_removed(GVolumeMonitor*, GVolume*);
// void _goglib_gio2_VolumeMonitor_virtual_drive_changed(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_connected(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_disconnected(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_eject_button(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_drive_stop_button(void* fnptr, GVolumeMonitor* carg0, GDrive* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GDrive*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_connected_drives(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// GMount* _goglib_gio2_VolumeMonitor_virtual_get_mount_for_uuid(void* fnptr, GVolumeMonitor* carg0, const char* carg1) {
// 	return ((GMount* (*) (GVolumeMonitor*, const char*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_mounts(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// GVolume* _goglib_gio2_VolumeMonitor_virtual_get_volume_for_uuid(void* fnptr, GVolumeMonitor* carg0, const char* carg1) {
// 	return ((GVolume* (*) (GVolumeMonitor*, const char*))(fnptr))(carg0, carg1);
// }
// GList* _goglib_gio2_VolumeMonitor_virtual_get_volumes(void* fnptr, GVolumeMonitor* carg0) {
// 	return ((GList* (*) (GVolumeMonitor*))(fnptr))(carg0);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_added(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_changed(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_pre_unmount(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_mount_removed(void* fnptr, GVolumeMonitor* carg0, GMount* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GMount*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_added(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_changed(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// void _goglib_gio2_VolumeMonitor_virtual_volume_removed(void* fnptr, GVolumeMonitor* carg0, GVolume* carg1) {
// 	return ((void (*) (GVolumeMonitor*, GVolume*))(fnptr))(carg0, carg1);
// }
// extern gboolean _goglib_gio2_FileIOStream_can_seek(GFileIOStream*);
// extern gboolean _goglib_gio2_FileIOStream_can_truncate(GFileIOStream*);
// extern char* _goglib_gio2_FileIOStream_get_etag(GFileIOStream*);
// extern GFileInfo* _goglib_gio2_FileIOStream_query_info(GFileIOStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileIOStream_query_info_finish(GFileIOStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileIOStream_seek(GFileIOStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileIOStream_tell(GFileIOStream*);
// extern gboolean _goglib_gio2_FileIOStream_truncate_fn(GFileIOStream*, goffset, GCancellable*, GError*);
// gboolean _goglib_gio2_FileIOStream_virtual_can_seek(void* fnptr, GFileIOStream* carg0) {
// 	return ((gboolean (*) (GFileIOStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_can_truncate(void* fnptr, GFileIOStream* carg0) {
// 	return ((gboolean (*) (GFileIOStream*))(fnptr))(carg0);
// }
// char* _goglib_gio2_FileIOStream_virtual_get_etag(void* fnptr, GFileIOStream* carg0) {
// 	return ((char* (*) (GFileIOStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileIOStream_virtual_query_info(void* fnptr, GFileIOStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileIOStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileIOStream_virtual_query_info_finish(void* fnptr, GFileIOStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileIOStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_seek(void* fnptr, GFileIOStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileIOStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileIOStream_virtual_tell(void* fnptr, GFileIOStream* carg0) {
// 	return ((goffset (*) (GFileIOStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileIOStream_virtual_truncate_fn(void* fnptr, GFileIOStream* carg0, goffset carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GFileIOStream*, goffset, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// extern gboolean _goglib_gio2_FileInputStream_can_seek(GFileInputStream*);
// extern GFileInfo* _goglib_gio2_FileInputStream_query_info(GFileInputStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileInputStream_query_info_finish(GFileInputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileInputStream_seek(GFileInputStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileInputStream_tell(GFileInputStream*);
// gboolean _goglib_gio2_FileInputStream_virtual_can_seek(void* fnptr, GFileInputStream* carg0) {
// 	return ((gboolean (*) (GFileInputStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileInputStream_virtual_query_info(void* fnptr, GFileInputStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileInputStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileInputStream_virtual_query_info_finish(void* fnptr, GFileInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileInputStream_virtual_seek(void* fnptr, GFileInputStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileInputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileInputStream_virtual_tell(void* fnptr, GFileInputStream* carg0) {
// 	return ((goffset (*) (GFileInputStream*))(fnptr))(carg0);
// }
// extern gboolean _goglib_gio2_FileOutputStream_can_seek(GFileOutputStream*);
// extern gboolean _goglib_gio2_FileOutputStream_can_truncate(GFileOutputStream*);
// extern char* _goglib_gio2_FileOutputStream_get_etag(GFileOutputStream*);
// extern GFileInfo* _goglib_gio2_FileOutputStream_query_info(GFileOutputStream*, const char*, GCancellable*, GError*);
// extern GFileInfo* _goglib_gio2_FileOutputStream_query_info_finish(GFileOutputStream*, GAsyncResult*, GError*);
// extern gboolean _goglib_gio2_FileOutputStream_seek(GFileOutputStream*, goffset, GSeekType, GCancellable*, GError*);
// extern goffset _goglib_gio2_FileOutputStream_tell(GFileOutputStream*);
// extern gboolean _goglib_gio2_FileOutputStream_truncate_fn(GFileOutputStream*, goffset, GCancellable*, GError*);
// gboolean _goglib_gio2_FileOutputStream_virtual_can_seek(void* fnptr, GFileOutputStream* carg0) {
// 	return ((gboolean (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_can_truncate(void* fnptr, GFileOutputStream* carg0) {
// 	return ((gboolean (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// char* _goglib_gio2_FileOutputStream_virtual_get_etag(void* fnptr, GFileOutputStream* carg0) {
// 	return ((char* (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// GFileInfo* _goglib_gio2_FileOutputStream_virtual_query_info(void* fnptr, GFileOutputStream* carg0, const char* carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileOutputStream*, const char*, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// GFileInfo* _goglib_gio2_FileOutputStream_virtual_query_info_finish(void* fnptr, GFileOutputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((GFileInfo* (*) (GFileOutputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_seek(void* fnptr, GFileOutputStream* carg0, goffset carg1, GSeekType carg2, GCancellable* carg3, GError** _cerr) {
// 	return ((gboolean (*) (GFileOutputStream*, goffset, GSeekType, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, carg3, _cerr);
// }
// goffset _goglib_gio2_FileOutputStream_virtual_tell(void* fnptr, GFileOutputStream* carg0) {
// 	return ((goffset (*) (GFileOutputStream*))(fnptr))(carg0);
// }
// gboolean _goglib_gio2_FileOutputStream_virtual_truncate_fn(void* fnptr, GFileOutputStream* carg0, goffset carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gboolean (*) (GFileOutputStream*, goffset, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// extern gssize _goglib_gio2_BufferedInputStream_fill(GBufferedInputStream*, gssize, GCancellable*, GError*);
// extern gssize _goglib_gio2_BufferedInputStream_fill_finish(GBufferedInputStream*, GAsyncResult*, GError*);
// gssize _goglib_gio2_BufferedInputStream_virtual_fill(void* fnptr, GBufferedInputStream* carg0, gssize carg1, GCancellable* carg2, GError** _cerr) {
// 	return ((gssize (*) (GBufferedInputStream*, gssize, GCancellable*, GError**))(fnptr))(carg0, carg1, carg2, _cerr);
// }
// gssize _goglib_gio2_BufferedInputStream_virtual_fill_finish(void* fnptr, GBufferedInputStream* carg0, GAsyncResult* carg1, GError** _cerr) {
// 	return ((gssize (*) (GBufferedInputStream*, GAsyncResult*, GError**))(fnptr))(carg0, carg1, _cerr);
// }
import "C"

// GType values.
var (
	TypeBusType                    = gobject.Type(C.g_bus_type_get_type())
	TypeConverterResult            = gobject.Type(C.g_converter_result_get_type())
	TypeCredentialsType            = gobject.Type(C.g_credentials_type_get_type())
	TypeDataStreamByteOrder        = gobject.Type(C.g_data_stream_byte_order_get_type())
	TypeDataStreamNewlineType      = gobject.Type(C.g_data_stream_newline_type_get_type())
	TypeDriveStartStopType         = gobject.Type(C.g_drive_start_stop_type_get_type())
	TypeEmblemOrigin               = gobject.Type(C.g_emblem_origin_get_type())
	TypeFileAttributeStatus        = gobject.Type(C.g_file_attribute_status_get_type())
	TypeFileAttributeType          = gobject.Type(C.g_file_attribute_type_get_type())
	TypeFileMonitorEvent           = gobject.Type(C.g_file_monitor_event_get_type())
	TypeFileType                   = gobject.Type(C.g_file_type_get_type())
	TypeFilesystemPreviewType      = gobject.Type(C.g_filesystem_preview_type_get_type())
	TypeIOErrorEnum                = gobject.Type(C.g_io_error_enum_get_type())
	TypeIOModuleScopeFlags         = gobject.Type(C.g_io_module_scope_flags_get_type())
	TypeMemoryMonitorWarningLevel  = gobject.Type(C.g_memory_monitor_warning_level_get_type())
	TypeMountOperationResult       = gobject.Type(C.g_mount_operation_result_get_type())
	TypeNetworkConnectivity        = gobject.Type(C.g_network_connectivity_get_type())
	TypeNotificationPriority       = gobject.Type(C.g_notification_priority_get_type())
	TypePasswordSave               = gobject.Type(C.g_password_save_get_type())
	TypePollableReturn             = gobject.Type(C.g_pollable_return_get_type())
	TypeResolverError              = gobject.Type(C.g_resolver_error_get_type())
	TypeResolverRecordType         = gobject.Type(C.g_resolver_record_type_get_type())
	TypeResourceError              = gobject.Type(C.g_resource_error_get_type())
	TypeSocketClientEvent          = gobject.Type(C.g_socket_client_event_get_type())
	TypeSocketFamily               = gobject.Type(C.g_socket_family_get_type())
	TypeSocketListenerEvent        = gobject.Type(C.g_socket_listener_event_get_type())
	TypeSocketProtocol             = gobject.Type(C.g_socket_protocol_get_type())
	TypeSocketType                 = gobject.Type(C.g_socket_type_get_type())
	TypeTlsAuthenticationMode      = gobject.Type(C.g_tls_authentication_mode_get_type())
	TypeTlsCertificateRequestFlags = gobject.Type(C.g_tls_certificate_request_flags_get_type())
	TypeTlsChannelBindingError     = gobject.Type(C.g_tls_channel_binding_error_get_type())
	TypeTlsChannelBindingType      = gobject.Type(C.g_tls_channel_binding_type_get_type())
	TypeTlsDatabaseLookupFlags     = gobject.Type(C.g_tls_database_lookup_flags_get_type())
	TypeTlsError                   = gobject.Type(C.g_tls_error_get_type())
	TypeTlsInteractionResult       = gobject.Type(C.g_tls_interaction_result_get_type())
	TypeTlsProtocolVersion         = gobject.Type(C.g_tls_protocol_version_get_type())
	TypeTlsRehandshakeMode         = gobject.Type(C.g_tls_rehandshake_mode_get_type())
	TypeZlibCompressorFormat       = gobject.Type(C.g_zlib_compressor_format_get_type())
	TypeAppInfoCreateFlags         = gobject.Type(C.g_app_info_create_flags_get_type())
	TypeApplicationFlags           = gobject.Type(C.g_application_flags_get_type())
	TypeAskPasswordFlags           = gobject.Type(C.g_ask_password_flags_get_type())
	TypeBusNameOwnerFlags          = gobject.Type(C.g_bus_name_owner_flags_get_type())
	TypeBusNameWatcherFlags        = gobject.Type(C.g_bus_name_watcher_flags_get_type())
	TypeConverterFlags             = gobject.Type(C.g_converter_flags_get_type())
	TypeDriveStartFlags            = gobject.Type(C.g_drive_start_flags_get_type())
	TypeFileAttributeInfoFlags     = gobject.Type(C.g_file_attribute_info_flags_get_type())
	TypeFileCopyFlags              = gobject.Type(C.g_file_copy_flags_get_type())
	TypeFileCreateFlags            = gobject.Type(C.g_file_create_flags_get_type())
	TypeFileMeasureFlags           = gobject.Type(C.g_file_measure_flags_get_type())
	TypeFileMonitorFlags           = gobject.Type(C.g_file_monitor_flags_get_type())
	TypeFileQueryInfoFlags         = gobject.Type(C.g_file_query_info_flags_get_type())
	TypeIOStreamSpliceFlags        = gobject.Type(C.g_io_stream_splice_flags_get_type())
	TypeMountMountFlags            = gobject.Type(C.g_mount_mount_flags_get_type())
	TypeMountUnmountFlags          = gobject.Type(C.g_mount_unmount_flags_get_type())
	TypeOutputStreamSpliceFlags    = gobject.Type(C.g_output_stream_splice_flags_get_type())
	TypeResolverNameLookupFlags    = gobject.Type(C.g_resolver_name_lookup_flags_get_type())
	TypeResourceFlags              = gobject.Type(C.g_resource_flags_get_type())
	TypeResourceLookupFlags        = gobject.Type(C.g_resource_lookup_flags_get_type())
	TypeSettingsBindFlags          = gobject.Type(C.g_settings_bind_flags_get_type())
	TypeSocketMsgFlags             = gobject.Type(C.g_socket_msg_flags_get_type())
	TypeTlsCertificateFlags        = gobject.Type(C.g_tls_certificate_flags_get_type())
	TypeTlsDatabaseVerifyFlags     = gobject.Type(C.g_tls_database_verify_flags_get_type())
	TypeTlsPasswordFlags           = gobject.Type(C.g_tls_password_flags_get_type())
	TypeAction                     = gobject.Type(C.g_action_get_type())
	TypeActionGroup                = gobject.Type(C.g_action_group_get_type())
	TypeActionMap                  = gobject.Type(C.g_action_map_get_type())
	TypeAppInfo                    = gobject.Type(C.g_app_info_get_type())
	TypeAsyncInitable              = gobject.Type(C.g_async_initable_get_type())
	TypeAsyncResult                = gobject.Type(C.g_async_result_get_type())
	TypeConverter                  = gobject.Type(C.g_converter_get_type())
	TypeDatagramBased              = gobject.Type(C.g_datagram_based_get_type())
	TypeDrive                      = gobject.Type(C.g_drive_get_type())
	TypeDtlsConnection             = gobject.Type(C.g_dtls_connection_get_type())
	TypeDtlsServerConnection       = gobject.Type(C.g_dtls_server_connection_get_type())
	TypeFile                       = gobject.Type(C.g_file_get_type())
	TypeIcon                       = gobject.Type(C.g_icon_get_type())
	TypeInitable                   = gobject.Type(C.g_initable_get_type())
	TypeListModel                  = gobject.Type(C.g_list_model_get_type())
	TypeLoadableIcon               = gobject.Type(C.g_loadable_icon_get_type())
	TypeMemoryMonitor              = gobject.Type(C.g_memory_monitor_get_type())
	TypeMount                      = gobject.Type(C.g_mount_get_type())
	TypeNetworkMonitor             = gobject.Type(C.g_network_monitor_get_type())
	TypePollableInputStream        = gobject.Type(C.g_pollable_input_stream_get_type())
	TypePollableOutputStream       = gobject.Type(C.g_pollable_output_stream_get_type())
	TypePowerProfileMonitor        = gobject.Type(C.g_power_profile_monitor_get_type())
	TypeProxy                      = gobject.Type(C.g_proxy_get_type())
	TypeProxyResolver              = gobject.Type(C.g_proxy_resolver_get_type())
	TypeRemoteActionGroup          = gobject.Type(C.g_remote_action_group_get_type())
	TypeSeekable                   = gobject.Type(C.g_seekable_get_type())
	TypeSocketConnectable          = gobject.Type(C.g_socket_connectable_get_type())
	TypeTlsBackend                 = gobject.Type(C.g_tls_backend_get_type())
	TypeTlsClientConnection        = gobject.Type(C.g_tls_client_connection_get_type())
	TypeTlsFileDatabase            = gobject.Type(C.g_tls_file_database_get_type())
	TypeTlsServerConnection        = gobject.Type(C.g_tls_server_connection_get_type())
	TypeVolume                     = gobject.Type(C.g_volume_get_type())
	TypeDebugController            = gobject.Type(C.g_debug_controller_get_type())
	TypeDtlsClientConnection       = gobject.Type(C.g_dtls_client_connection_get_type())
	TypeAppInfoMonitor             = gobject.Type(C.g_app_info_monitor_get_type())
	TypeAppLaunchContext           = gobject.Type(C.g_app_launch_context_get_type())
	TypeApplication                = gobject.Type(C.g_application_get_type())
	TypeApplicationCommandLine     = gobject.Type(C.g_application_command_line_get_type())
	TypeBytesIcon                  = gobject.Type(C.g_bytes_icon_get_type())
	TypeCancellable                = gobject.Type(C.g_cancellable_get_type())
	TypeCharsetConverter           = gobject.Type(C.g_charset_converter_get_type())
	TypeCredentials                = gobject.Type(C.g_credentials_get_type())
	TypeEmblem                     = gobject.Type(C.g_emblem_get_type())
	TypeEmblemedIcon               = gobject.Type(C.g_emblemed_icon_get_type())
	TypeFileEnumerator             = gobject.Type(C.g_file_enumerator_get_type())
	TypeFileIcon                   = gobject.Type(C.g_file_icon_get_type())
	TypeFileInfo                   = gobject.Type(C.g_file_info_get_type())
	TypeFileMonitor                = gobject.Type(C.g_file_monitor_get_type())
	TypeFilenameCompleter          = gobject.Type(C.g_filename_completer_get_type())
	TypeIOStream                   = gobject.Type(C.g_io_stream_get_type())
	TypeInetAddress                = gobject.Type(C.g_inet_address_get_type())
	TypeInetAddressMask            = gobject.Type(C.g_inet_address_mask_get_type())
	TypeInputStream                = gobject.Type(C.g_input_stream_get_type())
	TypeListStore                  = gobject.Type(C.g_list_store_get_type())
	TypeMemoryInputStream          = gobject.Type(C.g_memory_input_stream_get_type())
	TypeMenuAttributeIter          = gobject.Type(C.g_menu_attribute_iter_get_type())
	TypeMenuItem                   = gobject.Type(C.g_menu_item_get_type())
	TypeMenuLinkIter               = gobject.Type(C.g_menu_link_iter_get_type())
	TypeMenuModel                  = gobject.Type(C.g_menu_model_get_type())
	TypeMountOperation             = gobject.Type(C.g_mount_operation_get_type())
	TypeNetworkAddress             = gobject.Type(C.g_network_address_get_type())
	TypeNetworkService             = gobject.Type(C.g_network_service_get_type())
	TypeNotification               = gobject.Type(C.g_notification_get_type())
	TypeOutputStream               = gobject.Type(C.g_output_stream_get_type())
	TypePermission                 = gobject.Type(C.g_permission_get_type())
	TypePropertyAction             = gobject.Type(C.g_property_action_get_type())
	TypeResolver                   = gobject.Type(C.g_resolver_get_type())
	TypeSettings                   = gobject.Type(C.g_settings_get_type())
	TypeSimpleAction               = gobject.Type(C.g_simple_action_get_type())
	TypeSimpleActionGroup          = gobject.Type(C.g_simple_action_group_get_type())
	TypeSimpleAsyncResult          = gobject.Type(C.g_simple_async_result_get_type())
	TypeSimpleIOStream             = gobject.Type(C.g_simple_io_stream_get_type())
	TypeSimplePermission           = gobject.Type(C.g_simple_permission_get_type())
	TypeSimpleProxyResolver        = gobject.Type(C.g_simple_proxy_resolver_get_type())
	TypeSocket                     = gobject.Type(C.g_socket_get_type())
	TypeSocketAddress              = gobject.Type(C.g_socket_address_get_type())
	TypeSocketAddressEnumerator    = gobject.Type(C.g_socket_address_enumerator_get_type())
	TypeSocketClient               = gobject.Type(C.g_socket_client_get_type())
	TypeSocketConnection           = gobject.Type(C.g_socket_connection_get_type())
	TypeSocketControlMessage       = gobject.Type(C.g_socket_control_message_get_type())
	TypeSocketListener             = gobject.Type(C.g_socket_listener_get_type())
	TypeSocketService              = gobject.Type(C.g_socket_service_get_type())
	TypeTask                       = gobject.Type(C.g_task_get_type())
	TypeTcpConnection              = gobject.Type(C.g_tcp_connection_get_type())
	TypeTcpWrapperConnection       = gobject.Type(C.g_tcp_wrapper_connection_get_type())
	TypeThemedIcon                 = gobject.Type(C.g_themed_icon_get_type())
	TypeThreadedSocketService      = gobject.Type(C.g_threaded_socket_service_get_type())
	TypeTlsCertificate             = gobject.Type(C.g_tls_certificate_get_type())
	TypeTlsConnection              = gobject.Type(C.g_tls_connection_get_type())
	TypeTlsDatabase                = gobject.Type(C.g_tls_database_get_type())
	TypeTlsInteraction             = gobject.Type(C.g_tls_interaction_get_type())
	TypeTlsPassword                = gobject.Type(C.g_tls_password_get_type())
	TypeVfs                        = gobject.Type(C.g_vfs_get_type())
	TypeVolumeMonitor              = gobject.Type(C.g_volume_monitor_get_type())
	TypeZlibDecompressor           = gobject.Type(C.g_zlib_decompressor_get_type())
	TypeFileIOStream               = gobject.Type(C.g_file_io_stream_get_type())
	TypeFileInputStream            = gobject.Type(C.g_file_input_stream_get_type())
	TypeFileOutputStream           = gobject.Type(C.g_file_output_stream_get_type())
	TypeFilterInputStream          = gobject.Type(C.g_filter_input_stream_get_type())
	TypeFilterOutputStream         = gobject.Type(C.g_filter_output_stream_get_type())
	TypeInetSocketAddress          = gobject.Type(C.g_inet_socket_address_get_type())
	TypeMemoryOutputStream         = gobject.Type(C.g_memory_output_stream_get_type())
	TypeMenu                       = gobject.Type(C.g_menu_get_type())
	TypeNativeSocketAddress        = gobject.Type(C.g_native_socket_address_get_type())
	TypeNativeVolumeMonitor        = gobject.Type(C.g_native_volume_monitor_get_type())
	TypeProxyAddress               = gobject.Type(C.g_proxy_address_get_type())
	TypeProxyAddressEnumerator     = gobject.Type(C.g_proxy_address_enumerator_get_type())
	TypeBufferedInputStream        = gobject.Type(C.g_buffered_input_stream_get_type())
	TypeBufferedOutputStream       = gobject.Type(C.g_buffered_output_stream_get_type())
	TypeConverterInputStream       = gobject.Type(C.g_converter_input_stream_get_type())
	TypeConverterOutputStream      = gobject.Type(C.g_converter_output_stream_get_type())
	TypeDataInputStream            = gobject.Type(C.g_data_input_stream_get_type())
	TypeDataOutputStream           = gobject.Type(C.g_data_output_stream_get_type())
	TypeFileAttributeInfoList      = gobject.Type(C.g_file_attribute_info_list_get_type())
	TypeFileAttributeMatcher       = gobject.Type(C.g_file_attribute_matcher_get_type())
	TypeSettingsSchema             = gobject.Type(C.g_settings_schema_get_type())
	TypeSettingsSchemaKey          = gobject.Type(C.g_settings_schema_key_get_type())
	TypeSettingsSchemaSource       = gobject.Type(C.g_settings_schema_source_get_type())
	TypeSrvTarget                  = gobject.Type(C.g_srv_target_get_type())
)

func init() {
	gobject.RegisterGValueMarshalers([]gobject.TypeMarshaler{
		gobject.TypeMarshaler{T: TypeBusType, F: marshalBusType},
		gobject.TypeMarshaler{T: TypeConverterResult, F: marshalConverterResult},
		gobject.TypeMarshaler{T: TypeCredentialsType, F: marshalCredentialsType},
		gobject.TypeMarshaler{T: TypeDataStreamByteOrder, F: marshalDataStreamByteOrder},
		gobject.TypeMarshaler{T: TypeDataStreamNewlineType, F: marshalDataStreamNewlineType},
		gobject.TypeMarshaler{T: TypeDriveStartStopType, F: marshalDriveStartStopType},
		gobject.TypeMarshaler{T: TypeEmblemOrigin, F: marshalEmblemOrigin},
		gobject.TypeMarshaler{T: TypeFileAttributeStatus, F: marshalFileAttributeStatus},
		gobject.TypeMarshaler{T: TypeFileAttributeType, F: marshalFileAttributeType},
		gobject.TypeMarshaler{T: TypeFileMonitorEvent, F: marshalFileMonitorEvent},
		gobject.TypeMarshaler{T: TypeFileType, F: marshalFileType},
		gobject.TypeMarshaler{T: TypeFilesystemPreviewType, F: marshalFilesystemPreviewType},
		gobject.TypeMarshaler{T: TypeIOErrorEnum, F: marshalIOErrorEnum},
		gobject.TypeMarshaler{T: TypeIOModuleScopeFlags, F: marshalIOModuleScopeFlags},
		gobject.TypeMarshaler{T: TypeMemoryMonitorWarningLevel, F: marshalMemoryMonitorWarningLevel},
		gobject.TypeMarshaler{T: TypeMountOperationResult, F: marshalMountOperationResult},
		gobject.TypeMarshaler{T: TypeNetworkConnectivity, F: marshalNetworkConnectivity},
		gobject.TypeMarshaler{T: TypeNotificationPriority, F: marshalNotificationPriority},
		gobject.TypeMarshaler{T: TypePasswordSave, F: marshalPasswordSave},
		gobject.TypeMarshaler{T: TypePollableReturn, F: marshalPollableReturn},
		gobject.TypeMarshaler{T: TypeResolverError, F: marshalResolverError},
		gobject.TypeMarshaler{T: TypeResolverRecordType, F: marshalResolverRecordType},
		gobject.TypeMarshaler{T: TypeResourceError, F: marshalResourceError},
		gobject.TypeMarshaler{T: TypeSocketClientEvent, F: marshalSocketClientEvent},
		gobject.TypeMarshaler{T: TypeSocketFamily, F: marshalSocketFamily},
		gobject.TypeMarshaler{T: TypeSocketListenerEvent, F: marshalSocketListenerEvent},
		gobject.TypeMarshaler{T: TypeSocketProtocol, F: marshalSocketProtocol},
		gobject.TypeMarshaler{T: TypeSocketType, F: marshalSocketType},
		gobject.TypeMarshaler{T: TypeTlsAuthenticationMode, F: marshalTlsAuthenticationMode},
		gobject.TypeMarshaler{T: TypeTlsCertificateRequestFlags, F: marshalTlsCertificateRequestFlags},
		gobject.TypeMarshaler{T: TypeTlsChannelBindingError, F: marshalTlsChannelBindingError},
		gobject.TypeMarshaler{T: TypeTlsChannelBindingType, F: marshalTlsChannelBindingType},
		gobject.TypeMarshaler{T: TypeTlsDatabaseLookupFlags, F: marshalTlsDatabaseLookupFlags},
		gobject.TypeMarshaler{T: TypeTlsError, F: marshalTlsError},
		gobject.TypeMarshaler{T: TypeTlsInteractionResult, F: marshalTlsInteractionResult},
		gobject.TypeMarshaler{T: TypeTlsProtocolVersion, F: marshalTlsProtocolVersion},
		gobject.TypeMarshaler{T: TypeTlsRehandshakeMode, F: marshalTlsRehandshakeMode},
		gobject.TypeMarshaler{T: TypeZlibCompressorFormat, F: marshalZlibCompressorFormat},
		gobject.TypeMarshaler{T: TypeAppInfoCreateFlags, F: marshalAppInfoCreateFlags},
		gobject.TypeMarshaler{T: TypeApplicationFlags, F: marshalApplicationFlags},
		gobject.TypeMarshaler{T: TypeAskPasswordFlags, F: marshalAskPasswordFlags},
		gobject.TypeMarshaler{T: TypeBusNameOwnerFlags, F: marshalBusNameOwnerFlags},
		gobject.TypeMarshaler{T: TypeBusNameWatcherFlags, F: marshalBusNameWatcherFlags},
		gobject.TypeMarshaler{T: TypeConverterFlags, F: marshalConverterFlags},
		gobject.TypeMarshaler{T: TypeDriveStartFlags, F: marshalDriveStartFlags},
		gobject.TypeMarshaler{T: TypeFileAttributeInfoFlags, F: marshalFileAttributeInfoFlags},
		gobject.TypeMarshaler{T: TypeFileCopyFlags, F: marshalFileCopyFlags},
		gobject.TypeMarshaler{T: TypeFileCreateFlags, F: marshalFileCreateFlags},
		gobject.TypeMarshaler{T: TypeFileMeasureFlags, F: marshalFileMeasureFlags},
		gobject.TypeMarshaler{T: TypeFileMonitorFlags, F: marshalFileMonitorFlags},
		gobject.TypeMarshaler{T: TypeFileQueryInfoFlags, F: marshalFileQueryInfoFlags},
		gobject.TypeMarshaler{T: TypeIOStreamSpliceFlags, F: marshalIOStreamSpliceFlags},
		gobject.TypeMarshaler{T: TypeMountMountFlags, F: marshalMountMountFlags},
		gobject.TypeMarshaler{T: TypeMountUnmountFlags, F: marshalMountUnmountFlags},
		gobject.TypeMarshaler{T: TypeOutputStreamSpliceFlags, F: marshalOutputStreamSpliceFlags},
		gobject.TypeMarshaler{T: TypeResolverNameLookupFlags, F: marshalResolverNameLookupFlags},
		gobject.TypeMarshaler{T: TypeResourceFlags, F: marshalResourceFlags},
		gobject.TypeMarshaler{T: TypeResourceLookupFlags, F: marshalResourceLookupFlags},
		gobject.TypeMarshaler{T: TypeSettingsBindFlags, F: marshalSettingsBindFlags},
		gobject.TypeMarshaler{T: TypeSocketMsgFlags, F: marshalSocketMsgFlags},
		gobject.TypeMarshaler{T: TypeTlsCertificateFlags, F: marshalTlsCertificateFlags},
		gobject.TypeMarshaler{T: TypeTlsDatabaseVerifyFlags, F: marshalTlsDatabaseVerifyFlags},
		gobject.TypeMarshaler{T: TypeTlsPasswordFlags, F: marshalTlsPasswordFlags},
		gobject.TypeMarshaler{T: TypeAction, F: marshalActionInstance},
		gobject.TypeMarshaler{T: TypeActionGroup, F: marshalActionGroupInstance},
		gobject.TypeMarshaler{T: TypeActionMap, F: marshalActionMapInstance},
		gobject.TypeMarshaler{T: TypeAppInfo, F: marshalAppInfoInstance},
		gobject.TypeMarshaler{T: TypeAsyncInitable, F: marshalAsyncInitableInstance},
		gobject.TypeMarshaler{T: TypeAsyncResult, F: marshalAsyncResultInstance},
		gobject.TypeMarshaler{T: TypeConverter, F: marshalConverterInstance},
		gobject.TypeMarshaler{T: TypeDatagramBased, F: marshalDatagramBasedInstance},
		gobject.TypeMarshaler{T: TypeDrive, F: marshalDriveInstance},
		gobject.TypeMarshaler{T: TypeDtlsConnection, F: marshalDtlsConnectionInstance},
		gobject.TypeMarshaler{T: TypeDtlsServerConnection, F: marshalDtlsServerConnectionInstance},
		gobject.TypeMarshaler{T: TypeFile, F: marshalFileInstance},
		gobject.TypeMarshaler{T: TypeIcon, F: marshalIconInstance},
		gobject.TypeMarshaler{T: TypeInitable, F: marshalInitableInstance},
		gobject.TypeMarshaler{T: TypeListModel, F: marshalListModelInstance},
		gobject.TypeMarshaler{T: TypeLoadableIcon, F: marshalLoadableIconInstance},
		gobject.TypeMarshaler{T: TypeMemoryMonitor, F: marshalMemoryMonitorInstance},
		gobject.TypeMarshaler{T: TypeMount, F: marshalMountInstance},
		gobject.TypeMarshaler{T: TypeNetworkMonitor, F: marshalNetworkMonitorInstance},
		gobject.TypeMarshaler{T: TypePollableInputStream, F: marshalPollableInputStreamInstance},
		gobject.TypeMarshaler{T: TypePollableOutputStream, F: marshalPollableOutputStreamInstance},
		gobject.TypeMarshaler{T: TypePowerProfileMonitor, F: marshalPowerProfileMonitorInstance},
		gobject.TypeMarshaler{T: TypeProxy, F: marshalProxyInstance},
		gobject.TypeMarshaler{T: TypeProxyResolver, F: marshalProxyResolverInstance},
		gobject.TypeMarshaler{T: TypeRemoteActionGroup, F: marshalRemoteActionGroupInstance},
		gobject.TypeMarshaler{T: TypeSeekable, F: marshalSeekableInstance},
		gobject.TypeMarshaler{T: TypeSocketConnectable, F: marshalSocketConnectableInstance},
		gobject.TypeMarshaler{T: TypeTlsBackend, F: marshalTlsBackendInstance},
		gobject.TypeMarshaler{T: TypeTlsClientConnection, F: marshalTlsClientConnectionInstance},
		gobject.TypeMarshaler{T: TypeTlsFileDatabase, F: marshalTlsFileDatabaseInstance},
		gobject.TypeMarshaler{T: TypeTlsServerConnection, F: marshalTlsServerConnectionInstance},
		gobject.TypeMarshaler{T: TypeVolume, F: marshalVolumeInstance},
		gobject.TypeMarshaler{T: TypeDebugController, F: marshalDebugControllerInstance},
		gobject.TypeMarshaler{T: TypeDtlsClientConnection, F: marshalDtlsClientConnectionInstance},
		gobject.TypeMarshaler{T: TypeAppInfoMonitor, F: marshalAppInfoMonitorInstance},
		gobject.TypeMarshaler{T: TypeAppLaunchContext, F: marshalAppLaunchContextInstance},
		gobject.TypeMarshaler{T: TypeApplication, F: marshalApplicationInstance},
		gobject.TypeMarshaler{T: TypeApplicationCommandLine, F: marshalApplicationCommandLineInstance},
		gobject.TypeMarshaler{T: TypeBytesIcon, F: marshalBytesIconInstance},
		gobject.TypeMarshaler{T: TypeCancellable, F: marshalCancellableInstance},
		gobject.TypeMarshaler{T: TypeCharsetConverter, F: marshalCharsetConverterInstance},
		gobject.TypeMarshaler{T: TypeCredentials, F: marshalCredentialsInstance},
		gobject.TypeMarshaler{T: TypeEmblem, F: marshalEmblemInstance},
		gobject.TypeMarshaler{T: TypeEmblemedIcon, F: marshalEmblemedIconInstance},
		gobject.TypeMarshaler{T: TypeFileEnumerator, F: marshalFileEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeFileIcon, F: marshalFileIconInstance},
		gobject.TypeMarshaler{T: TypeFileInfo, F: marshalFileInfoInstance},
		gobject.TypeMarshaler{T: TypeFileMonitor, F: marshalFileMonitorInstance},
		gobject.TypeMarshaler{T: TypeFilenameCompleter, F: marshalFilenameCompleterInstance},
		gobject.TypeMarshaler{T: TypeIOStream, F: marshalIOStreamInstance},
		gobject.TypeMarshaler{T: TypeInetAddress, F: marshalInetAddressInstance},
		gobject.TypeMarshaler{T: TypeInetAddressMask, F: marshalInetAddressMaskInstance},
		gobject.TypeMarshaler{T: TypeInputStream, F: marshalInputStreamInstance},
		gobject.TypeMarshaler{T: TypeListStore, F: marshalListStoreInstance},
		gobject.TypeMarshaler{T: TypeMemoryInputStream, F: marshalMemoryInputStreamInstance},
		gobject.TypeMarshaler{T: TypeMenuAttributeIter, F: marshalMenuAttributeIterInstance},
		gobject.TypeMarshaler{T: TypeMenuItem, F: marshalMenuItemInstance},
		gobject.TypeMarshaler{T: TypeMenuLinkIter, F: marshalMenuLinkIterInstance},
		gobject.TypeMarshaler{T: TypeMenuModel, F: marshalMenuModelInstance},
		gobject.TypeMarshaler{T: TypeMountOperation, F: marshalMountOperationInstance},
		gobject.TypeMarshaler{T: TypeNetworkAddress, F: marshalNetworkAddressInstance},
		gobject.TypeMarshaler{T: TypeNetworkService, F: marshalNetworkServiceInstance},
		gobject.TypeMarshaler{T: TypeNotification, F: marshalNotificationInstance},
		gobject.TypeMarshaler{T: TypeOutputStream, F: marshalOutputStreamInstance},
		gobject.TypeMarshaler{T: TypePermission, F: marshalPermissionInstance},
		gobject.TypeMarshaler{T: TypePropertyAction, F: marshalPropertyActionInstance},
		gobject.TypeMarshaler{T: TypeResolver, F: marshalResolverInstance},
		gobject.TypeMarshaler{T: TypeSettings, F: marshalSettingsInstance},
		gobject.TypeMarshaler{T: TypeSimpleAction, F: marshalSimpleActionInstance},
		gobject.TypeMarshaler{T: TypeSimpleActionGroup, F: marshalSimpleActionGroupInstance},
		gobject.TypeMarshaler{T: TypeSimpleAsyncResult, F: marshalSimpleAsyncResultInstance},
		gobject.TypeMarshaler{T: TypeSimpleIOStream, F: marshalSimpleIOStreamInstance},
		gobject.TypeMarshaler{T: TypeSimplePermission, F: marshalSimplePermissionInstance},
		gobject.TypeMarshaler{T: TypeSimpleProxyResolver, F: marshalSimpleProxyResolverInstance},
		gobject.TypeMarshaler{T: TypeSocket, F: marshalSocketInstance},
		gobject.TypeMarshaler{T: TypeSocketAddress, F: marshalSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeSocketAddressEnumerator, F: marshalSocketAddressEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeSocketClient, F: marshalSocketClientInstance},
		gobject.TypeMarshaler{T: TypeSocketConnection, F: marshalSocketConnectionInstance},
		gobject.TypeMarshaler{T: TypeSocketControlMessage, F: marshalSocketControlMessageInstance},
		gobject.TypeMarshaler{T: TypeSocketListener, F: marshalSocketListenerInstance},
		gobject.TypeMarshaler{T: TypeSocketService, F: marshalSocketServiceInstance},
		gobject.TypeMarshaler{T: TypeTask, F: marshalTaskInstance},
		gobject.TypeMarshaler{T: TypeTcpConnection, F: marshalTcpConnectionInstance},
		gobject.TypeMarshaler{T: TypeTcpWrapperConnection, F: marshalTcpWrapperConnectionInstance},
		gobject.TypeMarshaler{T: TypeThemedIcon, F: marshalThemedIconInstance},
		gobject.TypeMarshaler{T: TypeThreadedSocketService, F: marshalThreadedSocketServiceInstance},
		gobject.TypeMarshaler{T: TypeTlsCertificate, F: marshalTlsCertificateInstance},
		gobject.TypeMarshaler{T: TypeTlsConnection, F: marshalTlsConnectionInstance},
		gobject.TypeMarshaler{T: TypeTlsDatabase, F: marshalTlsDatabaseInstance},
		gobject.TypeMarshaler{T: TypeTlsInteraction, F: marshalTlsInteractionInstance},
		gobject.TypeMarshaler{T: TypeTlsPassword, F: marshalTlsPasswordInstance},
		gobject.TypeMarshaler{T: TypeVfs, F: marshalVfsInstance},
		gobject.TypeMarshaler{T: TypeVolumeMonitor, F: marshalVolumeMonitorInstance},
		gobject.TypeMarshaler{T: TypeZlibDecompressor, F: marshalZlibDecompressorInstance},
		gobject.TypeMarshaler{T: TypeFileIOStream, F: marshalFileIOStreamInstance},
		gobject.TypeMarshaler{T: TypeFileInputStream, F: marshalFileInputStreamInstance},
		gobject.TypeMarshaler{T: TypeFileOutputStream, F: marshalFileOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeFilterInputStream, F: marshalFilterInputStreamInstance},
		gobject.TypeMarshaler{T: TypeFilterOutputStream, F: marshalFilterOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeInetSocketAddress, F: marshalInetSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeMemoryOutputStream, F: marshalMemoryOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeMenu, F: marshalMenuInstance},
		gobject.TypeMarshaler{T: TypeNativeSocketAddress, F: marshalNativeSocketAddressInstance},
		gobject.TypeMarshaler{T: TypeNativeVolumeMonitor, F: marshalNativeVolumeMonitorInstance},
		gobject.TypeMarshaler{T: TypeProxyAddress, F: marshalProxyAddressInstance},
		gobject.TypeMarshaler{T: TypeProxyAddressEnumerator, F: marshalProxyAddressEnumeratorInstance},
		gobject.TypeMarshaler{T: TypeBufferedInputStream, F: marshalBufferedInputStreamInstance},
		gobject.TypeMarshaler{T: TypeBufferedOutputStream, F: marshalBufferedOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeConverterInputStream, F: marshalConverterInputStreamInstance},
		gobject.TypeMarshaler{T: TypeConverterOutputStream, F: marshalConverterOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeDataInputStream, F: marshalDataInputStreamInstance},
		gobject.TypeMarshaler{T: TypeDataOutputStream, F: marshalDataOutputStreamInstance},
		gobject.TypeMarshaler{T: TypeFileAttributeInfoList, F: marshalFileAttributeInfoList},
		gobject.TypeMarshaler{T: TypeFileAttributeMatcher, F: marshalFileAttributeMatcher},
		gobject.TypeMarshaler{T: TypeSettingsSchema, F: marshalSettingsSchema},
		gobject.TypeMarshaler{T: TypeSettingsSchemaKey, F: marshalSettingsSchemaKey},
		gobject.TypeMarshaler{T: TypeSettingsSchemaSource, F: marshalSettingsSchemaSource},
		gobject.TypeMarshaler{T: TypeSrvTarget, F: marshalSrvTarget},
	})
}

// MENU_EXPORTER_MAX_SECTION_SIZE wraps G_MENU_EXPORTER_MAX_SECTION_SIZE
//
// The maximum number of entries in a menu section supported by
// g_dbus_connection_export_menu_model().
// 
// The exact value of the limit may change in future GLib versions.
const MENU_EXPORTER_MAX_SECTION_SIZE = 1000
// BusType wraps GBusType
//
// An enumeration for well-known message buses.
type BusType C.int

const (
	// BusTypeStarter wraps G_BUS_TYPE_STARTER
	//
	// An alias for the message bus that activated the process, if any.
	BusTypeStarter BusType = -1
	// BusTypeNone wraps G_BUS_TYPE_NONE
	//
	// Not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem wraps G_BUS_TYPE_SYSTEM
	//
	// The system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession wraps G_BUS_TYPE_SESSION
	//
	// The login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p unsafe.Pointer) (any, error) {
	return BusType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = BusType(0)

func (e BusType) GoValueType() gobject.Type {
	return TypeBusType
}

func (e BusType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e BusType) String() string {
	switch e {
		case BusTypeNone: return "BusTypeNone"
		case BusTypeSession: return "BusTypeSession"
		case BusTypeStarter: return "BusTypeStarter"
		case BusTypeSystem: return "BusTypeSystem"
		default: return fmt.Sprintf("BusType(%d)", e)
	}
}

// ConverterResult wraps GConverterResult
//
// Results returned from g_converter_convert().
type ConverterResult C.int

const (
	// ConverterError wraps G_CONVERTER_ERROR
	//
	// There was an error during conversion.
	ConverterError ConverterResult = 0
	// ConverterConverted wraps G_CONVERTER_CONVERTED
	//
	// Some data was consumed or produced
	ConverterConverted ConverterResult = 1
	// ConverterFinished wraps G_CONVERTER_FINISHED
	//
	// The conversion is finished
	ConverterFinished ConverterResult = 2
	// ConverterFlushed wraps G_CONVERTER_FLUSHED
	//
	// Flushing is finished
	ConverterFlushed ConverterResult = 3
)

func marshalConverterResult(p unsafe.Pointer) (any, error) {
	return ConverterResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ConverterResult(0)

func (e ConverterResult) GoValueType() gobject.Type {
	return TypeConverterResult
}

func (e ConverterResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ConverterResult) String() string {
	switch e {
		case ConverterConverted: return "ConverterConverted"
		case ConverterError: return "ConverterError"
		case ConverterFinished: return "ConverterFinished"
		case ConverterFlushed: return "ConverterFlushed"
		default: return fmt.Sprintf("ConverterResult(%d)", e)
	}
}

// CredentialsType wraps GCredentialsType
//
// Enumeration describing different kinds of native credential types.
type CredentialsType C.int

const (
	// CredentialsTypeInvalid wraps G_CREDENTIALS_TYPE_INVALID
	//
	// Indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = 0
	// CredentialsTypeLinuxUcred wraps G_CREDENTIALS_TYPE_LINUX_UCRED
	//
	// The native credentials type is a `struct ucred`.
	CredentialsTypeLinuxUcred CredentialsType = 1
	// CredentialsTypeFreebsdCmsgcred wraps G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED
	//
	// The native credentials type is a `struct cmsgcred`.
	CredentialsTypeFreebsdCmsgcred CredentialsType = 2
	// CredentialsTypeOpenbsdSockpeercred wraps G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED
	//
	// The native credentials type is a `struct sockpeercred`. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred CredentialsType = 3
	// CredentialsTypeSolarisUcred wraps G_CREDENTIALS_TYPE_SOLARIS_UCRED
	//
	// The native credentials type is a `ucred_t`. Added in 2.40.
	CredentialsTypeSolarisUcred CredentialsType = 4
	// CredentialsTypeNetbsdUnpcbid wraps G_CREDENTIALS_TYPE_NETBSD_UNPCBID
	//
	// The native credentials type is a `struct unpcbid`. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid CredentialsType = 5
	// CredentialsTypeAppleXucred wraps G_CREDENTIALS_TYPE_APPLE_XUCRED
	//
	// The native credentials type is a `struct xucred`. Added in 2.66.
	CredentialsTypeAppleXucred CredentialsType = 6
	// CredentialsTypeWin32Pid wraps G_CREDENTIALS_TYPE_WIN32_PID
	//
	// The native credentials type is a PID `DWORD`. Added in 2.72.
	CredentialsTypeWin32Pid CredentialsType = 7
)

func marshalCredentialsType(p unsafe.Pointer) (any, error) {
	return CredentialsType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = CredentialsType(0)

func (e CredentialsType) GoValueType() gobject.Type {
	return TypeCredentialsType
}

func (e CredentialsType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e CredentialsType) String() string {
	switch e {
		case CredentialsTypeAppleXucred: return "CredentialsTypeAppleXucred"
		case CredentialsTypeFreebsdCmsgcred: return "CredentialsTypeFreebsdCmsgcred"
		case CredentialsTypeInvalid: return "CredentialsTypeInvalid"
		case CredentialsTypeLinuxUcred: return "CredentialsTypeLinuxUcred"
		case CredentialsTypeNetbsdUnpcbid: return "CredentialsTypeNetbsdUnpcbid"
		case CredentialsTypeOpenbsdSockpeercred: return "CredentialsTypeOpenbsdSockpeercred"
		case CredentialsTypeSolarisUcred: return "CredentialsTypeSolarisUcred"
		case CredentialsTypeWin32Pid: return "CredentialsTypeWin32Pid"
		default: return fmt.Sprintf("CredentialsType(%d)", e)
	}
}

// DataStreamByteOrder wraps GDataStreamByteOrder
//
// #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
// across various machine architectures.
type DataStreamByteOrder C.int

const (
	// DataStreamByteOrderBigEndian wraps G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN
	//
	// Selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = 0
	// DataStreamByteOrderLittleEndian wraps G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN
	//
	// Selects Little Endian byte order.
	DataStreamByteOrderLittleEndian DataStreamByteOrder = 1
	// DataStreamByteOrderHostEndian wraps G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN
	//
	// Selects endianness based on host machine's architecture.
	DataStreamByteOrderHostEndian DataStreamByteOrder = 2
)

func marshalDataStreamByteOrder(p unsafe.Pointer) (any, error) {
	return DataStreamByteOrder(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DataStreamByteOrder(0)

func (e DataStreamByteOrder) GoValueType() gobject.Type {
	return TypeDataStreamByteOrder
}

func (e DataStreamByteOrder) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DataStreamByteOrder) String() string {
	switch e {
		case DataStreamByteOrderBigEndian: return "DataStreamByteOrderBigEndian"
		case DataStreamByteOrderHostEndian: return "DataStreamByteOrderHostEndian"
		case DataStreamByteOrderLittleEndian: return "DataStreamByteOrderLittleEndian"
		default: return fmt.Sprintf("DataStreamByteOrder(%d)", e)
	}
}

// DataStreamNewlineType wraps GDataStreamNewlineType
//
// #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
type DataStreamNewlineType C.int

const (
	// DataStreamNewlineTypeLf wraps G_DATA_STREAM_NEWLINE_TYPE_LF
	//
	// Selects "LF" line endings, common on most modern UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = 0
	// DataStreamNewlineTypeCr wraps G_DATA_STREAM_NEWLINE_TYPE_CR
	//
	// Selects "CR" line endings.
	DataStreamNewlineTypeCr DataStreamNewlineType = 1
	// DataStreamNewlineTypeCrLf wraps G_DATA_STREAM_NEWLINE_TYPE_CR_LF
	//
	// Selects "CR, LF" line ending, common on Microsoft Windows.
	DataStreamNewlineTypeCrLf DataStreamNewlineType = 2
	// DataStreamNewlineTypeAny wraps G_DATA_STREAM_NEWLINE_TYPE_ANY
	//
	// Automatically try to handle any line ending type.
	DataStreamNewlineTypeAny DataStreamNewlineType = 3
)

func marshalDataStreamNewlineType(p unsafe.Pointer) (any, error) {
	return DataStreamNewlineType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DataStreamNewlineType(0)

func (e DataStreamNewlineType) GoValueType() gobject.Type {
	return TypeDataStreamNewlineType
}

func (e DataStreamNewlineType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DataStreamNewlineType) String() string {
	switch e {
		case DataStreamNewlineTypeAny: return "DataStreamNewlineTypeAny"
		case DataStreamNewlineTypeCr: return "DataStreamNewlineTypeCr"
		case DataStreamNewlineTypeCrLf: return "DataStreamNewlineTypeCrLf"
		case DataStreamNewlineTypeLf: return "DataStreamNewlineTypeLf"
		default: return fmt.Sprintf("DataStreamNewlineType(%d)", e)
	}
}

// DriveStartStopType wraps GDriveStartStopType
//
// Enumeration describing how a drive can be started/stopped.
type DriveStartStopType C.int

const (
	// DriveStartStopTypeUnknown wraps G_DRIVE_START_STOP_TYPE_UNKNOWN
	//
	// Unknown or drive doesn't support
	//    start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = 0
	// DriveStartStopTypeShutdown wraps G_DRIVE_START_STOP_TYPE_SHUTDOWN
	//
	// The stop method will physically
	//    shut down the drive and e.g. power down the port the drive is
	//    attached to.
	DriveStartStopTypeShutdown DriveStartStopType = 1
	// DriveStartStopTypeNetwork wraps G_DRIVE_START_STOP_TYPE_NETWORK
	//
	// The start/stop methods are used
	//    for connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork DriveStartStopType = 2
	// DriveStartStopTypeMultidisk wraps G_DRIVE_START_STOP_TYPE_MULTIDISK
	//
	// The start/stop methods will
	//    assemble/disassemble a virtual drive from several physical
	//    drives.
	DriveStartStopTypeMultidisk DriveStartStopType = 3
	// DriveStartStopTypePassword wraps G_DRIVE_START_STOP_TYPE_PASSWORD
	//
	// The start/stop methods will
	//    unlock/lock the disk (for example using the ATA `SECURITY UNLOCK
	//    DEVICE` command)
	DriveStartStopTypePassword DriveStartStopType = 4
)

func marshalDriveStartStopType(p unsafe.Pointer) (any, error) {
	return DriveStartStopType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = DriveStartStopType(0)

func (e DriveStartStopType) GoValueType() gobject.Type {
	return TypeDriveStartStopType
}

func (e DriveStartStopType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e DriveStartStopType) String() string {
	switch e {
		case DriveStartStopTypeMultidisk: return "DriveStartStopTypeMultidisk"
		case DriveStartStopTypeNetwork: return "DriveStartStopTypeNetwork"
		case DriveStartStopTypePassword: return "DriveStartStopTypePassword"
		case DriveStartStopTypeShutdown: return "DriveStartStopTypeShutdown"
		case DriveStartStopTypeUnknown: return "DriveStartStopTypeUnknown"
		default: return fmt.Sprintf("DriveStartStopType(%d)", e)
	}
}

// EmblemOrigin wraps GEmblemOrigin
//
// GEmblemOrigin is used to add information about the origin of the emblem
// to #GEmblem.
type EmblemOrigin C.int

const (
	// EmblemOriginUnknown wraps G_EMBLEM_ORIGIN_UNKNOWN
	//
	// Emblem of unknown origin
	EmblemOriginUnknown EmblemOrigin = 0
	// EmblemOriginDevice wraps G_EMBLEM_ORIGIN_DEVICE
	//
	// Emblem adds device-specific information
	EmblemOriginDevice EmblemOrigin = 1
	// EmblemOriginLivemetadata wraps G_EMBLEM_ORIGIN_LIVEMETADATA
	//
	// Emblem depicts live metadata, such as "readonly"
	EmblemOriginLivemetadata EmblemOrigin = 2
	// EmblemOriginTag wraps G_EMBLEM_ORIGIN_TAG
	//
	// Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
	EmblemOriginTag EmblemOrigin = 3
)

func marshalEmblemOrigin(p unsafe.Pointer) (any, error) {
	return EmblemOrigin(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = EmblemOrigin(0)

func (e EmblemOrigin) GoValueType() gobject.Type {
	return TypeEmblemOrigin
}

func (e EmblemOrigin) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e EmblemOrigin) String() string {
	switch e {
		case EmblemOriginDevice: return "EmblemOriginDevice"
		case EmblemOriginLivemetadata: return "EmblemOriginLivemetadata"
		case EmblemOriginTag: return "EmblemOriginTag"
		case EmblemOriginUnknown: return "EmblemOriginUnknown"
		default: return fmt.Sprintf("EmblemOrigin(%d)", e)
	}
}

// FileAttributeStatus wraps GFileAttributeStatus
//
// Used by g_file_set_attributes_from_info() when setting file attributes.
type FileAttributeStatus C.int

const (
	// FileAttributeStatusUnset wraps G_FILE_ATTRIBUTE_STATUS_UNSET
	//
	// Attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = 0
	// FileAttributeStatusSet wraps G_FILE_ATTRIBUTE_STATUS_SET
	//
	// Attribute value is set.
	FileAttributeStatusSet FileAttributeStatus = 1
	// FileAttributeStatusErrorSetting wraps G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING
	//
	// Indicates an error in setting the value.
	FileAttributeStatusErrorSetting FileAttributeStatus = 2
)

func marshalFileAttributeStatus(p unsafe.Pointer) (any, error) {
	return FileAttributeStatus(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileAttributeStatus(0)

func (e FileAttributeStatus) GoValueType() gobject.Type {
	return TypeFileAttributeStatus
}

func (e FileAttributeStatus) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileAttributeStatus) String() string {
	switch e {
		case FileAttributeStatusErrorSetting: return "FileAttributeStatusErrorSetting"
		case FileAttributeStatusSet: return "FileAttributeStatusSet"
		case FileAttributeStatusUnset: return "FileAttributeStatusUnset"
		default: return fmt.Sprintf("FileAttributeStatus(%d)", e)
	}
}

// FileAttributeType wraps GFileAttributeType
//
// The data types for file attributes.
type FileAttributeType C.int

const (
	// FileAttributeTypeInvalid wraps G_FILE_ATTRIBUTE_TYPE_INVALID
	//
	// indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = 0
	// FileAttributeTypeString wraps G_FILE_ATTRIBUTE_TYPE_STRING
	//
	// a null terminated UTF8 string.
	FileAttributeTypeString FileAttributeType = 1
	// FileAttributeTypeByteString wraps G_FILE_ATTRIBUTE_TYPE_BYTE_STRING
	//
	// a zero terminated string of non-zero bytes.
	FileAttributeTypeByteString FileAttributeType = 2
	// FileAttributeTypeBoolean wraps G_FILE_ATTRIBUTE_TYPE_BOOLEAN
	//
	// a boolean value.
	FileAttributeTypeBoolean FileAttributeType = 3
	// FileAttributeTypeUint32 wraps G_FILE_ATTRIBUTE_TYPE_UINT32
	//
	// an unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32 FileAttributeType = 4
	// FileAttributeTypeInt32 wraps G_FILE_ATTRIBUTE_TYPE_INT32
	//
	// a signed 4-byte/32-bit integer.
	FileAttributeTypeInt32 FileAttributeType = 5
	// FileAttributeTypeUint64 wraps G_FILE_ATTRIBUTE_TYPE_UINT64
	//
	// an unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64 FileAttributeType = 6
	// FileAttributeTypeInt64 wraps G_FILE_ATTRIBUTE_TYPE_INT64
	//
	// a signed 8-byte/64-bit integer.
	FileAttributeTypeInt64 FileAttributeType = 7
	// FileAttributeTypeObject wraps G_FILE_ATTRIBUTE_TYPE_OBJECT
	//
	// a #GObject.
	FileAttributeTypeObject FileAttributeType = 8
	// FileAttributeTypeStringv wraps G_FILE_ATTRIBUTE_TYPE_STRINGV
	//
	// a %NULL terminated char **. Since 2.22
	FileAttributeTypeStringv FileAttributeType = 9
)

func marshalFileAttributeType(p unsafe.Pointer) (any, error) {
	return FileAttributeType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileAttributeType(0)

func (e FileAttributeType) GoValueType() gobject.Type {
	return TypeFileAttributeType
}

func (e FileAttributeType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileAttributeType) String() string {
	switch e {
		case FileAttributeTypeBoolean: return "FileAttributeTypeBoolean"
		case FileAttributeTypeByteString: return "FileAttributeTypeByteString"
		case FileAttributeTypeInt32: return "FileAttributeTypeInt32"
		case FileAttributeTypeInt64: return "FileAttributeTypeInt64"
		case FileAttributeTypeInvalid: return "FileAttributeTypeInvalid"
		case FileAttributeTypeObject: return "FileAttributeTypeObject"
		case FileAttributeTypeString: return "FileAttributeTypeString"
		case FileAttributeTypeStringv: return "FileAttributeTypeStringv"
		case FileAttributeTypeUint32: return "FileAttributeTypeUint32"
		case FileAttributeTypeUint64: return "FileAttributeTypeUint64"
		default: return fmt.Sprintf("FileAttributeType(%d)", e)
	}
}

// FileMonitorEvent wraps GFileMonitorEvent
//
// Specifies what type of event a monitor event is.
type FileMonitorEvent C.int

const (
	// FileMonitorEventChanged wraps G_FILE_MONITOR_EVENT_CHANGED
	//
	// a file changed.
	FileMonitorEventChanged FileMonitorEvent = 0
	// FileMonitorEventChangesDoneHint wraps G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT
	//
	// a hint that this was probably the last change in a set of changes.
	FileMonitorEventChangesDoneHint FileMonitorEvent = 1
	// FileMonitorEventDeleted wraps G_FILE_MONITOR_EVENT_DELETED
	//
	// a file was deleted.
	FileMonitorEventDeleted FileMonitorEvent = 2
	// FileMonitorEventCreated wraps G_FILE_MONITOR_EVENT_CREATED
	//
	// a file was created.
	FileMonitorEventCreated FileMonitorEvent = 3
	// FileMonitorEventAttributeChanged wraps G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED
	//
	// a file attribute was changed.
	FileMonitorEventAttributeChanged FileMonitorEvent = 4
	// FileMonitorEventPreUnmount wraps G_FILE_MONITOR_EVENT_PRE_UNMOUNT
	//
	// the file location will soon be unmounted.
	FileMonitorEventPreUnmount FileMonitorEvent = 5
	// FileMonitorEventUnmounted wraps G_FILE_MONITOR_EVENT_UNMOUNTED
	//
	// the file location was unmounted.
	FileMonitorEventUnmounted FileMonitorEvent = 6
	// FileMonitorEventMoved wraps G_FILE_MONITOR_EVENT_MOVED
	//
	// the file was moved -- only sent if the
	//   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
	FileMonitorEventMoved FileMonitorEvent = 7
	// FileMonitorEventRenamed wraps G_FILE_MONITOR_EVENT_RENAMED
	//
	// the file was renamed within the
	//   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
	//   flag is set.  Since: 2.46.
	FileMonitorEventRenamed FileMonitorEvent = 8
	// FileMonitorEventMovedIn wraps G_FILE_MONITOR_EVENT_MOVED_IN
	//
	// the file was moved into the
	//   monitored directory from another location -- only sent if the
	//   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
	FileMonitorEventMovedIn FileMonitorEvent = 9
	// FileMonitorEventMovedOut wraps G_FILE_MONITOR_EVENT_MOVED_OUT
	//
	// the file was moved out of the
	//   monitored directory to another location -- only sent if the
	//   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
	FileMonitorEventMovedOut FileMonitorEvent = 10
)

func marshalFileMonitorEvent(p unsafe.Pointer) (any, error) {
	return FileMonitorEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileMonitorEvent(0)

func (e FileMonitorEvent) GoValueType() gobject.Type {
	return TypeFileMonitorEvent
}

func (e FileMonitorEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileMonitorEvent) String() string {
	switch e {
		case FileMonitorEventAttributeChanged: return "FileMonitorEventAttributeChanged"
		case FileMonitorEventChanged: return "FileMonitorEventChanged"
		case FileMonitorEventChangesDoneHint: return "FileMonitorEventChangesDoneHint"
		case FileMonitorEventCreated: return "FileMonitorEventCreated"
		case FileMonitorEventDeleted: return "FileMonitorEventDeleted"
		case FileMonitorEventMoved: return "FileMonitorEventMoved"
		case FileMonitorEventMovedIn: return "FileMonitorEventMovedIn"
		case FileMonitorEventMovedOut: return "FileMonitorEventMovedOut"
		case FileMonitorEventPreUnmount: return "FileMonitorEventPreUnmount"
		case FileMonitorEventRenamed: return "FileMonitorEventRenamed"
		case FileMonitorEventUnmounted: return "FileMonitorEventUnmounted"
		default: return fmt.Sprintf("FileMonitorEvent(%d)", e)
	}
}

// FileType wraps GFileType
//
// Indicates the file's on-disk type.
// 
// On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
// use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
// whether a file is a symlink or not. This is due to the fact that NTFS does
// not have a single filesystem object type for symbolic links - it has
// files that symlink to files, and directories that symlink to directories.
// #GFileType enumeration cannot precisely represent this important distinction,
// which is why all Windows symlinks will continue to be reported as
// %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.
type FileType C.int

const (
	// FileTypeUnknown wraps G_FILE_TYPE_UNKNOWN
	//
	// File's type is unknown.
	FileTypeUnknown FileType = 0
	// FileTypeRegular wraps G_FILE_TYPE_REGULAR
	//
	// File handle represents a regular file.
	FileTypeRegular FileType = 1
	// FileTypeDirectory wraps G_FILE_TYPE_DIRECTORY
	//
	// File handle represents a directory.
	FileTypeDirectory FileType = 2
	// FileTypeSymbolicLink wraps G_FILE_TYPE_SYMBOLIC_LINK
	//
	// File handle represents a symbolic link
	//    (Unix systems).
	FileTypeSymbolicLink FileType = 3
	// FileTypeSpecial wraps G_FILE_TYPE_SPECIAL
	//
	// File is a "special" file, such as a socket, fifo,
	//    block device, or character device.
	FileTypeSpecial FileType = 4
	// FileTypeShortcut wraps G_FILE_TYPE_SHORTCUT
	//
	// File is a shortcut (Windows systems).
	FileTypeShortcut FileType = 5
	// FileTypeMountable wraps G_FILE_TYPE_MOUNTABLE
	//
	// File is a mountable location.
	FileTypeMountable FileType = 6
)

func marshalFileType(p unsafe.Pointer) (any, error) {
	return FileType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FileType(0)

func (e FileType) GoValueType() gobject.Type {
	return TypeFileType
}

func (e FileType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FileType) String() string {
	switch e {
		case FileTypeDirectory: return "FileTypeDirectory"
		case FileTypeMountable: return "FileTypeMountable"
		case FileTypeRegular: return "FileTypeRegular"
		case FileTypeShortcut: return "FileTypeShortcut"
		case FileTypeSpecial: return "FileTypeSpecial"
		case FileTypeSymbolicLink: return "FileTypeSymbolicLink"
		case FileTypeUnknown: return "FileTypeUnknown"
		default: return fmt.Sprintf("FileType(%d)", e)
	}
}

// FilesystemPreviewType wraps GFilesystemPreviewType
//
// Indicates a hint from the file system whether files should be
// previewed in a file manager. Returned as the value of the key
// %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType C.int

const (
	// FilesystemPreviewTypeIfAlways wraps G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS
	//
	// Only preview files if user has explicitly requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = 0
	// FilesystemPreviewTypeIfLocal wraps G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL
	//
	// Preview files if user has requested preview of "local" files.
	FilesystemPreviewTypeIfLocal FilesystemPreviewType = 1
	// FilesystemPreviewTypeNever wraps G_FILESYSTEM_PREVIEW_TYPE_NEVER
	//
	// Never preview files.
	FilesystemPreviewTypeNever FilesystemPreviewType = 2
)

func marshalFilesystemPreviewType(p unsafe.Pointer) (any, error) {
	return FilesystemPreviewType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = FilesystemPreviewType(0)

func (e FilesystemPreviewType) GoValueType() gobject.Type {
	return TypeFilesystemPreviewType
}

func (e FilesystemPreviewType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e FilesystemPreviewType) String() string {
	switch e {
		case FilesystemPreviewTypeIfAlways: return "FilesystemPreviewTypeIfAlways"
		case FilesystemPreviewTypeIfLocal: return "FilesystemPreviewTypeIfLocal"
		case FilesystemPreviewTypeNever: return "FilesystemPreviewTypeNever"
		default: return fmt.Sprintf("FilesystemPreviewType(%d)", e)
	}
}

// IOErrorEnum wraps GIOErrorEnum
//
// Error codes returned by GIO functions.
// 
// Note that this domain may be extended in future GLib releases. In
// general, new error codes either only apply to new APIs, or else
// replace %G_IO_ERROR_FAILED in cases that were not explicitly
// distinguished before. You should therefore avoid writing code like
// |[&lt;!-- language="C" --&gt;
// if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//   {
//     // Assume that this is EPRINTERONFIRE
//     ...
//   }
// ]|
// but should instead treat all unrecognized error codes the same as
// %G_IO_ERROR_FAILED.
// 
// See also #GPollableReturn for a cheaper way of returning
// %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.
type IOErrorEnum C.int

const (
	// IOErrorFailed wraps G_IO_ERROR_FAILED
	//
	// Generic error condition for when an operation fails
	//     and no more specific #GIOErrorEnum value is defined.
	IOErrorFailed IOErrorEnum = 0
	// IOErrorNotFound wraps G_IO_ERROR_NOT_FOUND
	//
	// File not found.
	IOErrorNotFound IOErrorEnum = 1
	// IOErrorExists wraps G_IO_ERROR_EXISTS
	//
	// File already exists.
	IOErrorExists IOErrorEnum = 2
	// IOErrorIsDirectory wraps G_IO_ERROR_IS_DIRECTORY
	//
	// File is a directory.
	IOErrorIsDirectory IOErrorEnum = 3
	// IOErrorNotDirectory wraps G_IO_ERROR_NOT_DIRECTORY
	//
	// File is not a directory.
	IOErrorNotDirectory IOErrorEnum = 4
	// IOErrorNotEmpty wraps G_IO_ERROR_NOT_EMPTY
	//
	// File is a directory that isn't empty.
	IOErrorNotEmpty IOErrorEnum = 5
	// IOErrorNotRegularFile wraps G_IO_ERROR_NOT_REGULAR_FILE
	//
	// File is not a regular file.
	IOErrorNotRegularFile IOErrorEnum = 6
	// IOErrorNotSymbolicLink wraps G_IO_ERROR_NOT_SYMBOLIC_LINK
	//
	// File is not a symbolic link.
	IOErrorNotSymbolicLink IOErrorEnum = 7
	// IOErrorNotMountableFile wraps G_IO_ERROR_NOT_MOUNTABLE_FILE
	//
	// File cannot be mounted.
	IOErrorNotMountableFile IOErrorEnum = 8
	// IOErrorFilenameTooLong wraps G_IO_ERROR_FILENAME_TOO_LONG
	//
	// Filename is too many characters.
	IOErrorFilenameTooLong IOErrorEnum = 9
	// IOErrorInvalidFilename wraps G_IO_ERROR_INVALID_FILENAME
	//
	// Filename is invalid or contains invalid characters.
	IOErrorInvalidFilename IOErrorEnum = 10
	// IOErrorTooManyLinks wraps G_IO_ERROR_TOO_MANY_LINKS
	//
	// File contains too many symbolic links.
	IOErrorTooManyLinks IOErrorEnum = 11
	// IOErrorNoSpace wraps G_IO_ERROR_NO_SPACE
	//
	// No space left on drive.
	IOErrorNoSpace IOErrorEnum = 12
	// IOErrorInvalidArgument wraps G_IO_ERROR_INVALID_ARGUMENT
	//
	// Invalid argument.
	IOErrorInvalidArgument IOErrorEnum = 13
	// IOErrorPermissionDenied wraps G_IO_ERROR_PERMISSION_DENIED
	//
	// Permission denied.
	IOErrorPermissionDenied IOErrorEnum = 14
	// IOErrorNotSupported wraps G_IO_ERROR_NOT_SUPPORTED
	//
	// Operation (or one of its parameters) not supported
	IOErrorNotSupported IOErrorEnum = 15
	// IOErrorNotMounted wraps G_IO_ERROR_NOT_MOUNTED
	//
	// File isn't mounted.
	IOErrorNotMounted IOErrorEnum = 16
	// IOErrorAlreadyMounted wraps G_IO_ERROR_ALREADY_MOUNTED
	//
	// File is already mounted.
	IOErrorAlreadyMounted IOErrorEnum = 17
	// IOErrorClosed wraps G_IO_ERROR_CLOSED
	//
	// File was closed.
	IOErrorClosed IOErrorEnum = 18
	// IOErrorCancelled wraps G_IO_ERROR_CANCELLED
	//
	// Operation was cancelled. See #GCancellable.
	IOErrorCancelled IOErrorEnum = 19
	// IOErrorPending wraps G_IO_ERROR_PENDING
	//
	// Operations are still pending.
	IOErrorPending IOErrorEnum = 20
	// IOErrorReadOnly wraps G_IO_ERROR_READ_ONLY
	//
	// File is read only.
	IOErrorReadOnly IOErrorEnum = 21
	// IOErrorCantCreateBackup wraps G_IO_ERROR_CANT_CREATE_BACKUP
	//
	// Backup couldn't be created.
	IOErrorCantCreateBackup IOErrorEnum = 22
	// IOErrorWrongEtag wraps G_IO_ERROR_WRONG_ETAG
	//
	// File's Entity Tag was incorrect.
	IOErrorWrongEtag IOErrorEnum = 23
	// IOErrorTimedOut wraps G_IO_ERROR_TIMED_OUT
	//
	// Operation timed out.
	IOErrorTimedOut IOErrorEnum = 24
	// IOErrorWouldRecurse wraps G_IO_ERROR_WOULD_RECURSE
	//
	// Operation would be recursive.
	IOErrorWouldRecurse IOErrorEnum = 25
	// IOErrorBusy wraps G_IO_ERROR_BUSY
	//
	// File is busy.
	IOErrorBusy IOErrorEnum = 26
	// IOErrorWouldBlock wraps G_IO_ERROR_WOULD_BLOCK
	//
	// Operation would block.
	IOErrorWouldBlock IOErrorEnum = 27
	// IOErrorHostNotFound wraps G_IO_ERROR_HOST_NOT_FOUND
	//
	// Host couldn't be found (remote operations).
	IOErrorHostNotFound IOErrorEnum = 28
	// IOErrorWouldMerge wraps G_IO_ERROR_WOULD_MERGE
	//
	// Operation would merge files.
	IOErrorWouldMerge IOErrorEnum = 29
	// IOErrorFailedHandled wraps G_IO_ERROR_FAILED_HANDLED
	//
	// Operation failed and a helper program has
	//     already interacted with the user. Do not display any error dialog.
	IOErrorFailedHandled IOErrorEnum = 30
	// IOErrorTooManyOpenFiles wraps G_IO_ERROR_TOO_MANY_OPEN_FILES
	//
	// The current process has too many files
	//     open and can't open any more. Duplicate descriptors do count toward
	//     this limit. Since 2.20
	IOErrorTooManyOpenFiles IOErrorEnum = 31
	// IOErrorNotInitialized wraps G_IO_ERROR_NOT_INITIALIZED
	//
	// The object has not been initialized. Since 2.22
	IOErrorNotInitialized IOErrorEnum = 32
	// IOErrorAddressInUse wraps G_IO_ERROR_ADDRESS_IN_USE
	//
	// The requested address is already in use. Since 2.22
	IOErrorAddressInUse IOErrorEnum = 33
	// IOErrorPartialInput wraps G_IO_ERROR_PARTIAL_INPUT
	//
	// Need more input to finish operation. Since 2.24
	IOErrorPartialInput IOErrorEnum = 34
	// IOErrorInvalidData wraps G_IO_ERROR_INVALID_DATA
	//
	// The input data was invalid. Since 2.24
	IOErrorInvalidData IOErrorEnum = 35
	// IOErrorDBusError wraps G_IO_ERROR_DBUS_ERROR
	//
	// A remote object generated an error that
	//     doesn't correspond to a locally registered #GError error
	//     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
	//     error name and g_dbus_error_strip_remote_error() to fix up the
	//     message so it matches what was received on the wire. Since 2.26.
	IOErrorDBusError IOErrorEnum = 36
	// IOErrorHostUnreachable wraps G_IO_ERROR_HOST_UNREACHABLE
	//
	// Host unreachable. Since 2.26
	IOErrorHostUnreachable IOErrorEnum = 37
	// IOErrorNetworkUnreachable wraps G_IO_ERROR_NETWORK_UNREACHABLE
	//
	// Network unreachable. Since 2.26
	IOErrorNetworkUnreachable IOErrorEnum = 38
	// IOErrorConnectionRefused wraps G_IO_ERROR_CONNECTION_REFUSED
	//
	// Connection refused. Since 2.26
	IOErrorConnectionRefused IOErrorEnum = 39
	// IOErrorProxyFailed wraps G_IO_ERROR_PROXY_FAILED
	//
	// Connection to proxy server failed. Since 2.26
	IOErrorProxyFailed IOErrorEnum = 40
	// IOErrorProxyAuthFailed wraps G_IO_ERROR_PROXY_AUTH_FAILED
	//
	// Proxy authentication failed. Since 2.26
	IOErrorProxyAuthFailed IOErrorEnum = 41
	// IOErrorProxyNeedAuth wraps G_IO_ERROR_PROXY_NEED_AUTH
	//
	// Proxy server needs authentication. Since 2.26
	IOErrorProxyNeedAuth IOErrorEnum = 42
	// IOErrorProxyNotAllowed wraps G_IO_ERROR_PROXY_NOT_ALLOWED
	//
	// Proxy connection is not allowed by ruleset.
	//     Since 2.26
	IOErrorProxyNotAllowed IOErrorEnum = 43
	// IOErrorBrokenPipe wraps G_IO_ERROR_BROKEN_PIPE
	//
	// Broken pipe. Since 2.36
	IOErrorBrokenPipe IOErrorEnum = 44
	// IOErrorConnectionClosed wraps G_IO_ERROR_CONNECTION_CLOSED
	//
	// Connection closed by peer. Note that this
	//     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
	//     "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
	//     returned %G_IO_ERROR_FAILED. Now they should all return the same
	//     value, which has this more logical name. Since 2.44.
	IOErrorConnectionClosed IOErrorEnum = 44
	// IOErrorNotConnected wraps G_IO_ERROR_NOT_CONNECTED
	//
	// Transport endpoint is not connected. Since 2.44
	IOErrorNotConnected IOErrorEnum = 45
	// IOErrorMessageTooLarge wraps G_IO_ERROR_MESSAGE_TOO_LARGE
	//
	// Message too large. Since 2.48.
	IOErrorMessageTooLarge IOErrorEnum = 46
	// IOErrorNoSuchDevice wraps G_IO_ERROR_NO_SUCH_DEVICE
	//
	// No such device found. Since 2.74
	IOErrorNoSuchDevice IOErrorEnum = 47
	// IOErrorDestinationUnset wraps G_IO_ERROR_DESTINATION_UNSET
	//
	// Destination address unset. Since 2.80
	IOErrorDestinationUnset IOErrorEnum = 48
)

func marshalIOErrorEnum(p unsafe.Pointer) (any, error) {
	return IOErrorEnum(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = IOErrorEnum(0)

func (e IOErrorEnum) GoValueType() gobject.Type {
	return TypeIOErrorEnum
}

func (e IOErrorEnum) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e IOErrorEnum) String() string {
	switch e {
		case IOErrorAddressInUse: return "IOErrorAddressInUse"
		case IOErrorAlreadyMounted: return "IOErrorAlreadyMounted"
		case IOErrorBrokenPipe: return "IOErrorBrokenPipe"
		case IOErrorBusy: return "IOErrorBusy"
		case IOErrorCancelled: return "IOErrorCancelled"
		case IOErrorCantCreateBackup: return "IOErrorCantCreateBackup"
		case IOErrorClosed: return "IOErrorClosed"
		case IOErrorConnectionRefused: return "IOErrorConnectionRefused"
		case IOErrorDBusError: return "IOErrorDBusError"
		case IOErrorDestinationUnset: return "IOErrorDestinationUnset"
		case IOErrorExists: return "IOErrorExists"
		case IOErrorFailed: return "IOErrorFailed"
		case IOErrorFailedHandled: return "IOErrorFailedHandled"
		case IOErrorFilenameTooLong: return "IOErrorFilenameTooLong"
		case IOErrorHostNotFound: return "IOErrorHostNotFound"
		case IOErrorHostUnreachable: return "IOErrorHostUnreachable"
		case IOErrorInvalidArgument: return "IOErrorInvalidArgument"
		case IOErrorInvalidData: return "IOErrorInvalidData"
		case IOErrorInvalidFilename: return "IOErrorInvalidFilename"
		case IOErrorIsDirectory: return "IOErrorIsDirectory"
		case IOErrorMessageTooLarge: return "IOErrorMessageTooLarge"
		case IOErrorNetworkUnreachable: return "IOErrorNetworkUnreachable"
		case IOErrorNoSpace: return "IOErrorNoSpace"
		case IOErrorNoSuchDevice: return "IOErrorNoSuchDevice"
		case IOErrorNotConnected: return "IOErrorNotConnected"
		case IOErrorNotDirectory: return "IOErrorNotDirectory"
		case IOErrorNotEmpty: return "IOErrorNotEmpty"
		case IOErrorNotFound: return "IOErrorNotFound"
		case IOErrorNotInitialized: return "IOErrorNotInitialized"
		case IOErrorNotMountableFile: return "IOErrorNotMountableFile"
		case IOErrorNotMounted: return "IOErrorNotMounted"
		case IOErrorNotRegularFile: return "IOErrorNotRegularFile"
		case IOErrorNotSupported: return "IOErrorNotSupported"
		case IOErrorNotSymbolicLink: return "IOErrorNotSymbolicLink"
		case IOErrorPartialInput: return "IOErrorPartialInput"
		case IOErrorPending: return "IOErrorPending"
		case IOErrorPermissionDenied: return "IOErrorPermissionDenied"
		case IOErrorProxyAuthFailed: return "IOErrorProxyAuthFailed"
		case IOErrorProxyFailed: return "IOErrorProxyFailed"
		case IOErrorProxyNeedAuth: return "IOErrorProxyNeedAuth"
		case IOErrorProxyNotAllowed: return "IOErrorProxyNotAllowed"
		case IOErrorReadOnly: return "IOErrorReadOnly"
		case IOErrorTimedOut: return "IOErrorTimedOut"
		case IOErrorTooManyLinks: return "IOErrorTooManyLinks"
		case IOErrorTooManyOpenFiles: return "IOErrorTooManyOpenFiles"
		case IOErrorWouldBlock: return "IOErrorWouldBlock"
		case IOErrorWouldMerge: return "IOErrorWouldMerge"
		case IOErrorWouldRecurse: return "IOErrorWouldRecurse"
		case IOErrorWrongEtag: return "IOErrorWrongEtag"
		default: return fmt.Sprintf("IOErrorEnum(%d)", e)
	}
}

// IOModuleScopeFlags wraps GIOModuleScopeFlags
//
// Flags for use with g_io_module_scope_new().
type IOModuleScopeFlags C.int

const (
	// IOModuleScopeNone wraps G_IO_MODULE_SCOPE_NONE
	//
	// No module scan flags
	IOModuleScopeNone IOModuleScopeFlags = 0
	// IOModuleScopeBlockDuplicates wraps G_IO_MODULE_SCOPE_BLOCK_DUPLICATES
	//
	// When using this scope to load or
	//     scan modules, automatically block a modules which has the same base
	//     basename as previously loaded module.
	IOModuleScopeBlockDuplicates IOModuleScopeFlags = 1
)

func marshalIOModuleScopeFlags(p unsafe.Pointer) (any, error) {
	return IOModuleScopeFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = IOModuleScopeFlags(0)

func (e IOModuleScopeFlags) GoValueType() gobject.Type {
	return TypeIOModuleScopeFlags
}

func (e IOModuleScopeFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e IOModuleScopeFlags) String() string {
	switch e {
		case IOModuleScopeBlockDuplicates: return "IOModuleScopeBlockDuplicates"
		case IOModuleScopeNone: return "IOModuleScopeNone"
		default: return fmt.Sprintf("IOModuleScopeFlags(%d)", e)
	}
}

// MemoryMonitorWarningLevel wraps GMemoryMonitorWarningLevel
//
// Memory availability warning levels.
// 
// Note that because new values might be added, it is recommended that applications check
// #GMemoryMonitorWarningLevel as ranges, for example:
// |[&lt;!-- language="C" --&gt;
// if (warning_level &gt; G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//   drop_caches ();
// ]|
type MemoryMonitorWarningLevel C.int

const (
	// MemoryMonitorWarningLevelLow wraps G_MEMORY_MONITOR_WARNING_LEVEL_LOW
	//
	// Memory on the device is low, processes
	//   should free up unneeded resources (for example, in-memory caches) so they can
	//   be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium wraps G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM
	//
	// Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW
	//   but the device has even less free memory, so processes should try harder to free
	//   up unneeded resources. If your process does not need to stay running, it is a
	//   good time for it to quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical wraps G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL
	//
	// The system will soon start terminating
	//   processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p unsafe.Pointer) (any, error) {
	return MemoryMonitorWarningLevel(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = MemoryMonitorWarningLevel(0)

func (e MemoryMonitorWarningLevel) GoValueType() gobject.Type {
	return TypeMemoryMonitorWarningLevel
}

func (e MemoryMonitorWarningLevel) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e MemoryMonitorWarningLevel) String() string {
	switch e {
		case MemoryMonitorWarningLevelCritical: return "MemoryMonitorWarningLevelCritical"
		case MemoryMonitorWarningLevelLow: return "MemoryMonitorWarningLevelLow"
		case MemoryMonitorWarningLevelMedium: return "MemoryMonitorWarningLevelMedium"
		default: return fmt.Sprintf("MemoryMonitorWarningLevel(%d)", e)
	}
}

// MountOperationResult wraps GMountOperationResult
//
// #GMountOperationResult is returned as a result when a request for
// information is send by the mounting operation.
type MountOperationResult C.int

const (
	// MountOperationHandled wraps G_MOUNT_OPERATION_HANDLED
	//
	// The request was fulfilled and the
	//     user specified data is now available
	MountOperationHandled MountOperationResult = 0
	// MountOperationAborted wraps G_MOUNT_OPERATION_ABORTED
	//
	// The user requested the mount operation
	//     to be aborted
	MountOperationAborted MountOperationResult = 1
	// MountOperationUnhandled wraps G_MOUNT_OPERATION_UNHANDLED
	//
	// The request was unhandled (i.e. not
	//     implemented)
	MountOperationUnhandled MountOperationResult = 2
)

func marshalMountOperationResult(p unsafe.Pointer) (any, error) {
	return MountOperationResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = MountOperationResult(0)

func (e MountOperationResult) GoValueType() gobject.Type {
	return TypeMountOperationResult
}

func (e MountOperationResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e MountOperationResult) String() string {
	switch e {
		case MountOperationAborted: return "MountOperationAborted"
		case MountOperationHandled: return "MountOperationHandled"
		case MountOperationUnhandled: return "MountOperationUnhandled"
		default: return fmt.Sprintf("MountOperationResult(%d)", e)
	}
}

// NetworkConnectivity wraps GNetworkConnectivity
//
// The host's network connectivity state, as reported by #GNetworkMonitor.
type NetworkConnectivity C.int

const (
	// NetworkConnectivityLocal wraps G_NETWORK_CONNECTIVITY_LOCAL
	//
	// The host is not configured with a
	//   route to the Internet; it may or may not be connected to a local
	//   network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited wraps G_NETWORK_CONNECTIVITY_LIMITED
	//
	// The host is connected to a network, but
	//   does not appear to be able to reach the full Internet, perhaps
	//   due to upstream network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal wraps G_NETWORK_CONNECTIVITY_PORTAL
	//
	// The host is behind a captive portal and
	//   cannot reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull wraps G_NETWORK_CONNECTIVITY_FULL
	//
	// The host is connected to a network, and
	//   appears to be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p unsafe.Pointer) (any, error) {
	return NetworkConnectivity(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = NetworkConnectivity(0)

func (e NetworkConnectivity) GoValueType() gobject.Type {
	return TypeNetworkConnectivity
}

func (e NetworkConnectivity) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e NetworkConnectivity) String() string {
	switch e {
		case NetworkConnectivityFull: return "NetworkConnectivityFull"
		case NetworkConnectivityLimited: return "NetworkConnectivityLimited"
		case NetworkConnectivityLocal: return "NetworkConnectivityLocal"
		case NetworkConnectivityPortal: return "NetworkConnectivityPortal"
		default: return fmt.Sprintf("NetworkConnectivity(%d)", e)
	}
}

// NotificationPriority wraps GNotificationPriority
//
// Priority levels for #GNotifications.
type NotificationPriority C.int

const (
	// NotificationPriorityNormal wraps G_NOTIFICATION_PRIORITY_NORMAL
	//
	// the default priority, to be used for the
	//   majority of notifications (for example email messages, software updates,
	//   completed download/sync operations)
	NotificationPriorityNormal NotificationPriority = 0
	// NotificationPriorityLow wraps G_NOTIFICATION_PRIORITY_LOW
	//
	// for notifications that do not require
	//   immediate attention - typically used for contextual background
	//   information, such as contact birthdays or local weather
	NotificationPriorityLow NotificationPriority = 1
	// NotificationPriorityHigh wraps G_NOTIFICATION_PRIORITY_HIGH
	//
	// for events that require more attention,
	//   usually because responses are time-sensitive (for example chat and SMS
	//   messages or alarms)
	NotificationPriorityHigh NotificationPriority = 2
	// NotificationPriorityUrgent wraps G_NOTIFICATION_PRIORITY_URGENT
	//
	// for urgent notifications, or notifications
	//   that require a response in a short space of time (for example phone calls
	//   or emergency warnings)
	NotificationPriorityUrgent NotificationPriority = 3
)

func marshalNotificationPriority(p unsafe.Pointer) (any, error) {
	return NotificationPriority(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = NotificationPriority(0)

func (e NotificationPriority) GoValueType() gobject.Type {
	return TypeNotificationPriority
}

func (e NotificationPriority) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e NotificationPriority) String() string {
	switch e {
		case NotificationPriorityHigh: return "NotificationPriorityHigh"
		case NotificationPriorityLow: return "NotificationPriorityLow"
		case NotificationPriorityNormal: return "NotificationPriorityNormal"
		case NotificationPriorityUrgent: return "NotificationPriorityUrgent"
		default: return fmt.Sprintf("NotificationPriority(%d)", e)
	}
}

// PasswordSave wraps GPasswordSave
//
// #GPasswordSave is used to indicate the lifespan of a saved password.
// 
// #Gvfs stores passwords in the Gnome keyring when this flag allows it
// to, and later retrieves it again from there.
type PasswordSave C.int

const (
	// PasswordSaveNever wraps G_PASSWORD_SAVE_NEVER
	//
	// never save a password.
	PasswordSaveNever PasswordSave = 0
	// PasswordSaveForSession wraps G_PASSWORD_SAVE_FOR_SESSION
	//
	// save a password for the session.
	PasswordSaveForSession PasswordSave = 1
	// PasswordSavePermanently wraps G_PASSWORD_SAVE_PERMANENTLY
	//
	// save a password permanently.
	PasswordSavePermanently PasswordSave = 2
)

func marshalPasswordSave(p unsafe.Pointer) (any, error) {
	return PasswordSave(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = PasswordSave(0)

func (e PasswordSave) GoValueType() gobject.Type {
	return TypePasswordSave
}

func (e PasswordSave) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e PasswordSave) String() string {
	switch e {
		case PasswordSaveForSession: return "PasswordSaveForSession"
		case PasswordSaveNever: return "PasswordSaveNever"
		case PasswordSavePermanently: return "PasswordSavePermanently"
		default: return fmt.Sprintf("PasswordSave(%d)", e)
	}
}

// PollableReturn wraps GPollableReturn
//
// Return value for various IO operations that signal errors via the
// return value and not necessarily via a #GError.
// 
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for
// regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.
// 
// In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the
// operation to give details about the error that happened.
type PollableReturn C.int

const (
	// PollableReturnFailed wraps G_POLLABLE_RETURN_FAILED
	//
	// Generic error condition for when an operation fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOK wraps G_POLLABLE_RETURN_OK
	//
	// The operation was successfully finished.
	PollableReturnOK PollableReturn = 1
	// PollableReturnWouldBlock wraps G_POLLABLE_RETURN_WOULD_BLOCK
	//
	// The operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p unsafe.Pointer) (any, error) {
	return PollableReturn(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = PollableReturn(0)

func (e PollableReturn) GoValueType() gobject.Type {
	return TypePollableReturn
}

func (e PollableReturn) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e PollableReturn) String() string {
	switch e {
		case PollableReturnFailed: return "PollableReturnFailed"
		case PollableReturnOK: return "PollableReturnOK"
		case PollableReturnWouldBlock: return "PollableReturnWouldBlock"
		default: return fmt.Sprintf("PollableReturn(%d)", e)
	}
}

// ResolverError wraps GResolverError
//
// An error code used with %G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError C.int

const (
	// ResolverErrorNotFound wraps G_RESOLVER_ERROR_NOT_FOUND
	//
	// the requested name/address/service was not
	//     found
	ResolverErrorNotFound ResolverError = 0
	// ResolverErrorTemporaryFailure wraps G_RESOLVER_ERROR_TEMPORARY_FAILURE
	//
	// the requested information could not
	//     be looked up due to a network error or similar problem
	ResolverErrorTemporaryFailure ResolverError = 1
	// ResolverErrorInternal wraps G_RESOLVER_ERROR_INTERNAL
	//
	// unknown error
	ResolverErrorInternal ResolverError = 2
)

func marshalResolverError(p unsafe.Pointer) (any, error) {
	return ResolverError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResolverError(0)

func (e ResolverError) GoValueType() gobject.Type {
	return TypeResolverError
}

func (e ResolverError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResolverError) String() string {
	switch e {
		case ResolverErrorInternal: return "ResolverErrorInternal"
		case ResolverErrorNotFound: return "ResolverErrorNotFound"
		case ResolverErrorTemporaryFailure: return "ResolverErrorTemporaryFailure"
		default: return fmt.Sprintf("ResolverError(%d)", e)
	}
}

// ResolverErrorQuark wraps g_resolver_error_quark
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Gets the #GResolver Error Quark.
func ResolverErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_resolver_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// ResolverRecordType wraps GResolverRecordType
//
// The type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in
// the variant tuples returned.
// 
// %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the
// weight, a `guint16` with the port, and a string of the hostname.
// 
// %G_RESOLVER_RECORD_MX records are returned as variants with the signature
// `(qs)`, representing a `guint16` with the preference, and a string containing
// the mail exchanger hostname.
// 
// %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// `(as)`, representing an array of the strings in the text record. Note: Most TXT
// records only contain a single string, but
// [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a
// record to contain multiple strings. The RFC which defines the interpretation
// of a specific TXT record will likely require concatenation of multiple
// strings if they are present, as with
// [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).
// 
// %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// `(ssuuuuu)`, representing a string containing the primary name server, a
// string containing the administrator, the serial as a `guint32`, the refresh
// interval as a `guint32`, the retry interval as a `guint32`, the expire timeout
// as a `guint32`, and the TTL as a `guint32`.
// 
// %G_RESOLVER_RECORD_NS records are returned as variants with the signature
// `(s)`, representing a string of the hostname of the name server.
type ResolverRecordType C.int

const (
	// ResolverRecordSrv wraps G_RESOLVER_RECORD_SRV
	//
	// look up DNS SRV records for a domain
	ResolverRecordSrv ResolverRecordType = 1
	// ResolverRecordMx wraps G_RESOLVER_RECORD_MX
	//
	// look up DNS MX records for a domain
	ResolverRecordMx ResolverRecordType = 2
	// ResolverRecordTxt wraps G_RESOLVER_RECORD_TXT
	//
	// look up DNS TXT records for a name
	ResolverRecordTxt ResolverRecordType = 3
	// ResolverRecordSoa wraps G_RESOLVER_RECORD_SOA
	//
	// look up DNS SOA records for a zone
	ResolverRecordSoa ResolverRecordType = 4
	// ResolverRecordNs wraps G_RESOLVER_RECORD_NS
	//
	// look up DNS NS records for a domain
	ResolverRecordNs ResolverRecordType = 5
)

func marshalResolverRecordType(p unsafe.Pointer) (any, error) {
	return ResolverRecordType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResolverRecordType(0)

func (e ResolverRecordType) GoValueType() gobject.Type {
	return TypeResolverRecordType
}

func (e ResolverRecordType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResolverRecordType) String() string {
	switch e {
		case ResolverRecordMx: return "ResolverRecordMx"
		case ResolverRecordNs: return "ResolverRecordNs"
		case ResolverRecordSoa: return "ResolverRecordSoa"
		case ResolverRecordSrv: return "ResolverRecordSrv"
		case ResolverRecordTxt: return "ResolverRecordTxt"
		default: return fmt.Sprintf("ResolverRecordType(%d)", e)
	}
}

// ResourceError wraps GResourceError
//
// An error code used with %G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError C.int

const (
	// ResourceErrorNotFound wraps G_RESOURCE_ERROR_NOT_FOUND
	//
	// no file was found at the requested path
	ResourceErrorNotFound ResourceError = 0
	// ResourceErrorInternal wraps G_RESOURCE_ERROR_INTERNAL
	//
	// unknown error
	ResourceErrorInternal ResourceError = 1
)

func marshalResourceError(p unsafe.Pointer) (any, error) {
	return ResourceError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ResourceError(0)

func (e ResourceError) GoValueType() gobject.Type {
	return TypeResourceError
}

func (e ResourceError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ResourceError) String() string {
	switch e {
		case ResourceErrorInternal: return "ResourceErrorInternal"
		case ResourceErrorNotFound: return "ResourceErrorNotFound"
		default: return fmt.Sprintf("ResourceError(%d)", e)
	}
}

// ResourceErrorQuark wraps g_resource_error_quark
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Gets the [struct@Gio.Resource] Error Quark.
func ResourceErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_resource_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// SocketClientEvent wraps GSocketClientEvent
//
// Describes an event occurring on a #GSocketClient. See the
// #GSocketClient::event signal for more details.
// 
// Additional values may be added to this type in the future.
type SocketClientEvent C.int

const (
	// SocketClientResolving wraps G_SOCKET_CLIENT_RESOLVING
	//
	// The client is doing a DNS lookup.
	SocketClientResolving SocketClientEvent = 0
	// SocketClientResolved wraps G_SOCKET_CLIENT_RESOLVED
	//
	// The client has completed a DNS lookup.
	SocketClientResolved SocketClientEvent = 1
	// SocketClientConnecting wraps G_SOCKET_CLIENT_CONNECTING
	//
	// The client is connecting to a remote
	//   host (either a proxy or the destination server).
	SocketClientConnecting SocketClientEvent = 2
	// SocketClientConnected wraps G_SOCKET_CLIENT_CONNECTED
	//
	// The client has connected to a remote
	//   host.
	SocketClientConnected SocketClientEvent = 3
	// SocketClientProxyNegotiating wraps G_SOCKET_CLIENT_PROXY_NEGOTIATING
	//
	// The client is negotiating
	//   with a proxy to connect to the destination server.
	SocketClientProxyNegotiating SocketClientEvent = 4
	// SocketClientProxyNegotiated wraps G_SOCKET_CLIENT_PROXY_NEGOTIATED
	//
	// The client has negotiated
	//   with the proxy server.
	SocketClientProxyNegotiated SocketClientEvent = 5
	// SocketClientTlsHandshaking wraps G_SOCKET_CLIENT_TLS_HANDSHAKING
	//
	// The client is performing a
	//   TLS handshake.
	SocketClientTlsHandshaking SocketClientEvent = 6
	// SocketClientTlsHandshaked wraps G_SOCKET_CLIENT_TLS_HANDSHAKED
	//
	// The client has performed a
	//   TLS handshake.
	SocketClientTlsHandshaked SocketClientEvent = 7
	// SocketClientComplete wraps G_SOCKET_CLIENT_COMPLETE
	//
	// The client is done with a particular
	//   #GSocketConnectable.
	SocketClientComplete SocketClientEvent = 8
)

func marshalSocketClientEvent(p unsafe.Pointer) (any, error) {
	return SocketClientEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketClientEvent(0)

func (e SocketClientEvent) GoValueType() gobject.Type {
	return TypeSocketClientEvent
}

func (e SocketClientEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketClientEvent) String() string {
	switch e {
		case SocketClientComplete: return "SocketClientComplete"
		case SocketClientConnected: return "SocketClientConnected"
		case SocketClientConnecting: return "SocketClientConnecting"
		case SocketClientProxyNegotiated: return "SocketClientProxyNegotiated"
		case SocketClientProxyNegotiating: return "SocketClientProxyNegotiating"
		case SocketClientResolved: return "SocketClientResolved"
		case SocketClientResolving: return "SocketClientResolving"
		case SocketClientTlsHandshaked: return "SocketClientTlsHandshaked"
		case SocketClientTlsHandshaking: return "SocketClientTlsHandshaking"
		default: return fmt.Sprintf("SocketClientEvent(%d)", e)
	}
}

// SocketFamily wraps GSocketFamily
//
// The protocol family of a #GSocketAddress. (These values are
// identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
// if available.)
type SocketFamily C.int

const (
	// SocketFamilyInvalid wraps G_SOCKET_FAMILY_INVALID
	//
	// no address family
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyIpv4 wraps G_SOCKET_FAMILY_IPV4
	//
	// the IPv4 family
	SocketFamilyIpv4 SocketFamily = 2
	// SocketFamilyIpv6 wraps G_SOCKET_FAMILY_IPV6
	//
	// the IPv6 family
	SocketFamilyIpv6 SocketFamily = 10
)

func marshalSocketFamily(p unsafe.Pointer) (any, error) {
	return SocketFamily(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketFamily(0)

func (e SocketFamily) GoValueType() gobject.Type {
	return TypeSocketFamily
}

func (e SocketFamily) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketFamily) String() string {
	switch e {
		case SocketFamilyInvalid: return "SocketFamilyInvalid"
		case SocketFamilyIpv4: return "SocketFamilyIpv4"
		case SocketFamilyIpv6: return "SocketFamilyIpv6"
		default: return fmt.Sprintf("SocketFamily(%d)", e)
	}
}

// SocketListenerEvent wraps GSocketListenerEvent
//
// Describes an event occurring on a #GSocketListener. See the
// #GSocketListener::event signal for more details.
// 
// Additional values may be added to this type in the future.
type SocketListenerEvent C.int

const (
	// SocketListenerBinding wraps G_SOCKET_LISTENER_BINDING
	//
	// The listener is about to bind a socket.
	SocketListenerBinding SocketListenerEvent = 0
	// SocketListenerBound wraps G_SOCKET_LISTENER_BOUND
	//
	// The listener has bound a socket.
	SocketListenerBound SocketListenerEvent = 1
	// SocketListenerListening wraps G_SOCKET_LISTENER_LISTENING
	//
	// The listener is about to start
	//    listening on this socket.
	SocketListenerListening SocketListenerEvent = 2
	// SocketListenerListened wraps G_SOCKET_LISTENER_LISTENED
	//
	// The listener is now listening on
	//   this socket.
	SocketListenerListened SocketListenerEvent = 3
)

func marshalSocketListenerEvent(p unsafe.Pointer) (any, error) {
	return SocketListenerEvent(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketListenerEvent(0)

func (e SocketListenerEvent) GoValueType() gobject.Type {
	return TypeSocketListenerEvent
}

func (e SocketListenerEvent) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketListenerEvent) String() string {
	switch e {
		case SocketListenerBinding: return "SocketListenerBinding"
		case SocketListenerBound: return "SocketListenerBound"
		case SocketListenerListened: return "SocketListenerListened"
		case SocketListenerListening: return "SocketListenerListening"
		default: return fmt.Sprintf("SocketListenerEvent(%d)", e)
	}
}

// SocketProtocol wraps GSocketProtocol
//
// A protocol identifier is specified when creating a #GSocket, which is a
// family/type specific identifier, where 0 means the default protocol for
// the particular family/type.
// 
// This enum contains a set of commonly available and used protocols. You
// can also pass any other identifiers handled by the platform in order to
// use protocols not listed here.
type SocketProtocol C.int

const (
	// SocketProtocolUnknown wraps G_SOCKET_PROTOCOL_UNKNOWN
	//
	// The protocol type is unknown
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault wraps G_SOCKET_PROTOCOL_DEFAULT
	//
	// The default protocol for the family/type
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTcp wraps G_SOCKET_PROTOCOL_TCP
	//
	// TCP over IP
	SocketProtocolTcp SocketProtocol = 6
	// SocketProtocolUdp wraps G_SOCKET_PROTOCOL_UDP
	//
	// UDP over IP
	SocketProtocolUdp SocketProtocol = 17
	// SocketProtocolSctp wraps G_SOCKET_PROTOCOL_SCTP
	//
	// SCTP over IP
	SocketProtocolSctp SocketProtocol = 132
)

func marshalSocketProtocol(p unsafe.Pointer) (any, error) {
	return SocketProtocol(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketProtocol(0)

func (e SocketProtocol) GoValueType() gobject.Type {
	return TypeSocketProtocol
}

func (e SocketProtocol) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketProtocol) String() string {
	switch e {
		case SocketProtocolDefault: return "SocketProtocolDefault"
		case SocketProtocolSctp: return "SocketProtocolSctp"
		case SocketProtocolTcp: return "SocketProtocolTcp"
		case SocketProtocolUdp: return "SocketProtocolUdp"
		case SocketProtocolUnknown: return "SocketProtocolUnknown"
		default: return fmt.Sprintf("SocketProtocol(%d)", e)
	}
}

// SocketType wraps GSocketType
//
// Flags used when creating a #GSocket. Some protocols may not implement
// all the socket types.
type SocketType C.int

const (
	// SocketTypeInvalid wraps G_SOCKET_TYPE_INVALID
	//
	// Type unknown or wrong
	SocketTypeInvalid SocketType = 0
	// SocketTypeStream wraps G_SOCKET_TYPE_STREAM
	//
	// Reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream SocketType = 1
	// SocketTypeDatagram wraps G_SOCKET_TYPE_DATAGRAM
	//
	// Connectionless, unreliable datagram passing.
	//     (e.g. UDP)
	SocketTypeDatagram SocketType = 2
	// SocketTypeSeqpacket wraps G_SOCKET_TYPE_SEQPACKET
	//
	// Reliable connection-based passing of datagrams
	//     of fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket SocketType = 3
)

func marshalSocketType(p unsafe.Pointer) (any, error) {
	return SocketType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = SocketType(0)

func (e SocketType) GoValueType() gobject.Type {
	return TypeSocketType
}

func (e SocketType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e SocketType) String() string {
	switch e {
		case SocketTypeDatagram: return "SocketTypeDatagram"
		case SocketTypeInvalid: return "SocketTypeInvalid"
		case SocketTypeSeqpacket: return "SocketTypeSeqpacket"
		case SocketTypeStream: return "SocketTypeStream"
		default: return fmt.Sprintf("SocketType(%d)", e)
	}
}

// TlsAuthenticationMode wraps GTlsAuthenticationMode
//
// The client authentication mode for a #GTlsServerConnection.
type TlsAuthenticationMode C.int

const (
	// TlsAuthenticationNone wraps G_TLS_AUTHENTICATION_NONE
	//
	// client authentication not required
	TlsAuthenticationNone TlsAuthenticationMode = 0
	// TlsAuthenticationRequested wraps G_TLS_AUTHENTICATION_REQUESTED
	//
	// client authentication is requested
	TlsAuthenticationRequested TlsAuthenticationMode = 1
	// TlsAuthenticationRequired wraps G_TLS_AUTHENTICATION_REQUIRED
	//
	// client authentication is required
	TlsAuthenticationRequired TlsAuthenticationMode = 2
)

func marshalTlsAuthenticationMode(p unsafe.Pointer) (any, error) {
	return TlsAuthenticationMode(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsAuthenticationMode(0)

func (e TlsAuthenticationMode) GoValueType() gobject.Type {
	return TypeTlsAuthenticationMode
}

func (e TlsAuthenticationMode) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsAuthenticationMode) String() string {
	switch e {
		case TlsAuthenticationNone: return "TlsAuthenticationNone"
		case TlsAuthenticationRequested: return "TlsAuthenticationRequested"
		case TlsAuthenticationRequired: return "TlsAuthenticationRequired"
		default: return fmt.Sprintf("TlsAuthenticationMode(%d)", e)
	}
}

// TlsCertificateRequestFlags wraps GTlsCertificateRequestFlags
//
// Flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TlsCertificateRequestFlags C.int

const (
	// TlsCertificateRequestNone wraps G_TLS_CERTIFICATE_REQUEST_NONE
	//
	// No flags
	TlsCertificateRequestNone TlsCertificateRequestFlags = 0
)

func marshalTlsCertificateRequestFlags(p unsafe.Pointer) (any, error) {
	return TlsCertificateRequestFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsCertificateRequestFlags(0)

func (e TlsCertificateRequestFlags) GoValueType() gobject.Type {
	return TypeTlsCertificateRequestFlags
}

func (e TlsCertificateRequestFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsCertificateRequestFlags) String() string {
	switch e {
		case TlsCertificateRequestNone: return "TlsCertificateRequestNone"
		default: return fmt.Sprintf("TlsCertificateRequestFlags(%d)", e)
	}
}

// TlsChannelBindingError wraps GTlsChannelBindingError
//
// An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to
// indicate a TLS channel binding retrieval error.
type TlsChannelBindingError C.int

const (
	// TlsChannelBindingErrorNotImplemented wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED
	//
	// Either entire binding
	//    retrieval facility or specific binding type is not implemented in the
	//    TLS backend.
	TlsChannelBindingErrorNotImplemented TlsChannelBindingError = 0
	// TlsChannelBindingErrorInvalidState wraps G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE
	//
	// The handshake is not yet
	//    complete on the connection which is a strong requirement for any existing
	//    binding type.
	TlsChannelBindingErrorInvalidState TlsChannelBindingError = 1
	// TlsChannelBindingErrorNotAvailable wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE
	//
	// Handshake is complete but
	//    binding data is not available. That normally indicates the TLS
	//    implementation failed to provide the binding data. For example, some
	//    implementations do not provide a peer certificate for resumed connections.
	TlsChannelBindingErrorNotAvailable TlsChannelBindingError = 2
	// TlsChannelBindingErrorNotSupported wraps G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED
	//
	// Binding type is not supported
	//    on the current connection. This error could be triggered when requesting
	//    `tls-server-end-point` binding data for a certificate which has no hash
	//    function or uses multiple hash functions.
	TlsChannelBindingErrorNotSupported TlsChannelBindingError = 3
	// TlsChannelBindingErrorGeneralError wraps G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR
	//
	// Any other backend error
	//    preventing binding data retrieval.
	TlsChannelBindingErrorGeneralError TlsChannelBindingError = 4
)

func marshalTlsChannelBindingError(p unsafe.Pointer) (any, error) {
	return TlsChannelBindingError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsChannelBindingError(0)

func (e TlsChannelBindingError) GoValueType() gobject.Type {
	return TypeTlsChannelBindingError
}

func (e TlsChannelBindingError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsChannelBindingError) String() string {
	switch e {
		case TlsChannelBindingErrorGeneralError: return "TlsChannelBindingErrorGeneralError"
		case TlsChannelBindingErrorInvalidState: return "TlsChannelBindingErrorInvalidState"
		case TlsChannelBindingErrorNotAvailable: return "TlsChannelBindingErrorNotAvailable"
		case TlsChannelBindingErrorNotImplemented: return "TlsChannelBindingErrorNotImplemented"
		case TlsChannelBindingErrorNotSupported: return "TlsChannelBindingErrorNotSupported"
		default: return fmt.Sprintf("TlsChannelBindingError(%d)", e)
	}
}

// TlsChannelBindingErrorQuark wraps g_tls_channel_binding_error_quark
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Gets the TLS channel binding error quark.
func TlsChannelBindingErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_tls_channel_binding_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TlsChannelBindingType wraps GTlsChannelBindingType
//
// The type of TLS channel binding data to retrieve from #GTlsConnection
// or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The
// [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)
// binding type is not currently implemented.
type TlsChannelBindingType C.int

const (
	// TlsChannelBindingTlsUnique wraps G_TLS_CHANNEL_BINDING_TLS_UNIQUE
	//
	// [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding
	//    type
	TlsChannelBindingTlsUnique TlsChannelBindingType = 0
	// TlsChannelBindingTlsServerEndPoint wraps G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT
	//
	// [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)
	//    binding type
	TlsChannelBindingTlsServerEndPoint TlsChannelBindingType = 1
	// TlsChannelBindingTlsExporter wraps G_TLS_CHANNEL_BINDING_TLS_EXPORTER
	//
	// [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding
	//    type. Since: 2.74
	TlsChannelBindingTlsExporter TlsChannelBindingType = 2
)

func marshalTlsChannelBindingType(p unsafe.Pointer) (any, error) {
	return TlsChannelBindingType(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsChannelBindingType(0)

func (e TlsChannelBindingType) GoValueType() gobject.Type {
	return TypeTlsChannelBindingType
}

func (e TlsChannelBindingType) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsChannelBindingType) String() string {
	switch e {
		case TlsChannelBindingTlsExporter: return "TlsChannelBindingTlsExporter"
		case TlsChannelBindingTlsServerEndPoint: return "TlsChannelBindingTlsServerEndPoint"
		case TlsChannelBindingTlsUnique: return "TlsChannelBindingTlsUnique"
		default: return fmt.Sprintf("TlsChannelBindingType(%d)", e)
	}
}

// TlsDatabaseLookupFlags wraps GTlsDatabaseLookupFlags
//
// Flags for g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(),
// and g_tls_database_lookup_certificates_issued_by().
type TlsDatabaseLookupFlags C.int

const (
	// TlsDatabaseLookupNone wraps G_TLS_DATABASE_LOOKUP_NONE
	//
	// No lookup flags
	TlsDatabaseLookupNone TlsDatabaseLookupFlags = 0
	// TlsDatabaseLookupKeypair wraps G_TLS_DATABASE_LOOKUP_KEYPAIR
	//
	// Restrict lookup to certificates that have
	//     a private key.
	TlsDatabaseLookupKeypair TlsDatabaseLookupFlags = 1
)

func marshalTlsDatabaseLookupFlags(p unsafe.Pointer) (any, error) {
	return TlsDatabaseLookupFlags(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsDatabaseLookupFlags(0)

func (e TlsDatabaseLookupFlags) GoValueType() gobject.Type {
	return TypeTlsDatabaseLookupFlags
}

func (e TlsDatabaseLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsDatabaseLookupFlags) String() string {
	switch e {
		case TlsDatabaseLookupKeypair: return "TlsDatabaseLookupKeypair"
		case TlsDatabaseLookupNone: return "TlsDatabaseLookupNone"
		default: return fmt.Sprintf("TlsDatabaseLookupFlags(%d)", e)
	}
}

// TlsError wraps GTlsError
//
// An error code used with %G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TlsError C.int

const (
	// TlsErrorUnavailable wraps G_TLS_ERROR_UNAVAILABLE
	//
	// No TLS provider is available
	TlsErrorUnavailable TlsError = 0
	// TlsErrorMisc wraps G_TLS_ERROR_MISC
	//
	// Miscellaneous TLS error
	TlsErrorMisc TlsError = 1
	// TlsErrorBadCertificate wraps G_TLS_ERROR_BAD_CERTIFICATE
	//
	// The certificate presented could not
	//   be parsed or failed validation.
	TlsErrorBadCertificate TlsError = 2
	// TlsErrorNotTls wraps G_TLS_ERROR_NOT_TLS
	//
	// The TLS handshake failed because the
	//   peer does not seem to be a TLS server.
	TlsErrorNotTls TlsError = 3
	// TlsErrorHandshake wraps G_TLS_ERROR_HANDSHAKE
	//
	// The TLS handshake failed because the
	//   peer's certificate was not acceptable.
	TlsErrorHandshake TlsError = 4
	// TlsErrorCertificateRequired wraps G_TLS_ERROR_CERTIFICATE_REQUIRED
	//
	// The TLS handshake failed because
	//   the server requested a client-side certificate, but none was
	//   provided. See g_tls_connection_set_certificate().
	TlsErrorCertificateRequired TlsError = 5
	// TlsErrorEOF wraps G_TLS_ERROR_EOF
	//
	// The TLS connection was closed without proper
	//   notice, which may indicate an attack. See
	//   g_tls_connection_set_require_close_notify().
	TlsErrorEOF TlsError = 6
	// TlsErrorInappropriateFallback wraps G_TLS_ERROR_INAPPROPRIATE_FALLBACK
	//
	// The TLS handshake failed
	//   because the client sent the fallback SCSV, indicating a protocol
	//   downgrade attack. Since: 2.60
	TlsErrorInappropriateFallback TlsError = 7
	// TlsErrorBadCertificatePassword wraps G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD
	//
	// The certificate failed
	//   to load because a password was incorrect. Since: 2.72
	TlsErrorBadCertificatePassword TlsError = 8
)

func marshalTlsError(p unsafe.Pointer) (any, error) {
	return TlsError(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsError(0)

func (e TlsError) GoValueType() gobject.Type {
	return TypeTlsError
}

func (e TlsError) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsError) String() string {
	switch e {
		case TlsErrorBadCertificate: return "TlsErrorBadCertificate"
		case TlsErrorBadCertificatePassword: return "TlsErrorBadCertificatePassword"
		case TlsErrorCertificateRequired: return "TlsErrorCertificateRequired"
		case TlsErrorEOF: return "TlsErrorEOF"
		case TlsErrorHandshake: return "TlsErrorHandshake"
		case TlsErrorInappropriateFallback: return "TlsErrorInappropriateFallback"
		case TlsErrorMisc: return "TlsErrorMisc"
		case TlsErrorNotTls: return "TlsErrorNotTls"
		case TlsErrorUnavailable: return "TlsErrorUnavailable"
		default: return fmt.Sprintf("TlsError(%d)", e)
	}
}

// TlsErrorQuark wraps g_tls_error_quark
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Gets the TLS error quark.
func TlsErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_tls_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TlsInteractionResult wraps GTlsInteractionResult
//
// #GTlsInteractionResult is returned by various functions in #GTlsInteraction
// when finishing an interaction request.
type TlsInteractionResult C.int

const (
	// TlsInteractionUnhandled wraps G_TLS_INTERACTION_UNHANDLED
	//
	// The interaction was unhandled (i.e. not
	//     implemented).
	TlsInteractionUnhandled TlsInteractionResult = 0
	// TlsInteractionHandled wraps G_TLS_INTERACTION_HANDLED
	//
	// The interaction completed, and resulting data
	//     is available.
	TlsInteractionHandled TlsInteractionResult = 1
	// TlsInteractionFailed wraps G_TLS_INTERACTION_FAILED
	//
	// The interaction has failed, or was cancelled.
	//     and the operation should be aborted.
	TlsInteractionFailed TlsInteractionResult = 2
)

func marshalTlsInteractionResult(p unsafe.Pointer) (any, error) {
	return TlsInteractionResult(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsInteractionResult(0)

func (e TlsInteractionResult) GoValueType() gobject.Type {
	return TypeTlsInteractionResult
}

func (e TlsInteractionResult) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsInteractionResult) String() string {
	switch e {
		case TlsInteractionFailed: return "TlsInteractionFailed"
		case TlsInteractionHandled: return "TlsInteractionHandled"
		case TlsInteractionUnhandled: return "TlsInteractionUnhandled"
		default: return fmt.Sprintf("TlsInteractionResult(%d)", e)
	}
}

// TlsProtocolVersion wraps GTlsProtocolVersion
//
// The TLS or DTLS protocol version used by a #GTlsConnection or
// #GDtlsConnection. The integer values of these versions are sequential
// to ensure newer known protocol versions compare greater than older
// known versions. Any known DTLS protocol version will compare greater
// than any SSL or TLS protocol version. The protocol version may be
// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer
// protocol version that GLib does not yet know about. This means that
// it's possible for an unknown DTLS protocol version to compare less
// than the TLS protocol versions.
type TlsProtocolVersion C.int

const (
	// TlsProtocolVersionUnknown wraps G_TLS_PROTOCOL_VERSION_UNKNOWN
	//
	// No protocol version or unknown protocol version
	TlsProtocolVersionUnknown TlsProtocolVersion = 0
	// TlsProtocolVersionSsl30 wraps G_TLS_PROTOCOL_VERSION_SSL_3_0
	//
	// SSL 3.0, which is insecure and should not be used
	TlsProtocolVersionSsl30 TlsProtocolVersion = 1
	// TlsProtocolVersionTls10 wraps G_TLS_PROTOCOL_VERSION_TLS_1_0
	//
	// TLS 1.0, which is insecure and should not be used
	TlsProtocolVersionTls10 TlsProtocolVersion = 2
	// TlsProtocolVersionTls11 wraps G_TLS_PROTOCOL_VERSION_TLS_1_1
	//
	// TLS 1.1, which is insecure and should not be used
	TlsProtocolVersionTls11 TlsProtocolVersion = 3
	// TlsProtocolVersionTls12 wraps G_TLS_PROTOCOL_VERSION_TLS_1_2
	//
	// TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)
	TlsProtocolVersionTls12 TlsProtocolVersion = 4
	// TlsProtocolVersionTls13 wraps G_TLS_PROTOCOL_VERSION_TLS_1_3
	//
	// TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
	TlsProtocolVersionTls13 TlsProtocolVersion = 5
	// TlsProtocolVersionDtls10 wraps G_TLS_PROTOCOL_VERSION_DTLS_1_0
	//
	// DTLS 1.0, which is insecure and should not be used
	TlsProtocolVersionDtls10 TlsProtocolVersion = 201
	// TlsProtocolVersionDtls12 wraps G_TLS_PROTOCOL_VERSION_DTLS_1_2
	//
	// DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)
	TlsProtocolVersionDtls12 TlsProtocolVersion = 202
)

func marshalTlsProtocolVersion(p unsafe.Pointer) (any, error) {
	return TlsProtocolVersion(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsProtocolVersion(0)

func (e TlsProtocolVersion) GoValueType() gobject.Type {
	return TypeTlsProtocolVersion
}

func (e TlsProtocolVersion) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsProtocolVersion) String() string {
	switch e {
		case TlsProtocolVersionDtls10: return "TlsProtocolVersionDtls10"
		case TlsProtocolVersionDtls12: return "TlsProtocolVersionDtls12"
		case TlsProtocolVersionSsl30: return "TlsProtocolVersionSsl30"
		case TlsProtocolVersionTls10: return "TlsProtocolVersionTls10"
		case TlsProtocolVersionTls11: return "TlsProtocolVersionTls11"
		case TlsProtocolVersionTls12: return "TlsProtocolVersionTls12"
		case TlsProtocolVersionTls13: return "TlsProtocolVersionTls13"
		case TlsProtocolVersionUnknown: return "TlsProtocolVersionUnknown"
		default: return fmt.Sprintf("TlsProtocolVersion(%d)", e)
	}
}

// TlsRehandshakeMode wraps GTlsRehandshakeMode
//
// When to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
type TlsRehandshakeMode C.int

const (
	// TlsRehandshakeNever wraps G_TLS_REHANDSHAKE_NEVER
	//
	// Never allow rehandshaking
	TlsRehandshakeNever TlsRehandshakeMode = 0
	// TlsRehandshakeSafely wraps G_TLS_REHANDSHAKE_SAFELY
	//
	// Allow safe rehandshaking only
	TlsRehandshakeSafely TlsRehandshakeMode = 1
	// TlsRehandshakeUnsafely wraps G_TLS_REHANDSHAKE_UNSAFELY
	//
	// Allow unsafe rehandshaking
	TlsRehandshakeUnsafely TlsRehandshakeMode = 2
)

func marshalTlsRehandshakeMode(p unsafe.Pointer) (any, error) {
	return TlsRehandshakeMode(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = TlsRehandshakeMode(0)

func (e TlsRehandshakeMode) GoValueType() gobject.Type {
	return TypeTlsRehandshakeMode
}

func (e TlsRehandshakeMode) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e TlsRehandshakeMode) String() string {
	switch e {
		case TlsRehandshakeNever: return "TlsRehandshakeNever"
		case TlsRehandshakeSafely: return "TlsRehandshakeSafely"
		case TlsRehandshakeUnsafely: return "TlsRehandshakeUnsafely"
		default: return fmt.Sprintf("TlsRehandshakeMode(%d)", e)
	}
}

// ZlibCompressorFormat wraps GZlibCompressorFormat
//
// Used to select the type of data format to use for #GZlibDecompressor
// and #GZlibCompressor.
type ZlibCompressorFormat C.int

const (
	// ZlibCompressorFormatZlib wraps G_ZLIB_COMPRESSOR_FORMAT_ZLIB
	//
	// deflate compression with zlib header
	ZlibCompressorFormatZlib ZlibCompressorFormat = 0
	// ZlibCompressorFormatGzip wraps G_ZLIB_COMPRESSOR_FORMAT_GZIP
	//
	// gzip file format
	ZlibCompressorFormatGzip ZlibCompressorFormat = 1
	// ZlibCompressorFormatRaw wraps G_ZLIB_COMPRESSOR_FORMAT_RAW
	//
	// deflate compression with no header
	ZlibCompressorFormatRaw ZlibCompressorFormat = 2
)

func marshalZlibCompressorFormat(p unsafe.Pointer) (any, error) {
	return ZlibCompressorFormat(gobject.ValueFromNative(p).Enum()), nil
}

var _ gobject.GoValueInitializer = ZlibCompressorFormat(0)

func (e ZlibCompressorFormat) GoValueType() gobject.Type {
	return TypeZlibCompressorFormat
}

func (e ZlibCompressorFormat) SetGoValue(v *gobject.Value) {
	v.SetEnum(int(e))
}

func (e ZlibCompressorFormat) String() string {
	switch e {
		case ZlibCompressorFormatGzip: return "ZlibCompressorFormatGzip"
		case ZlibCompressorFormatRaw: return "ZlibCompressorFormatRaw"
		case ZlibCompressorFormatZlib: return "ZlibCompressorFormatZlib"
		default: return fmt.Sprintf("ZlibCompressorFormat(%d)", e)
	}
}

// AppInfoCreateFlags wraps GAppInfoCreateFlags
//
// Flags used when creating a #GAppInfo.
type AppInfoCreateFlags C.gint

const (
	// AppInfoCreateNone wraps G_APP_INFO_CREATE_NONE
	//
	// No flags.
	AppInfoCreateNone AppInfoCreateFlags = 0
	// AppInfoCreateNeedsTerminal wraps G_APP_INFO_CREATE_NEEDS_TERMINAL
	//
	// Application opens in a terminal window.
	AppInfoCreateNeedsTerminal AppInfoCreateFlags = 1
	// AppInfoCreateSupportsUris wraps G_APP_INFO_CREATE_SUPPORTS_URIS
	//
	// Application supports URI arguments.
	AppInfoCreateSupportsUris AppInfoCreateFlags = 2
	// AppInfoCreateSupportsStartupNotification wraps G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION
	//
	// Application supports startup notification. Since 2.26
	AppInfoCreateSupportsStartupNotification AppInfoCreateFlags = 4
)

func marshalAppInfoCreateFlags(p unsafe.Pointer) (any, error) {
	return AppInfoCreateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a AppInfoCreateFlags) Has(other AppInfoCreateFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = AppInfoCreateFlags(0)

func (f AppInfoCreateFlags) GoValueType() gobject.Type {
	return TypeAppInfoCreateFlags
}

func (f AppInfoCreateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f AppInfoCreateFlags) String() string {
	if f == 0 {
		return "AppInfoCreateFlags(0)"
	}

	var parts []string
	if (f & AppInfoCreateNone) != 0 {
		parts = append(parts, "AppInfoCreateNone")
	}
	if (f & AppInfoCreateNeedsTerminal) != 0 {
		parts = append(parts, "AppInfoCreateNeedsTerminal")
	}
	if (f & AppInfoCreateSupportsUris) != 0 {
		parts = append(parts, "AppInfoCreateSupportsUris")
	}
	if (f & AppInfoCreateSupportsStartupNotification) != 0 {
		parts = append(parts, "AppInfoCreateSupportsStartupNotification")
	}
	return "AppInfoCreateFlags(" + strings.Join(parts, "|") + ")"
}

// ApplicationFlags wraps GApplicationFlags
//
// Flags used to define the behaviour of a #GApplication.
type ApplicationFlags C.gint

const (
	// ApplicationFlagsNone wraps G_APPLICATION_FLAGS_NONE
	//
	// Default flags.
	//
	// Deprecated: (since 2.74.0) Use [flags@Gio.ApplicationFlags.DEFAULT_FLAGS].
	ApplicationFlagsNone ApplicationFlags = 0
	// ApplicationDefaultFlags wraps G_APPLICATION_DEFAULT_FLAGS
	//
	// Default flags.
	ApplicationDefaultFlags ApplicationFlags = 0
	// ApplicationIsService wraps G_APPLICATION_IS_SERVICE
	//
	// Run as a service. In this mode, registration
	//      fails if the service is already running, and the application
	//      will initially wait up to 10 seconds for an initial activation
	//      message to arrive.
	ApplicationIsService ApplicationFlags = 1
	// ApplicationIsLauncher wraps G_APPLICATION_IS_LAUNCHER
	//
	// Don't try to become the primary instance.
	ApplicationIsLauncher ApplicationFlags = 2
	// ApplicationHandlesOpen wraps G_APPLICATION_HANDLES_OPEN
	//
	// This application handles opening files (in
	//     the primary instance). Note that this flag only affects the default
	//     implementation of local_command_line(), and has no effect if
	//     %G_APPLICATION_HANDLES_COMMAND_LINE is given.
	//     See g_application_run() for details.
	ApplicationHandlesOpen ApplicationFlags = 4
	// ApplicationHandlesCommandLine wraps G_APPLICATION_HANDLES_COMMAND_LINE
	//
	// This application handles command line
	//     arguments (in the primary instance). Note that this flag only affect
	//     the default implementation of local_command_line().
	//     See g_application_run() for details.
	ApplicationHandlesCommandLine ApplicationFlags = 8
	// ApplicationSendEnvironment wraps G_APPLICATION_SEND_ENVIRONMENT
	//
	// Send the environment of the
	//     launching process to the primary instance. Set this flag if your
	//     application is expected to behave differently depending on certain
	//     environment variables. For instance, an editor might be expected
	//     to use the `GIT_COMMITTER_NAME` environment variable
	//     when editing a git commit message. The environment is available
	//     to the #GApplication::command-line signal handler, via
	//     g_application_command_line_getenv().
	ApplicationSendEnvironment ApplicationFlags = 16
	// ApplicationNonUnique wraps G_APPLICATION_NON_UNIQUE
	//
	// Make no attempts to do any of the typical
	//     single-instance application negotiation, even if the application
	//     ID is given.  The application neither attempts to become the
	//     owner of the application ID nor does it check if an existing
	//     owner already exists.  Everything occurs in the local process.
	//     Since: 2.30.
	ApplicationNonUnique ApplicationFlags = 32
	// ApplicationCanOverrideAppID wraps G_APPLICATION_CAN_OVERRIDE_APP_ID
	//
	// Allow users to override the
	//     application ID from the command line with `--gapplication-app-id`.
	//     Since: 2.48
	ApplicationCanOverrideAppID ApplicationFlags = 64
	// ApplicationAllowReplacement wraps G_APPLICATION_ALLOW_REPLACEMENT
	//
	// Allow another instance to take over
	//     the bus name. Since: 2.60
	ApplicationAllowReplacement ApplicationFlags = 128
	// ApplicationReplace wraps G_APPLICATION_REPLACE
	//
	// Take over from another instance. This flag is
	//     usually set by passing `--gapplication-replace` on the commandline.
	//     Since: 2.60
	ApplicationReplace ApplicationFlags = 256
)

func marshalApplicationFlags(p unsafe.Pointer) (any, error) {
	return ApplicationFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a ApplicationFlags) Has(other ApplicationFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = ApplicationFlags(0)

func (f ApplicationFlags) GoValueType() gobject.Type {
	return TypeApplicationFlags
}

func (f ApplicationFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ApplicationFlags) String() string {
	if f == 0 {
		return "ApplicationFlags(0)"
	}

	var parts []string
	if (f & ApplicationFlagsNone) != 0 {
		parts = append(parts, "ApplicationFlagsNone")
	}
	if (f & ApplicationDefaultFlags) != 0 {
		parts = append(parts, "ApplicationDefaultFlags")
	}
	if (f & ApplicationIsService) != 0 {
		parts = append(parts, "ApplicationIsService")
	}
	if (f & ApplicationIsLauncher) != 0 {
		parts = append(parts, "ApplicationIsLauncher")
	}
	if (f & ApplicationHandlesOpen) != 0 {
		parts = append(parts, "ApplicationHandlesOpen")
	}
	if (f & ApplicationHandlesCommandLine) != 0 {
		parts = append(parts, "ApplicationHandlesCommandLine")
	}
	if (f & ApplicationSendEnvironment) != 0 {
		parts = append(parts, "ApplicationSendEnvironment")
	}
	if (f & ApplicationNonUnique) != 0 {
		parts = append(parts, "ApplicationNonUnique")
	}
	if (f & ApplicationCanOverrideAppID) != 0 {
		parts = append(parts, "ApplicationCanOverrideAppID")
	}
	if (f & ApplicationAllowReplacement) != 0 {
		parts = append(parts, "ApplicationAllowReplacement")
	}
	if (f & ApplicationReplace) != 0 {
		parts = append(parts, "ApplicationReplace")
	}
	return "ApplicationFlags(" + strings.Join(parts, "|") + ")"
}

// AskPasswordFlags wraps GAskPasswordFlags
//
// #GAskPasswordFlags are used to request specific information from the
// user, or to notify the user of their choices in an authentication
// situation.
type AskPasswordFlags C.gint

const (
	// AskPasswordNeedPassword wraps G_ASK_PASSWORD_NEED_PASSWORD
	//
	// operation requires a password.
	AskPasswordNeedPassword AskPasswordFlags = 1
	// AskPasswordNeedUsername wraps G_ASK_PASSWORD_NEED_USERNAME
	//
	// operation requires a username.
	AskPasswordNeedUsername AskPasswordFlags = 2
	// AskPasswordNeedDomain wraps G_ASK_PASSWORD_NEED_DOMAIN
	//
	// operation requires a domain.
	AskPasswordNeedDomain AskPasswordFlags = 4
	// AskPasswordSavingSupported wraps G_ASK_PASSWORD_SAVING_SUPPORTED
	//
	// operation supports saving settings.
	AskPasswordSavingSupported AskPasswordFlags = 8
	// AskPasswordAnonymousSupported wraps G_ASK_PASSWORD_ANONYMOUS_SUPPORTED
	//
	// operation supports anonymous users.
	AskPasswordAnonymousSupported AskPasswordFlags = 16
	// AskPasswordTcrypt wraps G_ASK_PASSWORD_TCRYPT
	//
	// operation takes TCRYPT parameters (Since: 2.58)
	AskPasswordTcrypt AskPasswordFlags = 32
)

func marshalAskPasswordFlags(p unsafe.Pointer) (any, error) {
	return AskPasswordFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if a contains other
func (a AskPasswordFlags) Has(other AskPasswordFlags) bool {
	return (a & other) == other
}

var _ gobject.GoValueInitializer = AskPasswordFlags(0)

func (f AskPasswordFlags) GoValueType() gobject.Type {
	return TypeAskPasswordFlags
}

func (f AskPasswordFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f AskPasswordFlags) String() string {
	if f == 0 {
		return "AskPasswordFlags(0)"
	}

	var parts []string
	if (f & AskPasswordNeedPassword) != 0 {
		parts = append(parts, "AskPasswordNeedPassword")
	}
	if (f & AskPasswordNeedUsername) != 0 {
		parts = append(parts, "AskPasswordNeedUsername")
	}
	if (f & AskPasswordNeedDomain) != 0 {
		parts = append(parts, "AskPasswordNeedDomain")
	}
	if (f & AskPasswordSavingSupported) != 0 {
		parts = append(parts, "AskPasswordSavingSupported")
	}
	if (f & AskPasswordAnonymousSupported) != 0 {
		parts = append(parts, "AskPasswordAnonymousSupported")
	}
	if (f & AskPasswordTcrypt) != 0 {
		parts = append(parts, "AskPasswordTcrypt")
	}
	return "AskPasswordFlags(" + strings.Join(parts, "|") + ")"
}

// BusNameOwnerFlags wraps GBusNameOwnerFlags
//
// Flags used in g_bus_own_name().
type BusNameOwnerFlags C.gint

const (
	// BusNameOwnerFlagsNone wraps G_BUS_NAME_OWNER_FLAGS_NONE
	//
	// No flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0
	// BusNameOwnerFlagsAllowReplacement wraps G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT
	//
	// Allow another message bus connection to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 1
	// BusNameOwnerFlagsReplace wraps G_BUS_NAME_OWNER_FLAGS_REPLACE
	//
	// If another message bus connection owns the name and have
	// specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 2
	// BusNameOwnerFlagsDoNotQueue wraps G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE
	//
	// If another message bus connection owns the name, immediately return an error
	// from [func@Gio.bus_own_name] rather than entering the waiting queue for that
	// name.
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 4
)

func marshalBusNameOwnerFlags(p unsafe.Pointer) (any, error) {
	return BusNameOwnerFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BusNameOwnerFlags) Has(other BusNameOwnerFlags) bool {
	return (b & other) == other
}

var _ gobject.GoValueInitializer = BusNameOwnerFlags(0)

func (f BusNameOwnerFlags) GoValueType() gobject.Type {
	return TypeBusNameOwnerFlags
}

func (f BusNameOwnerFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f BusNameOwnerFlags) String() string {
	if f == 0 {
		return "BusNameOwnerFlags(0)"
	}

	var parts []string
	if (f & BusNameOwnerFlagsNone) != 0 {
		parts = append(parts, "BusNameOwnerFlagsNone")
	}
	if (f & BusNameOwnerFlagsAllowReplacement) != 0 {
		parts = append(parts, "BusNameOwnerFlagsAllowReplacement")
	}
	if (f & BusNameOwnerFlagsReplace) != 0 {
		parts = append(parts, "BusNameOwnerFlagsReplace")
	}
	if (f & BusNameOwnerFlagsDoNotQueue) != 0 {
		parts = append(parts, "BusNameOwnerFlagsDoNotQueue")
	}
	return "BusNameOwnerFlags(" + strings.Join(parts, "|") + ")"
}

// BusNameWatcherFlags wraps GBusNameWatcherFlags
//
// Flags used in g_bus_watch_name().
type BusNameWatcherFlags C.gint

const (
	// BusNameWatcherFlagsNone wraps G_BUS_NAME_WATCHER_FLAGS_NONE
	//
	// No flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0
	// BusNameWatcherFlagsAutoStart wraps G_BUS_NAME_WATCHER_FLAGS_AUTO_START
	//
	// If no-one owns the name when
	// beginning to watch the name, ask the bus to launch an owner for the
	// name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 1
)

func marshalBusNameWatcherFlags(p unsafe.Pointer) (any, error) {
	return BusNameWatcherFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BusNameWatcherFlags) Has(other BusNameWatcherFlags) bool {
	return (b & other) == other
}

var _ gobject.GoValueInitializer = BusNameWatcherFlags(0)

func (f BusNameWatcherFlags) GoValueType() gobject.Type {
	return TypeBusNameWatcherFlags
}

func (f BusNameWatcherFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f BusNameWatcherFlags) String() string {
	if f == 0 {
		return "BusNameWatcherFlags(0)"
	}

	var parts []string
	if (f & BusNameWatcherFlagsNone) != 0 {
		parts = append(parts, "BusNameWatcherFlagsNone")
	}
	if (f & BusNameWatcherFlagsAutoStart) != 0 {
		parts = append(parts, "BusNameWatcherFlagsAutoStart")
	}
	return "BusNameWatcherFlags(" + strings.Join(parts, "|") + ")"
}

// ConverterFlags wraps GConverterFlags
//
// Flags used when calling a g_converter_convert().
type ConverterFlags C.gint

const (
	// ConverterNoFlags wraps G_CONVERTER_NO_FLAGS
	//
	// No flags.
	ConverterNoFlags ConverterFlags = 0
	// ConverterInputAtEnd wraps G_CONVERTER_INPUT_AT_END
	//
	// At end of input data
	ConverterInputAtEnd ConverterFlags = 1
	// ConverterFlush wraps G_CONVERTER_FLUSH
	//
	// Flush data
	ConverterFlush ConverterFlags = 2
)

func marshalConverterFlags(p unsafe.Pointer) (any, error) {
	return ConverterFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if c contains other
func (c ConverterFlags) Has(other ConverterFlags) bool {
	return (c & other) == other
}

var _ gobject.GoValueInitializer = ConverterFlags(0)

func (f ConverterFlags) GoValueType() gobject.Type {
	return TypeConverterFlags
}

func (f ConverterFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ConverterFlags) String() string {
	if f == 0 {
		return "ConverterFlags(0)"
	}

	var parts []string
	if (f & ConverterNoFlags) != 0 {
		parts = append(parts, "ConverterNoFlags")
	}
	if (f & ConverterInputAtEnd) != 0 {
		parts = append(parts, "ConverterInputAtEnd")
	}
	if (f & ConverterFlush) != 0 {
		parts = append(parts, "ConverterFlush")
	}
	return "ConverterFlags(" + strings.Join(parts, "|") + ")"
}

// DriveStartFlags wraps GDriveStartFlags
//
// Flags used when starting a drive.
type DriveStartFlags C.gint

const (
	// DriveStartNone wraps G_DRIVE_START_NONE
	//
	// No flags set.
	DriveStartNone DriveStartFlags = 0
)

func marshalDriveStartFlags(p unsafe.Pointer) (any, error) {
	return DriveStartFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if d contains other
func (d DriveStartFlags) Has(other DriveStartFlags) bool {
	return (d & other) == other
}

var _ gobject.GoValueInitializer = DriveStartFlags(0)

func (f DriveStartFlags) GoValueType() gobject.Type {
	return TypeDriveStartFlags
}

func (f DriveStartFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f DriveStartFlags) String() string {
	if f == 0 {
		return "DriveStartFlags(0)"
	}

	var parts []string
	if (f & DriveStartNone) != 0 {
		parts = append(parts, "DriveStartNone")
	}
	return "DriveStartFlags(" + strings.Join(parts, "|") + ")"
}

// FileAttributeInfoFlags wraps GFileAttributeInfoFlags
//
// Flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags C.gint

const (
	// FileAttributeInfoNone wraps G_FILE_ATTRIBUTE_INFO_NONE
	//
	// no flags set.
	FileAttributeInfoNone FileAttributeInfoFlags = 0
	// FileAttributeInfoCopyWithFile wraps G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE
	//
	// copy the attribute values when the file is copied.
	FileAttributeInfoCopyWithFile FileAttributeInfoFlags = 1
	// FileAttributeInfoCopyWhenMoved wraps G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED
	//
	// copy the attribute values when the file is moved.
	FileAttributeInfoCopyWhenMoved FileAttributeInfoFlags = 2
)

func marshalFileAttributeInfoFlags(p unsafe.Pointer) (any, error) {
	return FileAttributeInfoFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileAttributeInfoFlags) Has(other FileAttributeInfoFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileAttributeInfoFlags(0)

func (f FileAttributeInfoFlags) GoValueType() gobject.Type {
	return TypeFileAttributeInfoFlags
}

func (f FileAttributeInfoFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileAttributeInfoFlags) String() string {
	if f == 0 {
		return "FileAttributeInfoFlags(0)"
	}

	var parts []string
	if (f & FileAttributeInfoNone) != 0 {
		parts = append(parts, "FileAttributeInfoNone")
	}
	if (f & FileAttributeInfoCopyWithFile) != 0 {
		parts = append(parts, "FileAttributeInfoCopyWithFile")
	}
	if (f & FileAttributeInfoCopyWhenMoved) != 0 {
		parts = append(parts, "FileAttributeInfoCopyWhenMoved")
	}
	return "FileAttributeInfoFlags(" + strings.Join(parts, "|") + ")"
}

// FileCopyFlags wraps GFileCopyFlags
//
// Flags used when copying or moving files.
type FileCopyFlags C.gint

const (
	// FileCopyNone wraps G_FILE_COPY_NONE
	//
	// No flags set.
	FileCopyNone FileCopyFlags = 0
	// FileCopyOverwrite wraps G_FILE_COPY_OVERWRITE
	//
	// Overwrite any existing files
	FileCopyOverwrite FileCopyFlags = 1
	// FileCopyBackup wraps G_FILE_COPY_BACKUP
	//
	// Make a backup of any existing files.
	FileCopyBackup FileCopyFlags = 2
	// FileCopyNofollowSymlinks wraps G_FILE_COPY_NOFOLLOW_SYMLINKS
	//
	// Don't follow symlinks.
	FileCopyNofollowSymlinks FileCopyFlags = 4
	// FileCopyAllMetadata wraps G_FILE_COPY_ALL_METADATA
	//
	// Copy all file metadata instead of just default set used for copy (see #GFileInfo).
	FileCopyAllMetadata FileCopyFlags = 8
	// FileCopyNoFallbackForMove wraps G_FILE_COPY_NO_FALLBACK_FOR_MOVE
	//
	// Don't use copy and delete fallback if native move not supported.
	FileCopyNoFallbackForMove FileCopyFlags = 16
	// FileCopyTargetDefaultPerms wraps G_FILE_COPY_TARGET_DEFAULT_PERMS
	//
	// Leaves target file with default perms, instead of setting the source file perms.
	FileCopyTargetDefaultPerms FileCopyFlags = 32
	// FileCopyTargetDefaultModifiedTime wraps G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME
	//
	// Use default modification
	//     timestamps instead of copying them from the source file. Since 2.80
	FileCopyTargetDefaultModifiedTime FileCopyFlags = 64
)

func marshalFileCopyFlags(p unsafe.Pointer) (any, error) {
	return FileCopyFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileCopyFlags) Has(other FileCopyFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileCopyFlags(0)

func (f FileCopyFlags) GoValueType() gobject.Type {
	return TypeFileCopyFlags
}

func (f FileCopyFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileCopyFlags) String() string {
	if f == 0 {
		return "FileCopyFlags(0)"
	}

	var parts []string
	if (f & FileCopyNone) != 0 {
		parts = append(parts, "FileCopyNone")
	}
	if (f & FileCopyOverwrite) != 0 {
		parts = append(parts, "FileCopyOverwrite")
	}
	if (f & FileCopyBackup) != 0 {
		parts = append(parts, "FileCopyBackup")
	}
	if (f & FileCopyNofollowSymlinks) != 0 {
		parts = append(parts, "FileCopyNofollowSymlinks")
	}
	if (f & FileCopyAllMetadata) != 0 {
		parts = append(parts, "FileCopyAllMetadata")
	}
	if (f & FileCopyNoFallbackForMove) != 0 {
		parts = append(parts, "FileCopyNoFallbackForMove")
	}
	if (f & FileCopyTargetDefaultPerms) != 0 {
		parts = append(parts, "FileCopyTargetDefaultPerms")
	}
	if (f & FileCopyTargetDefaultModifiedTime) != 0 {
		parts = append(parts, "FileCopyTargetDefaultModifiedTime")
	}
	return "FileCopyFlags(" + strings.Join(parts, "|") + ")"
}

// FileCreateFlags wraps GFileCreateFlags
//
// Flags used when an operation may create a file.
type FileCreateFlags C.gint

const (
	// FileCreateNone wraps G_FILE_CREATE_NONE
	//
	// No flags set.
	FileCreateNone FileCreateFlags = 0
	// FileCreatePrivate wraps G_FILE_CREATE_PRIVATE
	//
	// Create a file that can only be
	//    accessed by the current user.
	FileCreatePrivate FileCreateFlags = 1
	// FileCreateReplaceDestination wraps G_FILE_CREATE_REPLACE_DESTINATION
	//
	// Replace the destination
	//    as if it didn't exist before. Don't try to keep any old
	//    permissions, replace instead of following links. This
	//    is generally useful if you're doing a "copy over"
	//    rather than a "save new version of" replace operation.
	//    You can think of it as "unlink destination" before
	//    writing to it, although the implementation may not
	//    be exactly like that. This flag can only be used with
	//    g_file_replace() and its variants, including g_file_replace_contents().
	//    Since 2.20
	FileCreateReplaceDestination FileCreateFlags = 2
)

func marshalFileCreateFlags(p unsafe.Pointer) (any, error) {
	return FileCreateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileCreateFlags) Has(other FileCreateFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileCreateFlags(0)

func (f FileCreateFlags) GoValueType() gobject.Type {
	return TypeFileCreateFlags
}

func (f FileCreateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileCreateFlags) String() string {
	if f == 0 {
		return "FileCreateFlags(0)"
	}

	var parts []string
	if (f & FileCreateNone) != 0 {
		parts = append(parts, "FileCreateNone")
	}
	if (f & FileCreatePrivate) != 0 {
		parts = append(parts, "FileCreatePrivate")
	}
	if (f & FileCreateReplaceDestination) != 0 {
		parts = append(parts, "FileCreateReplaceDestination")
	}
	return "FileCreateFlags(" + strings.Join(parts, "|") + ")"
}

// FileMeasureFlags wraps GFileMeasureFlags
//
// Flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags C.gint

const (
	// FileMeasureNone wraps G_FILE_MEASURE_NONE
	//
	// No flags set.
	FileMeasureNone FileMeasureFlags = 0
	// FileMeasureReportAnyError wraps G_FILE_MEASURE_REPORT_ANY_ERROR
	//
	// Report any error encountered
	//   while traversing the directory tree.  Normally errors are only
	//   reported for the toplevel file.
	FileMeasureReportAnyError FileMeasureFlags = 2
	// FileMeasureApparentSize wraps G_FILE_MEASURE_APPARENT_SIZE
	//
	// Tally usage based on apparent file
	//   sizes.  Normally, the block-size is used, if available, as this is a
	//   more accurate representation of disk space used.
	//   Compare with `du --apparent-size`.
	//   Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will
	//   ignore the sizes of file types other than regular files and links, as the
	//   sizes of other file types are not specified in a standard way.
	FileMeasureApparentSize FileMeasureFlags = 4
	// FileMeasureNoXdev wraps G_FILE_MEASURE_NO_XDEV
	//
	// Do not cross mount point boundaries.
	//   Compare with `du -x`.
	FileMeasureNoXdev FileMeasureFlags = 8
)

func marshalFileMeasureFlags(p unsafe.Pointer) (any, error) {
	return FileMeasureFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileMeasureFlags) Has(other FileMeasureFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileMeasureFlags(0)

func (f FileMeasureFlags) GoValueType() gobject.Type {
	return TypeFileMeasureFlags
}

func (f FileMeasureFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileMeasureFlags) String() string {
	if f == 0 {
		return "FileMeasureFlags(0)"
	}

	var parts []string
	if (f & FileMeasureNone) != 0 {
		parts = append(parts, "FileMeasureNone")
	}
	if (f & FileMeasureReportAnyError) != 0 {
		parts = append(parts, "FileMeasureReportAnyError")
	}
	if (f & FileMeasureApparentSize) != 0 {
		parts = append(parts, "FileMeasureApparentSize")
	}
	if (f & FileMeasureNoXdev) != 0 {
		parts = append(parts, "FileMeasureNoXdev")
	}
	return "FileMeasureFlags(" + strings.Join(parts, "|") + ")"
}

// FileMonitorFlags wraps GFileMonitorFlags
//
// Flags used to set what a #GFileMonitor will watch for.
type FileMonitorFlags C.gint

const (
	// FileMonitorNone wraps G_FILE_MONITOR_NONE
	//
	// No flags set.
	FileMonitorNone FileMonitorFlags = 0
	// FileMonitorWatchMounts wraps G_FILE_MONITOR_WATCH_MOUNTS
	//
	// Watch for mount events.
	FileMonitorWatchMounts FileMonitorFlags = 1
	// FileMonitorSendMoved wraps G_FILE_MONITOR_SEND_MOVED
	//
	// Pair DELETED and CREATED events caused
	//   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
	//   event instead (NB: not supported on all backends; the default
	//   behaviour -without specifying this flag- is to send single DELETED
	//   and CREATED events).  Deprecated since 2.46: use
	//   %G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorSendMoved FileMonitorFlags = 2
	// FileMonitorWatchHardLinks wraps G_FILE_MONITOR_WATCH_HARD_LINKS
	//
	// Watch for changes to the file made
	//   via another hard link. Since 2.36.
	FileMonitorWatchHardLinks FileMonitorFlags = 4
	// FileMonitorWatchMoves wraps G_FILE_MONITOR_WATCH_MOVES
	//
	// Watch for rename operations on a
	//   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
	//   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
	//   events to be emitted when possible.  Since: 2.46.
	FileMonitorWatchMoves FileMonitorFlags = 8
)

func marshalFileMonitorFlags(p unsafe.Pointer) (any, error) {
	return FileMonitorFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileMonitorFlags) Has(other FileMonitorFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileMonitorFlags(0)

func (f FileMonitorFlags) GoValueType() gobject.Type {
	return TypeFileMonitorFlags
}

func (f FileMonitorFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileMonitorFlags) String() string {
	if f == 0 {
		return "FileMonitorFlags(0)"
	}

	var parts []string
	if (f & FileMonitorNone) != 0 {
		parts = append(parts, "FileMonitorNone")
	}
	if (f & FileMonitorWatchMounts) != 0 {
		parts = append(parts, "FileMonitorWatchMounts")
	}
	if (f & FileMonitorSendMoved) != 0 {
		parts = append(parts, "FileMonitorSendMoved")
	}
	if (f & FileMonitorWatchHardLinks) != 0 {
		parts = append(parts, "FileMonitorWatchHardLinks")
	}
	if (f & FileMonitorWatchMoves) != 0 {
		parts = append(parts, "FileMonitorWatchMoves")
	}
	return "FileMonitorFlags(" + strings.Join(parts, "|") + ")"
}

// FileQueryInfoFlags wraps GFileQueryInfoFlags
//
// Flags used when querying a #GFileInfo.
type FileQueryInfoFlags C.gint

const (
	// FileQueryInfoNone wraps G_FILE_QUERY_INFO_NONE
	//
	// No flags set.
	FileQueryInfoNone FileQueryInfoFlags = 0
	// FileQueryInfoNofollowSymlinks wraps G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
	//
	// Don't follow symlinks.
	FileQueryInfoNofollowSymlinks FileQueryInfoFlags = 1
)

func marshalFileQueryInfoFlags(p unsafe.Pointer) (any, error) {
	return FileQueryInfoFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if f contains other
func (f FileQueryInfoFlags) Has(other FileQueryInfoFlags) bool {
	return (f & other) == other
}

var _ gobject.GoValueInitializer = FileQueryInfoFlags(0)

func (f FileQueryInfoFlags) GoValueType() gobject.Type {
	return TypeFileQueryInfoFlags
}

func (f FileQueryInfoFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f FileQueryInfoFlags) String() string {
	if f == 0 {
		return "FileQueryInfoFlags(0)"
	}

	var parts []string
	if (f & FileQueryInfoNone) != 0 {
		parts = append(parts, "FileQueryInfoNone")
	}
	if (f & FileQueryInfoNofollowSymlinks) != 0 {
		parts = append(parts, "FileQueryInfoNofollowSymlinks")
	}
	return "FileQueryInfoFlags(" + strings.Join(parts, "|") + ")"
}

// IOStreamSpliceFlags wraps GIOStreamSpliceFlags
//
// GIOStreamSpliceFlags determine how streams should be spliced.
type IOStreamSpliceFlags C.gint

const (
	// IOStreamSpliceNone wraps G_IO_STREAM_SPLICE_NONE
	//
	// Do not close either stream.
	IOStreamSpliceNone IOStreamSpliceFlags = 0
	// IOStreamSpliceCloseStream1 wraps G_IO_STREAM_SPLICE_CLOSE_STREAM1
	//
	// Close the first stream after
	//     the splice.
	IOStreamSpliceCloseStream1 IOStreamSpliceFlags = 1
	// IOStreamSpliceCloseStream2 wraps G_IO_STREAM_SPLICE_CLOSE_STREAM2
	//
	// Close the second stream after
	//     the splice.
	IOStreamSpliceCloseStream2 IOStreamSpliceFlags = 2
	// IOStreamSpliceWaitForBoth wraps G_IO_STREAM_SPLICE_WAIT_FOR_BOTH
	//
	// Wait for both splice operations to finish
	//     before calling the callback.
	IOStreamSpliceWaitForBoth IOStreamSpliceFlags = 4
)

func marshalIOStreamSpliceFlags(p unsafe.Pointer) (any, error) {
	return IOStreamSpliceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if i contains other
func (i IOStreamSpliceFlags) Has(other IOStreamSpliceFlags) bool {
	return (i & other) == other
}

var _ gobject.GoValueInitializer = IOStreamSpliceFlags(0)

func (f IOStreamSpliceFlags) GoValueType() gobject.Type {
	return TypeIOStreamSpliceFlags
}

func (f IOStreamSpliceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f IOStreamSpliceFlags) String() string {
	if f == 0 {
		return "IOStreamSpliceFlags(0)"
	}

	var parts []string
	if (f & IOStreamSpliceNone) != 0 {
		parts = append(parts, "IOStreamSpliceNone")
	}
	if (f & IOStreamSpliceCloseStream1) != 0 {
		parts = append(parts, "IOStreamSpliceCloseStream1")
	}
	if (f & IOStreamSpliceCloseStream2) != 0 {
		parts = append(parts, "IOStreamSpliceCloseStream2")
	}
	if (f & IOStreamSpliceWaitForBoth) != 0 {
		parts = append(parts, "IOStreamSpliceWaitForBoth")
	}
	return "IOStreamSpliceFlags(" + strings.Join(parts, "|") + ")"
}

// MountMountFlags wraps GMountMountFlags
//
// Flags used when mounting a mount.
type MountMountFlags C.gint

const (
	// MountMountNone wraps G_MOUNT_MOUNT_NONE
	//
	// No flags set.
	MountMountNone MountMountFlags = 0
)

func marshalMountMountFlags(p unsafe.Pointer) (any, error) {
	return MountMountFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if m contains other
func (m MountMountFlags) Has(other MountMountFlags) bool {
	return (m & other) == other
}

var _ gobject.GoValueInitializer = MountMountFlags(0)

func (f MountMountFlags) GoValueType() gobject.Type {
	return TypeMountMountFlags
}

func (f MountMountFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f MountMountFlags) String() string {
	if f == 0 {
		return "MountMountFlags(0)"
	}

	var parts []string
	if (f & MountMountNone) != 0 {
		parts = append(parts, "MountMountNone")
	}
	return "MountMountFlags(" + strings.Join(parts, "|") + ")"
}

// MountUnmountFlags wraps GMountUnmountFlags
//
// Flags used when an unmounting a mount.
type MountUnmountFlags C.gint

const (
	// MountUnmountNone wraps G_MOUNT_UNMOUNT_NONE
	//
	// No flags set.
	MountUnmountNone MountUnmountFlags = 0
	// MountUnmountForce wraps G_MOUNT_UNMOUNT_FORCE
	//
	// Unmount even if there are outstanding
	//  file operations on the mount.
	MountUnmountForce MountUnmountFlags = 1
)

func marshalMountUnmountFlags(p unsafe.Pointer) (any, error) {
	return MountUnmountFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if m contains other
func (m MountUnmountFlags) Has(other MountUnmountFlags) bool {
	return (m & other) == other
}

var _ gobject.GoValueInitializer = MountUnmountFlags(0)

func (f MountUnmountFlags) GoValueType() gobject.Type {
	return TypeMountUnmountFlags
}

func (f MountUnmountFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f MountUnmountFlags) String() string {
	if f == 0 {
		return "MountUnmountFlags(0)"
	}

	var parts []string
	if (f & MountUnmountNone) != 0 {
		parts = append(parts, "MountUnmountNone")
	}
	if (f & MountUnmountForce) != 0 {
		parts = append(parts, "MountUnmountForce")
	}
	return "MountUnmountFlags(" + strings.Join(parts, "|") + ")"
}

// OutputStreamSpliceFlags wraps GOutputStreamSpliceFlags
//
// GOutputStreamSpliceFlags determine how streams should be spliced.
type OutputStreamSpliceFlags C.gint

const (
	// OutputStreamSpliceNone wraps G_OUTPUT_STREAM_SPLICE_NONE
	//
	// Do not close either stream.
	OutputStreamSpliceNone OutputStreamSpliceFlags = 0
	// OutputStreamSpliceCloseSource wraps G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE
	//
	// Close the source stream after
	//     the splice.
	OutputStreamSpliceCloseSource OutputStreamSpliceFlags = 1
	// OutputStreamSpliceCloseTarget wraps G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET
	//
	// Close the target stream after
	//     the splice.
	OutputStreamSpliceCloseTarget OutputStreamSpliceFlags = 2
)

func marshalOutputStreamSpliceFlags(p unsafe.Pointer) (any, error) {
	return OutputStreamSpliceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if o contains other
func (o OutputStreamSpliceFlags) Has(other OutputStreamSpliceFlags) bool {
	return (o & other) == other
}

var _ gobject.GoValueInitializer = OutputStreamSpliceFlags(0)

func (f OutputStreamSpliceFlags) GoValueType() gobject.Type {
	return TypeOutputStreamSpliceFlags
}

func (f OutputStreamSpliceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f OutputStreamSpliceFlags) String() string {
	if f == 0 {
		return "OutputStreamSpliceFlags(0)"
	}

	var parts []string
	if (f & OutputStreamSpliceNone) != 0 {
		parts = append(parts, "OutputStreamSpliceNone")
	}
	if (f & OutputStreamSpliceCloseSource) != 0 {
		parts = append(parts, "OutputStreamSpliceCloseSource")
	}
	if (f & OutputStreamSpliceCloseTarget) != 0 {
		parts = append(parts, "OutputStreamSpliceCloseTarget")
	}
	return "OutputStreamSpliceFlags(" + strings.Join(parts, "|") + ")"
}

// ResolverNameLookupFlags wraps GResolverNameLookupFlags
//
// Flags to modify lookup behavior.
type ResolverNameLookupFlags C.gint

const (
	// ResolverNameLookupFlagsDefault wraps G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT
	//
	// default behavior (same as g_resolver_lookup_by_name())
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0
	// ResolverNameLookupFlagsIpv4Only wraps G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY
	//
	// only resolve ipv4 addresses
	ResolverNameLookupFlagsIpv4Only ResolverNameLookupFlags = 1
	// ResolverNameLookupFlagsIpv6Only wraps G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY
	//
	// only resolve ipv6 addresses
	ResolverNameLookupFlagsIpv6Only ResolverNameLookupFlags = 2
)

func marshalResolverNameLookupFlags(p unsafe.Pointer) (any, error) {
	return ResolverNameLookupFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResolverNameLookupFlags) Has(other ResolverNameLookupFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResolverNameLookupFlags(0)

func (f ResolverNameLookupFlags) GoValueType() gobject.Type {
	return TypeResolverNameLookupFlags
}

func (f ResolverNameLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResolverNameLookupFlags) String() string {
	if f == 0 {
		return "ResolverNameLookupFlags(0)"
	}

	var parts []string
	if (f & ResolverNameLookupFlagsDefault) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsDefault")
	}
	if (f & ResolverNameLookupFlagsIpv4Only) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsIpv4Only")
	}
	if (f & ResolverNameLookupFlagsIpv6Only) != 0 {
		parts = append(parts, "ResolverNameLookupFlagsIpv6Only")
	}
	return "ResolverNameLookupFlags(" + strings.Join(parts, "|") + ")"
}

// ResourceFlags wraps GResourceFlags
//
// GResourceFlags give information about a particular file inside a resource
// bundle.
type ResourceFlags C.gint

const (
	// ResourceFlagsNone wraps G_RESOURCE_FLAGS_NONE
	//
	// No flags set.
	ResourceFlagsNone ResourceFlags = 0
	// ResourceFlagsCompressed wraps G_RESOURCE_FLAGS_COMPRESSED
	//
	// The file is compressed.
	ResourceFlagsCompressed ResourceFlags = 1
)

func marshalResourceFlags(p unsafe.Pointer) (any, error) {
	return ResourceFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResourceFlags) Has(other ResourceFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResourceFlags(0)

func (f ResourceFlags) GoValueType() gobject.Type {
	return TypeResourceFlags
}

func (f ResourceFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResourceFlags) String() string {
	if f == 0 {
		return "ResourceFlags(0)"
	}

	var parts []string
	if (f & ResourceFlagsNone) != 0 {
		parts = append(parts, "ResourceFlagsNone")
	}
	if (f & ResourceFlagsCompressed) != 0 {
		parts = append(parts, "ResourceFlagsCompressed")
	}
	return "ResourceFlags(" + strings.Join(parts, "|") + ")"
}

// ResourceLookupFlags wraps GResourceLookupFlags
//
// GResourceLookupFlags determine how resource path lookups are handled.
type ResourceLookupFlags C.gint

const (
	// ResourceLookupFlagsNone wraps G_RESOURCE_LOOKUP_FLAGS_NONE
	//
	// No flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0
)

func marshalResourceLookupFlags(p unsafe.Pointer) (any, error) {
	return ResourceLookupFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if r contains other
func (r ResourceLookupFlags) Has(other ResourceLookupFlags) bool {
	return (r & other) == other
}

var _ gobject.GoValueInitializer = ResourceLookupFlags(0)

func (f ResourceLookupFlags) GoValueType() gobject.Type {
	return TypeResourceLookupFlags
}

func (f ResourceLookupFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f ResourceLookupFlags) String() string {
	if f == 0 {
		return "ResourceLookupFlags(0)"
	}

	var parts []string
	if (f & ResourceLookupFlagsNone) != 0 {
		parts = append(parts, "ResourceLookupFlagsNone")
	}
	return "ResourceLookupFlags(" + strings.Join(parts, "|") + ")"
}

// SettingsBindFlags wraps GSettingsBindFlags
//
// Flags used when creating a binding.
// 
// These flags determine in which direction the binding works. The default is to
// synchronize in both directions.
type SettingsBindFlags C.gint

const (
	// SettingsBindDefault wraps G_SETTINGS_BIND_DEFAULT
	//
	// Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
	SettingsBindDefault SettingsBindFlags = 0
	// SettingsBindGet wraps G_SETTINGS_BIND_GET
	//
	// Update the [class@GObject.Object] property when the setting changes.
	//   It is an error to use this flag if the property is not writable.
	SettingsBindGet SettingsBindFlags = 1
	// SettingsBindSet wraps G_SETTINGS_BIND_SET
	//
	// Update the setting when the [class@GObject.Object] property changes.
	//   It is an error to use this flag if the property is not readable.
	SettingsBindSet SettingsBindFlags = 2
	// SettingsBindNoSensitivity wraps G_SETTINGS_BIND_NO_SENSITIVITY
	//
	// Do not try to bind a &#x2018;sensitivity&#x2019; property to the writability of the setting
	SettingsBindNoSensitivity SettingsBindFlags = 4
	// SettingsBindGetNoChanges wraps G_SETTINGS_BIND_GET_NO_CHANGES
	//
	// When set in addition to [flags@Gio.SettingsBindFlags.GET],
	//   set the [class@GObject.Object] property
	//   value initially from the setting, but do not listen for changes of the setting
	SettingsBindGetNoChanges SettingsBindFlags = 8
	// SettingsBindInvertBoolean wraps G_SETTINGS_BIND_INVERT_BOOLEAN
	//
	// When passed to [method@Gio.Settings.bind],
	//   uses a pair of mapping functions that invert
	//   the boolean value when mapping between the setting and the property.  The setting and property must both
	//   be booleans.  You cannot pass this flag to [method@Gio.Settings.bind_with_mapping].
	SettingsBindInvertBoolean SettingsBindFlags = 16
)

func marshalSettingsBindFlags(p unsafe.Pointer) (any, error) {
	return SettingsBindFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if s contains other
func (s SettingsBindFlags) Has(other SettingsBindFlags) bool {
	return (s & other) == other
}

var _ gobject.GoValueInitializer = SettingsBindFlags(0)

func (f SettingsBindFlags) GoValueType() gobject.Type {
	return TypeSettingsBindFlags
}

func (f SettingsBindFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f SettingsBindFlags) String() string {
	if f == 0 {
		return "SettingsBindFlags(0)"
	}

	var parts []string
	if (f & SettingsBindDefault) != 0 {
		parts = append(parts, "SettingsBindDefault")
	}
	if (f & SettingsBindGet) != 0 {
		parts = append(parts, "SettingsBindGet")
	}
	if (f & SettingsBindSet) != 0 {
		parts = append(parts, "SettingsBindSet")
	}
	if (f & SettingsBindNoSensitivity) != 0 {
		parts = append(parts, "SettingsBindNoSensitivity")
	}
	if (f & SettingsBindGetNoChanges) != 0 {
		parts = append(parts, "SettingsBindGetNoChanges")
	}
	if (f & SettingsBindInvertBoolean) != 0 {
		parts = append(parts, "SettingsBindInvertBoolean")
	}
	return "SettingsBindFlags(" + strings.Join(parts, "|") + ")"
}

// SocketMsgFlags wraps GSocketMsgFlags
//
// Flags used in g_socket_receive_message() and g_socket_send_message().
// The flags listed in the enum are some commonly available flags, but the
// values used for them are the same as on the platform, and any other flags
// are passed in/out as is. So to use a platform specific flag, just include
// the right system header and pass in the flag.
type SocketMsgFlags C.gint

const (
	// SocketMsgNone wraps G_SOCKET_MSG_NONE
	//
	// No flags.
	SocketMsgNone SocketMsgFlags = 0
	// SocketMsgOob wraps G_SOCKET_MSG_OOB
	//
	// Request to send/receive out of band data.
	SocketMsgOob SocketMsgFlags = 1
	// SocketMsgPeek wraps G_SOCKET_MSG_PEEK
	//
	// Read data from the socket without removing it from
	//     the queue.
	SocketMsgPeek SocketMsgFlags = 2
	// SocketMsgDontroute wraps G_SOCKET_MSG_DONTROUTE
	//
	// Don't use a gateway to send out the packet,
	//     only send to hosts on directly connected networks.
	SocketMsgDontroute SocketMsgFlags = 4
)

func marshalSocketMsgFlags(p unsafe.Pointer) (any, error) {
	return SocketMsgFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if s contains other
func (s SocketMsgFlags) Has(other SocketMsgFlags) bool {
	return (s & other) == other
}

var _ gobject.GoValueInitializer = SocketMsgFlags(0)

func (f SocketMsgFlags) GoValueType() gobject.Type {
	return TypeSocketMsgFlags
}

func (f SocketMsgFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f SocketMsgFlags) String() string {
	if f == 0 {
		return "SocketMsgFlags(0)"
	}

	var parts []string
	if (f & SocketMsgNone) != 0 {
		parts = append(parts, "SocketMsgNone")
	}
	if (f & SocketMsgOob) != 0 {
		parts = append(parts, "SocketMsgOob")
	}
	if (f & SocketMsgPeek) != 0 {
		parts = append(parts, "SocketMsgPeek")
	}
	if (f & SocketMsgDontroute) != 0 {
		parts = append(parts, "SocketMsgDontroute")
	}
	return "SocketMsgFlags(" + strings.Join(parts, "|") + ")"
}

// TlsCertificateFlags wraps GTlsCertificateFlags
//
// A set of flags describing TLS certification validation. This can be
// used to describe why a particular certificate was rejected (for
// example, in #GTlsConnection::accept-certificate).
// 
// GLib guarantees that if certificate verification fails, at least one
// flag will be set, but it does not guarantee that all possible flags
// will be set. Accordingly, you may not safely decide to ignore any
// particular type of error. For example, it would be incorrect to mask
// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
// because this could potentially be the only error flag set even if
// other problems exist with the certificate.
type TlsCertificateFlags C.gint

const (
	// TlsCertificateNoFlags wraps G_TLS_CERTIFICATE_NO_FLAGS
	//
	// No flags set. Since: 2.74
	TlsCertificateNoFlags TlsCertificateFlags = 0
	// TlsCertificateUnknownCa wraps G_TLS_CERTIFICATE_UNKNOWN_CA
	//
	// The signing certificate authority is
	//   not known.
	TlsCertificateUnknownCa TlsCertificateFlags = 1
	// TlsCertificateBadIdentity wraps G_TLS_CERTIFICATE_BAD_IDENTITY
	//
	// The certificate does not match the
	//   expected identity of the site that it was retrieved from.
	TlsCertificateBadIdentity TlsCertificateFlags = 2
	// TlsCertificateNotActivated wraps G_TLS_CERTIFICATE_NOT_ACTIVATED
	//
	// The certificate's activation time
	//   is still in the future
	TlsCertificateNotActivated TlsCertificateFlags = 4
	// TlsCertificateExpired wraps G_TLS_CERTIFICATE_EXPIRED
	//
	// The certificate has expired
	TlsCertificateExpired TlsCertificateFlags = 8
	// TlsCertificateRevoked wraps G_TLS_CERTIFICATE_REVOKED
	//
	// The certificate has been revoked
	//   according to the #GTlsConnection's certificate revocation list.
	TlsCertificateRevoked TlsCertificateFlags = 16
	// TlsCertificateInsecure wraps G_TLS_CERTIFICATE_INSECURE
	//
	// The certificate's algorithm is
	//   considered insecure.
	TlsCertificateInsecure TlsCertificateFlags = 32
	// TlsCertificateGenericError wraps G_TLS_CERTIFICATE_GENERIC_ERROR
	//
	// Some other error occurred validating
	//   the certificate
	TlsCertificateGenericError TlsCertificateFlags = 64
	// TlsCertificateValidateAll wraps G_TLS_CERTIFICATE_VALIDATE_ALL
	//
	// the combination of all of the above
	//   flags
	TlsCertificateValidateAll TlsCertificateFlags = 127
)

func marshalTlsCertificateFlags(p unsafe.Pointer) (any, error) {
	return TlsCertificateFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsCertificateFlags) Has(other TlsCertificateFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsCertificateFlags(0)

func (f TlsCertificateFlags) GoValueType() gobject.Type {
	return TypeTlsCertificateFlags
}

func (f TlsCertificateFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsCertificateFlags) String() string {
	if f == 0 {
		return "TlsCertificateFlags(0)"
	}

	var parts []string
	if (f & TlsCertificateNoFlags) != 0 {
		parts = append(parts, "TlsCertificateNoFlags")
	}
	if (f & TlsCertificateUnknownCa) != 0 {
		parts = append(parts, "TlsCertificateUnknownCa")
	}
	if (f & TlsCertificateBadIdentity) != 0 {
		parts = append(parts, "TlsCertificateBadIdentity")
	}
	if (f & TlsCertificateNotActivated) != 0 {
		parts = append(parts, "TlsCertificateNotActivated")
	}
	if (f & TlsCertificateExpired) != 0 {
		parts = append(parts, "TlsCertificateExpired")
	}
	if (f & TlsCertificateRevoked) != 0 {
		parts = append(parts, "TlsCertificateRevoked")
	}
	if (f & TlsCertificateInsecure) != 0 {
		parts = append(parts, "TlsCertificateInsecure")
	}
	if (f & TlsCertificateGenericError) != 0 {
		parts = append(parts, "TlsCertificateGenericError")
	}
	if (f & TlsCertificateValidateAll) != 0 {
		parts = append(parts, "TlsCertificateValidateAll")
	}
	return "TlsCertificateFlags(" + strings.Join(parts, "|") + ")"
}

// TlsDatabaseVerifyFlags wraps GTlsDatabaseVerifyFlags
//
// Flags for g_tls_database_verify_chain().
type TlsDatabaseVerifyFlags C.gint

const (
	// TlsDatabaseVerifyNone wraps G_TLS_DATABASE_VERIFY_NONE
	//
	// No verification flags
	TlsDatabaseVerifyNone TlsDatabaseVerifyFlags = 0
)

func marshalTlsDatabaseVerifyFlags(p unsafe.Pointer) (any, error) {
	return TlsDatabaseVerifyFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsDatabaseVerifyFlags) Has(other TlsDatabaseVerifyFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsDatabaseVerifyFlags(0)

func (f TlsDatabaseVerifyFlags) GoValueType() gobject.Type {
	return TypeTlsDatabaseVerifyFlags
}

func (f TlsDatabaseVerifyFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsDatabaseVerifyFlags) String() string {
	if f == 0 {
		return "TlsDatabaseVerifyFlags(0)"
	}

	var parts []string
	if (f & TlsDatabaseVerifyNone) != 0 {
		parts = append(parts, "TlsDatabaseVerifyNone")
	}
	return "TlsDatabaseVerifyFlags(" + strings.Join(parts, "|") + ")"
}

// TlsPasswordFlags wraps GTlsPasswordFlags
//
// Various flags for the password.
type TlsPasswordFlags C.gint

const (
	// TlsPasswordNone wraps G_TLS_PASSWORD_NONE
	//
	// No flags
	TlsPasswordNone TlsPasswordFlags = 0
	// TlsPasswordRetry wraps G_TLS_PASSWORD_RETRY
	//
	// The password was wrong, and the user should retry.
	TlsPasswordRetry TlsPasswordFlags = 2
	// TlsPasswordManyTries wraps G_TLS_PASSWORD_MANY_TRIES
	//
	// Hint to the user that the password has been
	//    wrong many times, and the user may not have many chances left.
	TlsPasswordManyTries TlsPasswordFlags = 4
	// TlsPasswordFinalTry wraps G_TLS_PASSWORD_FINAL_TRY
	//
	// Hint to the user that this is the last try to get
	//    this password right.
	TlsPasswordFinalTry TlsPasswordFlags = 8
	// TlsPasswordPkcs11User wraps G_TLS_PASSWORD_PKCS11_USER
	//
	// For PKCS #11, the user PIN is required.
	//    Since: 2.70.
	TlsPasswordPkcs11User TlsPasswordFlags = 16
	// TlsPasswordPkcs11SecurityOfficer wraps G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER
	//
	// For PKCS #11, the security officer
	//    PIN is required. Since: 2.70.
	TlsPasswordPkcs11SecurityOfficer TlsPasswordFlags = 32
	// TlsPasswordPkcs11ContextSpecific wraps G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC
	//
	// For PKCS #11, the context-specific
	//    PIN is required. Since: 2.70.
	TlsPasswordPkcs11ContextSpecific TlsPasswordFlags = 64
)

func marshalTlsPasswordFlags(p unsafe.Pointer) (any, error) {
	return TlsPasswordFlags(gobject.ValueFromNative(p).Flags()), nil
}
// Has returns true if t contains other
func (t TlsPasswordFlags) Has(other TlsPasswordFlags) bool {
	return (t & other) == other
}

var _ gobject.GoValueInitializer = TlsPasswordFlags(0)

func (f TlsPasswordFlags) GoValueType() gobject.Type {
	return TypeTlsPasswordFlags
}

func (f TlsPasswordFlags) SetGoValue(v *gobject.Value) {
	v.SetFlags(int(f))
}

func (f TlsPasswordFlags) String() string {
	if f == 0 {
		return "TlsPasswordFlags(0)"
	}

	var parts []string
	if (f & TlsPasswordNone) != 0 {
		parts = append(parts, "TlsPasswordNone")
	}
	if (f & TlsPasswordRetry) != 0 {
		parts = append(parts, "TlsPasswordRetry")
	}
	if (f & TlsPasswordManyTries) != 0 {
		parts = append(parts, "TlsPasswordManyTries")
	}
	if (f & TlsPasswordFinalTry) != 0 {
		parts = append(parts, "TlsPasswordFinalTry")
	}
	if (f & TlsPasswordPkcs11User) != 0 {
		parts = append(parts, "TlsPasswordPkcs11User")
	}
	if (f & TlsPasswordPkcs11SecurityOfficer) != 0 {
		parts = append(parts, "TlsPasswordPkcs11SecurityOfficer")
	}
	if (f & TlsPasswordPkcs11ContextSpecific) != 0 {
		parts = append(parts, "TlsPasswordPkcs11ContextSpecific")
	}
	return "TlsPasswordFlags(" + strings.Join(parts, "|") + ")"
}

// AsyncReadyCallback wraps GAsyncReadyCallback
// 
// The function takes the following parameters:
// 
// 	- sourceObject gobject.Object (nullable): the object the asynchronous operation was started with. 
// 	- res AsyncResult: a #GAsyncResult. 
//
// Type definition for a function that will be called back when an asynchronous
// operation within GIO has been completed. #GAsyncReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later
// iteration of the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// where the #GTask was created. All other users of
// #GAsyncReadyCallback must likewise call it asynchronously in a
// later iteration of the main context.
// 
// The asynchronous operation is guaranteed to have held a reference to
// @source_object from the time when the `*_async()` function was called, until
// after this callback returns.
type AsyncReadyCallback func(sourceObject gobject.Object, res AsyncResult)

// VfsFileLookupFunc wraps GVfsFileLookupFunc
// 
// The function takes the following parameters:
// 
// 	- vfs Vfs: a #GVfs 
// 	- identifier string: the identifier to look up a #GFile for. This can either
//     be a URI or a parse name as returned by g_file_get_parse_name() 
// 
// The function returns the following values:
// 
// 	- goret File (nullable) 
//
// This function type is used by g_vfs_register_uri_scheme() to make it
// possible for a client to associate a URI scheme to a different #GFile
// implementation.
// 
// The client should return a reference to the new file that has been
// created for @uri, or %NULL to continue with the default implementation.
type VfsFileLookupFunc func(vfs Vfs, identifier string) (goret File)

// BusGet wraps g_bus_get
// 
// The function takes the following parameters:
// 
// 	- busType BusType: a #GBusType 
// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
//
// Asynchronously connects to the message bus specified by @bus_type.
// 
// When the operation is finished, @callback will be invoked. You can
// then call g_bus_get_finish() to get the result of the operation.
// 
// This is an asynchronous failable function. See g_bus_get_sync() for
// the synchronous version.
func BusGet(busType BusType, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 C.GBusType            // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = C.GBusType(busType)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_bus_get(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// BusUnownName wraps g_bus_unown_name
// 
// The function takes the following parameters:
// 
// 	- ownerId uint: an identifier obtained from [func@Gio.bus_own_name] 
//
// Stops owning a name.
// 
// Note that there may still be D-Bus traffic to process (relating to owning
// and unowning the name) in the current thread-default
// [struct@GLib.MainContext] after this function has returned. You should
// continue to iterate the [struct@GLib.MainContext] until the
// [callback@GLib.DestroyNotify] function passed to [func@Gio.bus_own_name] is
// called, in order to avoid memory leaks through callbacks queued on the
// [struct@GLib.MainContext] after it&#x2019;s stopped being iterated.
func BusUnownName(ownerId uint) {
	var carg1 C.guint // in, none, casted

	carg1 = C.guint(ownerId)

	C.g_bus_unown_name(carg1)
	runtime.KeepAlive(ownerId)
}

// BusUnwatchName wraps g_bus_unwatch_name
// 
// The function takes the following parameters:
// 
// 	- watcherId uint: An identifier obtained from g_bus_watch_name() 
//
// Stops watching a name.
// 
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default #GMainContext after
// this function has returned. You should continue to iterate the #GMainContext
// until the #GDestroyNotify function passed to g_bus_watch_name() is called, in
// order to avoid memory leaks through callbacks queued on the #GMainContext
// after it&#x2019;s stopped being iterated.
func BusUnwatchName(watcherId uint) {
	var carg1 C.guint // in, none, casted

	carg1 = C.guint(watcherId)

	C.g_bus_unwatch_name(carg1)
	runtime.KeepAlive(watcherId)
}

// ContentTypeCanBeExecutable wraps g_content_type_can_be_executable
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a content type can be executable. Note that for instance
// things like text files can be executables (i.e. scripts and batch files).
func ContentTypeCanBeExecutable(typ string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_can_be_executable(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeEquals wraps g_content_type_equals
// 
// The function takes the following parameters:
// 
// 	- type1 string: a content type string 
// 	- type2 string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Compares two content types for equality.
func ContentTypeEquals(type1 string, type2 string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(type1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(type2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_equals(carg1, carg2)
	runtime.KeepAlive(type1)
	runtime.KeepAlive(type2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeFromMimeType wraps g_content_type_from_mime_type
// 
// The function takes the following parameters:
// 
// 	- mimeType string: a mime type string 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Tries to find a content type based on the mime type name.
func ContentTypeFromMimeType(mimeType string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_from_mime_type(carg1)
	runtime.KeepAlive(mimeType)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetDescription wraps g_content_type_get_description
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the human readable description of the content type.
func ContentTypeGetDescription(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_description(carg1)
	runtime.KeepAlive(typ)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGetGenericIconName wraps g_content_type_get_generic_icon_name
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the generic icon name for a content type.
// 
// See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on the generic icon name.
func ContentTypeGetGenericIconName(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_generic_icon_name(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetIcon wraps g_content_type_get_icon
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the icon for a content type.
func ContentTypeGetIcon(typ string) Icon {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_icon(carg1)
	runtime.KeepAlive(typ)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGetMimeDirs wraps g_content_type_get_mime_dirs
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Get the list of directories which MIME data is loaded from. See
// g_content_type_set_mime_dirs() for details.
func ContentTypeGetMimeDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_content_type_get_mime_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// ContentTypeGetMimeType wraps g_content_type_get_mime_type
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the mime type for the content type, if one is registered.
func ContentTypeGetMimeType(typ string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_mime_type(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ContentTypeGetSymbolicIcon wraps g_content_type_get_symbolic_icon
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the symbolic icon for a content type.
func ContentTypeGetSymbolicIcon(typ string) Icon {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_get_symbolic_icon(carg1)
	runtime.KeepAlive(typ)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ContentTypeGuess wraps g_content_type_guess
// 
// The function takes the following parameters:
// 
// 	- filename string (nullable): a path, or %NULL 
// 	- data []byte (nullable): a stream of data, or %NULL 
// 
// The function returns the following values:
// 
// 	- resultUncertain bool: return location for the certainty
//     of the result, or %NULL 
// 	- goret string 
//
// Guesses the content type based on example data. If the function is
// uncertain, @result_uncertain will be set to %TRUE. Either @filename
// or @data may be %NULL, in which case the guess will be based solely
// on the other argument.
func ContentTypeGuess(filename string, data []byte) (bool, string) {
	var carg1 *C.gchar   // in, none, string, nullable-string
	var carg2 *C.guchar  // in, transfer: none, C Pointers: 1, Name: array[guchar], nullable, array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize    // implicit
	var carg4 C.gboolean // out
	var cret  *C.gchar   // return, full, string

	if filename != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = data
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_content_type_guess(carg1, carg2, carg3, &carg4)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(data)

	var resultUncertain bool
	var goret           string

	if carg4 != 0 {
		resultUncertain = true
	}
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return resultUncertain, goret
}

// ContentTypeGuessForTree wraps g_content_type_guess_for_tree
// 
// The function takes the following parameters:
// 
// 	- root File: the root of the tree to guess a type for 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Tries to guess the type of the tree with root @root, by
// looking at the files it contains. The result is an array
// of content types, with the best guess coming first.
// 
// The types returned all have the form x-content/foo, e.g.
// x-content/audio-cdda (for audio CDs) or x-content/image-dcf
// (for a camera memory card). See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
// 
// This function is useful in the implementation of
// g_mount_guess_content_type().
func ContentTypeGuessForTree(root File) []string {
	var carg1 *C.GFile  // in, none, converted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.GFile)(UnsafeFileToGlibNone(root))

	cret = C.g_content_type_guess_for_tree(carg1)
	runtime.KeepAlive(root)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ContentTypeIsA wraps g_content_type_is_a
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 	- supertype string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if @type is a subset of @supertype.
func ContentTypeIsA(typ string, supertype string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(supertype)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_is_a(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeIsMimeType wraps g_content_type_is_mime_type
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 	- mimeType string: a mime type string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if @type is a subset of @mime_type.
// Convenience wrapper around g_content_type_is_a().
func ContentTypeIsMimeType(typ string, mimeType string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_content_type_is_mime_type(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(mimeType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeIsUnknown wraps g_content_type_is_unknown
// 
// The function takes the following parameters:
// 
// 	- typ string: a content type string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the content type is the generic "unknown" type.
// On UNIX this is the "application/octet-stream" mimetype,
// while on win32 it is "*" and on OSX it is a dynamic type
// or octet-stream.
func ContentTypeIsUnknown(typ string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_content_type_is_unknown(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ContentTypeSetMimeDirs wraps g_content_type_set_mime_dirs
// 
// The function takes the following parameters:
// 
// 	- dirs []string (nullable): %NULL-terminated list of
//    directories to load MIME data from, including any `mime/` subdirectory,
//    and with the first directory to try listed first 
//
// Set the list of directories used by GIO to load the MIME database.
// If @dirs is %NULL, the directories used are the default:
// 
//  - the `mime` subdirectory of the directory in `$XDG_DATA_HOME`
//  - the `mime` subdirectory of every directory in `$XDG_DATA_DIRS`
// 
// This function is intended to be used when writing tests that depend on
// information stored in the MIME database, in order to control the data.
// 
// Typically, in case your tests use %G_TEST_OPTION_ISOLATE_DIRS, but they
// depend on the system&#x2019;s MIME database, you should call this function
// with @dirs set to %NULL before calling g_test_init(), for instance:
// 
// |[&lt;!-- language="C" --&gt;
//   // Load MIME data from the system
//   g_content_type_set_mime_dirs (NULL);
//   // Isolate the environment
//   g_test_init (&amp;argc, &amp;argv, G_TEST_OPTION_ISOLATE_DIRS, NULL);
// 
//   &#x2026;
// 
//   return g_test_run ();
// ]|
func ContentTypeSetMimeDirs(dirs []string) {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = dirs
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_content_type_set_mime_dirs(carg1)
	runtime.KeepAlive(dirs)
}

// ContentTypesGetRegistered wraps g_content_types_get_registered
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets a list of strings containing all the registered content types
// known to the system. The list and its data should be freed using
// `g_list_free_full (list, g_free)`.
func ContentTypesGetRegistered() []string {
	var cret *C.GList // container, transfer: full

	cret = C.g_content_types_get_registered()

	var goret []string

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) string {
			var dst string // string
			dst = C.GoString((*C.char)(v))
			defer C.free(v)
			return dst
		},
	)

	return goret
}

// DBusAddressEscapeValue wraps g_dbus_address_escape_value
// 
// The function takes the following parameters:
// 
// 	- str string: an unescaped string to be included in a D-Bus address
//     as the value in a key-value pair 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escape @string so it can appear in a D-Bus address as the value
// part of a key-value pair.
// 
// For instance, if @string is `/run/bus-for-:0`,
// this function would return `/run/bus-for-%3A0`,
// which could be used in a D-Bus address like
// `unix:nonce-tcp:host=127.0.0.1,port=42,noncefile=/run/bus-for-%3A0`.
func DBusAddressEscapeValue(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_address_escape_value(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusAddressGetForBusSync wraps g_dbus_address_get_for_bus_sync
// 
// The function takes the following parameters:
// 
// 	- busType BusType: a #GBusType 
// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Synchronously looks up the D-Bus address for the well-known message
// bus instance specified by @bus_type. This may involve using various
// platform specific mechanisms.
// 
// The returned address will be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusAddressGetForBusSync(busType BusType, cancellable Cancellable) (string, error) {
	var carg1 C.GBusType      // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = C.GBusType(busType)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dbus_address_get_for_bus_sync(carg1, carg2, &_cerr)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DBusAddressGetStream wraps g_dbus_address_get_stream
// 
// The function takes the following parameters:
// 
// 	- address string: A valid D-Bus address. 
// 	- cancellable Cancellable (nullable): A #GCancellable or %NULL. 
// 	- callback AsyncReadyCallback (nullable): A #GAsyncReadyCallback to call when the request is satisfied. 
//
// Asynchronously connects to an endpoint specified by @address and
// sets up the connection so it is in a state to run the client-side
// of the D-Bus authentication conversation. @address must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// When the operation is finished, @callback will be invoked. You can
// then call g_dbus_address_get_stream_finish() to get the result of
// the operation.
// 
// This is an asynchronous failable function. See
// g_dbus_address_get_stream_sync() for the synchronous version.
func DBusAddressGetStream(address string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dbus_address_get_stream(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// DBusAddressGetStreamFinish wraps g_dbus_address_get_stream_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream(). 
// 
// The function returns the following values:
// 
// 	- outGuid string (nullable): %NULL or return location to store the GUID extracted from @address, if any. 
// 	- goret IOStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an operation started with g_dbus_address_get_stream().
// 
// A server is not required to set a GUID, so @out_guid may be set to %NULL
// even on success.
func DBusAddressGetStreamFinish(res AsyncResult) (string, IOStream, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_dbus_address_get_stream_finish(carg1, &carg2, &_cerr)
	runtime.KeepAlive(res)

	var outGuid string
	var goret   IOStream
	var _goerr  error

	if carg2 != nil {
		outGuid = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outGuid, goret, _goerr
}

// DBusAddressGetStreamSync wraps g_dbus_address_get_stream_sync
// 
// The function takes the following parameters:
// 
// 	- address string: A valid D-Bus address. 
// 	- cancellable Cancellable (nullable): A #GCancellable or %NULL. 
// 
// The function returns the following values:
// 
// 	- outGuid string (nullable): %NULL or return location to store the GUID extracted from @address, if any. 
// 	- goret IOStream 
// 	- _goerr error (nullable): an error 
//
// Synchronously connects to an endpoint specified by @address and
// sets up the connection so it is in a state to run the client-side
// of the D-Bus authentication conversation. @address must be in the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// A server is not required to set a GUID, so @out_guid may be set to %NULL
// even on success.
// 
// This is a synchronous failable function. See
// g_dbus_address_get_stream() for the asynchronous version.
func DBusAddressGetStreamSync(address string, cancellable Cancellable) (string, IOStream, error) {
	var carg1 *C.gchar        // in, none, string
	var carg3 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dbus_address_get_stream_sync(carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var outGuid string
	var goret   IOStream
	var _goerr  error

	if carg2 != nil {
		outGuid = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outGuid, goret, _goerr
}

// DBusEscapeObjectPath wraps g_dbus_escape_object_path
// 
// The function takes the following parameters:
// 
// 	- s string: the string to escape 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This is a language binding friendly version of g_dbus_escape_object_path_bytestring().
func DBusEscapeObjectPath(s string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_escape_object_path(carg1)
	runtime.KeepAlive(s)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusEscapeObjectPathBytestring wraps g_dbus_escape_object_path_bytestring
// 
// The function takes the following parameters:
// 
// 	- bytes []uint8: the string of bytes to escape 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes @bytes for use in a D-Bus object path component.
// @bytes is an array of zero or more nonzero bytes in an
// unspecified encoding, followed by a single zero byte.
// 
// The escaping method consists of replacing all non-alphanumeric
// characters (see g_ascii_isalnum()) with their hexadecimal value
// preceded by an underscore (`_`). For example:
// `foo.bar.baz` will become `foo_2ebar_2ebaz`.
// 
// This method is appropriate to use when the input is nearly
// a valid object path component but is not when your input
// is far from being a valid object path component.
// Other escaping algorithms are also valid to use with
// D-Bus object paths.
// 
// This can be reversed with g_dbus_unescape_object_path().
func DBusEscapeObjectPathBytestring(bytes []uint8) string {
	var carg1 *C.guint8 // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	_ = bytes
	_ = carg1
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")

	cret = C.g_dbus_escape_object_path_bytestring(carg1)
	runtime.KeepAlive(bytes)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusGenerateGuid wraps g_dbus_generate_guid
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Generate a D-Bus GUID that can be used with
// e.g. g_dbus_connection_new().
// 
// See the
// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#uuids)
// regarding what strings are valid D-Bus GUIDs. The specification refers to
// these as &#x2018;UUIDs&#x2019; whereas GLib (for historical reasons) refers to them as
// &#x2018;GUIDs&#x2019;. The terms are interchangeable.
// 
// Note that D-Bus GUIDs do not follow
// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122).
func DBusGenerateGuid() string {
	var cret *C.gchar // return, full, string

	cret = C.g_dbus_generate_guid()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// DBusIsAddress wraps g_dbus_is_address
// 
// The function takes the following parameters:
// 
// 	- str string: A string. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a
// [D-Bus address](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
// 
// This doesn't check if @string is actually supported by #GDBusServer
// or #GDBusConnection - use g_dbus_is_supported_address() to do more
// checks.
func DBusIsAddress(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_address(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsErrorName wraps g_dbus_is_error_name
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether @string is a valid D-Bus error name.
// 
// This function returns the same result as g_dbus_is_interface_name(),
// because D-Bus error names are defined to have exactly the
// same syntax as interface names.
func DBusIsErrorName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_error_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsGuid wraps g_dbus_is_guid
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a D-Bus GUID.
// 
// See the documentation for g_dbus_generate_guid() for more information about
// the format of a GUID.
func DBusIsGuid(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_guid(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsInterfaceName wraps g_dbus_is_interface_name
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a valid D-Bus interface name.
func DBusIsInterfaceName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_interface_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsMemberName wraps g_dbus_is_member_name
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a valid D-Bus member (e.g. signal or method) name.
func DBusIsMemberName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_member_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsName wraps g_dbus_is_name
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a valid D-Bus bus name (either unique or well-known).
func DBusIsName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusIsSupportedAddress wraps g_dbus_is_supported_address
// 
// The function takes the following parameters:
// 
// 	- str string: A string. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Like g_dbus_is_address() but also checks if the library supports the
// transports in @string and that key/value pairs for each transport
// are valid. See the specification of the
// [D-Bus address format](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses).
func DBusIsSupportedAddress(str string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_supported_address(carg1, &_cerr)
	runtime.KeepAlive(str)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DBusIsUniqueName wraps g_dbus_is_unique_name
// 
// The function takes the following parameters:
// 
// 	- str string: The string to check. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @string is a valid D-Bus unique bus name.
func DBusIsUniqueName(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_is_unique_name(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// DBusUnescapeObjectPath wraps g_dbus_unescape_object_path
// 
// The function takes the following parameters:
// 
// 	- s string: the string to unescape 
// 
// The function returns the following values:
// 
// 	- goret []uint8 (nullable) 
//
// Unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could
// not have been returned by g_dbus_escape_object_path(), this function
// returns %NULL.
// 
// Encoding alphanumeric characters which do not need to be
// encoded is not allowed (e.g `_63` is not valid, the string
// should contain `c` instead).
func DBusUnescapeObjectPath(s string) []uint8 {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.guint8 // return, transfer: none, C Pointers: 1, Name: array[guint8], scope: , nullable, array (inner guint8 (*typesystem.CastablePrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_dbus_unescape_object_path(carg1)
	runtime.KeepAlive(s)

	var goret []uint8

	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint8 (guint8*) because of unknown reason")

	return goret
}

// IOErrorFromErrno wraps g_io_error_from_errno
// 
// The function takes the following parameters:
// 
// 	- errNo int32: Error number as defined in errno.h. 
// 
// The function returns the following values:
// 
// 	- goret IOErrorEnum 
//
// Converts `errno.h` error codes into GIO error codes.
// 
// The fallback value %G_IO_ERROR_FAILED is returned for error codes not
// currently handled (but note that future GLib releases may return a more
// specific value instead).
// 
// As `errno` is global and may be modified by intermediate function
// calls, you should save its value immediately after the call returns,
// and use the saved value instead of `errno`:
// 
// 
// |[&lt;!-- language="C" --&gt;
//   int saved_errno;
// 
//   ret = read (blah);
//   saved_errno = errno;
// 
//   g_io_error_from_errno (saved_errno);
// ]|
func IOErrorFromErrno(errNo int32) IOErrorEnum {
	var carg1 C.gint         // in, none, casted
	var cret  C.GIOErrorEnum // return, none, casted

	carg1 = C.gint(errNo)

	cret = C.g_io_error_from_errno(carg1)
	runtime.KeepAlive(errNo)

	var goret IOErrorEnum

	goret = IOErrorEnum(cret)

	return goret
}

// IOErrorFromFileError wraps g_io_error_from_file_error
// 
// The function takes the following parameters:
// 
// 	- fileError glib.FileError: a #GFileError. 
// 
// The function returns the following values:
// 
// 	- goret IOErrorEnum 
//
// Converts #GFileError error codes into GIO error codes.
func IOErrorFromFileError(fileError glib.FileError) IOErrorEnum {
	var carg1 C.GFileError   // in, none, casted
	var cret  C.GIOErrorEnum // return, none, casted

	carg1 = C.GFileError(fileError)

	cret = C.g_io_error_from_file_error(carg1)
	runtime.KeepAlive(fileError)

	var goret IOErrorEnum

	goret = IOErrorEnum(cret)

	return goret
}

// IOErrorQuark wraps g_io_error_quark
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Gets the GIO Error Quark.
func IOErrorQuark() glib.Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_io_error_quark()

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// IOModulesScanAllInDirectory wraps g_io_modules_scan_all_in_directory
// 
// The function takes the following parameters:
// 
// 	- dirname string: pathname for a directory containing modules
//     to scan. 
//
// Scans all the modules in the specified directory, ensuring that
// any extension point implemented by a module is registered.
// 
// This may not actually load and initialize all the types in each
// module, some modules may be lazily loaded and initialized when
// an extension point it implements is used with e.g.
// g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
// 
// If you need to guarantee that all types are loaded in all the modules,
// use g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectory(dirname string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(dirname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_io_modules_scan_all_in_directory(carg1)
	runtime.KeepAlive(dirname)
}

// IOModulesScanAllInDirectoryWithScope wraps g_io_modules_scan_all_in_directory_with_scope
// 
// The function takes the following parameters:
// 
// 	- dirname string: pathname for a directory containing modules
//     to scan. 
// 	- scope *IOModuleScope: a scope to use when scanning the modules 
//
// Scans all the modules in the specified directory, ensuring that
// any extension point implemented by a module is registered.
// 
// This may not actually load and initialize all the types in each
// module, some modules may be lazily loaded and initialized when
// an extension point it implements is used with e.g.
// g_io_extension_point_get_extensions() or
// g_io_extension_point_get_extension_by_name().
// 
// If you need to guarantee that all types are loaded in all the modules,
// use g_io_modules_load_all_in_directory().
func IOModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	var carg1 *C.gchar          // in, none, string
	var carg2 *C.GIOModuleScope // in, none, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dirname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GIOModuleScope)(UnsafeIOModuleScopeToGlibNone(scope))

	C.g_io_modules_scan_all_in_directory_with_scope(carg1, carg2)
	runtime.KeepAlive(dirname)
	runtime.KeepAlive(scope)
}

// IOSchedulerCancelAllJobs wraps g_io_scheduler_cancel_all_jobs
//
// Cancels all cancellable I/O jobs.
// 
// A job is cancellable if a #GCancellable was passed into
// g_io_scheduler_push_job().
//
// Deprecated: (since 2.36.0) You should never call this function, since you don't
// know how other libraries in your program might be making use of
// gioscheduler.
func IOSchedulerCancelAllJobs() {

	C.g_io_scheduler_cancel_all_jobs()
}

// PollableStreamRead wraps g_pollable_stream_read
// 
// The function takes the following parameters:
// 
// 	- stream InputStream: a #GInputStream 
// 	- buffer []byte: a buffer to
//   read data into 
// 	- blocking bool: whether to do blocking I/O 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to read from @stream, as with g_input_stream_read() (if
// @blocking is %TRUE) or g_pollable_input_stream_read_nonblocking()
// (if @blocking is %FALSE). This can be used to more easily share
// code between blocking and non-blocking implementations of a method.
// 
// If @blocking is %FALSE, then @stream must be a
// #GPollableInputStream for which g_pollable_input_stream_can_poll()
// returns %TRUE, or else the behavior is undefined. If @blocking is
// %TRUE, then @stream does not need to be a #GPollableInputStream.
func PollableStreamRead(stream InputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 unsafe.Pointer  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 C.gboolean      // in
	var carg5 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_read(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PollableStreamWrite wraps g_pollable_stream_write
// 
// The function takes the following parameters:
// 
// 	- stream OutputStream: a #GOutputStream. 
// 	- buffer []byte: the buffer
//   containing the data to write. 
// 	- blocking bool: whether to do blocking I/O 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to write to @stream, as with g_output_stream_write() (if
// @blocking is %TRUE) or g_pollable_output_stream_write_nonblocking()
// (if @blocking is %FALSE). This can be used to more easily share
// code between blocking and non-blocking implementations of a method.
// 
// If @blocking is %FALSE, then @stream must be a
// #GPollableOutputStream for which
// g_pollable_output_stream_can_poll() returns %TRUE or else the
// behavior is undefined. If @blocking is %TRUE, then @stream does not
// need to be a #GPollableOutputStream.
func PollableStreamWrite(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (int, error) {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var carg5 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_write(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PollableStreamWriteAll wraps g_pollable_stream_write_all
// 
// The function takes the following parameters:
// 
// 	- stream OutputStream: a #GOutputStream. 
// 	- buffer []byte: the buffer
//   containing the data to write. 
// 	- blocking bool: whether to do blocking I/O 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that was
//   written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to write @count bytes to @stream, as with
// g_output_stream_write_all(), but using g_pollable_stream_write()
// rather than g_output_stream_write().
// 
// On a successful write of @count bytes, %TRUE is returned, and
// @bytes_written is set to @count.
// 
// If there is an error during the operation (including
// %G_IO_ERROR_WOULD_BLOCK in the non-blocking case), %FALSE is
// returned and @error is set to indicate the error status,
// @bytes_written is updated to contain the number of bytes written
// into the stream before the error occurred.
// 
// As with g_pollable_stream_write(), if @blocking is %FALSE, then
// @stream must be a #GPollableOutputStream for which
// g_pollable_output_stream_can_poll() returns %TRUE or else the
// behavior is undefined. If @blocking is %TRUE, then @stream does not
// need to be a #GPollableOutputStream.
func PollableStreamWriteAll(stream OutputStream, buffer []byte, blocking bool, cancellable Cancellable) (uint, bool, error) {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var carg6 *C.GCancellable  // in, none, converted, nullable
	var carg5 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if blocking {
		carg4 = C.TRUE
	}
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_stream_write_all(carg1, carg2, carg3, carg4, &carg5, carg6, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// ResourcesEnumerateChildren wraps g_resources_enumerate_children
// 
// The function takes the following parameters:
// 
// 	- path string: A path name inside the resource 
// 	- lookupFlags ResourceLookupFlags: A [flags@Gio.ResourceLookupFlags] 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Returns all the names of children at the specified @path in the set of
// globally registered resources.
// 
// The return result is a `NULL` terminated list of strings which should
// be released with [func@GLib.strfreev].
// 
// @lookup_flags controls the behaviour of the lookup.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  **C.char               // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_enumerate_children(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResourcesGetInfo wraps g_resources_get_info
// 
// The function takes the following parameters:
// 
// 	- path string: A path name inside the resource 
// 	- lookupFlags ResourceLookupFlags: A [flags@Gio.ResourceLookupFlags] 
// 
// The function returns the following values:
// 
// 	- size uint: a location to place the length of the contents of the file,
//    or `NULL` if the length is not needed 
// 	- flags uint32: a location to place the [flags@Gio.ResourceFlags] about the file,
//    or `NULL` if the flags are not needed 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Looks for a file at the specified @path in the set of
// globally registered resources and if found returns information about it.
// 
// @lookup_flags controls the behaviour of the lookup.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (uint, uint32, bool, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var carg3 C.gsize                // out, full, casted
	var carg4 C.guint32              // out, full, casted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_get_info(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var size   uint
	var flags  uint32
	var goret  bool
	var _goerr error

	size = uint(carg3)
	flags = uint32(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return size, flags, goret, _goerr
}

// ResourcesLookupData wraps g_resources_lookup_data
// 
// The function takes the following parameters:
// 
// 	- path string: A path name inside the resource 
// 	- lookupFlags ResourceLookupFlags: A [flags@Gio.ResourceLookupFlags] 
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Looks for a file at the specified @path in the set of
// globally registered resources and returns a [struct@GLib.Bytes] that
// lets you directly access the data in memory.
// 
// The data is always followed by a zero byte, so you
// can safely use the data as a C string. However, that byte
// is not included in the size of the [struct@GLib.Bytes].
// 
// For uncompressed resource files this is a pointer directly into
// the resource bundle, which is typically in some read-only data section
// in the program binary. For compressed files we allocate memory on
// the heap and automatically uncompress the data.
// 
// @lookup_flags controls the behaviour of the lookup.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  *C.GBytes              // return, full, converted
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_lookup_data(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResourcesOpenStream wraps g_resources_open_stream
// 
// The function takes the following parameters:
// 
// 	- path string: A path name inside the resource 
// 	- lookupFlags ResourceLookupFlags: A [flags@Gio.ResourceLookupFlags] 
// 
// The function returns the following values:
// 
// 	- goret InputStream 
// 	- _goerr error (nullable): an error 
//
// Looks for a file at the specified @path in the set of
// globally registered resources and returns a [class@Gio.InputStream]
// that lets you read the data.
// 
// @lookup_flags controls the behaviour of the lookup.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (InputStream, error) {
	var carg1 *C.char                // in, none, string
	var carg2 C.GResourceLookupFlags // in, none, casted
	var cret  *C.GInputStream        // return, full, converted
	var _cerr *C.GError              // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResourceLookupFlags(lookupFlags)

	cret = C.g_resources_open_stream(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var goret  InputStream
	var _goerr error

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ActionInstance is the instance type used by all types implementing GAction. It is used internally by the bindings. Users should use the interface [Action] instead.
type ActionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Action = (*ActionInstance)(nil)

// Action wraps GAction
//
// `GAction` represents a single named action.
// 
// The main interface to an action is that it can be activated with
// [method@Gio.Action.activate]. This results in the 'activate' signal being
// emitted. An activation has a `GVariant` parameter (which may be
// `NULL`). The correct type for the parameter is determined by a static
// parameter type (which is given at construction time).
// 
// An action may optionally have a state, in which case the state may be
// set with [method@Gio.Action.change_state]. This call takes a [type@GLib.Variant]. The
// correct type for the state is determined by a static state type
// (which is given at construction time).
// 
// The state may have a hint associated with it, specifying its valid
// range.
// 
// `GAction` is merely the interface to the concept of an action, as
// described above.  Various implementations of actions exist, including
// [class@Gio.SimpleAction].
// 
// In all cases, the implementing class is responsible for storing the
// name of the action, the parameter type, the enabled state, the optional
// state type and the state and emitting the appropriate signals when these
// change. The implementor is responsible for filtering calls to
// [method@Gio.Action.activate] and [method@Gio.Action.change_state]
// for type safety and for the state being enabled.
// 
// Probably the only useful thing to do with a `GAction` is to put it
// inside of a [class@Gio.SimpleActionGroup].
type Action interface {
	upcastToGAction() *ActionInstance

	// GetEnabled wraps g_action_get_enabled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @action is currently enabled.
	// 
	// An action must be enabled in order to be activated or in order to
	// have its state changed from outside callers.
	GetEnabled() bool
	// GetName wraps g_action_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Queries the name of @action.
	GetName() string
	// GetParameterType wraps g_action_get_parameter_type
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.VariantType (nullable) 
	//
	// Queries the type of the parameter that must be given when activating
	// @action.
	// 
	// When activating the action using [method@Gio.Action.activate], the
	// [type@GLib.Variant] given to that function must be of the type returned by
	// this function.
	// 
	// In the case that this function returns `NULL`, you must not give any
	// [type@GLib.Variant], but `NULL` instead.
	GetParameterType() *glib.VariantType
	// GetStateType wraps g_action_get_state_type
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.VariantType (nullable) 
	//
	// Queries the type of the state of @action.
	// 
	// If the action is stateful (e.g. created with
	// [ctor@Gio.SimpleAction.new_stateful]) then this function returns the
	// [type@GLib.VariantType] of the state.  This is the type of the initial value
	// given as the state. All calls to [method@Gio.Action.change_state] must give a
	// [type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
	// [type@GLib.Variant] of the same type.
	// 
	// If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
	// then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
	// will return `NULL` and you must not call [method@Gio.Action.change_state].
	GetStateType() *glib.VariantType
}

var _ Action = (*ActionInstance)(nil)

func unsafeWrapAction(base *gobject.ObjectInstance) *ActionInstance {
	return &ActionInstance{
		Instance: *base,
	}
}

func marshalActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionInstance) upcastToGAction() *ActionInstance {
	return a
}

// UnsafeActionFromGlibNone is used to convert raw GAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionFromGlibNone(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibNone(c).(Action)
}

// UnsafeActionFromGlibFull is used to convert raw GAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionFromGlibFull(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibFull(c).(Action)
}

// UnsafeActionFromGlibBorrow is used to convert raw GAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionFromGlibBorrow(c unsafe.Pointer) Action {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Action)
}

// UnsafeActionToGlibNone is used to convert the instance to it's C value GAction. This is used by the bindings internally.
func UnsafeActionToGlibNone(c Action) unsafe.Pointer {
	i := c.upcastToGAction()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionToGlibFull is used to convert the instance to it's C value GAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionToGlibFull(c Action) unsafe.Pointer {
	i := c.upcastToGAction()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ActionNameIsValid wraps g_action_name_is_valid
// 
// The function takes the following parameters:
// 
// 	- actionName string: a potential action name 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @action_name is valid.
// 
// @action_name is valid if it consists only of alphanumeric characters,
// plus `-` and `.`.  The empty string is not a valid action name.
// 
// It is an error to call this function with a non-UTF-8 @action_name.
// @action_name must not be `NULL`.
func ActionNameIsValid(actionName string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_name_is_valid(carg1)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetEnabled wraps g_action_get_enabled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @action is currently enabled.
// 
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (action *ActionInstance) GetEnabled() bool {
	var carg0 *C.GAction // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_enabled(carg0)
	runtime.KeepAlive(action)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetName wraps g_action_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Queries the name of @action.
func (action *ActionInstance) GetName() string {
	var carg0 *C.GAction // in, none, converted
	var cret  *C.gchar   // return, none, string

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_name(carg0)
	runtime.KeepAlive(action)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetParameterType wraps g_action_get_parameter_type
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantType (nullable) 
//
// Queries the type of the parameter that must be given when activating
// @action.
// 
// When activating the action using [method@Gio.Action.activate], the
// [type@GLib.Variant] given to that function must be of the type returned by
// this function.
// 
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
func (action *ActionInstance) GetParameterType() *glib.VariantType {
	var carg0 *C.GAction      // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_parameter_type(carg0)
	runtime.KeepAlive(action)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetStateType wraps g_action_get_state_type
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantType (nullable) 
//
// Queries the type of the state of @action.
// 
// If the action is stateful (e.g. created with
// [ctor@Gio.SimpleAction.new_stateful]) then this function returns the
// [type@GLib.VariantType] of the state.  This is the type of the initial value
// given as the state. All calls to [method@Gio.Action.change_state] must give a
// [type@GLib.Variant] of this type and [method@Gio.Action.get_state] will return a
// [type@GLib.Variant] of the same type.
// 
// If the action is not stateful (e.g. created with [ctor@Gio.SimpleAction.new])
// then this function will return `NULL`. In that case, [method@Gio.Action.get_state]
// will return `NULL` and you must not call [method@Gio.Action.change_state].
func (action *ActionInstance) GetStateType() *glib.VariantType {
	var carg0 *C.GAction      // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GAction)(UnsafeActionToGlibNone(action))

	cret = C.g_action_get_state_type(carg0)
	runtime.KeepAlive(action)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ActionGroupInstance is the instance type used by all types implementing GActionGroup. It is used internally by the bindings. Users should use the interface [ActionGroup] instead.
type ActionGroupInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ActionGroup = (*ActionGroupInstance)(nil)

// ActionGroup wraps GActionGroup
//
// `GActionGroup` represents a group of actions.
// 
// Actions can be used to expose functionality in a structured way, either
// from one part of a program to another, or to the outside world. Action
// groups are often used together with a [type@Gio.MenuModel] that provides additional
// representation data for displaying the actions to the user, e.g. in a menu.
// 
// The main way to interact with the actions in a `GActionGroup` is to
// activate them with [method@Gio.ActionGroup.activate_action]. Activating an
// action may require a [type@GLib.Variant] parameter. The required type of the
// parameter can be inquired with [method@Gio.ActionGroup.get_action_parameter_type].
// Actions may be disabled, see [method@Gio.ActionGroup.get_action_enabled].
// Activating a disabled action has no effect.
// 
// Actions may optionally have a state in the form of a [type@GLib.Variant]. The current
// state of an action can be inquired with [method@Gio.ActionGroup.get_action_state].
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling [method@Gio.ActionGroup.change_action_state].
// 
// As typical example, consider a text editing application which has an
// option to change the current font to &#x2018;bold&#x2019;. A good way to represent
// this would be a stateful action, with a boolean state. Activating the
// action would toggle the state.
// 
// Each action in the group has a unique name (which is a string).  All
// method calls, except [method@Gio.ActionGroup.list_actions] take the name of
// an action as an argument.
// 
// The `GActionGroup` API is meant to be the &#x2018;public&#x2019; API to the action
// group. The calls here are exactly the interaction that &#x2018;external
// forces&#x2019; (eg: UI, incoming D-Bus messages, etc.) are supposed to have
// with actions. &#x2018;Internal&#x2019; APIs (ie: ones meant only to be accessed by
// the action group implementation) are found on subclasses. This is
// why you will find &#x2013; for example &#x2013; [method@Gio.ActionGroup.get_action_enabled]
// but not an equivalent `set_action_enabled()` method.
// 
// Signals are emitted on the action group in response to state changes
// on individual actions.
// 
// Implementations of `GActionGroup` should provide implementations for
// the virtual functions [method@Gio.ActionGroup.list_actions] and
// [method@Gio.ActionGroup.query_action]. The other virtual functions should
// not be implemented &#x2014; their &#x2018;wrappers&#x2019; are actually implemented with
// calls to [method@Gio.ActionGroup.query_action].
type ActionGroup interface {
	upcastToGActionGroup() *ActionGroupInstance

	// ActionAdded wraps g_action_group_action_added
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of an action in the group 
	//
	// Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.
	// 
	// This function should only be called by [type@Gio.ActionGroup] implementations.
	ActionAdded(string)
	// ActionEnabledChanged wraps g_action_group_action_enabled_changed
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of an action in the group 
	// 	- enabled bool: whether the action is now enabled 
	//
	// Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.
	// 
	// This function should only be called by [type@Gio.ActionGroup] implementations.
	ActionEnabledChanged(string, bool)
	// ActionRemoved wraps g_action_group_action_removed
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of an action in the group 
	//
	// Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.
	// 
	// This function should only be called by [type@Gio.ActionGroup] implementations.
	ActionRemoved(string)
	// GetActionEnabled wraps g_action_group_get_action_enabled
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the named action within @action_group is currently enabled.
	// 
	// An action must be enabled in order to be activated or in order to
	// have its state changed from outside callers.
	GetActionEnabled(string) bool
	// GetActionParameterType wraps g_action_group_get_action_parameter_type
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.VariantType (nullable) 
	//
	// Queries the type of the parameter that must be given when activating
	// the named action within @action_group.
	// 
	// When activating the action using [method@Gio.ActionGroup.activate_action],
	// the [type@GLib.Variant] given to that function must be of the type returned
	// by this function.
	// 
	// In the case that this function returns `NULL`, you must not give any
	// [type@GLib.Variant], but `NULL` instead.
	// 
	// The parameter type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different parameter type.
	GetActionParameterType(string) *glib.VariantType
	// GetActionStateType wraps g_action_group_get_action_state_type
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.VariantType (nullable) 
	//
	// Queries the type of the state of the named action within
	// @action_group.
	// 
	// If the action is stateful then this function returns the
	// [type@GLib.VariantType] of the state.  All calls to
	// [method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
	// type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
	// of the same type.
	// 
	// If the action is not stateful then this function will return `NULL`.
	// In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
	// and you must not call [method@Gio.ActionGroup.change_action_state].
	// 
	// The state type of a particular action will never change but it is
	// possible for an action to be removed and for a new action to be added
	// with the same name but a different state type.
	GetActionStateType(string) *glib.VariantType
	// HasAction wraps g_action_group_has_action
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action to check for 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the named action exists within @action_group.
	HasAction(string) bool
	// ListActions wraps g_action_group_list_actions
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Lists the actions contained within @action_group.
	// 
	// The caller is responsible for freeing the list with [func@GLib.strfreev] when
	// it is no longer required.
	ListActions() []string
	// ConnectActionAdded connects the provided callback to the "action-added" signal
	//
	// Signals that a new action was just added to the group.
	// 
	// This signal is emitted after the action has been added
	// and is now visible.
	ConnectActionAdded(func(ActionGroup, string)) gobject.SignalHandle
	// ConnectActionEnabledChanged connects the provided callback to the "action-enabled-changed" signal
	//
	// Signals that the enabled status of the named action has changed.
	ConnectActionEnabledChanged(func(ActionGroup, string, bool)) gobject.SignalHandle
	// ConnectActionRemoved connects the provided callback to the "action-removed" signal
	//
	// Signals that an action is just about to be removed from the group.
	// 
	// This signal is emitted before the action is removed, so the action
	// is still visible and can be queried from the signal handler.
	ConnectActionRemoved(func(ActionGroup, string)) gobject.SignalHandle
}

var _ ActionGroup = (*ActionGroupInstance)(nil)

func unsafeWrapActionGroup(base *gobject.ObjectInstance) *ActionGroupInstance {
	return &ActionGroupInstance{
		Instance: *base,
	}
}

func marshalActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionGroupInstance) upcastToGActionGroup() *ActionGroupInstance {
	return a
}

// UnsafeActionGroupFromGlibNone is used to convert raw GActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionGroupFromGlibNone(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(ActionGroup)
}

// UnsafeActionGroupFromGlibFull is used to convert raw GActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionGroupFromGlibFull(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(ActionGroup)
}

// UnsafeActionGroupFromGlibBorrow is used to convert raw GActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionGroupFromGlibBorrow(c unsafe.Pointer) ActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ActionGroup)
}

// UnsafeActionGroupToGlibNone is used to convert the instance to it's C value GActionGroup. This is used by the bindings internally.
func UnsafeActionGroupToGlibNone(c ActionGroup) unsafe.Pointer {
	i := c.upcastToGActionGroup()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionGroupToGlibFull is used to convert the instance to it's C value GActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionGroupToGlibFull(c ActionGroup) unsafe.Pointer {
	i := c.upcastToGActionGroup()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ActionAdded wraps g_action_group_action_added
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of an action in the group 
//
// Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.
// 
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (actionGroup *ActionGroupInstance) ActionAdded(actionName string) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_group_action_added(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// ActionEnabledChanged wraps g_action_group_action_enabled_changed
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of an action in the group 
// 	- enabled bool: whether the action is now enabled 
//
// Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.
// 
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (actionGroup *ActionGroupInstance) ActionEnabledChanged(actionName string, enabled bool) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gboolean      // in

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))
	if enabled {
		carg2 = C.TRUE
	}

	C.g_action_group_action_enabled_changed(carg0, carg1, carg2)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// ActionRemoved wraps g_action_group_action_removed
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of an action in the group 
//
// Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.
// 
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (actionGroup *ActionGroupInstance) ActionRemoved(actionName string) {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_group_action_removed(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)
}

// GetActionEnabled wraps g_action_group_get_action_enabled
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action to query 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the named action within @action_group is currently enabled.
// 
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (actionGroup *ActionGroupInstance) GetActionEnabled(actionName string) bool {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_enabled(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetActionParameterType wraps g_action_group_get_action_parameter_type
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action to query 
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantType (nullable) 
//
// Queries the type of the parameter that must be given when activating
// the named action within @action_group.
// 
// When activating the action using [method@Gio.ActionGroup.activate_action],
// the [type@GLib.Variant] given to that function must be of the type returned
// by this function.
// 
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
// 
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (actionGroup *ActionGroupInstance) GetActionParameterType(actionName string) *glib.VariantType {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_parameter_type(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetActionStateType wraps g_action_group_get_action_state_type
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action to query 
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantType (nullable) 
//
// Queries the type of the state of the named action within
// @action_group.
// 
// If the action is stateful then this function returns the
// [type@GLib.VariantType] of the state.  All calls to
// [method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
// type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
// of the same type.
// 
// If the action is not stateful then this function will return `NULL`.
// In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
// and you must not call [method@Gio.ActionGroup.change_action_state].
// 
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (actionGroup *ActionGroupInstance) GetActionStateType(actionName string) *glib.VariantType {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_get_action_state_type(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret *glib.VariantType

	if cret != nil {
		goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// HasAction wraps g_action_group_has_action
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action to check for 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the named action exists within @action_group.
func (actionGroup *ActionGroupInstance) HasAction(actionName string) bool {
	var carg0 *C.GActionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_group_has_action(carg0, carg1)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(actionName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListActions wraps g_action_group_list_actions
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Lists the actions contained within @action_group.
// 
// The caller is responsible for freeing the list with [func@GLib.strfreev] when
// it is no longer required.
func (actionGroup *ActionGroupInstance) ListActions() []string {
	var carg0 *C.GActionGroup // in, none, converted
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))

	cret = C.g_action_group_list_actions(carg0)
	runtime.KeepAlive(actionGroup)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ConnectActionAdded connects the provided callback to the "action-added" signal
//
// Signals that a new action was just added to the group.
// 
// This signal is emitted after the action has been added
// and is now visible.
func (o *ActionGroupInstance) ConnectActionAdded(fn func(ActionGroup, string)) gobject.SignalHandle {
	return o.Instance.Connect("action-added", fn)
}

// ConnectActionEnabledChanged connects the provided callback to the "action-enabled-changed" signal
//
// Signals that the enabled status of the named action has changed.
func (o *ActionGroupInstance) ConnectActionEnabledChanged(fn func(ActionGroup, string, bool)) gobject.SignalHandle {
	return o.Instance.Connect("action-enabled-changed", fn)
}

// ConnectActionRemoved connects the provided callback to the "action-removed" signal
//
// Signals that an action is just about to be removed from the group.
// 
// This signal is emitted before the action is removed, so the action
// is still visible and can be queried from the signal handler.
func (o *ActionGroupInstance) ConnectActionRemoved(fn func(ActionGroup, string)) gobject.SignalHandle {
	return o.Instance.Connect("action-removed", fn)
}

// ActionMapInstance is the instance type used by all types implementing GActionMap. It is used internally by the bindings. Users should use the interface [ActionMap] instead.
type ActionMapInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ActionMap = (*ActionMapInstance)(nil)

// ActionMap wraps GActionMap
//
// `GActionMap` is an interface for action containers.
// 
// The `GActionMap` interface is implemented by [iface@Gio.ActionGroup]
// implementations that operate by containing a number of named
// [iface@Gio.Action] instances, such as [class@Gio.SimpleActionGroup].
// 
// One useful application of this interface is to map the
// names of actions from various action groups to unique,
// prefixed names (e.g. by prepending "app." or "win.").
// This is the motivation for the &#x2018;Map&#x2019; part of the interface
// name.
type ActionMap interface {
	upcastToGActionMap() *ActionMapInstance

	// AddAction wraps g_action_map_add_action
	// 
	// The function takes the following parameters:
	// 
	// 	- action Action: a [iface@Gio.Action] 
	//
	// Adds an action to the @action_map.
	// 
	// If the action map already contains an action with the same name
	// as @action then the old action is dropped from the action map.
	// 
	// The action map takes its own reference on @action.
	AddAction(Action)
	// LookupAction wraps g_action_map_lookup_action
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of an action 
	// 
	// The function returns the following values:
	// 
	// 	- goret Action (nullable) 
	//
	// Looks up the action with the name @action_name in @action_map.
	// 
	// If no such action exists, returns `NULL`.
	LookupAction(string) Action
	// RemoveAction wraps g_action_map_remove_action
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action 
	//
	// Removes the named action from the action map.
	// 
	// If no action of this name is in the map then nothing happens.
	RemoveAction(string)
	// RemoveActionEntries wraps g_action_map_remove_action_entries
	// 
	// The function takes the following parameters:
	// 
	// 	- entries []ActionEntry: a pointer to
	//   the first item in an array of [struct@Gio.ActionEntry] structs 
	//
	// Remove actions from a [iface@Gio.ActionMap]. This is meant as the reverse of
	// [method@Gio.ActionMap.add_action_entries].
	// 
	// 
	// ```c
	// static const GActionEntry entries[] = {
	//     { "quit",         activate_quit              },
	//     { "print-string", activate_print_string, "s" }
	// };
	// 
	// void
	// add_actions (GActionMap *map)
	// {
	//   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
	// }
	// 
	// void
	// remove_actions (GActionMap *map)
	// {
	//   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
	// }
	// ```
	RemoveActionEntries([]ActionEntry)
}

var _ ActionMap = (*ActionMapInstance)(nil)

func unsafeWrapActionMap(base *gobject.ObjectInstance) *ActionMapInstance {
	return &ActionMapInstance{
		Instance: *base,
	}
}

func marshalActionMapInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *ActionMapInstance) upcastToGActionMap() *ActionMapInstance {
	return a
}

// UnsafeActionMapFromGlibNone is used to convert raw GActionMap pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeActionMapFromGlibNone(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibNone(c).(ActionMap)
}

// UnsafeActionMapFromGlibFull is used to convert raw GActionMap pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeActionMapFromGlibFull(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibFull(c).(ActionMap)
}

// UnsafeActionMapFromGlibBorrow is used to convert raw GActionMap pointers to go without touching any references. This is used by the bindings internally.
func UnsafeActionMapFromGlibBorrow(c unsafe.Pointer) ActionMap {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ActionMap)
}

// UnsafeActionMapToGlibNone is used to convert the instance to it's C value GActionMap. This is used by the bindings internally.
func UnsafeActionMapToGlibNone(c ActionMap) unsafe.Pointer {
	i := c.upcastToGActionMap()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeActionMapToGlibFull is used to convert the instance to it's C value GActionMap, while removeing the finalizer. This is used by the bindings internally.
func UnsafeActionMapToGlibFull(c ActionMap) unsafe.Pointer {
	i := c.upcastToGActionMap()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// AddAction wraps g_action_map_add_action
// 
// The function takes the following parameters:
// 
// 	- action Action: a [iface@Gio.Action] 
//
// Adds an action to the @action_map.
// 
// If the action map already contains an action with the same name
// as @action then the old action is dropped from the action map.
// 
// The action map takes its own reference on @action.
func (actionMap *ActionMapInstance) AddAction(action Action) {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.GAction    // in, none, converted

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.GAction)(UnsafeActionToGlibNone(action))

	C.g_action_map_add_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(action)
}

// LookupAction wraps g_action_map_lookup_action
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of an action 
// 
// The function returns the following values:
// 
// 	- goret Action (nullable) 
//
// Looks up the action with the name @action_name in @action_map.
// 
// If no such action exists, returns `NULL`.
func (actionMap *ActionMapInstance) LookupAction(actionName string) Action {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.GAction    // return, none, converted, nullable

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_action_map_lookup_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)

	var goret Action

	if cret != nil {
		goret = UnsafeActionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// RemoveAction wraps g_action_map_remove_action
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action 
//
// Removes the named action from the action map.
// 
// If no action of this name is in the map then nothing happens.
func (actionMap *ActionMapInstance) RemoveAction(actionName string) {
	var carg0 *C.GActionMap // in, none, converted
	var carg1 *C.gchar      // in, none, string

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_action_map_remove_action(carg0, carg1)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(actionName)
}

// RemoveActionEntries wraps g_action_map_remove_action_entries
// 
// The function takes the following parameters:
// 
// 	- entries []ActionEntry: a pointer to
//   the first item in an array of [struct@Gio.ActionEntry] structs 
//
// Remove actions from a [iface@Gio.ActionMap]. This is meant as the reverse of
// [method@Gio.ActionMap.add_action_entries].
// 
// 
// ```c
// static const GActionEntry entries[] = {
//     { "quit",         activate_quit              },
//     { "print-string", activate_print_string, "s" }
// };
// 
// void
// add_actions (GActionMap *map)
// {
//   g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
// }
// 
// void
// remove_actions (GActionMap *map)
// {
//   g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
// }
// ```
func (actionMap *ActionMapInstance) RemoveActionEntries(entries []ActionEntry) {
	var carg0 *C.GActionMap   // in, none, converted
	var carg1 *C.GActionEntry // in, transfer: none, C Pointers: 1, Name: array[ActionEntry], array (inner GActionEntry (*typesystem.Record), length-by: carg2)
	var carg2 C.gint          // implicit

	carg0 = (*C.GActionMap)(UnsafeActionMapToGlibNone(actionMap))
	_ = entries
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []ActionEntry (const GActionEntry*) because of unimplemented: non-fixed size array")

	C.g_action_map_remove_action_entries(carg0, carg1, carg2)
	runtime.KeepAlive(actionMap)
	runtime.KeepAlive(entries)
}

// AppInfoInstance is the instance type used by all types implementing GAppInfo. It is used internally by the bindings. Users should use the interface [AppInfo] instead.
type AppInfoInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AppInfo = (*AppInfoInstance)(nil)

// AppInfo wraps GAppInfo
//
// Information about an installed application and methods to launch
// it (with file arguments).
// 
// `GAppInfo` and `GAppLaunchContext` are used for describing and launching
// applications installed on the system.
// 
// As of GLib 2.20, URIs will always be converted to POSIX paths
// (using [method@Gio.File.get_path]) when using [method@Gio.AppInfo.launch]
// even if the application requested an URI and not a POSIX path. For example
// for a desktop-file based application with the following Exec key:
// 
// ```
// Exec=totem %U
// ```
// 
// and a single URI, `sftp://foo/file.avi`, then
// `/home/user/.gvfs/sftp on foo/file.avi` will be passed. This will only work
// if a set of suitable GIO extensions (such as GVfs 2.26 compiled with FUSE
// support), is available and operational; if this is not the case, the URI
// will be passed unmodified to the application. Some URIs, such as `mailto:`,
// of course cannot be mapped to a POSIX path (in GVfs there&#x2019;s no FUSE mount
// for it); such URIs will be passed unmodified to the application.
// 
// Specifically for GVfs 2.26 and later, the POSIX URI will be mapped
// back to the GIO URI in the [iface@Gio.File] constructors (since GVfs
// implements the GVfs extension point). As such, if the application
// needs to examine the URI, it needs to use [method@Gio.File.get_uri]
// or similar on [iface@Gio.File]. In other words, an application cannot
// assume that the URI passed to e.g. [func@Gio.File.new_for_commandline_arg]
// is equal to the result of [method@Gio.File.get_uri]. The following snippet
// illustrates this:
// 
// ```c
// GFile *f;
// char *uri;
// 
// file = g_file_new_for_commandline_arg (uri_from_commandline);
// 
// uri = g_file_get_uri (file);
// strcmp (uri, uri_from_commandline) == 0;
// g_free (uri);
// 
// if (g_file_has_uri_scheme (file, "cdda"))
//   {
//     // do something special with uri
//   }
// g_object_unref (file);
// ```
// 
// This code will work when both `cdda://sr0/Track 1.wav` and
// `/home/user/.gvfs/cdda on sr0/Track 1.wav` is passed to the
// application. It should be noted that it&#x2019;s generally not safe
// for applications to rely on the format of a particular URIs.
// Different launcher applications (e.g. file managers) may have
// different ideas of what a given URI means.
type AppInfo interface {
	upcastToGAppInfo() *AppInfoInstance

	// AddSupportsType wraps g_app_info_add_supports_type
	// 
	// The function takes the following parameters:
	// 
	// 	- contentType string: a string. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Adds a content type to the application information to indicate the
	// application is capable of opening files with the given content type.
	AddSupportsType(string) (bool, error)
	// CanDelete wraps g_app_info_can_delete
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Obtains the information whether the [iface@Gio.AppInfo] can be deleted.
	// See [method@Gio.AppInfo.delete].
	CanDelete() bool
	// CanRemoveSupportsType wraps g_app_info_can_remove_supports_type
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a supported content type can be removed from an application.
	CanRemoveSupportsType() bool
	// Delete wraps g_app_info_delete
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tries to delete a [iface@Gio.AppInfo].
	// 
	// On some platforms, there may be a difference between user-defined
	// [iface@Gio.AppInfo]s which can be deleted, and system-wide ones which cannot.
	// See [method@Gio.AppInfo.can_delete].
	Delete() bool
	// Dup wraps g_app_info_dup
	// 
	// The function returns the following values:
	// 
	// 	- goret AppInfo 
	//
	// Creates a duplicate of a [iface@Gio.AppInfo].
	Dup() AppInfo
	// Equal wraps g_app_info_equal
	// 
	// The function takes the following parameters:
	// 
	// 	- appinfo2 AppInfo: the second [iface@Gio.AppInfo]. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if two [iface@Gio.AppInfo]s are equal.
	// 
	// Note that the check *may not* compare each individual field, and only does
	// an identity check. In case detecting changes in the contents is needed,
	// program code must additionally compare relevant fields.
	Equal(AppInfo) bool
	// GetCommandline wraps g_app_info_get_commandline
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the commandline with which the application will be
	// started.
	GetCommandline() string
	// GetDescription wraps g_app_info_get_description
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets a human-readable description of an installed application.
	GetDescription() string
	// GetDisplayName wraps g_app_info_get_display_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the display name of the application. The display name is often more
	// descriptive to the user than the name itself.
	GetDisplayName() string
	// GetExecutable wraps g_app_info_get_executable
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the executable&#x2019;s name for the installed application.
	// 
	// This is intended to be used for debugging or labelling what program is going
	// to be run. To launch the executable, use [method@Gio.AppInfo.launch] and related
	// functions, rather than spawning the return value from this function.
	GetExecutable() string
	// GetIcon wraps g_app_info_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon (nullable) 
	//
	// Gets the icon for the application.
	GetIcon() Icon
	// GetID wraps g_app_info_get_id
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the ID of an application. An id is a string that identifies the
	// application. The exact format of the id is platform dependent. For instance,
	// on Unix this is the desktop file id from the xdg menu specification.
	// 
	// Note that the returned ID may be `NULL`, depending on how the @appinfo has
	// been constructed.
	GetID() string
	// GetName wraps g_app_info_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the installed name of the application.
	GetName() string
	// GetSupportedTypes wraps g_app_info_get_supported_types
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Retrieves the list of content types that @app_info claims to support.
	// If this information is not provided by the environment, this function
	// will return `NULL`.
	// 
	// This function does not take in consideration associations added with
	// [method@Gio.AppInfo.add_supports_type], but only those exported directly by
	// the application.
	GetSupportedTypes() []string
	// LaunchUrisFinish wraps g_app_info_launch_uris_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the async result 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a [method@Gio.AppInfo.launch_uris_async] operation.
	LaunchUrisFinish(AsyncResult) (bool, error)
	// RemoveSupportsType wraps g_app_info_remove_supports_type
	// 
	// The function takes the following parameters:
	// 
	// 	- contentType string: a string. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Removes a supported type from an application, if possible.
	RemoveSupportsType(string) (bool, error)
	// SetAsDefaultForExtension wraps g_app_info_set_as_default_for_extension
	// 
	// The function takes the following parameters:
	// 
	// 	- extension string: a string containing the file extension (without
	//   the dot). 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets the application as the default handler for the given file extension.
	SetAsDefaultForExtension(string) (bool, error)
	// SetAsDefaultForType wraps g_app_info_set_as_default_for_type
	// 
	// The function takes the following parameters:
	// 
	// 	- contentType string: the content type. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets the application as the default handler for a given type.
	SetAsDefaultForType(string) (bool, error)
	// SetAsLastUsedForType wraps g_app_info_set_as_last_used_for_type
	// 
	// The function takes the following parameters:
	// 
	// 	- contentType string: the content type. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets the application as the last used application for a given type. This
	// will make the application appear as first in the list returned by
	// [func@Gio.AppInfo.get_recommended_for_type], regardless of the default
	// application for that content type.
	SetAsLastUsedForType(string) (bool, error)
	// ShouldShow wraps g_app_info_should_show
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles wraps g_app_info_supports_files
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsUris wraps g_app_info_supports_uris
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the application supports reading files and directories from URIs.
	SupportsUris() bool
}

var _ AppInfo = (*AppInfoInstance)(nil)

func unsafeWrapAppInfo(base *gobject.ObjectInstance) *AppInfoInstance {
	return &AppInfoInstance{
		Instance: *base,
	}
}

func marshalAppInfoInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AppInfoInstance) upcastToGAppInfo() *AppInfoInstance {
	return a
}

// UnsafeAppInfoFromGlibNone is used to convert raw GAppInfo pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoFromGlibNone(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibNone(c).(AppInfo)
}

// UnsafeAppInfoFromGlibFull is used to convert raw GAppInfo pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoFromGlibFull(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibFull(c).(AppInfo)
}

// UnsafeAppInfoFromGlibBorrow is used to convert raw GAppInfo pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppInfoFromGlibBorrow(c unsafe.Pointer) AppInfo {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppInfo)
}

// UnsafeAppInfoToGlibNone is used to convert the instance to it's C value GAppInfo. This is used by the bindings internally.
func UnsafeAppInfoToGlibNone(c AppInfo) unsafe.Pointer {
	i := c.upcastToGAppInfo()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAppInfoToGlibFull is used to convert the instance to it's C value GAppInfo, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppInfoToGlibFull(c AppInfo) unsafe.Pointer {
	i := c.upcastToGAppInfo()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// AppInfoCreateFromCommandline wraps g_app_info_create_from_commandline
// 
// The function takes the following parameters:
// 
// 	- commandline string: the command line to use 
// 	- applicationName string (nullable): the application name, or `NULL` to use @commandline 
// 	- flags AppInfoCreateFlags: flags that can specify details of the created [iface@Gio.AppInfo] 
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
// 	- _goerr error (nullable): an error 
//
// Creates a new [iface@Gio.AppInfo] from the given information.
// 
// Note that for @commandline, the quoting rules of the `Exec` key of the
// [freedesktop.org Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
// are applied. For example, if the @commandline contains
// percent-encoded URIs, the percent-character must be doubled in order to prevent it from
// being swallowed by `Exec` key unquoting. See
// [the specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s07.html)
// for exact quoting rules.
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) (AppInfo, error) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string, nullable-string
	var carg3 C.GAppInfoCreateFlags // in, none, casted
	var cret  *C.GAppInfo           // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(commandline)))
	defer C.free(unsafe.Pointer(carg1))
	if applicationName != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(applicationName)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = C.GAppInfoCreateFlags(flags)

	cret = C.g_app_info_create_from_commandline(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(commandline)
	runtime.KeepAlive(applicationName)
	runtime.KeepAlive(flags)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetAll wraps g_app_info_get_all
// 
// The function returns the following values:
// 
// 	- goret []AppInfo 
//
// Gets a list of all of the applications currently registered
// on this system.
// 
// For desktop files, this includes applications that have
// [`NoDisplay=true`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-nodisplay)
// set or are excluded from display by means of
// [`OnlyShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-onlyshowin)
// or [`NotShowIn`](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-notshowin).
// See [method@Gio.AppInfo.should_show].
// 
// The returned list does not include applications which have the
// [`Hidden` key](https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s06.html#key-hidden)
// set.
func AppInfoGetAll() []AppInfo {
	var cret *C.GList // container, transfer: full

	cret = C.g_app_info_get_all()

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetAllForType wraps g_app_info_get_all_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type to find a [iface@Gio.AppInfo] for 
// 
// The function returns the following values:
// 
// 	- goret []AppInfo 
//
// Gets a list of all [iface@Gio.AppInfo]s for a given content type,
// including the recommended and fallback [iface@Gio.AppInfo]s. See
// [func@Gio.AppInfo.get_recommended_for_type] and
// [func@Gio.AppInfo.get_fallback_for_type].
func AppInfoGetAllForType(contentType string) []AppInfo {
	var carg1 *C.char  // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_all_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetDefaultForType wraps g_app_info_get_default_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type to find a [iface@Gio.AppInfo] for 
// 	- mustSupportUris bool: if `TRUE`, the [iface@Gio.AppInfo] is expected to
//   support URIs 
// 
// The function returns the following values:
// 
// 	- goret AppInfo (nullable) 
//
// Gets the default [iface@Gio.AppInfo] for a given content type.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) AppInfo {
	var carg1 *C.char     // in, none, string
	var carg2 C.gboolean  // in
	var cret  *C.GAppInfo // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))
	if mustSupportUris {
		carg2 = C.TRUE
	}

	cret = C.g_app_info_get_default_for_type(carg1, carg2)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)

	var goret AppInfo

	if cret != nil {
		goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// AppInfoGetDefaultForTypeAsync wraps g_app_info_get_default_for_type_async
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type to find a [iface@Gio.AppInfo] for 
// 	- mustSupportUris bool: if `TRUE`, the [iface@Gio.AppInfo] is expected to
//   support URIs 
// 	- cancellable Cancellable (nullable): a [class@Gio.Cancellable] 
// 	- callback AsyncReadyCallback (nullable): a [type@Gio.AsyncReadyCallback] to call
//   when the request is done 
//
// Asynchronously gets the default [iface@Gio.AppInfo] for a given content
// type.
func AppInfoGetDefaultForTypeAsync(contentType string, mustSupportUris bool, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 C.gboolean            // in
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))
	if mustSupportUris {
		carg2 = C.TRUE
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_get_default_for_type_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForTypeFinish wraps g_app_info_get_default_for_type_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the async result 
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes a default [iface@Gio.AppInfo] lookup started by
// [func@Gio.AppInfo.get_default_for_type_async].
// 
// If no #[iface@Gio.AppInfo] is found, then @error will be set to
// [error@Gio.IOErrorEnum.NOT_FOUND].
func AppInfoGetDefaultForTypeFinish(result AsyncResult) (AppInfo, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_get_default_for_type_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetDefaultForURIScheme wraps g_app_info_get_default_for_uri_scheme
// 
// The function takes the following parameters:
// 
// 	- uriScheme string: a string containing a URI scheme. 
// 
// The function returns the following values:
// 
// 	- goret AppInfo (nullable) 
//
// Gets the default application for handling URIs with the given URI scheme.
// 
// A URI scheme is the initial part of the URI, up to but not including the `:`.
// For example, `http`, `ftp` or `sip`.
func AppInfoGetDefaultForURIScheme(uriScheme string) AppInfo {
	var carg1 *C.char     // in, none, string
	var cret  *C.GAppInfo // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_default_for_uri_scheme(carg1)
	runtime.KeepAlive(uriScheme)

	var goret AppInfo

	if cret != nil {
		goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// AppInfoGetDefaultForURISchemeAsync wraps g_app_info_get_default_for_uri_scheme_async
// 
// The function takes the following parameters:
// 
// 	- uriScheme string: a string containing a URI scheme. 
// 	- cancellable Cancellable (nullable): a [class@Gio.Cancellable] 
// 	- callback AsyncReadyCallback (nullable): a [type@Gio.AsyncReadyCallback] to call
//   when the request is done 
//
// Asynchronously gets the default application for handling URIs with
// the given URI scheme. A URI scheme is the initial part
// of the URI, up to but not including the `:`, e.g. `http`,
// `ftp` or `sip`.
func AppInfoGetDefaultForURISchemeAsync(uriScheme string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_get_default_for_uri_scheme_async(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoGetDefaultForURISchemeFinish wraps g_app_info_get_default_for_uri_scheme_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the async result 
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes a default [iface@Gio.AppInfo] lookup started by
// [func@Gio.AppInfo.get_default_for_uri_scheme_async].
// 
// If no [iface@Gio.AppInfo] is found, then @error will be set to
// [error@Gio.IOErrorEnum.NOT_FOUND].
func AppInfoGetDefaultForURISchemeFinish(result AsyncResult) (AppInfo, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_get_default_for_uri_scheme_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoGetFallbackForType wraps g_app_info_get_fallback_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type to find a [iface@Gio.AppInfo] for 
// 
// The function returns the following values:
// 
// 	- goret []AppInfo 
//
// Gets a list of fallback [iface@Gio.AppInfo]s for a given content type, i.e.
// those applications which claim to support the given content type by MIME
// type subclassing and not directly.
func AppInfoGetFallbackForType(contentType string) []AppInfo {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_fallback_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoGetRecommendedForType wraps g_app_info_get_recommended_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type to find a [iface@Gio.AppInfo] for 
// 
// The function returns the following values:
// 
// 	- goret []AppInfo 
//
// Gets a list of recommended [iface@Gio.AppInfo]s for a given content type,
// i.e. those applications which claim to support the given content type
// exactly, and not by MIME type subclassing.
// 
// Note that the first application of the list is the last used one, i.e.
// the last one for which [method@Gio.AppInfo.set_as_last_used_for_type] has
// been called.
func AppInfoGetRecommendedForType(contentType string) []AppInfo {
	var carg1 *C.gchar // in, none, string
	var cret  *C.GList // container, transfer: full

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_get_recommended_for_type(carg1)
	runtime.KeepAlive(contentType)

	var goret []AppInfo

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) AppInfo {
			var dst AppInfo // converted
			dst = UnsafeAppInfoFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// AppInfoLaunchDefaultForURI wraps g_app_info_launch_default_for_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: the uri to show 
// 	- _context AppLaunchContext (nullable): optional launch context 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Utility function that launches the default application registered to handle
// the specified uri. Synchronous I/O is done on the uri to detect the type of
// the file if required.
// 
// The D-Bus&#x2013;activated applications don&#x2019;t have to be started if your application
// terminates too soon after this function. To prevent this, use
// [func@Gio.AppInfo.launch_default_for_uri_async] instead.
func AppInfoLaunchDefaultForURI(uri string, _context AppLaunchContext) (bool, error) {
	var carg1 *C.char              // in, none, string
	var carg2 *C.GAppLaunchContext // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if _context != nil {
		carg2 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	}

	cret = C.g_app_info_launch_default_for_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(_context)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoLaunchDefaultForURIAsync wraps g_app_info_launch_default_for_uri_async
// 
// The function takes the following parameters:
// 
// 	- uri string: the uri to show 
// 	- _context AppLaunchContext (nullable): optional launch context 
// 	- cancellable Cancellable (nullable): a [class@Gio.Cancellable] 
// 	- callback AsyncReadyCallback (nullable): a [type@Gio.AsyncReadyCallback] to call
//   when the request is done 
//
// Async version of [func@Gio.AppInfo.launch_default_for_uri].
// 
// This version is useful if you are interested in receiving error information
// in the case where the application is sandboxed and the portal may present an
// application chooser dialog to the user.
// 
// This is also useful if you want to be sure that the D-Bus&#x2013;activated
// applications are really started before termination and if you are interested
// in receiving error information from their activation.
func AppInfoLaunchDefaultForURIAsync(uri string, _context AppLaunchContext, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string
	var carg2 *C.GAppLaunchContext  // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if _context != nil {
		carg2 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_app_info_launch_default_for_uri_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppInfoLaunchDefaultForURIFinish wraps g_app_info_launch_default_for_uri_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the async result 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous launch-default-for-uri operation.
func AppInfoLaunchDefaultForURIFinish(result AsyncResult) (bool, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_launch_default_for_uri_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppInfoResetTypeAssociations wraps g_app_info_reset_type_associations
// 
// The function takes the following parameters:
// 
// 	- contentType string: a content type 
//
// Removes all changes to the type associations done by
// [method@Gio.AppInfo.set_as_default_for_type],
// [method@Gio.AppInfo.set_as_default_for_extension],
// [method@Gio.AppInfo.add_supports_type] or
// [method@Gio.AppInfo.remove_supports_type].
func AppInfoResetTypeAssociations(contentType string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_info_reset_type_associations(carg1)
	runtime.KeepAlive(contentType)
}

// AddSupportsType wraps g_app_info_add_supports_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: a string. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Adds a content type to the application information to indicate the
// application is capable of opening files with the given content type.
func (appinfo *AppInfoInstance) AddSupportsType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_add_supports_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CanDelete wraps g_app_info_can_delete
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Obtains the information whether the [iface@Gio.AppInfo] can be deleted.
// See [method@Gio.AppInfo.delete].
func (appinfo *AppInfoInstance) CanDelete() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_can_delete(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanRemoveSupportsType wraps g_app_info_can_remove_supports_type
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a supported content type can be removed from an application.
func (appinfo *AppInfoInstance) CanRemoveSupportsType() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_can_remove_supports_type(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Delete wraps g_app_info_delete
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tries to delete a [iface@Gio.AppInfo].
// 
// On some platforms, there may be a difference between user-defined
// [iface@Gio.AppInfo]s which can be deleted, and system-wide ones which cannot.
// See [method@Gio.AppInfo.can_delete].
func (appinfo *AppInfoInstance) Delete() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_delete(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Dup wraps g_app_info_dup
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
//
// Creates a duplicate of a [iface@Gio.AppInfo].
func (appinfo *AppInfoInstance) Dup() AppInfo {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.GAppInfo // return, full, converted

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_dup(carg0)
	runtime.KeepAlive(appinfo)

	var goret AppInfo

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_app_info_equal
// 
// The function takes the following parameters:
// 
// 	- appinfo2 AppInfo: the second [iface@Gio.AppInfo]. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if two [iface@Gio.AppInfo]s are equal.
// 
// Note that the check *may not* compare each individual field, and only does
// an identity check. In case detecting changes in the contents is needed,
// program code must additionally compare relevant fields.
func (appinfo1 *AppInfoInstance) Equal(appinfo2 AppInfo) bool {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo1))
	carg1 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo2))

	cret = C.g_app_info_equal(carg0, carg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCommandline wraps g_app_info_get_commandline
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the commandline with which the application will be
// started.
func (appinfo *AppInfoInstance) GetCommandline() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_commandline(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDescription wraps g_app_info_get_description
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets a human-readable description of an installed application.
func (appinfo *AppInfoInstance) GetDescription() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable-string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_description(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDisplayName wraps g_app_info_get_display_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the display name of the application. The display name is often more
// descriptive to the user than the name itself.
func (appinfo *AppInfoInstance) GetDisplayName() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_display_name(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetExecutable wraps g_app_info_get_executable
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the executable&#x2019;s name for the installed application.
// 
// This is intended to be used for debugging or labelling what program is going
// to be run. To launch the executable, use [method@Gio.AppInfo.launch] and related
// functions, rather than spawning the return value from this function.
func (appinfo *AppInfoInstance) GetExecutable() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_executable(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetIcon wraps g_app_info_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon (nullable) 
//
// Gets the icon for the application.
func (appinfo *AppInfoInstance) GetIcon() Icon {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.GIcon    // return, none, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_icon(carg0)
	runtime.KeepAlive(appinfo)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetID wraps g_app_info_get_id
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
// 
// Note that the returned ID may be `NULL`, depending on how the @appinfo has
// been constructed.
func (appinfo *AppInfoInstance) GetID() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string, nullable-string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_id(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetName wraps g_app_info_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the installed name of the application.
func (appinfo *AppInfoInstance) GetName() string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  *C.char     // return, none, string

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_name(carg0)
	runtime.KeepAlive(appinfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSupportedTypes wraps g_app_info_get_supported_types
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Retrieves the list of content types that @app_info claims to support.
// If this information is not provided by the environment, this function
// will return `NULL`.
// 
// This function does not take in consideration associations added with
// [method@Gio.AppInfo.add_supports_type], but only those exported directly by
// the application.
func (appinfo *AppInfoInstance) GetSupportedTypes() []string {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  **C.char    // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_get_supported_types(carg0)
	runtime.KeepAlive(appinfo)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const char**) because of unknown reason")

	return goret
}

// LaunchUrisFinish wraps g_app_info_launch_uris_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the async result 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a [method@Gio.AppInfo.launch_uris_async] operation.
func (appinfo *AppInfoInstance) LaunchUrisFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GAppInfo     // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_app_info_launch_uris_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveSupportsType wraps g_app_info_remove_supports_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: a string. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes a supported type from an application, if possible.
func (appinfo *AppInfoInstance) RemoveSupportsType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_remove_supports_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsDefaultForExtension wraps g_app_info_set_as_default_for_extension
// 
// The function takes the following parameters:
// 
// 	- extension string: a string containing the file extension (without
//   the dot). 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets the application as the default handler for the given file extension.
func (appinfo *AppInfoInstance) SetAsDefaultForExtension(extension string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_default_for_extension(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsDefaultForType wraps g_app_info_set_as_default_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets the application as the default handler for a given type.
func (appinfo *AppInfoInstance) SetAsDefaultForType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_default_for_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAsLastUsedForType wraps g_app_info_set_as_last_used_for_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: the content type. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets the application as the last used application for a given type. This
// will make the application appear as first in the list returned by
// [func@Gio.AppInfo.get_recommended_for_type], regardless of the default
// application for that content type.
func (appinfo *AppInfoInstance) SetAsLastUsedForType(contentType string) (bool, error) {
	var carg0 *C.GAppInfo // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_app_info_set_as_last_used_for_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShouldShow wraps g_app_info_should_show
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the application info should be shown in menus that
// list available applications.
func (appinfo *AppInfoInstance) ShouldShow() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_should_show(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsFiles wraps g_app_info_supports_files
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the application accepts files as arguments.
func (appinfo *AppInfoInstance) SupportsFiles() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_supports_files(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsUris wraps g_app_info_supports_uris
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the application supports reading files and directories from URIs.
func (appinfo *AppInfoInstance) SupportsUris() bool {
	var carg0 *C.GAppInfo // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GAppInfo)(UnsafeAppInfoToGlibNone(appinfo))

	cret = C.g_app_info_supports_uris(carg0)
	runtime.KeepAlive(appinfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// AsyncInitableInstance is the instance type used by all types implementing GAsyncInitable. It is used internally by the bindings. Users should use the interface [AsyncInitable] instead.
type AsyncInitableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AsyncInitable = (*AsyncInitableInstance)(nil)

// AsyncInitable wraps GAsyncInitable
//
// `GAsyncInitable` is an interface for asynchronously initializable objects.
// 
// This is the asynchronous version of [iface@Gio.Initable]; it behaves the same
// in all ways except that initialization is asynchronous. For more details
// see the descriptions on `GInitable`.
// 
// A class may implement both the `GInitable` and `GAsyncInitable` interfaces.
// 
// Users of objects implementing this are not intended to use the interface
// method directly; instead it will be used automatically in various ways.
// For C applications you generally just call [func@Gio.AsyncInitable.new_async]
// directly, or indirectly via a foo_thing_new_async() wrapper. This will call
// [method@Gio.AsyncInitable.init_async] under the covers, calling back with `NULL`
// and a set `GError` on failure.
// 
// A typical implementation might look something like this:
// 
// ```c
// enum {
//    NOT_INITIALIZED,
//    INITIALIZING,
//    INITIALIZED
// };
// 
// static void
// _foo_ready_cb (Foo *self)
// {
//   GList *l;
// 
//   self-&gt;priv-&gt;state = INITIALIZED;
// 
//   for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
//     {
//       GTask *task = l-&gt;data;
// 
//       if (self-&gt;priv-&gt;success)
//         g_task_return_boolean (task, TRUE);
//       else
//         g_task_return_new_error (task, ...);
//       g_object_unref (task);
//     }
// 
//   g_list_free (self-&gt;priv-&gt;init_results);
//   self-&gt;priv-&gt;init_results = NULL;
// }
// 
// static void
// foo_init_async (GAsyncInitable       *initable,
//                 int                   io_priority,
//                 GCancellable         *cancellable,
//                 GAsyncReadyCallback   callback,
//                 gpointer              user_data)
// {
//   Foo *self = FOO (initable);
//   GTask *task;
// 
//   task = g_task_new (initable, cancellable, callback, user_data);
//   g_task_set_name (task, G_STRFUNC);
// 
//   switch (self-&gt;priv-&gt;state)
//     {
//       case NOT_INITIALIZED:
//         _foo_get_ready (self);
//         self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
//                                                   task);
//         self-&gt;priv-&gt;state = INITIALIZING;
//         break;
//       case INITIALIZING:
//         self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
//                                                   task);
//         break;
//       case INITIALIZED:
//         if (!self-&gt;priv-&gt;success)
//           g_task_return_new_error (task, ...);
//         else
//           g_task_return_boolean (task, TRUE);
//         g_object_unref (task);
//         break;
//     }
// }
// 
// static gboolean
// foo_init_finish (GAsyncInitable       *initable,
//                  GAsyncResult         *result,
//                  GError              **error)
// {
//   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
// 
//   return g_task_propagate_boolean (G_TASK (result), error);
// }
// 
// static void
// foo_async_initable_iface_init (gpointer g_iface,
//                                gpointer data)
// {
//   GAsyncInitableIface *iface = g_iface;
// 
//   iface-&gt;init_async = foo_init_async;
//   iface-&gt;init_finish = foo_init_finish;
// }
// ```
type AsyncInitable interface {
	upcastToGAsyncInitable() *AsyncInitableInstance

	// InitAsync wraps g_async_initable_init_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the operation 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
	//
	// Starts asynchronous initialization of the object implementing the
	// interface. This must be done before any real use of the object after
	// initial construction. If the object also implements #GInitable you can
	// optionally call g_initable_init() instead.
	// 
	// This method is intended for language bindings. If writing in C,
	// g_async_initable_new_async() should typically be used instead.
	// 
	// When the initialization is finished, @callback will be called. You can
	// then call g_async_initable_init_finish() to get the result of the
	// initialization.
	// 
	// Implementations may also support cancellation. If @cancellable is not
	// %NULL, then initialization can be cancelled by triggering the cancellable
	// object from another thread. If the operation was cancelled, the error
	// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
	// the object doesn't support cancellable initialization, the error
	// %G_IO_ERROR_NOT_SUPPORTED will be returned.
	// 
	// As with #GInitable, if the object is not initialized, or initialization
	// returns with an error, then all operations on the object except
	// g_object_ref() and g_object_unref() are considered to be invalid, and
	// have undefined behaviour. They will often fail with g_critical() or
	// g_warning(), but this must not be relied on.
	// 
	// Callers should not assume that a class which implements #GAsyncInitable can
	// be initialized multiple times; for more information, see g_initable_init().
	// If a class explicitly supports being initialized multiple times,
	// implementation requires yielding all subsequent calls to init_async() on the
	// results of the first call.
	// 
	// For classes that also support the #GInitable interface, the default
	// implementation of this method will run the g_initable_init() function
	// in a thread, so if you want to support asynchronous initialization via
	// threads, just implement the #GAsyncInitable interface without overriding
	// any interface methods.
	InitAsync(int32, Cancellable, AsyncReadyCallback)
	// InitFinish wraps g_async_initable_init_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes asynchronous initialization and returns the result.
	// See g_async_initable_init_async().
	InitFinish(AsyncResult) (bool, error)
	// NewFinish wraps g_async_initable_new_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: the #GAsyncResult from the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Object 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes the async construction for the various g_async_initable_new
	// calls, returning the created object or %NULL on error.
	NewFinish(AsyncResult) (gobject.Object, error)
}

var _ AsyncInitable = (*AsyncInitableInstance)(nil)

func unsafeWrapAsyncInitable(base *gobject.ObjectInstance) *AsyncInitableInstance {
	return &AsyncInitableInstance{
		Instance: *base,
	}
}

func marshalAsyncInitableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AsyncInitableInstance) upcastToGAsyncInitable() *AsyncInitableInstance {
	return a
}

// UnsafeAsyncInitableFromGlibNone is used to convert raw GAsyncInitable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibNone(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibNone(c).(AsyncInitable)
}

// UnsafeAsyncInitableFromGlibFull is used to convert raw GAsyncInitable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibFull(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibFull(c).(AsyncInitable)
}

// UnsafeAsyncInitableFromGlibBorrow is used to convert raw GAsyncInitable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAsyncInitableFromGlibBorrow(c unsafe.Pointer) AsyncInitable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AsyncInitable)
}

// UnsafeAsyncInitableToGlibNone is used to convert the instance to it's C value GAsyncInitable. This is used by the bindings internally.
func UnsafeAsyncInitableToGlibNone(c AsyncInitable) unsafe.Pointer {
	i := c.upcastToGAsyncInitable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAsyncInitableToGlibFull is used to convert the instance to it's C value GAsyncInitable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAsyncInitableToGlibFull(c AsyncInitable) unsafe.Pointer {
	i := c.upcastToGAsyncInitable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// InitAsync wraps g_async_initable_init_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the operation 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
//
// Starts asynchronous initialization of the object implementing the
// interface. This must be done before any real use of the object after
// initial construction. If the object also implements #GInitable you can
// optionally call g_initable_init() instead.
// 
// This method is intended for language bindings. If writing in C,
// g_async_initable_new_async() should typically be used instead.
// 
// When the initialization is finished, @callback will be called. You can
// then call g_async_initable_init_finish() to get the result of the
// initialization.
// 
// Implementations may also support cancellation. If @cancellable is not
// %NULL, then initialization can be cancelled by triggering the cancellable
// object from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
// the object doesn't support cancellable initialization, the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
// 
// As with #GInitable, if the object is not initialized, or initialization
// returns with an error, then all operations on the object except
// g_object_ref() and g_object_unref() are considered to be invalid, and
// have undefined behaviour. They will often fail with g_critical() or
// g_warning(), but this must not be relied on.
// 
// Callers should not assume that a class which implements #GAsyncInitable can
// be initialized multiple times; for more information, see g_initable_init().
// If a class explicitly supports being initialized multiple times,
// implementation requires yielding all subsequent calls to init_async() on the
// results of the first call.
// 
// For classes that also support the #GInitable interface, the default
// implementation of this method will run the g_initable_init() function
// in a thread, so if you want to support asynchronous initialization via
// threads, just implement the #GAsyncInitable interface without overriding
// any interface methods.
func (initable *AsyncInitableInstance) InitAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GAsyncInitable     // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_async_initable_init_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// InitFinish wraps g_async_initable_init_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes asynchronous initialization and returns the result.
// See g_async_initable_init_async().
func (initable *AsyncInitableInstance) InitFinish(res AsyncResult) (bool, error) {
	var carg0 *C.GAsyncInitable // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_initable_init_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewFinish wraps g_async_initable_new_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: the #GAsyncResult from the callback 
// 
// The function returns the following values:
// 
// 	- goret gobject.Object 
// 	- _goerr error (nullable): an error 
//
// Finishes the async construction for the various g_async_initable_new
// calls, returning the created object or %NULL on error.
func (initable *AsyncInitableInstance) NewFinish(res AsyncResult) (gobject.Object, error) {
	var carg0 *C.GAsyncInitable // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  *C.GObject        // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GAsyncInitable)(UnsafeAsyncInitableToGlibNone(initable))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_initable_new_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(res)

	var goret  gobject.Object
	var _goerr error

	goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AsyncResultInstance is the instance type used by all types implementing GAsyncResult. It is used internally by the bindings. Users should use the interface [AsyncResult] instead.
type AsyncResultInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ AsyncResult = (*AsyncResultInstance)(nil)

// AsyncResult wraps GAsyncResult
//
// `GAsyncResult` provides a base class for implementing asynchronous function results.
// 
// Asynchronous operations are broken up into two separate operations
// which are chained together by a `GAsyncReadyCallback`. To begin
// an asynchronous operation, provide a `GAsyncReadyCallback` to the
// asynchronous function. This callback will be triggered when the
// operation has completed, and must be run in a later iteration of
// the thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) from where the operation was
// initiated. It will be passed a `GAsyncResult` instance filled with the
// details of the operation's success or failure, the object the asynchronous
// function was started for and any error codes returned. The asynchronous
// callback function is then expected to call the corresponding `_finish()`
// function, passing the object the function was called for, the
// `GAsyncResult` instance, and (optionally) an @error to grab any
// error conditions that may have occurred.
// 
// The `_finish()` function for an operation takes the generic result
// (of type `GAsyncResult`) and returns the specific result that the
// operation in question yields (e.g. a [class@Gio.FileEnumerator] for a
// "enumerate children" operation). If the result or error status of the
// operation is not needed, there is no need to call the `_finish()`
// function; GIO will take care of cleaning up the result and error
// information after the `GAsyncReadyCallback` returns. You can pass
// `NULL` for the `GAsyncReadyCallback` if you don't need to take any
// action at all after the operation completes. Applications may also
// take a reference to the `GAsyncResult` and call `_finish()` later;
// however, the `_finish()` function may be called at most once.
// 
// Example of a typical asynchronous operation flow:
// 
// ```c
// void _theoretical_frobnitz_async (Theoretical         *t,
//                                   GCancellable        *c,
//                                   GAsyncReadyCallback  cb,
//                                   gpointer             u);
// 
// gboolean _theoretical_frobnitz_finish (Theoretical   *t,
//                                        GAsyncResult  *res,
//                                        GError       **e);
// 
// static void
// frobnitz_result_func (GObject      *source_object,
// 		 GAsyncResult *res,
// 		 gpointer      user_data)
// {
//   gboolean success = FALSE;
// 
//   success = _theoretical_frobnitz_finish (source_object, res, NULL);
// 
//   if (success)
//     g_printf ("Hurray!\n");
//   else
//     g_printf ("Uh oh!\n");
// 
//   ...
// 
// }
// 
// int main (int argc, void *argv[])
// {
//    ...
// 
//    _theoretical_frobnitz_async (theoretical_data,
//                                 NULL,
//                                 frobnitz_result_func,
//                                 NULL);
// 
//    ...
// }
// ```
// 
// The callback for an asynchronous operation is called only once, and is
// always called, even in the case of a cancelled operation. On cancellation
// the result is a `G_IO_ERROR_CANCELLED` error.
// 
// ## I/O Priority
// 
// Many I/O-related asynchronous operations have a priority parameter,
// which is used in certain cases to determine the order in which
// operations are executed. They are not used to determine system-wide
// I/O scheduling. Priorities are integers, with lower numbers indicating
// higher priority. It is recommended to choose priorities between
// `G_PRIORITY_LOW` and `G_PRIORITY_HIGH`, with `G_PRIORITY_DEFAULT`
// as a default.
type AsyncResult interface {
	upcastToGAsyncResult() *AsyncResultInstance

	// GetSourceObject wraps g_async_result_get_source_object
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Object (nullable) 
	//
	// Gets the source object from a [iface@Gio.AsyncResult].
	GetSourceObject() gobject.Object
	// LegacyPropagateError wraps g_async_result_legacy_propagate_error
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// If @res is a [class@Gio.SimpleAsyncResult], this is equivalent to
	// [method@Gio.SimpleAsyncResult.propagate_error]. Otherwise it returns
	// `FALSE`.
	// 
	// This can be used for legacy error handling in async `*_finish()`
	// wrapper functions that traditionally handled [class@Gio.SimpleAsyncResult]
	// error returns themselves rather than calling into the virtual method.
	// This should not be used in new code; [iface@Gio.AsyncResult] errors that are
	// set by virtual methods should also be extracted by virtual methods,
	// to enable subclasses to chain up correctly.
	LegacyPropagateError() (bool, error)
}

var _ AsyncResult = (*AsyncResultInstance)(nil)

func unsafeWrapAsyncResult(base *gobject.ObjectInstance) *AsyncResultInstance {
	return &AsyncResultInstance{
		Instance: *base,
	}
}

func marshalAsyncResultInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (a *AsyncResultInstance) upcastToGAsyncResult() *AsyncResultInstance {
	return a
}

// UnsafeAsyncResultFromGlibNone is used to convert raw GAsyncResult pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibNone(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibNone(c).(AsyncResult)
}

// UnsafeAsyncResultFromGlibFull is used to convert raw GAsyncResult pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibFull(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibFull(c).(AsyncResult)
}

// UnsafeAsyncResultFromGlibBorrow is used to convert raw GAsyncResult pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAsyncResultFromGlibBorrow(c unsafe.Pointer) AsyncResult {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AsyncResult)
}

// UnsafeAsyncResultToGlibNone is used to convert the instance to it's C value GAsyncResult. This is used by the bindings internally.
func UnsafeAsyncResultToGlibNone(c AsyncResult) unsafe.Pointer {
	i := c.upcastToGAsyncResult()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeAsyncResultToGlibFull is used to convert the instance to it's C value GAsyncResult, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAsyncResultToGlibFull(c AsyncResult) unsafe.Pointer {
	i := c.upcastToGAsyncResult()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetSourceObject wraps g_async_result_get_source_object
// 
// The function returns the following values:
// 
// 	- goret gobject.Object (nullable) 
//
// Gets the source object from a [iface@Gio.AsyncResult].
func (res *AsyncResultInstance) GetSourceObject() gobject.Object {
	var carg0 *C.GAsyncResult // in, none, converted
	var cret  *C.GObject      // return, full, converted, nullable

	carg0 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_result_get_source_object(carg0)
	runtime.KeepAlive(res)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// LegacyPropagateError wraps g_async_result_legacy_propagate_error
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// If @res is a [class@Gio.SimpleAsyncResult], this is equivalent to
// [method@Gio.SimpleAsyncResult.propagate_error]. Otherwise it returns
// `FALSE`.
// 
// This can be used for legacy error handling in async `*_finish()`
// wrapper functions that traditionally handled [class@Gio.SimpleAsyncResult]
// error returns themselves rather than calling into the virtual method.
// This should not be used in new code; [iface@Gio.AsyncResult] errors that are
// set by virtual methods should also be extracted by virtual methods,
// to enable subclasses to chain up correctly.
func (res *AsyncResultInstance) LegacyPropagateError() (bool, error) {
	var carg0 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_async_result_legacy_propagate_error(carg0, &_cerr)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConverterInstance is the instance type used by all types implementing GConverter. It is used internally by the bindings. Users should use the interface [Converter] instead.
type ConverterInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Converter = (*ConverterInstance)(nil)

// Converter wraps GConverter
//
// `GConverter` is an interface for streaming conversions.
// 
// `GConverter` is implemented by objects that convert
// binary data in various ways. The conversion can be
// stateful and may fail at any place.
// 
// Some example conversions are: character set conversion,
// compression, decompression and regular expression
// replace.
type Converter interface {
	upcastToGConverter() *ConverterInstance

	// Convert wraps g_converter_convert
	// 
	// The function takes the following parameters:
	// 
	// 	- inbuf []byte: the buffer
	//         containing the data to convert. 
	// 	- outbuf []byte: a
	//    buffer to write converted data in. 
	// 	- flags ConverterFlags: a #GConverterFlags controlling the conversion details 
	// 
	// The function returns the following values:
	// 
	// 	- bytesRead uint: will be set to the number of bytes read
	//    from @inbuf on success 
	// 	- bytesWritten uint: will be set to the number of bytes
	//    written to @outbuf on success 
	// 	- goret ConverterResult 
	// 	- _goerr error (nullable): an error 
	//
	// This is the main operation used when converting data. It is to be called
	// multiple times in a loop, and each time it will do some work, i.e.
	// producing some output (in @outbuf) or consuming some input (from @inbuf) or
	// both. If its not possible to do any work an error is returned.
	// 
	// Note that a single call may not consume all input (or any input at all).
	// Also a call may produce output even if given no input, due to state stored
	// in the converter producing output.
	// 
	// If any data was either produced or consumed, and then an error happens, then
	// only the successful conversion is reported and the error is returned on the
	// next call.
	// 
	// A full conversion loop involves calling this method repeatedly, each time
	// giving it new input and space output space. When there is no more input
	// data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
	// The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
	// each time until all data is consumed and all output is produced, then
	// %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
	// may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
	// in a decompression converter where the end of data is detectable from the
	// data (and there might even be other data after the end of the compressed data).
	// 
	// When some data has successfully been converted @bytes_read and is set to
	// the number of bytes read from @inbuf, and @bytes_written is set to indicate
	// how many bytes was written to @outbuf. If there are more data to output
	// or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
	// %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
	// then %G_CONVERTER_FINISHED is returned.
	// 
	// On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
	// Some errors need special handling:
	// 
	// %G_IO_ERROR_NO_SPACE is returned if there is not enough space
	// to write the resulting converted data, the application should
	// call the function again with a larger @outbuf to continue.
	// 
	// %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
	// input to fully determine what the conversion should produce,
	// and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
	// example with an incomplete multibyte sequence when converting text,
	// or when a regexp matches up to the end of the input (and may match
	// further input). It may also happen when @inbuf_size is zero and
	// there is no more data to produce.
	// 
	// When this happens the application should read more input and then
	// call the function again. If further input shows that there is no
	// more data call the function again with the same data but with
	// the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
	// to finish as e.g. in the regexp match case (or, to fail again with
	// %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
	// input is actually partial).
	// 
	// After g_converter_convert() has returned %G_CONVERTER_FINISHED the
	// converter object is in an invalid state where its not allowed
	// to call g_converter_convert() anymore. At this time you can only
	// free the object or call g_converter_reset() to reset it to the
	// initial state.
	// 
	// If the flag %G_CONVERTER_FLUSH is set then conversion is modified
	// to try to write out all internal state to the output. The application
	// has to call the function multiple times with the flag set, and when
	// the available input has been consumed and all internal state has
	// been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
	// really at the end) is returned instead of %G_CONVERTER_CONVERTED.
	// This is somewhat similar to what happens at the end of the input stream,
	// but done in the middle of the data.
	// 
	// This has different meanings for different conversions. For instance
	// in a compression converter it would mean that we flush all the
	// compression state into output such that if you uncompress the
	// compressed data you get back all the input data. Doing this may
	// make the final file larger due to padding though. Another example
	// is a regexp conversion, where if you at the end of the flushed data
	// have a match, but there is also a potential longer match. In the
	// non-flushed case we would ask for more input, but when flushing we
	// treat this as the end of input and do the match.
	// 
	// Flushing is not always possible (like if a charset converter flushes
	// at a partial multibyte sequence). Converters are supposed to try
	// to produce as much output as possible and then return an error
	// (typically %G_IO_ERROR_PARTIAL_INPUT).
	Convert([]byte, []byte, ConverterFlags) (uint, uint, ConverterResult, error)
	// ConvertBytes wraps g_converter_convert_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- bytes *glib.Bytes: the data to convert 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Applies @converter to the data in @bytes.
	ConvertBytes(*glib.Bytes) (*glib.Bytes, error)
	// Reset wraps g_converter_reset
	//
	// Resets all internal state in the converter, making it behave
	// as if it was just created. If the converter has any internal
	// state that would produce output then that output is lost.
	Reset()
}

var _ Converter = (*ConverterInstance)(nil)

func unsafeWrapConverter(base *gobject.ObjectInstance) *ConverterInstance {
	return &ConverterInstance{
		Instance: *base,
	}
}

func marshalConverterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (c *ConverterInstance) upcastToGConverter() *ConverterInstance {
	return c
}

// UnsafeConverterFromGlibNone is used to convert raw GConverter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterFromGlibNone(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibNone(c).(Converter)
}

// UnsafeConverterFromGlibFull is used to convert raw GConverter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterFromGlibFull(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibFull(c).(Converter)
}

// UnsafeConverterFromGlibBorrow is used to convert raw GConverter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterFromGlibBorrow(c unsafe.Pointer) Converter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Converter)
}

// UnsafeConverterToGlibNone is used to convert the instance to it's C value GConverter. This is used by the bindings internally.
func UnsafeConverterToGlibNone(c Converter) unsafe.Pointer {
	i := c.upcastToGConverter()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeConverterToGlibFull is used to convert the instance to it's C value GConverter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterToGlibFull(c Converter) unsafe.Pointer {
	i := c.upcastToGConverter()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Convert wraps g_converter_convert
// 
// The function takes the following parameters:
// 
// 	- inbuf []byte: the buffer
//         containing the data to convert. 
// 	- outbuf []byte: a
//    buffer to write converted data in. 
// 	- flags ConverterFlags: a #GConverterFlags controlling the conversion details 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: will be set to the number of bytes read
//    from @inbuf on success 
// 	- bytesWritten uint: will be set to the number of bytes
//    written to @outbuf on success 
// 	- goret ConverterResult 
// 	- _goerr error (nullable): an error 
//
// This is the main operation used when converting data. It is to be called
// multiple times in a loop, and each time it will do some work, i.e.
// producing some output (in @outbuf) or consuming some input (from @inbuf) or
// both. If its not possible to do any work an error is returned.
// 
// Note that a single call may not consume all input (or any input at all).
// Also a call may produce output even if given no input, due to state stored
// in the converter producing output.
// 
// If any data was either produced or consumed, and then an error happens, then
// only the successful conversion is reported and the error is returned on the
// next call.
// 
// A full conversion loop involves calling this method repeatedly, each time
// giving it new input and space output space. When there is no more input
// data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
// The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
// each time until all data is consumed and all output is produced, then
// %G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
// may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
// in a decompression converter where the end of data is detectable from the
// data (and there might even be other data after the end of the compressed data).
// 
// When some data has successfully been converted @bytes_read and is set to
// the number of bytes read from @inbuf, and @bytes_written is set to indicate
// how many bytes was written to @outbuf. If there are more data to output
// or consume (i.e. unless the %G_CONVERTER_INPUT_AT_END is specified) then
// %G_CONVERTER_CONVERTED is returned, and if no more data is to be output
// then %G_CONVERTER_FINISHED is returned.
// 
// On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
// Some errors need special handling:
// 
// %G_IO_ERROR_NO_SPACE is returned if there is not enough space
// to write the resulting converted data, the application should
// call the function again with a larger @outbuf to continue.
// 
// %G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
// input to fully determine what the conversion should produce,
// and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
// example with an incomplete multibyte sequence when converting text,
// or when a regexp matches up to the end of the input (and may match
// further input). It may also happen when @inbuf_size is zero and
// there is no more data to produce.
// 
// When this happens the application should read more input and then
// call the function again. If further input shows that there is no
// more data call the function again with the same data but with
// the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
// to finish as e.g. in the regexp match case (or, to fail again with
// %G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
// input is actually partial).
// 
// After g_converter_convert() has returned %G_CONVERTER_FINISHED the
// converter object is in an invalid state where its not allowed
// to call g_converter_convert() anymore. At this time you can only
// free the object or call g_converter_reset() to reset it to the
// initial state.
// 
// If the flag %G_CONVERTER_FLUSH is set then conversion is modified
// to try to write out all internal state to the output. The application
// has to call the function multiple times with the flag set, and when
// the available input has been consumed and all internal state has
// been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
// really at the end) is returned instead of %G_CONVERTER_CONVERTED.
// This is somewhat similar to what happens at the end of the input stream,
// but done in the middle of the data.
// 
// This has different meanings for different conversions. For instance
// in a compression converter it would mean that we flush all the
// compression state into output such that if you uncompress the
// compressed data you get back all the input data. Doing this may
// make the final file larger due to padding though. Another example
// is a regexp conversion, where if you at the end of the flushed data
// have a match, but there is also a potential longer match. In the
// non-flushed case we would ask for more input, but when flushing we
// treat this as the end of input and do the match.
// 
// Flushing is not always possible (like if a charset converter flushes
// at a partial multibyte sequence). Converters are supposed to try
// to produce as much output as possible and then return an error
// (typically %G_IO_ERROR_PARTIAL_INPUT).
func (converter *ConverterInstance) Convert(inbuf []byte, outbuf []byte, flags ConverterFlags) (uint, uint, ConverterResult, error) {
	var carg0 *C.GConverter      // in, none, converted
	var carg1 unsafe.Pointer     // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 unsafe.Pointer     // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg4)
	var carg4 C.gsize            // implicit
	var carg5 C.GConverterFlags  // in, none, casted
	var carg6 C.gsize            // out, full, casted
	var carg7 C.gsize            // out, full, casted
	var cret  C.GConverterResult // return, none, casted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))
	_ = inbuf
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	_ = outbuf
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg5 = C.GConverterFlags(flags)

	cret = C.g_converter_convert(carg0, carg1, carg2, carg3, carg4, carg5, &carg6, &carg7, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)
	runtime.KeepAlive(flags)

	var bytesRead    uint
	var bytesWritten uint
	var goret        ConverterResult
	var _goerr       error

	bytesRead = uint(carg6)
	bytesWritten = uint(carg7)
	goret = ConverterResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// ConvertBytes wraps g_converter_convert_bytes
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: the data to convert 
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Applies @converter to the data in @bytes.
func (converter *ConverterInstance) ConvertBytes(bytes *glib.Bytes) (*glib.Bytes, error) {
	var carg0 *C.GConverter // in, none, converted
	var carg1 *C.GBytes     // in, none, converted
	var cret  *C.GBytes     // return, full, converted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_converter_convert_bytes(carg0, carg1, &_cerr)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(bytes)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Reset wraps g_converter_reset
//
// Resets all internal state in the converter, making it behave
// as if it was just created. If the converter has any internal
// state that would produce output then that output is lost.
func (converter *ConverterInstance) Reset() {
	var carg0 *C.GConverter // in, none, converted

	carg0 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	C.g_converter_reset(carg0)
	runtime.KeepAlive(converter)
}

// DatagramBasedInstance is the instance type used by all types implementing GDatagramBased. It is used internally by the bindings. Users should use the interface [DatagramBased] instead.
type DatagramBasedInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DatagramBased = (*DatagramBasedInstance)(nil)

// DatagramBased wraps GDatagramBased
//
// Interface for socket-like objects with datagram semantics.
// 
// A `GDatagramBased` is a networking interface for representing datagram-based
// communications. It is a more or less direct mapping of the core parts of the
// BSD socket API in a portable GObject interface. It is implemented by
// [class@Gio.Socket], which wraps the UNIX socket API on UNIX and winsock2 on Windows.
// 
// `GDatagramBased` is entirely platform independent, and is intended to be used
// alongside higher-level networking APIs such as [class@Gio.IOStream].
// 
// It uses vectored scatter/gather I/O by default, allowing for many messages
// to be sent or received in a single call. Where possible, implementations of
// the interface should take advantage of vectored I/O to minimise processing
// or system calls. For example, `GSocket` uses `recvmmsg()` and `sendmmsg()`
// where possible. Callers should take advantage of scatter/gather I/O (the use of
// multiple buffers per message) to avoid unnecessary copying of data to
// assemble or disassemble a message.
// 
// Each `GDatagramBased` operation has a timeout parameter which may be negative
// for blocking behaviour, zero for non-blocking behaviour, or positive for
// timeout behaviour. A blocking operation blocks until finished or there is an
// error. A non-blocking operation will return immediately with a
// `G_IO_ERROR_WOULD_BLOCK` error if it cannot make progress. A timeout operation
// will block until the operation is complete or the timeout expires; if the
// timeout expires it will return what progress it made, or
// `G_IO_ERROR_TIMED_OUT` if no progress was made. To know when a call would
// successfully run you can call [method@Gio.DatagramBased.condition_check] or
// [method@Gio.DatagramBased.condition_wait]. You can also use
// [method@Gio.DatagramBased.create_source] and attach it to a [struct@GLib.MainContext]
// to get callbacks when I/O is possible.
// 
// When running a non-blocking operation applications should always be able to
// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns `G_IO_ERROR_WOULD_BLOCK`.
// 
// As with `GSocket`, `GDatagramBased`s can be either connection oriented (for
// example, SCTP) or connectionless (for example, UDP). `GDatagramBased`s must be
// datagram-based, not stream-based. The interface does not cover connection
// establishment &#x2014; use methods on the underlying type to establish a connection
// before sending and receiving data through the `GDatagramBased` API. For
// connectionless socket types the target/source address is specified or
// received in each I/O operation.
// 
// Like most other APIs in GLib, `GDatagramBased` is not inherently thread safe.
// To use a `GDatagramBased` concurrently from multiple threads, you must
// implement your own locking.
type DatagramBased interface {
	upcastToGDatagramBased() *DatagramBasedInstance

	// ConditionCheck wraps g_datagram_based_condition_check
	// 
	// The function takes the following parameters:
	// 
	// 	- condition glib.IOCondition: a #GIOCondition mask to check 
	// 
	// The function returns the following values:
	// 
	// 	- goret glib.IOCondition 
	//
	// Checks on the readiness of @datagram_based to perform operations. The
	// operations specified in @condition are checked for and masked against the
	// currently-satisfied conditions on @datagram_based. The result is returned.
	// 
	// %G_IO_IN will be set in the return value if data is available to read with
	// g_datagram_based_receive_messages(), or if the connection is closed remotely
	// (EOS); and if the datagram_based has not been closed locally using some
	// implementation-specific method (such as g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket).
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
	// example), all calls to this function will return %G_IO_ERROR_CLOSED.
	// 
	// %G_IO_OUT will be set if it is expected that at least one byte can be sent
	// using g_datagram_based_send_messages() without blocking. It will not be set
	// if the datagram_based has been closed locally.
	// 
	// %G_IO_HUP will be set if the connection has been closed locally.
	// 
	// %G_IO_ERR will be set if there was an asynchronous error in transmitting data
	// previously enqueued using g_datagram_based_send_messages().
	// 
	// Note that on Windows, it is possible for an operation to return
	// %G_IO_ERROR_WOULD_BLOCK even immediately after
	// g_datagram_based_condition_check() has claimed that the #GDatagramBased is
	// ready for writing. Rather than calling g_datagram_based_condition_check() and
	// then writing to the #GDatagramBased if it succeeds, it is generally better to
	// simply try writing right away, and try again later if the initial attempt
	// returns %G_IO_ERROR_WOULD_BLOCK.
	// 
	// It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
	// conditions will always be set in the output if they are true. Apart from
	// these flags, the output is guaranteed to be masked by @condition.
	// 
	// This call never blocks.
	ConditionCheck(glib.IOCondition) glib.IOCondition
	// ConditionWait wraps g_datagram_based_condition_wait
	// 
	// The function takes the following parameters:
	// 
	// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
	// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
	//   to block indefinitely 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Waits for up to @timeout microseconds for condition to become true on
	// @datagram_based. If the condition is met, %TRUE is returned.
	// 
	// If @cancellable is cancelled before the condition is met, or if @timeout is
	// reached before the condition is met, then %FALSE is returned and @error is
	// set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
	ConditionWait(glib.IOCondition, int64, Cancellable) (bool, error)
	// ReceiveMessages wraps g_datagram_based_receive_messages
	// 
	// The function takes the following parameters:
	// 
	// 	- messages []InputMessage: an array of #GInputMessage structs 
	// 	- flags int32: an int containing #GSocketMsgFlags flags for the overall operation 
	// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
	//   to block indefinitely 
	// 	- cancellable Cancellable (nullable): a %GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Receive one or more data messages from @datagram_based in one go.
	// 
	// @messages must point to an array of #GInputMessage structs and
	// @num_messages must be the length of this array. Each #GInputMessage
	// contains a pointer to an array of #GInputVector structs describing the
	// buffers that the data received in each message will be written to.
	// 
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the #GSocketMsgFlags enum, but the
	// values there are the same as the system values, and the flags
	// are passed in as-is, so you can pass in system-specific flags too. These
	// flags affect the overall receive operation. Flags affecting individual
	// messages are returned in #GInputMessage.flags.
	// 
	// The other members of #GInputMessage are treated as described in its
	// documentation.
	// 
	// If @timeout is negative the call will block until @num_messages have been
	// received, the connection is closed remotely (EOS), @cancellable is cancelled,
	// or an error occurs.
	// 
	// If @timeout is 0 the call will return up to @num_messages without blocking,
	// or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
	// to be received.
	// 
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached
	// before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
	// otherwise it will return the number of messages received before timing out.
	// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
	// recvmmsg().)
	// 
	// To be notified when messages are available, wait for the %G_IO_IN condition.
	// Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
	// g_datagram_based_receive_messages() even if you were previously notified of a
	// %G_IO_IN condition.
	// 
	// If the remote peer closes the connection, any messages queued in the
	// underlying receive buffer will be returned, and subsequent calls to
	// g_datagram_based_receive_messages() will return 0 (with no error set).
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
	// example), all calls to this function will return %G_IO_ERROR_CLOSED.
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned. If
	// @cancellable is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
	// other error.
	ReceiveMessages([]InputMessage, int32, int64, Cancellable) (int32, error)
	// SendMessages wraps g_datagram_based_send_messages
	// 
	// The function takes the following parameters:
	// 
	// 	- messages []OutputMessage: an array of #GOutputMessage structs 
	// 	- flags int32: an int containing #GSocketMsgFlags flags 
	// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
	//   to block indefinitely 
	// 	- cancellable Cancellable (nullable): a %GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Send one or more data messages from @datagram_based in one go.
	// 
	// @messages must point to an array of #GOutputMessage structs and
	// @num_messages must be the length of this array. Each #GOutputMessage
	// contains an address to send the data to, and a pointer to an array of
	// #GOutputVector structs to describe the buffers that the data to be sent
	// for each message will be gathered from.
	// 
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the #GSocketMsgFlags enum, but the
	// values there are the same as the system values, and the flags
	// are passed in as-is, so you can pass in system-specific flags too.
	// 
	// The other members of #GOutputMessage are treated as described in its
	// documentation.
	// 
	// If @timeout is negative the call will block until @num_messages have been
	// sent, @cancellable is cancelled, or an error occurs.
	// 
	// If @timeout is 0 the call will send up to @num_messages without blocking,
	// or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
	// 
	// If @timeout is positive the call will block on the same conditions as if
	// @timeout were negative. If the timeout is reached before any messages are
	// sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
	// of messages sent before timing out.
	// 
	// To be notified when messages can be sent, wait for the %G_IO_OUT condition.
	// Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
	// g_datagram_based_send_messages() even if you were previously notified of a
	// %G_IO_OUT condition. (On Windows in particular, this is very common due to
	// the way the underlying APIs work.)
	// 
	// If the connection is shut down or closed (by calling g_socket_close() or
	// g_socket_shutdown() with @shutdown_write set, if it&#x2019;s a #GSocket, for
	// example), all calls to this function will return %G_IO_ERROR_CLOSED.
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of messages
	// successfully sent before the error will be returned. If @cancellable is
	// cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
	SendMessages([]OutputMessage, int32, int64, Cancellable) (int32, error)
}

var _ DatagramBased = (*DatagramBasedInstance)(nil)

func unsafeWrapDatagramBased(base *gobject.ObjectInstance) *DatagramBasedInstance {
	return &DatagramBasedInstance{
		Instance: *base,
	}
}

func marshalDatagramBasedInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DatagramBasedInstance) upcastToGDatagramBased() *DatagramBasedInstance {
	return d
}

// UnsafeDatagramBasedFromGlibNone is used to convert raw GDatagramBased pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibNone(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibNone(c).(DatagramBased)
}

// UnsafeDatagramBasedFromGlibFull is used to convert raw GDatagramBased pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibFull(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibFull(c).(DatagramBased)
}

// UnsafeDatagramBasedFromGlibBorrow is used to convert raw GDatagramBased pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDatagramBasedFromGlibBorrow(c unsafe.Pointer) DatagramBased {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DatagramBased)
}

// UnsafeDatagramBasedToGlibNone is used to convert the instance to it's C value GDatagramBased. This is used by the bindings internally.
func UnsafeDatagramBasedToGlibNone(c DatagramBased) unsafe.Pointer {
	i := c.upcastToGDatagramBased()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDatagramBasedToGlibFull is used to convert the instance to it's C value GDatagramBased, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDatagramBasedToGlibFull(c DatagramBased) unsafe.Pointer {
	i := c.upcastToGDatagramBased()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ConditionCheck wraps g_datagram_based_condition_check
// 
// The function takes the following parameters:
// 
// 	- condition glib.IOCondition: a #GIOCondition mask to check 
// 
// The function returns the following values:
// 
// 	- goret glib.IOCondition 
//
// Checks on the readiness of @datagram_based to perform operations. The
// operations specified in @condition are checked for and masked against the
// currently-satisfied conditions on @datagram_based. The result is returned.
// 
// %G_IO_IN will be set in the return value if data is available to read with
// g_datagram_based_receive_messages(), or if the connection is closed remotely
// (EOS); and if the datagram_based has not been closed locally using some
// implementation-specific method (such as g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket).
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
// example), all calls to this function will return %G_IO_ERROR_CLOSED.
// 
// %G_IO_OUT will be set if it is expected that at least one byte can be sent
// using g_datagram_based_send_messages() without blocking. It will not be set
// if the datagram_based has been closed locally.
// 
// %G_IO_HUP will be set if the connection has been closed locally.
// 
// %G_IO_ERR will be set if there was an asynchronous error in transmitting data
// previously enqueued using g_datagram_based_send_messages().
// 
// Note that on Windows, it is possible for an operation to return
// %G_IO_ERROR_WOULD_BLOCK even immediately after
// g_datagram_based_condition_check() has claimed that the #GDatagramBased is
// ready for writing. Rather than calling g_datagram_based_condition_check() and
// then writing to the #GDatagramBased if it succeeds, it is generally better to
// simply try writing right away, and try again later if the initial attempt
// returns %G_IO_ERROR_WOULD_BLOCK.
// 
// It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition; these
// conditions will always be set in the output if they are true. Apart from
// these flags, the output is guaranteed to be masked by @condition.
// 
// This call never blocks.
func (datagramBased *DatagramBasedInstance) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 C.GIOCondition    // in, none, casted
	var cret  C.GIOCondition    // return, none, casted

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	carg1 = C.GIOCondition(condition)

	cret = C.g_datagram_based_condition_check(carg0, carg1)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)

	var goret glib.IOCondition

	goret = glib.IOCondition(cret)

	return goret
}

// ConditionWait wraps g_datagram_based_condition_wait
// 
// The function takes the following parameters:
// 
// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
//   to block indefinitely 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Waits for up to @timeout microseconds for condition to become true on
// @datagram_based. If the condition is met, %TRUE is returned.
// 
// If @cancellable is cancelled before the condition is met, or if @timeout is
// reached before the condition is met, then %FALSE is returned and @error is
// set appropriately (%G_IO_ERROR_CANCELLED or %G_IO_ERROR_TIMED_OUT).
func (datagramBased *DatagramBasedInstance) ConditionWait(condition glib.IOCondition, timeout int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 C.GIOCondition    // in, none, casted
	var carg2 C.gint64          // in, none, casted
	var carg3 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	carg1 = C.GIOCondition(condition)
	carg2 = C.gint64(timeout)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_condition_wait(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveMessages wraps g_datagram_based_receive_messages
// 
// The function takes the following parameters:
// 
// 	- messages []InputMessage: an array of #GInputMessage structs 
// 	- flags int32: an int containing #GSocketMsgFlags flags for the overall operation 
// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
//   to block indefinitely 
// 	- cancellable Cancellable (nullable): a %GCancellable 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Receive one or more data messages from @datagram_based in one go.
// 
// @messages must point to an array of #GInputMessage structs and
// @num_messages must be the length of this array. Each #GInputMessage
// contains a pointer to an array of #GInputVector structs describing the
// buffers that the data received in each message will be written to.
// 
// @flags modify how all messages are received. The commonly available
// arguments for this are available in the #GSocketMsgFlags enum, but the
// values there are the same as the system values, and the flags
// are passed in as-is, so you can pass in system-specific flags too. These
// flags affect the overall receive operation. Flags affecting individual
// messages are returned in #GInputMessage.flags.
// 
// The other members of #GInputMessage are treated as described in its
// documentation.
// 
// If @timeout is negative the call will block until @num_messages have been
// received, the connection is closed remotely (EOS), @cancellable is cancelled,
// or an error occurs.
// 
// If @timeout is 0 the call will return up to @num_messages without blocking,
// or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the operating system
// to be received.
// 
// If @timeout is positive the call will block on the same conditions as if
// @timeout were negative. If the timeout is reached
// before any messages are received, %G_IO_ERROR_TIMED_OUT is returned,
// otherwise it will return the number of messages received before timing out.
// (Note: This is effectively the behaviour of `MSG_WAITFORONE` with
// recvmmsg().)
// 
// To be notified when messages are available, wait for the %G_IO_IN condition.
// Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_receive_messages() even if you were previously notified of a
// %G_IO_IN condition.
// 
// If the remote peer closes the connection, any messages queued in the
// underlying receive buffer will be returned, and subsequent calls to
// g_datagram_based_receive_messages() will return 0 (with no error set).
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_read set, if it&#x2019;s a #GSocket, for
// example), all calls to this function will return %G_IO_ERROR_CLOSED.
// 
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be received; otherwise the number of
// messages successfully received before the error will be returned. If
// @cancellable is cancelled, %G_IO_ERROR_CANCELLED is returned as with any
// other error.
func (datagramBased *DatagramBasedInstance) ReceiveMessages(messages []InputMessage, flags int32, timeout int64, cancellable Cancellable) (int32, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 *C.GInputMessage  // in, transfer: none, C Pointers: 1, Name: array[InputMessage], array (inner GInputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 C.gint64          // in, none, casted
	var carg5 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []InputMessage (GInputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	carg4 = C.gint64(timeout)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_receive_messages(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessages wraps g_datagram_based_send_messages
// 
// The function takes the following parameters:
// 
// 	- messages []OutputMessage: an array of #GOutputMessage structs 
// 	- flags int32: an int containing #GSocketMsgFlags flags 
// 	- timeout int64: the maximum time (in microseconds) to wait, 0 to not block, or -1
//   to block indefinitely 
// 	- cancellable Cancellable (nullable): a %GCancellable 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Send one or more data messages from @datagram_based in one go.
// 
// @messages must point to an array of #GOutputMessage structs and
// @num_messages must be the length of this array. Each #GOutputMessage
// contains an address to send the data to, and a pointer to an array of
// #GOutputVector structs to describe the buffers that the data to be sent
// for each message will be gathered from.
// 
// @flags modify how the message is sent. The commonly available arguments
// for this are available in the #GSocketMsgFlags enum, but the
// values there are the same as the system values, and the flags
// are passed in as-is, so you can pass in system-specific flags too.
// 
// The other members of #GOutputMessage are treated as described in its
// documentation.
// 
// If @timeout is negative the call will block until @num_messages have been
// sent, @cancellable is cancelled, or an error occurs.
// 
// If @timeout is 0 the call will send up to @num_messages without blocking,
// or will return %G_IO_ERROR_WOULD_BLOCK if there is no space to send messages.
// 
// If @timeout is positive the call will block on the same conditions as if
// @timeout were negative. If the timeout is reached before any messages are
// sent, %G_IO_ERROR_TIMED_OUT is returned, otherwise it will return the number
// of messages sent before timing out.
// 
// To be notified when messages can be sent, wait for the %G_IO_OUT condition.
// Note though that you may still receive %G_IO_ERROR_WOULD_BLOCK from
// g_datagram_based_send_messages() even if you were previously notified of a
// %G_IO_OUT condition. (On Windows in particular, this is very common due to
// the way the underlying APIs work.)
// 
// If the connection is shut down or closed (by calling g_socket_close() or
// g_socket_shutdown() with @shutdown_write set, if it&#x2019;s a #GSocket, for
// example), all calls to this function will return %G_IO_ERROR_CLOSED.
// 
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned. If @cancellable is
// cancelled, %G_IO_ERROR_CANCELLED is returned as with any other error.
func (datagramBased *DatagramBasedInstance) SendMessages(messages []OutputMessage, flags int32, timeout int64, cancellable Cancellable) (int32, error) {
	var carg0 *C.GDatagramBased // in, none, converted
	var carg1 *C.GOutputMessage // in, transfer: none, C Pointers: 1, Name: array[OutputMessage], array (inner GOutputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 C.gint64          // in, none, casted
	var carg5 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(datagramBased))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputMessage (GOutputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	carg4 = C.gint64(timeout)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_datagram_based_send_messages(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(datagramBased)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DriveInstance is the instance type used by all types implementing GDrive. It is used internally by the bindings. Users should use the interface [Drive] instead.
type DriveInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Drive = (*DriveInstance)(nil)

// Drive wraps GDrive
//
// `GDrive` represents a piece of hardware connected to the machine.
// It&#x2019;s generally only created for removable hardware or hardware with
// removable media. For example, an optical disc drive, or a USB flash drive.
// 
// `GDrive` is a container class for [iface@Gio.Volume] objects that stem from
// the same piece of media. As such, `GDrive` abstracts a drive with
// (or without) removable media and provides operations for querying
// whether media is available, determining whether media change is
// automatically detected and ejecting the media.
// 
// If the `GDrive` reports that media isn&#x2019;t automatically detected, one
// can poll for media; typically one should not do this periodically
// as a poll for media operation is potentially expensive and may
// spin up the drive creating noise.
// 
// `GDrive` supports starting and stopping drives with authentication
// support for the former. This can be used to support a diverse set
// of use cases including connecting/disconnecting iSCSI devices,
// powering down external disk enclosures and starting/stopping
// multi-disk devices such as RAID devices. Note that the actual
// semantics and side-effects of starting/stopping a `GDrive` may vary
// according to implementation. To choose the correct verbs in e.g. a
// file manager, use [method@Gio.Drive.get_start_stop_type].
// 
// For [porting from GnomeVFS](migrating-gnome-vfs.html) note that there is no
// equivalent of `GDrive` in that API.
type Drive interface {
	upcastToGDrive() *DriveInstance

	// CanEject wraps g_drive_can_eject
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a drive can be ejected.
	CanEject() bool
	// CanPollForMedia wraps g_drive_can_poll_for_media
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a drive can be polled for media changes.
	CanPollForMedia() bool
	// CanStart wraps g_drive_can_start
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a drive can be started.
	CanStart() bool
	// CanStartDegraded wraps g_drive_can_start_degraded
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a drive can be started degraded.
	CanStartDegraded() bool
	// CanStop wraps g_drive_can_stop
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a drive can be stopped.
	CanStop() bool
	// Eject wraps g_drive_eject
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Asynchronously ejects a drive.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_drive_eject_finish() to obtain the
	// result of the operation.
	//
	// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_drive_eject_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a drive.
	//
	// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_drive_eject_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Ejects a drive. This is an asynchronous operation, and is
	// finished by calling g_drive_eject_with_operation_finish() with the @drive
	// and #GAsyncResult data returned in the @callback.
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_drive_eject_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a drive. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateIdentifiers wraps g_drive_enumerate_identifiers
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the kinds of identifiers that @drive has.
	// Use g_drive_get_identifier() to obtain the identifiers
	// themselves.
	EnumerateIdentifiers() []string
	// GetIcon wraps g_drive_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the icon for @drive.
	GetIcon() Icon
	// GetIdentifier wraps g_drive_get_identifier
	// 
	// The function takes the following parameters:
	// 
	// 	- kind string: the kind of identifier to return 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the identifier of the given kind for @drive. The only
	// identifier currently available is
	// %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
	GetIdentifier(string) string
	// GetName wraps g_drive_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name of @drive.
	GetName() string
	// GetSortKey wraps g_drive_get_sort_key
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the sort key for @drive, if any.
	GetSortKey() string
	// GetStartStopType wraps g_drive_get_start_stop_type
	// 
	// The function returns the following values:
	// 
	// 	- goret DriveStartStopType 
	//
	// Gets a hint about how a drive can be started/stopped.
	GetStartStopType() DriveStartStopType
	// GetSymbolicIcon wraps g_drive_get_symbolic_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the icon for @drive.
	GetSymbolicIcon() Icon
	// GetVolumes wraps g_drive_get_volumes
	// 
	// The function returns the following values:
	// 
	// 	- goret []Volume 
	//
	// Get a list of mountable volumes for @drive.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetVolumes() []Volume
	// HasMedia wraps g_drive_has_media
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the @drive has media. Note that the OS may not be polling
	// the drive for media changes; see g_drive_is_media_check_automatic()
	// for more details.
	HasMedia() bool
	// HasVolumes wraps g_drive_has_volumes
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check if @drive has any mountable volumes.
	HasVolumes() bool
	// IsMediaCheckAutomatic wraps g_drive_is_media_check_automatic
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @drive is capable of automatically detecting media changes.
	IsMediaCheckAutomatic() bool
	// IsMediaRemovable wraps g_drive_is_media_removable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the @drive supports removable media.
	IsMediaRemovable() bool
	// IsRemovable wraps g_drive_is_removable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the #GDrive and/or its media is considered removable by the user.
	// See g_drive_is_media_removable().
	IsRemovable() bool
	// PollForMedia wraps g_drive_poll_for_media
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Asynchronously polls @drive to see if media has been inserted or removed.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_drive_poll_for_media_finish() to obtain the
	// result of the operation.
	PollForMedia(Cancellable, AsyncReadyCallback)
	// PollForMediaFinish wraps g_drive_poll_for_media_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an operation started with g_drive_poll_for_media() on a drive.
	PollForMediaFinish(AsyncResult) (bool, error)
	// Start wraps g_drive_start
	// 
	// The function takes the following parameters:
	// 
	// 	- flags DriveStartFlags: flags affecting the start operation. 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Asynchronously starts a drive.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_drive_start_finish() to obtain the
	// result of the operation.
	Start(DriveStartFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StartFinish wraps g_drive_start_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes starting a drive.
	StartFinish(AsyncResult) (bool, error)
	// Stop wraps g_drive_stop
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for stopping. 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Asynchronously stops a drive.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_drive_stop_finish() to obtain the
	// result of the operation.
	Stop(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StopFinish wraps g_drive_stop_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes stopping a drive.
	StopFinish(AsyncResult) (bool, error)
	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Emitted when the drive's state has changed.
	ConnectChanged(func(Drive)) gobject.SignalHandle
	// ConnectDisconnected connects the provided callback to the "disconnected" signal
	//
	// This signal is emitted when the #GDrive have been
	// disconnected. If the recipient is holding references to the
	// object they should release them so the object can be
	// finalized.
	ConnectDisconnected(func(Drive)) gobject.SignalHandle
	// ConnectEjectButton connects the provided callback to the "eject-button" signal
	//
	// Emitted when the physical eject button (if any) of a drive has
	// been pressed.
	ConnectEjectButton(func(Drive)) gobject.SignalHandle
	// ConnectStopButton connects the provided callback to the "stop-button" signal
	//
	// Emitted when the physical stop button (if any) of a drive has
	// been pressed.
	ConnectStopButton(func(Drive)) gobject.SignalHandle
}

var _ Drive = (*DriveInstance)(nil)

func unsafeWrapDrive(base *gobject.ObjectInstance) *DriveInstance {
	return &DriveInstance{
		Instance: *base,
	}
}

func marshalDriveInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DriveInstance) upcastToGDrive() *DriveInstance {
	return d
}

// UnsafeDriveFromGlibNone is used to convert raw GDrive pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDriveFromGlibNone(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibNone(c).(Drive)
}

// UnsafeDriveFromGlibFull is used to convert raw GDrive pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDriveFromGlibFull(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibFull(c).(Drive)
}

// UnsafeDriveFromGlibBorrow is used to convert raw GDrive pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDriveFromGlibBorrow(c unsafe.Pointer) Drive {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Drive)
}

// UnsafeDriveToGlibNone is used to convert the instance to it's C value GDrive. This is used by the bindings internally.
func UnsafeDriveToGlibNone(c Drive) unsafe.Pointer {
	i := c.upcastToGDrive()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDriveToGlibFull is used to convert the instance to it's C value GDrive, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDriveToGlibFull(c Drive) unsafe.Pointer {
	i := c.upcastToGDrive()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_drive_can_eject
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a drive can be ejected.
func (drive *DriveInstance) CanEject() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_eject(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanPollForMedia wraps g_drive_can_poll_for_media
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a drive can be polled for media changes.
func (drive *DriveInstance) CanPollForMedia() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_poll_for_media(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStart wraps g_drive_can_start
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a drive can be started.
func (drive *DriveInstance) CanStart() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_start(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStartDegraded wraps g_drive_can_start_degraded
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a drive can be started degraded.
func (drive *DriveInstance) CanStartDegraded() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_start_degraded(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanStop wraps g_drive_can_stop
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a drive can be stopped.
func (drive *DriveInstance) CanStop() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_can_stop(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_drive_eject
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Asynchronously ejects a drive.
// 
// When the operation is finished, @callback will be called.
// You can then call g_drive_eject_finish() to obtain the
// result of the operation.
//
// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation() instead.
func (drive *DriveInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_drive_eject_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a drive.
//
// Deprecated: (since 2.22.0) Use g_drive_eject_with_operation_finish() instead.
func (drive *DriveInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_drive_eject_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Ejects a drive. This is an asynchronous operation, and is
// finished by calling g_drive_eject_with_operation_finish() with the @drive
// and #GAsyncResult data returned in the @callback.
func (drive *DriveInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_drive_eject_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a drive. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (drive *DriveInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateIdentifiers wraps g_drive_enumerate_identifiers
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the kinds of identifiers that @drive has.
// Use g_drive_get_identifier() to obtain the identifiers
// themselves.
func (drive *DriveInstance) EnumerateIdentifiers() []string {
	var carg0 *C.GDrive // in, none, converted
	var cret  **C.char  // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_enumerate_identifiers(carg0)
	runtime.KeepAlive(drive)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetIcon wraps g_drive_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the icon for @drive.
func (drive *DriveInstance) GetIcon() Icon {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_icon(carg0)
	runtime.KeepAlive(drive)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIdentifier wraps g_drive_get_identifier
// 
// The function takes the following parameters:
// 
// 	- kind string: the kind of identifier to return 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the identifier of the given kind for @drive. The only
// identifier currently available is
// %G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE.
func (drive *DriveInstance) GetIdentifier(kind string) string {
	var carg0 *C.GDrive // in, none, converted
	var carg1 *C.char   // in, none, string
	var cret  *C.char   // return, full, string, nullable-string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_drive_get_identifier(carg0, carg1)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(kind)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetName wraps g_drive_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of @drive.
func (drive *DriveInstance) GetName() string {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.char   // return, full, string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_name(carg0)
	runtime.KeepAlive(drive)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_drive_get_sort_key
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the sort key for @drive, if any.
func (drive *DriveInstance) GetSortKey() string {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.gchar  // return, none, string, nullable-string

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_sort_key(carg0)
	runtime.KeepAlive(drive)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetStartStopType wraps g_drive_get_start_stop_type
// 
// The function returns the following values:
// 
// 	- goret DriveStartStopType 
//
// Gets a hint about how a drive can be started/stopped.
func (drive *DriveInstance) GetStartStopType() DriveStartStopType {
	var carg0 *C.GDrive             // in, none, converted
	var cret  C.GDriveStartStopType // return, none, casted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_start_stop_type(carg0)
	runtime.KeepAlive(drive)

	var goret DriveStartStopType

	goret = DriveStartStopType(cret)

	return goret
}

// GetSymbolicIcon wraps g_drive_get_symbolic_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the icon for @drive.
func (drive *DriveInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_symbolic_icon(carg0)
	runtime.KeepAlive(drive)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetVolumes wraps g_drive_get_volumes
// 
// The function returns the following values:
// 
// 	- goret []Volume 
//
// Get a list of mountable volumes for @drive.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (drive *DriveInstance) GetVolumes() []Volume {
	var carg0 *C.GDrive // in, none, converted
	var cret  *C.GList  // container, transfer: full

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_get_volumes(carg0)
	runtime.KeepAlive(drive)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// HasMedia wraps g_drive_has_media
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the @drive has media. Note that the OS may not be polling
// the drive for media changes; see g_drive_is_media_check_automatic()
// for more details.
func (drive *DriveInstance) HasMedia() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_has_media(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasVolumes wraps g_drive_has_volumes
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check if @drive has any mountable volumes.
func (drive *DriveInstance) HasVolumes() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_has_volumes(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMediaCheckAutomatic wraps g_drive_is_media_check_automatic
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @drive is capable of automatically detecting media changes.
func (drive *DriveInstance) IsMediaCheckAutomatic() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_media_check_automatic(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMediaRemovable wraps g_drive_is_media_removable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the @drive supports removable media.
func (drive *DriveInstance) IsMediaRemovable() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_media_removable(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsRemovable wraps g_drive_is_removable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the #GDrive and/or its media is considered removable by the user.
// See g_drive_is_media_removable().
func (drive *DriveInstance) IsRemovable() bool {
	var carg0 *C.GDrive  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	cret = C.g_drive_is_removable(carg0)
	runtime.KeepAlive(drive)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollForMedia wraps g_drive_poll_for_media
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Asynchronously polls @drive to see if media has been inserted or removed.
// 
// When the operation is finished, @callback will be called.
// You can then call g_drive_poll_for_media_finish() to obtain the
// result of the operation.
func (drive *DriveInstance) PollForMedia(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_poll_for_media(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// PollForMediaFinish wraps g_drive_poll_for_media_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an operation started with g_drive_poll_for_media() on a drive.
func (drive *DriveInstance) PollForMediaFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_poll_for_media_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Start wraps g_drive_start
// 
// The function takes the following parameters:
// 
// 	- flags DriveStartFlags: flags affecting the start operation. 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Asynchronously starts a drive.
// 
// When the operation is finished, @callback will be called.
// You can then call g_drive_start_finish() to obtain the
// result of the operation.
func (drive *DriveInstance) Start(flags DriveStartFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GDriveStartFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GDriveStartFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_start(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StartFinish wraps g_drive_start_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes starting a drive.
func (drive *DriveInstance) StartFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_start_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Stop wraps g_drive_stop
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for stopping. 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Asynchronously stops a drive.
// 
// When the operation is finished, @callback will be called.
// You can then call g_drive_stop_finish() to obtain the
// result of the operation.
func (drive *DriveInstance) Stop(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDrive             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_drive_stop(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StopFinish wraps g_drive_stop_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes stopping a drive.
func (drive *DriveInstance) StopFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDrive       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_drive_stop_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(drive)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Emitted when the drive's state has changed.
func (o *DriveInstance) ConnectChanged(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectDisconnected connects the provided callback to the "disconnected" signal
//
// This signal is emitted when the #GDrive have been
// disconnected. If the recipient is holding references to the
// object they should release them so the object can be
// finalized.
func (o *DriveInstance) ConnectDisconnected(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("disconnected", fn)
}

// ConnectEjectButton connects the provided callback to the "eject-button" signal
//
// Emitted when the physical eject button (if any) of a drive has
// been pressed.
func (o *DriveInstance) ConnectEjectButton(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("eject-button", fn)
}

// ConnectStopButton connects the provided callback to the "stop-button" signal
//
// Emitted when the physical stop button (if any) of a drive has
// been pressed.
func (o *DriveInstance) ConnectStopButton(fn func(Drive)) gobject.SignalHandle {
	return o.Instance.Connect("stop-button", fn)
}

// DtlsConnectionInstance is the instance type used by all types implementing GDtlsConnection. It is used internally by the bindings. Users should use the interface [DtlsConnection] instead.
type DtlsConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsConnection = (*DtlsConnectionInstance)(nil)

// DtlsConnection wraps GDtlsConnection
//
// `GDtlsConnection` is the base DTLS connection class type, which wraps
// a [iface@Gio.DatagramBased] and provides DTLS encryption on top of it. Its
// subclasses, [iface@Gio.DtlsClientConnection] and
// [iface@Gio.DtlsServerConnection], implement client-side and server-side DTLS,
// respectively.
// 
// For TLS support, see [class@Gio.TlsConnection].
// 
// As DTLS is datagram based, `GDtlsConnection` implements
// [iface@Gio.DatagramBased], presenting a datagram-socket-like API for the
// encrypted connection. This operates over a base datagram connection, which is
// also a `GDatagramBased` ([property@Gio.DtlsConnection:base-socket]).
// 
// To close a DTLS connection, use [method@Gio.DtlsConnection.close].
// 
// Neither [iface@Gio.DtlsServerConnection] or [iface@Gio.DtlsClientConnection]
// set the peer address on their base [iface@Gio.DatagramBased] if it is a
// [class@Gio.Socket] &#x2014; it is up to the caller to do that if they wish. If they
// do not, and [method@Gio.Socket.close] is called on the base socket, the
// `GDtlsConnection` will not raise a `G_IO_ERROR_NOT_CONNECTED` error on
// further I/O.
type DtlsConnection interface {
	upcastToGDtlsConnection() *DtlsConnectionInstance

	// Close wraps g_dtls_connection_close
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Close the DTLS connection. This is equivalent to calling
	// g_dtls_connection_shutdown() to shut down both sides of the connection.
	// 
	// Closing a #GDtlsConnection waits for all buffered but untransmitted data to
	// be sent before it completes. It then sends a `close_notify` DTLS alert to the
	// peer and may wait for a `close_notify` to be received from the peer. It does
	// not close the underlying #GDtlsConnection:base-socket; that must be closed
	// separately.
	// 
	// Once @conn is closed, all other operations will return %G_IO_ERROR_CLOSED.
	// Closing a #GDtlsConnection multiple times will not return an error.
	// 
	// #GDtlsConnections will be automatically closed when the last reference is
	// dropped, but you might want to call this function to make sure resources are
	// released as early as possible.
	// 
	// If @cancellable is cancelled, the #GDtlsConnection may be left
	// partially-closed and any pending untransmitted data may be lost. Call
	// g_dtls_connection_close() again to complete closing the #GDtlsConnection.
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_dtls_connection_close_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the close operation is complete 
	//
	// Asynchronously close the DTLS connection. See g_dtls_connection_close() for
	// more information.
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_dtls_connection_close_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS close operation. See g_dtls_connection_close()
	// for more information.
	CloseFinish(AsyncResult) (bool, error)
	// EmitAcceptCertificate wraps g_dtls_connection_emit_accept_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- peerCert TlsCertificate: the peer's #GTlsCertificate 
	// 	- errors TlsCertificateFlags: the problems with @peer_cert 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Used by #GDtlsConnection implementations to emit the
	// #GDtlsConnection::accept-certificate signal.
	EmitAcceptCertificate(TlsCertificate, TlsCertificateFlags) bool
	// GetCertificate wraps g_dtls_connection_get_certificate
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	//
	// Gets @conn's certificate, as set by
	// g_dtls_connection_set_certificate().
	GetCertificate() TlsCertificate
	// GetCiphersuiteName wraps g_dtls_connection_get_ciphersuite_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Returns the name of the current DTLS ciphersuite, or %NULL if the
	// connection has not handshaked or has been closed. Beware that the TLS
	// backend may use any of multiple different naming conventions, because
	// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
	// are different from each other and different from the standard, IANA-
	// registered ciphersuite names. The ciphersuite name is intended to be
	// displayed to the user for informative purposes only, and parsing it
	// is not recommended.
	GetCiphersuiteName() string
	// GetDatabase wraps g_dtls_connection_get_database
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsDatabase (nullable) 
	//
	// Gets the certificate database that @conn uses to verify
	// peer certificates. See g_dtls_connection_set_database().
	GetDatabase() TlsDatabase
	// GetInteraction wraps g_dtls_connection_get_interaction
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteraction (nullable) 
	//
	// Get the object that will be used to interact with the user. It will be used
	// for things like prompting the user for passwords. If %NULL is returned, then
	// no user interaction will occur for this connection.
	GetInteraction() TlsInteraction
	// GetNegotiatedProtocol wraps g_dtls_connection_get_negotiated_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the name of the application-layer protocol negotiated during
	// the handshake.
	// 
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend
	// does not support ALPN, then this will be %NULL. See
	// g_dtls_connection_set_advertised_protocols().
	GetNegotiatedProtocol() string
	// GetPeerCertificate wraps g_dtls_connection_get_peer_certificate
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	//
	// Gets @conn's peer's certificate after the handshake has completed
	// or failed. (It is not set during the emission of
	// #GDtlsConnection::accept-certificate.)
	GetPeerCertificate() TlsCertificate
	// GetPeerCertificateErrors wraps g_dtls_connection_get_peer_certificate_errors
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// Gets the errors associated with validating @conn's peer's
	// certificate, after the handshake has completed or failed. (It is
	// not set during the emission of #GDtlsConnection::accept-certificate.)
	GetPeerCertificateErrors() TlsCertificateFlags
	// GetProtocolVersion wraps g_dtls_connection_get_protocol_version
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsProtocolVersion 
	//
	// Returns the current DTLS protocol version, which may be
	// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
	// has been closed, or if the TLS backend has implemented a protocol version
	// that is not a recognized #GTlsProtocolVersion.
	GetProtocolVersion() TlsProtocolVersion
	// GetRehandshakeMode wraps g_dtls_connection_get_rehandshake_mode
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsRehandshakeMode 
	//
	// Gets @conn rehandshaking mode. See
	// g_dtls_connection_set_rehandshake_mode() for details.
	//
	// Deprecated: (since 2.64.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	GetRehandshakeMode() TlsRehandshakeMode
	// GetRequireCloseNotify wraps g_dtls_connection_get_require_close_notify
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether or not @conn expects a proper TLS close notification
	// when the connection is closed. See
	// g_dtls_connection_set_require_close_notify() for details.
	GetRequireCloseNotify() bool
	// Handshake wraps g_dtls_connection_handshake
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts a TLS handshake on @conn.
	// 
	// On the client side, it is never necessary to call this method;
	// although the connection needs to perform a handshake after
	// connecting, #GDtlsConnection will handle this for you automatically
	// when you try to send or receive data on the connection. You can call
	// g_dtls_connection_handshake() manually if you want to know whether
	// the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case,
	// if it fails, it may not be possible to tell if it failed before
	// or after completing the handshake), but beware that servers may reject
	// client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	// 
	// Likewise, on the server side, although a handshake is necessary at
	// the beginning of the communication, you do not need to call this
	// function explicitly unless you want clearer error reporting.
	// 
	// Previously, calling g_dtls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was
	// deprecated in GLib 2.60 because rehandshaking was removed from the
	// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
	// the initial handshake will no longer do anything.
	// 
	// #GDtlsConnection::accept_certificate may be emitted during the
	// handshake.
	Handshake(Cancellable) (bool, error)
	// HandshakeAsync wraps g_dtls_connection_handshake_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the handshake is complete 
	//
	// Asynchronously performs a TLS handshake on @conn. See
	// g_dtls_connection_handshake() for more information.
	HandshakeAsync(int32, Cancellable, AsyncReadyCallback)
	// HandshakeFinish wraps g_dtls_connection_handshake_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS handshake operation. See
	// g_dtls_connection_handshake() for more information.
	HandshakeFinish(AsyncResult) (bool, error)
	// SetAdvertisedProtocols wraps g_dtls_connection_set_advertised_protocols
	// 
	// The function takes the following parameters:
	// 
	// 	- protocols []string (nullable): a %NULL-terminated
	//   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL 
	//
	// Sets the list of application-layer protocols to advertise that the
	// caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be
	// used to negotiate a compatible protocol with the peer; use
	// g_dtls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake.  Specifying %NULL for the the value
	// of @protocols will disable ALPN negotiation.
	// 
	// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols([]string)
	// SetCertificate wraps g_dtls_connection_set_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: the certificate to use for @conn 
	//
	// This sets the certificate that @conn will present to its peer
	// during the TLS handshake. For a #GDtlsServerConnection, it is
	// mandatory to set this, and that will normally be done at construct
	// time.
	// 
	// For a #GDtlsClientConnection, this is optional. If a handshake fails
	// with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
	// requires a certificate, and if you try connecting again, you should
	// call this method first. You can call
	// g_dtls_client_connection_get_accepted_cas() on the failed connection
	// to get a list of Certificate Authorities that the server will
	// accept certificates from.
	// 
	// (It is also possible that a server will allow the connection with
	// or without a certificate; in that case, if you don't provide a
	// certificate, you can tell that the server requested one by the fact
	// that g_dtls_client_connection_get_accepted_cas() will return
	// non-%NULL.)
	SetCertificate(TlsCertificate)
	// SetDatabase wraps g_dtls_connection_set_database
	// 
	// The function takes the following parameters:
	// 
	// 	- database TlsDatabase (nullable): a #GTlsDatabase 
	//
	// Sets the certificate database that is used to verify peer certificates.
	// This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to %NULL, then
	// peer certificate validation will always set the
	// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// #GDtlsConnection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// #GDtlsClientConnection:validation-flags).
	// 
	// There are nonintuitive security implications when using a non-default
	// database. See #GDtlsConnection:database for details.
	SetDatabase(TlsDatabase)
	// SetInteraction wraps g_dtls_connection_set_interaction
	// 
	// The function takes the following parameters:
	// 
	// 	- interaction TlsInteraction (nullable): an interaction object, or %NULL 
	//
	// Set the object that will be used to interact with the user. It will be used
	// for things like prompting the user for passwords.
	// 
	// The @interaction argument will normally be a derived subclass of
	// #GTlsInteraction. %NULL can also be provided if no user interaction
	// should occur for this connection.
	SetInteraction(TlsInteraction)
	// SetRehandshakeMode wraps g_dtls_connection_set_rehandshake_mode
	// 
	// The function takes the following parameters:
	// 
	// 	- mode TlsRehandshakeMode: the rehandshaking mode 
	//
	// Since GLib 2.64, changing the rehandshake mode is no longer supported
	// and will have no effect. With TLS 1.3, rehandshaking has been removed from
	// the TLS protocol, replaced by separate post-handshake authentication and
	// rekey operations.
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	SetRehandshakeMode(TlsRehandshakeMode)
	// SetRequireCloseNotify wraps g_dtls_connection_set_require_close_notify
	// 
	// The function takes the following parameters:
	// 
	// 	- requireCloseNotify bool: whether or not to require close notification 
	//
	// Sets whether or not @conn expects a proper TLS close notification
	// before the connection is closed. If this is %TRUE (the default),
	// then @conn will expect to receive a TLS close notification from its
	// peer before the connection is closed, and will return a
	// %G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	// 
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data
	// (because the application-level data includes a length field, or is
	// somehow self-delimiting); in this case, the close notify is
	// redundant and may be omitted. You
	// can use g_dtls_connection_set_require_close_notify() to tell @conn
	// to allow an "unannounced" connection close, in which case the close
	// will show up as a 0-length read, as in a non-TLS
	// #GDatagramBased, and it is up to the application to check that
	// the data has been fully received.
	// 
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_dtls_connection_close_async() on
	// @conn itself, this will send a close notification regardless of the
	// setting of this property. If you explicitly want to do an unclean
	// close, you can close @conn's #GDtlsConnection:base-socket rather
	// than closing @conn itself.
	SetRequireCloseNotify(bool)
	// Shutdown wraps g_dtls_connection_shutdown
	// 
	// The function takes the following parameters:
	// 
	// 	- shutdownRead bool: %TRUE to stop reception of incoming datagrams 
	// 	- shutdownWrite bool: %TRUE to stop sending outgoing datagrams 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Shut down part or all of a DTLS connection.
	// 
	// If @shutdown_read is %TRUE then the receiving side of the connection is shut
	// down, and further reading is disallowed. Subsequent calls to
	// g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
	// 
	// If @shutdown_write is %TRUE then the sending side of the connection is shut
	// down, and further writing is disallowed. Subsequent calls to
	// g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
	// 
	// It is allowed for both @shutdown_read and @shutdown_write to be TRUE &#x2014; this
	// is equivalent to calling g_dtls_connection_close().
	// 
	// If @cancellable is cancelled, the #GDtlsConnection may be left
	// partially-closed and any pending untransmitted data may be lost. Call
	// g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
	Shutdown(bool, bool, Cancellable) (bool, error)
	// ShutdownAsync wraps g_dtls_connection_shutdown_async
	// 
	// The function takes the following parameters:
	// 
	// 	- shutdownRead bool: %TRUE to stop reception of incoming datagrams 
	// 	- shutdownWrite bool: %TRUE to stop sending outgoing datagrams 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the shutdown operation is complete 
	//
	// Asynchronously shut down part or all of the DTLS connection. See
	// g_dtls_connection_shutdown() for more information.
	ShutdownAsync(bool, bool, int32, Cancellable, AsyncReadyCallback)
	// ShutdownFinish wraps g_dtls_connection_shutdown_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS shutdown operation. See
	// g_dtls_connection_shutdown() for more information.
	ShutdownFinish(AsyncResult) (bool, error)
	// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
	//
	// Emitted during the TLS handshake after the peer certificate has
	// been received. You can examine @peer_cert's certification path by
	// calling g_tls_certificate_get_issuer() on it.
	// 
	// For a client-side connection, @peer_cert is the server's
	// certificate, and the signal will only be emitted if the
	// certificate was not acceptable according to @conn's
	// #GDtlsClientConnection:validation_flags. If you would like the
	// certificate to be accepted despite @errors, return %TRUE from the
	// signal handler. Otherwise, if no handler accepts the certificate,
	// the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
	// 
	// GLib guarantees that if certificate verification fails, this signal
	// will be emitted with at least one error will be set in @errors, but
	// it does not guarantee that all possible errors will be set.
	// Accordingly, you may not safely decide to ignore any particular
	// type of error. For example, it would be incorrect to ignore
	// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
	// certificates, because this could potentially be the only error flag
	// set even if other problems exist with the certificate.
	// 
	// For a server-side connection, @peer_cert is the certificate
	// presented by the client, if this was requested via the server's
	// #GDtlsServerConnection:authentication_mode. On the server side,
	// the signal is always emitted when the client presents a
	// certificate, and the certificate will only be accepted if a
	// handler returns %TRUE.
	// 
	// Note that if this signal is emitted as part of asynchronous I/O
	// in the main thread, then you should not attempt to interact with
	// the user before returning from the signal handler. If you want to
	// let the user decide whether or not to accept the certificate, you
	// would have to return %FALSE from the signal handler on the first
	// attempt, and then after the connection attempt returns a
	// %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
	// if the user decides to accept the certificate, remember that fact,
	// create a new connection, and return %TRUE from the signal handler
	// the next time.
	// 
	// If you are doing I/O in another thread, you do not
	// need to worry about this, and can simply block in the signal
	// handler until the UI thread returns an answer.
	ConnectAcceptCertificate(func(DtlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle
}

var _ DtlsConnection = (*DtlsConnectionInstance)(nil)

func unsafeWrapDtlsConnection(base *gobject.ObjectInstance) *DtlsConnectionInstance {
	return &DtlsConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsConnectionInstance) upcastToGDtlsConnection() *DtlsConnectionInstance {
	return d
}

// UnsafeDtlsConnectionFromGlibNone is used to convert raw GDtlsConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibNone(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsConnection)
}

// UnsafeDtlsConnectionFromGlibFull is used to convert raw GDtlsConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibFull(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsConnection)
}

// UnsafeDtlsConnectionFromGlibBorrow is used to convert raw GDtlsConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsConnectionFromGlibBorrow(c unsafe.Pointer) DtlsConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsConnection)
}

// UnsafeDtlsConnectionToGlibNone is used to convert the instance to it's C value GDtlsConnection. This is used by the bindings internally.
func UnsafeDtlsConnectionToGlibNone(c DtlsConnection) unsafe.Pointer {
	i := c.upcastToGDtlsConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsConnectionToGlibFull is used to convert the instance to it's C value GDtlsConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsConnectionToGlibFull(c DtlsConnection) unsafe.Pointer {
	i := c.upcastToGDtlsConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Close wraps g_dtls_connection_close
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Close the DTLS connection. This is equivalent to calling
// g_dtls_connection_shutdown() to shut down both sides of the connection.
// 
// Closing a #GDtlsConnection waits for all buffered but untransmitted data to
// be sent before it completes. It then sends a `close_notify` DTLS alert to the
// peer and may wait for a `close_notify` to be received from the peer. It does
// not close the underlying #GDtlsConnection:base-socket; that must be closed
// separately.
// 
// Once @conn is closed, all other operations will return %G_IO_ERROR_CLOSED.
// Closing a #GDtlsConnection multiple times will not return an error.
// 
// #GDtlsConnections will be automatically closed when the last reference is
// dropped, but you might want to call this function to make sure resources are
// released as early as possible.
// 
// If @cancellable is cancelled, the #GDtlsConnection may be left
// partially-closed and any pending untransmitted data may be lost. Call
// g_dtls_connection_close() again to complete closing the #GDtlsConnection.
func (conn *DtlsConnectionInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_dtls_connection_close_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the close operation is complete 
//
// Asynchronously close the DTLS connection. See g_dtls_connection_close() for
// more information.
func (conn *DtlsConnectionInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_dtls_connection_close_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous TLS close operation. See g_dtls_connection_close()
// for more information.
func (conn *DtlsConnectionInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EmitAcceptCertificate wraps g_dtls_connection_emit_accept_certificate
// 
// The function takes the following parameters:
// 
// 	- peerCert TlsCertificate: the peer's #GTlsCertificate 
// 	- errors TlsCertificateFlags: the problems with @peer_cert 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Used by #GDtlsConnection implementations to emit the
// #GDtlsConnection::accept-certificate signal.
func (conn *DtlsConnectionInstance) EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GDtlsConnection     // in, none, converted
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C.g_dtls_connection_emit_accept_certificate(carg0, carg1, carg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCertificate wraps g_dtls_connection_get_certificate
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
//
// Gets @conn's certificate, as set by
// g_dtls_connection_set_certificate().
func (conn *DtlsConnectionInstance) GetCertificate() TlsCertificate {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCiphersuiteName wraps g_dtls_connection_get_ciphersuite_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the name of the current DTLS ciphersuite, or %NULL if the
// connection has not handshaked or has been closed. Beware that the TLS
// backend may use any of multiple different naming conventions, because
// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
// are different from each other and different from the standard, IANA-
// registered ciphersuite names. The ciphersuite name is intended to be
// displayed to the user for informative purposes only, and parsing it
// is not recommended.
func (conn *DtlsConnectionInstance) GetCiphersuiteName() string {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_ciphersuite_name(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetDatabase wraps g_dtls_connection_get_database
// 
// The function returns the following values:
// 
// 	- goret TlsDatabase (nullable) 
//
// Gets the certificate database that @conn uses to verify
// peer certificates. See g_dtls_connection_set_database().
func (conn *DtlsConnectionInstance) GetDatabase() TlsDatabase {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsDatabase    // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_database(carg0)
	runtime.KeepAlive(conn)

	var goret TlsDatabase

	if cret != nil {
		goret = UnsafeTlsDatabaseFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetInteraction wraps g_dtls_connection_get_interaction
// 
// The function returns the following values:
// 
// 	- goret TlsInteraction (nullable) 
//
// Get the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords. If %NULL is returned, then
// no user interaction will occur for this connection.
func (conn *DtlsConnectionInstance) GetInteraction() TlsInteraction {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsInteraction // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_interaction(carg0)
	runtime.KeepAlive(conn)

	var goret TlsInteraction

	if cret != nil {
		goret = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetNegotiatedProtocol wraps g_dtls_connection_get_negotiated_protocol
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the name of the application-layer protocol negotiated during
// the handshake.
// 
// If the peer did not use the ALPN extension, or did not advertise a
// protocol that matched one of @conn's protocols, or the TLS backend
// does not support ALPN, then this will be %NULL. See
// g_dtls_connection_set_advertised_protocols().
func (conn *DtlsConnectionInstance) GetNegotiatedProtocol() string {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_negotiated_protocol(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPeerCertificate wraps g_dtls_connection_get_peer_certificate
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
//
// Gets @conn's peer's certificate after the handshake has completed
// or failed. (It is not set during the emission of
// #GDtlsConnection::accept-certificate.)
func (conn *DtlsConnectionInstance) GetPeerCertificate() TlsCertificate {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_peer_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetPeerCertificateErrors wraps g_dtls_connection_get_peer_certificate_errors
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// Gets the errors associated with validating @conn's peer's
// certificate, after the handshake has completed or failed. (It is
// not set during the emission of #GDtlsConnection::accept-certificate.)
func (conn *DtlsConnectionInstance) GetPeerCertificateErrors() TlsCertificateFlags {
	var carg0 *C.GDtlsConnection     // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_peer_certificate_errors(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// GetProtocolVersion wraps g_dtls_connection_get_protocol_version
// 
// The function returns the following values:
// 
// 	- goret TlsProtocolVersion 
//
// Returns the current DTLS protocol version, which may be
// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
// has been closed, or if the TLS backend has implemented a protocol version
// that is not a recognized #GTlsProtocolVersion.
func (conn *DtlsConnectionInstance) GetProtocolVersion() TlsProtocolVersion {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var cret  C.GTlsProtocolVersion // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_protocol_version(carg0)
	runtime.KeepAlive(conn)

	var goret TlsProtocolVersion

	goret = TlsProtocolVersion(cret)

	return goret
}

// GetRehandshakeMode wraps g_dtls_connection_get_rehandshake_mode
// 
// The function returns the following values:
// 
// 	- goret TlsRehandshakeMode 
//
// Gets @conn rehandshaking mode. See
// g_dtls_connection_set_rehandshake_mode() for details.
//
// Deprecated: (since 2.64.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *DtlsConnectionInstance) GetRehandshakeMode() TlsRehandshakeMode {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var cret  C.GTlsRehandshakeMode // return, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_rehandshake_mode(carg0)
	runtime.KeepAlive(conn)

	var goret TlsRehandshakeMode

	goret = TlsRehandshakeMode(cret)

	return goret
}

// GetRequireCloseNotify wraps g_dtls_connection_get_require_close_notify
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether or not @conn expects a proper TLS close notification
// when the connection is closed. See
// g_dtls_connection_set_require_close_notify() for details.
func (conn *DtlsConnectionInstance) GetRequireCloseNotify() bool {
	var carg0 *C.GDtlsConnection // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))

	cret = C.g_dtls_connection_get_require_close_notify(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Handshake wraps g_dtls_connection_handshake
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts a TLS handshake on @conn.
// 
// On the client side, it is never necessary to call this method;
// although the connection needs to perform a handshake after
// connecting, #GDtlsConnection will handle this for you automatically
// when you try to send or receive data on the connection. You can call
// g_dtls_connection_handshake() manually if you want to know whether
// the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case,
// if it fails, it may not be possible to tell if it failed before
// or after completing the handshake), but beware that servers may reject
// client authentication after the handshake has completed, so a
// successful handshake does not indicate the connection will be usable.
// 
// Likewise, on the server side, although a handshake is necessary at
// the beginning of the communication, you do not need to call this
// function explicitly unless you want clearer error reporting.
// 
// Previously, calling g_dtls_connection_handshake() after the initial
// handshake would trigger a rehandshake; however, this usage was
// deprecated in GLib 2.60 because rehandshaking was removed from the
// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
// the initial handshake will no longer do anything.
// 
// #GDtlsConnection::accept_certificate may be emitted during the
// handshake.
func (conn *DtlsConnectionInstance) Handshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_handshake(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HandshakeAsync wraps g_dtls_connection_handshake_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the handshake is complete 
//
// Asynchronously performs a TLS handshake on @conn. See
// g_dtls_connection_handshake() for more information.
func (conn *DtlsConnectionInstance) HandshakeAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_handshake_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// HandshakeFinish wraps g_dtls_connection_handshake_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous TLS handshake operation. See
// g_dtls_connection_handshake() for more information.
func (conn *DtlsConnectionInstance) HandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_handshake_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAdvertisedProtocols wraps g_dtls_connection_set_advertised_protocols
// 
// The function takes the following parameters:
// 
// 	- protocols []string (nullable): a %NULL-terminated
//   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL 
//
// Sets the list of application-layer protocols to advertise that the
// caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be
// used to negotiate a compatible protocol with the peer; use
// g_dtls_connection_get_negotiated_protocol() to find the negotiated
// protocol after the handshake.  Specifying %NULL for the the value
// of @protocols will disable ALPN negotiation.
// 
// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
func (conn *DtlsConnectionInstance) SetAdvertisedProtocols(protocols []string) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 **C.gchar          // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	_ = protocols
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_dtls_connection_set_advertised_protocols(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate wraps g_dtls_connection_set_certificate
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: the certificate to use for @conn 
//
// This sets the certificate that @conn will present to its peer
// during the TLS handshake. For a #GDtlsServerConnection, it is
// mandatory to set this, and that will normally be done at construct
// time.
// 
// For a #GDtlsClientConnection, this is optional. If a handshake fails
// with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
// requires a certificate, and if you try connecting again, you should
// call this method first. You can call
// g_dtls_client_connection_get_accepted_cas() on the failed connection
// to get a list of Certificate Authorities that the server will
// accept certificates from.
// 
// (It is also possible that a server will allow the connection with
// or without a certificate; in that case, if you don't provide a
// certificate, you can tell that the server requested one by the fact
// that g_dtls_client_connection_get_accepted_cas() will return
// non-%NULL.)
func (conn *DtlsConnectionInstance) SetCertificate(certificate TlsCertificate) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	C.g_dtls_connection_set_certificate(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase wraps g_dtls_connection_set_database
// 
// The function takes the following parameters:
// 
// 	- database TlsDatabase (nullable): a #GTlsDatabase 
//
// Sets the certificate database that is used to verify peer certificates.
// This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to %NULL, then
// peer certificate validation will always set the
// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// #GDtlsConnection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// #GDtlsClientConnection:validation-flags).
// 
// There are nonintuitive security implications when using a non-default
// database. See #GDtlsConnection:database for details.
func (conn *DtlsConnectionInstance) SetDatabase(database TlsDatabase) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsDatabase    // in, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_dtls_connection_set_database(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction wraps g_dtls_connection_set_interaction
// 
// The function takes the following parameters:
// 
// 	- interaction TlsInteraction (nullable): an interaction object, or %NULL 
//
// Set the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords.
// 
// The @interaction argument will normally be a derived subclass of
// #GTlsInteraction. %NULL can also be provided if no user interaction
// should occur for this connection.
func (conn *DtlsConnectionInstance) SetInteraction(interaction TlsInteraction) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GTlsInteraction // in, none, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if interaction != nil {
		carg1 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}

	C.g_dtls_connection_set_interaction(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode wraps g_dtls_connection_set_rehandshake_mode
// 
// The function takes the following parameters:
// 
// 	- mode TlsRehandshakeMode: the rehandshaking mode 
//
// Since GLib 2.64, changing the rehandshake mode is no longer supported
// and will have no effect. With TLS 1.3, rehandshaking has been removed from
// the TLS protocol, replaced by separate post-handshake authentication and
// rekey operations.
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *DtlsConnectionInstance) SetRehandshakeMode(mode TlsRehandshakeMode) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.GTlsRehandshakeMode // in, none, casted

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = C.GTlsRehandshakeMode(mode)

	C.g_dtls_connection_set_rehandshake_mode(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify wraps g_dtls_connection_set_require_close_notify
// 
// The function takes the following parameters:
// 
// 	- requireCloseNotify bool: whether or not to require close notification 
//
// Sets whether or not @conn expects a proper TLS close notification
// before the connection is closed. If this is %TRUE (the default),
// then @conn will expect to receive a TLS close notification from its
// peer before the connection is closed, and will return a
// %G_TLS_ERROR_EOF error if the connection is closed without proper
// notification (since this may indicate a network error, or
// man-in-the-middle attack).
// 
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data
// (because the application-level data includes a length field, or is
// somehow self-delimiting); in this case, the close notify is
// redundant and may be omitted. You
// can use g_dtls_connection_set_require_close_notify() to tell @conn
// to allow an "unannounced" connection close, in which case the close
// will show up as a 0-length read, as in a non-TLS
// #GDatagramBased, and it is up to the application to check that
// the data has been fully received.
// 
// Note that this only affects the behavior when the peer closes the
// connection; when the application calls g_dtls_connection_close_async() on
// @conn itself, this will send a close notification regardless of the
// setting of this property. If you explicitly want to do an unclean
// close, you can close @conn's #GDtlsConnection:base-socket rather
// than closing @conn itself.
func (conn *DtlsConnectionInstance) SetRequireCloseNotify(requireCloseNotify bool) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if requireCloseNotify {
		carg1 = C.TRUE
	}

	C.g_dtls_connection_set_require_close_notify(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// Shutdown wraps g_dtls_connection_shutdown
// 
// The function takes the following parameters:
// 
// 	- shutdownRead bool: %TRUE to stop reception of incoming datagrams 
// 	- shutdownWrite bool: %TRUE to stop sending outgoing datagrams 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Shut down part or all of a DTLS connection.
// 
// If @shutdown_read is %TRUE then the receiving side of the connection is shut
// down, and further reading is disallowed. Subsequent calls to
// g_datagram_based_receive_messages() will return %G_IO_ERROR_CLOSED.
// 
// If @shutdown_write is %TRUE then the sending side of the connection is shut
// down, and further writing is disallowed. Subsequent calls to
// g_datagram_based_send_messages() will return %G_IO_ERROR_CLOSED.
// 
// It is allowed for both @shutdown_read and @shutdown_write to be TRUE &#x2014; this
// is equivalent to calling g_dtls_connection_close().
// 
// If @cancellable is cancelled, the #GDtlsConnection may be left
// partially-closed and any pending untransmitted data may be lost. Call
// g_dtls_connection_shutdown() again to complete closing the #GDtlsConnection.
func (conn *DtlsConnectionInstance) Shutdown(shutdownRead bool, shutdownWrite bool, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 C.gboolean         // in
	var carg2 C.gboolean         // in
	var carg3 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_dtls_connection_shutdown(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShutdownAsync wraps g_dtls_connection_shutdown_async
// 
// The function takes the following parameters:
// 
// 	- shutdownRead bool: %TRUE to stop reception of incoming datagrams 
// 	- shutdownWrite bool: %TRUE to stop sending outgoing datagrams 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the shutdown operation is complete 
//
// Asynchronously shut down part or all of the DTLS connection. See
// g_dtls_connection_shutdown() for more information.
func (conn *DtlsConnectionInstance) ShutdownAsync(shutdownRead bool, shutdownWrite bool, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDtlsConnection    // in, none, converted
	var carg1 C.gboolean            // in
	var carg2 C.gboolean            // in
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_dtls_connection_shutdown_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ShutdownFinish wraps g_dtls_connection_shutdown_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous TLS shutdown operation. See
// g_dtls_connection_shutdown() for more information.
func (conn *DtlsConnectionInstance) ShutdownFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GDtlsConnection // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GDtlsConnection)(UnsafeDtlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_dtls_connection_shutdown_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
//
// Emitted during the TLS handshake after the peer certificate has
// been received. You can examine @peer_cert's certification path by
// calling g_tls_certificate_get_issuer() on it.
// 
// For a client-side connection, @peer_cert is the server's
// certificate, and the signal will only be emitted if the
// certificate was not acceptable according to @conn's
// #GDtlsClientConnection:validation_flags. If you would like the
// certificate to be accepted despite @errors, return %TRUE from the
// signal handler. Otherwise, if no handler accepts the certificate,
// the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
// 
// GLib guarantees that if certificate verification fails, this signal
// will be emitted with at least one error will be set in @errors, but
// it does not guarantee that all possible errors will be set.
// Accordingly, you may not safely decide to ignore any particular
// type of error. For example, it would be incorrect to ignore
// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
// certificates, because this could potentially be the only error flag
// set even if other problems exist with the certificate.
// 
// For a server-side connection, @peer_cert is the certificate
// presented by the client, if this was requested via the server's
// #GDtlsServerConnection:authentication_mode. On the server side,
// the signal is always emitted when the client presents a
// certificate, and the certificate will only be accepted if a
// handler returns %TRUE.
// 
// Note that if this signal is emitted as part of asynchronous I/O
// in the main thread, then you should not attempt to interact with
// the user before returning from the signal handler. If you want to
// let the user decide whether or not to accept the certificate, you
// would have to return %FALSE from the signal handler on the first
// attempt, and then after the connection attempt returns a
// %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
// if the user decides to accept the certificate, remember that fact,
// create a new connection, and return %TRUE from the signal handler
// the next time.
// 
// If you are doing I/O in another thread, you do not
// need to worry about this, and can simply block in the signal
// handler until the UI thread returns an answer.
func (o *DtlsConnectionInstance) ConnectAcceptCertificate(fn func(DtlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle {
	return o.Instance.Connect("accept-certificate", fn)
}

// DtlsServerConnectionInstance is the instance type used by all types implementing GDtlsServerConnection. It is used internally by the bindings. Users should use the interface [DtlsServerConnection] instead.
type DtlsServerConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsServerConnection = (*DtlsServerConnectionInstance)(nil)

// DtlsServerConnection wraps GDtlsServerConnection
//
// `GDtlsServerConnection` is the server-side subclass of
// [iface@Gio.DtlsConnection], representing a server-side DTLS connection.
type DtlsServerConnection interface {
	upcastToGDtlsServerConnection() *DtlsServerConnectionInstance
}

var _ DtlsServerConnection = (*DtlsServerConnectionInstance)(nil)

func unsafeWrapDtlsServerConnection(base *gobject.ObjectInstance) *DtlsServerConnectionInstance {
	return &DtlsServerConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsServerConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsServerConnectionInstance) upcastToGDtlsServerConnection() *DtlsServerConnectionInstance {
	return d
}

// UnsafeDtlsServerConnectionFromGlibNone is used to convert raw GDtlsServerConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibNone(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionFromGlibFull is used to convert raw GDtlsServerConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibFull(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionFromGlibBorrow is used to convert raw GDtlsServerConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsServerConnectionFromGlibBorrow(c unsafe.Pointer) DtlsServerConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsServerConnection)
}

// UnsafeDtlsServerConnectionToGlibNone is used to convert the instance to it's C value GDtlsServerConnection. This is used by the bindings internally.
func UnsafeDtlsServerConnectionToGlibNone(c DtlsServerConnection) unsafe.Pointer {
	i := c.upcastToGDtlsServerConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsServerConnectionToGlibFull is used to convert the instance to it's C value GDtlsServerConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionToGlibFull(c DtlsServerConnection) unsafe.Pointer {
	i := c.upcastToGDtlsServerConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewDtlsServerConnection wraps g_dtls_server_connection_new
// 
// The function takes the following parameters:
// 
// 	- baseSocket DatagramBased: the #GDatagramBased to wrap 
// 	- certificate TlsCertificate (nullable): the default server certificate, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret DtlsServerConnection 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GDtlsServerConnection wrapping @base_socket.
func NewDtlsServerConnection(baseSocket DatagramBased, certificate TlsCertificate) (DtlsServerConnection, error) {
	var carg1 *C.GDatagramBased  // in, none, converted
	var carg2 *C.GTlsCertificate // in, none, converted, nullable
	var cret  *C.GDatagramBased  // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(baseSocket))
	if certificate != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	}

	cret = C.g_dtls_server_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(certificate)

	var goret  DtlsServerConnection
	var _goerr error

	goret = UnsafeDtlsServerConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileInstance is the instance type used by all types implementing GFile. It is used internally by the bindings. Users should use the interface [File] instead.
type FileInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ File = (*FileInstance)(nil)

// File wraps GFile
//
// `GFile` is a high level abstraction for manipulating files on a
// virtual file system. `GFile`s are lightweight, immutable objects
// that do no I/O upon creation. It is necessary to understand that
// `GFile` objects do not represent files, merely an identifier for a
// file. All file content I/O is implemented as streaming operations
// (see [class@Gio.InputStream] and [class@Gio.OutputStream]).
// 
// To construct a `GFile`, you can use:
// 
// - [func@Gio.File.new_for_path] if you have a path.
// - [func@Gio.File.new_for_uri] if you have a URI.
// - [func@Gio.File.new_for_commandline_arg] or
//   [func@Gio.File.new_for_commandline_arg_and_cwd] for a command line
//   argument.
// - [func@Gio.File.new_tmp] to create a temporary file from a template.
// - [func@Gio.File.new_tmp_async] to asynchronously create a temporary file.
// - [func@Gio.File.new_tmp_dir_async] to asynchronously create a temporary
//   directory.
// - [func@Gio.File.parse_name] from a UTF-8 string gotten from
//   [method@Gio.File.get_parse_name].
// - [func@Gio.File.new_build_filename] or [func@Gio.File.new_build_filenamev]
//   to create a file from path elements.
// 
// One way to think of a `GFile` is as an abstraction of a pathname. For
// normal files the system pathname is what is stored internally, but as
// `GFile`s are extensible it could also be something else that corresponds
// to a pathname in a userspace implementation of a filesystem.
// 
// `GFile`s make up hierarchies of directories and files that correspond to
// the files on a filesystem. You can move through the file system with
// `GFile` using [method@Gio.File.get_parent] to get an identifier for the
// parent directory, [method@Gio.File.get_child] to get a child within a
// directory, and [method@Gio.File.resolve_relative_path] to resolve a relative
// path between two `GFile`s. There can be multiple hierarchies, so you may not
// end up at the same root if you repeatedly call [method@Gio.File.get_parent]
// on two different files.
// 
// All `GFile`s have a basename (get with [method@Gio.File.get_basename]). These
// names are byte strings that are used to identify the file on the filesystem
// (relative to its parent directory) and there is no guarantees that they
// have any particular charset encoding or even make any sense at all. If
// you want to use filenames in a user interface you should use the display
// name that you can get by requesting the
// `G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME` attribute with
// [method@Gio.File.query_info]. This is guaranteed to be in UTF-8 and can be
// used in a user interface. But always store the real basename or the `GFile`
// to use to actually access the file, because there is no way to go from a
// display name to the actual name.
// 
// Using `GFile` as an identifier has the same weaknesses as using a path
// in that there may be multiple aliases for the same file. For instance,
// hard or soft links may cause two different `GFile`s to refer to the same
// file. Other possible causes for aliases are: case insensitive filesystems,
// short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
// check if two `GFile`s point to the same file you can query for the
// `G_FILE_ATTRIBUTE_ID_FILE` attribute. Note that `GFile` does some trivial
// canonicalization of pathnames passed in, so that trivial differences in
// the path string used at creation (duplicated slashes, slash at end of
// path, `.` or `..` path segments, etc) does not create different `GFile`s.
// 
// Many `GFile` operations have both synchronous and asynchronous versions
// to suit your application. Asynchronous versions of synchronous functions
// simply have `_async()` appended to their function names. The asynchronous
// I/O functions call a [callback@Gio.AsyncReadyCallback] which is then used to
// finalize the operation, producing a [iface@Gio.AsyncResult] which is then
// passed to the function&#x2019;s matching `_finish()` operation.
// 
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section](overview.html#asynchronous-programming)
// for more.
// 
// Some `GFile` operations almost always take a noticeable amount of time, and
// so do not have synchronous analogs. Notable cases include:
// 
// - [method@Gio.File.mount_mountable] to mount a mountable file.
// - [method@Gio.File.unmount_mountable_with_operation] to unmount a mountable
//   file.
// - [method@Gio.File.eject_mountable_with_operation] to eject a mountable file.
// 
// ## Entity Tags
// 
// One notable feature of `GFile`s are entity tags, or &#x2018;etags&#x2019; for
// short. Entity tags are somewhat like a more abstract version of the
// traditional mtime, and can be used to quickly determine if the file
// has been modified from the version on the file system. See the
// HTTP 1.1
// [specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
// for HTTP `ETag` headers, which are a very similar concept.
type File interface {
	upcastToGFile() *FileInstance

	// AppendTo wraps g_file_append_to
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Gets an output stream for appending data to the file.
	// If the file doesn't already exist it is created.
	// 
	// By default files created are generally readable by everyone,
	// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
	// will be made readable only to the current user, to the level that
	// is supported on the target filesystem.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// Some file systems don't allow all file names, and may return an
	// %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
	// %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
	// possible too, and depend on what kind of filesystem the file is on.
	AppendTo(FileCreateFlags, Cancellable) (FileOutputStream, error)
	// AppendToAsync wraps g_file_append_to_async
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously opens @file for appending.
	// 
	// For more details, see g_file_append_to() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_append_to_finish() to get the result
	// of the operation.
	AppendToAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// AppendToFinish wraps g_file_append_to_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file append operation started with
	// g_file_append_to_async().
	AppendToFinish(AsyncResult) (FileOutputStream, error)
	// BuildAttributeListForCopy wraps g_file_build_attribute_list_for_copy
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCopyFlags: a set of #GFileCopyFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Prepares the file attribute query string for copying to @file.
	// 
	// This function prepares an attribute query string to be
	// passed to g_file_query_info() to get a list of attributes
	// normally copied with the file (see g_file_copy_attributes()
	// for the detailed description). This function is used by the
	// implementation of g_file_copy_attributes() and is useful
	// when one needs to query and set the attributes in two
	// stages (e.g., for recursive move of a directory).
	BuildAttributeListForCopy(FileCopyFlags, Cancellable) (string, error)
	// CopyAttributes wraps g_file_copy_attributes
	// 
	// The function takes the following parameters:
	// 
	// 	- destination File: a #GFile to copy attributes to 
	// 	- flags FileCopyFlags: a set of #GFileCopyFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Copies the file attributes from @source to @destination.
	// 
	// Normally only a subset of the file attributes are copied,
	// those that are copies in a normal file copy operation
	// (which for instance does not include e.g. owner). However
	// if %G_FILE_COPY_ALL_METADATA is specified in @flags, then
	// all the metadata that is possible to copy is copied. This
	// is useful when implementing move by copy + delete source.
	CopyAttributes(File, FileCopyFlags, Cancellable) (bool, error)
	// CopyFinish wraps g_file_copy_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes copying the file started with g_file_copy_async().
	CopyFinish(AsyncResult) (bool, error)
	// Create wraps g_file_create
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a new file and returns an output stream for writing to it.
	// The file must not already exist.
	// 
	// By default files created are generally readable by everyone,
	// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
	// will be made readable only to the current user, to the level
	// that is supported on the target filesystem.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If a file or directory with this name already exists the
	// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
	// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
	// be returned. Other errors are possible too, and depend on what kind
	// of filesystem the file is on.
	Create(FileCreateFlags, Cancellable) (FileOutputStream, error)
	// CreateAsync wraps g_file_create_async
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously creates a new file and returns an output stream
	// for writing to it. The file must not already exist.
	// 
	// For more details, see g_file_create() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_create_finish() to get the result
	// of the operation.
	CreateAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// CreateFinish wraps g_file_create_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(AsyncResult) (FileOutputStream, error)
	// CreateReadwrite wraps g_file_create_readwrite
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a new file and returns a stream for reading and
	// writing to it. The file must not already exist.
	// 
	// By default files created are generally readable by everyone,
	// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
	// will be made readable only to the current user, to the level
	// that is supported on the target filesystem.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If a file or directory with this name already exists, the
	// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
	// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
	// error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
	// will be returned. Other errors are possible too, and depend on what
	// kind of filesystem the file is on.
	// 
	// Note that in many non-local file cases read and write streams are
	// not supported, so make sure you really need to do read and write
	// streaming, rather than just opening for reading or writing.
	CreateReadwrite(FileCreateFlags, Cancellable) (FileIOStream, error)
	// CreateReadwriteAsync wraps g_file_create_readwrite_async
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously creates a new file and returns a stream
	// for reading and writing to it. The file must not already exist.
	// 
	// For more details, see g_file_create_readwrite() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_create_readwrite_finish() to get
	// the result of the operation.
	CreateReadwriteAsync(FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// CreateReadwriteFinish wraps g_file_create_readwrite_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file create operation started with
	// g_file_create_readwrite_async().
	CreateReadwriteFinish(AsyncResult) (FileIOStream, error)
	// Delete wraps g_file_delete
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Deletes a file. If the @file is a directory, it will only be
	// deleted if it is empty. This has the same semantics as g_unlink().
	// 
	// If @file doesn&#x2019;t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
	// for deletion to be implemented avoiding
	// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
	// |[
	// g_autoptr(GError) local_error = NULL;
	// if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
	//     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
	//   {
	//     // deletion failed for some reason other than the file not existing:
	//     // so report the error
	//     g_warning ("Failed to delete %s: %s",
	//                g_file_peek_path (my_file), local_error-&gt;message);
	//   }
	// ]|
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Delete(Cancellable) (bool, error)
	// DeleteAsync wraps g_file_delete_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied 
	//
	// Asynchronously delete a file. If the @file is a directory, it will
	// only be deleted if it is empty.  This has the same semantics as
	// g_unlink().
	DeleteAsync(int32, Cancellable, AsyncReadyCallback)
	// DeleteFinish wraps g_file_delete_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes deleting a file started with g_file_delete_async().
	DeleteFinish(AsyncResult) (bool, error)
	// Dup wraps g_file_dup
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Duplicates a #GFile handle. This operation does not duplicate
	// the actual file or directory represented by the #GFile; see
	// g_file_copy() if attempting to copy a file.
	// 
	// g_file_dup() is useful when a second handle is needed to the same underlying
	// file, for use in a separate thread (#GFile is not thread-safe). For use
	// within the same thread, use g_object_ref() to increment the existing object&#x2019;s
	// reference count.
	// 
	// This call does no blocking I/O.
	Dup() File
	// EjectMountable wraps g_file_eject_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Starts an asynchronous eject on a mountable.
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_eject_mountable_finish().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	//
	// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation() instead.
	EjectMountable(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectMountableFinish wraps g_file_eject_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	//
	// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation_finish()
	//   instead.
	EjectMountableFinish(AsyncResult) (bool, error)
	// EjectMountableWithOperation wraps g_file_eject_mountable_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation,
	//   or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Starts an asynchronous eject on a mountable.
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_eject_mountable_with_operation_finish().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	EjectMountableWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectMountableWithOperationFinish wraps g_file_eject_mountable_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous eject operation started by
	// g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateChildren wraps g_file_enumerate_children
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileEnumerator 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the requested information about the files in a directory.
	// The result is a #GFileEnumerator object that will give out
	// #GFileInfo objects for all the files in the directory.
	// 
	// The @attributes value is a string that specifies the file
	// attributes that should be gathered. It is not an error if
	// it's not possible to read a particular requested attribute
	// from a file - it just won't be set. @attributes should
	// be a comma-separated list of attributes or attribute wildcards.
	// The wildcard "*" means all attributes, and a wildcard like
	// "standard::*" means all attributes in the standard namespace.
	// An example attribute query be "standard::*,owner::user".
	// The standard attributes are available as defines, like
	// %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
	// always be specified if you plan to call g_file_enumerator_get_child() or
	// g_file_enumerator_iterate() on the returned enumerator.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
	// be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
	// error will be returned. Other errors are possible too.
	EnumerateChildren(string, FileQueryInfoFlags, Cancellable) (FileEnumerator, error)
	// EnumerateChildrenAsync wraps g_file_enumerate_children_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously gets the requested information about the files
	// in a directory. The result is a #GFileEnumerator object that will
	// give out #GFileInfo objects for all the files in the directory.
	// 
	// For more details, see g_file_enumerate_children() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called. You can
	// then call g_file_enumerate_children_finish() to get the result of
	// the operation.
	EnumerateChildrenAsync(string, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// EnumerateChildrenFinish wraps g_file_enumerate_children_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileEnumerator 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async enumerate children operation.
	// See g_file_enumerate_children_async().
	EnumerateChildrenFinish(AsyncResult) (FileEnumerator, error)
	// Equal wraps g_file_equal
	// 
	// The function takes the following parameters:
	// 
	// 	- file2 File: the second #GFile 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the two given #GFiles refer to the same file.
	// 
	// Note that two #GFiles that differ can still refer to the same
	// file on the filesystem due to various forms of filename
	// aliasing.
	// 
	// This call does no blocking I/O.
	Equal(File) bool
	// FindEnclosingMount wraps g_file_find_enclosing_mount
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount 
	// 	- _goerr error (nullable): an error 
	//
	// Gets a #GMount for the #GFile.
	// 
	// #GMount is returned only for user interesting locations, see
	// #GVolumeMonitor. If the #GFileIface for @file does not have a #mount,
	// @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	FindEnclosingMount(Cancellable) (Mount, error)
	// FindEnclosingMountAsync wraps g_file_find_enclosing_mount_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously gets the mount for the file.
	// 
	// For more details, see g_file_find_enclosing_mount() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_find_enclosing_mount_finish() to
	// get the result of the operation.
	FindEnclosingMountAsync(int32, Cancellable, AsyncReadyCallback)
	// FindEnclosingMountFinish wraps g_file_find_enclosing_mount_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous find mount request.
	// See g_file_find_enclosing_mount_async().
	FindEnclosingMountFinish(AsyncResult) (Mount, error)
	// GetBasename wraps g_file_get_basename
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the base name (the last component of the path) for a given #GFile.
	// 
	// If called for the top level of a system (such as the filesystem root
	// or a uri like sftp://host/) it will return a single directory separator
	// (and on Windows, possibly a drive letter).
	// 
	// The base name is a byte string (not UTF-8). It has no defined encoding
	// or rules other than it may not contain zero bytes.  If you want to use
	// filenames in a user interface you should use the display name that you
	// can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
	// attribute with g_file_query_info().
	// 
	// This call does no blocking I/O.
	GetBasename() string
	// GetChild wraps g_file_get_child
	// 
	// The function takes the following parameters:
	// 
	// 	- name string: string containing the child's basename 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a child of @file with basename equal to @name.
	// 
	// Note that the file with that specific name might not exist, but
	// you can still have a #GFile that points to it. You can use this
	// for instance to create that file.
	// 
	// This call does no blocking I/O.
	GetChild(string) File
	// GetChildForDisplayName wraps g_file_get_child_for_display_name
	// 
	// The function takes the following parameters:
	// 
	// 	- displayName string: string to a possible child 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the child of @file for a given @display_name (i.e. a UTF-8
	// version of the name). If this function fails, it returns %NULL
	// and @error will be set. This is very useful when constructing a
	// #GFile for a new file and the user entered the filename in the
	// user interface, for instance when you select a directory and
	// type a filename in the file selector.
	// 
	// This call does no blocking I/O.
	GetChildForDisplayName(string) (File, error)
	// GetParent wraps g_file_get_parent
	// 
	// The function returns the following values:
	// 
	// 	- goret File (nullable) 
	//
	// Gets the parent directory for the @file.
	// If the @file represents the root directory of the
	// file system, then %NULL will be returned.
	// 
	// This call does no blocking I/O.
	GetParent() File
	// GetParseName wraps g_file_get_parse_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the parse name of the @file.
	// A parse name is a UTF-8 string that describes the
	// file such that one can get the #GFile back using
	// g_file_parse_name().
	// 
	// This is generally used to show the #GFile as a nice
	// full-pathname kind of string in a user interface,
	// like in a location entry.
	// 
	// For local files with names that can safely be converted
	// to UTF-8 the pathname is used, otherwise the IRI is used
	// (a form of URI that allows UTF-8 characters unescaped).
	// 
	// This call does no blocking I/O.
	GetParseName() string
	// GetPath wraps g_file_get_path
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
	// guaranteed to be an absolute, canonical path. It might contain symlinks.
	// 
	// This call does no blocking I/O.
	GetPath() string
	// GetRelativePath wraps g_file_get_relative_path
	// 
	// The function takes the following parameters:
	// 
	// 	- descendant File: input #GFile 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the path for @descendant relative to @parent.
	// 
	// This call does no blocking I/O.
	GetRelativePath(File) string
	// GetURI wraps g_file_get_uri
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the URI for the @file.
	// 
	// This call does no blocking I/O.
	GetURI() string
	// GetURIScheme wraps g_file_get_uri_scheme
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the URI scheme for a #GFile.
	// RFC 3986 decodes the scheme as:
	// |[
	// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
	// ]|
	// Common schemes include "file", "http", "ftp", etc.
	// 
	// The scheme can be different from the one used to construct the #GFile,
	// in that it might be replaced with one that is logically equivalent to the #GFile.
	// 
	// This call does no blocking I/O.
	GetURIScheme() string
	// HasParent wraps g_file_has_parent
	// 
	// The function takes the following parameters:
	// 
	// 	- parent File (nullable): the parent to check for, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @file has a parent, and optionally, if it is @parent.
	// 
	// If @parent is %NULL then this function returns %TRUE if @file has any
	// parent at all.  If @parent is non-%NULL then %TRUE is only returned
	// if @file is an immediate child of @parent.
	HasParent(File) bool
	// HasPrefix wraps g_file_has_prefix
	// 
	// The function takes the following parameters:
	// 
	// 	- prefix File: input #GFile 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks whether @file has the prefix specified by @prefix.
	// 
	// In other words, if the names of initial elements of @file's
	// pathname match @prefix. Only full pathname elements are matched,
	// so a path like /foo is not considered a prefix of /foobar, only
	// of /foo/bar.
	// 
	// A #GFile is not a prefix of itself. If you want to check for
	// equality, use g_file_equal().
	// 
	// This call does no I/O, as it works purely on names. As such it can
	// sometimes return %FALSE even if @file is inside a @prefix (from a
	// filesystem point of view), because the prefix of @file is an alias
	// of @prefix.
	HasPrefix(File) bool
	// HasURIScheme wraps g_file_has_uri_scheme
	// 
	// The function takes the following parameters:
	// 
	// 	- uriScheme string: a string containing a URI scheme 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks to see if a #GFile has a given URI scheme.
	// 
	// This call does no blocking I/O.
	HasURIScheme(string) bool
	// IsNative wraps g_file_is_native
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks to see if a file is native to the platform.
	// 
	// A native file is one expressed in the platform-native filename format,
	// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
	// as it might be on a locally mounted remote filesystem.
	// 
	// On some systems non-native files may be available using the native
	// filesystem via a userspace filesystem (FUSE), in these cases this call
	// will return %FALSE, but g_file_get_path() will still return a native path.
	// 
	// This call does no blocking I/O.
	IsNative() bool
	// LoadBytes wraps g_file_load_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- etagOut string (nullable): a location to place the current
	//   entity tag for the file, or %NULL if the entity tag is not needed 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Loads the contents of @file and returns it as #GBytes.
	// 
	// If @file is a resource:// based URI, the resulting bytes will reference the
	// embedded resource instead of a copy. Otherwise, this is equivalent to calling
	// g_file_load_contents() and g_bytes_new_take().
	// 
	// For resources, @etag_out will be set to %NULL.
	// 
	// The data contained in the resulting #GBytes is always zero-terminated, but
	// this is not included in the #GBytes length. The resulting #GBytes should be
	// freed with g_bytes_unref() when no longer in use.
	LoadBytes(Cancellable) (string, *glib.Bytes, error)
	// LoadBytesAsync wraps g_file_load_bytes_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously loads the contents of @file as #GBytes.
	// 
	// If @file is a resource:// based URI, the resulting bytes will reference the
	// embedded resource instead of a copy. Otherwise, this is equivalent to calling
	// g_file_load_contents_async() and g_bytes_new_take().
	// 
	// @callback should call g_file_load_bytes_finish() to get the result of this
	// asynchronous operation.
	// 
	// See g_file_load_bytes() for more information.
	LoadBytesAsync(Cancellable, AsyncReadyCallback)
	// LoadBytesFinish wraps g_file_load_bytes_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult provided to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- etagOut string (nullable): a location to place the current
	//   entity tag for the file, or %NULL if the entity tag is not needed 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Completes an asynchronous request to g_file_load_bytes_async().
	// 
	// For resources, @etag_out will be set to %NULL.
	// 
	// The data contained in the resulting #GBytes is always zero-terminated, but
	// this is not included in the #GBytes length. The resulting #GBytes should be
	// freed with g_bytes_unref() when no longer in use.
	// 
	// See g_file_load_bytes() for more information.
	LoadBytesFinish(AsyncResult) (string, *glib.Bytes, error)
	// LoadContents wraps g_file_load_contents
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- contents string: a location to place the contents of the file 
	// 	- length uint: a location to place the length of the contents of the file,
	//   or %NULL if the length is not needed 
	// 	- etagOut string (nullable): a location to place the current entity tag for the file,
	//   or %NULL if the entity tag is not needed 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Loads the content of the file into memory. The data is always
	// zero-terminated, but this is not included in the resultant @length.
	// The returned @contents should be freed with g_free() when no longer
	// needed.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	LoadContents(Cancellable) (string, string, bool, error)
	// LoadContentsAsync wraps g_file_load_contents_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
	//
	// Starts an asynchronous load of the @file's contents.
	// 
	// For more details, see g_file_load_contents() which is
	// the synchronous version of this call.
	// 
	// When the load operation has completed, @callback will be called
	// with @user data. To finish the operation, call
	// g_file_load_contents_finish() with the #GAsyncResult returned by
	// the @callback.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	LoadContentsAsync(Cancellable, AsyncReadyCallback)
	// LoadContentsFinish wraps g_file_load_contents_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- contents string: a location to place the contents of the file 
	// 	- length uint: a location to place the length of the contents of the file,
	//   or %NULL if the length is not needed 
	// 	- etagOut string (nullable): a location to place the current entity tag for the file,
	//   or %NULL if the entity tag is not needed 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous load of the @file's contents.
	// The contents are placed in @contents, and @length is set to the
	// size of the @contents string. The @contents should be freed with
	// g_free() when no longer needed. If @etag_out is present, it will be
	// set to the new entity tag for the @file.
	LoadContentsFinish(AsyncResult) (string, string, bool, error)
	// LoadPartialContentsFinish wraps g_file_load_partial_contents_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- contents string: a location to place the contents of the file 
	// 	- length uint: a location to place the length of the contents of the file,
	//   or %NULL if the length is not needed 
	// 	- etagOut string (nullable): a location to place the current entity tag for the file,
	//   or %NULL if the entity tag is not needed 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous partial load operation that was started
	// with g_file_load_partial_contents_async(). The data is always
	// zero-terminated, but this is not included in the resultant @length.
	// The returned @contents should be freed with g_free() when no longer
	// needed.
	LoadPartialContentsFinish(AsyncResult) (string, string, bool, error)
	// MakeDirectory wraps g_file_make_directory
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a directory.
	// 
	// Note that this will only create a child directory
	// of the immediate parent directory of the path or URI given by the #GFile.
	// To recursively create directories, see g_file_make_directory_with_parents().
	// 
	// This function will fail if the parent directory does not exist, setting
	// @error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
	// creating directories, this function will fail, setting @error to
	// %G_IO_ERROR_NOT_SUPPORTED. If the directory already exists,
	// [error@Gio.IOErrorEnum.EXISTS] will be returned.
	// 
	// For a local #GFile the newly created directory will have the default
	// (current) ownership and permissions of the current process.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	MakeDirectory(Cancellable) (bool, error)
	// MakeDirectoryAsync wraps g_file_make_directory_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied 
	//
	// Asynchronously creates a directory.
	MakeDirectoryAsync(int32, Cancellable, AsyncReadyCallback)
	// MakeDirectoryFinish wraps g_file_make_directory_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous directory creation, started with
	// g_file_make_directory_async().
	MakeDirectoryFinish(AsyncResult) (bool, error)
	// MakeDirectoryWithParents wraps g_file_make_directory_with_parents
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a directory and any parent directories that may not
	// exist similar to 'mkdir -p'. If the file system does not support
	// creating directories, this function will fail, setting @error to
	// %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
	// this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
	// the similar g_mkdir_with_parents().
	// 
	// For a local #GFile the newly created directories will have the default
	// (current) ownership and permissions of the current process.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	MakeDirectoryWithParents(Cancellable) (bool, error)
	// MakeSymbolicLink wraps g_file_make_symbolic_link
	// 
	// The function takes the following parameters:
	// 
	// 	- symlinkValue string: a string with the path for the target
	//   of the new symlink 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a symbolic link named @file which contains the string
	// @symlink_value.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	MakeSymbolicLink(string, Cancellable) (bool, error)
	// MakeSymbolicLinkAsync wraps g_file_make_symbolic_link_async
	// 
	// The function takes the following parameters:
	// 
	// 	- symlinkValue string: a string with the path for the target
	//   of the new symlink 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied 
	//
	// Asynchronously creates a symbolic link named @file which contains the
	// string @symlink_value.
	MakeSymbolicLinkAsync(string, int32, Cancellable, AsyncReadyCallback)
	// MakeSymbolicLinkFinish wraps g_file_make_symbolic_link_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous symbolic link creation, started with
	// g_file_make_symbolic_link_async().
	MakeSymbolicLinkFinish(AsyncResult) (bool, error)
	// MeasureDiskUsageFinish wraps g_file_measure_disk_usage_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- diskUsage uint64: the number of bytes of disk space used 
	// 	- numDirs uint64: the number of directories encountered 
	// 	- numFiles uint64: the number of non-directories encountered 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the results from an earlier call to
	// g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
	// more information.
	MeasureDiskUsageFinish(AsyncResult) (uint64, uint64, uint64, bool, error)
	// Monitor wraps g_file_monitor
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileMonitor 
	// 	- _goerr error (nullable): an error 
	//
	// Obtains a file or directory monitor for the given file,
	// depending on the type of the file.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Monitor(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MonitorDirectory wraps g_file_monitor_directory
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileMonitor 
	// 	- _goerr error (nullable): an error 
	//
	// Obtains a directory monitor for the given file.
	// This may fail if directory monitoring is not supported.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// It does not make sense for @flags to contain
	// %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
	// directories.  It is not possible to monitor all the files in a
	// directory for changes made via hard links; if you want to do this then
	// you must register individual watches with g_file_monitor().
	MonitorDirectory(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MonitorFile wraps g_file_monitor_file
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileMonitor 
	// 	- _goerr error (nullable): an error 
	//
	// Obtains a file monitor for the given file. If no file notification
	// mechanism exists, then regular polling of the file is used.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
	// will also attempt to report changes made to the file via another
	// filename (ie, a hard link). Without this flag, you can only rely on
	// changes made through the filename contained in @file to be
	// reported. Using this flag may result in an increase in resource
	// usage, and may not have any effect depending on the #GFileMonitor
	// backend and/or filesystem type.
	MonitorFile(FileMonitorFlags, Cancellable) (FileMonitor, error)
	// MountEnclosingVolume wraps g_file_mount_enclosing_volume
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountMountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation
	//   or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied, or %NULL 
	//
	// Starts a @mount_operation, mounting the volume that contains
	// the file @location.
	// 
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_mount_enclosing_volume_finish().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	MountEnclosingVolume(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountEnclosingVolumeFinish wraps g_file_mount_enclosing_volume_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a mount operation started by g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(AsyncResult) (bool, error)
	// MountMountable wraps g_file_mount_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountMountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation,
	//   or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
	// Using @mount_operation, you can request callbacks when, for instance,
	// passwords are needed during authentication.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_mount_mountable_finish() to get
	// the result of the operation.
	MountMountable(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountMountableFinish wraps g_file_mount_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a mount operation. See g_file_mount_mountable() for details.
	// 
	// Finish an asynchronous mount operation that was started
	// with g_file_mount_mountable().
	MountMountableFinish(AsyncResult) (File, error)
	// MoveFinish wraps g_file_move_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file movement, started with
	// g_file_move_async().
	MoveFinish(AsyncResult) (bool, error)
	// OpenReadwrite wraps g_file_open_readwrite
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Opens an existing file for reading and writing. The result is
	// a #GFileIOStream that can be used to read and write the contents
	// of the file.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
	// be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
	// error will be returned. Other errors are possible too, and depend on
	// what kind of filesystem the file is on. Note that in many non-local
	// file cases read and write streams are not supported, so make sure you
	// really need to do read and write streaming, rather than just opening
	// for reading or writing.
	OpenReadwrite(Cancellable) (FileIOStream, error)
	// OpenReadwriteAsync wraps g_file_open_readwrite_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously opens @file for reading and writing.
	// 
	// For more details, see g_file_open_readwrite() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_open_readwrite_finish() to get
	// the result of the operation.
	OpenReadwriteAsync(int32, Cancellable, AsyncReadyCallback)
	// OpenReadwriteFinish wraps g_file_open_readwrite_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file read operation started with
	// g_file_open_readwrite_async().
	OpenReadwriteFinish(AsyncResult) (FileIOStream, error)
	// PeekPath wraps g_file_peek_path
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full().  This is useful for example in C
	// applications which mix `g_file_*` APIs with native ones.  It
	// also avoids an extra duplicated string when possible, so will be
	// generally more efficient.
	// 
	// This call does no blocking I/O.
	PeekPath() string
	// PollMountable wraps g_file_poll_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied, or %NULL 
	//
	// Polls a file of type %G_FILE_TYPE_MOUNTABLE.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_mount_mountable_finish() to get
	// the result of the operation.
	PollMountable(Cancellable, AsyncReadyCallback)
	// PollMountableFinish wraps g_file_poll_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a poll operation. See g_file_poll_mountable() for details.
	// 
	// Finish an asynchronous poll operation that was polled
	// with g_file_poll_mountable().
	PollMountableFinish(AsyncResult) (bool, error)
	// QueryDefaultHandler wraps g_file_query_default_handler
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret AppInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Returns the #GAppInfo that is registered as the default
	// application to handle the file specified by @file.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	QueryDefaultHandler(Cancellable) (AppInfo, error)
	// QueryDefaultHandlerAsync wraps g_file_query_default_handler_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is done 
	//
	// Async version of g_file_query_default_handler().
	QueryDefaultHandlerAsync(int32, Cancellable, AsyncReadyCallback)
	// QueryDefaultHandlerFinish wraps g_file_query_default_handler_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret AppInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a g_file_query_default_handler_async() operation.
	QueryDefaultHandlerFinish(AsyncResult) (AppInfo, error)
	// QueryExists wraps g_file_query_exists
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Utility function to check if a particular file exists.
	// 
	// The fallback implementation of this API is using [method@Gio.File.query_info]
	// and therefore may do blocking I/O. To asynchronously query the existence
	// of a file, use [method@Gio.File.query_info_async].
	// 
	// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
	// and then execute something based on the outcome of that, because the
	// file might have been created or removed in between the operations. The
	// general approach to handling that is to not check, but just do the
	// operation and handle the errors as they come.
	// 
	// As an example of race-free checking, take the case of reading a file,
	// and if it doesn't exist, creating it. There are two racy versions: read
	// it, and on error create it; and: check if it exists, if not create it.
	// These can both result in two processes creating the file (with perhaps
	// a partially written file as the result). The correct approach is to
	// always try to create the file with g_file_create() which will either
	// atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
	// 
	// However, in many cases an existence check is useful in a user interface,
	// for instance to make a menu item sensitive/insensitive, so that you don't
	// have to fool users that something is possible and then just show an error
	// dialog. If you do this, you should make sure to also handle the errors
	// that can happen due to races when you execute the operation.
	QueryExists(Cancellable) bool
	// QueryFileType wraps g_file_query_file_type
	// 
	// The function takes the following parameters:
	// 
	// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags passed to g_file_query_info() 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileType 
	//
	// Utility function to inspect the #GFileType of a file. This is
	// implemented using g_file_query_info() and as such does blocking I/O.
	// 
	// The primary use case of this method is to check if a file is
	// a regular file, directory, or symlink.
	QueryFileType(FileQueryInfoFlags, Cancellable) FileType
	// QueryFilesystemInfo wraps g_file_query_filesystem_info
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Similar to g_file_query_info(), but obtains information
	// about the filesystem the @file is on, rather than the file itself.
	// For instance the amount of space available and the type of
	// the filesystem.
	// 
	// The @attributes value is a string that specifies the attributes
	// that should be gathered. It is not an error if it's not possible
	// to read a particular requested attribute from a file - it just
	// won't be set. @attributes should be a comma-separated list of
	// attributes or attribute wildcards. The wildcard "*" means all
	// attributes, and a wildcard like "filesystem::*" means all attributes
	// in the filesystem namespace. The standard namespace for filesystem
	// attributes is "filesystem". Common attributes of interest are
	// %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
	// in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
	// and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
	// be returned. Other errors are possible too, and depend on what
	// kind of filesystem the file is on.
	QueryFilesystemInfo(string, Cancellable) (FileInfo, error)
	// QueryFilesystemInfoAsync wraps g_file_query_filesystem_info_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously gets the requested information about the filesystem
	// that the specified @file is on. The result is a #GFileInfo object
	// that contains key-value attributes (such as type or size for the
	// file).
	// 
	// For more details, see g_file_query_filesystem_info() which is the
	// synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called. You can
	// then call g_file_query_info_finish() to get the result of the
	// operation.
	QueryFilesystemInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryFilesystemInfoFinish wraps g_file_query_filesystem_info_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous filesystem info query.
	// See g_file_query_filesystem_info_async().
	QueryFilesystemInfoFinish(AsyncResult) (FileInfo, error)
	// QueryInfo wraps g_file_query_info
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- flags FileQueryInfoFlags: flags to affect the query operation 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the requested information about specified @file.
	// 
	// The result is a [class@Gio.FileInfo] object that contains key-value
	// attributes (such as the type or size of the file).
	// 
	// The @attributes value is a string that specifies the file
	// attributes that should be gathered. It is not an error if
	// it&#x2019;s not possible to read a particular requested attribute
	// from a file &#x2014; it just won't be set. In particular this means that if a file
	// is inaccessible (due to being in a folder with restrictive permissions), for
	// example, you can expect the returned [class@Gio.FileInfo] to have very few
	// attributes set. You should check whether an attribute is set using
	// [method@Gio.FileInfo.has_attribute] before trying to retrieve its value.
	// 
	// It is guaranteed that if any of the following attributes are listed in
	// @attributes, they will always be set in the returned [class@Gio.FileInfo],
	// even if the user doesn&#x2019;t have permissions to access the file:
	// 
	//  - [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME]
	//  - [const@Gio.FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME]
	// 
	// @attributes should be a comma-separated list of attributes or attribute
	// wildcards. The wildcard `"*"` means all attributes, and a wildcard like
	// `"standard::*"` means all attributes in the standard namespace.
	// An example attribute query might be `"standard::*,owner::user"`.
	// The standard attributes are available as defines, like
	// [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME].
	// 
	// If @cancellable is not `NULL`, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be
	// returned.
	// 
	// For symlinks, normally the information about the target of the
	// symlink is returned, rather than information about the symlink
	// itself. However if you pass [flags@Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS]
	// in @flags the information about the symlink itself will be returned.
	// Also, for symlinks that point to non-existing files the information
	// about the symlink itself will be returned.
	// 
	// If the file does not exist, the [error@Gio.IOErrorEnum.NOT_FOUND] error will be
	// returned. Other errors are possible too, and depend on what kind of
	// file system the file is on.
	QueryInfo(string, FileQueryInfoFlags, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_query_info_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: an attribute query string 
	// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously gets the requested information about specified @file.
	// The result is a #GFileInfo object that contains key-value attributes
	// (such as type or size for the file).
	// 
	// For more details, see g_file_query_info() which is the synchronous
	// version of this call.
	// 
	// When the operation is finished, @callback will be called. You can
	// then call g_file_query_info_finish() to get the result of the operation.
	QueryInfoAsync(string, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_query_info_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file info query.
	// See g_file_query_info_async().
	QueryInfoFinish(AsyncResult) (FileInfo, error)
	// QuerySettableAttributes wraps g_file_query_settable_attributes
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret *FileAttributeInfoList 
	// 	- _goerr error (nullable): an error 
	//
	// Obtain the list of settable attributes for the file.
	// 
	// Returns the type and full attribute name of all the attributes
	// that can be set on this file. This doesn't mean setting it will
	// always succeed though, you might get an access failure, or some
	// specific file may not support a specific attribute.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	QuerySettableAttributes(Cancellable) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces wraps g_file_query_writable_namespaces
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret *FileAttributeInfoList 
	// 	- _goerr error (nullable): an error 
	//
	// Obtain the list of attribute namespaces where new attributes
	// can be created by a user. An example of this is extended
	// attributes (in the "xattr" namespace).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	QueryWritableNamespaces(Cancellable) (*FileAttributeInfoList, error)
	// Read wraps g_file_read
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Opens a file for reading. The result is a #GFileInputStream that
	// can be used to read the contents of the file.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
	// returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
	// error will be returned. Other errors are possible too, and depend
	// on what kind of filesystem the file is on.
	Read(Cancellable) (FileInputStream, error)
	// ReadAsync wraps g_file_read_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously opens @file for reading.
	// 
	// For more details, see g_file_read() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_read_finish() to get the result
	// of the operation.
	ReadAsync(int32, Cancellable, AsyncReadyCallback)
	// ReadFinish wraps g_file_read_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(AsyncResult) (FileInputStream, error)
	// Replace wraps g_file_replace
	// 
	// The function takes the following parameters:
	// 
	// 	- etag string (nullable): an optional [entity tag](#entity-tags)
	//   for the current #GFile, or #NULL to ignore 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Returns an output stream for overwriting the file, possibly
	// creating a backup copy of the file first. If the file doesn't exist,
	// it will be created.
	// 
	// This will try to replace the file in the safest way possible so
	// that any errors during the writing will not affect an already
	// existing copy of the file. For instance, for local files it
	// may write to a temporary file and then atomically rename over
	// the destination when the stream is closed.
	// 
	// By default files created are generally readable by everyone,
	// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
	// will be made readable only to the current user, to the level that
	// is supported on the target filesystem.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled
	// by triggering the cancellable object from another thread. If the
	// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
	// returned.
	// 
	// If you pass in a non-%NULL @etag value and @file already exists, then
	// this value is compared to the current entity tag of the file, and if
	// they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
	// generally means that the file has been changed since you last read
	// it. You can get the new etag from g_file_output_stream_get_etag()
	// after you've finished writing and closed the #GFileOutputStream. When
	// you load a new file you can use g_file_input_stream_query_info() to
	// get the etag of the file.
	// 
	// If @make_backup is %TRUE, this function will attempt to make a
	// backup of the current file before overwriting it. If this fails
	// a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
	// want to replace anyway, try again with @make_backup set to %FALSE.
	// 
	// If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
	// be returned, and if the file is some other form of non-regular file
	// then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
	// file systems don't allow all file names, and may return an
	// %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
	// %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
	// possible too, and depend on what kind of filesystem the file is on.
	Replace(string, bool, FileCreateFlags, Cancellable) (FileOutputStream, error)
	// ReplaceAsync wraps g_file_replace_async
	// 
	// The function takes the following parameters:
	// 
	// 	- etag string (nullable): an [entity tag](#entity-tags) for the current #GFile,
	//   or %NULL to ignore 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously overwrites the file, replacing the contents,
	// possibly creating a backup copy of the file first.
	// 
	// For more details, see g_file_replace() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_replace_finish() to get the result
	// of the operation.
	ReplaceAsync(string, bool, FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// ReplaceContents wraps g_file_replace_contents
	// 
	// The function takes the following parameters:
	// 
	// 	- contents string: a string containing the new contents for @file 
	// 	- etag string (nullable): the old [entity-tag](#entity-tags) for the document,
	//   or %NULL 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- newEtag string (nullable): a location to a new [entity tag](#entity-tags)
	//   for the document. This should be freed with g_free() when no longer
	//   needed, or %NULL 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Replaces the contents of @file with @contents of @length bytes.
	// 
	// If @etag is specified (not %NULL), any existing file must have that etag,
	// or the error %G_IO_ERROR_WRONG_ETAG will be returned.
	// 
	// If @make_backup is %TRUE, this function will attempt to make a backup
	// of @file. Internally, it uses g_file_replace(), so will try to replace the
	// file contents in the safest way possible. For example, atomic renames are
	// used when replacing local files&#x2019; contents.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// The returned @new_etag can be used to verify that the file hasn't
	// changed the next time it is saved over.
	ReplaceContents(string, string, bool, FileCreateFlags, Cancellable) (string, bool, error)
	// ReplaceContentsAsync wraps g_file_replace_contents_async
	// 
	// The function takes the following parameters:
	// 
	// 	- contents string: string of contents to replace the file with 
	// 	- etag string (nullable): a new [entity tag](#entity-tags) for the @file, or %NULL 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
	//
	// Starts an asynchronous replacement of @file with the given
	// @contents of @length bytes. @etag will replace the document's
	// current entity tag.
	// 
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_replace_contents_finish().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// If @make_backup is %TRUE, this function will attempt to
	// make a backup of @file.
	// 
	// Note that no copy of @contents will be made, so it must stay valid
	// until @callback is called. See g_file_replace_contents_bytes_async()
	// for a #GBytes version that will automatically hold a reference to the
	// contents (without copying) for the duration of the call.
	ReplaceContentsAsync(string, string, bool, FileCreateFlags, Cancellable, AsyncReadyCallback)
	// ReplaceContentsBytesAsync wraps g_file_replace_contents_bytes_async
	// 
	// The function takes the following parameters:
	// 
	// 	- contents *glib.Bytes: a #GBytes 
	// 	- etag string (nullable): a new [entity tag](#entity-tags) for the @file, or %NULL 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
	//
	// Same as g_file_replace_contents_async() but takes a #GBytes input instead.
	// This function will keep a ref on @contents until the operation is done.
	// Unlike g_file_replace_contents_async() this allows forgetting about the
	// content without waiting for the callback.
	// 
	// When this operation has completed, @callback will be called with
	// @user_user data, and the operation can be finalized with
	// g_file_replace_contents_finish().
	ReplaceContentsBytesAsync(*glib.Bytes, string, bool, FileCreateFlags, Cancellable, AsyncReadyCallback)
	// ReplaceContentsFinish wraps g_file_replace_contents_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- newEtag string (nullable): a location of a new [entity tag](#entity-tags)
	//   for the document. This should be freed with g_free() when it is no
	//   longer needed, or %NULL 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous replace of the given @file. See
	// g_file_replace_contents_async(). Sets @new_etag to the new entity
	// tag for the document, if present.
	ReplaceContentsFinish(AsyncResult) (string, bool, error)
	// ReplaceFinish wraps g_file_replace_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileOutputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file replace operation started with
	// g_file_replace_async().
	ReplaceFinish(AsyncResult) (FileOutputStream, error)
	// ReplaceReadwrite wraps g_file_replace_readwrite
	// 
	// The function takes the following parameters:
	// 
	// 	- etag string (nullable): an optional [entity tag](#entity-tags)
	//   for the current #GFile, or #NULL to ignore 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Returns an output stream for overwriting the file in readwrite mode,
	// possibly creating a backup copy of the file first. If the file doesn't
	// exist, it will be created.
	// 
	// For details about the behaviour, see g_file_replace() which does the
	// same thing but returns an output stream only.
	// 
	// Note that in many non-local file cases read and write streams are not
	// supported, so make sure you really need to do read and write streaming,
	// rather than just opening for reading or writing.
	ReplaceReadwrite(string, bool, FileCreateFlags, Cancellable) (FileIOStream, error)
	// ReplaceReadwriteAsync wraps g_file_replace_readwrite_async
	// 
	// The function takes the following parameters:
	// 
	// 	- etag string (nullable): an [entity tag](#entity-tags) for the current #GFile,
	//   or %NULL to ignore 
	// 	- makeBackup bool: %TRUE if a backup should be created 
	// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously overwrites the file in read-write mode,
	// replacing the contents, possibly creating a backup copy
	// of the file first.
	// 
	// For more details, see g_file_replace_readwrite() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_replace_readwrite_finish() to get
	// the result of the operation.
	ReplaceReadwriteAsync(string, bool, FileCreateFlags, int32, Cancellable, AsyncReadyCallback)
	// ReplaceReadwriteFinish wraps g_file_replace_readwrite_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileIOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file replace operation started with
	// g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(AsyncResult) (FileIOStream, error)
	// ResolveRelativePath wraps g_file_resolve_relative_path
	// 
	// The function takes the following parameters:
	// 
	// 	- relativePath string: a given relative path string 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Resolves a relative path for @file to an absolute path.
	// 
	// This call does no blocking I/O.
	// 
	// If the @relative_path is an absolute path name, the resolution
	// is done absolutely (without taking @file path as base).
	ResolveRelativePath(string) File
	// SetAttributeByteString wraps g_file_set_attribute_byte_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value string: a string containing the attribute's new value 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
	// If @attribute is of a different type, this operation will fail,
	// returning %FALSE.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeByteString(string, string, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeInt32 wraps g_file_set_attribute_int32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value int32: a #gint32 containing the attribute's new value 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
	// If @attribute is of a different type, this operation will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt32(string, int32, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeInt64 wraps g_file_set_attribute_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value int64: a #guint64 containing the attribute's new value 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
	// If @attribute is of a different type, this operation will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeInt64(string, int64, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeString wraps g_file_set_attribute_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value string: a string containing the attribute's value 
	// 	- flags FileQueryInfoFlags: #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
	// If @attribute is of a different type, this operation will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeString(string, string, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeUint32 wraps g_file_set_attribute_uint32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value uint32: a #guint32 containing the attribute's new value 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
	// If @attribute is of a different type, this operation will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint32(string, uint32, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributeUint64 wraps g_file_set_attribute_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a string containing the attribute's name 
	// 	- value uint64: a #guint64 containing the attribute's new value 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
	// If @attribute is of a different type, this operation will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributeUint64(string, uint64, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetAttributesAsync wraps g_file_set_attributes_async
	// 
	// The function takes the following parameters:
	// 
	// 	- info FileInfo: a #GFileInfo 
	// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously sets the attributes of @file with @info.
	// 
	// For more details, see g_file_set_attributes_from_info(),
	// which is the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_set_attributes_finish() to get
	// the result of the operation.
	SetAttributesAsync(FileInfo, FileQueryInfoFlags, int32, Cancellable, AsyncReadyCallback)
	// SetAttributesFinish wraps g_file_set_attributes_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- info FileInfo: a #GFileInfo 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes setting an attribute started in g_file_set_attributes_async().
	SetAttributesFinish(AsyncResult) (FileInfo, bool, error)
	// SetAttributesFromInfo wraps g_file_set_attributes_from_info
	// 
	// The function takes the following parameters:
	// 
	// 	- info FileInfo: a #GFileInfo 
	// 	- flags FileQueryInfoFlags: #GFileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to set all attributes in the #GFileInfo on the target
	// values, not stopping on the first error.
	// 
	// If there is any error during this operation then @error will
	// be set to the first error. Error on particular fields are flagged
	// by setting the "status" field in the attribute value to
	// %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
	// also detect further errors.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetAttributesFromInfo(FileInfo, FileQueryInfoFlags, Cancellable) (bool, error)
	// SetDisplayName wraps g_file_set_display_name
	// 
	// The function takes the following parameters:
	// 
	// 	- displayName string: a string 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	// 	- _goerr error (nullable): an error 
	//
	// Renames @file to the specified display name.
	// 
	// The display name is converted from UTF-8 to the correct encoding
	// for the target filesystem if possible and the @file is renamed to this.
	// 
	// If you want to implement a rename operation in the user interface the
	// edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
	// initial value in the rename widget, and then the result after editing
	// should be passed to g_file_set_display_name().
	// 
	// On success the resulting converted filename is returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	SetDisplayName(string, Cancellable) (File, error)
	// SetDisplayNameAsync wraps g_file_set_display_name_async
	// 
	// The function takes the following parameters:
	// 
	// 	- displayName string: a string 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously sets the display name for a given #GFile.
	// 
	// For more details, see g_file_set_display_name() which is
	// the synchronous version of this call.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_set_display_name_finish() to get
	// the result of the operation.
	SetDisplayNameAsync(string, int32, Cancellable, AsyncReadyCallback)
	// SetDisplayNameFinish wraps g_file_set_display_name_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(AsyncResult) (File, error)
	// StartMountable wraps g_file_start_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- flags DriveStartFlags: flags affecting the operation 
	// 	- startOperation MountOperation (nullable): a #GMountOperation, or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied, or %NULL 
	//
	// Starts a file of type %G_FILE_TYPE_MOUNTABLE.
	// Using @start_operation, you can request callbacks when, for instance,
	// passwords are needed during authentication.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_mount_mountable_finish() to get
	// the result of the operation.
	StartMountable(DriveStartFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StartMountableFinish wraps g_file_start_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a start operation. See g_file_start_mountable() for details.
	// 
	// Finish an asynchronous start operation that was started
	// with g_file_start_mountable().
	StartMountableFinish(AsyncResult) (bool, error)
	// StopMountable wraps g_file_stop_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation,
	//   or %NULL to avoid user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied, or %NULL 
	//
	// Stops a file of type %G_FILE_TYPE_MOUNTABLE.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_stop_mountable_finish() to get
	// the result of the operation.
	StopMountable(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// StopMountableFinish wraps g_file_stop_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stop operation, see g_file_stop_mountable() for details.
	// 
	// Finish an asynchronous stop operation that was started
	// with g_file_stop_mountable().
	StopMountableFinish(AsyncResult) (bool, error)
	// SupportsThreadContexts wraps g_file_supports_thread_contexts
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @file supports thread-default main contexts
	// (see [method@GLib.MainContext.push_thread_default])
	// If this returns %FALSE, you cannot perform asynchronous operations on
	// @file in a thread that has a thread-default context.
	SupportsThreadContexts() bool
	// Trash wraps g_file_trash
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sends @file to the "Trashcan", if possible. This is similar to
	// deleting it, but the user can recover it before emptying the trashcan.
	// Trashing is disabled for system mounts by default (see
	// g_unix_mount_entry_is_system_internal()), so this call can return the
	// %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
	// mount option can be used to disable g_file_trash() support for particular
	// mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
	// Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
	// g_file_trash() support for particular system mounts.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Trash(Cancellable) (bool, error)
	// TrashAsync wraps g_file_trash_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied 
	//
	// Asynchronously sends @file to the Trash location, if possible.
	TrashAsync(int32, Cancellable, AsyncReadyCallback)
	// TrashFinish wraps g_file_trash_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous file trashing operation, started with
	// g_file_trash_async().
	TrashFinish(AsyncResult) (bool, error)
	// UnmountMountable wraps g_file_unmount_mountable
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_unmount_mountable_finish() to get
	// the result of the operation.
	//
	// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation() instead.
	UnmountMountable(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// UnmountMountableFinish wraps g_file_unmount_mountable_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an unmount operation, see g_file_unmount_mountable() for details.
	// 
	// Finish an asynchronous unmount operation that was started
	// with g_file_unmount_mountable().
	//
	// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation_finish()
	//   instead.
	UnmountMountableFinish(AsyncResult) (bool, error)
	// UnmountMountableWithOperation wraps g_file_unmount_mountable_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation,
	//   or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object,
	//   %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_file_unmount_mountable_finish() to get
	// the result of the operation.
	UnmountMountableWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// UnmountMountableWithOperationFinish wraps g_file_unmount_mountable_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an unmount operation,
	// see g_file_unmount_mountable_with_operation() for details.
	// 
	// Finish an asynchronous unmount operation that was started
	// with g_file_unmount_mountable_with_operation().
	UnmountMountableWithOperationFinish(AsyncResult) (bool, error)
}

var _ File = (*FileInstance)(nil)

func unsafeWrapFile(base *gobject.ObjectInstance) *FileInstance {
	return &FileInstance{
		Instance: *base,
	}
}

func marshalFileInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (f *FileInstance) upcastToGFile() *FileInstance {
	return f
}

// UnsafeFileFromGlibNone is used to convert raw GFile pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileFromGlibNone(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibNone(c).(File)
}

// UnsafeFileFromGlibFull is used to convert raw GFile pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileFromGlibFull(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibFull(c).(File)
}

// UnsafeFileFromGlibBorrow is used to convert raw GFile pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileFromGlibBorrow(c unsafe.Pointer) File {
	return gobject.UnsafeObjectFromGlibBorrow(c).(File)
}

// UnsafeFileToGlibNone is used to convert the instance to it's C value GFile. This is used by the bindings internally.
func UnsafeFileToGlibNone(c File) unsafe.Pointer {
	i := c.upcastToGFile()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeFileToGlibFull is used to convert the instance to it's C value GFile, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileToGlibFull(c File) unsafe.Pointer {
	i := c.upcastToGFile()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewFileBuildFilenamev wraps g_file_new_build_filenamev
// 
// The function takes the following parameters:
// 
// 	- args []string: %NULL-terminated
//   array of strings containing the path elements. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Constructs a #GFile from a vector of elements using the correct
// separator for filenames.
// 
// Using this function is equivalent to calling g_build_filenamev(),
// followed by g_file_new_for_path() on the result.
func NewFileBuildFilenamev(args []string) File {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.GFile  // return, full, converted

	_ = args
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_file_new_build_filenamev(carg1)
	runtime.KeepAlive(args)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForCommandlineArg wraps g_file_new_for_commandline_arg
// 
// The function takes the following parameters:
// 
// 	- arg string: a command line string 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Creates a #GFile with the given argument from the command line.
// The value of @arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory.
// This operation never fails, but the returned object might not
// support any I/O operation if @arg points to a malformed path.
// 
// Note that on Windows, this function expects its argument to be in
// UTF-8 -- not the system code page.  This means that you
// should not use this function with string from argv as it is passed
// to main().  g_win32_get_command_line() will return a UTF-8 version of
// the commandline.  #GApplication also uses UTF-8 but
// g_application_command_line_create_file_for_arg() may be more useful
// for you there.  It is also always possible to use this function with
// #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
func NewFileForCommandlineArg(arg string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_commandline_arg(carg1)
	runtime.KeepAlive(arg)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForCommandlineArgAndCwd wraps g_file_new_for_commandline_arg_and_cwd
// 
// The function takes the following parameters:
// 
// 	- arg string: a command line string 
// 	- cwd string: the current working directory of the commandline 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Creates a #GFile with the given argument from the command line.
// 
// This function is similar to g_file_new_for_commandline_arg() except
// that it allows for passing the current working directory as an
// argument instead of using the current working directory of the
// process.
// 
// This is useful if the commandline argument was given in a context
// other than the invocation of the current process.
// 
// See also g_application_command_line_create_file_for_arg().
func NewFileForCommandlineArgAndCwd(arg string, cwd string) File {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(cwd)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_file_new_for_commandline_arg_and_cwd(carg1, carg2)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(cwd)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForPath wraps g_file_new_for_path
// 
// The function takes the following parameters:
// 
// 	- path string: a string containing a relative or absolute path.
//   The string must be encoded in the glib filename encoding. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O
// operation if @path is malformed.
func NewFileForPath(path string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_path(carg1)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileForURI wraps g_file_new_for_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: a UTF-8 string containing a URI 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O
// operation if @uri is malformed or if the uri type is
// not supported.
func NewFileForURI(uri string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_new_for_uri(carg1)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewFileTmp wraps g_file_new_tmp
// 
// The function takes the following parameters:
// 
// 	- tmpl string (nullable): Template for the file
//   name, as in g_file_open_tmp(), or %NULL for a default template 
// 
// The function returns the following values:
// 
// 	- iostream FileIOStream: on return, a #GFileIOStream for the created file 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and
// #GFileIOStream pointing to it.
// 
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
// 
// Unlike the other #GFile constructors, this will return %NULL if
// a temporary file could not be created.
func NewFileTmp(tmpl string) (FileIOStream, File, error) {
	var carg1 *C.char          // in, none, string, nullable-string
	var carg2 *C.GFileIOStream // out, full, converted
	var cret  *C.GFile         // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_new_tmp(carg1, &carg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var iostream FileIOStream
	var goret    File
	var _goerr   error

	iostream = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(carg2))
	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return iostream, goret, _goerr
}

// NewFileTmpAsync wraps g_file_new_tmp_async
// 
// The function takes the following parameters:
// 
// 	- tmpl string (nullable): Template for the file
//   name, as in g_file_open_tmp(), or %NULL for a default template 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is done 
//
// Asynchronously opens a file in the preferred directory for temporary files
//  (as returned by g_get_tmp_dir()) as g_file_new_tmp().
// 
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
func NewFileTmpAsync(tmpl string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_new_tmp_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirAsync wraps g_file_new_tmp_dir_async
// 
// The function takes the following parameters:
// 
// 	- tmpl string (nullable): Template for the file
//   name, as in g_dir_make_tmp(), or %NULL for a default template 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is done 
//
// Asynchronously creates a directory in the preferred directory for
// temporary files (as returned by g_get_tmp_dir()) as g_dir_make_tmp().
// 
// @tmpl should be a string in the GLib file name encoding
// containing a sequence of six 'X' characters, and containing no
// directory components. If it is %NULL, a default template is used.
func NewFileTmpDirAsync(tmpl string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	if tmpl != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_new_tmp_dir_async(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NewFileTmpDirFinish wraps g_file_new_tmp_dir_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Finishes a temporary directory creation started by
// g_file_new_tmp_dir_async().
func NewFileTmpDirFinish(result AsyncResult) (File, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_new_tmp_dir_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewFileTmpFinish wraps g_file_new_tmp_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- iostream FileIOStream: on return, a #GFileIOStream for the created file 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Finishes a temporary file creation started by g_file_new_tmp_async().
func NewFileTmpFinish(result AsyncResult) (FileIOStream, File, error) {
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 *C.GFileIOStream // out, full, converted
	var cret  *C.GFile         // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_new_tmp_finish(carg1, &carg2, &_cerr)
	runtime.KeepAlive(result)

	var iostream FileIOStream
	var goret    File
	var _goerr   error

	iostream = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(carg2))
	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return iostream, goret, _goerr
}

// FileParseName wraps g_file_parse_name
// 
// The function takes the following parameters:
// 
// 	- parseName string: a file name or path to be parsed 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Constructs a #GFile with the given @parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails,
// but the returned object might not support any I/O operation if
// the @parse_name cannot be parsed.
func FileParseName(parseName string) File {
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_parse_name(carg1)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AppendTo wraps g_file_append_to
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Gets an output stream for appending data to the file.
// If the file doesn't already exist it is created.
// 
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// Some file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
// %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (file *FileInstance) AppendTo(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 C.GFileCreateFlags   // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_append_to(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AppendToAsync wraps g_file_append_to_async
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously opens @file for appending.
// 
// For more details, see g_file_append_to() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_append_to_finish() to get the result
// of the operation.
func (file *FileInstance) AppendToAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_append_to_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AppendToFinish wraps g_file_append_to_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file append operation started with
// g_file_append_to_async().
func (file *FileInstance) AppendToFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_append_to_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// BuildAttributeListForCopy wraps g_file_build_attribute_list_for_copy
// 
// The function takes the following parameters:
// 
// 	- flags FileCopyFlags: a set of #GFileCopyFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Prepares the file attribute query string for copying to @file.
// 
// This function prepares an attribute query string to be
// passed to g_file_query_info() to get a list of attributes
// normally copied with the file (see g_file_copy_attributes()
// for the detailed description). This function is used by the
// implementation of g_file_copy_attributes() and is useful
// when one needs to query and set the attributes in two
// stages (e.g., for recursive move of a directory).
func (file *FileInstance) BuildAttributeListForCopy(flags FileCopyFlags, cancellable Cancellable) (string, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 C.GFileCopyFlags // in, none, casted
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.char          // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCopyFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_build_attribute_list_for_copy(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopyAttributes wraps g_file_copy_attributes
// 
// The function takes the following parameters:
// 
// 	- destination File: a #GFile to copy attributes to 
// 	- flags FileCopyFlags: a set of #GFileCopyFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Copies the file attributes from @source to @destination.
// 
// Normally only a subset of the file attributes are copied,
// those that are copies in a normal file copy operation
// (which for instance does not include e.g. owner). However
// if %G_FILE_COPY_ALL_METADATA is specified in @flags, then
// all the metadata that is possible to copy is copied. This
// is useful when implementing move by copy + delete source.
func (source *FileInstance) CopyAttributes(destination File, flags FileCopyFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GFile         // in, none, converted
	var carg2 C.GFileCopyFlags // in, none, casted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(source))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(destination))
	carg2 = C.GFileCopyFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_copy_attributes(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(source)
	runtime.KeepAlive(destination)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopyFinish wraps g_file_copy_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes copying the file started with g_file_copy_async().
func (file *FileInstance) CopyFinish(res AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_copy_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Create wraps g_file_create
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Creates a new file and returns an output stream for writing to it.
// The file must not already exist.
// 
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If a file or directory with this name already exists the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
// be returned. Other errors are possible too, and depend on what kind
// of filesystem the file is on.
func (file *FileInstance) Create(flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 C.GFileCreateFlags   // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_create(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateAsync wraps g_file_create_async
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously creates a new file and returns an output stream
// for writing to it. The file must not already exist.
// 
// For more details, see g_file_create() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_create_finish() to get the result
// of the operation.
func (file *FileInstance) CreateAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_create_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CreateFinish wraps g_file_create_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file create operation started with
// g_file_create_async().
func (file *FileInstance) CreateFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_create_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateReadwrite wraps g_file_create_readwrite
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
// 
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level
// that is supported on the target filesystem.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If a file or directory with this name already exists, the
// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
// error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
// will be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
// 
// Note that in many non-local file cases read and write streams are
// not supported, so make sure you really need to do read and write
// streaming, rather than just opening for reading or writing.
func (file *FileInstance) CreateReadwrite(flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 C.GFileCreateFlags // in, none, casted
	var carg2 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileIOStream   // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_create_readwrite(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CreateReadwriteAsync wraps g_file_create_readwrite_async
// 
// The function takes the following parameters:
// 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
// 
// For more details, see g_file_create_readwrite() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_create_readwrite_finish() to get
// the result of the operation.
func (file *FileInstance) CreateReadwriteAsync(flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileCreateFlags    // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileCreateFlags(flags)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_create_readwrite_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CreateReadwriteFinish wraps g_file_create_readwrite_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file create operation started with
// g_file_create_readwrite_async().
func (file *FileInstance) CreateReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_create_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Delete wraps g_file_delete
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Deletes a file. If the @file is a directory, it will only be
// deleted if it is empty. This has the same semantics as g_unlink().
// 
// If @file doesn&#x2019;t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
// for deletion to be implemented avoiding
// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
// |[
// g_autoptr(GError) local_error = NULL;
// if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
//     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//   {
//     // deletion failed for some reason other than the file not existing:
//     // so report the error
//     g_warning ("Failed to delete %s: %s",
//                g_file_peek_path (my_file), local_error-&gt;message);
//   }
// ]|
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) Delete(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_delete(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DeleteAsync wraps g_file_delete_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied 
//
// Asynchronously delete a file. If the @file is a directory, it will
// only be deleted if it is empty.  This has the same semantics as
// g_unlink().
func (file *FileInstance) DeleteAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_delete_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// DeleteFinish wraps g_file_delete_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes deleting a file started with g_file_delete_async().
func (file *FileInstance) DeleteFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_delete_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Dup wraps g_file_dup
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Duplicates a #GFile handle. This operation does not duplicate
// the actual file or directory represented by the #GFile; see
// g_file_copy() if attempting to copy a file.
// 
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing object&#x2019;s
// reference count.
// 
// This call does no blocking I/O.
func (file *FileInstance) Dup() File {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_dup(carg0)
	runtime.KeepAlive(file)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// EjectMountable wraps g_file_eject_mountable
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_finish().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
//
// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation() instead.
func (file *FileInstance) EjectMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_eject_mountable(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectMountableFinish wraps g_file_eject_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous eject operation started by
// g_file_eject_mountable().
//
// Deprecated: (since 2.22.0) Use g_file_eject_mountable_with_operation_finish()
//   instead.
func (file *FileInstance) EjectMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_eject_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectMountableWithOperation wraps g_file_eject_mountable_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation,
//   or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Starts an asynchronous eject on a mountable.
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) EjectMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_eject_mountable_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectMountableWithOperationFinish wraps g_file_eject_mountable_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous eject operation started by
// g_file_eject_mountable_with_operation().
func (file *FileInstance) EjectMountableWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_eject_mountable_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateChildren wraps g_file_enumerate_children
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileEnumerator 
// 	- _goerr error (nullable): an error 
//
// Gets the requested information about the files in a directory.
// The result is a #GFileEnumerator object that will give out
// #GFileInfo objects for all the files in the directory.
// 
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// it's not possible to read a particular requested attribute
// from a file - it just won't be set. @attributes should
// be a comma-separated list of attributes or attribute wildcards.
// The wildcard "*" means all attributes, and a wildcard like
// "standard::*" means all attributes in the standard namespace.
// An example attribute query be "standard::*,owner::user".
// The standard attributes are available as defines, like
// %G_FILE_ATTRIBUTE_STANDARD_NAME. %G_FILE_ATTRIBUTE_STANDARD_NAME should
// always be specified if you plan to call g_file_enumerator_get_child() or
// g_file_enumerator_iterate() on the returned enumerator.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is not a directory, the %G_IO_ERROR_NOT_DIRECTORY
// error will be returned. Other errors are possible too.
func (file *FileInstance) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileEnumerator, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GFileEnumerator    // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerate_children(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileEnumerator
	var _goerr error

	goret = UnsafeFileEnumeratorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateChildrenAsync wraps g_file_enumerate_children_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously gets the requested information about the files
// in a directory. The result is a #GFileEnumerator object that will
// give out #GFileInfo objects for all the files in the directory.
// 
// For more details, see g_file_enumerate_children() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called. You can
// then call g_file_enumerate_children_finish() to get the result of
// the operation.
func (file *FileInstance) EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerate_children_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EnumerateChildrenFinish wraps g_file_enumerate_children_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileEnumerator 
// 	- _goerr error (nullable): an error 
//
// Finishes an async enumerate children operation.
// See g_file_enumerate_children_async().
func (file *FileInstance) EnumerateChildrenFinish(res AsyncResult) (FileEnumerator, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GFileEnumerator // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_enumerate_children_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileEnumerator
	var _goerr error

	goret = UnsafeFileEnumeratorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_file_equal
// 
// The function takes the following parameters:
// 
// 	- file2 File: the second #GFile 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the two given #GFiles refer to the same file.
// 
// Note that two #GFiles that differ can still refer to the same
// file on the filesystem due to various forms of filename
// aliasing.
// 
// This call does no blocking I/O.
func (file1 *FileInstance) Equal(file2 File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file1))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file2))

	cret = C.g_file_equal(carg0, carg1)
	runtime.KeepAlive(file1)
	runtime.KeepAlive(file2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// FindEnclosingMount wraps g_file_find_enclosing_mount
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret Mount 
// 	- _goerr error (nullable): an error 
//
// Gets a #GMount for the #GFile.
// 
// #GMount is returned only for user interesting locations, see
// #GVolumeMonitor. If the #GFileIface for @file does not have a #mount,
// @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL #will be returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) FindEnclosingMount(cancellable Cancellable) (Mount, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GMount       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_find_enclosing_mount(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  Mount
	var _goerr error

	goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FindEnclosingMountAsync wraps g_file_find_enclosing_mount_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously gets the mount for the file.
// 
// For more details, see g_file_find_enclosing_mount() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_find_enclosing_mount_finish() to
// get the result of the operation.
func (file *FileInstance) FindEnclosingMountAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_find_enclosing_mount_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FindEnclosingMountFinish wraps g_file_find_enclosing_mount_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret Mount 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous find mount request.
// See g_file_find_enclosing_mount_async().
func (file *FileInstance) FindEnclosingMountFinish(res AsyncResult) (Mount, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GMount       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_find_enclosing_mount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  Mount
	var _goerr error

	goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBasename wraps g_file_get_basename
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the base name (the last component of the path) for a given #GFile.
// 
// If called for the top level of a system (such as the filesystem root
// or a uri like sftp://host/) it will return a single directory separator
// (and on Windows, possibly a drive letter).
// 
// The base name is a byte string (not UTF-8). It has no defined encoding
// or rules other than it may not contain zero bytes.  If you want to use
// filenames in a user interface you should use the display name that you
// can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
// attribute with g_file_query_info().
// 
// This call does no blocking I/O.
func (file *FileInstance) GetBasename() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_basename(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetChild wraps g_file_get_child
// 
// The function takes the following parameters:
// 
// 	- name string: string containing the child's basename 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets a child of @file with basename equal to @name.
// 
// Note that the file with that specific name might not exist, but
// you can still have a #GFile that points to it. You can use this
// for instance to create that file.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetChild(name string) File {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_child(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(name)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetChildForDisplayName wraps g_file_get_child_for_display_name
// 
// The function takes the following parameters:
// 
// 	- displayName string: string to a possible child 
// 
// The function returns the following values:
// 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Gets the child of @file for a given @display_name (i.e. a UTF-8
// version of the name). If this function fails, it returns %NULL
// and @error will be set. This is very useful when constructing a
// #GFile for a new file and the user entered the filename in the
// user interface, for instance when you select a directory and
// type a filename in the file selector.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetChildForDisplayName(displayName string) (File, error) {
	var carg0 *C.GFile  // in, none, converted
	var carg1 *C.char   // in, none, string
	var cret  *C.GFile  // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_child_for_display_name(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetParent wraps g_file_get_parent
// 
// The function returns the following values:
// 
// 	- goret File (nullable) 
//
// Gets the parent directory for the @file.
// If the @file represents the root directory of the
// file system, then %NULL will be returned.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetParent() File {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.GFile // return, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_parent(carg0)
	runtime.KeepAlive(file)

	var goret File

	if cret != nil {
		goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetParseName wraps g_file_get_parse_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the parse name of the @file.
// A parse name is a UTF-8 string that describes the
// file such that one can get the #GFile back using
// g_file_parse_name().
// 
// This is generally used to show the #GFile as a nice
// full-pathname kind of string in a user interface,
// like in a location entry.
// 
// For local files with names that can safely be converted
// to UTF-8 the pathname is used, otherwise the IRI is used
// (a form of URI that allows UTF-8 characters unescaped).
// 
// This call does no blocking I/O.
func (file *FileInstance) GetParseName() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_parse_name(carg0)
	runtime.KeepAlive(file)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetPath wraps g_file_get_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetPath() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_path(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetRelativePath wraps g_file_get_relative_path
// 
// The function takes the following parameters:
// 
// 	- descendant File: input #GFile 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the path for @descendant relative to @parent.
// 
// This call does no blocking I/O.
func (parent *FileInstance) GetRelativePath(descendant File) string {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(parent))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(descendant))

	cret = C.g_file_get_relative_path(carg0, carg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(descendant)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetURI wraps g_file_get_uri
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the URI for the @file.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetURI() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_uri(carg0)
	runtime.KeepAlive(file)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetURIScheme wraps g_file_get_uri_scheme
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the URI scheme for a #GFile.
// RFC 3986 decodes the scheme as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include "file", "http", "ftp", etc.
// 
// The scheme can be different from the one used to construct the #GFile,
// in that it might be replaced with one that is logically equivalent to the #GFile.
// 
// This call does no blocking I/O.
func (file *FileInstance) GetURIScheme() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, full, string, nullable-string

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_get_uri_scheme(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// HasParent wraps g_file_has_parent
// 
// The function takes the following parameters:
// 
// 	- parent File (nullable): the parent to check for, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @file has a parent, and optionally, if it is @parent.
// 
// If @parent is %NULL then this function returns %TRUE if @file has any
// parent at all.  If @parent is non-%NULL then %TRUE is only returned
// if @file is an immediate child of @parent.
func (file *FileInstance) HasParent(parent File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted, nullable
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if parent != nil {
		carg1 = (*C.GFile)(UnsafeFileToGlibNone(parent))
	}

	cret = C.g_file_has_parent(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(parent)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasPrefix wraps g_file_has_prefix
// 
// The function takes the following parameters:
// 
// 	- prefix File: input #GFile 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks whether @file has the prefix specified by @prefix.
// 
// In other words, if the names of initial elements of @file's
// pathname match @prefix. Only full pathname elements are matched,
// so a path like /foo is not considered a prefix of /foobar, only
// of /foo/bar.
// 
// A #GFile is not a prefix of itself. If you want to check for
// equality, use g_file_equal().
// 
// This call does no I/O, as it works purely on names. As such it can
// sometimes return %FALSE even if @file is inside a @prefix (from a
// filesystem point of view), because the prefix of @file is an alias
// of @prefix.
func (file *FileInstance) HasPrefix(prefix File) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(prefix))

	cret = C.g_file_has_prefix(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(prefix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasURIScheme wraps g_file_has_uri_scheme
// 
// The function takes the following parameters:
// 
// 	- uriScheme string: a string containing a URI scheme 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks to see if a #GFile has a given URI scheme.
// 
// This call does no blocking I/O.
func (file *FileInstance) HasURIScheme(uriScheme string) bool {
	var carg0 *C.GFile   // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_has_uri_scheme(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(uriScheme)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsNative wraps g_file_is_native
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks to see if a file is native to the platform.
// 
// A native file is one expressed in the platform-native filename format,
// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
// as it might be on a locally mounted remote filesystem.
// 
// On some systems non-native files may be available using the native
// filesystem via a userspace filesystem (FUSE), in these cases this call
// will return %FALSE, but g_file_get_path() will still return a native path.
// 
// This call does no blocking I/O.
func (file *FileInstance) IsNative() bool {
	var carg0 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_is_native(carg0)
	runtime.KeepAlive(file)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadBytes wraps g_file_load_bytes
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- etagOut string (nullable): a location to place the current
//   entity tag for the file, or %NULL if the entity tag is not needed 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Loads the contents of @file and returns it as #GBytes.
// 
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
// 
// For resources, @etag_out will be set to %NULL.
// 
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
func (file *FileInstance) LoadBytes(cancellable Cancellable) (string, *glib.Bytes, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_load_bytes(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var etagOut string
	var goret   *glib.Bytes
	var _goerr  error

	if carg2 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return etagOut, goret, _goerr
}

// LoadBytesAsync wraps g_file_load_bytes_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously loads the contents of @file as #GBytes.
// 
// If @file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
// 
// @callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
// 
// See g_file_load_bytes() for more information.
func (file *FileInstance) LoadBytesAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_load_bytes_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadBytesFinish wraps g_file_load_bytes_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult provided to the callback 
// 
// The function returns the following values:
// 
// 	- etagOut string (nullable): a location to place the current
//   entity tag for the file, or %NULL if the entity tag is not needed 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Completes an asynchronous request to g_file_load_bytes_async().
// 
// For resources, @etag_out will be set to %NULL.
// 
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
// 
// See g_file_load_bytes() for more information.
func (file *FileInstance) LoadBytesFinish(result AsyncResult) (string, *glib.Bytes, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.gchar        // out, full, string, nullable-string
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_load_bytes_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var etagOut string
	var goret   *glib.Bytes
	var _goerr  error

	if carg2 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return etagOut, goret, _goerr
}

// LoadContents wraps g_file_load_contents
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- contents string: a location to place the contents of the file 
// 	- length uint: a location to place the length of the contents of the file,
//   or %NULL if the length is not needed 
// 	- etagOut string (nullable): a location to place the current entity tag for the file,
//   or %NULL if the entity tag is not needed 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads the content of the file into memory. The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) LoadContents(cancellable Cancellable) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_load_contents(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// LoadContentsAsync wraps g_file_load_contents_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
//
// Starts an asynchronous load of the @file's contents.
// 
// For more details, see g_file_load_contents() which is
// the synchronous version of this call.
// 
// When the load operation has completed, @callback will be called
// with @user data. To finish the operation, call
// g_file_load_contents_finish() with the #GAsyncResult returned by
// the @callback.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) LoadContentsAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_load_contents_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadContentsFinish wraps g_file_load_contents_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- contents string: a location to place the contents of the file 
// 	- length uint: a location to place the length of the contents of the file,
//   or %NULL if the length is not needed 
// 	- etagOut string (nullable): a location to place the current entity tag for the file,
//   or %NULL if the entity tag is not needed 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous load of the @file's contents.
// The contents are placed in @contents, and @length is set to the
// size of the @contents string. The @contents should be freed with
// g_free() when no longer needed. If @etag_out is present, it will be
// set to the new entity tag for the @file.
func (file *FileInstance) LoadContentsFinish(res AsyncResult) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_load_contents_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// LoadPartialContentsFinish wraps g_file_load_partial_contents_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- contents string: a location to place the contents of the file 
// 	- length uint: a location to place the length of the contents of the file,
//   or %NULL if the length is not needed 
// 	- etagOut string (nullable): a location to place the current entity tag for the file,
//   or %NULL if the entity tag is not needed 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous partial load operation that was started
// with g_file_load_partial_contents_async(). The data is always
// zero-terminated, but this is not included in the resultant @length.
// The returned @contents should be freed with g_free() when no longer
// needed.
func (file *FileInstance) LoadPartialContentsFinish(res AsyncResult) (string, string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_load_partial_contents_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var contents string
	var etagOut  string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if carg4 != nil {
		etagOut = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, etagOut, goret, _goerr
}

// MakeDirectory wraps g_file_make_directory
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Creates a directory.
// 
// Note that this will only create a child directory
// of the immediate parent directory of the path or URI given by the #GFile.
// To recursively create directories, see g_file_make_directory_with_parents().
// 
// This function will fail if the parent directory does not exist, setting
// @error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED. If the directory already exists,
// [error@Gio.IOErrorEnum.EXISTS] will be returned.
// 
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) MakeDirectory(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_directory(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeDirectoryAsync wraps g_file_make_directory_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied 
//
// Asynchronously creates a directory.
func (file *FileInstance) MakeDirectoryAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_make_directory_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MakeDirectoryFinish wraps g_file_make_directory_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
func (file *FileInstance) MakeDirectoryFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_make_directory_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeDirectoryWithParents wraps g_file_make_directory_with_parents
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Creates a directory and any parent directories that may not
// exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting @error to
// %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
// this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
// the similar g_mkdir_with_parents().
// 
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) MakeDirectoryWithParents(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_directory_with_parents(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeSymbolicLink wraps g_file_make_symbolic_link
// 
// The function takes the following parameters:
// 
// 	- symlinkValue string: a string with the path for the target
//   of the new symlink 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Creates a symbolic link named @file which contains the string
// @symlink_value.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) MakeSymbolicLink(symlinkValue string, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_make_symbolic_link(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MakeSymbolicLinkAsync wraps g_file_make_symbolic_link_async
// 
// The function takes the following parameters:
// 
// 	- symlinkValue string: a string with the path for the target
//   of the new symlink 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied 
//
// Asynchronously creates a symbolic link named @file which contains the
// string @symlink_value.
func (file *FileInstance) MakeSymbolicLinkAsync(symlinkValue string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_make_symbolic_link_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(symlinkValue)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MakeSymbolicLinkFinish wraps g_file_make_symbolic_link_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous symbolic link creation, started with
// g_file_make_symbolic_link_async().
func (file *FileInstance) MakeSymbolicLinkFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_make_symbolic_link_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MeasureDiskUsageFinish wraps g_file_measure_disk_usage_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- diskUsage uint64: the number of bytes of disk space used 
// 	- numDirs uint64: the number of directories encountered 
// 	- numFiles uint64: the number of non-directories encountered 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Collects the results from an earlier call to
// g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
// more information.
func (file *FileInstance) MeasureDiskUsageFinish(result AsyncResult) (uint64, uint64, uint64, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.guint64       // out, full, casted
	var carg3 C.guint64       // out, full, casted
	var carg4 C.guint64       // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_measure_disk_usage_finish(carg0, carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var diskUsage uint64
	var numDirs   uint64
	var numFiles  uint64
	var goret     bool
	var _goerr    error

	diskUsage = uint64(carg2)
	numDirs = uint64(carg3)
	numFiles = uint64(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return diskUsage, numDirs, numFiles, goret, _goerr
}

// Monitor wraps g_file_monitor
// 
// The function takes the following parameters:
// 
// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileMonitor 
// 	- _goerr error (nullable): an error 
//
// Obtains a file or directory monitor for the given file,
// depending on the type of the file.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) Monitor(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MonitorDirectory wraps g_file_monitor_directory
// 
// The function takes the following parameters:
// 
// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileMonitor 
// 	- _goerr error (nullable): an error 
//
// Obtains a directory monitor for the given file.
// This may fail if directory monitoring is not supported.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// It does not make sense for @flags to contain
// %G_FILE_MONITOR_WATCH_HARD_LINKS, since hard links can not be made to
// directories.  It is not possible to monitor all the files in a
// directory for changes made via hard links; if you want to do this then
// you must register individual watches with g_file_monitor().
func (file *FileInstance) MonitorDirectory(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor_directory(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MonitorFile wraps g_file_monitor_file
// 
// The function takes the following parameters:
// 
// 	- flags FileMonitorFlags: a set of #GFileMonitorFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileMonitor 
// 	- _goerr error (nullable): an error 
//
// Obtains a file monitor for the given file. If no file notification
// mechanism exists, then regular polling of the file is used.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// If @flags contains %G_FILE_MONITOR_WATCH_HARD_LINKS then the monitor
// will also attempt to report changes made to the file via another
// filename (ie, a hard link). Without this flag, you can only rely on
// changes made through the filename contained in @file to be
// reported. Using this flag may result in an increase in resource
// usage, and may not have any effect depending on the #GFileMonitor
// backend and/or filesystem type.
func (file *FileInstance) MonitorFile(flags FileMonitorFlags, cancellable Cancellable) (FileMonitor, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 C.GFileMonitorFlags // in, none, casted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileMonitor     // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileMonitorFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_monitor_file(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileMonitor
	var _goerr error

	goret = UnsafeFileMonitorFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MountEnclosingVolume wraps g_file_mount_enclosing_volume
// 
// The function takes the following parameters:
// 
// 	- flags MountMountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation
//   or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied, or %NULL 
//
// Starts a @mount_operation, mounting the volume that contains
// the file @location.
// 
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_mount_enclosing_volume_finish().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (location *FileInstance) MountEnclosingVolume(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(location))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_mount_enclosing_volume(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(location)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountEnclosingVolumeFinish wraps g_file_mount_enclosing_volume_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a mount operation started by g_file_mount_enclosing_volume().
func (location *FileInstance) MountEnclosingVolumeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(location))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_mount_enclosing_volume_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(location)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MountMountable wraps g_file_mount_mountable
// 
// The function takes the following parameters:
// 
// 	- flags MountMountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation,
//   or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Mounts a file of type G_FILE_TYPE_MOUNTABLE.
// Using @mount_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (file *FileInstance) MountMountable(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_mount_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountMountableFinish wraps g_file_mount_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Finishes a mount operation. See g_file_mount_mountable() for details.
// 
// Finish an asynchronous mount operation that was started
// with g_file_mount_mountable().
func (file *FileInstance) MountMountableFinish(result AsyncResult) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_mount_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MoveFinish wraps g_file_move_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file movement, started with
// g_file_move_async().
func (file *FileInstance) MoveFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_move_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// OpenReadwrite wraps g_file_open_readwrite
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Opens an existing file for reading and writing. The result is
// a #GFileIOStream that can be used to read and write the contents
// of the file.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend on
// what kind of filesystem the file is on. Note that in many non-local
// file cases read and write streams are not supported, so make sure you
// really need to do read and write streaming, rather than just opening
// for reading or writing.
func (file *FileInstance) OpenReadwrite(cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_open_readwrite(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// OpenReadwriteAsync wraps g_file_open_readwrite_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously opens @file for reading and writing.
// 
// For more details, see g_file_open_readwrite() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_open_readwrite_finish() to get
// the result of the operation.
func (file *FileInstance) OpenReadwriteAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_open_readwrite_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// OpenReadwriteFinish wraps g_file_open_readwrite_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
func (file *FileInstance) OpenReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_open_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PeekPath wraps g_file_peek_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full().  This is useful for example in C
// applications which mix `g_file_*` APIs with native ones.  It
// also avoids an extra duplicated string when possible, so will be
// generally more efficient.
// 
// This call does no blocking I/O.
func (file *FileInstance) PeekPath() string {
	var carg0 *C.GFile // in, none, converted
	var cret  *C.char  // return, none, string, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_peek_path(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PollMountable wraps g_file_poll_mountable
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied, or %NULL 
//
// Polls a file of type %G_FILE_TYPE_MOUNTABLE.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (file *FileInstance) PollMountable(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_poll_mountable(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// PollMountableFinish wraps g_file_poll_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a poll operation. See g_file_poll_mountable() for details.
// 
// Finish an asynchronous poll operation that was polled
// with g_file_poll_mountable().
func (file *FileInstance) PollMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_poll_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryDefaultHandler wraps g_file_query_default_handler
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
// 	- _goerr error (nullable): an error 
//
// Returns the #GAppInfo that is registered as the default
// application to handle the file specified by @file.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) QueryDefaultHandler(cancellable Cancellable) (AppInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_default_handler(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryDefaultHandlerAsync wraps g_file_query_default_handler_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is done 
//
// Async version of g_file_query_default_handler().
func (file *FileInstance) QueryDefaultHandlerAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_default_handler_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryDefaultHandlerFinish wraps g_file_query_default_handler_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret AppInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes a g_file_query_default_handler_async() operation.
func (file *FileInstance) QueryDefaultHandlerFinish(result AsyncResult) (AppInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GAppInfo     // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_query_default_handler_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  AppInfo
	var _goerr error

	goret = UnsafeAppInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryExists wraps g_file_query_exists
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Utility function to check if a particular file exists.
// 
// The fallback implementation of this API is using [method@Gio.File.query_info]
// and therefore may do blocking I/O. To asynchronously query the existence
// of a file, use [method@Gio.File.query_info_async].
// 
// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
// and then execute something based on the outcome of that, because the
// file might have been created or removed in between the operations. The
// general approach to handling that is to not check, but just do the
// operation and handle the errors as they come.
// 
// As an example of race-free checking, take the case of reading a file,
// and if it doesn't exist, creating it. There are two racy versions: read
// it, and on error create it; and: check if it exists, if not create it.
// These can both result in two processes creating the file (with perhaps
// a partially written file as the result). The correct approach is to
// always try to create the file with g_file_create() which will either
// atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
// 
// However, in many cases an existence check is useful in a user interface,
// for instance to make a menu item sensitive/insensitive, so that you don't
// have to fool users that something is possible and then just show an error
// dialog. If you do this, you should make sure to also handle the errors
// that can happen due to races when you execute the operation.
func (file *FileInstance) QueryExists(cancellable Cancellable) bool {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_exists(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// QueryFileType wraps g_file_query_file_type
// 
// The function takes the following parameters:
// 
// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags passed to g_file_query_info() 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileType 
//
// Utility function to inspect the #GFileType of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
// 
// The primary use case of this method is to check if a file is
// a regular file, directory, or symlink.
func (file *FileInstance) QueryFileType(flags FileQueryInfoFlags, cancellable Cancellable) FileType {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GFileQueryInfoFlags // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  C.GFileType           // return, none, casted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_file_type(carg0, carg1, carg2)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret FileType

	goret = FileType(cret)

	return goret
}

// QueryFilesystemInfo wraps g_file_query_filesystem_info
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Similar to g_file_query_info(), but obtains information
// about the filesystem the @file is on, rather than the file itself.
// For instance the amount of space available and the type of
// the filesystem.
// 
// The @attributes value is a string that specifies the attributes
// that should be gathered. It is not an error if it's not possible
// to read a particular requested attribute from a file - it just
// won't be set. @attributes should be a comma-separated list of
// attributes or attribute wildcards. The wildcard "*" means all
// attributes, and a wildcard like "filesystem::*" means all attributes
// in the filesystem namespace. The standard namespace for filesystem
// attributes is "filesystem". Common attributes of interest are
// %G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
// in bytes), %G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
// and %G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
// be returned. Other errors are possible too, and depend on what
// kind of filesystem the file is on.
func (file *FileInstance) QueryFilesystemInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_filesystem_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryFilesystemInfoAsync wraps g_file_query_filesystem_info_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously gets the requested information about the filesystem
// that the specified @file is on. The result is a #GFileInfo object
// that contains key-value attributes (such as type or size for the
// file).
// 
// For more details, see g_file_query_filesystem_info() which is the
// synchronous version of this call.
// 
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the
// operation.
func (file *FileInstance) QueryFilesystemInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_filesystem_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryFilesystemInfoFinish wraps g_file_query_filesystem_info_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous filesystem info query.
// See g_file_query_filesystem_info_async().
func (file *FileInstance) QueryFilesystemInfoFinish(res AsyncResult) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_query_filesystem_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfo wraps g_file_query_info
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- flags FileQueryInfoFlags: flags to affect the query operation 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Gets the requested information about specified @file.
// 
// The result is a [class@Gio.FileInfo] object that contains key-value
// attributes (such as the type or size of the file).
// 
// The @attributes value is a string that specifies the file
// attributes that should be gathered. It is not an error if
// it&#x2019;s not possible to read a particular requested attribute
// from a file &#x2014; it just won't be set. In particular this means that if a file
// is inaccessible (due to being in a folder with restrictive permissions), for
// example, you can expect the returned [class@Gio.FileInfo] to have very few
// attributes set. You should check whether an attribute is set using
// [method@Gio.FileInfo.has_attribute] before trying to retrieve its value.
// 
// It is guaranteed that if any of the following attributes are listed in
// @attributes, they will always be set in the returned [class@Gio.FileInfo],
// even if the user doesn&#x2019;t have permissions to access the file:
// 
//  - [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME]
//  - [const@Gio.FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME]
// 
// @attributes should be a comma-separated list of attributes or attribute
// wildcards. The wildcard `"*"` means all attributes, and a wildcard like
// `"standard::*"` means all attributes in the standard namespace.
// An example attribute query might be `"standard::*,owner::user"`.
// The standard attributes are available as defines, like
// [const@Gio.FILE_ATTRIBUTE_STANDARD_NAME].
// 
// If @cancellable is not `NULL`, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be
// returned.
// 
// For symlinks, normally the information about the target of the
// symlink is returned, rather than information about the symlink
// itself. However if you pass [flags@Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS]
// in @flags the information about the symlink itself will be returned.
// Also, for symlinks that point to non-existing files the information
// about the symlink itself will be returned.
// 
// If the file does not exist, the [error@Gio.IOErrorEnum.NOT_FOUND] error will be
// returned. Other errors are possible too, and depend on what kind of
// file system the file is on.
func (file *FileInstance) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GFileInfo          // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_info(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_query_info_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute query string 
// 	- flags FileQueryInfoFlags: a set of #GFileQueryInfoFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously gets the requested information about specified @file.
// The result is a #GFileInfo object that contains key-value attributes
// (such as type or size for the file).
// 
// For more details, see g_file_query_info() which is the synchronous
// version of this call.
// 
// When the operation is finished, @callback will be called. You can
// then call g_file_query_info_finish() to get the result of the operation.
func (file *FileInstance) QueryInfoAsync(attributes string, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_query_info_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file info query.
// See g_file_query_info_async().
func (file *FileInstance) QueryInfoFinish(res AsyncResult) (FileInfo, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QuerySettableAttributes wraps g_file_query_settable_attributes
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeInfoList 
// 	- _goerr error (nullable): an error 
//
// Obtain the list of settable attributes for the file.
// 
// Returns the type and full attribute name of all the attributes
// that can be set on this file. This doesn't mean setting it will
// always succeed though, you might get an access failure, or some
// specific file may not support a specific attribute.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) QuerySettableAttributes(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var carg0 *C.GFile                  // in, none, converted
	var carg1 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GFileAttributeInfoList // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_settable_attributes(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  *FileAttributeInfoList
	var _goerr error

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryWritableNamespaces wraps g_file_query_writable_namespaces
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeInfoList 
// 	- _goerr error (nullable): an error 
//
// Obtain the list of attribute namespaces where new attributes
// can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) QueryWritableNamespaces(cancellable Cancellable) (*FileAttributeInfoList, error) {
	var carg0 *C.GFile                  // in, none, converted
	var carg1 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GFileAttributeInfoList // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_query_writable_namespaces(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  *FileAttributeInfoList
	var _goerr error

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Read wraps g_file_read
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 
// The function returns the following values:
// 
// 	- goret FileInputStream 
// 	- _goerr error (nullable): an error 
//
// Opens a file for reading. The result is a #GFileInputStream that
// can be used to read the contents of the file.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
// returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
// error will be returned. Other errors are possible too, and depend
// on what kind of filesystem the file is on.
func (file *FileInstance) Read(cancellable Cancellable) (FileInputStream, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileInputStream // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_read(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  FileInputStream
	var _goerr error

	goret = UnsafeFileInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadAsync wraps g_file_read_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously opens @file for reading.
// 
// For more details, see g_file_read() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_read_finish() to get the result
// of the operation.
func (file *FileInstance) ReadAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_read_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadFinish wraps g_file_read_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileInputStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file read operation started with
// g_file_read_async().
func (file *FileInstance) ReadFinish(res AsyncResult) (FileInputStream, error) {
	var carg0 *C.GFile            // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var cret  *C.GFileInputStream // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_read_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileInputStream
	var _goerr error

	goret = UnsafeFileInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Replace wraps g_file_replace
// 
// The function takes the following parameters:
// 
// 	- etag string (nullable): an optional [entity tag](#entity-tags)
//   for the current #GFile, or #NULL to ignore 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Returns an output stream for overwriting the file, possibly
// creating a backup copy of the file first. If the file doesn't exist,
// it will be created.
// 
// This will try to replace the file in the safest way possible so
// that any errors during the writing will not affect an already
// existing copy of the file. For instance, for local files it
// may write to a temporary file and then atomically rename over
// the destination when the stream is closed.
// 
// By default files created are generally readable by everyone,
// but if you pass %G_FILE_CREATE_PRIVATE in @flags the file
// will be made readable only to the current user, to the level that
// is supported on the target filesystem.
// 
// If @cancellable is not %NULL, then the operation can be cancelled
// by triggering the cancellable object from another thread. If the
// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
// returned.
// 
// If you pass in a non-%NULL @etag value and @file already exists, then
// this value is compared to the current entity tag of the file, and if
// they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
// generally means that the file has been changed since you last read
// it. You can get the new etag from g_file_output_stream_get_etag()
// after you've finished writing and closed the #GFileOutputStream. When
// you load a new file you can use g_file_input_stream_query_info() to
// get the etag of the file.
// 
// If @make_backup is %TRUE, this function will attempt to make a
// backup of the current file before overwriting it. If this fails
// a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
// want to replace anyway, try again with @make_backup set to %FALSE.
// 
// If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
// be returned, and if the file is some other form of non-regular file
// then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
// file systems don't allow all file names, and may return an
// %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
// %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
// possible too, and depend on what kind of filesystem the file is on.
func (file *FileInstance) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.char              // in, none, string, nullable-string
	var carg2 C.gboolean           // in
	var carg3 C.GFileCreateFlags   // in, none, casted
	var carg4 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceAsync wraps g_file_replace_async
// 
// The function takes the following parameters:
// 
// 	- etag string (nullable): an [entity tag](#entity-tags) for the current #GFile,
//   or %NULL to ignore 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously overwrites the file, replacing the contents,
// possibly creating a backup copy of the file first.
// 
// For more details, see g_file_replace() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_finish() to get the result
// of the operation.
func (file *FileInstance) ReplaceAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.gboolean            // in
	var carg3 C.GFileCreateFlags    // in, none, casted
	var carg4 C.int                 // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	carg4 = C.int(ioPriority)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContents wraps g_file_replace_contents
// 
// The function takes the following parameters:
// 
// 	- contents string: a string containing the new contents for @file 
// 	- etag string (nullable): the old [entity-tag](#entity-tags) for the document,
//   or %NULL 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- newEtag string (nullable): a location to a new [entity tag](#entity-tags)
//   for the document. This should be freed with g_free() when no longer
//   needed, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Replaces the contents of @file with @contents of @length bytes.
// 
// If @etag is specified (not %NULL), any existing file must have that etag,
// or the error %G_IO_ERROR_WRONG_ETAG will be returned.
// 
// If @make_backup is %TRUE, this function will attempt to make a backup
// of @file. Internally, it uses g_file_replace(), so will try to replace the
// file contents in the safest way possible. For example, atomic renames are
// used when replacing local files&#x2019; contents.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// The returned @new_etag can be used to verify that the file hasn't
// changed the next time it is saved over.
func (file *FileInstance) ReplaceContents(contents string, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (string, bool, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.char            // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 *C.char            // in, none, string, nullable-string
	var carg4 C.gboolean         // in
	var carg5 C.GFileCreateFlags // in, none, casted
	var carg7 *C.GCancellable    // in, none, converted, nullable
	var carg6 *C.char            // out, full, string, nullable-string
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	_ = contents
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const char*) because of unimplemented: non-fixed size array")
	if etag != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if makeBackup {
		carg4 = C.TRUE
	}
	carg5 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg7 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace_contents(carg0, carg1, carg2, carg3, carg4, carg5, &carg6, carg7, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var newEtag string
	var goret   bool
	var _goerr  error

	if carg6 != nil {
		newEtag = C.GoString((*C.char)(unsafe.Pointer(carg6)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return newEtag, goret, _goerr
}

// ReplaceContentsAsync wraps g_file_replace_contents_async
// 
// The function takes the following parameters:
// 
// 	- contents string: string of contents to replace the file with 
// 	- etag string (nullable): a new [entity tag](#entity-tags) for the @file, or %NULL 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
//
// Starts an asynchronous replacement of @file with the given
// @contents of @length bytes. @etag will replace the document's
// current entity tag.
// 
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// If @make_backup is %TRUE, this function will attempt to
// make a backup of @file.
// 
// Note that no copy of @contents will be made, so it must stay valid
// until @callback is called. See g_file_replace_contents_bytes_async()
// for a #GBytes version that will automatically hold a reference to the
// contents (without copying) for the duration of the call.
func (file *FileInstance) ReplaceContentsAsync(contents string, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 *C.char               // in, none, string, nullable-string
	var carg4 C.gboolean            // in
	var carg5 C.GFileCreateFlags    // in, none, casted
	var carg6 *C.GCancellable       // in, none, converted, nullable
	var carg7 C.GAsyncReadyCallback // callback, scope: async, closure: carg8, nullable
	var carg8 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	_ = contents
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const char*) because of unimplemented: non-fixed size array")
	if etag != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if makeBackup {
		carg4 = C.TRUE
	}
	carg5 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg7 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg8 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_contents_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContentsBytesAsync wraps g_file_replace_contents_bytes_async
// 
// The function takes the following parameters:
// 
// 	- contents *glib.Bytes: a #GBytes 
// 	- etag string (nullable): a new [entity tag](#entity-tags) for the @file, or %NULL 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied 
//
// Same as g_file_replace_contents_async() but takes a #GBytes input instead.
// This function will keep a ref on @contents until the operation is done.
// Unlike g_file_replace_contents_async() this allows forgetting about the
// content without waiting for the callback.
// 
// When this operation has completed, @callback will be called with
// @user_user data, and the operation can be finalized with
// g_file_replace_contents_finish().
func (file *FileInstance) ReplaceContentsBytesAsync(contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GBytes             // in, none, converted
	var carg2 *C.char               // in, none, string, nullable-string
	var carg3 C.gboolean            // in
	var carg4 C.GFileCreateFlags    // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(contents))
	if etag != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if makeBackup {
		carg3 = C.TRUE
	}
	carg4 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_contents_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceContentsFinish wraps g_file_replace_contents_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- newEtag string (nullable): a location of a new [entity tag](#entity-tags)
//   for the document. This should be freed with g_free() when it is no
//   longer needed, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous replace of the given @file. See
// g_file_replace_contents_async(). Sets @new_etag to the new entity
// tag for the document, if present.
func (file *FileInstance) ReplaceContentsFinish(res AsyncResult) (string, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.char         // out, full, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_contents_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var newEtag string
	var goret   bool
	var _goerr  error

	if carg2 != nil {
		newEtag = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return newEtag, goret, _goerr
}

// ReplaceFinish wraps g_file_replace_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileOutputStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file replace operation started with
// g_file_replace_async().
func (file *FileInstance) ReplaceFinish(res AsyncResult) (FileOutputStream, error) {
	var carg0 *C.GFile             // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileOutputStream // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileOutputStream
	var _goerr error

	goret = UnsafeFileOutputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceReadwrite wraps g_file_replace_readwrite
// 
// The function takes the following parameters:
// 
// 	- etag string (nullable): an optional [entity tag](#entity-tags)
//   for the current #GFile, or #NULL to ignore 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Returns an output stream for overwriting the file in readwrite mode,
// possibly creating a backup copy of the file first. If the file doesn't
// exist, it will be created.
// 
// For details about the behaviour, see g_file_replace() which does the
// same thing but returns an output stream only.
// 
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
func (file *FileInstance) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable Cancellable) (FileIOStream, error) {
	var carg0 *C.GFile           // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string
	var carg2 C.gboolean         // in
	var carg3 C.GFileCreateFlags // in, none, casted
	var carg4 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileIOStream   // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_replace_readwrite(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceReadwriteAsync wraps g_file_replace_readwrite_async
// 
// The function takes the following parameters:
// 
// 	- etag string (nullable): an [entity tag](#entity-tags) for the current #GFile,
//   or %NULL to ignore 
// 	- makeBackup bool: %TRUE if a backup should be created 
// 	- flags FileCreateFlags: a set of #GFileCreateFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy
// of the file first.
// 
// For more details, see g_file_replace_readwrite() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_replace_readwrite_finish() to get
// the result of the operation.
func (file *FileInstance) ReplaceReadwriteAsync(etag string, makeBackup bool, flags FileCreateFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string, nullable-string
	var carg2 C.gboolean            // in
	var carg3 C.GFileCreateFlags    // in, none, casted
	var carg4 C.int                 // in, none, casted
	var carg5 *C.GCancellable       // in, none, converted, nullable
	var carg6 C.GAsyncReadyCallback // callback, scope: async, closure: carg7, nullable
	var carg7 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if etag != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if makeBackup {
		carg2 = C.TRUE
	}
	carg3 = C.GFileCreateFlags(flags)
	carg4 = C.int(ioPriority)
	if cancellable != nil {
		carg5 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg6 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg7 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_replace_readwrite_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReplaceReadwriteFinish wraps g_file_replace_readwrite_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret FileIOStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file replace operation started with
// g_file_replace_readwrite_async().
func (file *FileInstance) ReplaceReadwriteFinish(res AsyncResult) (FileIOStream, error) {
	var carg0 *C.GFile         // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileIOStream // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_replace_readwrite_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  FileIOStream
	var _goerr error

	goret = UnsafeFileIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ResolveRelativePath wraps g_file_resolve_relative_path
// 
// The function takes the following parameters:
// 
// 	- relativePath string: a given relative path string 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Resolves a relative path for @file to an absolute path.
// 
// This call does no blocking I/O.
// 
// If the @relative_path is an absolute path name, the resolution
// is done absolutely (without taking @file path as base).
func (file *FileInstance) ResolveRelativePath(relativePath string) File {
	var carg0 *C.GFile // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_resolve_relative_path(carg0, carg1)
	runtime.KeepAlive(file)
	runtime.KeepAlive(relativePath)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetAttributeByteString wraps g_file_set_attribute_byte_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value string: a string containing the attribute's new value 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
// If @attribute is of a different type, this operation will fail,
// returning %FALSE.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_byte_string(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeInt32 wraps g_file_set_attribute_int32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value int32: a #gint32 containing the attribute's new value 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
// If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.gint32              // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint32(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_int32(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeInt64 wraps g_file_set_attribute_int64
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value int64: a #guint64 containing the attribute's new value 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
// If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.gint64              // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_int64(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeString wraps g_file_set_attribute_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value string: a string containing the attribute's value 
// 	- flags FileQueryInfoFlags: #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
// If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 *C.char               // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_string(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeUint32 wraps g_file_set_attribute_uint32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value uint32: a #guint32 containing the attribute's new value 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
// If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.guint32             // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint32(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_uint32(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributeUint64 wraps g_file_set_attribute_uint64
// 
// The function takes the following parameters:
// 
// 	- attribute string: a string containing the attribute's name 
// 	- value uint64: a #guint64 containing the attribute's new value 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
// If @attribute is of a different type, this operation will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.guint64             // in, none, casted
	var carg3 C.GFileQueryInfoFlags // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(value)
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attribute_uint64(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAttributesAsync wraps g_file_set_attributes_async
// 
// The function takes the following parameters:
// 
// 	- info FileInfo: a #GFileInfo 
// 	- flags FileQueryInfoFlags: a #GFileQueryInfoFlags 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously sets the attributes of @file with @info.
// 
// For more details, see g_file_set_attributes_from_info(),
// which is the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_set_attributes_finish() to get
// the result of the operation.
func (file *FileInstance) SetAttributesAsync(info FileInfo, flags FileQueryInfoFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GFileInfo          // in, none, converted
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg2 = C.GFileQueryInfoFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_set_attributes_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(file)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SetAttributesFinish wraps g_file_set_attributes_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- info FileInfo: a #GFileInfo 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes setting an attribute started in g_file_set_attributes_async().
func (file *FileInstance) SetAttributesFinish(result AsyncResult) (FileInfo, bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 *C.GFileInfo    // out, full, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_set_attributes_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var info   FileInfo
	var goret  bool
	var _goerr error

	info = UnsafeFileInfoFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return info, goret, _goerr
}

// SetAttributesFromInfo wraps g_file_set_attributes_from_info
// 
// The function takes the following parameters:
// 
// 	- info FileInfo: a #GFileInfo 
// 	- flags FileQueryInfoFlags: #GFileQueryInfoFlags 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to set all attributes in the #GFileInfo on the target
// values, not stopping on the first error.
// 
// If there is any error during this operation then @error will
// be set to the first error. Error on particular fields are flagged
// by setting the "status" field in the attribute value to
// %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
// also detect further errors.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetAttributesFromInfo(info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.GFileInfo          // in, none, converted
	var carg2 C.GFileQueryInfoFlags // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg2 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_attributes_from_info(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDisplayName wraps g_file_set_display_name
// 
// The function takes the following parameters:
// 
// 	- displayName string: a string 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Renames @file to the specified display name.
// 
// The display name is converted from UTF-8 to the correct encoding
// for the target filesystem if possible and the @file is renamed to this.
// 
// If you want to implement a rename operation in the user interface the
// edit name (%G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
// initial value in the rename widget, and then the result after editing
// should be passed to g_file_set_display_name().
// 
// On success the resulting converted filename is returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) SetDisplayName(displayName string, cancellable Cancellable) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_set_display_name(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(cancellable)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDisplayNameAsync wraps g_file_set_display_name_async
// 
// The function takes the following parameters:
// 
// 	- displayName string: a string 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously sets the display name for a given #GFile.
// 
// For more details, see g_file_set_display_name() which is
// the synchronous version of this call.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_set_display_name_finish() to get
// the result of the operation.
func (file *FileInstance) SetDisplayNameAsync(displayName string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_set_display_name_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SetDisplayNameFinish wraps g_file_set_display_name_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret File 
// 	- _goerr error (nullable): an error 
//
// Finishes setting a display name started with
// g_file_set_display_name_async().
func (file *FileInstance) SetDisplayNameFinish(res AsyncResult) (File, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFile        // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_file_set_display_name_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var goret  File
	var _goerr error

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// StartMountable wraps g_file_start_mountable
// 
// The function takes the following parameters:
// 
// 	- flags DriveStartFlags: flags affecting the operation 
// 	- startOperation MountOperation (nullable): a #GMountOperation, or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call when the request is satisfied, or %NULL 
//
// Starts a file of type %G_FILE_TYPE_MOUNTABLE.
// Using @start_operation, you can request callbacks when, for instance,
// passwords are needed during authentication.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_mount_mountable_finish() to get
// the result of the operation.
func (file *FileInstance) StartMountable(flags DriveStartFlags, startOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GDriveStartFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(startOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_start_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StartMountableFinish wraps g_file_start_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a start operation. See g_file_start_mountable() for details.
// 
// Finish an asynchronous start operation that was started
// with g_file_start_mountable().
func (file *FileInstance) StartMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_start_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// StopMountable wraps g_file_stop_mountable
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation,
//   or %NULL to avoid user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied, or %NULL 
//
// Stops a file of type %G_FILE_TYPE_MOUNTABLE.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_stop_mountable_finish() to get
// the result of the operation.
func (file *FileInstance) StopMountable(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_stop_mountable(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// StopMountableFinish wraps g_file_stop_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a stop operation, see g_file_stop_mountable() for details.
// 
// Finish an asynchronous stop operation that was started
// with g_file_stop_mountable().
func (file *FileInstance) StopMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_stop_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SupportsThreadContexts wraps g_file_supports_thread_contexts
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @file supports thread-default main contexts
// (see [method@GLib.MainContext.push_thread_default])
// If this returns %FALSE, you cannot perform asynchronous operations on
// @file in a thread that has a thread-default context.
func (file *FileInstance) SupportsThreadContexts() bool {
	var carg0 *C.GFile   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_supports_thread_contexts(carg0)
	runtime.KeepAlive(file)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Trash wraps g_file_trash
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sends @file to the "Trashcan", if possible. This is similar to
// deleting it, but the user can recover it before emptying the trashcan.
// Trashing is disabled for system mounts by default (see
// g_unix_mount_entry_is_system_internal()), so this call can return the
// %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
// mount option can be used to disable g_file_trash() support for particular
// mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
// Since 2.82, the `x-gvfs-trash` unix mount option can be used to enable
// g_file_trash() support for particular system mounts.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (file *FileInstance) Trash(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_trash(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TrashAsync wraps g_file_trash_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied 
//
// Asynchronously sends @file to the Trash location, if possible.
func (file *FileInstance) TrashAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_trash_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// TrashFinish wraps g_file_trash_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
func (file *FileInstance) TrashFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_trash_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountMountable wraps g_file_unmount_mountable
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
//
// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation() instead.
func (file *FileInstance) UnmountMountable(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_unmount_mountable(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountMountableFinish wraps g_file_unmount_mountable_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an unmount operation, see g_file_unmount_mountable() for details.
// 
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable().
//
// Deprecated: (since 2.22.0) Use g_file_unmount_mountable_with_operation_finish()
//   instead.
func (file *FileInstance) UnmountMountableFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_unmount_mountable_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountMountableWithOperation wraps g_file_unmount_mountable_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation,
//   or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object,
//   %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Unmounts a file of type %G_FILE_TYPE_MOUNTABLE.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// 
// When the operation is finished, @callback will be called.
// You can then call g_file_unmount_mountable_finish() to get
// the result of the operation.
func (file *FileInstance) UnmountMountableWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFile              // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_unmount_mountable_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountMountableWithOperationFinish wraps g_file_unmount_mountable_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an unmount operation,
// see g_file_unmount_mountable_with_operation() for details.
// 
// Finish an asynchronous unmount operation that was started
// with g_file_unmount_mountable_with_operation().
func (file *FileInstance) UnmountMountableWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFile        // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_unmount_mountable_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IconInstance is the instance type used by all types implementing GIcon. It is used internally by the bindings. Users should use the interface [Icon] instead.
type IconInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Icon = (*IconInstance)(nil)

// Icon wraps GIcon
//
// `GIcon` is a very minimal interface for icons. It provides functions
// for checking the equality of two icons, hashing of icons and
// serializing an icon to and from strings.
// 
// `GIcon` does not provide the actual pixmap for the icon as this is out
// of GIO's scope, however implementations of `GIcon` may contain the name
// of an icon (see [class@Gio.ThemedIcon]), or the path to an icon
// (see [iface@Gio.LoadableIcon]).
// 
// To obtain a hash of a `GIcon`, see [method@Gio.Icon.hash].
// 
// To check if two `GIcon`s are equal, see [method@Gio.Icon.equal].
// 
// For serializing a `GIcon`, use [method@Gio.Icon.serialize] and
// [func@Gio.Icon.deserialize].
// 
// If you want to consume `GIcon` (for example, in a toolkit) you must
// be prepared to handle at least the three following cases:
// [iface@Gio.LoadableIcon], [class@Gio.ThemedIcon] and [class@Gio.EmblemedIcon].
// It may also make sense to have fast-paths for other cases (like handling
// [`GdkPixbuf`](https://docs.gtk.org/gdk-pixbuf/class.Pixbuf.html) directly,
// for example) but all compliant `GIcon` implementations outside of GIO must
// implement [iface@Gio.LoadableIcon].
// 
// If your application or library provides one or more `GIcon`
// implementations you need to ensure that your new implementation also
// implements [iface@Gio.LoadableIcon].  Additionally, you must provide an
// implementation of [method@Gio.Icon.serialize] that gives a result that is
// understood by [func@Gio.Icon.deserialize], yielding one of the built-in
// icon types.
type Icon interface {
	upcastToGIcon() *IconInstance

	// Equal wraps g_icon_equal
	// 
	// The function takes the following parameters:
	// 
	// 	- icon2 Icon (nullable): pointer to the second #GIcon. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if two icons are equal.
	Equal(Icon) bool
	// String wraps g_icon_to_string
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Generates a textual representation of @icon that can be used for
	// serialization such as when passing @icon to a different process or
	// saving it to persistent storage. Use g_icon_new_for_string() to
	// get @icon back from the returned string.
	// 
	// The encoding of the returned string is proprietary to #GIcon except
	// in the following two cases
	// 
	// - If @icon is a #GFileIcon, the returned string is a native path
	//   (such as `/path/to/my icon.png`) without escaping
	//   if the #GFile for @icon is a native file.  If the file is not
	//   native, the returned string is the result of g_file_get_uri()
	//   (such as `sftp://path/to/my%20icon.png`).
	// 
	// - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
	//   the encoding is simply the name (such as `network-server`).
	String() string
}

var _ Icon = (*IconInstance)(nil)

func unsafeWrapIcon(base *gobject.ObjectInstance) *IconInstance {
	return &IconInstance{
		Instance: *base,
	}
}

func marshalIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (i *IconInstance) upcastToGIcon() *IconInstance {
	return i
}

// UnsafeIconFromGlibNone is used to convert raw GIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeIconFromGlibNone(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibNone(c).(Icon)
}

// UnsafeIconFromGlibFull is used to convert raw GIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeIconFromGlibFull(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibFull(c).(Icon)
}

// UnsafeIconFromGlibBorrow is used to convert raw GIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeIconFromGlibBorrow(c unsafe.Pointer) Icon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Icon)
}

// UnsafeIconToGlibNone is used to convert the instance to it's C value GIcon. This is used by the bindings internally.
func UnsafeIconToGlibNone(c Icon) unsafe.Pointer {
	i := c.upcastToGIcon()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeIconToGlibFull is used to convert the instance to it's C value GIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeIconToGlibFull(c Icon) unsafe.Pointer {
	i := c.upcastToGIcon()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewIconForString wraps g_icon_new_for_string
// 
// The function takes the following parameters:
// 
// 	- str string: A string obtained via g_icon_to_string(). 
// 
// The function returns the following values:
// 
// 	- goret Icon 
// 	- _goerr error (nullable): an error 
//
// Generate a #GIcon instance from @str. This function can fail if
// @str is not valid - see g_icon_to_string() for discussion.
// 
// If your application or library provides one or more #GIcon
// implementations you need to ensure that each #GType is registered
// with the type system prior to calling g_icon_new_for_string().
func NewIconForString(str string) (Icon, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GIcon  // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_icon_new_for_string(carg1, &_cerr)
	runtime.KeepAlive(str)

	var goret  Icon
	var _goerr error

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_icon_equal
// 
// The function takes the following parameters:
// 
// 	- icon2 Icon (nullable): pointer to the second #GIcon. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if two icons are equal.
func (icon1 *IconInstance) Equal(icon2 Icon) bool {
	var carg0 *C.GIcon   // in, none, converted
	var carg1 *C.GIcon   // in, none, converted, nullable
	var cret  C.gboolean // return

	carg0 = (*C.GIcon)(UnsafeIconToGlibNone(icon1))
	if icon2 != nil {
		carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon2))
	}

	cret = C.g_icon_equal(carg0, carg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// String wraps g_icon_to_string
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Generates a textual representation of @icon that can be used for
// serialization such as when passing @icon to a different process or
// saving it to persistent storage. Use g_icon_new_for_string() to
// get @icon back from the returned string.
// 
// The encoding of the returned string is proprietary to #GIcon except
// in the following two cases
// 
// - If @icon is a #GFileIcon, the returned string is a native path
//   (such as `/path/to/my icon.png`) without escaping
//   if the #GFile for @icon is a native file.  If the file is not
//   native, the returned string is the result of g_file_get_uri()
//   (such as `sftp://path/to/my%20icon.png`).
// 
// - If @icon is a #GThemedIcon with exactly one name and no fallbacks,
//   the encoding is simply the name (such as `network-server`).
func (icon *IconInstance) String() string {
	var carg0 *C.GIcon // in, none, converted
	var cret  *C.gchar // return, full, string, nullable-string

	carg0 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	cret = C.g_icon_to_string(carg0)
	runtime.KeepAlive(icon)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// InitableInstance is the instance type used by all types implementing GInitable. It is used internally by the bindings. Users should use the interface [Initable] instead.
type InitableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Initable = (*InitableInstance)(nil)

// Initable wraps GInitable
//
// `GInitable` is implemented by objects that can fail during
// initialization. If an object implements this interface then
// it must be initialized as the first thing after construction,
// either via [method@Gio.Initable.init] or [method@Gio.AsyncInitable.init_async]
// (the latter is only available if it also implements [iface@Gio.AsyncInitable]).
// 
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except `g_object_ref()` and
// `g_object_unref()` are considered to be invalid, and have undefined
// behaviour. They will often fail with [func@GLib.critical] or
// [func@GLib.warning], but this must not be relied on.
// 
// Users of objects implementing this are not intended to use
// the interface method directly, instead it will be used automatically
// in various ways. For C applications you generally just call
// [func@Gio.Initable.new] directly, or indirectly via a `foo_thing_new()` wrapper.
// This will call [method@Gio.Initable.init] under the cover, returning `NULL`
// and setting a `GError` on failure (at which point the instance is
// unreferenced).
// 
// For bindings in languages where the native constructor supports
// exceptions the binding could check for objects implementing `GInitable`
// during normal construction and automatically initialize them, throwing
// an exception on failure.
type Initable interface {
	upcastToGInitable() *InitableInstance

	// Init wraps g_initable_init
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Initializes the object implementing the interface.
	// 
	// This method is intended for language bindings. If writing in C,
	// g_initable_new() should typically be used instead.
	// 
	// The object must be initialized before any real use after initial
	// construction, either with this function or g_async_initable_init_async().
	// 
	// Implementations may also support cancellation. If @cancellable is not %NULL,
	// then initialization can be cancelled by triggering the cancellable object
	// from another thread. If the operation was cancelled, the error
	// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
	// the object doesn't support cancellable initialization the error
	// %G_IO_ERROR_NOT_SUPPORTED will be returned.
	// 
	// If the object is not initialized, or initialization returns with an
	// error, then all operations on the object except g_object_ref() and
	// g_object_unref() are considered to be invalid, and have undefined
	// behaviour. See the [description][iface@Gio.Initable#description] for more details.
	// 
	// Callers should not assume that a class which implements #GInitable can be
	// initialized multiple times, unless the class explicitly documents itself as
	// supporting this. Generally, a class&#x2019; implementation of init() can assume
	// (and assert) that it will only be called once. Previously, this documentation
	// recommended all #GInitable implementations should be idempotent; that
	// recommendation was relaxed in GLib 2.54.
	// 
	// If a class explicitly supports being initialized multiple times, it is
	// recommended that the method is idempotent: multiple calls with the same
	// arguments should return the same results. Only the first call initializes
	// the object; further calls return the result of the first call.
	// 
	// One reason why a class might need to support idempotent initialization is if
	// it is designed to be used via the singleton pattern, with a
	// #GObjectClass.constructor that sometimes returns an existing instance.
	// In this pattern, a caller would expect to be able to call g_initable_init()
	// on the result of g_object_new(), regardless of whether it is in fact a new
	// instance.
	Init(Cancellable) (bool, error)
}

var _ Initable = (*InitableInstance)(nil)

func unsafeWrapInitable(base *gobject.ObjectInstance) *InitableInstance {
	return &InitableInstance{
		Instance: *base,
	}
}

func marshalInitableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (i *InitableInstance) upcastToGInitable() *InitableInstance {
	return i
}

// UnsafeInitableFromGlibNone is used to convert raw GInitable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInitableFromGlibNone(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibNone(c).(Initable)
}

// UnsafeInitableFromGlibFull is used to convert raw GInitable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInitableFromGlibFull(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibFull(c).(Initable)
}

// UnsafeInitableFromGlibBorrow is used to convert raw GInitable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInitableFromGlibBorrow(c unsafe.Pointer) Initable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Initable)
}

// UnsafeInitableToGlibNone is used to convert the instance to it's C value GInitable. This is used by the bindings internally.
func UnsafeInitableToGlibNone(c Initable) unsafe.Pointer {
	i := c.upcastToGInitable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeInitableToGlibFull is used to convert the instance to it's C value GInitable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInitableToGlibFull(c Initable) unsafe.Pointer {
	i := c.upcastToGInitable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Init wraps g_initable_init
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Initializes the object implementing the interface.
// 
// This method is intended for language bindings. If writing in C,
// g_initable_new() should typically be used instead.
// 
// The object must be initialized before any real use after initial
// construction, either with this function or g_async_initable_init_async().
// 
// Implementations may also support cancellation. If @cancellable is not %NULL,
// then initialization can be cancelled by triggering the cancellable object
// from another thread. If the operation was cancelled, the error
// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
// the object doesn't support cancellable initialization the error
// %G_IO_ERROR_NOT_SUPPORTED will be returned.
// 
// If the object is not initialized, or initialization returns with an
// error, then all operations on the object except g_object_ref() and
// g_object_unref() are considered to be invalid, and have undefined
// behaviour. See the [description][iface@Gio.Initable#description] for more details.
// 
// Callers should not assume that a class which implements #GInitable can be
// initialized multiple times, unless the class explicitly documents itself as
// supporting this. Generally, a class&#x2019; implementation of init() can assume
// (and assert) that it will only be called once. Previously, this documentation
// recommended all #GInitable implementations should be idempotent; that
// recommendation was relaxed in GLib 2.54.
// 
// If a class explicitly supports being initialized multiple times, it is
// recommended that the method is idempotent: multiple calls with the same
// arguments should return the same results. Only the first call initializes
// the object; further calls return the result of the first call.
// 
// One reason why a class might need to support idempotent initialization is if
// it is designed to be used via the singleton pattern, with a
// #GObjectClass.constructor that sometimes returns an existing instance.
// In this pattern, a caller would expect to be able to call g_initable_init()
// on the result of g_object_new(), regardless of whether it is in fact a new
// instance.
func (initable *InitableInstance) Init(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInitable    // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInitable)(UnsafeInitableToGlibNone(initable))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_initable_init(carg0, carg1, &_cerr)
	runtime.KeepAlive(initable)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ListModelInstance is the instance type used by all types implementing GListModel. It is used internally by the bindings. Users should use the interface [ListModel] instead.
type ListModelInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ListModel = (*ListModelInstance)(nil)

// ListModel wraps GListModel
//
// `GListModel` is an interface that represents a mutable list of
// [class@GObject.Object]. Its main intention is as a model for various widgets
// in user interfaces, such as list views, but it can also be used as a
// convenient method of returning lists of data, with support for
// updates.
// 
// Each object in the list may also report changes in itself via some
// mechanism (normally the [signal@GObject.Object::notify] signal).  Taken
// together with the [signal@Gio.ListModel::items-changed] signal, this provides
// for a list that can change its membership, and in which the members can
// change their individual properties.
// 
// A good example would be the list of visible wireless network access
// points, where each access point can report dynamic properties such as
// signal strength.
// 
// It is important to note that the `GListModel` itself does not report
// changes to the individual items.  It only reports changes to the list
// membership.  If you want to observe changes to the objects themselves
// then you need to connect signals to the objects that you are
// interested in.
// 
// All items in a `GListModel` are of (or derived from) the same type.
// [method@Gio.ListModel.get_item_type] returns that type.  The type may be an
// interface, in which case all objects in the list must implement it.
// 
// The semantics are close to that of an array:
// [method@Gio.ListModel.get_n_items] returns the number of items in the list
// and [method@Gio.ListModel.get_item] returns an item at a (0-based) position.
// In order to allow implementations to calculate the list length lazily,
// you can also iterate over items: starting from 0, repeatedly call
// [method@Gio.ListModel.get_item] until it returns `NULL`.
// 
// An implementation may create objects lazily, but must take care to
// return the same object for a given position until all references to
// it are gone.
// 
// On the other side, a consumer is expected only to hold references on
// objects that are currently &#x2018;user visible&#x2019;, in order to facilitate the
// maximum level of laziness in the implementation of the list and to
// reduce the required number of signal connections at a given time.
// 
// This interface is intended only to be used from a single thread.  The
// thread in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns
// the thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) in effect at the time that the
// model was created.
// 
// Over time, it has established itself as good practice for list model
// implementations to provide properties `item-type` and `n-items` to
// ease working with them. While it is not required, it is recommended
// that implementations provide these two properties. They should return
// the values of [method@Gio.ListModel.get_item_type] and
// [method@Gio.ListModel.get_n_items] respectively and be defined as such:
// 
// ```c
// properties[PROP_ITEM_TYPE] =
//   g_param_spec_gtype ("item-type", NULL, NULL, G_TYPE_OBJECT,
//                       G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
// properties[PROP_N_ITEMS] =
//   g_param_spec_uint ("n-items", NULL, NULL, 0, G_MAXUINT, 0,
//                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
// ```
type ListModel interface {
	upcastToGListModel() *ListModelInstance

	// GetItemType wraps g_list_model_get_item_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the type of the items in @list.
	// 
	// All items returned from g_list_model_get_item() are of the type
	// returned by this function, or a subtype, or if the type is an
	// interface, they are an implementation of that interface.
	// 
	// The item type of a #GListModel can not change during the life of the
	// model.
	GetItemType() gobject.Type
	// GetNItems wraps g_list_model_get_n_items
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the number of items in @list.
	// 
	// Depending on the model implementation, calling this function may be
	// less efficient than iterating the list with increasing values for
	// @position until g_list_model_get_item() returns %NULL.
	GetNItems() uint
	// GetObject wraps g_list_model_get_object
	// 
	// The function takes the following parameters:
	// 
	// 	- position uint: the position of the item to fetch 
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Object (nullable) 
	//
	// Get the item at @position.
	// 
	// If @position is greater than the number of items in @list, %NULL is
	// returned.
	// 
	// %NULL is never returned for an index that is smaller than the length
	// of the list.
	// 
	// This function is meant to be used by language bindings in place
	// of g_list_model_get_item().
	// 
	// See also: g_list_model_get_n_items()
	GetObject(uint) gobject.Object
	// ItemsChanged wraps g_list_model_items_changed
	// 
	// The function takes the following parameters:
	// 
	// 	- position uint: the position at which @list changed 
	// 	- removed uint: the number of items removed 
	// 	- added uint: the number of items added 
	//
	// Emits the #GListModel::items-changed signal on @list.
	// 
	// This function should only be called by classes implementing
	// #GListModel. It has to be called after the internal representation
	// of @list has been updated, because handlers connected to this signal
	// might query the new state of the list.
	// 
	// Implementations must only make changes to the model (as visible to
	// its consumer) in places that will not cause problems for that
	// consumer.  For models that are driven directly by a write API (such
	// as #GListStore), changes can be reported in response to uses of that
	// API.  For models that represent remote data, changes should only be
	// made from a fresh mainloop dispatch.  It is particularly not
	// permitted to make changes in response to a call to the #GListModel
	// consumer API.
	// 
	// Stated another way: in general, it is assumed that code making a
	// series of accesses to the model via the API, without returning to the
	// mainloop, and without calling other code, will continue to view the
	// same contents of the model.
	ItemsChanged(uint, uint, uint)
	// ConnectItemsChanged connects the provided callback to the "items-changed" signal
	//
	// This signal is emitted whenever items were added to or removed
	// from @list. At @position, @removed items were removed and @added
	// items were added in their place.
	// 
	// Note: If `removed != added`, the positions of all later items
	// in the model change.
	ConnectItemsChanged(func(ListModel, uint, uint, uint)) gobject.SignalHandle
}

var _ ListModel = (*ListModelInstance)(nil)

func unsafeWrapListModel(base *gobject.ObjectInstance) *ListModelInstance {
	return &ListModelInstance{
		Instance: *base,
	}
}

func marshalListModelInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (l *ListModelInstance) upcastToGListModel() *ListModelInstance {
	return l
}

// UnsafeListModelFromGlibNone is used to convert raw GListModel pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeListModelFromGlibNone(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibNone(c).(ListModel)
}

// UnsafeListModelFromGlibFull is used to convert raw GListModel pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeListModelFromGlibFull(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibFull(c).(ListModel)
}

// UnsafeListModelFromGlibBorrow is used to convert raw GListModel pointers to go without touching any references. This is used by the bindings internally.
func UnsafeListModelFromGlibBorrow(c unsafe.Pointer) ListModel {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ListModel)
}

// UnsafeListModelToGlibNone is used to convert the instance to it's C value GListModel. This is used by the bindings internally.
func UnsafeListModelToGlibNone(c ListModel) unsafe.Pointer {
	i := c.upcastToGListModel()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeListModelToGlibFull is used to convert the instance to it's C value GListModel, while removeing the finalizer. This is used by the bindings internally.
func UnsafeListModelToGlibFull(c ListModel) unsafe.Pointer {
	i := c.upcastToGListModel()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetItemType wraps g_list_model_get_item_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the type of the items in @list.
// 
// All items returned from g_list_model_get_item() are of the type
// returned by this function, or a subtype, or if the type is an
// interface, they are an implementation of that interface.
// 
// The item type of a #GListModel can not change during the life of the
// model.
func (list *ListModelInstance) GetItemType() gobject.Type {
	var carg0 *C.GListModel // in, none, converted
	var cret  C.GType       // return, none, casted, alias

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))

	cret = C.g_list_model_get_item_type(carg0)
	runtime.KeepAlive(list)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetNItems wraps g_list_model_get_n_items
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the number of items in @list.
// 
// Depending on the model implementation, calling this function may be
// less efficient than iterating the list with increasing values for
// @position until g_list_model_get_item() returns %NULL.
func (list *ListModelInstance) GetNItems() uint {
	var carg0 *C.GListModel // in, none, converted
	var cret  C.guint       // return, none, casted

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))

	cret = C.g_list_model_get_n_items(carg0)
	runtime.KeepAlive(list)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetObject wraps g_list_model_get_object
// 
// The function takes the following parameters:
// 
// 	- position uint: the position of the item to fetch 
// 
// The function returns the following values:
// 
// 	- goret gobject.Object (nullable) 
//
// Get the item at @position.
// 
// If @position is greater than the number of items in @list, %NULL is
// returned.
// 
// %NULL is never returned for an index that is smaller than the length
// of the list.
// 
// This function is meant to be used by language bindings in place
// of g_list_model_get_item().
// 
// See also: g_list_model_get_n_items()
func (list *ListModelInstance) GetObject(position uint) gobject.Object {
	var carg0 *C.GListModel // in, none, converted
	var carg1 C.guint       // in, none, casted
	var cret  *C.GObject    // return, full, converted, nullable

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))
	carg1 = C.guint(position)

	cret = C.g_list_model_get_object(carg0, carg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ItemsChanged wraps g_list_model_items_changed
// 
// The function takes the following parameters:
// 
// 	- position uint: the position at which @list changed 
// 	- removed uint: the number of items removed 
// 	- added uint: the number of items added 
//
// Emits the #GListModel::items-changed signal on @list.
// 
// This function should only be called by classes implementing
// #GListModel. It has to be called after the internal representation
// of @list has been updated, because handlers connected to this signal
// might query the new state of the list.
// 
// Implementations must only make changes to the model (as visible to
// its consumer) in places that will not cause problems for that
// consumer.  For models that are driven directly by a write API (such
// as #GListStore), changes can be reported in response to uses of that
// API.  For models that represent remote data, changes should only be
// made from a fresh mainloop dispatch.  It is particularly not
// permitted to make changes in response to a call to the #GListModel
// consumer API.
// 
// Stated another way: in general, it is assumed that code making a
// series of accesses to the model via the API, without returning to the
// mainloop, and without calling other code, will continue to view the
// same contents of the model.
func (list *ListModelInstance) ItemsChanged(position uint, removed uint, added uint) {
	var carg0 *C.GListModel // in, none, converted
	var carg1 C.guint       // in, none, casted
	var carg2 C.guint       // in, none, casted
	var carg3 C.guint       // in, none, casted

	carg0 = (*C.GListModel)(UnsafeListModelToGlibNone(list))
	carg1 = C.guint(position)
	carg2 = C.guint(removed)
	carg3 = C.guint(added)

	C.g_list_model_items_changed(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// ConnectItemsChanged connects the provided callback to the "items-changed" signal
//
// This signal is emitted whenever items were added to or removed
// from @list. At @position, @removed items were removed and @added
// items were added in their place.
// 
// Note: If `removed != added`, the positions of all later items
// in the model change.
func (o *ListModelInstance) ConnectItemsChanged(fn func(ListModel, uint, uint, uint)) gobject.SignalHandle {
	return o.Instance.Connect("items-changed", fn)
}

// LoadableIconInstance is the instance type used by all types implementing GLoadableIcon. It is used internally by the bindings. Users should use the interface [LoadableIcon] instead.
type LoadableIconInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ LoadableIcon = (*LoadableIconInstance)(nil)

// LoadableIcon wraps GLoadableIcon
//
// `GLoadableIcon` extends the [iface@Gio.Icon] interface and adds the ability
// to load icons from streams.
type LoadableIcon interface {
	upcastToGLoadableIcon() *LoadableIconInstance

	// Load wraps g_loadable_icon_load
	// 
	// The function takes the following parameters:
	// 
	// 	- size int32: an integer. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to
	// ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- typ string: a location to store the type of the loaded
	// icon, %NULL to ignore. 
	// 	- goret InputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Loads a loadable icon. For the asynchronous version of this function,
	// see g_loadable_icon_load_async().
	Load(int32, Cancellable) (string, InputStream, error)
	// LoadAsync wraps g_loadable_icon_load_async
	// 
	// The function takes the following parameters:
	// 
	// 	- size int32: an integer. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Loads an icon asynchronously. To finish this function, see
	// g_loadable_icon_load_finish(). For the synchronous, blocking
	// version of this function, see g_loadable_icon_load().
	LoadAsync(int32, Cancellable, AsyncReadyCallback)
	// LoadFinish wraps g_loadable_icon_load_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- res AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- typ string: a location to store the type of the loaded
	//        icon, %NULL to ignore. 
	// 	- goret InputStream 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous icon load started in g_loadable_icon_load_async().
	LoadFinish(AsyncResult) (string, InputStream, error)
}

var _ LoadableIcon = (*LoadableIconInstance)(nil)

func unsafeWrapLoadableIcon(base *gobject.ObjectInstance) *LoadableIconInstance {
	return &LoadableIconInstance{
		Instance: *base,
	}
}

func marshalLoadableIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (l *LoadableIconInstance) upcastToGLoadableIcon() *LoadableIconInstance {
	return l
}

// UnsafeLoadableIconFromGlibNone is used to convert raw GLoadableIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibNone(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(LoadableIcon)
}

// UnsafeLoadableIconFromGlibFull is used to convert raw GLoadableIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibFull(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(LoadableIcon)
}

// UnsafeLoadableIconFromGlibBorrow is used to convert raw GLoadableIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeLoadableIconFromGlibBorrow(c unsafe.Pointer) LoadableIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(LoadableIcon)
}

// UnsafeLoadableIconToGlibNone is used to convert the instance to it's C value GLoadableIcon. This is used by the bindings internally.
func UnsafeLoadableIconToGlibNone(c LoadableIcon) unsafe.Pointer {
	i := c.upcastToGLoadableIcon()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeLoadableIconToGlibFull is used to convert the instance to it's C value GLoadableIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeLoadableIconToGlibFull(c LoadableIcon) unsafe.Pointer {
	i := c.upcastToGLoadableIcon()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Load wraps g_loadable_icon_load
// 
// The function takes the following parameters:
// 
// 	- size int32: an integer. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to
// ignore. 
// 
// The function returns the following values:
// 
// 	- typ string: a location to store the type of the loaded
// icon, %NULL to ignore. 
// 	- goret InputStream 
// 	- _goerr error (nullable): an error 
//
// Loads a loadable icon. For the asynchronous version of this function,
// see g_loadable_icon_load_async().
func (icon *LoadableIconInstance) Load(size int32, cancellable Cancellable) (string, InputStream, error) {
	var carg0 *C.GLoadableIcon // in, none, converted
	var carg1 C.int            // in, none, casted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var carg2 *C.char          // out, full, string
	var cret  *C.GInputStream  // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = C.int(size)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_loadable_icon_load(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var typ    string
	var goret  InputStream
	var _goerr error

	typ = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return typ, goret, _goerr
}

// LoadAsync wraps g_loadable_icon_load_async
// 
// The function takes the following parameters:
// 
// 	- size int32: an integer. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Loads an icon asynchronously. To finish this function, see
// g_loadable_icon_load_finish(). For the synchronous, blocking
// version of this function, see g_loadable_icon_load().
func (icon *LoadableIconInstance) LoadAsync(size int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GLoadableIcon      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = C.int(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_loadable_icon_load_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LoadFinish wraps g_loadable_icon_load_finish
// 
// The function takes the following parameters:
// 
// 	- res AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- typ string: a location to store the type of the loaded
//        icon, %NULL to ignore. 
// 	- goret InputStream 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous icon load started in g_loadable_icon_load_async().
func (icon *LoadableIconInstance) LoadFinish(res AsyncResult) (string, InputStream, error) {
	var carg0 *C.GLoadableIcon // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 *C.char          // out, full, string
	var cret  *C.GInputStream  // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GLoadableIcon)(UnsafeLoadableIconToGlibNone(icon))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(res))

	cret = C.g_loadable_icon_load_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(res)

	var typ    string
	var goret  InputStream
	var _goerr error

	typ = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return typ, goret, _goerr
}

// MemoryMonitorInstance is the instance type used by all types implementing GMemoryMonitor. It is used internally by the bindings. Users should use the interface [MemoryMonitor] instead.
type MemoryMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ MemoryMonitor = (*MemoryMonitorInstance)(nil)

// MemoryMonitor wraps GMemoryMonitor
//
// `GMemoryMonitor` will monitor system memory and suggest to the application
// when to free memory so as to leave more room for other applications.
// It is implemented on Linux using the
// [Low Memory Monitor](https://gitlab.freedesktop.org/hadess/low-memory-monitor/)
// ([API documentation](https://hadess.pages.freedesktop.org/low-memory-monitor/)).
// 
// There is also an implementation for use inside Flatpak sandboxes.
// 
// Possible actions to take when the signal is received are:
// 
//  - Free caches
//  - Save files that haven&#x2019;t been looked at in a while to disk, ready to be reopened when needed
//  - Run a garbage collection cycle
//  - Try and compress fragmented allocations
//  - Exit on idle if the process has no reason to stay around
//  - Call [`malloc_trim(3)`](man:malloc_trim(3)) to return cached heap pages to
//    the kernel (if supported by your libc)
// 
// Note that some actions may not always improve system performance, and so
// should be profiled for your application. `malloc_trim()`, for example, may
// make future heap allocations slower (due to releasing cached heap pages back
// to the kernel).
// 
// See [type@Gio.MemoryMonitorWarningLevel] for details on the various warning
// levels.
// 
// ```c
// static void
// warning_cb (GMemoryMonitor *m, GMemoryMonitorWarningLevel level)
// {
//   g_debug ("Warning level: %d", level);
//   if (warning_level &gt; G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//     drop_caches ();
// }
// 
// static GMemoryMonitor *
// monitor_low_memory (void)
// {
//   GMemoryMonitor *m;
//   m = g_memory_monitor_dup_default ();
//   g_signal_connect (G_OBJECT (m), "low-memory-warning",
//                     G_CALLBACK (warning_cb), NULL);
//   return m;
// }
// ```
// 
// Don&#x2019;t forget to disconnect the [signal@Gio.MemoryMonitor::low-memory-warning]
// signal, and unref the `GMemoryMonitor` itself when exiting.
type MemoryMonitor interface {
	upcastToGMemoryMonitor() *MemoryMonitorInstance

	// ConnectLowMemoryWarning connects the provided callback to the "low-memory-warning" signal
	//
	// Emitted when the system is running low on free memory. The signal
	// handler should then take the appropriate action depending on the
	// warning level. See the #GMemoryMonitorWarningLevel documentation for
	// details.
	ConnectLowMemoryWarning(func(MemoryMonitor, MemoryMonitorWarningLevel)) gobject.SignalHandle
}

var _ MemoryMonitor = (*MemoryMonitorInstance)(nil)

func unsafeWrapMemoryMonitor(base *gobject.ObjectInstance) *MemoryMonitorInstance {
	return &MemoryMonitorInstance{
		Instance: *base,
	}
}

func marshalMemoryMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (m *MemoryMonitorInstance) upcastToGMemoryMonitor() *MemoryMonitorInstance {
	return m
}

// UnsafeMemoryMonitorFromGlibNone is used to convert raw GMemoryMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibNone(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorFromGlibFull is used to convert raw GMemoryMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibFull(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorFromGlibBorrow is used to convert raw GMemoryMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryMonitorFromGlibBorrow(c unsafe.Pointer) MemoryMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryMonitor)
}

// UnsafeMemoryMonitorToGlibNone is used to convert the instance to it's C value GMemoryMonitor. This is used by the bindings internally.
func UnsafeMemoryMonitorToGlibNone(c MemoryMonitor) unsafe.Pointer {
	i := c.upcastToGMemoryMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeMemoryMonitorToGlibFull is used to convert the instance to it's C value GMemoryMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryMonitorToGlibFull(c MemoryMonitor) unsafe.Pointer {
	i := c.upcastToGMemoryMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// MemoryMonitorDupDefault wraps g_memory_monitor_dup_default
// 
// The function returns the following values:
// 
// 	- goret MemoryMonitor 
//
// Gets a reference to the default #GMemoryMonitor for the system.
func MemoryMonitorDupDefault() MemoryMonitor {
	var cret *C.GMemoryMonitor // return, full, converted

	cret = C.g_memory_monitor_dup_default()

	var goret MemoryMonitor

	goret = UnsafeMemoryMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectLowMemoryWarning connects the provided callback to the "low-memory-warning" signal
//
// Emitted when the system is running low on free memory. The signal
// handler should then take the appropriate action depending on the
// warning level. See the #GMemoryMonitorWarningLevel documentation for
// details.
func (o *MemoryMonitorInstance) ConnectLowMemoryWarning(fn func(MemoryMonitor, MemoryMonitorWarningLevel)) gobject.SignalHandle {
	return o.Instance.Connect("low-memory-warning", fn)
}

// MountInstance is the instance type used by all types implementing GMount. It is used internally by the bindings. Users should use the interface [Mount] instead.
type MountInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Mount = (*MountInstance)(nil)

// Mount wraps GMount
//
// The `GMount` interface represents a user-visible mount, such as a mounted
// file system.
// 
// `GMount` is a &#x2018;mounted&#x2019; filesystem that you can access. Mounted is in
// quotes because it&#x2019;s not the same as a UNIX mount, it might be a GVFS
// mount, but you can still access the files on it if you use GIO.
// 
// A `GMount` might be associated with a [iface@Gio.Volume] (such as a USB flash
// drive) which hosts it.
// 
// Unmounting a `GMount` instance is an asynchronous operation. For
// more information about asynchronous operations, see [iface@Gio.AsyncResult]
// and [class@Gio.Task]. To unmount a `GMount` instance, first call
// [method@Gio.Mount.unmount_with_operation] with (at least) the `GMount`
// instance and a [type@Gio.AsyncReadyCallback].  The callback will be fired
// when the operation has resolved (either with success or failure), and a
// [iface@Gio.AsyncResult] structure will be passed to the callback.  That
// callback should then call [method@Gio.Mount.unmount_with_operation_finish]
// with the `GMount` and the [iface@Gio.AsyncResult] data to see if the
// operation was completed successfully.  If an `error` is present when
// [method@Gio.Mount.unmount_with_operation_finish] is called, then it will be
// filled with any error information.
// 
// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html), `GMount` is the
// moral equivalent of `GnomeVFSVolume`.
type Mount interface {
	upcastToGMount() *MountInstance

	// CanEject wraps g_mount_can_eject
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @mount can be ejected.
	CanEject() bool
	// CanUnmount wraps g_mount_can_unmount
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @mount can be unmounted.
	CanUnmount() bool
	// Eject wraps g_mount_eject
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Ejects a mount. This is an asynchronous operation, and is
	// finished by calling g_mount_eject_finish() with the @mount
	// and #GAsyncResult data returned in the @callback.
	//
	// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_mount_eject_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a mount. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	//
	// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_mount_eject_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Ejects a mount. This is an asynchronous operation, and is
	// finished by calling g_mount_eject_with_operation_finish() with the @mount
	// and #GAsyncResult data returned in the @callback.
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_mount_eject_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a mount. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// GetDefaultLocation wraps g_mount_get_default_location
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets the default location of @mount. The default location of the given
	// @mount is a path that reflects the main entry point for the user (e.g.
	// the home directory, or the root of the volume).
	GetDefaultLocation() File
	// GetDrive wraps g_mount_get_drive
	// 
	// The function returns the following values:
	// 
	// 	- goret Drive (nullable) 
	//
	// Gets the drive for the @mount.
	// 
	// This is a convenience method for getting the #GVolume and then
	// using that object to get the #GDrive.
	GetDrive() Drive
	// GetIcon wraps g_mount_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the icon for @mount.
	GetIcon() Icon
	// GetName wraps g_mount_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name of @mount.
	GetName() string
	// GetRoot wraps g_mount_get_root
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets the root directory on @mount.
	GetRoot() File
	// GetSortKey wraps g_mount_get_sort_key
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the sort key for @mount, if any.
	GetSortKey() string
	// GetSymbolicIcon wraps g_mount_get_symbolic_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the symbolic icon for @mount.
	GetSymbolicIcon() Icon
	// GetUuid wraps g_mount_get_uuid
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the UUID for the @mount. The reference is typically based on
	// the file system UUID for the mount in question and should be
	// considered an opaque string. Returns %NULL if there is no UUID
	// available.
	GetUuid() string
	// GetVolume wraps g_mount_get_volume
	// 
	// The function returns the following values:
	// 
	// 	- goret Volume (nullable) 
	//
	// Gets the volume for the @mount.
	GetVolume() Volume
	// GuessContentType wraps g_mount_guess_content_type
	// 
	// The function takes the following parameters:
	// 
	// 	- forceRescan bool: Whether to force a rescan of the content.
	//     Otherwise a cached result will be used if available 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// Tries to guess the type of content stored on @mount. Returns one or
	// more textual identifiers of well-known content types (typically
	// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
	// memory cards. See the
	// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	// specification for more on x-content types.
	// 
	// This is an asynchronous operation (see
	// g_mount_guess_content_type_sync() for the synchronous version), and
	// is finished by calling g_mount_guess_content_type_finish() with the
	// @mount and #GAsyncResult data returned in the @callback.
	GuessContentType(bool, Cancellable, AsyncReadyCallback)
	// GuessContentTypeFinish wraps g_mount_guess_content_type_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes guessing content types of @mount. If any errors occurred
	// during the operation, @error will be set to contain the errors and
	// %FALSE will be returned. In particular, you may get an
	// %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
	// guessing.
	GuessContentTypeFinish(AsyncResult) ([]string, error)
	// GuessContentTypeSync wraps g_mount_guess_content_type_sync
	// 
	// The function takes the following parameters:
	// 
	// 	- forceRescan bool: Whether to force a rescan of the content.
	//     Otherwise a cached result will be used if available 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to guess the type of content stored on @mount. Returns one or
	// more textual identifiers of well-known content types (typically
	// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
	// memory cards. See the
	// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
	// specification for more on x-content types.
	// 
	// This is a synchronous operation and as such may block doing IO;
	// see g_mount_guess_content_type() for the asynchronous version.
	GuessContentTypeSync(bool, Cancellable) ([]string, error)
	// IsShadowed wraps g_mount_is_shadowed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Determines if @mount is shadowed. Applications or libraries should
	// avoid displaying @mount in the user interface if it is shadowed.
	// 
	// A mount is said to be shadowed if there exists one or more user
	// visible objects (currently #GMount objects) with a root that is
	// inside the root of @mount.
	// 
	// One application of shadow mounts is when exposing a single file
	// system that is used to address several logical volumes. In this
	// situation, a #GVolumeMonitor implementation would create two
	// #GVolume objects (for example, one for the camera functionality of
	// the device and one for a SD card reader on the device) with
	// activation URIs `gphoto2://[usb:001,002]/store1/`
	// and `gphoto2://[usb:001,002]/store2/`. When the
	// underlying mount (with root
	// `gphoto2://[usb:001,002]/`) is mounted, said
	// #GVolumeMonitor implementation would create two #GMount objects
	// (each with their root matching the corresponding volume activation
	// root) that would shadow the original mount.
	// 
	// The proxy monitor in GVfs 2.26 and later, automatically creates and
	// manage shadow mounts (and shadows the underlying mount) if the
	// activation root on a #GVolume is set.
	IsShadowed() bool
	// Remount wraps g_mount_remount
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountMountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Remounts a mount. This is an asynchronous operation, and is
	// finished by calling g_mount_remount_finish() with the @mount
	// and #GAsyncResults data returned in the @callback.
	// 
	// Remounting is useful when some setting affecting the operation
	// of the volume has been changed, as these may need a remount to
	// take affect. While this is semantically equivalent with unmounting
	// and then remounting not all backends might need to actually be
	// unmounted.
	Remount(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// RemountFinish wraps g_mount_remount_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes remounting a mount. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	RemountFinish(AsyncResult) (bool, error)
	// Shadow wraps g_mount_shadow
	//
	// Increments the shadow count on @mount. Usually used by
	// #GVolumeMonitor implementations when creating a shadow mount for
	// @mount, see g_mount_is_shadowed() for more information. The caller
	// will need to emit the #GMount::changed signal on @mount manually.
	Shadow()
	// Unmount wraps g_mount_unmount
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Unmounts a mount. This is an asynchronous operation, and is
	// finished by calling g_mount_unmount_finish() with the @mount
	// and #GAsyncResult data returned in the @callback.
	//
	// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation() instead.
	Unmount(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// UnmountFinish wraps g_mount_unmount_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes unmounting a mount. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	//
	// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation_finish() instead.
	UnmountFinish(AsyncResult) (bool, error)
	// UnmountWithOperation wraps g_mount_unmount_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
	//     user interaction. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
	//
	// Unmounts a mount. This is an asynchronous operation, and is
	// finished by calling g_mount_unmount_with_operation_finish() with the @mount
	// and #GAsyncResult data returned in the @callback.
	UnmountWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// UnmountWithOperationFinish wraps g_mount_unmount_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes unmounting a mount. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	UnmountWithOperationFinish(AsyncResult) (bool, error)
	// Unshadow wraps g_mount_unshadow
	//
	// Decrements the shadow count on @mount. Usually used by
	// #GVolumeMonitor implementations when destroying a shadow mount for
	// @mount, see g_mount_is_shadowed() for more information. The caller
	// will need to emit the #GMount::changed signal on @mount manually.
	Unshadow()
	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Emitted when the mount has been changed.
	ConnectChanged(func(Mount)) gobject.SignalHandle
	// ConnectPreUnmount connects the provided callback to the "pre-unmount" signal
	//
	// This signal may be emitted when the #GMount is about to be
	// unmounted.
	// 
	// This signal depends on the backend and is only emitted if
	// GIO was used to unmount.
	ConnectPreUnmount(func(Mount)) gobject.SignalHandle
	// ConnectUnmounted connects the provided callback to the "unmounted" signal
	//
	// This signal is emitted when the #GMount have been
	// unmounted. If the recipient is holding references to the
	// object they should release them so the object can be
	// finalized.
	ConnectUnmounted(func(Mount)) gobject.SignalHandle
}

var _ Mount = (*MountInstance)(nil)

func unsafeWrapMount(base *gobject.ObjectInstance) *MountInstance {
	return &MountInstance{
		Instance: *base,
	}
}

func marshalMountInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (m *MountInstance) upcastToGMount() *MountInstance {
	return m
}

// UnsafeMountFromGlibNone is used to convert raw GMount pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMountFromGlibNone(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibNone(c).(Mount)
}

// UnsafeMountFromGlibFull is used to convert raw GMount pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMountFromGlibFull(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibFull(c).(Mount)
}

// UnsafeMountFromGlibBorrow is used to convert raw GMount pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMountFromGlibBorrow(c unsafe.Pointer) Mount {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Mount)
}

// UnsafeMountToGlibNone is used to convert the instance to it's C value GMount. This is used by the bindings internally.
func UnsafeMountToGlibNone(c Mount) unsafe.Pointer {
	i := c.upcastToGMount()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeMountToGlibFull is used to convert the instance to it's C value GMount, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMountToGlibFull(c Mount) unsafe.Pointer {
	i := c.upcastToGMount()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_mount_can_eject
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @mount can be ejected.
func (mount *MountInstance) CanEject() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_can_eject(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanUnmount wraps g_mount_can_unmount
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @mount can be unmounted.
func (mount *MountInstance) CanUnmount() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_can_unmount(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_mount_eject
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
//
// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation() instead.
func (mount *MountInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_mount_eject_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
//
// Deprecated: (since 2.22.0) Use g_mount_eject_with_operation_finish() instead.
func (mount *MountInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_mount_eject_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Ejects a mount. This is an asynchronous operation, and is
// finished by calling g_mount_eject_with_operation_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (mount *MountInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_mount_eject_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (mount *MountInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDefaultLocation wraps g_mount_get_default_location
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets the default location of @mount. The default location of the given
// @mount is a path that reflects the main entry point for the user (e.g.
// the home directory, or the root of the volume).
func (mount *MountInstance) GetDefaultLocation() File {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GFile  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_default_location(carg0)
	runtime.KeepAlive(mount)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDrive wraps g_mount_get_drive
// 
// The function returns the following values:
// 
// 	- goret Drive (nullable) 
//
// Gets the drive for the @mount.
// 
// This is a convenience method for getting the #GVolume and then
// using that object to get the #GDrive.
func (mount *MountInstance) GetDrive() Drive {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GDrive // return, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_drive(carg0)
	runtime.KeepAlive(mount)

	var goret Drive

	if cret != nil {
		goret = UnsafeDriveFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetIcon wraps g_mount_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the icon for @mount.
func (mount *MountInstance) GetIcon() Icon {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_icon(carg0)
	runtime.KeepAlive(mount)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetName wraps g_mount_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of @mount.
func (mount *MountInstance) GetName() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.char   // return, full, string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_name(carg0)
	runtime.KeepAlive(mount)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetRoot wraps g_mount_get_root
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets the root directory on @mount.
func (mount *MountInstance) GetRoot() File {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GFile  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_root(carg0)
	runtime.KeepAlive(mount)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_mount_get_sort_key
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the sort key for @mount, if any.
func (mount *MountInstance) GetSortKey() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.gchar  // return, none, string, nullable-string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_sort_key(carg0)
	runtime.KeepAlive(mount)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetSymbolicIcon wraps g_mount_get_symbolic_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the symbolic icon for @mount.
func (mount *MountInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_symbolic_icon(carg0)
	runtime.KeepAlive(mount)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetUuid wraps g_mount_get_uuid
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the UUID for the @mount. The reference is typically based on
// the file system UUID for the mount in question and should be
// considered an opaque string. Returns %NULL if there is no UUID
// available.
func (mount *MountInstance) GetUuid() string {
	var carg0 *C.GMount // in, none, converted
	var cret  *C.char   // return, full, string, nullable-string

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_uuid(carg0)
	runtime.KeepAlive(mount)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetVolume wraps g_mount_get_volume
// 
// The function returns the following values:
// 
// 	- goret Volume (nullable) 
//
// Gets the volume for the @mount.
func (mount *MountInstance) GetVolume() Volume {
	var carg0 *C.GMount  // in, none, converted
	var cret  *C.GVolume // return, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_get_volume(carg0)
	runtime.KeepAlive(mount)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GuessContentType wraps g_mount_guess_content_type
// 
// The function takes the following parameters:
// 
// 	- forceRescan bool: Whether to force a rescan of the content.
//     Otherwise a cached result will be used if available 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// Tries to guess the type of content stored on @mount. Returns one or
// more textual identifiers of well-known content types (typically
// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
// memory cards. See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
// 
// This is an asynchronous operation (see
// g_mount_guess_content_type_sync() for the synchronous version), and
// is finished by calling g_mount_guess_content_type_finish() with the
// @mount and #GAsyncResult data returned in the @callback.
func (mount *MountInstance) GuessContentType(forceRescan bool, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.gboolean            // in
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	if forceRescan {
		carg1 = C.TRUE
	}
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_guess_content_type(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// GuessContentTypeFinish wraps g_mount_guess_content_type_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Finishes guessing content types of @mount. If any errors occurred
// during the operation, @error will be set to contain the errors and
// %FALSE will be returned. In particular, you may get an
// %G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
// guessing.
func (mount *MountInstance) GuessContentTypeFinish(result AsyncResult) ([]string, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_guess_content_type_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GuessContentTypeSync wraps g_mount_guess_content_type_sync
// 
// The function takes the following parameters:
// 
// 	- forceRescan bool: Whether to force a rescan of the content.
//     Otherwise a cached result will be used if available 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Tries to guess the type of content stored on @mount. Returns one or
// more textual identifiers of well-known content types (typically
// prefixed with "x-content/"), e.g. x-content/image-dcf for camera
// memory cards. See the
// [shared-mime-info](http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
// 
// This is a synchronous operation and as such may block doing IO;
// see g_mount_guess_content_type() for the asynchronous version.
func (mount *MountInstance) GuessContentTypeSync(forceRescan bool, cancellable Cancellable) ([]string, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 C.gboolean      // in
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  **C.gchar       // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	if forceRescan {
		carg1 = C.TRUE
	}
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_mount_guess_content_type_sync(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(forceRescan)
	runtime.KeepAlive(cancellable)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IsShadowed wraps g_mount_is_shadowed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if @mount is shadowed. Applications or libraries should
// avoid displaying @mount in the user interface if it is shadowed.
// 
// A mount is said to be shadowed if there exists one or more user
// visible objects (currently #GMount objects) with a root that is
// inside the root of @mount.
// 
// One application of shadow mounts is when exposing a single file
// system that is used to address several logical volumes. In this
// situation, a #GVolumeMonitor implementation would create two
// #GVolume objects (for example, one for the camera functionality of
// the device and one for a SD card reader on the device) with
// activation URIs `gphoto2://[usb:001,002]/store1/`
// and `gphoto2://[usb:001,002]/store2/`. When the
// underlying mount (with root
// `gphoto2://[usb:001,002]/`) is mounted, said
// #GVolumeMonitor implementation would create two #GMount objects
// (each with their root matching the corresponding volume activation
// root) that would shadow the original mount.
// 
// The proxy monitor in GVfs 2.26 and later, automatically creates and
// manage shadow mounts (and shadows the underlying mount) if the
// activation root on a #GVolume is set.
func (mount *MountInstance) IsShadowed() bool {
	var carg0 *C.GMount  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_mount_is_shadowed(carg0)
	runtime.KeepAlive(mount)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Remount wraps g_mount_remount
// 
// The function takes the following parameters:
// 
// 	- flags MountMountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Remounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_remount_finish() with the @mount
// and #GAsyncResults data returned in the @callback.
// 
// Remounting is useful when some setting affecting the operation
// of the volume has been changed, as these may need a remount to
// take affect. While this is semantically equivalent with unmounting
// and then remounting not all backends might need to actually be
// unmounted.
func (mount *MountInstance) Remount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_remount(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// RemountFinish wraps g_mount_remount_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes remounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (mount *MountInstance) RemountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_remount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Shadow wraps g_mount_shadow
//
// Increments the shadow count on @mount. Usually used by
// #GVolumeMonitor implementations when creating a shadow mount for
// @mount, see g_mount_is_shadowed() for more information. The caller
// will need to emit the #GMount::changed signal on @mount manually.
func (mount *MountInstance) Shadow() {
	var carg0 *C.GMount // in, none, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C.g_mount_shadow(carg0)
	runtime.KeepAlive(mount)
}

// Unmount wraps g_mount_unmount
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Unmounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_unmount_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
//
// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation() instead.
func (mount *MountInstance) Unmount(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_unmount(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountFinish wraps g_mount_unmount_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes unmounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
//
// Deprecated: (since 2.22.0) Use g_mount_unmount_with_operation_finish() instead.
func (mount *MountInstance) UnmountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_unmount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UnmountWithOperation wraps g_mount_unmount_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid
//     user interaction. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL. 
//
// Unmounts a mount. This is an asynchronous operation, and is
// finished by calling g_mount_unmount_with_operation_finish() with the @mount
// and #GAsyncResult data returned in the @callback.
func (mount *MountInstance) UnmountWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GMount             // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_mount_unmount_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// UnmountWithOperationFinish wraps g_mount_unmount_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes unmounting a mount. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (mount *MountInstance) UnmountWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GMount       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_mount_unmount_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(mount)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Unshadow wraps g_mount_unshadow
//
// Decrements the shadow count on @mount. Usually used by
// #GVolumeMonitor implementations when destroying a shadow mount for
// @mount, see g_mount_is_shadowed() for more information. The caller
// will need to emit the #GMount::changed signal on @mount manually.
func (mount *MountInstance) Unshadow() {
	var carg0 *C.GMount // in, none, converted

	carg0 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C.g_mount_unshadow(carg0)
	runtime.KeepAlive(mount)
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Emitted when the mount has been changed.
func (o *MountInstance) ConnectChanged(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectPreUnmount connects the provided callback to the "pre-unmount" signal
//
// This signal may be emitted when the #GMount is about to be
// unmounted.
// 
// This signal depends on the backend and is only emitted if
// GIO was used to unmount.
func (o *MountInstance) ConnectPreUnmount(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("pre-unmount", fn)
}

// ConnectUnmounted connects the provided callback to the "unmounted" signal
//
// This signal is emitted when the #GMount have been
// unmounted. If the recipient is holding references to the
// object they should release them so the object can be
// finalized.
func (o *MountInstance) ConnectUnmounted(fn func(Mount)) gobject.SignalHandle {
	return o.Instance.Connect("unmounted", fn)
}

// NetworkMonitorInstance is the instance type used by all types implementing GNetworkMonitor. It is used internally by the bindings. Users should use the interface [NetworkMonitor] instead.
type NetworkMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ NetworkMonitor = (*NetworkMonitorInstance)(nil)

// NetworkMonitor wraps GNetworkMonitor
//
// `GNetworkMonitor` provides an easy-to-use cross-platform API
// for monitoring network connectivity. On Linux, the available
// implementations are based on the kernel's netlink interface and
// on NetworkManager.
// 
// There is also an implementation for use inside Flatpak sandboxes.
type NetworkMonitor interface {
	upcastToGNetworkMonitor() *NetworkMonitorInstance

	// CanReach wraps g_network_monitor_can_reach
	// 
	// The function takes the following parameters:
	// 
	// 	- connectable SocketConnectable: a #GSocketConnectable 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to determine whether or not the host pointed to by
	// @connectable can be reached, without actually trying to connect to
	// it.
	// 
	// This may return %TRUE even when #GNetworkMonitor:network-available
	// is %FALSE, if, for example, @monitor can determine that
	// @connectable refers to a host on a local network.
	// 
	// If @monitor believes that an attempt to connect to @connectable
	// will succeed, it will return %TRUE. Otherwise, it will return
	// %FALSE and set @error to an appropriate error (such as
	// %G_IO_ERROR_HOST_UNREACHABLE).
	// 
	// Note that although this does not attempt to connect to
	// @connectable, it may still block for a brief period of time (eg,
	// trying to do multicast DNS on the local network), so if you do not
	// want to block, you should use g_network_monitor_can_reach_async().
	CanReach(SocketConnectable, Cancellable) (bool, error)
	// CanReachAsync wraps g_network_monitor_can_reach_async
	// 
	// The function takes the following parameters:
	// 
	// 	- connectable SocketConnectable: a #GSocketConnectable 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//     to call when the request is satisfied 
	//
	// Asynchronously attempts to determine whether or not the host
	// pointed to by @connectable can be reached, without actually
	// trying to connect to it.
	// 
	// For more details, see g_network_monitor_can_reach().
	// 
	// When the operation is finished, @callback will be called.
	// You can then call g_network_monitor_can_reach_finish()
	// to get the result of the operation.
	CanReachAsync(SocketConnectable, Cancellable, AsyncReadyCallback)
	// CanReachFinish wraps g_network_monitor_can_reach_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async network connectivity test.
	// See g_network_monitor_can_reach_async().
	CanReachFinish(AsyncResult) (bool, error)
	// GetConnectivity wraps g_network_monitor_get_connectivity
	// 
	// The function returns the following values:
	// 
	// 	- goret NetworkConnectivity 
	//
	// Gets a more detailed networking state than
	// g_network_monitor_get_network_available().
	// 
	// If #GNetworkMonitor:network-available is %FALSE, then the
	// connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
	// 
	// If #GNetworkMonitor:network-available is %TRUE, then the
	// connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
	// is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
	// the host has a default route, but appears to be unable to actually
	// reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
	// host is trapped behind a "captive portal" that requires some sort
	// of login or acknowledgement before allowing full Internet access).
	// 
	// Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
	// %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
	// reachable but others are not. In this case, applications can
	// attempt to connect to remote servers, but should gracefully fall
	// back to their "offline" behavior if the connection attempt fails.
	GetConnectivity() NetworkConnectivity
	// GetNetworkAvailable wraps g_network_monitor_get_network_available
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the network is available. "Available" here means that the
	// system has a default route available for at least one of IPv4 or
	// IPv6. It does not necessarily imply that the public Internet is
	// reachable. See #GNetworkMonitor:network-available for more details.
	GetNetworkAvailable() bool
	// GetNetworkMetered wraps g_network_monitor_get_network_metered
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the network is metered.
	// See #GNetworkMonitor:network-metered for more details.
	GetNetworkMetered() bool
	// ConnectNetworkChanged connects the provided callback to the "network-changed" signal
	//
	// Emitted when the network configuration changes.
	ConnectNetworkChanged(func(NetworkMonitor, bool)) gobject.SignalHandle
}

var _ NetworkMonitor = (*NetworkMonitorInstance)(nil)

func unsafeWrapNetworkMonitor(base *gobject.ObjectInstance) *NetworkMonitorInstance {
	return &NetworkMonitorInstance{
		Instance: *base,
	}
}

func marshalNetworkMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (n *NetworkMonitorInstance) upcastToGNetworkMonitor() *NetworkMonitorInstance {
	return n
}

// UnsafeNetworkMonitorFromGlibNone is used to convert raw GNetworkMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibNone(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorFromGlibFull is used to convert raw GNetworkMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibFull(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorFromGlibBorrow is used to convert raw GNetworkMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkMonitorFromGlibBorrow(c unsafe.Pointer) NetworkMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkMonitor)
}

// UnsafeNetworkMonitorToGlibNone is used to convert the instance to it's C value GNetworkMonitor. This is used by the bindings internally.
func UnsafeNetworkMonitorToGlibNone(c NetworkMonitor) unsafe.Pointer {
	i := c.upcastToGNetworkMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeNetworkMonitorToGlibFull is used to convert the instance to it's C value GNetworkMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkMonitorToGlibFull(c NetworkMonitor) unsafe.Pointer {
	i := c.upcastToGNetworkMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NetworkMonitorGetDefault wraps g_network_monitor_get_default
// 
// The function returns the following values:
// 
// 	- goret NetworkMonitor 
//
// Gets the default #GNetworkMonitor for the system.
func NetworkMonitorGetDefault() NetworkMonitor {
	var cret *C.GNetworkMonitor // return, none, converted

	cret = C.g_network_monitor_get_default()

	var goret NetworkMonitor

	goret = UnsafeNetworkMonitorFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// CanReach wraps g_network_monitor_can_reach
// 
// The function takes the following parameters:
// 
// 	- connectable SocketConnectable: a #GSocketConnectable 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts to determine whether or not the host pointed to by
// @connectable can be reached, without actually trying to connect to
// it.
// 
// This may return %TRUE even when #GNetworkMonitor:network-available
// is %FALSE, if, for example, @monitor can determine that
// @connectable refers to a host on a local network.
// 
// If @monitor believes that an attempt to connect to @connectable
// will succeed, it will return %TRUE. Otherwise, it will return
// %FALSE and set @error to an appropriate error (such as
// %G_IO_ERROR_HOST_UNREACHABLE).
// 
// Note that although this does not attempt to connect to
// @connectable, it may still block for a brief period of time (eg,
// trying to do multicast DNS on the local network), so if you do not
// want to block, you should use g_network_monitor_can_reach_async().
func (monitor *NetworkMonitorInstance) CanReach(connectable SocketConnectable, cancellable Cancellable) (bool, error) {
	var carg0 *C.GNetworkMonitor    // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_network_monitor_can_reach(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CanReachAsync wraps g_network_monitor_can_reach_async
// 
// The function takes the following parameters:
// 
// 	- connectable SocketConnectable: a #GSocketConnectable 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//     to call when the request is satisfied 
//
// Asynchronously attempts to determine whether or not the host
// pointed to by @connectable can be reached, without actually
// trying to connect to it.
// 
// For more details, see g_network_monitor_can_reach().
// 
// When the operation is finished, @callback will be called.
// You can then call g_network_monitor_can_reach_finish()
// to get the result of the operation.
func (monitor *NetworkMonitorInstance) CanReachAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GNetworkMonitor    // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_network_monitor_can_reach_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CanReachFinish wraps g_network_monitor_can_reach_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an async network connectivity test.
// See g_network_monitor_can_reach_async().
func (monitor *NetworkMonitorInstance) CanReachFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_network_monitor_can_reach_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetConnectivity wraps g_network_monitor_get_connectivity
// 
// The function returns the following values:
// 
// 	- goret NetworkConnectivity 
//
// Gets a more detailed networking state than
// g_network_monitor_get_network_available().
// 
// If #GNetworkMonitor:network-available is %FALSE, then the
// connectivity state will be %G_NETWORK_CONNECTIVITY_LOCAL.
// 
// If #GNetworkMonitor:network-available is %TRUE, then the
// connectivity state will be %G_NETWORK_CONNECTIVITY_FULL (if there
// is full Internet connectivity), %G_NETWORK_CONNECTIVITY_LIMITED (if
// the host has a default route, but appears to be unable to actually
// reach the full Internet), or %G_NETWORK_CONNECTIVITY_PORTAL (if the
// host is trapped behind a "captive portal" that requires some sort
// of login or acknowledgement before allowing full Internet access).
// 
// Note that in the case of %G_NETWORK_CONNECTIVITY_LIMITED and
// %G_NETWORK_CONNECTIVITY_PORTAL, it is possible that some sites are
// reachable but others are not. In this case, applications can
// attempt to connect to remote servers, but should gracefully fall
// back to their "offline" behavior if the connection attempt fails.
func (monitor *NetworkMonitorInstance) GetConnectivity() NetworkConnectivity {
	var carg0 *C.GNetworkMonitor     // in, none, converted
	var cret  C.GNetworkConnectivity // return, none, casted

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_connectivity(carg0)
	runtime.KeepAlive(monitor)

	var goret NetworkConnectivity

	goret = NetworkConnectivity(cret)

	return goret
}

// GetNetworkAvailable wraps g_network_monitor_get_network_available
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the network is available. "Available" here means that the
// system has a default route available for at least one of IPv4 or
// IPv6. It does not necessarily imply that the public Internet is
// reachable. See #GNetworkMonitor:network-available for more details.
func (monitor *NetworkMonitorInstance) GetNetworkAvailable() bool {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_network_available(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNetworkMetered wraps g_network_monitor_get_network_metered
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the network is metered.
// See #GNetworkMonitor:network-metered for more details.
func (monitor *NetworkMonitorInstance) GetNetworkMetered() bool {
	var carg0 *C.GNetworkMonitor // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GNetworkMonitor)(UnsafeNetworkMonitorToGlibNone(monitor))

	cret = C.g_network_monitor_get_network_metered(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectNetworkChanged connects the provided callback to the "network-changed" signal
//
// Emitted when the network configuration changes.
func (o *NetworkMonitorInstance) ConnectNetworkChanged(fn func(NetworkMonitor, bool)) gobject.SignalHandle {
	return o.Instance.Connect("network-changed", fn)
}

// PollableInputStreamInstance is the instance type used by all types implementing GPollableInputStream. It is used internally by the bindings. Users should use the interface [PollableInputStream] instead.
type PollableInputStreamInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PollableInputStream = (*PollableInputStreamInstance)(nil)

// PollableInputStream wraps GPollableInputStream
//
// `GPollableInputStream` is implemented by [class@Gio.InputStream]s that
// can be polled for readiness to read. This can be used when
// interfacing with a non-GIO API that expects
// UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
// 
// Some classes may implement `GPollableInputStream` but have only certain
// instances of that class be pollable. If [method@Gio.PollableInputStream.can_poll]
// returns false, then the behavior of other `GPollableInputStream` methods is
// undefined.
type PollableInputStream interface {
	upcastToGPollableInputStream() *PollableInputStreamInstance

	// CanPoll wraps g_pollable_input_stream_can_poll
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @stream is actually pollable. Some classes may implement
	// #GPollableInputStream but have only certain instances of that class
	// be pollable. If this method returns %FALSE, then the behavior of
	// other #GPollableInputStream methods is undefined.
	// 
	// For any given stream, the value returned by this method is constant;
	// a stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsReadable wraps g_pollable_input_stream_is_readable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @stream can be read.
	// 
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_input_stream_read()
	// after this returns %TRUE would still block. To guarantee
	// non-blocking behavior, you should always use
	// g_pollable_input_stream_read_nonblocking(), which will return a
	// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	// 
	// The behaviour of this method is undefined if
	// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
	IsReadable() bool
}

var _ PollableInputStream = (*PollableInputStreamInstance)(nil)

func unsafeWrapPollableInputStream(base *gobject.ObjectInstance) *PollableInputStreamInstance {
	return &PollableInputStreamInstance{
		Instance: *base,
	}
}

func marshalPollableInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PollableInputStreamInstance) upcastToGPollableInputStream() *PollableInputStreamInstance {
	return p
}

// UnsafePollableInputStreamFromGlibNone is used to convert raw GPollableInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibNone(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(PollableInputStream)
}

// UnsafePollableInputStreamFromGlibFull is used to convert raw GPollableInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibFull(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(PollableInputStream)
}

// UnsafePollableInputStreamFromGlibBorrow is used to convert raw GPollableInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafePollableInputStreamFromGlibBorrow(c unsafe.Pointer) PollableInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PollableInputStream)
}

// UnsafePollableInputStreamToGlibNone is used to convert the instance to it's C value GPollableInputStream. This is used by the bindings internally.
func UnsafePollableInputStreamToGlibNone(c PollableInputStream) unsafe.Pointer {
	i := c.upcastToGPollableInputStream()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePollableInputStreamToGlibFull is used to convert the instance to it's C value GPollableInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafePollableInputStreamToGlibFull(c PollableInputStream) unsafe.Pointer {
	i := c.upcastToGPollableInputStream()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanPoll wraps g_pollable_input_stream_can_poll
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @stream is actually pollable. Some classes may implement
// #GPollableInputStream but have only certain instances of that class
// be pollable. If this method returns %FALSE, then the behavior of
// other #GPollableInputStream methods is undefined.
// 
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (stream *PollableInputStreamInstance) CanPoll() bool {
	var carg0 *C.GPollableInputStream // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPollableInputStream)(UnsafePollableInputStreamToGlibNone(stream))

	cret = C.g_pollable_input_stream_can_poll(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsReadable wraps g_pollable_input_stream_is_readable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @stream can be read.
// 
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_input_stream_read()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_input_stream_read_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
// 
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (stream *PollableInputStreamInstance) IsReadable() bool {
	var carg0 *C.GPollableInputStream // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPollableInputStream)(UnsafePollableInputStreamToGlibNone(stream))

	cret = C.g_pollable_input_stream_is_readable(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollableOutputStreamInstance is the instance type used by all types implementing GPollableOutputStream. It is used internally by the bindings. Users should use the interface [PollableOutputStream] instead.
type PollableOutputStreamInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PollableOutputStream = (*PollableOutputStreamInstance)(nil)

// PollableOutputStream wraps GPollableOutputStream
//
// `GPollableOutputStream` is implemented by [class@Gio.OutputStream]s that
// can be polled for readiness to write. This can be used when
// interfacing with a non-GIO API that expects
// UNIX-file-descriptor-style asynchronous I/O rather than GIO-style.
// 
// Some classes may implement `GPollableOutputStream` but have only certain
// instances of that class be pollable. If [method@Gio.PollableOutputStream.can_poll]
// returns false, then the behavior of other `GPollableOutputStream` methods is
// undefined.
type PollableOutputStream interface {
	upcastToGPollableOutputStream() *PollableOutputStreamInstance

	// CanPoll wraps g_pollable_output_stream_can_poll
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @stream is actually pollable. Some classes may implement
	// #GPollableOutputStream but have only certain instances of that
	// class be pollable. If this method returns %FALSE, then the behavior
	// of other #GPollableOutputStream methods is undefined.
	// 
	// For any given stream, the value returned by this method is constant;
	// a stream cannot switch from pollable to non-pollable or vice versa.
	CanPoll() bool
	// IsWritable wraps g_pollable_output_stream_is_writable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @stream can be written.
	// 
	// Note that some stream types may not be able to implement this 100%
	// reliably, and it is possible that a call to g_output_stream_write()
	// after this returns %TRUE would still block. To guarantee
	// non-blocking behavior, you should always use
	// g_pollable_output_stream_write_nonblocking(), which will return a
	// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
	// 
	// The behaviour of this method is undefined if
	// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
	IsWritable() bool
	// WriteNonblocking wraps g_pollable_output_stream_write_nonblocking
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: a buffer to write
	//     data from 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to write up to @count bytes from @buffer to @stream, as
	// with g_output_stream_write(). If @stream is not currently writable,
	// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
	// use g_pollable_output_stream_create_source() to create a #GSource
	// that will be triggered when @stream is writable.
	// 
	// Note that since this method never blocks, you cannot actually
	// use @cancellable to cancel it. However, it will return an error
	// if @cancellable has already been cancelled when you call, which
	// may happen if you call this method after a source triggers due
	// to having been cancelled.
	// 
	// Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
	// transports like D/TLS require that you re-send the same @buffer and
	// @count in the next write call.
	// 
	// The behaviour of this method is undefined if
	// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
	WriteNonblocking([]byte, Cancellable) (int, error)
	// WritevNonblocking wraps g_pollable_output_stream_writev_nonblocking
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were
	//     written to the stream 
	// 	- goret PollableReturn 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to write the bytes contained in the @n_vectors @vectors to @stream,
	// as with g_output_stream_writev(). If @stream is not currently writable,
	// this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
	// use g_pollable_output_stream_create_source() to create a #GSource
	// that will be triggered when @stream is writable. @error will *not* be
	// set in that case.
	// 
	// Note that since this method never blocks, you cannot actually
	// use @cancellable to cancel it. However, it will return an error
	// if @cancellable has already been cancelled when you call, which
	// may happen if you call this method after a source triggers due
	// to having been cancelled.
	// 
	// Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
	// transports like D/TLS require that you re-send the same @vectors and
	// @n_vectors in the next write call.
	// 
	// The behaviour of this method is undefined if
	// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
	WritevNonblocking([]OutputVector, Cancellable) (uint, PollableReturn, error)
}

var _ PollableOutputStream = (*PollableOutputStreamInstance)(nil)

func unsafeWrapPollableOutputStream(base *gobject.ObjectInstance) *PollableOutputStreamInstance {
	return &PollableOutputStreamInstance{
		Instance: *base,
	}
}

func marshalPollableOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PollableOutputStreamInstance) upcastToGPollableOutputStream() *PollableOutputStreamInstance {
	return p
}

// UnsafePollableOutputStreamFromGlibNone is used to convert raw GPollableOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibNone(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamFromGlibFull is used to convert raw GPollableOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibFull(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamFromGlibBorrow is used to convert raw GPollableOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafePollableOutputStreamFromGlibBorrow(c unsafe.Pointer) PollableOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PollableOutputStream)
}

// UnsafePollableOutputStreamToGlibNone is used to convert the instance to it's C value GPollableOutputStream. This is used by the bindings internally.
func UnsafePollableOutputStreamToGlibNone(c PollableOutputStream) unsafe.Pointer {
	i := c.upcastToGPollableOutputStream()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePollableOutputStreamToGlibFull is used to convert the instance to it's C value GPollableOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafePollableOutputStreamToGlibFull(c PollableOutputStream) unsafe.Pointer {
	i := c.upcastToGPollableOutputStream()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanPoll wraps g_pollable_output_stream_can_poll
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @stream is actually pollable. Some classes may implement
// #GPollableOutputStream but have only certain instances of that
// class be pollable. If this method returns %FALSE, then the behavior
// of other #GPollableOutputStream methods is undefined.
// 
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (stream *PollableOutputStreamInstance) CanPoll() bool {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))

	cret = C.g_pollable_output_stream_can_poll(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsWritable wraps g_pollable_output_stream_is_writable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @stream can be written.
// 
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_output_stream_write()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_output_stream_write_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
// 
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (stream *PollableOutputStreamInstance) IsWritable() bool {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))

	cret = C.g_pollable_output_stream_is_writable(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// WriteNonblocking wraps g_pollable_output_stream_write_nonblocking
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: a buffer to write
//     data from 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Attempts to write up to @count bytes from @buffer to @stream, as
// with g_output_stream_write(). If @stream is not currently writable,
// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_output_stream_create_source() to create a #GSource
// that will be triggered when @stream is writable.
// 
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
// 
// Also note that if %G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @buffer and
// @count in the next write call.
// 
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (stream *PollableOutputStreamInstance) WriteNonblocking(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var carg1 unsafe.Pointer           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize                  // implicit
	var carg3 *C.GCancellable          // in, none, converted, nullable
	var cret  C.gssize                 // return, none, casted
	var _cerr *C.GError                // out, full, converted, nullable

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_output_stream_write_nonblocking(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WritevNonblocking wraps g_pollable_output_stream_writev_nonblocking
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were
//     written to the stream 
// 	- goret PollableReturn 
// 	- _goerr error (nullable): an error 
//
// Attempts to write the bytes contained in the @n_vectors @vectors to @stream,
// as with g_output_stream_writev(). If @stream is not currently writable,
// this will immediately return %@G_POLLABLE_RETURN_WOULD_BLOCK, and you can
// use g_pollable_output_stream_create_source() to create a #GSource
// that will be triggered when @stream is writable. @error will *not* be
// set in that case.
// 
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
// 
// Also note that if %G_POLLABLE_RETURN_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same @vectors and
// @n_vectors in the next write call.
// 
// The behaviour of this method is undefined if
// g_pollable_output_stream_can_poll() returns %FALSE for @stream.
func (stream *PollableOutputStreamInstance) WritevNonblocking(vectors []OutputVector, cancellable Cancellable) (uint, PollableReturn, error) {
	var carg0 *C.GPollableOutputStream // in, none, converted
	var carg1 *C.GOutputVector         // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize                  // implicit
	var carg4 *C.GCancellable          // in, none, converted, nullable
	var carg3 C.gsize                  // out, full, casted
	var cret  C.GPollableReturn        // return, none, casted
	var _cerr *C.GError                // out, full, converted, nullable

	carg0 = (*C.GPollableOutputStream)(UnsafePollableOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_pollable_output_stream_writev_nonblocking(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        PollableReturn
	var _goerr       error

	bytesWritten = uint(carg3)
	goret = PollableReturn(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// PowerProfileMonitorInstance is the instance type used by all types implementing GPowerProfileMonitor. It is used internally by the bindings. Users should use the interface [PowerProfileMonitor] instead.
type PowerProfileMonitorInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ PowerProfileMonitor = (*PowerProfileMonitorInstance)(nil)

// PowerProfileMonitor wraps GPowerProfileMonitor
//
// `GPowerProfileMonitor` makes it possible for applications as well as OS
// components to monitor system power profiles and act upon them. It currently
// only exports whether the system is in &#x201C;Power Saver&#x201D; mode (known as
// &#x201C;Low Power&#x201D; mode on some systems).
// 
// When in &#x201C;Low Power&#x201D; mode, it is recommended that applications:
// 
// - disable automatic downloads;
// - reduce the rate of refresh from online sources such as calendar or
//   email synchronisation;
// - reduce the use of expensive visual effects.
// 
// It is also likely that OS components providing services to applications will
// lower their own background activity, for the sake of the system.
// 
// There are a variety of tools that exist for power consumption analysis, but those
// usually depend on the OS and hardware used. On Linux, one could use `upower` to
// monitor the battery discharge rate, `powertop` to check on the background activity
// or activity at all), `sysprof` to inspect CPU usage, and `intel_gpu_time` to
// profile GPU usage.
// 
// Don&#x2019;t forget to disconnect the [signal@GObject.Object::notify] signal for
// [property@Gio.PowerProfileMonitor:power-saver-enabled], and unref the
// `GPowerProfileMonitor` itself when exiting.
type PowerProfileMonitor interface {
	upcastToGPowerProfileMonitor() *PowerProfileMonitorInstance

	// GetPowerSaverEnabled wraps g_power_profile_monitor_get_power_saver_enabled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets whether the system is in &#x201C;Power Saver&#x201D; mode.
	// 
	// You are expected to listen to the
	// #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
	// changed.
	GetPowerSaverEnabled() bool
}

var _ PowerProfileMonitor = (*PowerProfileMonitorInstance)(nil)

func unsafeWrapPowerProfileMonitor(base *gobject.ObjectInstance) *PowerProfileMonitorInstance {
	return &PowerProfileMonitorInstance{
		Instance: *base,
	}
}

func marshalPowerProfileMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *PowerProfileMonitorInstance) upcastToGPowerProfileMonitor() *PowerProfileMonitorInstance {
	return p
}

// UnsafePowerProfileMonitorFromGlibNone is used to convert raw GPowerProfileMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibNone(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorFromGlibFull is used to convert raw GPowerProfileMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibFull(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorFromGlibBorrow is used to convert raw GPowerProfileMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafePowerProfileMonitorFromGlibBorrow(c unsafe.Pointer) PowerProfileMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PowerProfileMonitor)
}

// UnsafePowerProfileMonitorToGlibNone is used to convert the instance to it's C value GPowerProfileMonitor. This is used by the bindings internally.
func UnsafePowerProfileMonitorToGlibNone(c PowerProfileMonitor) unsafe.Pointer {
	i := c.upcastToGPowerProfileMonitor()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafePowerProfileMonitorToGlibFull is used to convert the instance to it's C value GPowerProfileMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafePowerProfileMonitorToGlibFull(c PowerProfileMonitor) unsafe.Pointer {
	i := c.upcastToGPowerProfileMonitor()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// PowerProfileMonitorDupDefault wraps g_power_profile_monitor_dup_default
// 
// The function returns the following values:
// 
// 	- goret PowerProfileMonitor 
//
// Gets a reference to the default #GPowerProfileMonitor for the system.
func PowerProfileMonitorDupDefault() PowerProfileMonitor {
	var cret *C.GPowerProfileMonitor // return, full, converted

	cret = C.g_power_profile_monitor_dup_default()

	var goret PowerProfileMonitor

	goret = UnsafePowerProfileMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetPowerSaverEnabled wraps g_power_profile_monitor_get_power_saver_enabled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets whether the system is in &#x201C;Power Saver&#x201D; mode.
// 
// You are expected to listen to the
// #GPowerProfileMonitor::notify::power-saver-enabled signal to know when the profile has
// changed.
func (monitor *PowerProfileMonitorInstance) GetPowerSaverEnabled() bool {
	var carg0 *C.GPowerProfileMonitor // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GPowerProfileMonitor)(UnsafePowerProfileMonitorToGlibNone(monitor))

	cret = C.g_power_profile_monitor_get_power_saver_enabled(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ProxyInstance is the instance type used by all types implementing GProxy. It is used internally by the bindings. Users should use the interface [Proxy] instead.
type ProxyInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Proxy = (*ProxyInstance)(nil)

// Proxy wraps GProxy
//
// A `GProxy` handles connecting to a remote host via a given type of
// proxy server. It is implemented by the `gio-proxy` extension point.
// The extensions are named after their proxy protocol name. As an
// example, a SOCKS5 proxy implementation can be retrieved with the
// name `socks5` using the function
// [method@Gio.IOExtensionPoint.get_extension_by_name].
type Proxy interface {
	upcastToGProxy() *ProxyInstance

	// ConnectProxy wraps g_proxy_connect
	// 
	// The function takes the following parameters:
	// 
	// 	- connection IOStream: a #GIOStream 
	// 	- proxyAddress ProxyAddress: a #GProxyAddress 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- goret IOStream 
	// 	- _goerr error (nullable): an error 
	//
	// Given @connection to communicate with a proxy (eg, a
	// #GSocketConnection that is connected to the proxy server), this
	// does the necessary handshake to connect to @proxy_address, and if
	// required, wraps the #GIOStream to handle proxy payload.
	ConnectProxy(IOStream, ProxyAddress, Cancellable) (IOStream, error)
	// ConnectAsync wraps g_proxy_connect_async
	// 
	// The function takes the following parameters:
	// 
	// 	- connection IOStream: a #GIOStream 
	// 	- proxyAddress ProxyAddress: a #GProxyAddress 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// Asynchronous version of g_proxy_connect().
	ConnectAsync(IOStream, ProxyAddress, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_proxy_connect_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret IOStream 
	// 	- _goerr error (nullable): an error 
	//
	// See g_proxy_connect().
	ConnectFinish(AsyncResult) (IOStream, error)
	// SupportsHostname wraps g_proxy_supports_hostname
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Some proxy protocols expect to be passed a hostname, which they
	// will resolve to an IP address themselves. Others, like SOCKS4, do
	// not allow this. This function will return %FALSE if @proxy is
	// implementing such a protocol. When %FALSE is returned, the caller
	// should resolve the destination hostname first, and then pass a
	// #GProxyAddress containing the stringified IP address to
	// g_proxy_connect() or g_proxy_connect_async().
	SupportsHostname() bool
}

var _ Proxy = (*ProxyInstance)(nil)

func unsafeWrapProxy(base *gobject.ObjectInstance) *ProxyInstance {
	return &ProxyInstance{
		Instance: *base,
	}
}

func marshalProxyInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *ProxyInstance) upcastToGProxy() *ProxyInstance {
	return p
}

// UnsafeProxyFromGlibNone is used to convert raw GProxy pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyFromGlibNone(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibNone(c).(Proxy)
}

// UnsafeProxyFromGlibFull is used to convert raw GProxy pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyFromGlibFull(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibFull(c).(Proxy)
}

// UnsafeProxyFromGlibBorrow is used to convert raw GProxy pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyFromGlibBorrow(c unsafe.Pointer) Proxy {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Proxy)
}

// UnsafeProxyToGlibNone is used to convert the instance to it's C value GProxy. This is used by the bindings internally.
func UnsafeProxyToGlibNone(c Proxy) unsafe.Pointer {
	i := c.upcastToGProxy()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeProxyToGlibFull is used to convert the instance to it's C value GProxy, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyToGlibFull(c Proxy) unsafe.Pointer {
	i := c.upcastToGProxy()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ProxyGetDefaultForProtocol wraps g_proxy_get_default_for_protocol
// 
// The function takes the following parameters:
// 
// 	- protocol string: the proxy protocol name (e.g. http, socks, etc) 
// 
// The function returns the following values:
// 
// 	- goret Proxy (nullable) 
//
// Find the `gio-proxy` extension point for a proxy implementation that supports
// the specified protocol.
func ProxyGetDefaultForProtocol(protocol string) Proxy {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GProxy // return, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_proxy_get_default_for_protocol(carg1)
	runtime.KeepAlive(protocol)

	var goret Proxy

	if cret != nil {
		goret = UnsafeProxyFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ConnectProxy wraps g_proxy_connect
// 
// The function takes the following parameters:
// 
// 	- connection IOStream: a #GIOStream 
// 	- proxyAddress ProxyAddress: a #GProxyAddress 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 
// The function returns the following values:
// 
// 	- goret IOStream 
// 	- _goerr error (nullable): an error 
//
// Given @connection to communicate with a proxy (eg, a
// #GSocketConnection that is connected to the proxy server), this
// does the necessary handshake to connect to @proxy_address, and if
// required, wraps the #GIOStream to handle proxy payload.
func (proxy *ProxyInstance) ConnectProxy(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable) (IOStream, error) {
	var carg0 *C.GProxy        // in, none, converted
	var carg1 *C.GIOStream     // in, none, converted
	var carg2 *C.GProxyAddress // in, none, converted
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GIOStream     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))
	carg2 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxyAddress))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_proxy_connect(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(cancellable)

	var goret  IOStream
	var _goerr error

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_proxy_connect_async
// 
// The function takes the following parameters:
// 
// 	- connection IOStream: a #GIOStream 
// 	- proxyAddress ProxyAddress: a #GProxyAddress 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// Asynchronous version of g_proxy_connect().
func (proxy *ProxyInstance) ConnectAsync(connection IOStream, proxyAddress ProxyAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GProxy             // in, none, converted
	var carg1 *C.GIOStream          // in, none, converted
	var carg2 *C.GProxyAddress      // in, none, converted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))
	carg2 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxyAddress))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_proxy_connect_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(proxyAddress)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_proxy_connect_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret IOStream 
// 	- _goerr error (nullable): an error 
//
// See g_proxy_connect().
func (proxy *ProxyInstance) ConnectFinish(result AsyncResult) (IOStream, error) {
	var carg0 *C.GProxy       // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GIOStream    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_proxy_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(result)

	var goret  IOStream
	var _goerr error

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SupportsHostname wraps g_proxy_supports_hostname
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Some proxy protocols expect to be passed a hostname, which they
// will resolve to an IP address themselves. Others, like SOCKS4, do
// not allow this. This function will return %FALSE if @proxy is
// implementing such a protocol. When %FALSE is returned, the caller
// should resolve the destination hostname first, and then pass a
// #GProxyAddress containing the stringified IP address to
// g_proxy_connect() or g_proxy_connect_async().
func (proxy *ProxyInstance) SupportsHostname() bool {
	var carg0 *C.GProxy  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GProxy)(UnsafeProxyToGlibNone(proxy))

	cret = C.g_proxy_supports_hostname(carg0)
	runtime.KeepAlive(proxy)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ProxyResolverInstance is the instance type used by all types implementing GProxyResolver. It is used internally by the bindings. Users should use the interface [ProxyResolver] instead.
type ProxyResolverInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ ProxyResolver = (*ProxyResolverInstance)(nil)

// ProxyResolver wraps GProxyResolver
//
// `GProxyResolver` provides synchronous and asynchronous network proxy
// resolution. `GProxyResolver` is used within [class@Gio.SocketClient] through
// the method [method@Gio.SocketConnectable.proxy_enumerate].
// 
// Implementations of `GProxyResolver` based on
// [libproxy](https://github.com/libproxy/libproxy) and GNOME settings can be
// found in [glib-networking](https://gitlab.gnome.org/GNOME/glib-networking).
// GIO comes with an implementation for use inside Flatpak portals.
type ProxyResolver interface {
	upcastToGProxyResolver() *ProxyResolverInstance

	// IsSupported wraps g_proxy_resolver_is_supported
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @resolver can be used on this system. (This is used
	// internally; g_proxy_resolver_get_default() will only return a proxy
	// resolver that returns %TRUE for this method.)
	IsSupported() bool
	// Lookup wraps g_proxy_resolver_lookup
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a URI representing the destination to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	// 	- _goerr error (nullable): an error 
	//
	// Looks into the system proxy configuration to determine what proxy,
	// if any, to use to connect to @uri. The returned proxy URIs are of
	// the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
	// `direct://`, where `&lt;protocol&gt;` could be http, rtsp, socks
	// or other proxying protocol.
	// 
	// If you don't know what network protocol is being used on the
	// socket, you should use `none` as the URI protocol.
	// In this case, the resolver might still return a generic proxy type
	// (such as SOCKS), but would not return protocol-specific proxy types
	// (such as http).
	// 
	// `direct://` is used when no proxy is needed.
	// Direct connection should not be attempted unless it is part of the
	// returned array of proxies.
	Lookup(string, Cancellable) ([]string, error)
	// LookupAsync wraps g_proxy_resolver_lookup_async
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a URI representing the destination to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
	// details.
	LookupAsync(string, Cancellable, AsyncReadyCallback)
	// LookupFinish wraps g_proxy_resolver_lookup_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	// 	- _goerr error (nullable): an error 
	//
	// Call this function to obtain the array of proxy URIs when
	// g_proxy_resolver_lookup_async() is complete. See
	// g_proxy_resolver_lookup() for more details.
	LookupFinish(AsyncResult) ([]string, error)
}

var _ ProxyResolver = (*ProxyResolverInstance)(nil)

func unsafeWrapProxyResolver(base *gobject.ObjectInstance) *ProxyResolverInstance {
	return &ProxyResolverInstance{
		Instance: *base,
	}
}

func marshalProxyResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (p *ProxyResolverInstance) upcastToGProxyResolver() *ProxyResolverInstance {
	return p
}

// UnsafeProxyResolverFromGlibNone is used to convert raw GProxyResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibNone(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyResolver)
}

// UnsafeProxyResolverFromGlibFull is used to convert raw GProxyResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibFull(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyResolver)
}

// UnsafeProxyResolverFromGlibBorrow is used to convert raw GProxyResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyResolverFromGlibBorrow(c unsafe.Pointer) ProxyResolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyResolver)
}

// UnsafeProxyResolverToGlibNone is used to convert the instance to it's C value GProxyResolver. This is used by the bindings internally.
func UnsafeProxyResolverToGlibNone(c ProxyResolver) unsafe.Pointer {
	i := c.upcastToGProxyResolver()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeProxyResolverToGlibFull is used to convert the instance to it's C value GProxyResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyResolverToGlibFull(c ProxyResolver) unsafe.Pointer {
	i := c.upcastToGProxyResolver()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// ProxyResolverGetDefault wraps g_proxy_resolver_get_default
// 
// The function returns the following values:
// 
// 	- goret ProxyResolver 
//
// Gets the default #GProxyResolver for the system.
func ProxyResolverGetDefault() ProxyResolver {
	var cret *C.GProxyResolver // return, none, converted

	cret = C.g_proxy_resolver_get_default()

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsSupported wraps g_proxy_resolver_is_supported
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @resolver can be used on this system. (This is used
// internally; g_proxy_resolver_get_default() will only return a proxy
// resolver that returns %TRUE for this method.)
func (resolver *ProxyResolverInstance) IsSupported() bool {
	var carg0 *C.GProxyResolver // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))

	cret = C.g_proxy_resolver_is_supported(carg0)
	runtime.KeepAlive(resolver)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Lookup wraps g_proxy_resolver_lookup
// 
// The function takes the following parameters:
// 
// 	- uri string: a URI representing the destination to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Looks into the system proxy configuration to determine what proxy,
// if any, to use to connect to @uri. The returned proxy URIs are of
// the form `&lt;protocol&gt;://[user[:password]@]host[:port]` or
// `direct://`, where `&lt;protocol&gt;` could be http, rtsp, socks
// or other proxying protocol.
// 
// If you don't know what network protocol is being used on the
// socket, you should use `none` as the URI protocol.
// In this case, the resolver might still return a generic proxy type
// (such as SOCKS), but would not return protocol-specific proxy types
// (such as http).
// 
// `direct://` is used when no proxy is needed.
// Direct connection should not be attempted unless it is part of the
// returned array of proxies.
func (resolver *ProxyResolverInstance) Lookup(uri string, cancellable Cancellable) ([]string, error) {
	var carg0 *C.GProxyResolver // in, none, converted
	var carg1 *C.gchar          // in, none, string
	var carg2 *C.GCancellable   // in, none, converted, nullable
	var cret  **C.gchar         // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_proxy_resolver_lookup(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cancellable)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupAsync wraps g_proxy_resolver_lookup_async
// 
// The function takes the following parameters:
// 
// 	- uri string: a URI representing the destination to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
// details.
func (resolver *ProxyResolverInstance) LookupAsync(uri string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GProxyResolver     // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_proxy_resolver_lookup_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupFinish wraps g_proxy_resolver_lookup_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Call this function to obtain the array of proxy URIs when
// g_proxy_resolver_lookup_async() is complete. See
// g_proxy_resolver_lookup() for more details.
func (resolver *ProxyResolverInstance) LookupFinish(result AsyncResult) ([]string, error) {
	var carg0 *C.GProxyResolver // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  **C.gchar         // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_proxy_resolver_lookup_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoteActionGroupInstance is the instance type used by all types implementing GRemoteActionGroup. It is used internally by the bindings. Users should use the interface [RemoteActionGroup] instead.
type RemoteActionGroupInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ RemoteActionGroup = (*RemoteActionGroupInstance)(nil)

// RemoteActionGroup wraps GRemoteActionGroup
//
// The `GRemoteActionGroup` interface is implemented by [iface@Gio.ActionGroup]
// instances that either transmit action invocations to other processes
// or receive action invocations in the local process from other
// processes.
// 
// The interface has `_full` variants of the two
// methods on [iface@Gio.ActionGroup] used to activate actions:
// [method@Gio.ActionGroup.activate_action] and
// [method@Gio.ActionGroup.change_action_state]. These variants allow a
// &#x2018;platform data&#x2019; [struct@GLib.Variant] to be specified: a dictionary providing
// context for the action invocation (for example: timestamps, startup
// notification IDs, etc).
// 
// [class@Gio.DBusActionGroup] implements `GRemoteActionGroup`.  This provides a
// mechanism to send platform data for action invocations over D-Bus.
// 
// Additionally, [method@Gio.DBusConnection.export_action_group] will check if
// the exported [iface@Gio.ActionGroup] implements `GRemoteActionGroup` and use
// the `_full` variants of the calls if available.  This
// provides a mechanism by which to receive platform data for action
// invocations that arrive by way of D-Bus.
type RemoteActionGroup interface {
	upcastToGRemoteActionGroup() *RemoteActionGroupInstance
}

var _ RemoteActionGroup = (*RemoteActionGroupInstance)(nil)

func unsafeWrapRemoteActionGroup(base *gobject.ObjectInstance) *RemoteActionGroupInstance {
	return &RemoteActionGroupInstance{
		Instance: *base,
	}
}

func marshalRemoteActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (r *RemoteActionGroupInstance) upcastToGRemoteActionGroup() *RemoteActionGroupInstance {
	return r
}

// UnsafeRemoteActionGroupFromGlibNone is used to convert raw GRemoteActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibNone(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupFromGlibFull is used to convert raw GRemoteActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibFull(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupFromGlibBorrow is used to convert raw GRemoteActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeRemoteActionGroupFromGlibBorrow(c unsafe.Pointer) RemoteActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(RemoteActionGroup)
}

// UnsafeRemoteActionGroupToGlibNone is used to convert the instance to it's C value GRemoteActionGroup. This is used by the bindings internally.
func UnsafeRemoteActionGroupToGlibNone(c RemoteActionGroup) unsafe.Pointer {
	i := c.upcastToGRemoteActionGroup()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeRemoteActionGroupToGlibFull is used to convert the instance to it's C value GRemoteActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeRemoteActionGroupToGlibFull(c RemoteActionGroup) unsafe.Pointer {
	i := c.upcastToGRemoteActionGroup()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// SeekableInstance is the instance type used by all types implementing GSeekable. It is used internally by the bindings. Users should use the interface [Seekable] instead.
type SeekableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Seekable = (*SeekableInstance)(nil)

// Seekable wraps GSeekable
//
// `GSeekable` is implemented by streams (implementations of
// [class@Gio.InputStream] or [class@Gio.OutputStream]) that support seeking.
// 
// Seekable streams largely fall into two categories: resizable and
// fixed-size.
// 
// `GSeekable` on fixed-sized streams is approximately the same as POSIX
// [`lseek()`](man:lseek(2)) on a block device (for example: attempting to seek
// past the end of the device is an error).  Fixed streams typically cannot be
// truncated.
// 
// `GSeekable` on resizable streams is approximately the same as POSIX
// [`lseek()`](man:lseek(2)) on a normal file.  Seeking past the end and writing
// data will usually cause the stream to resize by introducing zero bytes.
type Seekable interface {
	upcastToGSeekable() *SeekableInstance

	// CanSeek wraps g_seekable_can_seek
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests if the stream supports the #GSeekableIface.
	CanSeek() bool
	// CanTruncate wraps g_seekable_can_truncate
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests if the length of the stream can be adjusted with
	// g_seekable_truncate().
	CanTruncate() bool
	// Seek wraps g_seekable_seek
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64: a #goffset. 
	// 	- typ glib.SeekType: a #GSeekType. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Seeks in the stream by the given @offset, modified by @type.
	// 
	// Attempting to seek past the end of the stream will have different
	// results depending on if the stream is fixed-sized or resizable.  If
	// the stream is resizable then seeking past the end and then writing
	// will result in zeros filling the empty space.  Seeking past the end
	// of a resizable stream and reading will result in EOF.  Seeking past
	// the end of a fixed-sized stream will fail.
	// 
	// Any operation that would result in a negative offset will fail.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Seek(int64, glib.SeekType, Cancellable) (bool, error)
	// Tell wraps g_seekable_tell
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	//
	// Tells the current position within the stream.
	Tell() int64
	// Truncate wraps g_seekable_truncate
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64: new length for @seekable, in bytes. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets the length of the stream to @offset. If the stream was previously
	// larger than @offset, the extra data is discarded. If the stream was
	// previously shorter than @offset, it is extended with NUL ('\0') bytes.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Truncate(int64, Cancellable) (bool, error)
}

var _ Seekable = (*SeekableInstance)(nil)

func unsafeWrapSeekable(base *gobject.ObjectInstance) *SeekableInstance {
	return &SeekableInstance{
		Instance: *base,
	}
}

func marshalSeekableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (s *SeekableInstance) upcastToGSeekable() *SeekableInstance {
	return s
}

// UnsafeSeekableFromGlibNone is used to convert raw GSeekable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSeekableFromGlibNone(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibNone(c).(Seekable)
}

// UnsafeSeekableFromGlibFull is used to convert raw GSeekable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSeekableFromGlibFull(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibFull(c).(Seekable)
}

// UnsafeSeekableFromGlibBorrow is used to convert raw GSeekable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSeekableFromGlibBorrow(c unsafe.Pointer) Seekable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Seekable)
}

// UnsafeSeekableToGlibNone is used to convert the instance to it's C value GSeekable. This is used by the bindings internally.
func UnsafeSeekableToGlibNone(c Seekable) unsafe.Pointer {
	i := c.upcastToGSeekable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeSeekableToGlibFull is used to convert the instance to it's C value GSeekable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSeekableToGlibFull(c Seekable) unsafe.Pointer {
	i := c.upcastToGSeekable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanSeek wraps g_seekable_can_seek
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if the stream supports the #GSeekableIface.
func (seekable *SeekableInstance) CanSeek() bool {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_can_seek(carg0)
	runtime.KeepAlive(seekable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanTruncate wraps g_seekable_can_truncate
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if the length of the stream can be adjusted with
// g_seekable_truncate().
func (seekable *SeekableInstance) CanTruncate() bool {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_can_truncate(carg0)
	runtime.KeepAlive(seekable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Seek wraps g_seekable_seek
// 
// The function takes the following parameters:
// 
// 	- offset int64: a #goffset. 
// 	- typ glib.SeekType: a #GSeekType. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Seeks in the stream by the given @offset, modified by @type.
// 
// Attempting to seek past the end of the stream will have different
// results depending on if the stream is fixed-sized or resizable.  If
// the stream is resizable then seeking past the end and then writing
// will result in zeros filling the empty space.  Seeking past the end
// of a resizable stream and reading will result in EOF.  Seeking past
// the end of a fixed-sized stream will fail.
// 
// Any operation that would result in a negative offset will fail.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (seekable *SeekableInstance) Seek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSeekable    // in, none, converted
	var carg1 C.goffset       // in, none, casted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_seekable_seek(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Tell wraps g_seekable_tell
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Tells the current position within the stream.
func (seekable *SeekableInstance) Tell() int64 {
	var carg0 *C.GSeekable // in, none, converted
	var cret  C.goffset    // return, none, casted

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))

	cret = C.g_seekable_tell(carg0)
	runtime.KeepAlive(seekable)

	var goret int64

	goret = int64(cret)

	return goret
}

// Truncate wraps g_seekable_truncate
// 
// The function takes the following parameters:
// 
// 	- offset int64: new length for @seekable, in bytes. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets the length of the stream to @offset. If the stream was previously
// larger than @offset, the extra data is discarded. If the stream was
// previously shorter than @offset, it is extended with NUL ('\0') bytes.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (seekable *SeekableInstance) Truncate(offset int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSeekable    // in, none, converted
	var carg1 C.goffset       // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSeekable)(UnsafeSeekableToGlibNone(seekable))
	carg1 = C.goffset(offset)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_seekable_truncate(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SocketConnectableInstance is the instance type used by all types implementing GSocketConnectable. It is used internally by the bindings. Users should use the interface [SocketConnectable] instead.
type SocketConnectableInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ SocketConnectable = (*SocketConnectableInstance)(nil)

// SocketConnectable wraps GSocketConnectable
//
// Objects that describe one or more potential socket endpoints
// implement `GSocketConnectable`. Callers can then use
// [method@Gio.SocketConnectable.enumerate] to get a
// [class@Gio.SocketAddressEnumerator] to try out each socket address in turn
// until one succeeds, as shown in the sample code below.
// 
// ```c
// MyConnectionType *
// connect_to_host (const char    *hostname,
//                  guint16        port,
//                  GCancellable  *cancellable,
//                  GError       **error)
// {
//   MyConnection *conn = NULL;
//   GSocketConnectable *addr;
//   GSocketAddressEnumerator *enumerator;
//   GSocketAddress *sockaddr;
//   GError *conn_error = NULL;
// 
//   addr = g_network_address_new (hostname, port);
//   enumerator = g_socket_connectable_enumerate (addr);
//   g_object_unref (addr);
// 
//   // Try each sockaddr until we succeed. Record the first connection error,
//   // but not any further ones (since they'll probably be basically the same
//   // as the first).
//   while (!conn &amp;&amp; (sockaddr = g_socket_address_enumerator_next (enumerator, cancellable, error))
//     {
//       conn = connect_to_sockaddr (sockaddr, conn_error ? NULL : &amp;conn_error);
//       g_object_unref (sockaddr);
//     }
//   g_object_unref (enumerator);
// 
//   if (conn)
//     {
//       if (conn_error)
//         {
//           // We couldn't connect to the first address, but we succeeded
//           // in connecting to a later address.
//           g_error_free (conn_error);
//         }
//       return conn;
//     }
//   else if (error)
//     {
//       /// Either initial lookup failed, or else the caller cancelled us.
//       if (conn_error)
//         g_error_free (conn_error);
//       return NULL;
//     }
//   else
//     {
//       g_error_propagate (error, conn_error);
//       return NULL;
//     }
// }
// ```
type SocketConnectable interface {
	upcastToGSocketConnectable() *SocketConnectableInstance

	// Enumerate wraps g_socket_connectable_enumerate
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddressEnumerator 
	//
	// Creates a #GSocketAddressEnumerator for @connectable.
	Enumerate() SocketAddressEnumerator
	// ProxyEnumerate wraps g_socket_connectable_proxy_enumerate
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddressEnumerator 
	//
	// Creates a #GSocketAddressEnumerator for @connectable that will
	// return a #GProxyAddress for each of its addresses that you must connect
	// to via a proxy.
	// 
	// If @connectable does not implement
	// g_socket_connectable_proxy_enumerate(), this will fall back to
	// calling g_socket_connectable_enumerate().
	ProxyEnumerate() SocketAddressEnumerator
	// String wraps g_socket_connectable_to_string
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Format a #GSocketConnectable as a string. This is a human-readable format for
	// use in debugging output, and is not a stable serialization format. It is not
	// suitable for use in user interfaces as it exposes too much information for a
	// user.
	// 
	// If the #GSocketConnectable implementation does not support string formatting,
	// the implementation&#x2019;s type name will be returned as a fallback.
	String() string
}

var _ SocketConnectable = (*SocketConnectableInstance)(nil)

func unsafeWrapSocketConnectable(base *gobject.ObjectInstance) *SocketConnectableInstance {
	return &SocketConnectableInstance{
		Instance: *base,
	}
}

func marshalSocketConnectableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (s *SocketConnectableInstance) upcastToGSocketConnectable() *SocketConnectableInstance {
	return s
}

// UnsafeSocketConnectableFromGlibNone is used to convert raw GSocketConnectable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibNone(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketConnectable)
}

// UnsafeSocketConnectableFromGlibFull is used to convert raw GSocketConnectable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibFull(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketConnectable)
}

// UnsafeSocketConnectableFromGlibBorrow is used to convert raw GSocketConnectable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketConnectableFromGlibBorrow(c unsafe.Pointer) SocketConnectable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketConnectable)
}

// UnsafeSocketConnectableToGlibNone is used to convert the instance to it's C value GSocketConnectable. This is used by the bindings internally.
func UnsafeSocketConnectableToGlibNone(c SocketConnectable) unsafe.Pointer {
	i := c.upcastToGSocketConnectable()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeSocketConnectableToGlibFull is used to convert the instance to it's C value GSocketConnectable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketConnectableToGlibFull(c SocketConnectable) unsafe.Pointer {
	i := c.upcastToGSocketConnectable()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// Enumerate wraps g_socket_connectable_enumerate
// 
// The function returns the following values:
// 
// 	- goret SocketAddressEnumerator 
//
// Creates a #GSocketAddressEnumerator for @connectable.
func (connectable *SocketConnectableInstance) Enumerate() SocketAddressEnumerator {
	var carg0 *C.GSocketConnectable       // in, none, converted
	var cret  *C.GSocketAddressEnumerator // return, full, converted

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_enumerate(carg0)
	runtime.KeepAlive(connectable)

	var goret SocketAddressEnumerator

	goret = UnsafeSocketAddressEnumeratorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ProxyEnumerate wraps g_socket_connectable_proxy_enumerate
// 
// The function returns the following values:
// 
// 	- goret SocketAddressEnumerator 
//
// Creates a #GSocketAddressEnumerator for @connectable that will
// return a #GProxyAddress for each of its addresses that you must connect
// to via a proxy.
// 
// If @connectable does not implement
// g_socket_connectable_proxy_enumerate(), this will fall back to
// calling g_socket_connectable_enumerate().
func (connectable *SocketConnectableInstance) ProxyEnumerate() SocketAddressEnumerator {
	var carg0 *C.GSocketConnectable       // in, none, converted
	var cret  *C.GSocketAddressEnumerator // return, full, converted

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_proxy_enumerate(carg0)
	runtime.KeepAlive(connectable)

	var goret SocketAddressEnumerator

	goret = UnsafeSocketAddressEnumeratorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// String wraps g_socket_connectable_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Format a #GSocketConnectable as a string. This is a human-readable format for
// use in debugging output, and is not a stable serialization format. It is not
// suitable for use in user interfaces as it exposes too much information for a
// user.
// 
// If the #GSocketConnectable implementation does not support string formatting,
// the implementation&#x2019;s type name will be returned as a fallback.
func (connectable *SocketConnectableInstance) String() string {
	var carg0 *C.GSocketConnectable // in, none, converted
	var cret  *C.gchar              // return, full, string

	carg0 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))

	cret = C.g_socket_connectable_to_string(carg0)
	runtime.KeepAlive(connectable)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// TlsBackendInstance is the instance type used by all types implementing GTlsBackend. It is used internally by the bindings. Users should use the interface [TlsBackend] instead.
type TlsBackendInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsBackend = (*TlsBackendInstance)(nil)

// TlsBackend wraps GTlsBackend
//
// TLS (Transport Layer Security, aka SSL) and DTLS backend. This is an
// internal type used to coordinate the different classes implemented
// by a TLS backend.
type TlsBackend interface {
	upcastToGTlsBackend() *TlsBackendInstance

	// GetCertificateType wraps g_tls_backend_get_certificate_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend's #GTlsCertificate implementation.
	GetCertificateType() gobject.Type
	// GetClientConnectionType wraps g_tls_backend_get_client_connection_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend's #GTlsClientConnection implementation.
	GetClientConnectionType() gobject.Type
	// GetDefaultDatabase wraps g_tls_backend_get_default_database
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsDatabase 
	//
	// Gets the default #GTlsDatabase used to verify TLS connections.
	GetDefaultDatabase() TlsDatabase
	// GetDtlsClientConnectionType wraps g_tls_backend_get_dtls_client_connection_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend&#x2019;s #GDtlsClientConnection implementation.
	GetDtlsClientConnectionType() gobject.Type
	// GetDtlsServerConnectionType wraps g_tls_backend_get_dtls_server_connection_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend&#x2019;s #GDtlsServerConnection implementation.
	GetDtlsServerConnectionType() gobject.Type
	// GetFileDatabaseType wraps g_tls_backend_get_file_database_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend's #GTlsFileDatabase implementation.
	GetFileDatabaseType() gobject.Type
	// GetServerConnectionType wraps g_tls_backend_get_server_connection_type
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Type 
	//
	// Gets the #GType of @backend's #GTlsServerConnection implementation.
	GetServerConnectionType() gobject.Type
	// SetDefaultDatabase wraps g_tls_backend_set_default_database
	// 
	// The function takes the following parameters:
	// 
	// 	- database TlsDatabase (nullable): the #GTlsDatabase 
	//
	// Set the default #GTlsDatabase used to verify TLS connections
	// 
	// Any subsequent call to g_tls_backend_get_default_database() will return
	// the database set in this call.  Existing databases and connections are not
	// modified.
	// 
	// Setting a %NULL default database will reset to using the system default
	// database as if g_tls_backend_set_default_database() had never been called.
	SetDefaultDatabase(TlsDatabase)
	// SupportsDtls wraps g_tls_backend_supports_dtls
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if DTLS is supported. DTLS support may not be available even if TLS
	// support is available, and vice-versa.
	SupportsDtls() bool
	// SupportsTls wraps g_tls_backend_supports_tls
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if TLS is supported; if this returns %FALSE for the default
	// #GTlsBackend, it means no "real" TLS backend is available.
	SupportsTls() bool
}

var _ TlsBackend = (*TlsBackendInstance)(nil)

func unsafeWrapTlsBackend(base *gobject.ObjectInstance) *TlsBackendInstance {
	return &TlsBackendInstance{
		Instance: *base,
	}
}

func marshalTlsBackendInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsBackendInstance) upcastToGTlsBackend() *TlsBackendInstance {
	return t
}

// UnsafeTlsBackendFromGlibNone is used to convert raw GTlsBackend pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibNone(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsBackend)
}

// UnsafeTlsBackendFromGlibFull is used to convert raw GTlsBackend pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibFull(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsBackend)
}

// UnsafeTlsBackendFromGlibBorrow is used to convert raw GTlsBackend pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsBackendFromGlibBorrow(c unsafe.Pointer) TlsBackend {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsBackend)
}

// UnsafeTlsBackendToGlibNone is used to convert the instance to it's C value GTlsBackend. This is used by the bindings internally.
func UnsafeTlsBackendToGlibNone(c TlsBackend) unsafe.Pointer {
	i := c.upcastToGTlsBackend()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsBackendToGlibFull is used to convert the instance to it's C value GTlsBackend, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsBackendToGlibFull(c TlsBackend) unsafe.Pointer {
	i := c.upcastToGTlsBackend()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// TlsBackendGetDefault wraps g_tls_backend_get_default
// 
// The function returns the following values:
// 
// 	- goret TlsBackend 
//
// Gets the default #GTlsBackend for the system.
func TlsBackendGetDefault() TlsBackend {
	var cret *C.GTlsBackend // return, none, converted

	cret = C.g_tls_backend_get_default()

	var goret TlsBackend

	goret = UnsafeTlsBackendFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCertificateType wraps g_tls_backend_get_certificate_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend's #GTlsCertificate implementation.
func (backend *TlsBackendInstance) GetCertificateType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_certificate_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetClientConnectionType wraps g_tls_backend_get_client_connection_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend's #GTlsClientConnection implementation.
func (backend *TlsBackendInstance) GetClientConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_client_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetDefaultDatabase wraps g_tls_backend_get_default_database
// 
// The function returns the following values:
// 
// 	- goret TlsDatabase 
//
// Gets the default #GTlsDatabase used to verify TLS connections.
func (backend *TlsBackendInstance) GetDefaultDatabase() TlsDatabase {
	var carg0 *C.GTlsBackend  // in, none, converted
	var cret  *C.GTlsDatabase // return, full, converted

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_default_database(carg0)
	runtime.KeepAlive(backend)

	var goret TlsDatabase

	goret = UnsafeTlsDatabaseFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDtlsClientConnectionType wraps g_tls_backend_get_dtls_client_connection_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend&#x2019;s #GDtlsClientConnection implementation.
func (backend *TlsBackendInstance) GetDtlsClientConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_dtls_client_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetDtlsServerConnectionType wraps g_tls_backend_get_dtls_server_connection_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend&#x2019;s #GDtlsServerConnection implementation.
func (backend *TlsBackendInstance) GetDtlsServerConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_dtls_server_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetFileDatabaseType wraps g_tls_backend_get_file_database_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend's #GTlsFileDatabase implementation.
func (backend *TlsBackendInstance) GetFileDatabaseType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_file_database_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// GetServerConnectionType wraps g_tls_backend_get_server_connection_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the #GType of @backend's #GTlsServerConnection implementation.
func (backend *TlsBackendInstance) GetServerConnectionType() gobject.Type {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.GType        // return, none, casted, alias

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_get_server_connection_type(carg0)
	runtime.KeepAlive(backend)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SetDefaultDatabase wraps g_tls_backend_set_default_database
// 
// The function takes the following parameters:
// 
// 	- database TlsDatabase (nullable): the #GTlsDatabase 
//
// Set the default #GTlsDatabase used to verify TLS connections
// 
// Any subsequent call to g_tls_backend_get_default_database() will return
// the database set in this call.  Existing databases and connections are not
// modified.
// 
// Setting a %NULL default database will reset to using the system default
// database as if g_tls_backend_set_default_database() had never been called.
func (backend *TlsBackendInstance) SetDefaultDatabase(database TlsDatabase) {
	var carg0 *C.GTlsBackend  // in, none, converted
	var carg1 *C.GTlsDatabase // in, none, converted, nullable

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_tls_backend_set_default_database(carg0, carg1)
	runtime.KeepAlive(backend)
	runtime.KeepAlive(database)
}

// SupportsDtls wraps g_tls_backend_supports_dtls
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if DTLS is supported. DTLS support may not be available even if TLS
// support is available, and vice-versa.
func (backend *TlsBackendInstance) SupportsDtls() bool {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_supports_dtls(carg0)
	runtime.KeepAlive(backend)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SupportsTls wraps g_tls_backend_supports_tls
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if TLS is supported; if this returns %FALSE for the default
// #GTlsBackend, it means no "real" TLS backend is available.
func (backend *TlsBackendInstance) SupportsTls() bool {
	var carg0 *C.GTlsBackend // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GTlsBackend)(UnsafeTlsBackendToGlibNone(backend))

	cret = C.g_tls_backend_supports_tls(carg0)
	runtime.KeepAlive(backend)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TlsClientConnectionInstance is the instance type used by all types implementing GTlsClientConnection. It is used internally by the bindings. Users should use the interface [TlsClientConnection] instead.
type TlsClientConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsClientConnection = (*TlsClientConnectionInstance)(nil)

// TlsClientConnection wraps GTlsClientConnection
//
// `GTlsClientConnection` is the client-side subclass of
// [class@Gio.TlsConnection], representing a client-side TLS connection.
type TlsClientConnection interface {
	upcastToGTlsClientConnection() *TlsClientConnectionInstance

	// CopySessionState wraps g_tls_client_connection_copy_session_state
	// 
	// The function takes the following parameters:
	// 
	// 	- source TlsClientConnection: a #GTlsClientConnection 
	//
	// Possibly copies session state from one connection to another, for use
	// in TLS session resumption. This is not normally needed, but may be
	// used when the same session needs to be used between different
	// endpoints, as is required by some protocols, such as FTP over TLS.
	// @source should have already completed a handshake and, since TLS 1.3,
	// it should have been used to read data at least once. @conn should not
	// have completed a handshake.
	// 
	// It is not possible to know whether a call to this function will
	// actually do anything. Because session resumption is normally used
	// only for performance benefit, the TLS backend might not implement
	// this function. Even if implemented, it may not actually succeed in
	// allowing @conn to resume @source's TLS session, because the server
	// may not have sent a session resumption token to @source, or it may
	// refuse to accept the token from @conn. There is no way to know
	// whether a call to this function is actually successful.
	// 
	// Using this function is not required to benefit from session
	// resumption. If the TLS backend supports session resumption, the
	// session will be resumed automatically if it is possible to do so
	// without weakening the privacy guarantees normally provided by TLS,
	// without need to call this function. For example, with TLS 1.3,
	// a session ticket will be automatically copied from any
	// #GTlsClientConnection that has previously received session tickets
	// from the server, provided a ticket is available that has not
	// previously been used for session resumption, since session ticket
	// reuse would be a privacy weakness. Using this function causes the
	// ticket to be copied without regard for privacy considerations.
	CopySessionState(TlsClientConnection)
	// GetServerIdentity wraps g_tls_client_connection_get_server_identity
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnectable (nullable) 
	//
	// Gets @conn's expected server identity
	GetServerIdentity() SocketConnectable
	// GetUseSsl3 wraps g_tls_client_connection_get_use_ssl3
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// SSL 3.0 is no longer supported. See
	// g_tls_client_connection_set_use_ssl3() for details.
	//
	// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
	GetUseSsl3() bool
	// GetValidationFlags wraps g_tls_client_connection_get_validation_flags
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// Gets @conn's validation flags
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GTlsClientConnection:validation-flags for more
	// information.
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	GetValidationFlags() TlsCertificateFlags
	// SetServerIdentity wraps g_tls_client_connection_set_server_identity
	// 
	// The function takes the following parameters:
	// 
	// 	- identity SocketConnectable: a #GSocketConnectable describing the expected server identity 
	//
	// Sets @conn's expected server identity, which is used both to tell
	// servers on virtual hosts which certificate to present, and also
	// to let @conn know what name to look for in the certificate when
	// performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(SocketConnectable)
	// SetUseSsl3 wraps g_tls_client_connection_set_use_ssl3
	// 
	// The function takes the following parameters:
	// 
	// 	- useSsl3 bool: a #gboolean, ignored 
	//
	// Since GLib 2.42.1, SSL 3.0 is no longer supported.
	// 
	// From GLib 2.42.1 through GLib 2.62, this function could be used to
	// force use of TLS 1.0, the lowest-supported TLS protocol version at
	// the time. In the past, this was needed to connect to broken TLS
	// servers that exhibited protocol version intolerance. Such servers
	// are no longer common, and using TLS 1.0 is no longer considered
	// acceptable.
	// 
	// Since GLib 2.64, this function does nothing.
	//
	// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
	SetUseSsl3(bool)
	// SetValidationFlags wraps g_tls_client_connection_set_validation_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- flags TlsCertificateFlags: the #GTlsCertificateFlags to use 
	//
	// Sets @conn's validation flags, to override the default set of
	// checks performed when validating a server certificate. By default,
	// %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GTlsClientConnection:validation-flags for more
	// information.
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	SetValidationFlags(TlsCertificateFlags)
}

var _ TlsClientConnection = (*TlsClientConnectionInstance)(nil)

func unsafeWrapTlsClientConnection(base *gobject.ObjectInstance) *TlsClientConnectionInstance {
	return &TlsClientConnectionInstance{
		Instance: *base,
	}
}

func marshalTlsClientConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsClientConnectionInstance) upcastToGTlsClientConnection() *TlsClientConnectionInstance {
	return t
}

// UnsafeTlsClientConnectionFromGlibNone is used to convert raw GTlsClientConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibNone(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionFromGlibFull is used to convert raw GTlsClientConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibFull(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionFromGlibBorrow is used to convert raw GTlsClientConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsClientConnectionFromGlibBorrow(c unsafe.Pointer) TlsClientConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsClientConnection)
}

// UnsafeTlsClientConnectionToGlibNone is used to convert the instance to it's C value GTlsClientConnection. This is used by the bindings internally.
func UnsafeTlsClientConnectionToGlibNone(c TlsClientConnection) unsafe.Pointer {
	i := c.upcastToGTlsClientConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsClientConnectionToGlibFull is used to convert the instance to it's C value GTlsClientConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsClientConnectionToGlibFull(c TlsClientConnection) unsafe.Pointer {
	i := c.upcastToGTlsClientConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsClientConnection wraps g_tls_client_connection_new
// 
// The function takes the following parameters:
// 
// 	- baseIoStream IOStream: the #GIOStream to wrap 
// 	- serverIdentity SocketConnectable (nullable): the expected identity of the server 
// 
// The function returns the following values:
// 
// 	- goret TlsClientConnection 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GTlsClientConnection wrapping @base_io_stream (which
// must have pollable input and output streams) which is assumed to
// communicate with the server identified by @server_identity.
// 
// See the documentation for #GTlsConnection:base-io-stream for restrictions
// on when application code can run operations on the @base_io_stream after
// this function has returned.
func NewTlsClientConnection(baseIoStream IOStream, serverIdentity SocketConnectable) (TlsClientConnection, error) {
	var carg1 *C.GIOStream          // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, converted, nullable
	var cret  *C.GIOStream          // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	if serverIdentity != nil {
		carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(serverIdentity))
	}

	cret = C.g_tls_client_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(serverIdentity)

	var goret  TlsClientConnection
	var _goerr error

	goret = UnsafeTlsClientConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CopySessionState wraps g_tls_client_connection_copy_session_state
// 
// The function takes the following parameters:
// 
// 	- source TlsClientConnection: a #GTlsClientConnection 
//
// Possibly copies session state from one connection to another, for use
// in TLS session resumption. This is not normally needed, but may be
// used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS.
// @source should have already completed a handshake and, since TLS 1.3,
// it should have been used to read data at least once. @conn should not
// have completed a handshake.
// 
// It is not possible to know whether a call to this function will
// actually do anything. Because session resumption is normally used
// only for performance benefit, the TLS backend might not implement
// this function. Even if implemented, it may not actually succeed in
// allowing @conn to resume @source's TLS session, because the server
// may not have sent a session resumption token to @source, or it may
// refuse to accept the token from @conn. There is no way to know
// whether a call to this function is actually successful.
// 
// Using this function is not required to benefit from session
// resumption. If the TLS backend supports session resumption, the
// session will be resumed automatically if it is possible to do so
// without weakening the privacy guarantees normally provided by TLS,
// without need to call this function. For example, with TLS 1.3,
// a session ticket will be automatically copied from any
// #GTlsClientConnection that has previously received session tickets
// from the server, provided a ticket is available that has not
// previously been used for session resumption, since session ticket
// reuse would be a privacy weakness. Using this function causes the
// ticket to be copied without regard for privacy considerations.
func (conn *TlsClientConnectionInstance) CopySessionState(source TlsClientConnection) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 *C.GTlsClientConnection // in, none, converted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(source))

	C.g_tls_client_connection_copy_session_state(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

// GetServerIdentity wraps g_tls_client_connection_get_server_identity
// 
// The function returns the following values:
// 
// 	- goret SocketConnectable (nullable) 
//
// Gets @conn's expected server identity
func (conn *TlsClientConnectionInstance) GetServerIdentity() SocketConnectable {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  *C.GSocketConnectable   // return, none, converted, nullable

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_server_identity(carg0)
	runtime.KeepAlive(conn)

	var goret SocketConnectable

	if cret != nil {
		goret = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetUseSsl3 wraps g_tls_client_connection_get_use_ssl3
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// SSL 3.0 is no longer supported. See
// g_tls_client_connection_set_use_ssl3() for details.
//
// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
func (conn *TlsClientConnectionInstance) GetUseSsl3() bool {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  C.gboolean              // return

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_use_ssl3(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetValidationFlags wraps g_tls_client_connection_get_validation_flags
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// Gets @conn's validation flags
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GTlsClientConnection:validation-flags for more
// information.
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (conn *TlsClientConnectionInstance) GetValidationFlags() TlsCertificateFlags {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var cret  C.GTlsCertificateFlags  // return, none, casted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))

	cret = C.g_tls_client_connection_get_validation_flags(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetServerIdentity wraps g_tls_client_connection_set_server_identity
// 
// The function takes the following parameters:
// 
// 	- identity SocketConnectable: a #GSocketConnectable describing the expected server identity 
//
// Sets @conn's expected server identity, which is used both to tell
// servers on virtual hosts which certificate to present, and also
// to let @conn know what name to look for in the certificate when
// performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
func (conn *TlsClientConnectionInstance) SetServerIdentity(identity SocketConnectable) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 *C.GSocketConnectable   // in, none, converted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))

	C.g_tls_client_connection_set_server_identity(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetUseSsl3 wraps g_tls_client_connection_set_use_ssl3
// 
// The function takes the following parameters:
// 
// 	- useSsl3 bool: a #gboolean, ignored 
//
// Since GLib 2.42.1, SSL 3.0 is no longer supported.
// 
// From GLib 2.42.1 through GLib 2.62, this function could be used to
// force use of TLS 1.0, the lowest-supported TLS protocol version at
// the time. In the past, this was needed to connect to broken TLS
// servers that exhibited protocol version intolerance. Such servers
// are no longer common, and using TLS 1.0 is no longer considered
// acceptable.
// 
// Since GLib 2.64, this function does nothing.
//
// Deprecated: (since 2.56.0) SSL 3.0 is insecure.
func (conn *TlsClientConnectionInstance) SetUseSsl3(useSsl3 bool) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 C.gboolean              // in

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	if useSsl3 {
		carg1 = C.TRUE
	}

	C.g_tls_client_connection_set_use_ssl3(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSsl3)
}

// SetValidationFlags wraps g_tls_client_connection_set_validation_flags
// 
// The function takes the following parameters:
// 
// 	- flags TlsCertificateFlags: the #GTlsCertificateFlags to use 
//
// Sets @conn's validation flags, to override the default set of
// checks performed when validating a server certificate. By default,
// %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GTlsClientConnection:validation-flags for more
// information.
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (conn *TlsClientConnectionInstance) SetValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GTlsClientConnection // in, none, converted
	var carg1 C.GTlsCertificateFlags  // in, none, casted

	carg0 = (*C.GTlsClientConnection)(UnsafeTlsClientConnectionToGlibNone(conn))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_tls_client_connection_set_validation_flags(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// TlsFileDatabaseInstance is the instance type used by all types implementing GTlsFileDatabase. It is used internally by the bindings. Users should use the interface [TlsFileDatabase] instead.
type TlsFileDatabaseInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsFileDatabase = (*TlsFileDatabaseInstance)(nil)

// TlsFileDatabase wraps GTlsFileDatabase
//
// `GTlsFileDatabase` is implemented by [class@Gio.TlsDatabase] objects which
// load their certificate information from a file. It is an interface which
// TLS library specific subtypes implement.
type TlsFileDatabase interface {
	upcastToGTlsFileDatabase() *TlsFileDatabaseInstance
}

var _ TlsFileDatabase = (*TlsFileDatabaseInstance)(nil)

func unsafeWrapTlsFileDatabase(base *gobject.ObjectInstance) *TlsFileDatabaseInstance {
	return &TlsFileDatabaseInstance{
		Instance: *base,
	}
}

func marshalTlsFileDatabaseInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsFileDatabaseInstance) upcastToGTlsFileDatabase() *TlsFileDatabaseInstance {
	return t
}

// UnsafeTlsFileDatabaseFromGlibNone is used to convert raw GTlsFileDatabase pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibNone(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseFromGlibFull is used to convert raw GTlsFileDatabase pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibFull(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseFromGlibBorrow is used to convert raw GTlsFileDatabase pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsFileDatabaseFromGlibBorrow(c unsafe.Pointer) TlsFileDatabase {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsFileDatabase)
}

// UnsafeTlsFileDatabaseToGlibNone is used to convert the instance to it's C value GTlsFileDatabase. This is used by the bindings internally.
func UnsafeTlsFileDatabaseToGlibNone(c TlsFileDatabase) unsafe.Pointer {
	i := c.upcastToGTlsFileDatabase()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsFileDatabaseToGlibFull is used to convert the instance to it's C value GTlsFileDatabase, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseToGlibFull(c TlsFileDatabase) unsafe.Pointer {
	i := c.upcastToGTlsFileDatabase()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsFileDatabase wraps g_tls_file_database_new
// 
// The function takes the following parameters:
// 
// 	- anchors string: filename of anchor certificate authorities. 
// 
// The function returns the following values:
// 
// 	- goret TlsFileDatabase 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GTlsFileDatabase which uses anchor certificate authorities
// in @anchors to verify certificate chains.
// 
// The certificates in @anchors must be PEM encoded.
func NewTlsFileDatabase(anchors string) (TlsFileDatabase, error) {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GTlsDatabase // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(anchors)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_file_database_new(carg1, &_cerr)
	runtime.KeepAlive(anchors)

	var goret  TlsFileDatabase
	var _goerr error

	goret = UnsafeTlsFileDatabaseFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsServerConnectionInstance is the instance type used by all types implementing GTlsServerConnection. It is used internally by the bindings. Users should use the interface [TlsServerConnection] instead.
type TlsServerConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ TlsServerConnection = (*TlsServerConnectionInstance)(nil)

// TlsServerConnection wraps GTlsServerConnection
//
// `GTlsServerConnection` is the server-side subclass of
// [class@Gio.TlsConnection], representing a server-side TLS connection.
type TlsServerConnection interface {
	upcastToGTlsServerConnection() *TlsServerConnectionInstance
}

var _ TlsServerConnection = (*TlsServerConnectionInstance)(nil)

func unsafeWrapTlsServerConnection(base *gobject.ObjectInstance) *TlsServerConnectionInstance {
	return &TlsServerConnectionInstance{
		Instance: *base,
	}
}

func marshalTlsServerConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (t *TlsServerConnectionInstance) upcastToGTlsServerConnection() *TlsServerConnectionInstance {
	return t
}

// UnsafeTlsServerConnectionFromGlibNone is used to convert raw GTlsServerConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibNone(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionFromGlibFull is used to convert raw GTlsServerConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibFull(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionFromGlibBorrow is used to convert raw GTlsServerConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsServerConnectionFromGlibBorrow(c unsafe.Pointer) TlsServerConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsServerConnection)
}

// UnsafeTlsServerConnectionToGlibNone is used to convert the instance to it's C value GTlsServerConnection. This is used by the bindings internally.
func UnsafeTlsServerConnectionToGlibNone(c TlsServerConnection) unsafe.Pointer {
	i := c.upcastToGTlsServerConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeTlsServerConnectionToGlibFull is used to convert the instance to it's C value GTlsServerConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsServerConnectionToGlibFull(c TlsServerConnection) unsafe.Pointer {
	i := c.upcastToGTlsServerConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewTlsServerConnection wraps g_tls_server_connection_new
// 
// The function takes the following parameters:
// 
// 	- baseIoStream IOStream: the #GIOStream to wrap 
// 	- certificate TlsCertificate (nullable): the default server certificate, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsServerConnection 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GTlsServerConnection wrapping @base_io_stream (which
// must have pollable input and output streams).
// 
// See the documentation for #GTlsConnection:base-io-stream for restrictions
// on when application code can run operations on the @base_io_stream after
// this function has returned.
func NewTlsServerConnection(baseIoStream IOStream, certificate TlsCertificate) (TlsServerConnection, error) {
	var carg1 *C.GIOStream       // in, none, converted
	var carg2 *C.GTlsCertificate // in, none, converted, nullable
	var cret  *C.GIOStream       // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	if certificate != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	}

	cret = C.g_tls_server_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(certificate)

	var goret  TlsServerConnection
	var _goerr error

	goret = UnsafeTlsServerConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VolumeInstance is the instance type used by all types implementing GVolume. It is used internally by the bindings. Users should use the interface [Volume] instead.
type VolumeInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ Volume = (*VolumeInstance)(nil)

// Volume wraps GVolume
//
// The `GVolume` interface represents user-visible objects that can be
// mounted. For example, a file system partition on a USB flash drive, or an
// optical disc inserted into a disc drive.
// 
// If a `GVolume` is currently mounted, the corresponding [iface@Gio.Mount] can
// be retrieved using [method@Gio.Volume.get_mount].
// 
// Mounting a `GVolume` instance is an asynchronous operation. For more
// information about asynchronous operations, see [iface@Gio.AsyncResult] and
// [class@Gio.Task]. To mount a `GVolume`, first call [method@Gio.Volume.mount]
// with (at least) the `GVolume` instance, optionally a
// [class@Gio.MountOperation] object and a [type@Gio.AsyncReadyCallback].
// 
// Typically, one will only want to pass `NULL` for the
// [class@Gio.MountOperation] if automounting all volumes when a desktop session
// starts since it&#x2019;s not desirable to put up a lot of dialogs asking
// for credentials.
// 
// The callback will be fired when the operation has resolved (either
// with success or failure), and a [iface@Gio.AsyncResult] instance will be
// passed to the callback.  That callback should then call
// [method@Gio.Volume.mount_finish] with the `GVolume` instance and the
// [iface@Gio.AsyncResult] data to see if the operation was completed
// successfully.  If a [type@GLib.Error] is present when
// [method@Gio.Volume.mount_finish] is called, then it will be filled with any
// error information.
// 
// Note, when [porting from GnomeVFS](migrating-gnome-vfs.html),
// `GVolume` is the moral equivalent of `GnomeVFSDrive`.
// 
// ## Volume Identifiers
// 
// It is sometimes necessary to directly access the underlying
// operating system object behind a volume (e.g. for passing a volume
// to an application via the command line). For this purpose, GIO
// allows to obtain an &#x2018;identifier&#x2019; for the volume. There can be
// different kinds of identifiers, such as Hal UDIs, filesystem labels,
// traditional Unix devices (e.g. `/dev/sda2`), UUIDs. GIO uses predefined
// strings as names for the different kinds of identifiers:
// `G_VOLUME_IDENTIFIER_KIND_UUID`, `G_VOLUME_IDENTIFIER_KIND_LABEL`, etc.
// Use [method@Gio.Volume.get_identifier] to obtain an identifier for a volume.
// 
// Note that `G_VOLUME_IDENTIFIER_KIND_HAL_UDI` will only be available
// when the GVFS hal volume monitor is in use. Other volume monitors
// will generally be able to provide the `G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE`
// identifier, which can be used to obtain a hal device by means of
// `libhal_manager_find_device_string_match()`.
type Volume interface {
	upcastToGVolume() *VolumeInstance

	// CanEject wraps g_volume_can_eject
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a volume can be ejected.
	CanEject() bool
	// CanMount wraps g_volume_can_mount
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a volume can be mounted.
	CanMount() bool
	// Eject wraps g_volume_eject
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
	//
	// Ejects a volume. This is an asynchronous operation, and is
	// finished by calling g_volume_eject_finish() with the @volume
	// and #GAsyncResult returned in the @callback.
	//
	// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation() instead.
	Eject(MountUnmountFlags, Cancellable, AsyncReadyCallback)
	// EjectFinish wraps g_volume_eject_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a volume. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	//
	// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation_finish() instead.
	EjectFinish(AsyncResult) (bool, error)
	// EjectWithOperation wraps g_volume_eject_with_operation
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to
	//     avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
	//
	// Ejects a volume. This is an asynchronous operation, and is
	// finished by calling g_volume_eject_with_operation_finish() with the @volume
	// and #GAsyncResult data returned in the @callback.
	EjectWithOperation(MountUnmountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// EjectWithOperationFinish wraps g_volume_eject_with_operation_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes ejecting a volume. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	EjectWithOperationFinish(AsyncResult) (bool, error)
	// EnumerateIdentifiers wraps g_volume_enumerate_identifiers
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the kinds of [identifiers](#volume-identifiers) that @volume has.
	// Use g_volume_get_identifier() to obtain the identifiers themselves.
	EnumerateIdentifiers() []string
	// GetActivationRoot wraps g_volume_get_activation_root
	// 
	// The function returns the following values:
	// 
	// 	- goret File (nullable) 
	//
	// Gets the activation root for a #GVolume if it is known ahead of
	// mount time. Returns %NULL otherwise. If not %NULL and if @volume
	// is mounted, then the result of g_mount_get_root() on the
	// #GMount object obtained from g_volume_get_mount() will always
	// either be equal or a prefix of what this function returns. In
	// other words, in code
	// 
	// |[&lt;!-- language="C" --&gt;
	//   GMount *mount;
	//   GFile *mount_root
	//   GFile *volume_activation_root;
	// 
	//   mount = g_volume_get_mount (volume); // mounted, so never NULL
	//   mount_root = g_mount_get_root (mount);
	//   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
	// ]|
	// then the expression
	// |[&lt;!-- language="C" --&gt;
	//   (g_file_has_prefix (volume_activation_root, mount_root) ||
	//    g_file_equal (volume_activation_root, mount_root))
	// ]|
	// will always be %TRUE.
	// 
	// Activation roots are typically used in #GVolumeMonitor
	// implementations to find the underlying mount to shadow, see
	// g_mount_is_shadowed() for more details.
	GetActivationRoot() File
	// GetDrive wraps g_volume_get_drive
	// 
	// The function returns the following values:
	// 
	// 	- goret Drive (nullable) 
	//
	// Gets the drive for the @volume.
	GetDrive() Drive
	// GetIcon wraps g_volume_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the icon for @volume.
	GetIcon() Icon
	// GetIdentifier wraps g_volume_get_identifier
	// 
	// The function takes the following parameters:
	// 
	// 	- kind string: the kind of identifier to return 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the identifier of the given kind for @volume.
	// See the [introduction](#volume-identifiers) for more
	// information about volume identifiers.
	GetIdentifier(string) string
	// GetMount wraps g_volume_get_mount
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount (nullable) 
	//
	// Gets the mount for the @volume.
	GetMount() Mount
	// GetName wraps g_volume_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name of @volume.
	GetName() string
	// GetSortKey wraps g_volume_get_sort_key
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the sort key for @volume, if any.
	GetSortKey() string
	// GetSymbolicIcon wraps g_volume_get_symbolic_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the symbolic icon for @volume.
	GetSymbolicIcon() Icon
	// GetUuid wraps g_volume_get_uuid
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the UUID for the @volume. The reference is typically based on
	// the file system UUID for the volume in question and should be
	// considered an opaque string. Returns %NULL if there is no UUID
	// available.
	GetUuid() string
	// Mount wraps g_volume_mount
	// 
	// The function takes the following parameters:
	// 
	// 	- flags MountMountFlags: flags affecting the operation 
	// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid user interaction 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
	//
	// Mounts a volume. This is an asynchronous operation, and is
	// finished by calling g_volume_mount_finish() with the @volume
	// and #GAsyncResult returned in the @callback.
	Mount(MountMountFlags, MountOperation, Cancellable, AsyncReadyCallback)
	// MountFinish wraps g_volume_mount_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes mounting a volume. If any errors occurred during the operation,
	// @error will be set to contain the errors and %FALSE will be returned.
	// 
	// If the mount operation succeeded, g_volume_get_mount() on @volume
	// is guaranteed to return the mount right after calling this
	// function; there's no need to listen for the 'mount-added' signal on
	// #GVolumeMonitor.
	MountFinish(AsyncResult) (bool, error)
	// ShouldAutomount wraps g_volume_should_automount
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Returns whether the volume should be automatically mounted.
	ShouldAutomount() bool
	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Emitted when the volume has been changed.
	ConnectChanged(func(Volume)) gobject.SignalHandle
	// ConnectRemoved connects the provided callback to the "removed" signal
	//
	// This signal is emitted when the #GVolume have been removed. If
	// the recipient is holding references to the object they should
	// release them so the object can be finalized.
	ConnectRemoved(func(Volume)) gobject.SignalHandle
}

var _ Volume = (*VolumeInstance)(nil)

func unsafeWrapVolume(base *gobject.ObjectInstance) *VolumeInstance {
	return &VolumeInstance{
		Instance: *base,
	}
}

func marshalVolumeInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (v *VolumeInstance) upcastToGVolume() *VolumeInstance {
	return v
}

// UnsafeVolumeFromGlibNone is used to convert raw GVolume pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeFromGlibNone(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibNone(c).(Volume)
}

// UnsafeVolumeFromGlibFull is used to convert raw GVolume pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeFromGlibFull(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibFull(c).(Volume)
}

// UnsafeVolumeFromGlibBorrow is used to convert raw GVolume pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVolumeFromGlibBorrow(c unsafe.Pointer) Volume {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Volume)
}

// UnsafeVolumeToGlibNone is used to convert the instance to it's C value GVolume. This is used by the bindings internally.
func UnsafeVolumeToGlibNone(c Volume) unsafe.Pointer {
	i := c.upcastToGVolume()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeVolumeToGlibFull is used to convert the instance to it's C value GVolume, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVolumeToGlibFull(c Volume) unsafe.Pointer {
	i := c.upcastToGVolume()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// CanEject wraps g_volume_can_eject
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a volume can be ejected.
func (volume *VolumeInstance) CanEject() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_can_eject(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// CanMount wraps g_volume_can_mount
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a volume can be mounted.
func (volume *VolumeInstance) CanMount() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_can_mount(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Eject wraps g_volume_eject
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
//
// Ejects a volume. This is an asynchronous operation, and is
// finished by calling g_volume_eject_finish() with the @volume
// and #GAsyncResult returned in the @callback.
//
// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation() instead.
func (volume *VolumeInstance) Eject(flags MountUnmountFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountUnmountFlags(flags)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_eject(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectFinish wraps g_volume_eject_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
//
// Deprecated: (since 2.22.0) Use g_volume_eject_with_operation_finish() instead.
func (volume *VolumeInstance) EjectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_eject_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EjectWithOperation wraps g_volume_eject_with_operation
// 
// The function takes the following parameters:
// 
// 	- flags MountUnmountFlags: flags affecting the unmount if required for eject 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to
//     avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
//
// Ejects a volume. This is an asynchronous operation, and is
// finished by calling g_volume_eject_with_operation_finish() with the @volume
// and #GAsyncResult data returned in the @callback.
func (volume *VolumeInstance) EjectWithOperation(flags MountUnmountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountUnmountFlags  // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_eject_with_operation(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// EjectWithOperationFinish wraps g_volume_eject_with_operation_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes ejecting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
func (volume *VolumeInstance) EjectWithOperationFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_eject_with_operation_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// EnumerateIdentifiers wraps g_volume_enumerate_identifiers
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the kinds of [identifiers](#volume-identifiers) that @volume has.
// Use g_volume_get_identifier() to obtain the identifiers themselves.
func (volume *VolumeInstance) EnumerateIdentifiers() []string {
	var carg0 *C.GVolume // in, none, converted
	var cret  **C.char   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_enumerate_identifiers(carg0)
	runtime.KeepAlive(volume)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetActivationRoot wraps g_volume_get_activation_root
// 
// The function returns the following values:
// 
// 	- goret File (nullable) 
//
// Gets the activation root for a #GVolume if it is known ahead of
// mount time. Returns %NULL otherwise. If not %NULL and if @volume
// is mounted, then the result of g_mount_get_root() on the
// #GMount object obtained from g_volume_get_mount() will always
// either be equal or a prefix of what this function returns. In
// other words, in code
// 
// |[&lt;!-- language="C" --&gt;
//   GMount *mount;
//   GFile *mount_root
//   GFile *volume_activation_root;
// 
//   mount = g_volume_get_mount (volume); // mounted, so never NULL
//   mount_root = g_mount_get_root (mount);
//   volume_activation_root = g_volume_get_activation_root (volume); // assume not NULL
// ]|
// then the expression
// |[&lt;!-- language="C" --&gt;
//   (g_file_has_prefix (volume_activation_root, mount_root) ||
//    g_file_equal (volume_activation_root, mount_root))
// ]|
// will always be %TRUE.
// 
// Activation roots are typically used in #GVolumeMonitor
// implementations to find the underlying mount to shadow, see
// g_mount_is_shadowed() for more details.
func (volume *VolumeInstance) GetActivationRoot() File {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GFile   // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_activation_root(carg0)
	runtime.KeepAlive(volume)

	var goret File

	if cret != nil {
		goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetDrive wraps g_volume_get_drive
// 
// The function returns the following values:
// 
// 	- goret Drive (nullable) 
//
// Gets the drive for the @volume.
func (volume *VolumeInstance) GetDrive() Drive {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GDrive  // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_drive(carg0)
	runtime.KeepAlive(volume)

	var goret Drive

	if cret != nil {
		goret = UnsafeDriveFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetIcon wraps g_volume_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the icon for @volume.
func (volume *VolumeInstance) GetIcon() Icon {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GIcon   // return, full, converted

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_icon(carg0)
	runtime.KeepAlive(volume)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIdentifier wraps g_volume_get_identifier
// 
// The function takes the following parameters:
// 
// 	- kind string: the kind of identifier to return 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the identifier of the given kind for @volume.
// See the [introduction](#volume-identifiers) for more
// information about volume identifiers.
func (volume *VolumeInstance) GetIdentifier(kind string) string {
	var carg0 *C.GVolume // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  *C.char    // return, full, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(kind)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_get_identifier(carg0, carg1)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(kind)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetMount wraps g_volume_get_mount
// 
// The function returns the following values:
// 
// 	- goret Mount (nullable) 
//
// Gets the mount for the @volume.
func (volume *VolumeInstance) GetMount() Mount {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GMount  // return, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_mount(carg0)
	runtime.KeepAlive(volume)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetName wraps g_volume_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of @volume.
func (volume *VolumeInstance) GetName() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.char    // return, full, string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_name(carg0)
	runtime.KeepAlive(volume)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetSortKey wraps g_volume_get_sort_key
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the sort key for @volume, if any.
func (volume *VolumeInstance) GetSortKey() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_sort_key(carg0)
	runtime.KeepAlive(volume)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetSymbolicIcon wraps g_volume_get_symbolic_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the symbolic icon for @volume.
func (volume *VolumeInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.GIcon   // return, full, converted

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_symbolic_icon(carg0)
	runtime.KeepAlive(volume)

	var goret Icon

	goret = UnsafeIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetUuid wraps g_volume_get_uuid
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the UUID for the @volume. The reference is typically based on
// the file system UUID for the volume in question and should be
// considered an opaque string. Returns %NULL if there is no UUID
// available.
func (volume *VolumeInstance) GetUuid() string {
	var carg0 *C.GVolume // in, none, converted
	var cret  *C.char    // return, full, string, nullable-string

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_get_uuid(carg0)
	runtime.KeepAlive(volume)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Mount wraps g_volume_mount
// 
// The function takes the following parameters:
// 
// 	- flags MountMountFlags: flags affecting the operation 
// 	- mountOperation MountOperation (nullable): a #GMountOperation or %NULL to avoid user interaction 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback, or %NULL 
//
// Mounts a volume. This is an asynchronous operation, and is
// finished by calling g_volume_mount_finish() with the @volume
// and #GAsyncResult returned in the @callback.
func (volume *VolumeInstance) Mount(flags MountMountFlags, mountOperation MountOperation, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GVolume            // in, none, converted
	var carg1 C.GMountMountFlags    // in, none, casted
	var carg2 *C.GMountOperation    // in, none, converted, nullable
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = C.GMountMountFlags(flags)
	if mountOperation != nil {
		carg2 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(mountOperation))
	}
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_volume_mount(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// MountFinish wraps g_volume_mount_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes mounting a volume. If any errors occurred during the operation,
// @error will be set to contain the errors and %FALSE will be returned.
// 
// If the mount operation succeeded, g_volume_get_mount() on @volume
// is guaranteed to return the mount right after calling this
// function; there's no need to listen for the 'mount-added' signal on
// #GVolumeMonitor.
func (volume *VolumeInstance) MountFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GVolume      // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_volume_mount_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(volume)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ShouldAutomount wraps g_volume_should_automount
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the volume should be automatically mounted.
func (volume *VolumeInstance) ShouldAutomount() bool {
	var carg0 *C.GVolume // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	cret = C.g_volume_should_automount(carg0)
	runtime.KeepAlive(volume)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Emitted when the volume has been changed.
func (o *VolumeInstance) ConnectChanged(fn func(Volume)) gobject.SignalHandle {
	return o.Instance.Connect("changed", fn)
}

// ConnectRemoved connects the provided callback to the "removed" signal
//
// This signal is emitted when the #GVolume have been removed. If
// the recipient is holding references to the object they should
// release them so the object can be finalized.
func (o *VolumeInstance) ConnectRemoved(fn func(Volume)) gobject.SignalHandle {
	return o.Instance.Connect("removed", fn)
}

// DebugControllerInstance is the instance type used by all types implementing GDebugController. It is used internally by the bindings. Users should use the interface [DebugController] instead.
type DebugControllerInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DebugController = (*DebugControllerInstance)(nil)

// DebugController wraps GDebugController
//
// `GDebugController` is an interface to expose control of debugging features and
// debug output.
// 
// It is implemented on Linux using [class@Gio.DebugControllerDBus], which
// exposes a D-Bus interface to allow authenticated peers to control debug
// features in this process.
// 
// Whether debug output is enabled is exposed as
// [property@Gio.DebugController:debug-enabled]. This controls
// [func@GLib.log_set_debug_enabled] by default. Application code may
// connect to the [signal@GObject.Object::notify] signal for it
// to control other parts of its debug infrastructure as necessary.
// 
// If your application or service is using the default GLib log writer function,
// creating one of the built-in implementations of `GDebugController` should be
// all that&#x2019;s needed to dynamically enable or disable debug output.
type DebugController interface {
	upcastToGDebugController() *DebugControllerInstance

	// GetDebugEnabled wraps g_debug_controller_get_debug_enabled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Get the value of #GDebugController:debug-enabled.
	GetDebugEnabled() bool
	// SetDebugEnabled wraps g_debug_controller_set_debug_enabled
	// 
	// The function takes the following parameters:
	// 
	// 	- debugEnabled bool: %TRUE if debug output should be exposed, %FALSE otherwise 
	//
	// Set the value of #GDebugController:debug-enabled.
	SetDebugEnabled(bool)
}

var _ DebugController = (*DebugControllerInstance)(nil)

func unsafeWrapDebugController(base *gobject.ObjectInstance) *DebugControllerInstance {
	return &DebugControllerInstance{
		Instance: *base,
	}
}

func marshalDebugControllerInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DebugControllerInstance) upcastToGDebugController() *DebugControllerInstance {
	return d
}

// UnsafeDebugControllerFromGlibNone is used to convert raw GDebugController pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibNone(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibNone(c).(DebugController)
}

// UnsafeDebugControllerFromGlibFull is used to convert raw GDebugController pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibFull(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibFull(c).(DebugController)
}

// UnsafeDebugControllerFromGlibBorrow is used to convert raw GDebugController pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDebugControllerFromGlibBorrow(c unsafe.Pointer) DebugController {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DebugController)
}

// UnsafeDebugControllerToGlibNone is used to convert the instance to it's C value GDebugController. This is used by the bindings internally.
func UnsafeDebugControllerToGlibNone(c DebugController) unsafe.Pointer {
	i := c.upcastToGDebugController()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDebugControllerToGlibFull is used to convert the instance to it's C value GDebugController, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDebugControllerToGlibFull(c DebugController) unsafe.Pointer {
	i := c.upcastToGDebugController()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// GetDebugEnabled wraps g_debug_controller_get_debug_enabled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Get the value of #GDebugController:debug-enabled.
func (self *DebugControllerInstance) GetDebugEnabled() bool {
	var carg0 *C.GDebugController // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GDebugController)(UnsafeDebugControllerToGlibNone(self))

	cret = C.g_debug_controller_get_debug_enabled(carg0)
	runtime.KeepAlive(self)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetDebugEnabled wraps g_debug_controller_set_debug_enabled
// 
// The function takes the following parameters:
// 
// 	- debugEnabled bool: %TRUE if debug output should be exposed, %FALSE otherwise 
//
// Set the value of #GDebugController:debug-enabled.
func (self *DebugControllerInstance) SetDebugEnabled(debugEnabled bool) {
	var carg0 *C.GDebugController // in, none, converted
	var carg1 C.gboolean          // in

	carg0 = (*C.GDebugController)(UnsafeDebugControllerToGlibNone(self))
	if debugEnabled {
		carg1 = C.TRUE
	}

	C.g_debug_controller_set_debug_enabled(carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(debugEnabled)
}

// DtlsClientConnectionInstance is the instance type used by all types implementing GDtlsClientConnection. It is used internally by the bindings. Users should use the interface [DtlsClientConnection] instead.
type DtlsClientConnectionInstance struct {
	_ [0]func() // equal guard
	Instance gobject.ObjectInstance
}

var _ DtlsClientConnection = (*DtlsClientConnectionInstance)(nil)

// DtlsClientConnection wraps GDtlsClientConnection
//
// `GDtlsClientConnection` is the client-side subclass of
// [iface@Gio.DtlsConnection], representing a client-side DTLS connection.
type DtlsClientConnection interface {
	upcastToGDtlsClientConnection() *DtlsClientConnectionInstance

	// GetServerIdentity wraps g_dtls_client_connection_get_server_identity
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnectable 
	//
	// Gets @conn's expected server identity
	GetServerIdentity() SocketConnectable
	// GetValidationFlags wraps g_dtls_client_connection_get_validation_flags
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// Gets @conn's validation flags
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GDtlsClientConnection:validation-flags for more
	// information.
	//
	// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
	GetValidationFlags() TlsCertificateFlags
	// SetServerIdentity wraps g_dtls_client_connection_set_server_identity
	// 
	// The function takes the following parameters:
	// 
	// 	- identity SocketConnectable: a #GSocketConnectable describing the expected server identity 
	//
	// Sets @conn's expected server identity, which is used both to tell
	// servers on virtual hosts which certificate to present, and also
	// to let @conn know what name to look for in the certificate when
	// performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
	SetServerIdentity(SocketConnectable)
	// SetValidationFlags wraps g_dtls_client_connection_set_validation_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- flags TlsCertificateFlags: the #GTlsCertificateFlags to use 
	//
	// Sets @conn's validation flags, to override the default set of
	// checks performed when validating a server certificate. By default,
	// %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GDtlsClientConnection:validation-flags for more
	// information.
	//
	// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
	SetValidationFlags(TlsCertificateFlags)
}

var _ DtlsClientConnection = (*DtlsClientConnectionInstance)(nil)

func unsafeWrapDtlsClientConnection(base *gobject.ObjectInstance) *DtlsClientConnectionInstance {
	return &DtlsClientConnectionInstance{
		Instance: *base,
	}
}

func marshalDtlsClientConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

func (d *DtlsClientConnectionInstance) upcastToGDtlsClientConnection() *DtlsClientConnectionInstance {
	return d
}

// UnsafeDtlsClientConnectionFromGlibNone is used to convert raw GDtlsClientConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibNone(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionFromGlibFull is used to convert raw GDtlsClientConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibFull(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionFromGlibBorrow is used to convert raw GDtlsClientConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDtlsClientConnectionFromGlibBorrow(c unsafe.Pointer) DtlsClientConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DtlsClientConnection)
}

// UnsafeDtlsClientConnectionToGlibNone is used to convert the instance to it's C value GDtlsClientConnection. This is used by the bindings internally.
func UnsafeDtlsClientConnectionToGlibNone(c DtlsClientConnection) unsafe.Pointer {
	i := c.upcastToGDtlsClientConnection()
	return gobject.UnsafeObjectToGlibNone(&i.Instance)
}

// UnsafeDtlsClientConnectionToGlibFull is used to convert the instance to it's C value GDtlsClientConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionToGlibFull(c DtlsClientConnection) unsafe.Pointer {
	i := c.upcastToGDtlsClientConnection()
	return gobject.UnsafeObjectToGlibFull(&i.Instance)
}

// NewDtlsClientConnection wraps g_dtls_client_connection_new
// 
// The function takes the following parameters:
// 
// 	- baseSocket DatagramBased: the #GDatagramBased to wrap 
// 	- serverIdentity SocketConnectable (nullable): the expected identity of the server 
// 
// The function returns the following values:
// 
// 	- goret DtlsClientConnection 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GDtlsClientConnection wrapping @base_socket which is
// assumed to communicate with the server identified by @server_identity.
func NewDtlsClientConnection(baseSocket DatagramBased, serverIdentity SocketConnectable) (DtlsClientConnection, error) {
	var carg1 *C.GDatagramBased     // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, converted, nullable
	var cret  *C.GDatagramBased     // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.GDatagramBased)(UnsafeDatagramBasedToGlibNone(baseSocket))
	if serverIdentity != nil {
		carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(serverIdentity))
	}

	cret = C.g_dtls_client_connection_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(baseSocket)
	runtime.KeepAlive(serverIdentity)

	var goret  DtlsClientConnection
	var _goerr error

	goret = UnsafeDtlsClientConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetServerIdentity wraps g_dtls_client_connection_get_server_identity
// 
// The function returns the following values:
// 
// 	- goret SocketConnectable 
//
// Gets @conn's expected server identity
func (conn *DtlsClientConnectionInstance) GetServerIdentity() SocketConnectable {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var cret  *C.GSocketConnectable    // return, none, converted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))

	cret = C.g_dtls_client_connection_get_server_identity(carg0)
	runtime.KeepAlive(conn)

	var goret SocketConnectable

	goret = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetValidationFlags wraps g_dtls_client_connection_get_validation_flags
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// Gets @conn's validation flags
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GDtlsClientConnection:validation-flags for more
// information.
//
// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
func (conn *DtlsClientConnectionInstance) GetValidationFlags() TlsCertificateFlags {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var cret  C.GTlsCertificateFlags   // return, none, casted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))

	cret = C.g_dtls_client_connection_get_validation_flags(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetServerIdentity wraps g_dtls_client_connection_set_server_identity
// 
// The function takes the following parameters:
// 
// 	- identity SocketConnectable: a #GSocketConnectable describing the expected server identity 
//
// Sets @conn's expected server identity, which is used both to tell
// servers on virtual hosts which certificate to present, and also
// to let @conn know what name to look for in the certificate when
// performing %G_TLS_CERTIFICATE_BAD_IDENTITY validation, if enabled.
func (conn *DtlsClientConnectionInstance) SetServerIdentity(identity SocketConnectable) {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var carg1 *C.GSocketConnectable    // in, none, converted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))

	C.g_dtls_client_connection_set_server_identity(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(identity)
}

// SetValidationFlags wraps g_dtls_client_connection_set_validation_flags
// 
// The function takes the following parameters:
// 
// 	- flags TlsCertificateFlags: the #GTlsCertificateFlags to use 
//
// Sets @conn's validation flags, to override the default set of
// checks performed when validating a server certificate. By default,
// %G_TLS_CERTIFICATE_VALIDATE_ALL is used.
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GDtlsClientConnection:validation-flags for more
// information.
//
// Deprecated: (since 2.74.0) Do not attempt to ignore validation errors.
func (conn *DtlsClientConnectionInstance) SetValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GDtlsClientConnection // in, none, converted
	var carg1 C.GTlsCertificateFlags   // in, none, casted

	carg0 = (*C.GDtlsClientConnection)(UnsafeDtlsClientConnectionToGlibNone(conn))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_dtls_client_connection_set_validation_flags(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(flags)
}

// AppInfoMonitorInstance is the instance type used by all types extending GAppInfoMonitor. It is used internally by the bindings. Users should use the interface [AppInfoMonitor] instead.
type AppInfoMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ AppInfoMonitor = (*AppInfoMonitorInstance)(nil)

// AppInfoMonitor wraps GAppInfoMonitor
//
// `GAppInfoMonitor` monitors application information for changes.
// 
// `GAppInfoMonitor` is a very simple object used for monitoring the app
// info database for changes (newly installed or removed applications).
// 
// Call [func@Gio.AppInfoMonitor.get] to get a `GAppInfoMonitor` and connect
// to the [signal@Gio.AppInfoMonitor::changed] signal. The signal will be emitted once when
// the app info database changes, and will not be emitted again until after the
// next call to [func@Gio.AppInfo.get_all] or another `g_app_info_*()` function.
// This is because monitoring the app info database for changes is expensive.
// 
// The following functions will re-arm the [signal@Gio.AppInfoMonitor::changed]
// signal so it can be emitted again:
// 
//  - [func@Gio.AppInfo.get_all]
//  - [func@Gio.AppInfo.get_all_for_type]
//  - [func@Gio.AppInfo.get_default_for_type]
//  - [func@Gio.AppInfo.get_fallback_for_type]
//  - [func@Gio.AppInfo.get_recommended_for_type]
//  - [`g_desktop_app_info_get_implementations()`](../gio-unix/type_func.DesktopAppInfo.get_implementation.html)
//  - [`g_desktop_app_info_new()`](../gio-unix/ctor.DesktopAppInfo.new.html)
//  - [`g_desktop_app_info_new_from_filename()`](../gio-unix/ctor.DesktopAppInfo.new_from_filename.html)
//  - [`g_desktop_app_info_new_from_keyfile()`](../gio-unix/ctor.DesktopAppInfo.new_from_keyfile.html)
//  - [`g_desktop_app_info_search()`](../gio-unix/type_func.DesktopAppInfo.search.html)
// 
// The latter functions are available if using
// [`GDesktopAppInfo`](../gio-unix/class.DesktopAppInfo.html) from
// `gio-unix-2.0.pc` (GIR namespace `GioUnix-2.0`).
// 
// In the usual case, applications should try to make note of the change
// (doing things like invalidating caches) but not act on it. In
// particular, applications should avoid making calls to `GAppInfo` APIs
// in response to the change signal, deferring these until the time that
// the updated data is actually required. The exception to this case is when
// application information is actually being displayed on the screen
// (for example, during a search or when the list of all applications is shown).
// The reason for this is that changes to the list of installed applications
// often come in groups (like during system updates) and rescanning the list
// on every change is pointless and expensive.
type AppInfoMonitor interface {
	gobject.Object
	upcastToGAppInfoMonitor() *AppInfoMonitorInstance

	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Signal emitted when the app info database changes, when applications are
	// installed or removed.
	ConnectChanged(func(AppInfoMonitor)) gobject.SignalHandle
}

func unsafeWrapAppInfoMonitor(base *gobject.ObjectInstance) *AppInfoMonitorInstance {
	return &AppInfoMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeAppInfoMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppInfoMonitor(inst)
		},
	)
}

func marshalAppInfoMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeAppInfoMonitorFromGlibNone is used to convert raw GAppInfoMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibNone(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(AppInfoMonitor)
}

// UnsafeAppInfoMonitorFromGlibFull is used to convert raw GAppInfoMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibFull(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(AppInfoMonitor)
}

// UnsafeAppInfoMonitorFromGlibBorrow is used to convert raw GAppInfoMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppInfoMonitorFromGlibBorrow(c unsafe.Pointer) AppInfoMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppInfoMonitor)
}

func (a *AppInfoMonitorInstance) upcastToGAppInfoMonitor() *AppInfoMonitorInstance {
	return a
}

// UnsafeAppInfoMonitorToGlibNone is used to convert the instance to it's C value GAppInfoMonitor. This is used by the bindings internally.
func UnsafeAppInfoMonitorToGlibNone(c AppInfoMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeAppInfoMonitorToGlibFull is used to convert the instance to it's C value GAppInfoMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppInfoMonitorToGlibFull(c AppInfoMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// AppInfoMonitorGet wraps g_app_info_monitor_get
// 
// The function returns the following values:
// 
// 	- goret AppInfoMonitor 
//
// Gets the #GAppInfoMonitor for the current thread-default main
// context.
// 
// The #GAppInfoMonitor will emit a &#x201C;changed&#x201D; signal in the
// thread-default main context whenever the list of installed
// applications (as reported by g_app_info_get_all()) may have changed.
// 
// The #GAppInfoMonitor::changed signal will only be emitted once until
// g_app_info_get_all() (or another `g_app_info_*()` function) is called. Doing
// so will re-arm the signal ready to notify about the next change.
// 
// You must only call g_object_unref() on the return value from under
// the same main context as you created it.
func AppInfoMonitorGet() AppInfoMonitor {
	var cret *C.GAppInfoMonitor // return, full, converted

	cret = C.g_app_info_monitor_get()

	var goret AppInfoMonitor

	goret = UnsafeAppInfoMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Signal emitted when the app info database changes, when applications are
// installed or removed.
func (o *AppInfoMonitorInstance) ConnectChanged(fn func(AppInfoMonitor)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// AppLaunchContextInstance is the instance type used by all types extending GAppLaunchContext. It is used internally by the bindings. Users should use the interface [AppLaunchContext] instead.
type AppLaunchContextInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ AppLaunchContext = (*AppLaunchContextInstance)(nil)

// AppLaunchContext wraps GAppLaunchContext
//
// Integrating the launch with the launching application. This is used to
// handle for instance startup notification and launching the new application
// on the same screen as the launching window.
type AppLaunchContext interface {
	gobject.Object
	upcastToGAppLaunchContext() *AppLaunchContextInstance

	// GetEnvironment wraps g_app_launch_context_get_environment
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the complete environment variable list to be passed to
	// the child process when @context is used to launch an application.
	// This is a `NULL`-terminated array of strings, where each string has
	// the form `KEY=VALUE`.
	GetEnvironment() []string
	// LaunchFailed wraps g_app_launch_context_launch_failed
	// 
	// The function takes the following parameters:
	// 
	// 	- startupNotifyId string: the startup notification id that was returned by
	//   [method@Gio.AppLaunchContext.get_startup_notify_id]. 
	//
	// Called when an application has failed to launch, so that it can cancel
	// the application startup notification started in
	// [method@Gio.AppLaunchContext.get_startup_notify_id].
	LaunchFailed(string)
	// Setenv wraps g_app_launch_context_setenv
	// 
	// The function takes the following parameters:
	// 
	// 	- variable string: the environment variable to set 
	// 	- value string: the value for to set the variable to. 
	//
	// Arranges for @variable to be set to @value in the child&#x2019;s environment when
	// @context is used to launch an application.
	Setenv(string, string)
	// Unsetenv wraps g_app_launch_context_unsetenv
	// 
	// The function takes the following parameters:
	// 
	// 	- variable string: the environment variable to remove 
	//
	// Arranges for @variable to be unset in the child&#x2019;s environment when @context
	// is used to launch an application.
	Unsetenv(string)
	// ConnectLaunchFailed connects the provided callback to the "launch-failed" signal
	//
	// The [signal@Gio.AppLaunchContext::launch-failed] signal is emitted when a
	// [iface@Gio.AppInfo] launch fails. The startup notification id is provided,
	// so that the launcher can cancel the startup notification.
	// 
	// Because a launch operation may involve spawning multiple instances of the
	// target application, you should expect this signal to be emitted multiple
	// times, one for each spawned instance.
	ConnectLaunchFailed(func(AppLaunchContext, string)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentLaunchFailed calls the default implementations of the `GAppLaunchContext.launch_failed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- startupNotifyId string: the startup notification id that was returned by
	//   [method@Gio.AppLaunchContext.get_startup_notify_id]. 
	//
	// Called when an application has failed to launch, so that it can cancel
	// the application startup notification started in
	// [method@Gio.AppLaunchContext.get_startup_notify_id].
	ParentLaunchFailed(startupNotifyId string)
}

func unsafeWrapAppLaunchContext(base *gobject.ObjectInstance) *AppLaunchContextInstance {
	return &AppLaunchContextInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeAppLaunchContext,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppLaunchContext(inst)
		},
	)
}

func marshalAppLaunchContextInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeAppLaunchContextFromGlibNone is used to convert raw GAppLaunchContext pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibNone(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibNone(c).(AppLaunchContext)
}

// UnsafeAppLaunchContextFromGlibFull is used to convert raw GAppLaunchContext pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibFull(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibFull(c).(AppLaunchContext)
}

// UnsafeAppLaunchContextFromGlibBorrow is used to convert raw GAppLaunchContext pointers to go without touching any references. This is used by the bindings internally.
func UnsafeAppLaunchContextFromGlibBorrow(c unsafe.Pointer) AppLaunchContext {
	return gobject.UnsafeObjectFromGlibBorrow(c).(AppLaunchContext)
}

func (a *AppLaunchContextInstance) upcastToGAppLaunchContext() *AppLaunchContextInstance {
	return a
}

// UnsafeAppLaunchContextToGlibNone is used to convert the instance to it's C value GAppLaunchContext. This is used by the bindings internally.
func UnsafeAppLaunchContextToGlibNone(c AppLaunchContext) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeAppLaunchContextToGlibFull is used to convert the instance to it's C value GAppLaunchContext, while removeing the finalizer. This is used by the bindings internally.
func UnsafeAppLaunchContextToGlibFull(c AppLaunchContext) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewAppLaunchContext wraps g_app_launch_context_new
// 
// The function returns the following values:
// 
// 	- goret AppLaunchContext 
//
// Creates a new application launch context. This is not normally used,
// instead you instantiate a subclass of this, such as
// [`GdkAppLaunchContext`](https://docs.gtk.org/gdk4/class.AppLaunchContext.html).
func NewAppLaunchContext() AppLaunchContext {
	var cret *C.GAppLaunchContext // return, full, converted

	cret = C.g_app_launch_context_new()

	var goret AppLaunchContext

	goret = UnsafeAppLaunchContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetEnvironment wraps g_app_launch_context_get_environment
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the complete environment variable list to be passed to
// the child process when @context is used to launch an application.
// This is a `NULL`-terminated array of strings, where each string has
// the form `KEY=VALUE`.
func (_context *AppLaunchContextInstance) GetEnvironment() []string {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var cret  **C.char             // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))

	cret = C.g_app_launch_context_get_environment(carg0)
	runtime.KeepAlive(_context)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// LaunchFailed wraps g_app_launch_context_launch_failed
// 
// The function takes the following parameters:
// 
// 	- startupNotifyId string: the startup notification id that was returned by
//   [method@Gio.AppLaunchContext.get_startup_notify_id]. 
//
// Called when an application has failed to launch, so that it can cancel
// the application startup notification started in
// [method@Gio.AppLaunchContext.get_startup_notify_id].
func (_context *AppLaunchContextInstance) LaunchFailed(startupNotifyId string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_launch_context_launch_failed(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(startupNotifyId)
}

// Setenv wraps g_app_launch_context_setenv
// 
// The function takes the following parameters:
// 
// 	- variable string: the environment variable to set 
// 	- value string: the value for to set the variable to. 
//
// Arranges for @variable to be set to @value in the child&#x2019;s environment when
// @context is used to launch an application.
func (_context *AppLaunchContextInstance) Setenv(variable string, value string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_app_launch_context_setenv(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
}

// Unsetenv wraps g_app_launch_context_unsetenv
// 
// The function takes the following parameters:
// 
// 	- variable string: the environment variable to remove 
//
// Arranges for @variable to be unset in the child&#x2019;s environment when @context
// is used to launch an application.
func (_context *AppLaunchContextInstance) Unsetenv(variable string) {
	var carg0 *C.GAppLaunchContext // in, none, converted
	var carg1 *C.char              // in, none, string

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_app_launch_context_unsetenv(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(variable)
}

// ConnectLaunchFailed connects the provided callback to the "launch-failed" signal
//
// The [signal@Gio.AppLaunchContext::launch-failed] signal is emitted when a
// [iface@Gio.AppInfo] launch fails. The startup notification id is provided,
// so that the launcher can cancel the startup notification.
// 
// Because a launch operation may involve spawning multiple instances of the
// target application, you should expect this signal to be emitted multiple
// times, one for each spawned instance.
func (o *AppLaunchContextInstance) ConnectLaunchFailed(fn func(AppLaunchContext, string)) gobject.SignalHandle {
	return o.Connect("launch-failed", fn)
}

// AppLaunchContextOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type AppLaunchContextOverrides[Instance AppLaunchContext] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // LaunchFailed allows you to override the implementation of the virtual method launch_failed.
	// 
	// The function takes the following parameters:
	// 
	// 	- startupNotifyId string: the startup notification id that was returned by
	//   [method@Gio.AppLaunchContext.get_startup_notify_id]. 
	//
	// Called when an application has failed to launch, so that it can cancel
	// the application startup notification started in
	// [method@Gio.AppLaunchContext.get_startup_notify_id].
	LaunchFailed func(Instance, string)
}

// UnsafeApplyAppLaunchContextOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyAppLaunchContextOverrides[Instance AppLaunchContext](gclass unsafe.Pointer, overrides AppLaunchContextOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GAppLaunchContextClass)(gclass)

	if overrides.LaunchFailed != nil {
		pclass.launch_failed = (*[0]byte)(C._goglib_gio2_AppLaunchContext_launch_failed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_AppLaunchContext_launch_failed",
			func(carg0 *C.GAppLaunchContext, carg1 *C.char) {
				var _context        Instance // go GAppLaunchContext subclass
				var startupNotifyId string   // in, none, string

				_context = UnsafeAppLaunchContextFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				startupNotifyId = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.LaunchFailed(_context, startupNotifyId)
			},
		)
	}
}

// ParentLaunchFailed calls the default implementations of the `GAppLaunchContext.launch_failed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- startupNotifyId string: the startup notification id that was returned by
//   [method@Gio.AppLaunchContext.get_startup_notify_id]. 
//
// Called when an application has failed to launch, so that it can cancel
// the application startup notification started in
// [method@Gio.AppLaunchContext.get_startup_notify_id].
func (_context *AppLaunchContextInstance) ParentLaunchFailed(startupNotifyId string) {
	var carg0 *C.GAppLaunchContext
	var carg1 *C.char // in, none, converted

	parentclass := (*C.GAppLaunchContextClass)(classdata.PeekParentClass(UnsafeAppLaunchContextToGlibNone(_context)))

	carg0 = (*C.GAppLaunchContext)(UnsafeAppLaunchContextToGlibNone(_context))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_AppLaunchContext_virtual_launch_failed(unsafe.Pointer(parentclass.launch_failed), carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(startupNotifyId)
}

// RegisterAppLaunchContextSubClass is used to register a go subclass of GAppLaunchContext. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterAppLaunchContextSubClass[InstanceT AppLaunchContext](
		name string,
		classInit func(class *AppLaunchContextClass),
		constructor func() InstanceT,
		overrides AppLaunchContextOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeAppLaunchContext,
		UnsafeAppLaunchContextClassFromGlibBorrow,
		UnsafeApplyAppLaunchContextOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapAppLaunchContext(obj)
		},
		interfaceInits...,
	)
}

// ApplicationInstance is the instance type used by all types extending GApplication. It is used internally by the bindings. Users should use the interface [Application] instead.
type ApplicationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Application = (*ApplicationInstance)(nil)

// Application wraps GApplication
//
// `GApplication` is the core class for application support.
// 
// A `GApplication` is the foundation of an application. It wraps some
// low-level platform-specific services and is intended to act as the
// foundation for higher-level application classes such as
// `GtkApplication` or `MxApplication`. In general, you should not use
// this class outside of a higher level framework.
// 
// `GApplication` provides convenient life-cycle management by maintaining
// a "use count" for the primary application instance. The use count can
// be changed using [method@Gio.Application.hold] and
// [method@Gio.Application.release]. If it drops to zero, the application
// exits. Higher-level classes such as `GtkApplication` employ the use count
// to ensure that the application stays alive as long as it has any opened
// windows.
// 
// Another feature that `GApplication` (optionally) provides is process
// uniqueness. Applications can make use of this functionality by
// providing a unique application ID. If given, only one application
// with this ID can be running at a time per session. The session
// concept is platform-dependent, but corresponds roughly to a graphical
// desktop login. When your application is launched again, its
// arguments are passed through platform communication to the already
// running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is
// always the current instance. On Linux, the D-Bus session bus
// is used for communication.
// 
// The use of `GApplication` differs from some other commonly-used
// uniqueness libraries (such as libunique) in important ways. The
// application is not expected to manually register itself and check
// if it is the primary instance. Instead, the main() function of a
// `GApplication` should do very little more than instantiating the
// application instance, possibly connecting signal handlers, then
// calling [method@Gio.Application.run]. All checks for uniqueness are done
// internally. If the application is the primary instance then the
// startup signal is emitted and the mainloop runs. If the application
// is not the primary instance then a signal is sent to the primary
// instance and [method@Gio.Application.run] promptly returns. See the code
// examples below.
// 
// If used, the expected form of an application identifier is the
// same as that of a
// [D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
// `org._7_zip.Archiver`.
// For details on valid application identifiers, see [func@Gio.Application.id_is_valid].
// 
// On Linux, the application identifier is claimed as a well-known bus name
// on the user's session bus. This means that the uniqueness of your
// application is scoped to the current session. It also means that your
// application may provide additional services (through registration of other
// object paths) at that bus name. The registration of these object paths
// should be done with the shared GDBus session bus. Note that due to the
// internal architecture of GDBus, method calls can be dispatched at any time
// (even if a main loop is not running). For this reason, you must ensure that
// any object paths that you wish to register are registered before #GApplication
// attempts to acquire the bus name of your application (which happens in
// [method@Gio.Application.register]). Unfortunately, this means that you cannot
// use [property@Gio.Application:is-remote] to decide if you want to register
// object paths.
// 
// `GApplication` also implements the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
// interfaces and lets you easily export actions by adding them with
// [method@Gio.ActionMap.add_action]. When invoking an action by calling
// [method@Gio.ActionGroup.activate_action] on the application, it is always
// invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the [class@Gio.DBusActionGroup] wrapper to
// conveniently access them remotely. GIO provides a [class@Gio.DBusMenuModel] wrapper
// for remote access to exported [class@Gio.MenuModel]s.
// 
// Note: Due to the fact that actions are exported on the session bus,
// using `maybe` parameters is not supported, since D-Bus does not support
// `maybe` types.
// 
// There is a number of different entry points into a `GApplication`:
// 
// - via 'Activate' (i.e. just starting the application)
// 
// - via 'Open' (i.e. opening some files)
// 
// - by handling a command-line
// 
// - via activating an action
// 
// The [signal@Gio.Application::startup] signal lets you handle the application
// initialization for all of these in a single place.
// 
// Regardless of which of these entry points is used to start the
// application, `GApplication` passes some &#x2018;platform data&#x2019; from the
// launching instance to the primary instance, in the form of a
// [struct@GLib.Variant] dictionary mapping strings to variants. To use platform
// data, override the [vfunc@Gio.Application.before_emit] or
// [vfunc@Gio.Application.after_emit] virtual functions
// in your `GApplication` subclass. When dealing with
// [class@Gio.ApplicationCommandLine] objects, the platform data is
// directly available via [method@Gio.ApplicationCommandLine.get_cwd],
// [method@Gio.ApplicationCommandLine.get_environ] and
// [method@Gio.ApplicationCommandLine.get_platform_data].
// 
// As the name indicates, the platform data may vary depending on the
// operating system, but it always includes the current directory (key
// `cwd`), and optionally the environment (ie the set of environment
// variables and their values) of the calling process (key `environ`).
// The environment is only added to the platform data if the
// `G_APPLICATION_SEND_ENVIRONMENT` flag is set. `GApplication` subclasses
// can add their own platform data by overriding the
// [vfunc@Gio.Application.add_platform_data] virtual function. For instance,
// `GtkApplication` adds startup notification data in this way.
// 
// To parse commandline arguments you may handle the
// [signal@Gio.Application::command-line] signal or override the
// [vfunc@Gio.Application.local_command_line] virtual function, to parse them in
// either the primary instance or the local instance, respectively.
// 
// For an example of opening files with a `GApplication`, see
// [gapplication-example-open.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-open.c).
// 
// For an example of using actions with `GApplication`, see
// [gapplication-example-actions.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-actions.c).
// 
// For an example of using extra D-Bus hooks with `GApplication`, see
// [gapplication-example-dbushooks.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-dbushooks.c).
type Application interface {
	gobject.Object
	upcastToGApplication() *ApplicationInstance

	// Activate wraps g_application_activate
	//
	// Activates the application.
	// 
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	// 
	// The application must be registered before calling this function.
	Activate()
	// AddMainOption wraps g_application_add_main_option
	// 
	// The function takes the following parameters:
	// 
	// 	- longName string: the long name of an option used to specify it in a commandline 
	// 	- shortName byte: the short name of an option 
	// 	- flags glib.OptionFlags: flags from #GOptionFlags 
	// 	- arg glib.OptionArg: the type of the option, as a #GOptionArg 
	// 	- description string: the description for the option in `--help` output 
	// 	- argDescription string (nullable): the placeholder to use for the extra argument
	//    parsed by the option in `--help` output 
	//
	// Add an option to be handled by @application.
	// 
	// Calling this function is the equivalent of calling
	// g_application_add_main_option_entries() with a single #GOptionEntry
	// that has its arg_data member set to %NULL.
	// 
	// The parsed arguments will be packed into a #GVariantDict which
	// is passed to #GApplication::handle-local-options. If
	// %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
	// be sent to the primary instance. See
	// g_application_add_main_option_entries() for more details.
	// 
	// See #GOptionEntry for more documentation of the arguments.
	AddMainOption(string, byte, glib.OptionFlags, glib.OptionArg, string, string)
	// AddMainOptionEntries wraps g_application_add_main_option_entries
	// 
	// The function takes the following parameters:
	// 
	// 	- entries []glib.OptionEntry: the
	//   main options for the application 
	//
	// Adds main option entries to be handled by @application.
	// 
	// This function is comparable to g_option_context_add_main_entries().
	// 
	// After the commandline arguments are parsed, the
	// #GApplication::handle-local-options signal will be emitted.  At this
	// point, the application can inspect the values pointed to by @arg_data
	// in the given #GOptionEntrys.
	// 
	// Unlike #GOptionContext, #GApplication supports giving a %NULL
	// @arg_data for a non-callback #GOptionEntry.  This results in the
	// argument in question being packed into a #GVariantDict which is also
	// passed to #GApplication::handle-local-options, where it can be
	// inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
	// set, then the resulting dictionary is sent to the primary instance,
	// where g_application_command_line_get_options_dict() will return it.
	// As it has been passed outside the process at this point, the types of all
	// values in the options dict must be checked before being used.
	// This "packing" is done according to the type of the argument --
	// booleans for normal flags, strings for strings, bytestrings for
	// filenames, etc.  The packing only occurs if the flag is given (ie: we
	// do not pack a "false" #GVariant in the case that a flag is missing).
	// 
	// In general, it is recommended that all commandline arguments are
	// parsed locally.  The options dictionary should then be used to
	// transmit the result of the parsing to the primary instance, where
	// g_variant_dict_lookup() can be used.  For local options, it is
	// possible to either use @arg_data in the usual way, or to consult (and
	// potentially remove) the option from the options dictionary.
	// 
	// This function is new in GLib 2.40.  Before then, the only real choice
	// was to send all of the commandline arguments (options and all) to the
	// primary instance for handling.  #GApplication ignored them completely
	// on the local side.  Calling this function "opts in" to the new
	// behaviour, and in particular, means that unrecognized options will be
	// treated as errors.  Unrecognized options have never been ignored when
	// %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
	// 
	// If #GApplication::handle-local-options needs to see the list of
	// filenames, then the use of %G_OPTION_REMAINING is recommended.  If
	// @arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
	// the options dictionary.  If you do use %G_OPTION_REMAINING then you
	// need to handle these arguments for yourself because once they are
	// consumed, they will no longer be visible to the default handling
	// (which treats them as filenames to be opened).
	// 
	// It is important to use the proper GVariant format when retrieving
	// the options with g_variant_dict_lookup():
	// - for %G_OPTION_ARG_NONE, use `b`
	// - for %G_OPTION_ARG_STRING, use `&amp;s`
	// - for %G_OPTION_ARG_INT, use `i`
	// - for %G_OPTION_ARG_INT64, use `x`
	// - for %G_OPTION_ARG_DOUBLE, use `d`
	// - for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
	// - for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
	// - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`
	AddMainOptionEntries([]glib.OptionEntry)
	// AddOptionGroup wraps g_application_add_option_group
	// 
	// The function takes the following parameters:
	// 
	// 	- group *glib.OptionGroup: a #GOptionGroup 
	//
	// Adds a #GOptionGroup to the commandline handling of @application.
	// 
	// This function is comparable to g_option_context_add_group().
	// 
	// Unlike g_application_add_main_option_entries(), this function does
	// not deal with %NULL @arg_data and never transmits options to the
	// primary instance.
	// 
	// The reason for that is because, by the time the options arrive at the
	// primary instance, it is typically too late to do anything with them.
	// Taking the GTK option group as an example: GTK will already have been
	// initialised by the time the #GApplication::command-line handler runs.
	// In the case that this is not the first-running instance of the
	// application, the existing instance may already have been running for
	// a very long time.
	// 
	// This means that the options from #GOptionGroup are only really usable
	// in the case that the instance of the application being run is the
	// first instance.  Passing options like `--display=` or `--gdk-debug=`
	// on future runs will have no effect on the existing primary instance.
	// 
	// Calling this function will cause the options in the supplied option
	// group to be parsed, but it does not cause you to be "opted in" to the
	// new functionality whereby unrecognized options are rejected even if
	// %G_APPLICATION_HANDLES_COMMAND_LINE was given.
	AddOptionGroup(*glib.OptionGroup)
	// GetApplicationID wraps g_application_get_application_id
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the unique identifier for @application.
	GetApplicationID() string
	// GetDBusObjectPath wraps g_application_get_dbus_object_path
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the D-Bus object path being used by the application, or %NULL.
	// 
	// If #GApplication is using its D-Bus backend then this function will
	// return the D-Bus object path that #GApplication is using.  If the
	// application is the primary instance then there is an object published
	// at this path.  If the application is not the primary instance then
	// the result of this function is undefined.
	// 
	// If #GApplication is not using D-Bus then this function will return
	// %NULL.  This includes the situation where the D-Bus backend would
	// normally be in use but we were unable to connect to the bus.
	// 
	// This function must not be called before the application has been
	// registered.  See g_application_get_is_registered().
	GetDBusObjectPath() string
	// GetFlags wraps g_application_get_flags
	// 
	// The function returns the following values:
	// 
	// 	- goret ApplicationFlags 
	//
	// Gets the flags for @application.
	// 
	// See #GApplicationFlags.
	GetFlags() ApplicationFlags
	// GetInactivityTimeout wraps g_application_get_inactivity_timeout
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the current inactivity timeout for the application.
	// 
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	GetInactivityTimeout() uint
	// GetIsBusy wraps g_application_get_is_busy
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the application's current busy state, as set through
	// g_application_mark_busy() or g_application_bind_busy_property().
	GetIsBusy() bool
	// GetIsRegistered wraps g_application_get_is_registered
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @application is registered.
	// 
	// An application is registered if g_application_register() has been
	// successfully called.
	GetIsRegistered() bool
	// GetIsRemote wraps g_application_get_is_remote
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @application is remote.
	// 
	// If @application is remote then it means that another instance of
	// application already exists (the 'primary' instance).  Calls to
	// perform actions on @application will result in the actions being
	// performed by the primary instance.
	// 
	// The value of this property cannot be accessed before
	// g_application_register() has been called.  See
	// g_application_get_is_registered().
	GetIsRemote() bool
	// GetResourceBasePath wraps g_application_get_resource_base_path
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the resource base path of @application.
	// 
	// See g_application_set_resource_base_path() for more information.
	GetResourceBasePath() string
	// GetVersion wraps g_application_get_version
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the version of @application.
	GetVersion() string
	// Hold wraps g_application_hold
	//
	// Increases the use count of @application.
	// 
	// Use this function to indicate that the application has a reason to
	// continue to run.  For example, g_application_hold() is called by GTK
	// when a toplevel window is on the screen.
	// 
	// To cancel the hold, call g_application_release().
	Hold()
	// MarkBusy wraps g_application_mark_busy
	//
	// Increases the busy count of @application.
	// 
	// Use this function to indicate that the application is busy, for instance
	// while a long running operation is pending.
	// 
	// The busy state will be exposed to other processes, so a session shell will
	// use that information to indicate the state to the user (e.g. with a
	// spinner).
	// 
	// To cancel the busy indication, use g_application_unmark_busy().
	// 
	// The application must be registered before calling this function.
	MarkBusy()
	// Open wraps g_application_open
	// 
	// The function takes the following parameters:
	// 
	// 	- files []File: an array of #GFiles to open 
	// 	- hint string: a hint (or ""), but never %NULL 
	//
	// Opens the given files.
	// 
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	// 
	// @n_files must be greater than zero.
	// 
	// @hint is simply passed through to the ::open signal.  It is
	// intended to be used by applications that have multiple modes for
	// opening files (eg: "view" vs "edit", etc).  Unless you have a need
	// for this functionality, you should use "".
	// 
	// The application must be registered before calling this function
	// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
	Open([]File, string)
	// Quit wraps g_application_quit
	//
	// Immediately quits the application.
	// 
	// Upon return to the mainloop, g_application_run() will return,
	// calling only the 'shutdown' function before doing so.
	// 
	// The hold count is ignored.
	// Take care if your code has called g_application_hold() on the application and
	// is therefore still expecting it to exist.
	// (Note that you may have called g_application_hold() indirectly, for example
	// through gtk_application_add_window().)
	// 
	// The result of calling g_application_run() again after it returns is
	// unspecified.
	Quit()
	// Register wraps g_application_register
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts registration of the application.
	// 
	// This is the point at which the application discovers if it is the
	// primary instance or merely acting as a remote for an already-existing
	// primary instance.  This is implemented by attempting to acquire the
	// application identifier as a unique bus name on the session bus using
	// GDBus.
	// 
	// If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
	// given, then this process will always become the primary instance.
	// 
	// Due to the internal architecture of GDBus, method calls can be
	// dispatched at any time (even if a main loop is not running).  For
	// this reason, you must ensure that any object paths that you wish to
	// register are registered before calling this function.
	// 
	// If the application has already been registered then %TRUE is
	// returned with no work performed.
	// 
	// The #GApplication::startup signal is emitted if registration succeeds
	// and @application is the primary instance (including the non-unique
	// case).
	// 
	// In the event of an error (such as @cancellable being cancelled, or a
	// failure to connect to the session bus), %FALSE is returned and @error
	// is set appropriately.
	// 
	// Note: the return value of this function is not an indicator that this
	// instance is or is not the primary instance of the application.  See
	// g_application_get_is_remote() for that.
	Register(Cancellable) (bool, error)
	// Release wraps g_application_release
	//
	// Decrease the use count of @application.
	// 
	// When the use count reaches zero, the application will stop running.
	// 
	// Never call this function except to cancel the effect of a previous
	// call to g_application_hold().
	Release()
	// Run wraps g_application_run
	// 
	// The function takes the following parameters:
	// 
	// 	- argv []string (nullable): 
	//     the argv from main(), or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Runs the application.
	// 
	// This function is intended to be run from main() and its return value
	// is intended to be returned by main(). Although you are expected to pass
	// the @argc, @argv parameters from main() to this function, it is possible
	// to pass %NULL if @argv is not available or commandline handling is not
	// required.  Note that on Windows, @argc and @argv are ignored, and
	// g_win32_get_command_line() is called internally (for proper support
	// of Unicode commandline arguments).
	// 
	// #GApplication will attempt to parse the commandline arguments.  You
	// can add commandline flags to the list of recognised options by way of
	// g_application_add_main_option_entries().  After this, the
	// #GApplication::handle-local-options signal is emitted, from which the
	// application can inspect the values of its #GOptionEntrys.
	// 
	// #GApplication::handle-local-options is a good place to handle options
	// such as `--version`, where an immediate reply from the local process is
	// desired (instead of communicating with an already-running instance).
	// A #GApplication::handle-local-options handler can stop further processing
	// by returning a non-negative value, which then becomes the exit status of
	// the process.
	// 
	// What happens next depends on the flags: if
	// %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
	// commandline arguments are sent to the primary instance, where a
	// #GApplication::command-line signal is emitted.  Otherwise, the
	// remaining commandline arguments are assumed to be a list of files.
	// If there are no files listed, the application is activated via the
	// #GApplication::activate signal.  If there are one or more files, and
	// %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
	// via the #GApplication::open signal.
	// 
	// If you are interested in doing more complicated local handling of the
	// commandline then you should implement your own #GApplication subclass
	// and override local_command_line(). In this case, you most likely want
	// to return %TRUE from your local_command_line() implementation to
	// suppress the default handling. See
	// [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
	// for an example.
	// 
	// If, after the above is done, the use count of the application is zero
	// then the exit status is returned immediately.  If the use count is
	// non-zero then the default main context is iterated until the use count
	// falls to zero, at which point 0 is returned.
	// 
	// If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
	// run for as much as 10 seconds with a use count of zero while waiting
	// for the message that caused the activation to arrive.  After that,
	// if the use count falls to zero the application will exit immediately,
	// except in the case that g_application_set_inactivity_timeout() is in
	// use.
	// 
	// This function sets the prgname (g_set_prgname()), if not already set,
	// to the basename of argv[0].
	// 
	// Much like g_main_loop_run(), this function will acquire the main context
	// for the duration that the application is running.
	// 
	// Since 2.40, applications that are not explicitly flagged as services
	// or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
	// %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
	// default handler for local_command_line) if "--gapplication-service"
	// was given in the command line.  If this flag is present then normal
	// commandline processing is interrupted and the
	// %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
	// solution whereby running an application directly from the commandline
	// will invoke it in the normal way (which can be useful for debugging)
	// while still allowing applications to be D-Bus activated in service
	// mode.  The D-Bus service file should invoke the executable with
	// "--gapplication-service" as the sole commandline argument.  This
	// approach is suitable for use by most graphical applications but
	// should not be used from applications like editors that need precise
	// control over when processes invoked via the commandline will exit and
	// what their exit status will be.
	Run([]string) int32
	// SendNotification wraps g_application_send_notification
	// 
	// The function takes the following parameters:
	// 
	// 	- id string (nullable): id of the notification, or %NULL 
	// 	- notification Notification: the #GNotification to send 
	//
	// Sends a notification on behalf of @application to the desktop shell.
	// There is no guarantee that the notification is displayed immediately,
	// or even at all.
	// 
	// Notifications may persist after the application exits. It will be
	// D-Bus-activated when the notification or one of its actions is
	// activated.
	// 
	// Modifying @notification after this call has no effect. However, the
	// object can be reused for a later call to this function.
	// 
	// @id may be any string that uniquely identifies the event for the
	// application. It does not need to be in any special format. For
	// example, "new-message" might be appropriate for a notification about
	// new messages.
	// 
	// If a previous notification was sent with the same @id, it will be
	// replaced with @notification and shown again as if it was a new
	// notification. This works even for notifications sent from a previous
	// execution of the application, as long as @id is the same string.
	// 
	// @id may be `NULL`, but it is impossible to replace or withdraw
	// notifications without an id.
	// 
	// If @notification is no longer relevant, it can be withdrawn with
	// [method@Gio.Application.withdraw_notification].
	// 
	// It is an error to call this function if @application has no
	// application ID.
	SendNotification(string, Notification)
	// SetActionGroup wraps g_application_set_action_group
	// 
	// The function takes the following parameters:
	// 
	// 	- actionGroup ActionGroup (nullable): a #GActionGroup, or %NULL 
	//
	// This used to be how actions were associated with a #GApplication.
	// Now there is #GActionMap for that.
	//
	// Deprecated: (since 2.32.0) Use the #GActionMap interface instead.  Never ever
	// mix use of this API with use of #GActionMap on the same @application
	// or things will go very badly wrong.  This function is known to
	// introduce buggy behaviour (ie: signals not emitted on changes to the
	// action group), so you should really use #GActionMap instead.
	SetActionGroup(ActionGroup)
	// SetApplicationID wraps g_application_set_application_id
	// 
	// The function takes the following parameters:
	// 
	// 	- applicationId string (nullable): the identifier for @application 
	//
	// Sets the unique identifier for @application.
	// 
	// The application id can only be modified if @application has not yet
	// been registered.
	// 
	// If non-%NULL, the application id must be valid.  See
	// g_application_id_is_valid().
	SetApplicationID(string)
	// SetDefault wraps g_application_set_default
	//
	// Sets or unsets the default application for the process, as returned
	// by g_application_get_default().
	// 
	// This function does not take its own reference on @application.  If
	// @application is destroyed then the default application will revert
	// back to %NULL.
	SetDefault()
	// SetFlags wraps g_application_set_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- flags ApplicationFlags: the flags for @application 
	//
	// Sets the flags for @application.
	// 
	// The flags can only be modified if @application has not yet been
	// registered.
	// 
	// See #GApplicationFlags.
	SetFlags(ApplicationFlags)
	// SetInactivityTimeout wraps g_application_set_inactivity_timeout
	// 
	// The function takes the following parameters:
	// 
	// 	- inactivityTimeout uint: the timeout, in milliseconds 
	//
	// Sets the current inactivity timeout for the application.
	// 
	// This is the amount of time (in milliseconds) after the last call to
	// g_application_release() before the application stops running.
	// 
	// This call has no side effects of its own.  The value set here is only
	// used for next time g_application_release() drops the use count to
	// zero.  Any timeouts currently in progress are not impacted.
	SetInactivityTimeout(uint)
	// SetOptionContextDescription wraps g_application_set_option_context_description
	// 
	// The function takes the following parameters:
	// 
	// 	- description string (nullable): a string to be shown in `--help` output
	//  after the list of options, or %NULL 
	//
	// Adds a description to the @application option context.
	// 
	// See g_option_context_set_description() for more information.
	SetOptionContextDescription(string)
	// SetOptionContextParameterString wraps g_application_set_option_context_parameter_string
	// 
	// The function takes the following parameters:
	// 
	// 	- parameterString string (nullable): a string which is displayed
	//   in the first line of `--help` output, after the usage summary `programname [OPTION...]`. 
	//
	// Sets the parameter string to be used by the commandline handling of @application.
	// 
	// This function registers the argument to be passed to g_option_context_new()
	// when the internal #GOptionContext of @application is created.
	// 
	// See g_option_context_new() for more information about @parameter_string.
	SetOptionContextParameterString(string)
	// SetOptionContextSummary wraps g_application_set_option_context_summary
	// 
	// The function takes the following parameters:
	// 
	// 	- summary string (nullable): a string to be shown in `--help` output
	//  before the list of options, or %NULL 
	//
	// Adds a summary to the @application option context.
	// 
	// See g_option_context_set_summary() for more information.
	SetOptionContextSummary(string)
	// SetResourceBasePath wraps g_application_set_resource_base_path
	// 
	// The function takes the following parameters:
	// 
	// 	- resourcePath string (nullable): the resource path to use 
	//
	// Sets (or unsets) the base resource path of @application.
	// 
	// The path is used to automatically load various
	// [application resources][struct@Gio.Resource] such as menu layouts and
	// action descriptions. The various types of resources will be found at
	// fixed names relative to the given base path.
	// 
	// By default, the resource base path is determined from the application
	// ID by prefixing '/' and replacing each '.' with '/'.  This is done at
	// the time that the #GApplication object is constructed.  Changes to
	// the application ID after that point will not have an impact on the
	// resource base path.
	// 
	// As an example, if the application has an ID of "org.example.app" then
	// the default resource base path will be "/org/example/app".  If this
	// is a #GtkApplication (and you have not manually changed the path)
	// then Gtk will then search for the menus of the application at
	// "/org/example/app/gtk/menus.ui".
	// 
	// See #GResource for more information about adding resources to your
	// application.
	// 
	// You can disable automatic resource loading functionality by setting
	// the path to %NULL.
	// 
	// Changing the resource base path once the application is running is
	// not recommended.  The point at which the resource path is consulted
	// for forming paths for various purposes is unspecified.  When writing
	// a sub-class of #GApplication you should either set the
	// #GApplication:resource-base-path property at construction time, or call
	// this function during the instance initialization. Alternatively, you
	// can call this function in the #GApplicationClass.startup virtual function,
	// before chaining up to the parent implementation.
	SetResourceBasePath(string)
	// SetVersion wraps g_application_set_version
	// 
	// The function takes the following parameters:
	// 
	// 	- version string: the version of @application 
	//
	// Sets the version number of @application. This will be used to implement
	// a `--version` command line argument
	// 
	// The application version can only be modified if @application has not yet
	// been registered.
	SetVersion(string)
	// UnmarkBusy wraps g_application_unmark_busy
	//
	// Decreases the busy count of @application.
	// 
	// When the busy count reaches zero, the new state will be propagated
	// to other processes.
	// 
	// This function must only be called to cancel the effect of a previous
	// call to g_application_mark_busy().
	UnmarkBusy()
	// WithdrawNotification wraps g_application_withdraw_notification
	// 
	// The function takes the following parameters:
	// 
	// 	- id string: id of a previously sent notification 
	//
	// Withdraws a notification that was sent with
	// g_application_send_notification().
	// 
	// This call does nothing if a notification with @id doesn't exist or
	// the notification was never sent.
	// 
	// This function works even for notifications sent in previous
	// executions of this application, as long @id is the same as it was for
	// the sent notification.
	// 
	// Note that notifications are dismissed when the user clicks on one
	// of the buttons in a notification or triggers its default action, so
	// there is no need to explicitly withdraw the notification in that case.
	WithdrawNotification(string)
	// ConnectActivate connects the provided callback to the "activate" signal
	//
	// The ::activate signal is emitted on the primary instance when an
	// activation occurs. See g_application_activate().
	ConnectActivate(func(Application)) gobject.SignalHandle
	// ConnectCommandLine connects the provided callback to the "command-line" signal
	//
	// The ::command-line signal is emitted on the primary instance when
	// a commandline is not handled locally. See g_application_run() and
	// the #GApplicationCommandLine documentation for more information.
	ConnectCommandLine(func(Application, ApplicationCommandLine) int32) gobject.SignalHandle
	// ConnectHandleLocalOptions connects the provided callback to the "handle-local-options" signal
	//
	// The ::handle-local-options signal is emitted on the local instance
	// after the parsing of the commandline options has occurred.
	// 
	// You can add options to be recognised during commandline option
	// parsing using g_application_add_main_option_entries() and
	// g_application_add_option_group().
	// 
	// Signal handlers can inspect @options (along with values pointed to
	// from the @arg_data of an installed #GOptionEntrys) in order to
	// decide to perform certain actions, including direct local handling
	// (which may be useful for options like --version).
	// 
	// In the event that the application is marked
	// %G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
	// send the @options dictionary to the primary instance where it can be
	// read with g_application_command_line_get_options_dict().  The signal
	// handler can modify the dictionary before returning, and the
	// modified dictionary will be sent.
	// 
	// In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
	// "normal processing" will treat the remaining uncollected command
	// line arguments as filenames or URIs.  If there are no arguments,
	// the application is activated by g_application_activate().  One or
	// more arguments results in a call to g_application_open().
	// 
	// If you want to handle the local commandline arguments for yourself
	// by converting them to calls to g_application_open() or
	// g_action_group_activate_action() then you must be sure to register
	// the application first.  You should probably not call
	// g_application_activate() for yourself, however: just return -1 and
	// allow the default handler to do it for you.  This will ensure that
	// the `--gapplication-service` switch works properly (i.e. no activation
	// in that case).
	// 
	// Note that this signal is emitted from the default implementation of
	// local_command_line().  If you override that function and don't
	// chain up then this signal will never be emitted.
	// 
	// You can override local_command_line() if you need more powerful
	// capabilities than what is provided here, but this should not
	// normally be required.
	ConnectHandleLocalOptions(func(Application, glib.VariantDict) int32) gobject.SignalHandle
	// ConnectNameLost connects the provided callback to the "name-lost" signal
	//
	// The ::name-lost signal is emitted only on the registered primary instance
	// when a new instance has taken over. This can only happen if the application
	// is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.
	// 
	// The default handler for this signal calls g_application_quit().
	ConnectNameLost(func(Application) bool) gobject.SignalHandle
	// ConnectOpen connects the provided callback to the "open" signal
	//
	// The ::open signal is emitted on the primary instance when there are
	// files to open. See g_application_open() for more information.
	ConnectOpen(func(Application, []byte, int32, string)) gobject.SignalHandle
	// ConnectShutdown connects the provided callback to the "shutdown" signal
	//
	// The ::shutdown signal is emitted only on the registered primary instance
	// immediately after the main loop terminates.
	ConnectShutdown(func(Application)) gobject.SignalHandle
	// ConnectStartup connects the provided callback to the "startup" signal
	//
	// The ::startup signal is emitted on the primary instance immediately
	// after registration. See g_application_register().
	ConnectStartup(func(Application)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentActivate calls the default implementations of the `GApplication.activate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// Activates the application.
	// 
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	// 
	// The application must be registered before calling this function.
	ParentActivate()
	// ParentAddPlatformData calls the default implementations of the `GApplication.add_platform_data` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- builder *glib.VariantBuilder 
	//
	// invoked (locally) to add 'platform data' to be sent to
	//     the primary instance when activating, opening or invoking actions
	ParentAddPlatformData(builder *glib.VariantBuilder)
	// ParentCommandLine calls the default implementations of the `GApplication.command_line` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- commandLine ApplicationCommandLine 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// invoked on the primary instance when a command-line is
	//   not handled locally
	ParentCommandLine(commandLine ApplicationCommandLine) int32
	// ParentHandleLocalOptions calls the default implementations of the `GApplication.handle_local_options` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- options *glib.VariantDict 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// invoked locally after the parsing of the commandline
	//  options has occurred. Since: 2.40
	ParentHandleLocalOptions(options *glib.VariantDict) int32
	// ParentNameLost calls the default implementations of the `GApplication.name_lost` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// invoked when another instance is taking over the name. Since: 2.60
	ParentNameLost() bool
	// ParentOpen calls the default implementations of the `GApplication.open` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- files []File: an array of #GFiles to open 
	// 	- hint string: a hint (or ""), but never %NULL 
	//
	// Opens the given files.
	// 
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	// 
	// @n_files must be greater than zero.
	// 
	// @hint is simply passed through to the ::open signal.  It is
	// intended to be used by applications that have multiple modes for
	// opening files (eg: "view" vs "edit", etc).  Unless you have a need
	// for this functionality, you should use "".
	// 
	// The application must be registered before calling this function
	// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
	ParentOpen(files []File, hint string)
	// ParentQuitMainloop calls the default implementations of the `GApplication.quit_mainloop` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// Used to be invoked on the primary instance when the use
	//     count of the application drops to zero (and after any inactivity
	//     timeout, if requested). Not used anymore since 2.32
	ParentQuitMainloop()
	// ParentRunMainloop calls the default implementations of the `GApplication.run_mainloop` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// Used to be invoked on the primary instance from
	//     g_application_run() if the use-count is non-zero. Since 2.32,
	//     GApplication is iterating the main context directly and is not
	//     using @run_mainloop anymore
	ParentRunMainloop()
	// ParentShutdown calls the default implementations of the `GApplication.shutdown` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// invoked only on the registered primary instance immediately
	//      after the main loop terminates
	ParentShutdown()
	// ParentStartup calls the default implementations of the `GApplication.startup` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// invoked on the primary instance immediately after registration
	ParentStartup()
}

func unsafeWrapApplication(base *gobject.ObjectInstance) *ApplicationInstance {
	return &ApplicationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeApplication,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplication(inst)
		},
	)
}

func marshalApplicationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeApplicationFromGlibNone is used to convert raw GApplication pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationFromGlibNone(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibNone(c).(Application)
}

// UnsafeApplicationFromGlibFull is used to convert raw GApplication pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationFromGlibFull(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibFull(c).(Application)
}

// UnsafeApplicationFromGlibBorrow is used to convert raw GApplication pointers to go without touching any references. This is used by the bindings internally.
func UnsafeApplicationFromGlibBorrow(c unsafe.Pointer) Application {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Application)
}

func (a *ApplicationInstance) upcastToGApplication() *ApplicationInstance {
	return a
}

// UnsafeApplicationToGlibNone is used to convert the instance to it's C value GApplication. This is used by the bindings internally.
func UnsafeApplicationToGlibNone(c Application) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeApplicationToGlibFull is used to convert the instance to it's C value GApplication, while removeing the finalizer. This is used by the bindings internally.
func UnsafeApplicationToGlibFull(c Application) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewApplication wraps g_application_new
// 
// The function takes the following parameters:
// 
// 	- applicationId string (nullable): the application id 
// 	- flags ApplicationFlags: the application flags 
// 
// The function returns the following values:
// 
// 	- goret Application 
//
// Creates a new #GApplication instance.
// 
// If non-%NULL, the application id must be valid.  See
// g_application_id_is_valid().
// 
// If no application ID is given then some features of #GApplication
// (most notably application uniqueness) will be disabled.
func NewApplication(applicationId string, flags ApplicationFlags) Application {
	var carg1 *C.gchar            // in, none, string, nullable-string
	var carg2 C.GApplicationFlags // in, none, casted
	var cret  *C.GApplication     // return, full, converted

	if applicationId != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GApplicationFlags(flags)

	cret = C.g_application_new(carg1, carg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var goret Application

	goret = UnsafeApplicationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ApplicationGetDefault wraps g_application_get_default
// 
// The function returns the following values:
// 
// 	- goret Application (nullable) 
//
// Returns the default #GApplication instance for this process.
// 
// Normally there is only one #GApplication per process and it becomes
// the default when it is created.  You can exercise more control over
// this by using g_application_set_default().
// 
// If there is no default application then %NULL is returned.
func ApplicationGetDefault() Application {
	var cret *C.GApplication // return, none, converted, nullable

	cret = C.g_application_get_default()

	var goret Application

	if cret != nil {
		goret = UnsafeApplicationFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ApplicationIDIsValid wraps g_application_id_is_valid
// 
// The function takes the following parameters:
// 
// 	- applicationId string: a potential application identifier 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @application_id is a valid application identifier.
// 
// A valid ID is required for calls to g_application_new() and
// g_application_set_application_id().
// 
// Application identifiers follow the same format as
// [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// For convenience, the restrictions on application identifiers are
// reproduced here:
// 
// - Application identifiers are composed of 1 or more elements separated by a
//   period (`.`) character. All elements must contain at least one character.
// 
// - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
//   with `-` discouraged in new application identifiers. Each element must not
//   begin with a digit.
// 
// - Application identifiers must contain at least one `.` (period) character
//   (and thus at least two elements).
// 
// - Application identifiers must not begin with a `.` (period) character.
// 
// - Application identifiers must not exceed 255 characters.
// 
// Note that the hyphen (`-`) character is allowed in application identifiers,
// but is problematic or not allowed in various specifications and APIs that
// refer to D-Bus, such as
// [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
// the
// [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
// and the convention that an application's "main" interface and object path
// resemble its application identifier and bus name. To avoid situations that
// require special-case handling, it is recommended that new application
// identifiers consistently replace hyphens with underscores.
// 
// Like D-Bus interface names, application identifiers should start with the
// reversed DNS domain name of the author of the interface (in lower-case), and
// it is conventional for the rest of the application identifier to consist of
// words run together, with initial capital letters.
// 
// As with D-Bus interface names, if the author's DNS domain name contains
// hyphen/minus characters they should be replaced by underscores, and if it
// contains leading digits they should be escaped by prepending an underscore.
// For example, if the owner of 7-zip.org used an application identifier for an
// archiving application, it might be named `org._7_zip.Archiver`.
func ApplicationIDIsValid(applicationId string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_id_is_valid(carg1)
	runtime.KeepAlive(applicationId)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Activate wraps g_application_activate
//
// Activates the application.
// 
// In essence, this results in the #GApplication::activate signal being
// emitted in the primary instance.
// 
// The application must be registered before calling this function.
func (application *ApplicationInstance) Activate() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_activate(carg0)
	runtime.KeepAlive(application)
}

// AddMainOption wraps g_application_add_main_option
// 
// The function takes the following parameters:
// 
// 	- longName string: the long name of an option used to specify it in a commandline 
// 	- shortName byte: the short name of an option 
// 	- flags glib.OptionFlags: flags from #GOptionFlags 
// 	- arg glib.OptionArg: the type of the option, as a #GOptionArg 
// 	- description string: the description for the option in `--help` output 
// 	- argDescription string (nullable): the placeholder to use for the extra argument
//    parsed by the option in `--help` output 
//
// Add an option to be handled by @application.
// 
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single #GOptionEntry
// that has its arg_data member set to %NULL.
// 
// The parsed arguments will be packed into a #GVariantDict which
// is passed to #GApplication::handle-local-options. If
// %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
// be sent to the primary instance. See
// g_application_add_main_option_entries() for more details.
// 
// See #GOptionEntry for more documentation of the arguments.
func (application *ApplicationInstance) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description string, argDescription string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.char         // in, none, string
	var carg2 C.char          // in, none, casted
	var carg3 C.GOptionFlags  // in, none, casted
	var carg4 C.GOptionArg    // in, none, casted
	var carg5 *C.char         // in, none, string
	var carg6 *C.char         // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(longName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.char(shortName)
	carg3 = C.GOptionFlags(flags)
	carg4 = C.GOptionArg(arg)
	carg5 = (*C.char)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg5))
	if argDescription != "" {
		carg6 = (*C.char)(unsafe.Pointer(C.CString(argDescription)))
		defer C.free(unsafe.Pointer(carg6))
	}

	C.g_application_add_main_option(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(application)
	runtime.KeepAlive(longName)
	runtime.KeepAlive(shortName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(description)
	runtime.KeepAlive(argDescription)
}

// AddMainOptionEntries wraps g_application_add_main_option_entries
// 
// The function takes the following parameters:
// 
// 	- entries []glib.OptionEntry: the
//   main options for the application 
//
// Adds main option entries to be handled by @application.
// 
// This function is comparable to g_option_context_add_main_entries().
// 
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted.  At this
// point, the application can inspect the values pointed to by @arg_data
// in the given #GOptionEntrys.
// 
// Unlike #GOptionContext, #GApplication supports giving a %NULL
// @arg_data for a non-callback #GOptionEntry.  This results in the
// argument in question being packed into a #GVariantDict which is also
// passed to #GApplication::handle-local-options, where it can be
// inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
// set, then the resulting dictionary is sent to the primary instance,
// where g_application_command_line_get_options_dict() will return it.
// As it has been passed outside the process at this point, the types of all
// values in the options dict must be checked before being used.
// This "packing" is done according to the type of the argument --
// booleans for normal flags, strings for strings, bytestrings for
// filenames, etc.  The packing only occurs if the flag is given (ie: we
// do not pack a "false" #GVariant in the case that a flag is missing).
// 
// In general, it is recommended that all commandline arguments are
// parsed locally.  The options dictionary should then be used to
// transmit the result of the parsing to the primary instance, where
// g_variant_dict_lookup() can be used.  For local options, it is
// possible to either use @arg_data in the usual way, or to consult (and
// potentially remove) the option from the options dictionary.
// 
// This function is new in GLib 2.40.  Before then, the only real choice
// was to send all of the commandline arguments (options and all) to the
// primary instance for handling.  #GApplication ignored them completely
// on the local side.  Calling this function "opts in" to the new
// behaviour, and in particular, means that unrecognized options will be
// treated as errors.  Unrecognized options have never been ignored when
// %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
// 
// If #GApplication::handle-local-options needs to see the list of
// filenames, then the use of %G_OPTION_REMAINING is recommended.  If
// @arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
// the options dictionary.  If you do use %G_OPTION_REMAINING then you
// need to handle these arguments for yourself because once they are
// consumed, they will no longer be visible to the default handling
// (which treats them as filenames to be opened).
// 
// It is important to use the proper GVariant format when retrieving
// the options with g_variant_dict_lookup():
// - for %G_OPTION_ARG_NONE, use `b`
// - for %G_OPTION_ARG_STRING, use `&amp;s`
// - for %G_OPTION_ARG_INT, use `i`
// - for %G_OPTION_ARG_INT64, use `x`
// - for %G_OPTION_ARG_DOUBLE, use `d`
// - for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
// - for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
// - for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`
func (application *ApplicationInstance) AddMainOptionEntries(entries []glib.OptionEntry) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GOptionEntry // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []glib.OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")

	C.g_application_add_main_option_entries(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(entries)
}

// AddOptionGroup wraps g_application_add_option_group
// 
// The function takes the following parameters:
// 
// 	- group *glib.OptionGroup: a #GOptionGroup 
//
// Adds a #GOptionGroup to the commandline handling of @application.
// 
// This function is comparable to g_option_context_add_group().
// 
// Unlike g_application_add_main_option_entries(), this function does
// not deal with %NULL @arg_data and never transmits options to the
// primary instance.
// 
// The reason for that is because, by the time the options arrive at the
// primary instance, it is typically too late to do anything with them.
// Taking the GTK option group as an example: GTK will already have been
// initialised by the time the #GApplication::command-line handler runs.
// In the case that this is not the first-running instance of the
// application, the existing instance may already have been running for
// a very long time.
// 
// This means that the options from #GOptionGroup are only really usable
// in the case that the instance of the application being run is the
// first instance.  Passing options like `--display=` or `--gdk-debug=`
// on future runs will have no effect on the existing primary instance.
// 
// Calling this function will cause the options in the supplied option
// group to be parsed, but it does not cause you to be "opted in" to the
// new functionality whereby unrecognized options are rejected even if
// %G_APPLICATION_HANDLES_COMMAND_LINE was given.
func (application *ApplicationInstance) AddOptionGroup(group *glib.OptionGroup) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GOptionGroup // in, full, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GOptionGroup)(glib.UnsafeOptionGroupToGlibFull(group))

	C.g_application_add_option_group(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(group)
}

// GetApplicationID wraps g_application_get_application_id
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the unique identifier for @application.
func (application *ApplicationInstance) GetApplicationID() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_application_id(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDBusObjectPath wraps g_application_get_dbus_object_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the D-Bus object path being used by the application, or %NULL.
// 
// If #GApplication is using its D-Bus backend then this function will
// return the D-Bus object path that #GApplication is using.  If the
// application is the primary instance then there is an object published
// at this path.  If the application is not the primary instance then
// the result of this function is undefined.
// 
// If #GApplication is not using D-Bus then this function will return
// %NULL.  This includes the situation where the D-Bus backend would
// normally be in use but we were unable to connect to the bus.
// 
// This function must not be called before the application has been
// registered.  See g_application_get_is_registered().
func (application *ApplicationInstance) GetDBusObjectPath() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_dbus_object_path(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFlags wraps g_application_get_flags
// 
// The function returns the following values:
// 
// 	- goret ApplicationFlags 
//
// Gets the flags for @application.
// 
// See #GApplicationFlags.
func (application *ApplicationInstance) GetFlags() ApplicationFlags {
	var carg0 *C.GApplication     // in, none, converted
	var cret  C.GApplicationFlags // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_flags(carg0)
	runtime.KeepAlive(application)

	var goret ApplicationFlags

	goret = ApplicationFlags(cret)

	return goret
}

// GetInactivityTimeout wraps g_application_get_inactivity_timeout
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the current inactivity timeout for the application.
// 
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
func (application *ApplicationInstance) GetInactivityTimeout() uint {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.guint         // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_inactivity_timeout(carg0)
	runtime.KeepAlive(application)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetIsBusy wraps g_application_get_is_busy
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
func (application *ApplicationInstance) GetIsBusy() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_busy(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsRegistered wraps g_application_get_is_registered
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @application is registered.
// 
// An application is registered if g_application_register() has been
// successfully called.
func (application *ApplicationInstance) GetIsRegistered() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_registered(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsRemote wraps g_application_get_is_remote
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @application is remote.
// 
// If @application is remote then it means that another instance of
// application already exists (the 'primary' instance).  Calls to
// perform actions on @application will result in the actions being
// performed by the primary instance.
// 
// The value of this property cannot be accessed before
// g_application_register() has been called.  See
// g_application_get_is_registered().
func (application *ApplicationInstance) GetIsRemote() bool {
	var carg0 *C.GApplication // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_is_remote(carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetResourceBasePath wraps g_application_get_resource_base_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the resource base path of @application.
// 
// See g_application_set_resource_base_path() for more information.
func (application *ApplicationInstance) GetResourceBasePath() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_resource_base_path(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetVersion wraps g_application_get_version
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the version of @application.
func (application *ApplicationInstance) GetVersion() string {
	var carg0 *C.GApplication // in, none, converted
	var cret  *C.gchar        // return, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C.g_application_get_version(carg0)
	runtime.KeepAlive(application)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Hold wraps g_application_hold
//
// Increases the use count of @application.
// 
// Use this function to indicate that the application has a reason to
// continue to run.  For example, g_application_hold() is called by GTK
// when a toplevel window is on the screen.
// 
// To cancel the hold, call g_application_release().
func (application *ApplicationInstance) Hold() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_hold(carg0)
	runtime.KeepAlive(application)
}

// MarkBusy wraps g_application_mark_busy
//
// Increases the busy count of @application.
// 
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
// 
// The busy state will be exposed to other processes, so a session shell will
// use that information to indicate the state to the user (e.g. with a
// spinner).
// 
// To cancel the busy indication, use g_application_unmark_busy().
// 
// The application must be registered before calling this function.
func (application *ApplicationInstance) MarkBusy() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_mark_busy(carg0)
	runtime.KeepAlive(application)
}

// Open wraps g_application_open
// 
// The function takes the following parameters:
// 
// 	- files []File: an array of #GFiles to open 
// 	- hint string: a hint (or ""), but never %NULL 
//
// Opens the given files.
// 
// In essence, this results in the #GApplication::open signal being emitted
// in the primary instance.
// 
// @n_files must be greater than zero.
// 
// @hint is simply passed through to the ::open signal.  It is
// intended to be used by applications that have multiple modes for
// opening files (eg: "view" vs "edit", etc).  Unless you have a need
// for this functionality, you should use "".
// 
// The application must be registered before calling this function
// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
func (application *ApplicationInstance) Open(files []File, hint string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 **C.GFile       // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
	var carg2 C.gint          // implicit
	var carg3 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = files
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []File (GFile**) because of unimplemented: inner pointers in array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_application_open(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// Quit wraps g_application_quit
//
// Immediately quits the application.
// 
// Upon return to the mainloop, g_application_run() will return,
// calling only the 'shutdown' function before doing so.
// 
// The hold count is ignored.
// Take care if your code has called g_application_hold() on the application and
// is therefore still expecting it to exist.
// (Note that you may have called g_application_hold() indirectly, for example
// through gtk_application_add_window().)
// 
// The result of calling g_application_run() again after it returns is
// unspecified.
func (application *ApplicationInstance) Quit() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_quit(carg0)
	runtime.KeepAlive(application)
}

// Register wraps g_application_register
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts registration of the application.
// 
// This is the point at which the application discovers if it is the
// primary instance or merely acting as a remote for an already-existing
// primary instance.  This is implemented by attempting to acquire the
// application identifier as a unique bus name on the session bus using
// GDBus.
// 
// If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
// given, then this process will always become the primary instance.
// 
// Due to the internal architecture of GDBus, method calls can be
// dispatched at any time (even if a main loop is not running).  For
// this reason, you must ensure that any object paths that you wish to
// register are registered before calling this function.
// 
// If the application has already been registered then %TRUE is
// returned with no work performed.
// 
// The #GApplication::startup signal is emitted if registration succeeds
// and @application is the primary instance (including the non-unique
// case).
// 
// In the event of an error (such as @cancellable being cancelled, or a
// failure to connect to the session bus), %FALSE is returned and @error
// is set appropriately.
// 
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application.  See
// g_application_get_is_remote() for that.
func (application *ApplicationInstance) Register(cancellable Cancellable) (bool, error) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_application_register(carg0, carg1, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Release wraps g_application_release
//
// Decrease the use count of @application.
// 
// When the use count reaches zero, the application will stop running.
// 
// Never call this function except to cancel the effect of a previous
// call to g_application_hold().
func (application *ApplicationInstance) Release() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_release(carg0)
	runtime.KeepAlive(application)
}

// Run wraps g_application_run
// 
// The function takes the following parameters:
// 
// 	- argv []string (nullable): 
//     the argv from main(), or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Runs the application.
// 
// This function is intended to be run from main() and its return value
// is intended to be returned by main(). Although you are expected to pass
// the @argc, @argv parameters from main() to this function, it is possible
// to pass %NULL if @argv is not available or commandline handling is not
// required.  Note that on Windows, @argc and @argv are ignored, and
// g_win32_get_command_line() is called internally (for proper support
// of Unicode commandline arguments).
// 
// #GApplication will attempt to parse the commandline arguments.  You
// can add commandline flags to the list of recognised options by way of
// g_application_add_main_option_entries().  After this, the
// #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its #GOptionEntrys.
// 
// #GApplication::handle-local-options is a good place to handle options
// such as `--version`, where an immediate reply from the local process is
// desired (instead of communicating with an already-running instance).
// A #GApplication::handle-local-options handler can stop further processing
// by returning a non-negative value, which then becomes the exit status of
// the process.
// 
// What happens next depends on the flags: if
// %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
// commandline arguments are sent to the primary instance, where a
// #GApplication::command-line signal is emitted.  Otherwise, the
// remaining commandline arguments are assumed to be a list of files.
// If there are no files listed, the application is activated via the
// #GApplication::activate signal.  If there are one or more files, and
// %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
// via the #GApplication::open signal.
// 
// If you are interested in doing more complicated local handling of the
// commandline then you should implement your own #GApplication subclass
// and override local_command_line(). In this case, you most likely want
// to return %TRUE from your local_command_line() implementation to
// suppress the default handling. See
// [gapplication-example-cmdline2.c][https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c]
// for an example.
// 
// If, after the above is done, the use count of the application is zero
// then the exit status is returned immediately.  If the use count is
// non-zero then the default main context is iterated until the use count
// falls to zero, at which point 0 is returned.
// 
// If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
// run for as much as 10 seconds with a use count of zero while waiting
// for the message that caused the activation to arrive.  After that,
// if the use count falls to zero the application will exit immediately,
// except in the case that g_application_set_inactivity_timeout() is in
// use.
// 
// This function sets the prgname (g_set_prgname()), if not already set,
// to the basename of argv[0].
// 
// Much like g_main_loop_run(), this function will acquire the main context
// for the duration that the application is running.
// 
// Since 2.40, applications that are not explicitly flagged as services
// or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
// %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
// default handler for local_command_line) if "--gapplication-service"
// was given in the command line.  If this flag is present then normal
// commandline processing is interrupted and the
// %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
// solution whereby running an application directly from the commandline
// will invoke it in the normal way (which can be useful for debugging)
// while still allowing applications to be D-Bus activated in service
// mode.  The D-Bus service file should invoke the executable with
// "--gapplication-service" as the sole commandline argument.  This
// approach is suitable for use by most graphical applications but
// should not be used from applications like editors that need precise
// control over when processes invoked via the commandline will exit and
// what their exit status will be.
func (application *ApplicationInstance) Run(argv []string) int32 {
	var carg0 *C.GApplication // in, none, converted
	var carg1 C.int           // implicit
	var carg2 **C.char        // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), length-by: carg1)
	var cret  C.int           // return, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = argv
	_ = carg2
	_ = carg1
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	cret = C.g_application_run(carg0, carg1, carg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(argv)

	var goret int32

	goret = int32(cret)

	return goret
}

// SendNotification wraps g_application_send_notification
// 
// The function takes the following parameters:
// 
// 	- id string (nullable): id of the notification, or %NULL 
// 	- notification Notification: the #GNotification to send 
//
// Sends a notification on behalf of @application to the desktop shell.
// There is no guarantee that the notification is displayed immediately,
// or even at all.
// 
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is
// activated.
// 
// Modifying @notification after this call has no effect. However, the
// object can be reused for a later call to this function.
// 
// @id may be any string that uniquely identifies the event for the
// application. It does not need to be in any special format. For
// example, "new-message" might be appropriate for a notification about
// new messages.
// 
// If a previous notification was sent with the same @id, it will be
// replaced with @notification and shown again as if it was a new
// notification. This works even for notifications sent from a previous
// execution of the application, as long as @id is the same string.
// 
// @id may be `NULL`, but it is impossible to replace or withdraw
// notifications without an id.
// 
// If @notification is no longer relevant, it can be withdrawn with
// [method@Gio.Application.withdraw_notification].
// 
// It is an error to call this function if @application has no
// application ID.
func (application *ApplicationInstance) SendNotification(id string, notification Notification) {
	var carg0 *C.GApplication  // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.GNotification // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if id != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))

	C.g_application_send_notification(carg0, carg1, carg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
	runtime.KeepAlive(notification)
}

// SetActionGroup wraps g_application_set_action_group
// 
// The function takes the following parameters:
// 
// 	- actionGroup ActionGroup (nullable): a #GActionGroup, or %NULL 
//
// This used to be how actions were associated with a #GApplication.
// Now there is #GActionMap for that.
//
// Deprecated: (since 2.32.0) Use the #GActionMap interface instead.  Never ever
// mix use of this API with use of #GActionMap on the same @application
// or things will go very badly wrong.  This function is known to
// introduce buggy behaviour (ie: signals not emitted on changes to the
// action group), so you should really use #GActionMap instead.
func (application *ApplicationInstance) SetActionGroup(actionGroup ActionGroup) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.GActionGroup // in, none, converted, nullable

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if actionGroup != nil {
		carg1 = (*C.GActionGroup)(UnsafeActionGroupToGlibNone(actionGroup))
	}

	C.g_application_set_action_group(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(actionGroup)
}

// SetApplicationID wraps g_application_set_application_id
// 
// The function takes the following parameters:
// 
// 	- applicationId string (nullable): the identifier for @application 
//
// Sets the unique identifier for @application.
// 
// The application id can only be modified if @application has not yet
// been registered.
// 
// If non-%NULL, the application id must be valid.  See
// g_application_id_is_valid().
func (application *ApplicationInstance) SetApplicationID(applicationId string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if applicationId != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_application_id(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(applicationId)
}

// SetDefault wraps g_application_set_default
//
// Sets or unsets the default application for the process, as returned
// by g_application_get_default().
// 
// This function does not take its own reference on @application.  If
// @application is destroyed then the default application will revert
// back to %NULL.
func (application *ApplicationInstance) SetDefault() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_set_default(carg0)
	runtime.KeepAlive(application)
}

// SetFlags wraps g_application_set_flags
// 
// The function takes the following parameters:
// 
// 	- flags ApplicationFlags: the flags for @application 
//
// Sets the flags for @application.
// 
// The flags can only be modified if @application has not yet been
// registered.
// 
// See #GApplicationFlags.
func (application *ApplicationInstance) SetFlags(flags ApplicationFlags) {
	var carg0 *C.GApplication     // in, none, converted
	var carg1 C.GApplicationFlags // in, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = C.GApplicationFlags(flags)

	C.g_application_set_flags(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(flags)
}

// SetInactivityTimeout wraps g_application_set_inactivity_timeout
// 
// The function takes the following parameters:
// 
// 	- inactivityTimeout uint: the timeout, in milliseconds 
//
// Sets the current inactivity timeout for the application.
// 
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
// 
// This call has no side effects of its own.  The value set here is only
// used for next time g_application_release() drops the use count to
// zero.  Any timeouts currently in progress are not impacted.
func (application *ApplicationInstance) SetInactivityTimeout(inactivityTimeout uint) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 C.guint         // in, none, casted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(inactivityTimeout)
}

// SetOptionContextDescription wraps g_application_set_option_context_description
// 
// The function takes the following parameters:
// 
// 	- description string (nullable): a string to be shown in `--help` output
//  after the list of options, or %NULL 
//
// Adds a description to the @application option context.
// 
// See g_option_context_set_description() for more information.
func (application *ApplicationInstance) SetOptionContextDescription(description string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if description != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_description(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(description)
}

// SetOptionContextParameterString wraps g_application_set_option_context_parameter_string
// 
// The function takes the following parameters:
// 
// 	- parameterString string (nullable): a string which is displayed
//   in the first line of `--help` output, after the usage summary `programname [OPTION...]`. 
//
// Sets the parameter string to be used by the commandline handling of @application.
// 
// This function registers the argument to be passed to g_option_context_new()
// when the internal #GOptionContext of @application is created.
// 
// See g_option_context_new() for more information about @parameter_string.
func (application *ApplicationInstance) SetOptionContextParameterString(parameterString string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if parameterString != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(parameterString)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_parameter_string(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(parameterString)
}

// SetOptionContextSummary wraps g_application_set_option_context_summary
// 
// The function takes the following parameters:
// 
// 	- summary string (nullable): a string to be shown in `--help` output
//  before the list of options, or %NULL 
//
// Adds a summary to the @application option context.
// 
// See g_option_context_set_summary() for more information.
func (application *ApplicationInstance) SetOptionContextSummary(summary string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if summary != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_option_context_summary(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(summary)
}

// SetResourceBasePath wraps g_application_set_resource_base_path
// 
// The function takes the following parameters:
// 
// 	- resourcePath string (nullable): the resource path to use 
//
// Sets (or unsets) the base resource path of @application.
// 
// The path is used to automatically load various
// [application resources][struct@Gio.Resource] such as menu layouts and
// action descriptions. The various types of resources will be found at
// fixed names relative to the given base path.
// 
// By default, the resource base path is determined from the application
// ID by prefixing '/' and replacing each '.' with '/'.  This is done at
// the time that the #GApplication object is constructed.  Changes to
// the application ID after that point will not have an impact on the
// resource base path.
// 
// As an example, if the application has an ID of "org.example.app" then
// the default resource base path will be "/org/example/app".  If this
// is a #GtkApplication (and you have not manually changed the path)
// then Gtk will then search for the menus of the application at
// "/org/example/app/gtk/menus.ui".
// 
// See #GResource for more information about adding resources to your
// application.
// 
// You can disable automatic resource loading functionality by setting
// the path to %NULL.
// 
// Changing the resource base path once the application is running is
// not recommended.  The point at which the resource path is consulted
// for forming paths for various purposes is unspecified.  When writing
// a sub-class of #GApplication you should either set the
// #GApplication:resource-base-path property at construction time, or call
// this function during the instance initialization. Alternatively, you
// can call this function in the #GApplicationClass.startup virtual function,
// before chaining up to the parent implementation.
func (application *ApplicationInstance) SetResourceBasePath(resourcePath string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string, nullable-string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	if resourcePath != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_application_set_resource_base_path(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(resourcePath)
}

// SetVersion wraps g_application_set_version
// 
// The function takes the following parameters:
// 
// 	- version string: the version of @application 
//
// Sets the version number of @application. This will be used to implement
// a `--version` command line argument
// 
// The application version can only be modified if @application has not yet
// been registered.
func (application *ApplicationInstance) SetVersion(version string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(version)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_set_version(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(version)
}

// UnmarkBusy wraps g_application_unmark_busy
//
// Decreases the busy count of @application.
// 
// When the busy count reaches zero, the new state will be propagated
// to other processes.
// 
// This function must only be called to cancel the effect of a previous
// call to g_application_mark_busy().
func (application *ApplicationInstance) UnmarkBusy() {
	var carg0 *C.GApplication // in, none, converted

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C.g_application_unmark_busy(carg0)
	runtime.KeepAlive(application)
}

// WithdrawNotification wraps g_application_withdraw_notification
// 
// The function takes the following parameters:
// 
// 	- id string: id of a previously sent notification 
//
// Withdraws a notification that was sent with
// g_application_send_notification().
// 
// This call does nothing if a notification with @id doesn't exist or
// the notification was never sent.
// 
// This function works even for notifications sent in previous
// executions of this application, as long @id is the same as it was for
// the sent notification.
// 
// Note that notifications are dismissed when the user clicks on one
// of the buttons in a notification or triggers its default action, so
// there is no need to explicitly withdraw the notification in that case.
func (application *ApplicationInstance) WithdrawNotification(id string) {
	var carg0 *C.GApplication // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_withdraw_notification(carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
}

// ConnectActivate connects the provided callback to the "activate" signal
//
// The ::activate signal is emitted on the primary instance when an
// activation occurs. See g_application_activate().
func (o *ApplicationInstance) ConnectActivate(fn func(Application)) gobject.SignalHandle {
	return o.Connect("activate", fn)
}

// ConnectCommandLine connects the provided callback to the "command-line" signal
//
// The ::command-line signal is emitted on the primary instance when
// a commandline is not handled locally. See g_application_run() and
// the #GApplicationCommandLine documentation for more information.
func (o *ApplicationInstance) ConnectCommandLine(fn func(Application, ApplicationCommandLine) int32) gobject.SignalHandle {
	return o.Connect("command-line", fn)
}

// ConnectHandleLocalOptions connects the provided callback to the "handle-local-options" signal
//
// The ::handle-local-options signal is emitted on the local instance
// after the parsing of the commandline options has occurred.
// 
// You can add options to be recognised during commandline option
// parsing using g_application_add_main_option_entries() and
// g_application_add_option_group().
// 
// Signal handlers can inspect @options (along with values pointed to
// from the @arg_data of an installed #GOptionEntrys) in order to
// decide to perform certain actions, including direct local handling
// (which may be useful for options like --version).
// 
// In the event that the application is marked
// %G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
// send the @options dictionary to the primary instance where it can be
// read with g_application_command_line_get_options_dict().  The signal
// handler can modify the dictionary before returning, and the
// modified dictionary will be sent.
// 
// In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
// "normal processing" will treat the remaining uncollected command
// line arguments as filenames or URIs.  If there are no arguments,
// the application is activated by g_application_activate().  One or
// more arguments results in a call to g_application_open().
// 
// If you want to handle the local commandline arguments for yourself
// by converting them to calls to g_application_open() or
// g_action_group_activate_action() then you must be sure to register
// the application first.  You should probably not call
// g_application_activate() for yourself, however: just return -1 and
// allow the default handler to do it for you.  This will ensure that
// the `--gapplication-service` switch works properly (i.e. no activation
// in that case).
// 
// Note that this signal is emitted from the default implementation of
// local_command_line().  If you override that function and don't
// chain up then this signal will never be emitted.
// 
// You can override local_command_line() if you need more powerful
// capabilities than what is provided here, but this should not
// normally be required.
func (o *ApplicationInstance) ConnectHandleLocalOptions(fn func(Application, glib.VariantDict) int32) gobject.SignalHandle {
	return o.Connect("handle-local-options", fn)
}

// ConnectNameLost connects the provided callback to the "name-lost" signal
//
// The ::name-lost signal is emitted only on the registered primary instance
// when a new instance has taken over. This can only happen if the application
// is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.
// 
// The default handler for this signal calls g_application_quit().
func (o *ApplicationInstance) ConnectNameLost(fn func(Application) bool) gobject.SignalHandle {
	return o.Connect("name-lost", fn)
}

// ConnectOpen connects the provided callback to the "open" signal
//
// The ::open signal is emitted on the primary instance when there are
// files to open. See g_application_open() for more information.
func (o *ApplicationInstance) ConnectOpen(fn func(Application, []byte, int32, string)) gobject.SignalHandle {
	return o.Connect("open", fn)
}

// ConnectShutdown connects the provided callback to the "shutdown" signal
//
// The ::shutdown signal is emitted only on the registered primary instance
// immediately after the main loop terminates.
func (o *ApplicationInstance) ConnectShutdown(fn func(Application)) gobject.SignalHandle {
	return o.Connect("shutdown", fn)
}

// ConnectStartup connects the provided callback to the "startup" signal
//
// The ::startup signal is emitted on the primary instance immediately
// after registration. See g_application_register().
func (o *ApplicationInstance) ConnectStartup(fn func(Application)) gobject.SignalHandle {
	return o.Connect("startup", fn)
}

// ApplicationOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ApplicationOverrides[Instance Application] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Activate allows you to override the implementation of the virtual method activate.
	//
	// Activates the application.
	// 
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	// 
	// The application must be registered before calling this function.
	Activate func(Instance)
	// // AddPlatformData allows you to override the implementation of the virtual method add_platform_data.
	// 
	// The function takes the following parameters:
	// 
	// 	- builder *glib.VariantBuilder 
	//
	// invoked (locally) to add 'platform data' to be sent to
	//     the primary instance when activating, opening or invoking actions
	AddPlatformData func(Instance, *glib.VariantBuilder)
	// // CommandLine allows you to override the implementation of the virtual method command_line.
	// 
	// The function takes the following parameters:
	// 
	// 	- commandLine ApplicationCommandLine 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// invoked on the primary instance when a command-line is
	//   not handled locally
	CommandLine func(Instance, ApplicationCommandLine) int32
	// // HandleLocalOptions allows you to override the implementation of the virtual method handle_local_options.
	// 
	// The function takes the following parameters:
	// 
	// 	- options *glib.VariantDict 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// invoked locally after the parsing of the commandline
	//  options has occurred. Since: 2.40
	HandleLocalOptions func(Instance, *glib.VariantDict) int32
	// // NameLost allows you to override the implementation of the virtual method name_lost.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// invoked when another instance is taking over the name. Since: 2.60
	NameLost func(Instance) bool
	// // Open allows you to override the implementation of the virtual method open.
	// 
	// The function takes the following parameters:
	// 
	// 	- files []File: an array of #GFiles to open 
	// 	- hint string: a hint (or ""), but never %NULL 
	//
	// Opens the given files.
	// 
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	// 
	// @n_files must be greater than zero.
	// 
	// @hint is simply passed through to the ::open signal.  It is
	// intended to be used by applications that have multiple modes for
	// opening files (eg: "view" vs "edit", etc).  Unless you have a need
	// for this functionality, you should use "".
	// 
	// The application must be registered before calling this function
	// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
	Open func(Instance, []File, string)
	// // QuitMainloop allows you to override the implementation of the virtual method quit_mainloop.
	//
	// Used to be invoked on the primary instance when the use
	//     count of the application drops to zero (and after any inactivity
	//     timeout, if requested). Not used anymore since 2.32
	QuitMainloop func(Instance)
	// // RunMainloop allows you to override the implementation of the virtual method run_mainloop.
	//
	// Used to be invoked on the primary instance from
	//     g_application_run() if the use-count is non-zero. Since 2.32,
	//     GApplication is iterating the main context directly and is not
	//     using @run_mainloop anymore
	RunMainloop func(Instance)
	// // Shutdown allows you to override the implementation of the virtual method shutdown.
	//
	// invoked only on the registered primary instance immediately
	//      after the main loop terminates
	Shutdown func(Instance)
	// // Startup allows you to override the implementation of the virtual method startup.
	//
	// invoked on the primary instance immediately after registration
	Startup func(Instance)
}

// UnsafeApplyApplicationOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyApplicationOverrides[Instance Application](gclass unsafe.Pointer, overrides ApplicationOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GApplicationClass)(gclass)

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._goglib_gio2_Application_activate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_activate",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Activate(application)
			},
		)
	}

	if overrides.AddPlatformData != nil {
		pclass.add_platform_data = (*[0]byte)(C._goglib_gio2_Application_add_platform_data)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_add_platform_data",
			func(carg0 *C.GApplication, carg1 *C.GVariantBuilder) {
				var application Instance             // go GApplication subclass
				var builder     *glib.VariantBuilder // in, none, converted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				builder = glib.UnsafeVariantBuilderFromGlibNone(unsafe.Pointer(carg1))

				overrides.AddPlatformData(application, builder)
			},
		)
	}

	if overrides.CommandLine != nil {
		pclass.command_line = (*[0]byte)(C._goglib_gio2_Application_command_line)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_command_line",
			func(carg0 *C.GApplication, carg1 *C.GApplicationCommandLine) (cret C.int) {
				var application Instance               // go GApplication subclass
				var commandLine ApplicationCommandLine // in, none, converted
				var goret       int32                  // return, none, casted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				commandLine = UnsafeApplicationCommandLineFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.CommandLine(application, commandLine)

				cret = C.int(goret)

				return cret
			},
		)
	}

	if overrides.HandleLocalOptions != nil {
		pclass.handle_local_options = (*[0]byte)(C._goglib_gio2_Application_handle_local_options)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_handle_local_options",
			func(carg0 *C.GApplication, carg1 *C.GVariantDict) (cret C.gint) {
				var application Instance          // go GApplication subclass
				var options     *glib.VariantDict // in, none, converted
				var goret       int32             // return, none, casted

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				options = glib.UnsafeVariantDictFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.HandleLocalOptions(application, options)

				cret = C.gint(goret)

				return cret
			},
		)
	}

	if overrides.NameLost != nil {
		pclass.name_lost = (*[0]byte)(C._goglib_gio2_Application_name_lost)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_name_lost",
			func(carg0 *C.GApplication) (cret C.gboolean) {
				var application Instance // go GApplication subclass
				var goret       bool     // return

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.NameLost(application)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._goglib_gio2_Application_open)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_open",
			func(carg0 *C.GApplication, carg1 **C.GFile, carg2 C.gint, carg3 *C.gchar) {
				var application Instance // go GApplication subclass
				var files       []File   // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
				var hint        string   // in, none, string

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = files
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []File (GFile**) because of unknown reason")
				hint = C.GoString((*C.char)(unsafe.Pointer(carg3)))

				overrides.Open(application, files, hint)
			},
		)
	}

	if overrides.QuitMainloop != nil {
		pclass.quit_mainloop = (*[0]byte)(C._goglib_gio2_Application_quit_mainloop)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_quit_mainloop",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.QuitMainloop(application)
			},
		)
	}

	if overrides.RunMainloop != nil {
		pclass.run_mainloop = (*[0]byte)(C._goglib_gio2_Application_run_mainloop)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_run_mainloop",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.RunMainloop(application)
			},
		)
	}

	if overrides.Shutdown != nil {
		pclass.shutdown = (*[0]byte)(C._goglib_gio2_Application_shutdown)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_shutdown",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Shutdown(application)
			},
		)
	}

	if overrides.Startup != nil {
		pclass.startup = (*[0]byte)(C._goglib_gio2_Application_startup)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Application_startup",
			func(carg0 *C.GApplication) {
				var application Instance // go GApplication subclass

				application = UnsafeApplicationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Startup(application)
			},
		)
	}
}

// ParentActivate calls the default implementations of the `GApplication.activate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// Activates the application.
// 
// In essence, this results in the #GApplication::activate signal being
// emitted in the primary instance.
// 
// The application must be registered before calling this function.
func (application *ApplicationInstance) ParentActivate() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_activate(unsafe.Pointer(parentclass.activate), carg0)
	runtime.KeepAlive(application)
}

// ParentAddPlatformData calls the default implementations of the `GApplication.add_platform_data` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- builder *glib.VariantBuilder 
//
// invoked (locally) to add 'platform data' to be sent to
//     the primary instance when activating, opening or invoking actions
func (application *ApplicationInstance) ParentAddPlatformData(builder *glib.VariantBuilder) {
	var carg0 *C.GApplication
	var carg1 *C.GVariantBuilder // in, none, converted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GVariantBuilder)(glib.UnsafeVariantBuilderToGlibNone(builder))

	C._goglib_gio2_Application_virtual_add_platform_data(unsafe.Pointer(parentclass.add_platform_data), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(builder)
}

// ParentCommandLine calls the default implementations of the `GApplication.command_line` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- commandLine ApplicationCommandLine 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// invoked on the primary instance when a command-line is
//   not handled locally
func (application *ApplicationInstance) ParentCommandLine(commandLine ApplicationCommandLine) int32 {
	var carg0 *C.GApplication
	var carg1 *C.GApplicationCommandLine // in, none, converted
	var cret  C.int                      // return, none, casted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(commandLine))

	cret = C._goglib_gio2_Application_virtual_command_line(unsafe.Pointer(parentclass.command_line), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(commandLine)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentHandleLocalOptions calls the default implementations of the `GApplication.handle_local_options` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- options *glib.VariantDict 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// invoked locally after the parsing of the commandline
//  options has occurred. Since: 2.40
func (application *ApplicationInstance) ParentHandleLocalOptions(options *glib.VariantDict) int32 {
	var carg0 *C.GApplication
	var carg1 *C.GVariantDict // in, none, converted
	var cret  C.gint          // return, none, casted

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	carg1 = (*C.GVariantDict)(glib.UnsafeVariantDictToGlibNone(options))

	cret = C._goglib_gio2_Application_virtual_handle_local_options(unsafe.Pointer(parentclass.handle_local_options), carg0, carg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(options)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentNameLost calls the default implementations of the `GApplication.name_lost` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// invoked when another instance is taking over the name. Since: 2.60
func (application *ApplicationInstance) ParentNameLost() bool {
	var carg0 *C.GApplication
	var cret  C.gboolean // return

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	cret = C._goglib_gio2_Application_virtual_name_lost(unsafe.Pointer(parentclass.name_lost), carg0)
	runtime.KeepAlive(application)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentOpen calls the default implementations of the `GApplication.open` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- files []File: an array of #GFiles to open 
// 	- hint string: a hint (or ""), but never %NULL 
//
// Opens the given files.
// 
// In essence, this results in the #GApplication::open signal being emitted
// in the primary instance.
// 
// @n_files must be greater than zero.
// 
// @hint is simply passed through to the ::open signal.  It is
// intended to be used by applications that have multiple modes for
// opening files (eg: "view" vs "edit", etc).  Unless you have a need
// for this functionality, you should use "".
// 
// The application must be registered before calling this function
// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
func (application *ApplicationInstance) ParentOpen(files []File, hint string) {
	var carg0 *C.GApplication
	var carg1 **C.GFile // in, none, converted
	var carg2 C.gint    // in, transfer: none, C Pointers: 2, Name: array[File], array (inner GFile* (*typesystem.Interface), length-by: carg2)
	var carg3 *C.gchar  // implicit

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))
	_ = files
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []File (GFile**) because of unimplemented: inner pointers in array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(carg3))

	C._goglib_gio2_Application_virtual_open(unsafe.Pointer(parentclass.open), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// ParentQuitMainloop calls the default implementations of the `GApplication.quit_mainloop` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// Used to be invoked on the primary instance when the use
//     count of the application drops to zero (and after any inactivity
//     timeout, if requested). Not used anymore since 2.32
func (application *ApplicationInstance) ParentQuitMainloop() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_quit_mainloop(unsafe.Pointer(parentclass.quit_mainloop), carg0)
	runtime.KeepAlive(application)
}

// ParentRunMainloop calls the default implementations of the `GApplication.run_mainloop` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// Used to be invoked on the primary instance from
//     g_application_run() if the use-count is non-zero. Since 2.32,
//     GApplication is iterating the main context directly and is not
//     using @run_mainloop anymore
func (application *ApplicationInstance) ParentRunMainloop() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_run_mainloop(unsafe.Pointer(parentclass.run_mainloop), carg0)
	runtime.KeepAlive(application)
}

// ParentShutdown calls the default implementations of the `GApplication.shutdown` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// invoked only on the registered primary instance immediately
//      after the main loop terminates
func (application *ApplicationInstance) ParentShutdown() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_shutdown(unsafe.Pointer(parentclass.shutdown), carg0)
	runtime.KeepAlive(application)
}

// ParentStartup calls the default implementations of the `GApplication.startup` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// invoked on the primary instance immediately after registration
func (application *ApplicationInstance) ParentStartup() {
	var carg0 *C.GApplication

	parentclass := (*C.GApplicationClass)(classdata.PeekParentClass(UnsafeApplicationToGlibNone(application)))

	carg0 = (*C.GApplication)(UnsafeApplicationToGlibNone(application))

	C._goglib_gio2_Application_virtual_startup(unsafe.Pointer(parentclass.startup), carg0)
	runtime.KeepAlive(application)
}

// RegisterApplicationSubClass is used to register a go subclass of GApplication. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterApplicationSubClass[InstanceT Application](
		name string,
		classInit func(class *ApplicationClass),
		constructor func() InstanceT,
		overrides ApplicationOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeApplication,
		UnsafeApplicationClassFromGlibBorrow,
		UnsafeApplyApplicationOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplication(obj)
		},
		interfaceInits...,
	)
}

// ApplicationCommandLineInstance is the instance type used by all types extending GApplicationCommandLine. It is used internally by the bindings. Users should use the interface [ApplicationCommandLine] instead.
type ApplicationCommandLineInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ApplicationCommandLine = (*ApplicationCommandLineInstance)(nil)

// ApplicationCommandLine wraps GApplicationCommandLine
//
// `GApplicationCommandLine` represents a command-line invocation of
// an application.
// 
// It is created by [class@Gio.Application] and emitted
// in the [signal@Gio.Application::command-line] signal and virtual function.
// 
// The class contains the list of arguments that the program was invoked
// with. It is also possible to query if the commandline invocation was
// local (ie: the current process is running in direct response to the
// invocation) or remote (ie: some other process forwarded the
// commandline to this process).
// 
// The `GApplicationCommandLine` object can provide the @argc and @argv
// parameters for use with the [struct@GLib.OptionContext] command-line parsing API,
// with the [method@Gio.ApplicationCommandLine.get_arguments] function. See
// [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
// for an example.
// 
// The exit status of the originally-invoked process may be set and
// messages can be printed to stdout or stderr of that process.
// 
// For remote invocation, the originally-invoked process exits when
// [method@Gio.ApplicationCommandLine.done] method is called. This method is
// also automatically called when the object is disposed.
// 
// The main use for `GApplicationCommandLine` (and the
// [signal@Gio.Application::command-line] signal) is 'Emacs server' like use cases:
// You can set the `EDITOR` environment variable to have e.g. git use
// your favourite editor to edit commit messages, and if you already
// have an instance of the editor running, the editing will happen
// in the running instance, instead of opening a new one. An important
// aspect of this use case is that the process that gets started by git
// does not return until the editing is done.
// 
// Normally, the commandline is completely handled in the
// [signal@Gio.Application::command-line] handler. The launching instance exits
// once the signal handler in the primary instance has returned, and
// the return value of the signal handler becomes the exit status
// of the launching instance.
// 
// ```c
// static int
// command_line (GApplication            *application,
//               GApplicationCommandLine *cmdline)
// {
//   gchar **argv;
//   gint argc;
//   gint i;
// 
//   argv = g_application_command_line_get_arguments (cmdline, &amp;argc);
// 
//   g_application_command_line_print (cmdline,
//                                     "This text is written back\n"
//                                     "to stdout of the caller\n");
// 
//   for (i = 0; i &lt; argc; i++)
//     g_print ("argument %d: %s\n", i, argv[i]);
// 
//   g_strfreev (argv);
// 
//   return 0;
// }
// ```
// 
// The complete example can be found here:
// [gapplication-example-cmdline.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline.c)
// 
// In more complicated cases, the handling of the commandline can be
// split between the launcher and the primary instance.
// 
// ```c
// static gboolean
//  test_local_cmdline (GApplication   *application,
//                      gchar        ***arguments,
//                      gint           *exit_status)
// {
//   gint i, j;
//   gchar **argv;
// 
//   argv = *arguments;
// 
//   if (argv[0] == NULL)
//     {
//       *exit_status = 0;
//       return FALSE;
//     }
// 
//   i = 1;
//   while (argv[i])
//     {
//       if (g_str_has_prefix (argv[i], "--local-"))
//         {
//           g_print ("handling argument %s locally\n", argv[i]);
//           g_free (argv[i]);
//           for (j = i; argv[j]; j++)
//             argv[j] = argv[j + 1];
//         }
//       else
//         {
//           g_print ("not handling argument %s locally\n", argv[i]);
//           i++;
//         }
//     }
// 
//   *exit_status = 0;
// 
//   return FALSE;
// }
// 
// static void
// test_application_class_init (TestApplicationClass *class)
// {
//   G_APPLICATION_CLASS (class)-&gt;local_command_line = test_local_cmdline;
// 
//   ...
// }
// ```
// 
// In this example of split commandline handling, options that start
// with `--local-` are handled locally, all other options are passed
// to the [signal@Gio.Application::command-line] handler which runs in the primary
// instance.
// 
// The complete example can be found here:
// [gapplication-example-cmdline2.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline2.c)
// 
// If handling the commandline requires a lot of work, it may be better to defer it.
// 
// ```c
// static gboolean
// my_cmdline_handler (gpointer data)
// {
//   GApplicationCommandLine *cmdline = data;
// 
//   // do the heavy lifting in an idle
// 
//   g_application_command_line_set_exit_status (cmdline, 0);
//   g_object_unref (cmdline); // this releases the application
// 
//   return G_SOURCE_REMOVE;
// }
// 
// static int
// command_line (GApplication            *application,
//               GApplicationCommandLine *cmdline)
// {
//   // keep the application running until we are done with this commandline
//   g_application_hold (application);
// 
//   g_object_set_data_full (G_OBJECT (cmdline),
//                           "application", application,
//                           (GDestroyNotify)g_application_release);
// 
//   g_object_ref (cmdline);
//   g_idle_add (my_cmdline_handler, cmdline);
// 
//   return 0;
// }
// ```
// 
// In this example the commandline is not completely handled before
// the [signal@Gio.Application::command-line] handler returns. Instead, we keep
// a reference to the `GApplicationCommandLine` object and handle it
// later (in this example, in an idle). Note that it is necessary to
// hold the application until you are done with the commandline.
// 
// The complete example can be found here:
// [gapplication-example-cmdline3.c](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/tests/gapplication-example-cmdline3.c)
type ApplicationCommandLine interface {
	gobject.Object
	upcastToGApplicationCommandLine() *ApplicationCommandLineInstance

	// CreateFileForArg wraps g_application_command_line_create_file_for_arg
	// 
	// The function takes the following parameters:
	// 
	// 	- arg string: an argument from @cmdline 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Creates a #GFile corresponding to a filename that was given as part
	// of the invocation of @cmdline.
	// 
	// This differs from g_file_new_for_commandline_arg() in that it
	// resolves relative pathnames using the current working directory of
	// the invoking process rather than the local process.
	CreateFileForArg(string) File
	// Done wraps g_application_command_line_done
	//
	// Signals that command line processing is completed.
	// 
	// For remote invocation, it causes the invoking process to terminate.
	// 
	// For local invocation, it does nothing.
	// 
	// This method should be called in the [signal@Gio.Application::command-line]
	// handler, after the exit status is set and all messages are printed.
	// 
	// After this call, g_application_command_line_set_exit_status() has no effect.
	// Subsequent calls to this method are no-ops.
	// 
	// This method is automatically called when the #GApplicationCommandLine
	// object is disposed &#x2014; so you can omit the call in non-garbage collected
	// languages.
	Done()
	// GetArguments wraps g_application_command_line_get_arguments
	// 
	// The function returns the following values:
	// 
	// 	- argc int32: the length of the arguments array, or %NULL 
	// 	- goret []string 
	//
	// Gets the list of arguments that was passed on the command line.
	// 
	// The strings in the array may contain non-UTF-8 data on UNIX (such as
	// filenames or arguments given in the system locale) but are always in
	// UTF-8 on Windows.
	// 
	// If you wish to use the return value with #GOptionContext, you must
	// use g_option_context_parse_strv().
	// 
	// The return value is %NULL-terminated and should be freed using
	// g_strfreev().
	GetArguments() (int32, []string)
	// GetCwd wraps g_application_command_line_get_cwd
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the working directory of the command line invocation.
	// The string may contain non-utf8 data.
	// 
	// It is possible that the remote application did not send a working
	// directory, so this may be %NULL.
	// 
	// The return value should not be modified or freed and is valid for as
	// long as @cmdline exists.
	GetCwd() string
	// GetEnviron wraps g_application_command_line_get_environ
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the contents of the 'environ' variable of the command line
	// invocation, as would be returned by g_get_environ(), ie as a
	// %NULL-terminated list of strings in the form 'NAME=VALUE'.
	// The strings may contain non-utf8 data.
	// 
	// The remote application usually does not send an environment.  Use
	// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
	// set it is possible that the environment is still not available (due
	// to invocation messages from other applications).
	// 
	// The return value should not be modified or freed and is valid for as
	// long as @cmdline exists.
	// 
	// See g_application_command_line_getenv() if you are only interested
	// in the value of a single environment variable.
	GetEnviron() []string
	// GetExitStatus wraps g_application_command_line_get_exit_status
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the exit status of @cmdline.  See
	// g_application_command_line_set_exit_status() for more information.
	GetExitStatus() int32
	// GetIsRemote wraps g_application_command_line_get_is_remote
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Determines if @cmdline represents a remote invocation.
	GetIsRemote() bool
	// GetOptionsDict wraps g_application_command_line_get_options_dict
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.VariantDict 
	//
	// Gets the options that were passed to g_application_command_line().
	// 
	// If you did not override local_command_line() then these are the same
	// options that were parsed according to the #GOptionEntrys added to the
	// application with g_application_add_main_option_entries() and possibly
	// modified from your GApplication::handle-local-options handler.
	// 
	// If no options were sent then an empty dictionary is returned so that
	// you don't need to check for %NULL.
	// 
	// The data has been passed via an untrusted external process, so the types of
	// all values must be checked before being used.
	GetOptionsDict() *glib.VariantDict
	// GetStdin wraps g_application_command_line_get_stdin
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream (nullable) 
	//
	// Gets the stdin of the invoking process.
	// 
	// The #GInputStream can be used to read data passed to the standard
	// input of the invoking process.
	// This doesn't work on all platforms.  Presently, it is only available
	// on UNIX when using a D-Bus daemon capable of passing file descriptors.
	// If stdin is not available then %NULL will be returned.  In the
	// future, support may be expanded to other platforms.
	// 
	// You must only call this function once per commandline invocation.
	GetStdin() InputStream
	// Getenv wraps g_application_command_line_getenv
	// 
	// The function takes the following parameters:
	// 
	// 	- name string: the environment variable to get 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the value of a particular environment variable of the command
	// line invocation, as would be returned by g_getenv().  The strings may
	// contain non-utf8 data.
	// 
	// The remote application usually does not send an environment.  Use
	// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
	// set it is possible that the environment is still not available (due
	// to invocation messages from other applications).
	// 
	// The return value should not be modified or freed and is valid for as
	// long as @cmdline exists.
	Getenv(string) string
	// PrintLiteral wraps g_application_command_line_print_literal
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stdout print handler in the invoking process.
	// 
	// Unlike g_application_command_line_print(), @message is not a `printf()`-style
	// format string. Use this function if @message contains text you don't have
	// control over, that could include `printf()` escape sequences.
	PrintLiteral(string)
	// PrinterrLiteral wraps g_application_command_line_printerr_literal
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stderr print handler in the invoking process.
	// 
	// Unlike g_application_command_line_printerr(), @message is not
	// a `printf()`-style format string. Use this function if @message contains text
	// you don't have control over, that could include `printf()` escape sequences.
	PrinterrLiteral(string)
	// SetExitStatus wraps g_application_command_line_set_exit_status
	// 
	// The function takes the following parameters:
	// 
	// 	- exitStatus int32: the exit status 
	//
	// Sets the exit status that will be used when the invoking process
	// exits.
	// 
	// The return value of the #GApplication::command-line signal is
	// passed to this function when the handler returns.  This is the usual
	// way of setting the exit status.
	// 
	// In the event that you want the remote invocation to continue running
	// and want to decide on the exit status in the future, you can use this
	// call.  For the case of a remote invocation, the remote process will
	// typically exit when the last reference is dropped on @cmdline.  The
	// exit status of the remote process will be equal to the last value
	// that was set with this function.
	// 
	// In the case that the commandline invocation is local, the situation
	// is slightly more complicated.  If the commandline invocation results
	// in the mainloop running (ie: because the use-count of the application
	// increased to a non-zero value) then the application is considered to
	// have been 'successful' in a certain sense, and the exit status is
	// always zero.  If the application use count is zero, though, the exit
	// status of the local #GApplicationCommandLine is used.
	// 
	// This method is a no-op if g_application_command_line_done() has
	// been called.
	SetExitStatus(int32)

	// chain up virtual methods:

	// ParentDone calls the default implementations of the `GApplicationCommandLine.done` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// Signals that command line processing is completed.
	// 
	// For remote invocation, it causes the invoking process to terminate.
	// 
	// For local invocation, it does nothing.
	// 
	// This method should be called in the [signal@Gio.Application::command-line]
	// handler, after the exit status is set and all messages are printed.
	// 
	// After this call, g_application_command_line_set_exit_status() has no effect.
	// Subsequent calls to this method are no-ops.
	// 
	// This method is automatically called when the #GApplicationCommandLine
	// object is disposed &#x2014; so you can omit the call in non-garbage collected
	// languages.
	ParentDone()
	// ParentGetStdin calls the default implementations of the `GApplicationCommandLine.get_stdin` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream (nullable) 
	//
	// Gets the stdin of the invoking process.
	// 
	// The #GInputStream can be used to read data passed to the standard
	// input of the invoking process.
	// This doesn't work on all platforms.  Presently, it is only available
	// on UNIX when using a D-Bus daemon capable of passing file descriptors.
	// If stdin is not available then %NULL will be returned.  In the
	// future, support may be expanded to other platforms.
	// 
	// You must only call this function once per commandline invocation.
	ParentGetStdin() InputStream
	// ParentPrintLiteral calls the default implementations of the `GApplicationCommandLine.print_literal` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stdout print handler in the invoking process.
	// 
	// Unlike g_application_command_line_print(), @message is not a `printf()`-style
	// format string. Use this function if @message contains text you don't have
	// control over, that could include `printf()` escape sequences.
	ParentPrintLiteral(message string)
	// ParentPrinterrLiteral calls the default implementations of the `GApplicationCommandLine.printerr_literal` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stderr print handler in the invoking process.
	// 
	// Unlike g_application_command_line_printerr(), @message is not
	// a `printf()`-style format string. Use this function if @message contains text
	// you don't have control over, that could include `printf()` escape sequences.
	ParentPrinterrLiteral(message string)
}

func unsafeWrapApplicationCommandLine(base *gobject.ObjectInstance) *ApplicationCommandLineInstance {
	return &ApplicationCommandLineInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeApplicationCommandLine,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplicationCommandLine(inst)
		},
	)
}

func marshalApplicationCommandLineInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeApplicationCommandLineFromGlibNone is used to convert raw GApplicationCommandLine pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibNone(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibNone(c).(ApplicationCommandLine)
}

// UnsafeApplicationCommandLineFromGlibFull is used to convert raw GApplicationCommandLine pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibFull(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibFull(c).(ApplicationCommandLine)
}

// UnsafeApplicationCommandLineFromGlibBorrow is used to convert raw GApplicationCommandLine pointers to go without touching any references. This is used by the bindings internally.
func UnsafeApplicationCommandLineFromGlibBorrow(c unsafe.Pointer) ApplicationCommandLine {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ApplicationCommandLine)
}

func (a *ApplicationCommandLineInstance) upcastToGApplicationCommandLine() *ApplicationCommandLineInstance {
	return a
}

// UnsafeApplicationCommandLineToGlibNone is used to convert the instance to it's C value GApplicationCommandLine. This is used by the bindings internally.
func UnsafeApplicationCommandLineToGlibNone(c ApplicationCommandLine) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeApplicationCommandLineToGlibFull is used to convert the instance to it's C value GApplicationCommandLine, while removeing the finalizer. This is used by the bindings internally.
func UnsafeApplicationCommandLineToGlibFull(c ApplicationCommandLine) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// CreateFileForArg wraps g_application_command_line_create_file_for_arg
// 
// The function takes the following parameters:
// 
// 	- arg string: an argument from @cmdline 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Creates a #GFile corresponding to a filename that was given as part
// of the invocation of @cmdline.
// 
// This differs from g_file_new_for_commandline_arg() in that it
// resolves relative pathnames using the current working directory of
// the invoking process rather than the local process.
func (cmdline *ApplicationCommandLineInstance) CreateFileForArg(arg string) File {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var cret  *C.GFile                   // return, full, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_command_line_create_file_for_arg(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(arg)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Done wraps g_application_command_line_done
//
// Signals that command line processing is completed.
// 
// For remote invocation, it causes the invoking process to terminate.
// 
// For local invocation, it does nothing.
// 
// This method should be called in the [signal@Gio.Application::command-line]
// handler, after the exit status is set and all messages are printed.
// 
// After this call, g_application_command_line_set_exit_status() has no effect.
// Subsequent calls to this method are no-ops.
// 
// This method is automatically called when the #GApplicationCommandLine
// object is disposed &#x2014; so you can omit the call in non-garbage collected
// languages.
func (cmdline *ApplicationCommandLineInstance) Done() {
	var carg0 *C.GApplicationCommandLine // in, none, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	C.g_application_command_line_done(carg0)
	runtime.KeepAlive(cmdline)
}

// GetArguments wraps g_application_command_line_get_arguments
// 
// The function returns the following values:
// 
// 	- argc int32: the length of the arguments array, or %NULL 
// 	- goret []string 
//
// Gets the list of arguments that was passed on the command line.
// 
// The strings in the array may contain non-UTF-8 data on UNIX (such as
// filenames or arguments given in the system locale) but are always in
// UTF-8 on Windows.
// 
// If you wish to use the return value with #GOptionContext, you must
// use g_option_context_parse_strv().
// 
// The return value is %NULL-terminated and should be freed using
// g_strfreev().
func (cmdline *ApplicationCommandLineInstance) GetArguments() (int32, []string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 C.int                      // out, full, casted
	var cret  **C.gchar                  // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_arguments(carg0, &carg1)
	runtime.KeepAlive(cmdline)

	var argc  int32
	var goret []string

	argc = int32(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return argc, goret
}

// GetCwd wraps g_application_command_line_get_cwd
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the working directory of the command line invocation.
// The string may contain non-utf8 data.
// 
// It is possible that the remote application did not send a working
// directory, so this may be %NULL.
// 
// The return value should not be modified or freed and is valid for as
// long as @cmdline exists.
func (cmdline *ApplicationCommandLineInstance) GetCwd() string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.gchar                   // return, none, string, nullable

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_cwd(carg0)
	runtime.KeepAlive(cmdline)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetEnviron wraps g_application_command_line_get_environ
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the contents of the 'environ' variable of the command line
// invocation, as would be returned by g_get_environ(), ie as a
// %NULL-terminated list of strings in the form 'NAME=VALUE'.
// The strings may contain non-utf8 data.
// 
// The remote application usually does not send an environment.  Use
// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
// set it is possible that the environment is still not available (due
// to invocation messages from other applications).
// 
// The return value should not be modified or freed and is valid for as
// long as @cmdline exists.
// 
// See g_application_command_line_getenv() if you are only interested
// in the value of a single environment variable.
func (cmdline *ApplicationCommandLineInstance) GetEnviron() []string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  **C.gchar                  // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_environ(carg0)
	runtime.KeepAlive(cmdline)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetExitStatus wraps g_application_command_line_get_exit_status
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the exit status of @cmdline.  See
// g_application_command_line_set_exit_status() for more information.
func (cmdline *ApplicationCommandLineInstance) GetExitStatus() int32 {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  C.int                      // return, none, casted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_exit_status(carg0)
	runtime.KeepAlive(cmdline)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetIsRemote wraps g_application_command_line_get_is_remote
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if @cmdline represents a remote invocation.
func (cmdline *ApplicationCommandLineInstance) GetIsRemote() bool {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  C.gboolean                 // return

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_is_remote(carg0)
	runtime.KeepAlive(cmdline)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetOptionsDict wraps g_application_command_line_get_options_dict
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantDict 
//
// Gets the options that were passed to g_application_command_line().
// 
// If you did not override local_command_line() then these are the same
// options that were parsed according to the #GOptionEntrys added to the
// application with g_application_add_main_option_entries() and possibly
// modified from your GApplication::handle-local-options handler.
// 
// If no options were sent then an empty dictionary is returned so that
// you don't need to check for %NULL.
// 
// The data has been passed via an untrusted external process, so the types of
// all values must be checked before being used.
func (cmdline *ApplicationCommandLineInstance) GetOptionsDict() *glib.VariantDict {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.GVariantDict            // return, none, converted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_options_dict(carg0)
	runtime.KeepAlive(cmdline)

	var goret *glib.VariantDict

	goret = glib.UnsafeVariantDictFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetStdin wraps g_application_command_line_get_stdin
// 
// The function returns the following values:
// 
// 	- goret InputStream (nullable) 
//
// Gets the stdin of the invoking process.
// 
// The #GInputStream can be used to read data passed to the standard
// input of the invoking process.
// This doesn't work on all platforms.  Presently, it is only available
// on UNIX when using a D-Bus daemon capable of passing file descriptors.
// If stdin is not available then %NULL will be returned.  In the
// future, support may be expanded to other platforms.
// 
// You must only call this function once per commandline invocation.
func (cmdline *ApplicationCommandLineInstance) GetStdin() InputStream {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var cret  *C.GInputStream            // return, full, converted, nullable

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C.g_application_command_line_get_stdin(carg0)
	runtime.KeepAlive(cmdline)

	var goret InputStream

	if cret != nil {
		goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// Getenv wraps g_application_command_line_getenv
// 
// The function takes the following parameters:
// 
// 	- name string: the environment variable to get 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the value of a particular environment variable of the command
// line invocation, as would be returned by g_getenv().  The strings may
// contain non-utf8 data.
// 
// The remote application usually does not send an environment.  Use
// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
// set it is possible that the environment is still not available (due
// to invocation messages from other applications).
// 
// The return value should not be modified or freed and is valid for as
// long as @cmdline exists.
func (cmdline *ApplicationCommandLineInstance) Getenv(name string) string {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var cret  *C.gchar                   // return, none, string, nullable-string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_application_command_line_getenv(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(name)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PrintLiteral wraps g_application_command_line_print_literal
// 
// The function takes the following parameters:
// 
// 	- message string: the message 
//
// Prints a message using the stdout print handler in the invoking process.
// 
// Unlike g_application_command_line_print(), @message is not a `printf()`-style
// format string. Use this function if @message contains text you don't have
// control over, that could include `printf()` escape sequences.
func (cmdline *ApplicationCommandLineInstance) PrintLiteral(message string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_command_line_print_literal(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// PrinterrLiteral wraps g_application_command_line_printerr_literal
// 
// The function takes the following parameters:
// 
// 	- message string: the message 
//
// Prints a message using the stderr print handler in the invoking process.
// 
// Unlike g_application_command_line_printerr(), @message is not
// a `printf()`-style format string. Use this function if @message contains text
// you don't have control over, that could include `printf()` escape sequences.
func (cmdline *ApplicationCommandLineInstance) PrinterrLiteral(message string) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 *C.gchar                   // in, none, string

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_application_command_line_printerr_literal(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// SetExitStatus wraps g_application_command_line_set_exit_status
// 
// The function takes the following parameters:
// 
// 	- exitStatus int32: the exit status 
//
// Sets the exit status that will be used when the invoking process
// exits.
// 
// The return value of the #GApplication::command-line signal is
// passed to this function when the handler returns.  This is the usual
// way of setting the exit status.
// 
// In the event that you want the remote invocation to continue running
// and want to decide on the exit status in the future, you can use this
// call.  For the case of a remote invocation, the remote process will
// typically exit when the last reference is dropped on @cmdline.  The
// exit status of the remote process will be equal to the last value
// that was set with this function.
// 
// In the case that the commandline invocation is local, the situation
// is slightly more complicated.  If the commandline invocation results
// in the mainloop running (ie: because the use-count of the application
// increased to a non-zero value) then the application is considered to
// have been 'successful' in a certain sense, and the exit status is
// always zero.  If the application use count is zero, though, the exit
// status of the local #GApplicationCommandLine is used.
// 
// This method is a no-op if g_application_command_line_done() has
// been called.
func (cmdline *ApplicationCommandLineInstance) SetExitStatus(exitStatus int32) {
	var carg0 *C.GApplicationCommandLine // in, none, converted
	var carg1 C.int                      // in, none, casted

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = C.int(exitStatus)

	C.g_application_command_line_set_exit_status(carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(exitStatus)
}

// ApplicationCommandLineOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ApplicationCommandLineOverrides[Instance ApplicationCommandLine] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Done allows you to override the implementation of the virtual method done.
	//
	// Signals that command line processing is completed.
	// 
	// For remote invocation, it causes the invoking process to terminate.
	// 
	// For local invocation, it does nothing.
	// 
	// This method should be called in the [signal@Gio.Application::command-line]
	// handler, after the exit status is set and all messages are printed.
	// 
	// After this call, g_application_command_line_set_exit_status() has no effect.
	// Subsequent calls to this method are no-ops.
	// 
	// This method is automatically called when the #GApplicationCommandLine
	// object is disposed &#x2014; so you can omit the call in non-garbage collected
	// languages.
	Done func(Instance)
	// // GetStdin allows you to override the implementation of the virtual method get_stdin.
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream (nullable) 
	//
	// Gets the stdin of the invoking process.
	// 
	// The #GInputStream can be used to read data passed to the standard
	// input of the invoking process.
	// This doesn't work on all platforms.  Presently, it is only available
	// on UNIX when using a D-Bus daemon capable of passing file descriptors.
	// If stdin is not available then %NULL will be returned.  In the
	// future, support may be expanded to other platforms.
	// 
	// You must only call this function once per commandline invocation.
	GetStdin func(Instance) InputStream
	// // PrintLiteral allows you to override the implementation of the virtual method print_literal.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stdout print handler in the invoking process.
	// 
	// Unlike g_application_command_line_print(), @message is not a `printf()`-style
	// format string. Use this function if @message contains text you don't have
	// control over, that could include `printf()` escape sequences.
	PrintLiteral func(Instance, string)
	// // PrinterrLiteral allows you to override the implementation of the virtual method printerr_literal.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: the message 
	//
	// Prints a message using the stderr print handler in the invoking process.
	// 
	// Unlike g_application_command_line_printerr(), @message is not
	// a `printf()`-style format string. Use this function if @message contains text
	// you don't have control over, that could include `printf()` escape sequences.
	PrinterrLiteral func(Instance, string)
}

// UnsafeApplyApplicationCommandLineOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyApplicationCommandLineOverrides[Instance ApplicationCommandLine](gclass unsafe.Pointer, overrides ApplicationCommandLineOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GApplicationCommandLineClass)(gclass)

	if overrides.Done != nil {
		pclass.done = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_done)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_done",
			func(carg0 *C.GApplicationCommandLine) {
				var cmdline Instance // go GApplicationCommandLine subclass

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Done(cmdline)
			},
		)
	}

	if overrides.GetStdin != nil {
		pclass.get_stdin = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_get_stdin)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_get_stdin",
			func(carg0 *C.GApplicationCommandLine) (cret *C.GInputStream) {
				var cmdline Instance    // go GApplicationCommandLine subclass
				var goret   InputStream // return, full, converted, nullable

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetStdin(cmdline)

				if goret != nil {
					cret = (*C.GInputStream)(UnsafeInputStreamToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.PrintLiteral != nil {
		pclass.print_literal = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_print_literal)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_print_literal",
			func(carg0 *C.GApplicationCommandLine, carg1 *C.gchar) {
				var cmdline Instance // go GApplicationCommandLine subclass
				var message string   // in, none, string

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.PrintLiteral(cmdline, message)
			},
		)
	}

	if overrides.PrinterrLiteral != nil {
		pclass.printerr_literal = (*[0]byte)(C._goglib_gio2_ApplicationCommandLine_printerr_literal)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ApplicationCommandLine_printerr_literal",
			func(carg0 *C.GApplicationCommandLine, carg1 *C.gchar) {
				var cmdline Instance // go GApplicationCommandLine subclass
				var message string   // in, none, string

				cmdline = UnsafeApplicationCommandLineFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.PrinterrLiteral(cmdline, message)
			},
		)
	}
}

// ParentDone calls the default implementations of the `GApplicationCommandLine.done` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// Signals that command line processing is completed.
// 
// For remote invocation, it causes the invoking process to terminate.
// 
// For local invocation, it does nothing.
// 
// This method should be called in the [signal@Gio.Application::command-line]
// handler, after the exit status is set and all messages are printed.
// 
// After this call, g_application_command_line_set_exit_status() has no effect.
// Subsequent calls to this method are no-ops.
// 
// This method is automatically called when the #GApplicationCommandLine
// object is disposed &#x2014; so you can omit the call in non-garbage collected
// languages.
func (cmdline *ApplicationCommandLineInstance) ParentDone() {
	var carg0 *C.GApplicationCommandLine

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	C._goglib_gio2_ApplicationCommandLine_virtual_done(unsafe.Pointer(parentclass.done), carg0)
	runtime.KeepAlive(cmdline)
}

// ParentGetStdin calls the default implementations of the `GApplicationCommandLine.get_stdin` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret InputStream (nullable) 
//
// Gets the stdin of the invoking process.
// 
// The #GInputStream can be used to read data passed to the standard
// input of the invoking process.
// This doesn't work on all platforms.  Presently, it is only available
// on UNIX when using a D-Bus daemon capable of passing file descriptors.
// If stdin is not available then %NULL will be returned.  In the
// future, support may be expanded to other platforms.
// 
// You must only call this function once per commandline invocation.
func (cmdline *ApplicationCommandLineInstance) ParentGetStdin() InputStream {
	var carg0 *C.GApplicationCommandLine
	var cret  *C.GInputStream // return, full, converted, nullable

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))

	cret = C._goglib_gio2_ApplicationCommandLine_virtual_get_stdin(unsafe.Pointer(parentclass.get_stdin), carg0)
	runtime.KeepAlive(cmdline)

	var goret InputStream

	if cret != nil {
		goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentPrintLiteral calls the default implementations of the `GApplicationCommandLine.print_literal` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- message string: the message 
//
// Prints a message using the stdout print handler in the invoking process.
// 
// Unlike g_application_command_line_print(), @message is not a `printf()`-style
// format string. Use this function if @message contains text you don't have
// control over, that could include `printf()` escape sequences.
func (cmdline *ApplicationCommandLineInstance) ParentPrintLiteral(message string) {
	var carg0 *C.GApplicationCommandLine
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_ApplicationCommandLine_virtual_print_literal(unsafe.Pointer(parentclass.print_literal), carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// ParentPrinterrLiteral calls the default implementations of the `GApplicationCommandLine.printerr_literal` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- message string: the message 
//
// Prints a message using the stderr print handler in the invoking process.
// 
// Unlike g_application_command_line_printerr(), @message is not
// a `printf()`-style format string. Use this function if @message contains text
// you don't have control over, that could include `printf()` escape sequences.
func (cmdline *ApplicationCommandLineInstance) ParentPrinterrLiteral(message string) {
	var carg0 *C.GApplicationCommandLine
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GApplicationCommandLineClass)(classdata.PeekParentClass(UnsafeApplicationCommandLineToGlibNone(cmdline)))

	carg0 = (*C.GApplicationCommandLine)(UnsafeApplicationCommandLineToGlibNone(cmdline))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_ApplicationCommandLine_virtual_printerr_literal(unsafe.Pointer(parentclass.printerr_literal), carg0, carg1)
	runtime.KeepAlive(cmdline)
	runtime.KeepAlive(message)
}

// RegisterApplicationCommandLineSubClass is used to register a go subclass of GApplicationCommandLine. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterApplicationCommandLineSubClass[InstanceT ApplicationCommandLine](
		name string,
		classInit func(class *ApplicationCommandLineClass),
		constructor func() InstanceT,
		overrides ApplicationCommandLineOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeApplicationCommandLine,
		UnsafeApplicationCommandLineClassFromGlibBorrow,
		UnsafeApplyApplicationCommandLineOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapApplicationCommandLine(obj)
		},
		interfaceInits...,
	)
}

// BytesIconInstance is the instance type used by all types extending GBytesIcon. It is used internally by the bindings. Users should use the interface [BytesIcon] instead.
type BytesIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ BytesIcon = (*BytesIconInstance)(nil)

// BytesIcon wraps GBytesIcon
//
// `GBytesIcon` specifies an image held in memory in a common format (usually
// PNG) to be used as icon.
type BytesIcon interface {
	gobject.Object
	upcastToGBytesIcon() *BytesIconInstance

	// GetBytes wraps g_bytes_icon_get_bytes
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	//
	// Gets the #GBytes associated with the given @icon.
	GetBytes() *glib.Bytes
}

func unsafeWrapBytesIcon(base *gobject.ObjectInstance) *BytesIconInstance {
	return &BytesIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBytesIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBytesIcon(inst)
		},
	)
}

func marshalBytesIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBytesIconFromGlibNone is used to convert raw GBytesIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBytesIconFromGlibNone(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(BytesIcon)
}

// UnsafeBytesIconFromGlibFull is used to convert raw GBytesIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBytesIconFromGlibFull(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(BytesIcon)
}

// UnsafeBytesIconFromGlibBorrow is used to convert raw GBytesIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBytesIconFromGlibBorrow(c unsafe.Pointer) BytesIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BytesIcon)
}

func (b *BytesIconInstance) upcastToGBytesIcon() *BytesIconInstance {
	return b
}

// UnsafeBytesIconToGlibNone is used to convert the instance to it's C value GBytesIcon. This is used by the bindings internally.
func UnsafeBytesIconToGlibNone(c BytesIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBytesIconToGlibFull is used to convert the instance to it's C value GBytesIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBytesIconToGlibFull(c BytesIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBytesIcon wraps g_bytes_icon_new
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: a #GBytes. 
// 
// The function returns the following values:
// 
// 	- goret BytesIcon 
//
// Creates a new icon for a bytes.
// 
// This cannot fail, but loading and interpreting the bytes may fail later on
// (for example, if g_loadable_icon_load() is called) if the image is invalid.
func NewBytesIcon(bytes *glib.Bytes) BytesIcon {
	var carg1 *C.GBytes // in, none, converted
	var cret  *C.GIcon  // return, full, converted

	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_bytes_icon_new(carg1)
	runtime.KeepAlive(bytes)

	var goret BytesIcon

	goret = UnsafeBytesIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetBytes wraps g_bytes_icon_get_bytes
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
//
// Gets the #GBytes associated with the given @icon.
func (icon *BytesIconInstance) GetBytes() *glib.Bytes {
	var carg0 *C.GBytesIcon // in, none, converted
	var cret  *C.GBytes     // return, none, converted

	carg0 = (*C.GBytesIcon)(UnsafeBytesIconToGlibNone(icon))

	cret = C.g_bytes_icon_get_bytes(carg0)
	runtime.KeepAlive(icon)

	var goret *glib.Bytes

	goret = glib.UnsafeBytesFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// CancellableInstance is the instance type used by all types extending GCancellable. It is used internally by the bindings. Users should use the interface [Cancellable] instead.
type CancellableInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Cancellable = (*CancellableInstance)(nil)

// Cancellable wraps GCancellable
//
// `GCancellable` allows operations to be cancelled.
// 
// `GCancellable` is a thread-safe operation cancellation stack used
// throughout GIO to allow for cancellation of synchronous and
// asynchronous operations.
type Cancellable interface {
	gobject.Object
	upcastToGCancellable() *CancellableInstance

	// Cancel wraps g_cancellable_cancel
	//
	// Will set @cancellable to cancelled, and will emit the
	// #GCancellable::cancelled signal. (However, see the warning about
	// race conditions in the documentation for that signal if you are
	// planning to connect to it.)
	// 
	// This function is thread-safe. In other words, you can safely call
	// it from a thread other than the one running the operation that was
	// passed the @cancellable.
	// 
	// If @cancellable is %NULL, this function returns immediately for convenience.
	// 
	// The convention within GIO is that cancelling an asynchronous
	// operation causes it to complete asynchronously. That is, if you
	// cancel the operation from the same thread in which it is running,
	// then the operation's #GAsyncReadyCallback will not be invoked until
	// the application returns to the main loop.
	// 
	// It is safe (although useless, since it will be a no-op) to call
	// this function from a [signal@Gio.Cancellable::cancelled] signal handler.
	Cancel()
	// Disconnect wraps g_cancellable_disconnect
	// 
	// The function takes the following parameters:
	// 
	// 	- handlerId uint32: Handler id of the handler to be disconnected, or `0`. 
	//
	// Disconnects a handler from a cancellable instance similar to
	// g_signal_handler_disconnect().  Additionally, in the event that a
	// signal handler is currently running, this call will block until the
	// handler has finished.  Calling this function from a
	// #GCancellable::cancelled signal handler will therefore result in a
	// deadlock.
	// 
	// This avoids a race condition where a thread cancels at the
	// same time as the cancellable operation is finished and the
	// signal handler is removed. See #GCancellable::cancelled for
	// details on how to use this.
	// 
	// If @cancellable is %NULL or @handler_id is `0` this function does
	// nothing.
	Disconnect(uint32)
	// GetFd wraps g_cancellable_get_fd
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the file descriptor for a cancellable job. This can be used to
	// implement cancellable operations on Unix systems. The returned fd will
	// turn readable when @cancellable is cancelled.
	// 
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done
	// with g_cancellable_reset().
	// 
	// After a successful return from this function, you should use
	// g_cancellable_release_fd() to free up resources allocated for
	// the returned file descriptor.
	// 
	// See also g_cancellable_make_pollfd().
	GetFd() int32
	// IsCancelled wraps g_cancellable_is_cancelled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a cancellable job has been cancelled.
	IsCancelled() bool
	// MakePollfd wraps g_cancellable_make_pollfd
	// 
	// The function takes the following parameters:
	// 
	// 	- pollfd *glib.PollFD: a pointer to a #GPollFD 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Creates a #GPollFD corresponding to @cancellable; this can be passed
	// to g_poll() and used to poll for cancellation. This is useful both
	// for unix systems without a native poll and for portability to
	// windows.
	// 
	// When this function returns %TRUE, you should use
	// g_cancellable_release_fd() to free up resources allocated for the
	// @pollfd. After a %FALSE return, do not call g_cancellable_release_fd().
	// 
	// If this function returns %FALSE, either no @cancellable was given or
	// resource limits prevent this function from allocating the necessary
	// structures for polling. (On Linux, you will likely have reached
	// the maximum number of file descriptors.) The suggested way to handle
	// these cases is to ignore the @cancellable.
	// 
	// You are not supposed to read from the fd yourself, just check for
	// readable status. Reading to unset the readable status is done
	// with g_cancellable_reset().
	// 
	// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
	// currently running, this call will block until the handler has finished.
	// Calling this function from a signal handler will therefore result in a
	// deadlock.
	MakePollfd(*glib.PollFD) bool
	// PopCurrent wraps g_cancellable_pop_current
	//
	// Pops @cancellable off the cancellable stack (verifying that @cancellable
	// is on the top of the stack).
	PopCurrent()
	// PushCurrent wraps g_cancellable_push_current
	//
	// Pushes @cancellable onto the cancellable stack. The current
	// cancellable can then be received using g_cancellable_get_current().
	// 
	// This is useful when implementing cancellable operations in
	// code that does not allow you to pass down the cancellable object.
	// 
	// This is typically called automatically by e.g. #GFile operations,
	// so you rarely have to call this yourself.
	PushCurrent()
	// ReleaseFd wraps g_cancellable_release_fd
	//
	// Releases a resources previously allocated by g_cancellable_get_fd()
	// or g_cancellable_make_pollfd().
	// 
	// For compatibility reasons with older releases, calling this function
	// is not strictly required, the resources will be automatically freed
	// when the @cancellable is finalized. However, the @cancellable will
	// block scarce file descriptors until it is finalized if this function
	// is not called. This can cause the application to run out of file
	// descriptors when many #GCancellables are used at the same time.
	// 
	// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
	// currently running, this call will block until the handler has finished.
	// Calling this function from a signal handler will therefore result in a
	// deadlock.
	ReleaseFd()
	// Reset wraps g_cancellable_reset
	//
	// Resets @cancellable to its uncancelled state.
	// 
	// If cancellable is currently in use by any cancellable operation
	// then the behavior of this function is undefined.
	// 
	// Note that it is generally not a good idea to reuse an existing
	// cancellable for more operations after it has been cancelled once,
	// as this function might tempt you to do. The recommended practice
	// is to drop the reference to a cancellable after cancelling it,
	// and let it die with the outstanding async operations. You should
	// create a fresh cancellable for further async operations.
	// 
	// In the event that a [signal@Gio.Cancellable::cancelled] signal handler is currently
	// running, this call will block until the handler has finished.
	// Calling this function from a signal handler will therefore result in a
	// deadlock.
	Reset()
	// SetErrorIfCancelled wraps g_cancellable_set_error_if_cancelled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// If the @cancellable is cancelled, sets the error to notify
	// that the operation was cancelled.
	SetErrorIfCancelled() (bool, error)
	// ConnectCancelled connects the provided callback to the "cancelled" signal
	//
	// Emitted when the operation has been cancelled.
	// 
	// Can be used by implementations of cancellable operations. If the
	// operation is cancelled from another thread, the signal will be
	// emitted in the thread that cancelled the operation, not the
	// thread that is running the operation.
	// 
	// Note that disconnecting from this signal (or any signal) in a
	// multi-threaded program is prone to race conditions. For instance
	// it is possible that a signal handler may be invoked even after
	// a call to g_signal_handler_disconnect() for that handler has
	// already returned.
	// 
	// There is also a problem when cancellation happens right before
	// connecting to the signal. If this happens the signal will
	// unexpectedly not be emitted, and checking before connecting to
	// the signal leaves a race condition where this is still happening.
	// 
	// In order to make it safe and easy to connect handlers there
	// are two helper functions: g_cancellable_connect() and
	// g_cancellable_disconnect() which protect against problems
	// like this.
	// 
	// An example of how to us this:
	// |[&lt;!-- language="C" --&gt;
	//     // Make sure we don't do unnecessary work if already cancelled
	//     if (g_cancellable_set_error_if_cancelled (cancellable, error))
	//       return;
	// 
	//     // Set up all the data needed to be able to handle cancellation
	//     // of the operation
	//     my_data = my_data_new (...);
	// 
	//     id = 0;
	//     if (cancellable)
	//       id = g_cancellable_connect (cancellable,
	//     			      G_CALLBACK (cancelled_handler)
	//     			      data, NULL);
	// 
	//     // cancellable operation here...
	// 
	//     g_cancellable_disconnect (cancellable, id);
	// 
	//     // cancelled_handler is never called after this, it is now safe
	//     // to free the data
	//     my_data_free (my_data);
	// ]|
	// 
	// Note that the cancelled signal is emitted in the thread that
	// the user cancelled from, which may be the main thread. So, the
	// cancellable signal should not do something that can block.
	ConnectCancelled(func(Cancellable)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentCancelled calls the default implementations of the `GCancellable.cancelled` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	ParentCancelled()
}

func unsafeWrapCancellable(base *gobject.ObjectInstance) *CancellableInstance {
	return &CancellableInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCancellable,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCancellable(inst)
		},
	)
}

func marshalCancellableInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCancellableFromGlibNone is used to convert raw GCancellable pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCancellableFromGlibNone(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibNone(c).(Cancellable)
}

// UnsafeCancellableFromGlibFull is used to convert raw GCancellable pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCancellableFromGlibFull(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibFull(c).(Cancellable)
}

// UnsafeCancellableFromGlibBorrow is used to convert raw GCancellable pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCancellableFromGlibBorrow(c unsafe.Pointer) Cancellable {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Cancellable)
}

func (c *CancellableInstance) upcastToGCancellable() *CancellableInstance {
	return c
}

// UnsafeCancellableToGlibNone is used to convert the instance to it's C value GCancellable. This is used by the bindings internally.
func UnsafeCancellableToGlibNone(c Cancellable) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCancellableToGlibFull is used to convert the instance to it's C value GCancellable, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCancellableToGlibFull(c Cancellable) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCancellable wraps g_cancellable_new
// 
// The function returns the following values:
// 
// 	- goret Cancellable 
//
// Creates a new #GCancellable object.
// 
// Applications that want to start one or more operations
// that should be cancellable should create a #GCancellable
// and pass it to the operations.
// 
// One #GCancellable can be used in multiple consecutive
// operations or in multiple concurrent operations.
func NewCancellable() Cancellable {
	var cret *C.GCancellable // return, full, converted

	cret = C.g_cancellable_new()

	var goret Cancellable

	goret = UnsafeCancellableFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// CancellableGetCurrent wraps g_cancellable_get_current
// 
// The function returns the following values:
// 
// 	- goret Cancellable (nullable) 
//
// Gets the top cancellable from the stack.
func CancellableGetCurrent() Cancellable {
	var cret *C.GCancellable // return, none, converted, nullable

	cret = C.g_cancellable_get_current()

	var goret Cancellable

	if cret != nil {
		goret = UnsafeCancellableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Cancel wraps g_cancellable_cancel
//
// Will set @cancellable to cancelled, and will emit the
// #GCancellable::cancelled signal. (However, see the warning about
// race conditions in the documentation for that signal if you are
// planning to connect to it.)
// 
// This function is thread-safe. In other words, you can safely call
// it from a thread other than the one running the operation that was
// passed the @cancellable.
// 
// If @cancellable is %NULL, this function returns immediately for convenience.
// 
// The convention within GIO is that cancelling an asynchronous
// operation causes it to complete asynchronously. That is, if you
// cancel the operation from the same thread in which it is running,
// then the operation's #GAsyncReadyCallback will not be invoked until
// the application returns to the main loop.
// 
// It is safe (although useless, since it will be a no-op) to call
// this function from a [signal@Gio.Cancellable::cancelled] signal handler.
func (cancellable *CancellableInstance) Cancel() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_cancel(carg0)
	runtime.KeepAlive(cancellable)
}

// Disconnect wraps g_cancellable_disconnect
// 
// The function takes the following parameters:
// 
// 	- handlerId uint32: Handler id of the handler to be disconnected, or `0`. 
//
// Disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect().  Additionally, in the event that a
// signal handler is currently running, this call will block until the
// handler has finished.  Calling this function from a
// #GCancellable::cancelled signal handler will therefore result in a
// deadlock.
// 
// This avoids a race condition where a thread cancels at the
// same time as the cancellable operation is finished and the
// signal handler is removed. See #GCancellable::cancelled for
// details on how to use this.
// 
// If @cancellable is %NULL or @handler_id is `0` this function does
// nothing.
func (cancellable *CancellableInstance) Disconnect(handlerId uint32) {
	var carg0 *C.GCancellable // in, none, converted
	var carg1 C.gulong        // in, none, casted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	carg1 = C.gulong(handlerId)

	C.g_cancellable_disconnect(carg0, carg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(handlerId)
}

// GetFd wraps g_cancellable_get_fd
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the file descriptor for a cancellable job. This can be used to
// implement cancellable operations on Unix systems. The returned fd will
// turn readable when @cancellable is cancelled.
// 
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done
// with g_cancellable_reset().
// 
// After a successful return from this function, you should use
// g_cancellable_release_fd() to free up resources allocated for
// the returned file descriptor.
// 
// See also g_cancellable_make_pollfd().
func (cancellable *CancellableInstance) GetFd() int32 {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.int           // return, none, casted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_get_fd(carg0)
	runtime.KeepAlive(cancellable)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsCancelled wraps g_cancellable_is_cancelled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a cancellable job has been cancelled.
func (cancellable *CancellableInstance) IsCancelled() bool {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_is_cancelled(carg0)
	runtime.KeepAlive(cancellable)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MakePollfd wraps g_cancellable_make_pollfd
// 
// The function takes the following parameters:
// 
// 	- pollfd *glib.PollFD: a pointer to a #GPollFD 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Creates a #GPollFD corresponding to @cancellable; this can be passed
// to g_poll() and used to poll for cancellation. This is useful both
// for unix systems without a native poll and for portability to
// windows.
// 
// When this function returns %TRUE, you should use
// g_cancellable_release_fd() to free up resources allocated for the
// @pollfd. After a %FALSE return, do not call g_cancellable_release_fd().
// 
// If this function returns %FALSE, either no @cancellable was given or
// resource limits prevent this function from allocating the necessary
// structures for polling. (On Linux, you will likely have reached
// the maximum number of file descriptors.) The suggested way to handle
// these cases is to ignore the @cancellable.
// 
// You are not supposed to read from the fd yourself, just check for
// readable status. Reading to unset the readable status is done
// with g_cancellable_reset().
// 
// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
// currently running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (cancellable *CancellableInstance) MakePollfd(pollfd *glib.PollFD) bool {
	var carg0 *C.GCancellable // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	carg1 = (*C.GPollFD)(glib.UnsafePollFDToGlibNone(pollfd))

	cret = C.g_cancellable_make_pollfd(carg0, carg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(pollfd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PopCurrent wraps g_cancellable_pop_current
//
// Pops @cancellable off the cancellable stack (verifying that @cancellable
// is on the top of the stack).
func (cancellable *CancellableInstance) PopCurrent() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_pop_current(carg0)
	runtime.KeepAlive(cancellable)
}

// PushCurrent wraps g_cancellable_push_current
//
// Pushes @cancellable onto the cancellable stack. The current
// cancellable can then be received using g_cancellable_get_current().
// 
// This is useful when implementing cancellable operations in
// code that does not allow you to pass down the cancellable object.
// 
// This is typically called automatically by e.g. #GFile operations,
// so you rarely have to call this yourself.
func (cancellable *CancellableInstance) PushCurrent() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_push_current(carg0)
	runtime.KeepAlive(cancellable)
}

// ReleaseFd wraps g_cancellable_release_fd
//
// Releases a resources previously allocated by g_cancellable_get_fd()
// or g_cancellable_make_pollfd().
// 
// For compatibility reasons with older releases, calling this function
// is not strictly required, the resources will be automatically freed
// when the @cancellable is finalized. However, the @cancellable will
// block scarce file descriptors until it is finalized if this function
// is not called. This can cause the application to run out of file
// descriptors when many #GCancellables are used at the same time.
// 
// Note that in the event that a [signal@Gio.Cancellable::cancelled] signal handler is
// currently running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (cancellable *CancellableInstance) ReleaseFd() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_release_fd(carg0)
	runtime.KeepAlive(cancellable)
}

// Reset wraps g_cancellable_reset
//
// Resets @cancellable to its uncancelled state.
// 
// If cancellable is currently in use by any cancellable operation
// then the behavior of this function is undefined.
// 
// Note that it is generally not a good idea to reuse an existing
// cancellable for more operations after it has been cancelled once,
// as this function might tempt you to do. The recommended practice
// is to drop the reference to a cancellable after cancelling it,
// and let it die with the outstanding async operations. You should
// create a fresh cancellable for further async operations.
// 
// In the event that a [signal@Gio.Cancellable::cancelled] signal handler is currently
// running, this call will block until the handler has finished.
// Calling this function from a signal handler will therefore result in a
// deadlock.
func (cancellable *CancellableInstance) Reset() {
	var carg0 *C.GCancellable // in, none, converted

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C.g_cancellable_reset(carg0)
	runtime.KeepAlive(cancellable)
}

// SetErrorIfCancelled wraps g_cancellable_set_error_if_cancelled
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// If the @cancellable is cancelled, sets the error to notify
// that the operation was cancelled.
func (cancellable *CancellableInstance) SetErrorIfCancelled() (bool, error) {
	var carg0 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	cret = C.g_cancellable_set_error_if_cancelled(carg0, &_cerr)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectCancelled connects the provided callback to the "cancelled" signal
//
// Emitted when the operation has been cancelled.
// 
// Can be used by implementations of cancellable operations. If the
// operation is cancelled from another thread, the signal will be
// emitted in the thread that cancelled the operation, not the
// thread that is running the operation.
// 
// Note that disconnecting from this signal (or any signal) in a
// multi-threaded program is prone to race conditions. For instance
// it is possible that a signal handler may be invoked even after
// a call to g_signal_handler_disconnect() for that handler has
// already returned.
// 
// There is also a problem when cancellation happens right before
// connecting to the signal. If this happens the signal will
// unexpectedly not be emitted, and checking before connecting to
// the signal leaves a race condition where this is still happening.
// 
// In order to make it safe and easy to connect handlers there
// are two helper functions: g_cancellable_connect() and
// g_cancellable_disconnect() which protect against problems
// like this.
// 
// An example of how to us this:
// |[&lt;!-- language="C" --&gt;
//     // Make sure we don't do unnecessary work if already cancelled
//     if (g_cancellable_set_error_if_cancelled (cancellable, error))
//       return;
// 
//     // Set up all the data needed to be able to handle cancellation
//     // of the operation
//     my_data = my_data_new (...);
// 
//     id = 0;
//     if (cancellable)
//       id = g_cancellable_connect (cancellable,
//     			      G_CALLBACK (cancelled_handler)
//     			      data, NULL);
// 
//     // cancellable operation here...
// 
//     g_cancellable_disconnect (cancellable, id);
// 
//     // cancelled_handler is never called after this, it is now safe
//     // to free the data
//     my_data_free (my_data);
// ]|
// 
// Note that the cancelled signal is emitted in the thread that
// the user cancelled from, which may be the main thread. So, the
// cancellable signal should not do something that can block.
func (o *CancellableInstance) ConnectCancelled(fn func(Cancellable)) gobject.SignalHandle {
	return o.Connect("cancelled", fn)
}

// CancellableOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type CancellableOverrides[Instance Cancellable] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Cancelled allows you to override the implementation of the virtual method cancelled.
	Cancelled func(Instance)
}

// UnsafeApplyCancellableOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyCancellableOverrides[Instance Cancellable](gclass unsafe.Pointer, overrides CancellableOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GCancellableClass)(gclass)

	if overrides.Cancelled != nil {
		pclass.cancelled = (*[0]byte)(C._goglib_gio2_Cancellable_cancelled)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Cancellable_cancelled",
			func(carg0 *C.GCancellable) {
				var cancellable Instance // go GCancellable subclass

				cancellable = UnsafeCancellableFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Cancelled(cancellable)
			},
		)
	}
}

// ParentCancelled calls the default implementations of the `GCancellable.cancelled` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
func (cancellable *CancellableInstance) ParentCancelled() {
	var carg0 *C.GCancellable

	parentclass := (*C.GCancellableClass)(classdata.PeekParentClass(UnsafeCancellableToGlibNone(cancellable)))

	carg0 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))

	C._goglib_gio2_Cancellable_virtual_cancelled(unsafe.Pointer(parentclass.cancelled), carg0)
	runtime.KeepAlive(cancellable)
}

// RegisterCancellableSubClass is used to register a go subclass of GCancellable. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterCancellableSubClass[InstanceT Cancellable](
		name string,
		classInit func(class *CancellableClass),
		constructor func() InstanceT,
		overrides CancellableOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeCancellable,
		UnsafeCancellableClassFromGlibBorrow,
		UnsafeApplyCancellableOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCancellable(obj)
		},
		interfaceInits...,
	)
}

// CharsetConverterInstance is the instance type used by all types extending GCharsetConverter. It is used internally by the bindings. Users should use the interface [CharsetConverter] instead.
type CharsetConverterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ CharsetConverter = (*CharsetConverterInstance)(nil)

// CharsetConverter wraps GCharsetConverter
//
// `GCharsetConverter` is an implementation of [iface@Gio.Converter] based on
// [struct@GLib.IConv].
type CharsetConverter interface {
	gobject.Object
	upcastToGCharsetConverter() *CharsetConverterInstance

	// GetNumFallbacks wraps g_charset_converter_get_num_fallbacks
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the number of fallbacks that @converter has applied so far.
	GetNumFallbacks() uint
	// GetUseFallback wraps g_charset_converter_get_use_fallback
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the #GCharsetConverter:use-fallback property.
	GetUseFallback() bool
	// SetUseFallback wraps g_charset_converter_set_use_fallback
	// 
	// The function takes the following parameters:
	// 
	// 	- useFallback bool: %TRUE to use fallbacks 
	//
	// Sets the #GCharsetConverter:use-fallback property.
	SetUseFallback(bool)

	// chain up virtual methods:
}

func unsafeWrapCharsetConverter(base *gobject.ObjectInstance) *CharsetConverterInstance {
	return &CharsetConverterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCharsetConverter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCharsetConverter(inst)
		},
	)
}

func marshalCharsetConverterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCharsetConverterFromGlibNone is used to convert raw GCharsetConverter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibNone(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibNone(c).(CharsetConverter)
}

// UnsafeCharsetConverterFromGlibFull is used to convert raw GCharsetConverter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibFull(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibFull(c).(CharsetConverter)
}

// UnsafeCharsetConverterFromGlibBorrow is used to convert raw GCharsetConverter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCharsetConverterFromGlibBorrow(c unsafe.Pointer) CharsetConverter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(CharsetConverter)
}

func (c *CharsetConverterInstance) upcastToGCharsetConverter() *CharsetConverterInstance {
	return c
}

// UnsafeCharsetConverterToGlibNone is used to convert the instance to it's C value GCharsetConverter. This is used by the bindings internally.
func UnsafeCharsetConverterToGlibNone(c CharsetConverter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCharsetConverterToGlibFull is used to convert the instance to it's C value GCharsetConverter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCharsetConverterToGlibFull(c CharsetConverter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCharsetConverter wraps g_charset_converter_new
// 
// The function takes the following parameters:
// 
// 	- toCharset string: destination charset 
// 	- fromCharset string: source charset 
// 
// The function returns the following values:
// 
// 	- goret CharsetConverter 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GCharsetConverter.
func NewCharsetConverter(toCharset string, fromCharset string) (CharsetConverter, error) {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var cret  *C.GCharsetConverter // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(toCharset)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(fromCharset)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_charset_converter_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(toCharset)
	runtime.KeepAlive(fromCharset)

	var goret  CharsetConverter
	var _goerr error

	goret = UnsafeCharsetConverterFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetNumFallbacks wraps g_charset_converter_get_num_fallbacks
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the number of fallbacks that @converter has applied so far.
func (converter *CharsetConverterInstance) GetNumFallbacks() uint {
	var carg0 *C.GCharsetConverter // in, none, converted
	var cret  C.guint              // return, none, casted

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))

	cret = C.g_charset_converter_get_num_fallbacks(carg0)
	runtime.KeepAlive(converter)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUseFallback wraps g_charset_converter_get_use_fallback
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the #GCharsetConverter:use-fallback property.
func (converter *CharsetConverterInstance) GetUseFallback() bool {
	var carg0 *C.GCharsetConverter // in, none, converted
	var cret  C.gboolean           // return

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))

	cret = C.g_charset_converter_get_use_fallback(carg0)
	runtime.KeepAlive(converter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUseFallback wraps g_charset_converter_set_use_fallback
// 
// The function takes the following parameters:
// 
// 	- useFallback bool: %TRUE to use fallbacks 
//
// Sets the #GCharsetConverter:use-fallback property.
func (converter *CharsetConverterInstance) SetUseFallback(useFallback bool) {
	var carg0 *C.GCharsetConverter // in, none, converted
	var carg1 C.gboolean           // in

	carg0 = (*C.GCharsetConverter)(UnsafeCharsetConverterToGlibNone(converter))
	if useFallback {
		carg1 = C.TRUE
	}

	C.g_charset_converter_set_use_fallback(carg0, carg1)
	runtime.KeepAlive(converter)
	runtime.KeepAlive(useFallback)
}

// CharsetConverterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type CharsetConverterOverrides[Instance CharsetConverter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyCharsetConverterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyCharsetConverterOverrides[Instance CharsetConverter](gclass unsafe.Pointer, overrides CharsetConverterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterCharsetConverterSubClass is used to register a go subclass of GCharsetConverter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterCharsetConverterSubClass[InstanceT CharsetConverter](
		name string,
		classInit func(class *CharsetConverterClass),
		constructor func() InstanceT,
		overrides CharsetConverterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeCharsetConverter,
		UnsafeCharsetConverterClassFromGlibBorrow,
		UnsafeApplyCharsetConverterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCharsetConverter(obj)
		},
		interfaceInits...,
	)
}

// CredentialsInstance is the instance type used by all types extending GCredentials. It is used internally by the bindings. Users should use the interface [Credentials] instead.
type CredentialsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Credentials = (*CredentialsInstance)(nil)

// Credentials wraps GCredentials
//
// The `GCredentials` type is a reference-counted wrapper for native
// credentials.
// 
// The information in `GCredentials` is typically used for identifying,
// authenticating and authorizing other processes.
// 
// Some operating systems supports looking up the credentials of the remote
// peer of a communication endpoint - see e.g. [method@Gio.Socket.get_credentials].
// 
// Some operating systems supports securely sending and receiving
// credentials over a Unix Domain Socket, see [class@Gio.UnixCredentialsMessage],
// [method@Gio.UnixConnection.send_credentials] and
// [method@Gio.UnixConnection.receive_credentials] for details.
// 
// On Linux, the native credential type is a `struct ucred` - see the
// [`unix(7)` man page](man:unix(7)) for details. This corresponds to
// `G_CREDENTIALS_TYPE_LINUX_UCRED`.
// 
// On Apple operating systems (including iOS, tvOS, and macOS), the native credential
// type is a `struct xucred`. This corresponds to `G_CREDENTIALS_TYPE_APPLE_XUCRED`.
// 
// On FreeBSD, Debian GNU/kFreeBSD, and GNU/Hurd, the native credential type is a
// `struct cmsgcred`. This corresponds to `G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED`.
// 
// On NetBSD, the native credential type is a `struct unpcbid`.
// This corresponds to `G_CREDENTIALS_TYPE_NETBSD_UNPCBID`.
// 
// On OpenBSD, the native credential type is a `struct sockpeercred`.
// This corresponds to `G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED`.
// 
// On Solaris (including OpenSolaris and its derivatives), the native credential type
// is a `ucred_t`. This corresponds to `G_CREDENTIALS_TYPE_SOLARIS_UCRED`.
// 
// Since GLib 2.72, on Windows, the native credentials may contain the PID of a
// process. This corresponds to `G_CREDENTIALS_TYPE_WIN32_PID`.
type Credentials interface {
	gobject.Object
	upcastToGCredentials() *CredentialsInstance

	// IsSameUser wraps g_credentials_is_same_user
	// 
	// The function takes the following parameters:
	// 
	// 	- otherCredentials Credentials: A #GCredentials. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Checks if @credentials and @other_credentials is the same user.
	// 
	// This operation can fail if #GCredentials is not supported on the
	// the OS.
	IsSameUser(Credentials) (bool, error)
	// String wraps g_credentials_to_string
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Creates a human-readable textual representation of @credentials
	// that can be used in logging and debug messages. The format of the
	// returned string may change in future GLib release.
	String() string
}

func unsafeWrapCredentials(base *gobject.ObjectInstance) *CredentialsInstance {
	return &CredentialsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeCredentials,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapCredentials(inst)
		},
	)
}

func marshalCredentialsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeCredentialsFromGlibNone is used to convert raw GCredentials pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeCredentialsFromGlibNone(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibNone(c).(Credentials)
}

// UnsafeCredentialsFromGlibFull is used to convert raw GCredentials pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeCredentialsFromGlibFull(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibFull(c).(Credentials)
}

// UnsafeCredentialsFromGlibBorrow is used to convert raw GCredentials pointers to go without touching any references. This is used by the bindings internally.
func UnsafeCredentialsFromGlibBorrow(c unsafe.Pointer) Credentials {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Credentials)
}

func (c *CredentialsInstance) upcastToGCredentials() *CredentialsInstance {
	return c
}

// UnsafeCredentialsToGlibNone is used to convert the instance to it's C value GCredentials. This is used by the bindings internally.
func UnsafeCredentialsToGlibNone(c Credentials) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeCredentialsToGlibFull is used to convert the instance to it's C value GCredentials, while removeing the finalizer. This is used by the bindings internally.
func UnsafeCredentialsToGlibFull(c Credentials) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewCredentials wraps g_credentials_new
// 
// The function returns the following values:
// 
// 	- goret Credentials 
//
// Creates a new #GCredentials object with credentials matching the
// the current process.
func NewCredentials() Credentials {
	var cret *C.GCredentials // return, full, converted

	cret = C.g_credentials_new()

	var goret Credentials

	goret = UnsafeCredentialsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IsSameUser wraps g_credentials_is_same_user
// 
// The function takes the following parameters:
// 
// 	- otherCredentials Credentials: A #GCredentials. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Checks if @credentials and @other_credentials is the same user.
// 
// This operation can fail if #GCredentials is not supported on the
// the OS.
func (credentials *CredentialsInstance) IsSameUser(otherCredentials Credentials) (bool, error) {
	var carg0 *C.GCredentials // in, none, converted
	var carg1 *C.GCredentials // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(credentials))
	carg1 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(otherCredentials))

	cret = C.g_credentials_is_same_user(carg0, carg1, &_cerr)
	runtime.KeepAlive(credentials)
	runtime.KeepAlive(otherCredentials)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// String wraps g_credentials_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a human-readable textual representation of @credentials
// that can be used in logging and debug messages. The format of the
// returned string may change in future GLib release.
func (credentials *CredentialsInstance) String() string {
	var carg0 *C.GCredentials // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GCredentials)(UnsafeCredentialsToGlibNone(credentials))

	cret = C.g_credentials_to_string(carg0)
	runtime.KeepAlive(credentials)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// EmblemInstance is the instance type used by all types extending GEmblem. It is used internally by the bindings. Users should use the interface [Emblem] instead.
type EmblemInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Emblem = (*EmblemInstance)(nil)

// Emblem wraps GEmblem
//
// `GEmblem` is an implementation of [iface@Gio.Icon] that supports
// having an emblem, which is an icon with additional properties.
// It can than be added to a [class@Gio.EmblemedIcon].
// 
// Currently, only metainformation about the emblem's origin is
// supported. More may be added in the future.
type Emblem interface {
	gobject.Object
	upcastToGEmblem() *EmblemInstance

	// GetIcon wraps g_emblem_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gives back the icon from @emblem.
	GetIcon() Icon
	// GetOrigin wraps g_emblem_get_origin
	// 
	// The function returns the following values:
	// 
	// 	- goret EmblemOrigin 
	//
	// Gets the origin of the emblem.
	GetOrigin() EmblemOrigin
}

func unsafeWrapEmblem(base *gobject.ObjectInstance) *EmblemInstance {
	return &EmblemInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeEmblem,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblem(inst)
		},
	)
}

func marshalEmblemInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeEmblemFromGlibNone is used to convert raw GEmblem pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemFromGlibNone(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibNone(c).(Emblem)
}

// UnsafeEmblemFromGlibFull is used to convert raw GEmblem pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemFromGlibFull(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibFull(c).(Emblem)
}

// UnsafeEmblemFromGlibBorrow is used to convert raw GEmblem pointers to go without touching any references. This is used by the bindings internally.
func UnsafeEmblemFromGlibBorrow(c unsafe.Pointer) Emblem {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Emblem)
}

func (e *EmblemInstance) upcastToGEmblem() *EmblemInstance {
	return e
}

// UnsafeEmblemToGlibNone is used to convert the instance to it's C value GEmblem. This is used by the bindings internally.
func UnsafeEmblemToGlibNone(c Emblem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeEmblemToGlibFull is used to convert the instance to it's C value GEmblem, while removeing the finalizer. This is used by the bindings internally.
func UnsafeEmblemToGlibFull(c Emblem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewEmblem wraps g_emblem_new
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a GIcon containing the icon. 
// 
// The function returns the following values:
// 
// 	- goret Emblem 
//
// Creates a new emblem for @icon.
func NewEmblem(icon Icon) Emblem {
	var carg1 *C.GIcon   // in, none, converted
	var cret  *C.GEmblem // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	cret = C.g_emblem_new(carg1)
	runtime.KeepAlive(icon)

	var goret Emblem

	goret = UnsafeEmblemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewEmblemWithOrigin wraps g_emblem_new_with_origin
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a GIcon containing the icon. 
// 	- origin EmblemOrigin: a GEmblemOrigin enum defining the emblem's origin 
// 
// The function returns the following values:
// 
// 	- goret Emblem 
//
// Creates a new emblem for @icon.
func NewEmblemWithOrigin(icon Icon, origin EmblemOrigin) Emblem {
	var carg1 *C.GIcon        // in, none, converted
	var carg2 C.GEmblemOrigin // in, none, casted
	var cret  *C.GEmblem      // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))
	carg2 = C.GEmblemOrigin(origin)

	cret = C.g_emblem_new_with_origin(carg1, carg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(origin)

	var goret Emblem

	goret = UnsafeEmblemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetIcon wraps g_emblem_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gives back the icon from @emblem.
func (emblem *EmblemInstance) GetIcon() Icon {
	var carg0 *C.GEmblem // in, none, converted
	var cret  *C.GIcon   // return, none, converted

	carg0 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	cret = C.g_emblem_get_icon(carg0)
	runtime.KeepAlive(emblem)

	var goret Icon

	goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetOrigin wraps g_emblem_get_origin
// 
// The function returns the following values:
// 
// 	- goret EmblemOrigin 
//
// Gets the origin of the emblem.
func (emblem *EmblemInstance) GetOrigin() EmblemOrigin {
	var carg0 *C.GEmblem      // in, none, converted
	var cret  C.GEmblemOrigin // return, none, casted

	carg0 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	cret = C.g_emblem_get_origin(carg0)
	runtime.KeepAlive(emblem)

	var goret EmblemOrigin

	goret = EmblemOrigin(cret)

	return goret
}

// EmblemedIconInstance is the instance type used by all types extending GEmblemedIcon. It is used internally by the bindings. Users should use the interface [EmblemedIcon] instead.
type EmblemedIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ EmblemedIcon = (*EmblemedIconInstance)(nil)

// EmblemedIcon wraps GEmblemedIcon
//
// `GEmblemedIcon` is an implementation of [iface@Gio.Icon] that supports
// adding an emblem to an icon. Adding multiple emblems to an
// icon is ensured via [method@Gio.EmblemedIcon.add_emblem].
// 
// Note that `GEmblemedIcon` allows no control over the position
// of the emblems. See also [class@Gio.Emblem] for more information.
type EmblemedIcon interface {
	gobject.Object
	upcastToGEmblemedIcon() *EmblemedIconInstance

	// AddEmblem wraps g_emblemed_icon_add_emblem
	// 
	// The function takes the following parameters:
	// 
	// 	- emblem Emblem: a #GEmblem 
	//
	// Adds @emblem to the #GList of #GEmblems.
	AddEmblem(Emblem)
	// ClearEmblems wraps g_emblemed_icon_clear_emblems
	//
	// Removes all the emblems from @icon.
	ClearEmblems()
	// GetEmblems wraps g_emblemed_icon_get_emblems
	// 
	// The function returns the following values:
	// 
	// 	- goret []Emblem 
	//
	// Gets the list of emblems for the @icon.
	GetEmblems() []Emblem
	// GetIcon wraps g_emblemed_icon_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon 
	//
	// Gets the main icon for @emblemed.
	GetIcon() Icon

	// chain up virtual methods:
}

func unsafeWrapEmblemedIcon(base *gobject.ObjectInstance) *EmblemedIconInstance {
	return &EmblemedIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeEmblemedIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblemedIcon(inst)
		},
	)
}

func marshalEmblemedIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeEmblemedIconFromGlibNone is used to convert raw GEmblemedIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibNone(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(EmblemedIcon)
}

// UnsafeEmblemedIconFromGlibFull is used to convert raw GEmblemedIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibFull(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(EmblemedIcon)
}

// UnsafeEmblemedIconFromGlibBorrow is used to convert raw GEmblemedIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeEmblemedIconFromGlibBorrow(c unsafe.Pointer) EmblemedIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(EmblemedIcon)
}

func (e *EmblemedIconInstance) upcastToGEmblemedIcon() *EmblemedIconInstance {
	return e
}

// UnsafeEmblemedIconToGlibNone is used to convert the instance to it's C value GEmblemedIcon. This is used by the bindings internally.
func UnsafeEmblemedIconToGlibNone(c EmblemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeEmblemedIconToGlibFull is used to convert the instance to it's C value GEmblemedIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeEmblemedIconToGlibFull(c EmblemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewEmblemedIcon wraps g_emblemed_icon_new
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a #GIcon 
// 	- emblem Emblem (nullable): a #GEmblem, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret EmblemedIcon 
//
// Creates a new emblemed icon for @icon with the emblem @emblem.
func NewEmblemedIcon(icon Icon, emblem Emblem) EmblemedIcon {
	var carg1 *C.GIcon   // in, none, converted
	var carg2 *C.GEmblem // in, none, converted, nullable
	var cret  *C.GIcon   // return, full, converted

	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))
	if emblem != nil {
		carg2 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))
	}

	cret = C.g_emblemed_icon_new(carg1, carg2)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(emblem)

	var goret EmblemedIcon

	goret = UnsafeEmblemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddEmblem wraps g_emblemed_icon_add_emblem
// 
// The function takes the following parameters:
// 
// 	- emblem Emblem: a #GEmblem 
//
// Adds @emblem to the #GList of #GEmblems.
func (emblemed *EmblemedIconInstance) AddEmblem(emblem Emblem) {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var carg1 *C.GEmblem       // in, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))
	carg1 = (*C.GEmblem)(UnsafeEmblemToGlibNone(emblem))

	C.g_emblemed_icon_add_emblem(carg0, carg1)
	runtime.KeepAlive(emblemed)
	runtime.KeepAlive(emblem)
}

// ClearEmblems wraps g_emblemed_icon_clear_emblems
//
// Removes all the emblems from @icon.
func (emblemed *EmblemedIconInstance) ClearEmblems() {
	var carg0 *C.GEmblemedIcon // in, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	C.g_emblemed_icon_clear_emblems(carg0)
	runtime.KeepAlive(emblemed)
}

// GetEmblems wraps g_emblemed_icon_get_emblems
// 
// The function returns the following values:
// 
// 	- goret []Emblem 
//
// Gets the list of emblems for the @icon.
func (emblemed *EmblemedIconInstance) GetEmblems() []Emblem {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var cret  *C.GList         // container, transfer: none

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	cret = C.g_emblemed_icon_get_emblems(carg0)
	runtime.KeepAlive(emblemed)

	var goret []Emblem

	goret = glib.UnsafeListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Emblem {
			var dst Emblem // converted
			dst = UnsafeEmblemFromGlibNone(v)
			return dst
		},
	)

	return goret
}

// GetIcon wraps g_emblemed_icon_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon 
//
// Gets the main icon for @emblemed.
func (emblemed *EmblemedIconInstance) GetIcon() Icon {
	var carg0 *C.GEmblemedIcon // in, none, converted
	var cret  *C.GIcon         // return, none, converted

	carg0 = (*C.GEmblemedIcon)(UnsafeEmblemedIconToGlibNone(emblemed))

	cret = C.g_emblemed_icon_get_icon(carg0)
	runtime.KeepAlive(emblemed)

	var goret Icon

	goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// EmblemedIconOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type EmblemedIconOverrides[Instance EmblemedIcon] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyEmblemedIconOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyEmblemedIconOverrides[Instance EmblemedIcon](gclass unsafe.Pointer, overrides EmblemedIconOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterEmblemedIconSubClass is used to register a go subclass of GEmblemedIcon. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterEmblemedIconSubClass[InstanceT EmblemedIcon](
		name string,
		classInit func(class *EmblemedIconClass),
		constructor func() InstanceT,
		overrides EmblemedIconOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeEmblemedIcon,
		UnsafeEmblemedIconClassFromGlibBorrow,
		UnsafeApplyEmblemedIconOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapEmblemedIcon(obj)
		},
		interfaceInits...,
	)
}

// FileEnumeratorInstance is the instance type used by all types extending GFileEnumerator. It is used internally by the bindings. Users should use the interface [FileEnumerator] instead.
type FileEnumeratorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileEnumerator = (*FileEnumeratorInstance)(nil)

// FileEnumerator wraps GFileEnumerator
//
// `GFileEnumerator` allows you to operate on a set of [iface@Gio.File] objects,
// returning a [class@Gio.FileInfo] structure for each file enumerated (e.g.
// [method@Gio.File.enumerate_children] will return a `GFileEnumerator` for each
// of the children within a directory).
// 
// To get the next file's information from a `GFileEnumerator`, use
// [method@Gio.FileEnumerator.next_file] or its asynchronous version,
// [method@Gio.FileEnumerator.next_files_async]. Note that the asynchronous
// version will return a list of [class@Gio.FileInfo] objects, whereas the
// synchronous will only return the next file in the enumerator.
// 
// The ordering of returned files is unspecified for non-Unix
// platforms; for more information, see [method@GLib.Dir.read_name].  On Unix,
// when operating on local files, returned files will be sorted by
// inode number.  Effectively you can assume that the ordering of
// returned files will be stable between successive calls (and
// applications) assuming the directory is unchanged.
// 
// If your application needs a specific ordering, such as by name or
// modification time, you will have to implement that in your
// application code.
// 
// To close a `GFileEnumerator`, use [method@Gio.FileEnumerator.close], or
// its asynchronous version, [method@Gio.FileEnumerator.close_async]. Once
// a `GFileEnumerator` is closed, no further actions may be performed
// on it, and it should be freed with [method@GObject.Object.unref].
type FileEnumerator interface {
	gobject.Object
	upcastToGFileEnumerator() *FileEnumeratorInstance

	// Close wraps g_file_enumerator_close
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Releases all resources used by this enumerator, making the
	// enumerator return %G_IO_ERROR_CLOSED on all calls.
	// 
	// This will be automatically called when the last reference
	// is dropped, but you might want to call this function to make
	// sure resources are released as early as possible.
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_file_enumerator_close_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously closes the file enumerator.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
	// g_file_enumerator_close_finish().
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_file_enumerator_close_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
	// 
	// If the file enumerator was already closed when g_file_enumerator_close_async()
	// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
	// return %FALSE. If the file enumerator had pending operation when the close
	// operation was started, then this function will report %G_IO_ERROR_PENDING, and
	// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
	// cancelled by triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
	// returned.
	CloseFinish(AsyncResult) (bool, error)
	// GetChild wraps g_file_enumerator_get_child
	// 
	// The function takes the following parameters:
	// 
	// 	- info FileInfo: a #GFileInfo gotten from g_file_enumerator_next_file()
	//   or the async equivalents. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Return a new #GFile which refers to the file named by @info in the source
	// directory of @enumerator.  This function is primarily intended to be used
	// inside loops with g_file_enumerator_next_file().
	// 
	// To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
	// attributes list used when creating the #GFileEnumerator.
	// 
	// This is a convenience method that's equivalent to:
	// |[&lt;!-- language="C" --&gt;
	//   gchar *name = g_file_info_get_name (info);
	//   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
	//                                    name);
	// ]|
	GetChild(FileInfo) File
	// GetContainer wraps g_file_enumerator_get_container
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Get the #GFile container which is being enumerated.
	GetContainer() File
	// HasPending wraps g_file_enumerator_has_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the file enumerator has pending operations.
	HasPending() bool
	// IsClosed wraps g_file_enumerator_is_closed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the file enumerator has been closed.
	IsClosed() bool
	// Iterate wraps g_file_enumerator_iterate
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable 
	// 
	// The function returns the following values:
	// 
	// 	- outInfo FileInfo: Output location for the next #GFileInfo, or %NULL 
	// 	- outChild File: Output location for the next #GFile, or %NULL 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// This is a version of g_file_enumerator_next_file() that's easier to
	// use correctly from C programs.  With g_file_enumerator_next_file(),
	// the gboolean return value signifies "end of iteration or error", which
	// requires allocation of a temporary #GError.
	// 
	// In contrast, with this function, a %FALSE return from
	// g_file_enumerator_iterate() *always* means
	// "error".  End of iteration is signaled by @out_info or @out_child being %NULL.
	// 
	// Another crucial difference is that the references for @out_info and
	// @out_child are owned by @direnum (they are cached as hidden
	// properties).  You must not unref them in your own code.  This makes
	// memory management significantly easier for C code in combination
	// with loops.
	// 
	// Finally, this function optionally allows retrieving a #GFile as
	// well.
	// 
	// You must specify at least one of @out_info or @out_child.
	// 
	// The code pattern for correctly using g_file_enumerator_iterate() from C
	// is:
	// 
	// |[
	// direnum = g_file_enumerate_children (file, ...);
	// while (TRUE)
	//   {
	//     GFileInfo *info;
	//     if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
	//       goto out;
	//     if (!info)
	//       break;
	//     ... do stuff with "info"; do not unref it! ...
	//   }
	// 
	// out:
	//   g_object_unref (direnum); // Note: frees the last @info
	// ]|
	Iterate(Cancellable) (FileInfo, File, bool, error)
	// NextFile wraps g_file_enumerator_next_file
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Returns information for the next file in the enumerated object.
	// Will block until the information is available. The #GFileInfo
	// returned from this function will contain attributes that match the
	// attribute string that was passed when the #GFileEnumerator was created.
	// 
	// See the documentation of #GFileEnumerator for information about the
	// order of returned files.
	// 
	// On error, returns %NULL and sets @error to the error. If the
	// enumerator is at the end, %NULL will be returned and @error will
	// be unset.
	NextFile(Cancellable) (FileInfo, error)
	// NextFilesAsync wraps g_file_enumerator_next_files_async
	// 
	// The function takes the following parameters:
	// 
	// 	- numFiles int32: the number of file info objects to request 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Request information for a number of files from the enumerator asynchronously.
	// When all I/O for the operation is finished the @callback will be called with
	// the requested information.
	// 
	// See the documentation of #GFileEnumerator for information about the
	// order of returned files.
	// 
	// Once the end of the enumerator is reached, or if an error occurs, the
	// @callback will be called with an empty list. In this case, the previous call
	// to g_file_enumerator_next_files_async() will typically have returned fewer
	// than @num_files items.
	// 
	// If a request is cancelled the callback will be called with
	// %G_IO_ERROR_CANCELLED.
	// 
	// This leads to the following pseudo-code usage:
	// |[
	// g_autoptr(GFile) dir = get_directory ();
	// g_autoptr(GFileEnumerator) enumerator = NULL;
	// g_autolist(GFileInfo) files = NULL;
	// g_autoptr(GError) local_error = NULL;
	// 
	// enumerator = yield g_file_enumerate_children_async (dir,
	//                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
	//                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
	//                                                     G_FILE_QUERY_INFO_NONE,
	//                                                     G_PRIORITY_DEFAULT,
	//                                                     cancellable,
	//                                                     &#x2026;,
	//                                                     &amp;local_error);
	// if (enumerator == NULL)
	//   g_error ("Error enumerating: %s", local_error-&gt;message);
	// 
	// // Loop until no files are returned, either because the end of the enumerator
	// // has been reached, or an error was returned.
	// do
	//   {
	//     files = yield g_file_enumerator_next_files_async (enumerator,
	//                                                       5,  // number of files to request
	//                                                       G_PRIORITY_DEFAULT,
	//                                                       cancellable,
	//                                                       &#x2026;,
	//                                                       &amp;local_error);
	// 
	//     // Process the returned files, but don&#x2019;t assume that exactly 5 were returned.
	//     for (GList *l = files; l != NULL; l = l-&gt;next)
	//       {
	//         GFileInfo *info = l-&gt;data;
	//         handle_file_info (info);
	//       }
	//   }
	// while (files != NULL);
	// 
	// if (local_error != NULL &amp;&amp;
	//     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
	//   g_error ("Error while enumerating: %s", local_error-&gt;message);
	// ]|
	// 
	// During an async request no other sync and async calls are allowed, and will
	// result in %G_IO_ERROR_PENDING errors.
	// 
	// Any outstanding I/O request with higher priority (lower numerical value) will
	// be executed before an outstanding request with lower priority. Default
	// priority is %G_PRIORITY_DEFAULT.
	NextFilesAsync(int32, int32, Cancellable, AsyncReadyCallback)
	// NextFilesFinish wraps g_file_enumerator_next_files_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
	NextFilesFinish(AsyncResult) ([]FileInfo, error)
	// SetPending wraps g_file_enumerator_set_pending
	// 
	// The function takes the following parameters:
	// 
	// 	- pending bool: a boolean value. 
	//
	// Sets the file enumerator as having pending operations.
	SetPending(bool)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GFileEnumerator.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
	// 
	// If the file enumerator was already closed when g_file_enumerator_close_async()
	// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
	// return %FALSE. If the file enumerator had pending operation when the close
	// operation was started, then this function will report %G_IO_ERROR_PENDING, and
	// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
	// cancelled by triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
	// returned.
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GFileEnumerator.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentNextFile calls the default implementations of the `GFileEnumerator.next_file` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Returns information for the next file in the enumerated object.
	// Will block until the information is available. The #GFileInfo
	// returned from this function will contain attributes that match the
	// attribute string that was passed when the #GFileEnumerator was created.
	// 
	// See the documentation of #GFileEnumerator for information about the
	// order of returned files.
	// 
	// On error, returns %NULL and sets @error to the error. If the
	// enumerator is at the end, %NULL will be returned and @error will
	// be unset.
	ParentNextFile(cancellable Cancellable) (FileInfo, error)
	// ParentNextFilesFinish calls the default implementations of the `GFileEnumerator.next_files_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
	ParentNextFilesFinish(result AsyncResult) ([]FileInfo, error)
}

func unsafeWrapFileEnumerator(base *gobject.ObjectInstance) *FileEnumeratorInstance {
	return &FileEnumeratorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileEnumerator(inst)
		},
	)
}

func marshalFileEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileEnumeratorFromGlibNone is used to convert raw GFileEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibNone(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(FileEnumerator)
}

// UnsafeFileEnumeratorFromGlibFull is used to convert raw GFileEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibFull(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(FileEnumerator)
}

// UnsafeFileEnumeratorFromGlibBorrow is used to convert raw GFileEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileEnumeratorFromGlibBorrow(c unsafe.Pointer) FileEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileEnumerator)
}

func (f *FileEnumeratorInstance) upcastToGFileEnumerator() *FileEnumeratorInstance {
	return f
}

// UnsafeFileEnumeratorToGlibNone is used to convert the instance to it's C value GFileEnumerator. This is used by the bindings internally.
func UnsafeFileEnumeratorToGlibNone(c FileEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileEnumeratorToGlibFull is used to convert the instance to it's C value GFileEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileEnumeratorToGlibFull(c FileEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Close wraps g_file_enumerator_close
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Releases all resources used by this enumerator, making the
// enumerator return %G_IO_ERROR_CLOSED on all calls.
// 
// This will be automatically called when the last reference
// is dropped, but you might want to call this function to make
// sure resources are released as early as possible.
func (enumerator *FileEnumeratorInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_file_enumerator_close_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously closes the file enumerator.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
// g_file_enumerator_close_finish().
func (enumerator *FileEnumeratorInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileEnumerator    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerator_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_file_enumerator_close_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
// 
// If the file enumerator was already closed when g_file_enumerator_close_async()
// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
// return %FALSE. If the file enumerator had pending operation when the close
// operation was started, then this function will report %G_IO_ERROR_PENDING, and
// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
// cancelled by triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
// returned.
func (enumerator *FileEnumeratorInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_enumerator_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetChild wraps g_file_enumerator_get_child
// 
// The function takes the following parameters:
// 
// 	- info FileInfo: a #GFileInfo gotten from g_file_enumerator_next_file()
//   or the async equivalents. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Return a new #GFile which refers to the file named by @info in the source
// directory of @enumerator.  This function is primarily intended to be used
// inside loops with g_file_enumerator_next_file().
// 
// To use this, %G_FILE_ATTRIBUTE_STANDARD_NAME must have been listed in the
// attributes list used when creating the #GFileEnumerator.
// 
// This is a convenience method that's equivalent to:
// |[&lt;!-- language="C" --&gt;
//   gchar *name = g_file_info_get_name (info);
//   GFile *child = g_file_get_child (g_file_enumerator_get_container (enumr),
//                                    name);
// ]|
func (enumerator *FileEnumeratorInstance) GetChild(info FileInfo) File {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GFileInfo       // in, none, converted
	var cret  *C.GFile           // return, full, converted

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_enumerator_get_child(carg0, carg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(info)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContainer wraps g_file_enumerator_get_container
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Get the #GFile container which is being enumerated.
func (enumerator *FileEnumeratorInstance) GetContainer() File {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  *C.GFile           // return, none, converted

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_get_container(carg0)
	runtime.KeepAlive(enumerator)

	var goret File

	goret = UnsafeFileFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// HasPending wraps g_file_enumerator_has_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the file enumerator has pending operations.
func (enumerator *FileEnumeratorInstance) HasPending() bool {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_has_pending(carg0)
	runtime.KeepAlive(enumerator)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_file_enumerator_is_closed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the file enumerator has been closed.
func (enumerator *FileEnumeratorInstance) IsClosed() bool {
	var carg0 *C.GFileEnumerator // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))

	cret = C.g_file_enumerator_is_closed(carg0)
	runtime.KeepAlive(enumerator)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Iterate wraps g_file_enumerator_iterate
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable 
// 
// The function returns the following values:
// 
// 	- outInfo FileInfo: Output location for the next #GFileInfo, or %NULL 
// 	- outChild File: Output location for the next #GFile, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// This is a version of g_file_enumerator_next_file() that's easier to
// use correctly from C programs.  With g_file_enumerator_next_file(),
// the gboolean return value signifies "end of iteration or error", which
// requires allocation of a temporary #GError.
// 
// In contrast, with this function, a %FALSE return from
// g_file_enumerator_iterate() *always* means
// "error".  End of iteration is signaled by @out_info or @out_child being %NULL.
// 
// Another crucial difference is that the references for @out_info and
// @out_child are owned by @direnum (they are cached as hidden
// properties).  You must not unref them in your own code.  This makes
// memory management significantly easier for C code in combination
// with loops.
// 
// Finally, this function optionally allows retrieving a #GFile as
// well.
// 
// You must specify at least one of @out_info or @out_child.
// 
// The code pattern for correctly using g_file_enumerator_iterate() from C
// is:
// 
// |[
// direnum = g_file_enumerate_children (file, ...);
// while (TRUE)
//   {
//     GFileInfo *info;
//     if (!g_file_enumerator_iterate (direnum, &amp;info, NULL, cancellable, error))
//       goto out;
//     if (!info)
//       break;
//     ... do stuff with "info"; do not unref it! ...
//   }
// 
// out:
//   g_object_unref (direnum); // Note: frees the last @info
// ]|
func (direnum *FileEnumeratorInstance) Iterate(cancellable Cancellable) (FileInfo, File, bool, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg3 *C.GCancellable    // in, none, converted, nullable
	var carg1 *C.GFileInfo       // out, none, converted
	var carg2 *C.GFile           // out, none, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(direnum))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_iterate(carg0, &carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(direnum)
	runtime.KeepAlive(cancellable)

	var outInfo  FileInfo
	var outChild File
	var goret    bool
	var _goerr   error

	outInfo = UnsafeFileInfoFromGlibNone(unsafe.Pointer(carg1))
	outChild = UnsafeFileFromGlibNone(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outInfo, outChild, goret, _goerr
}

// NextFile wraps g_file_enumerator_next_file
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo (nullable) 
// 	- _goerr error (nullable): an error 
//
// Returns information for the next file in the enumerated object.
// Will block until the information is available. The #GFileInfo
// returned from this function will contain attributes that match the
// attribute string that was passed when the #GFileEnumerator was created.
// 
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
// 
// On error, returns %NULL and sets @error to the error. If the
// enumerator is at the end, %NULL will be returned and @error will
// be unset.
func (enumerator *FileEnumeratorInstance) NextFile(cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GCancellable    // in, none, converted, nullable
	var cret  *C.GFileInfo       // return, full, converted, nullable
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_enumerator_next_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	if cret != nil {
		goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NextFilesAsync wraps g_file_enumerator_next_files_async
// 
// The function takes the following parameters:
// 
// 	- numFiles int32: the number of file info objects to request 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Request information for a number of files from the enumerator asynchronously.
// When all I/O for the operation is finished the @callback will be called with
// the requested information.
// 
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
// 
// Once the end of the enumerator is reached, or if an error occurs, the
// @callback will be called with an empty list. In this case, the previous call
// to g_file_enumerator_next_files_async() will typically have returned fewer
// than @num_files items.
// 
// If a request is cancelled the callback will be called with
// %G_IO_ERROR_CANCELLED.
// 
// This leads to the following pseudo-code usage:
// |[
// g_autoptr(GFile) dir = get_directory ();
// g_autoptr(GFileEnumerator) enumerator = NULL;
// g_autolist(GFileInfo) files = NULL;
// g_autoptr(GError) local_error = NULL;
// 
// enumerator = yield g_file_enumerate_children_async (dir,
//                                                     G_FILE_ATTRIBUTE_STANDARD_NAME ","
//                                                     G_FILE_ATTRIBUTE_STANDARD_TYPE,
//                                                     G_FILE_QUERY_INFO_NONE,
//                                                     G_PRIORITY_DEFAULT,
//                                                     cancellable,
//                                                     &#x2026;,
//                                                     &amp;local_error);
// if (enumerator == NULL)
//   g_error ("Error enumerating: %s", local_error-&gt;message);
// 
// // Loop until no files are returned, either because the end of the enumerator
// // has been reached, or an error was returned.
// do
//   {
//     files = yield g_file_enumerator_next_files_async (enumerator,
//                                                       5,  // number of files to request
//                                                       G_PRIORITY_DEFAULT,
//                                                       cancellable,
//                                                       &#x2026;,
//                                                       &amp;local_error);
// 
//     // Process the returned files, but don&#x2019;t assume that exactly 5 were returned.
//     for (GList *l = files; l != NULL; l = l-&gt;next)
//       {
//         GFileInfo *info = l-&gt;data;
//         handle_file_info (info);
//       }
//   }
// while (files != NULL);
// 
// if (local_error != NULL &amp;&amp;
//     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
//   g_error ("Error while enumerating: %s", local_error-&gt;message);
// ]|
// 
// During an async request no other sync and async calls are allowed, and will
// result in %G_IO_ERROR_PENDING errors.
// 
// Any outstanding I/O request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is %G_PRIORITY_DEFAULT.
func (enumerator *FileEnumeratorInstance) NextFilesAsync(numFiles int32, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileEnumerator    // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = C.int(numFiles)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_enumerator_next_files_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(numFiles)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NextFilesFinish wraps g_file_enumerator_next_files_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret []FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
func (enumerator *FileEnumeratorInstance) NextFilesFinish(result AsyncResult) ([]FileInfo, error) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GList           // container, transfer: full
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_enumerator_next_files_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  []FileInfo
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) FileInfo {
			var dst FileInfo // converted
			dst = UnsafeFileInfoFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetPending wraps g_file_enumerator_set_pending
// 
// The function takes the following parameters:
// 
// 	- pending bool: a boolean value. 
//
// Sets the file enumerator as having pending operations.
func (enumerator *FileEnumeratorInstance) SetPending(pending bool) {
	var carg0 *C.GFileEnumerator // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if pending {
		carg1 = C.TRUE
	}

	C.g_file_enumerator_set_pending(carg0, carg1)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(pending)
}

// FileEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileEnumeratorOverrides[Instance FileEnumerator] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
	// 
	// If the file enumerator was already closed when g_file_enumerator_close_async()
	// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
	// return %FALSE. If the file enumerator had pending operation when the close
	// operation was started, then this function will report %G_IO_ERROR_PENDING, and
	// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
	// cancelled by triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
	// returned.
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	CloseFn func(Instance, Cancellable) (bool, error)
	// // NextFile allows you to override the implementation of the virtual method next_file.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Returns information for the next file in the enumerated object.
	// Will block until the information is available. The #GFileInfo
	// returned from this function will contain attributes that match the
	// attribute string that was passed when the #GFileEnumerator was created.
	// 
	// See the documentation of #GFileEnumerator for information about the
	// order of returned files.
	// 
	// On error, returns %NULL and sets @error to the error. If the
	// enumerator is at the end, %NULL will be returned and @error will
	// be unset.
	NextFile func(Instance, Cancellable) (FileInfo, error)
	// // NextFilesFinish allows you to override the implementation of the virtual method next_files_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
	NextFilesFinish func(Instance, AsyncResult) ([]FileInfo, error)
}

// UnsafeApplyFileEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileEnumeratorOverrides[Instance FileEnumerator](gclass unsafe.Pointer, overrides FileEnumeratorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFileEnumeratorClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_FileEnumerator_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_close_finish",
			func(carg0 *C.GFileEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var enumerator Instance    // go GFileEnumerator subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(enumerator, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_FileEnumerator_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_close_fn",
			func(carg0 *C.GFileEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var enumerator  Instance    // go GFileEnumerator subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(enumerator, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFile != nil {
		pclass.next_file = (*[0]byte)(C._goglib_gio2_FileEnumerator_next_file)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_next_file",
			func(carg0 *C.GFileEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var enumerator  Instance    // go GFileEnumerator subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted, nullable
				var _goerr      error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.NextFile(enumerator, cancellable)

				if goret != nil {
					cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFilesFinish != nil {
		pclass.next_files_finish = (*[0]byte)(C._goglib_gio2_FileEnumerator_next_files_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileEnumerator_next_files_finish",
			func(carg0 *C.GFileEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var enumerator Instance    // go GFileEnumerator subclass
				var result     AsyncResult // in, none, converted
				var goret      []FileInfo  // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr     error       // out, full, converted

				enumerator = UnsafeFileEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.NextFilesFinish(enumerator, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []FileInfo (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GFileEnumerator.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes closing a file enumerator, started from g_file_enumerator_close_async().
// 
// If the file enumerator was already closed when g_file_enumerator_close_async()
// was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
// return %FALSE. If the file enumerator had pending operation when the close
// operation was started, then this function will report %G_IO_ERROR_PENDING, and
// return %FALSE.  If @cancellable was not %NULL, then the operation may have been
// cancelled by triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
// returned.
func (enumerator *FileEnumeratorInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileEnumerator_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GFileEnumerator.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (enumerator *FileEnumeratorInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileEnumerator_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFile calls the default implementations of the `GFileEnumerator.next_file` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo (nullable) 
// 	- _goerr error (nullable): an error 
//
// Returns information for the next file in the enumerated object.
// Will block until the information is available. The #GFileInfo
// returned from this function will contain attributes that match the
// attribute string that was passed when the #GFileEnumerator was created.
// 
// See the documentation of #GFileEnumerator for information about the
// order of returned files.
// 
// On error, returns %NULL and sets @error to the error. If the
// enumerator is at the end, %NULL will be returned and @error will
// be unset.
func (enumerator *FileEnumeratorInstance) ParentNextFile(cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GCancellable // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted, nullable
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileEnumerator_virtual_next_file(unsafe.Pointer(parentclass.next_file), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	if cret != nil {
		goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFilesFinish calls the default implementations of the `GFileEnumerator.next_files_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret []FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
func (enumerator *FileEnumeratorInstance) ParentNextFilesFinish(result AsyncResult) ([]FileInfo, error) {
	var carg0 *C.GFileEnumerator
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileEnumeratorClass)(classdata.PeekParentClass(UnsafeFileEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GFileEnumerator)(UnsafeFileEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileEnumerator_virtual_next_files_finish(unsafe.Pointer(parentclass.next_files_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  []FileInfo
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) FileInfo {
			var dst FileInfo // converted
			dst = UnsafeFileInfoFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileEnumeratorSubClass is used to register a go subclass of GFileEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileEnumeratorSubClass[InstanceT FileEnumerator](
		name string,
		classInit func(class *FileEnumeratorClass),
		constructor func() InstanceT,
		overrides FileEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileEnumerator,
		UnsafeFileEnumeratorClassFromGlibBorrow,
		UnsafeApplyFileEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileEnumerator(obj)
		},
		interfaceInits...,
	)
}

// FileIconInstance is the instance type used by all types extending GFileIcon. It is used internally by the bindings. Users should use the interface [FileIcon] instead.
type FileIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileIcon = (*FileIconInstance)(nil)

// FileIcon wraps GFileIcon
//
// `GFileIcon` specifies an icon by pointing to an image file
// to be used as icon.
// 
// It implements [iface@Gio.LoadableIcon].
type FileIcon interface {
	gobject.Object
	upcastToGFileIcon() *FileIconInstance

	// GetFile wraps g_file_icon_get_file
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets the #GFile associated with the given @icon.
	GetFile() File
}

func unsafeWrapFileIcon(base *gobject.ObjectInstance) *FileIconInstance {
	return &FileIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIcon(inst)
		},
	)
}

func marshalFileIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileIconFromGlibNone is used to convert raw GFileIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIconFromGlibNone(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(FileIcon)
}

// UnsafeFileIconFromGlibFull is used to convert raw GFileIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIconFromGlibFull(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(FileIcon)
}

// UnsafeFileIconFromGlibBorrow is used to convert raw GFileIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileIconFromGlibBorrow(c unsafe.Pointer) FileIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileIcon)
}

func (f *FileIconInstance) upcastToGFileIcon() *FileIconInstance {
	return f
}

// UnsafeFileIconToGlibNone is used to convert the instance to it's C value GFileIcon. This is used by the bindings internally.
func UnsafeFileIconToGlibNone(c FileIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileIconToGlibFull is used to convert the instance to it's C value GFileIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileIconToGlibFull(c FileIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFileIcon wraps g_file_icon_new
// 
// The function takes the following parameters:
// 
// 	- file File: a #GFile. 
// 
// The function returns the following values:
// 
// 	- goret FileIcon 
//
// Creates a new icon for a file.
func NewFileIcon(file File) FileIcon {
	var carg1 *C.GFile // in, none, converted
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file))

	cret = C.g_file_icon_new(carg1)
	runtime.KeepAlive(file)

	var goret FileIcon

	goret = UnsafeFileIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFile wraps g_file_icon_get_file
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets the #GFile associated with the given @icon.
func (icon *FileIconInstance) GetFile() File {
	var carg0 *C.GFileIcon // in, none, converted
	var cret  *C.GFile     // return, none, converted

	carg0 = (*C.GFileIcon)(UnsafeFileIconToGlibNone(icon))

	cret = C.g_file_icon_get_file(carg0)
	runtime.KeepAlive(icon)

	var goret File

	goret = UnsafeFileFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// FileInfoInstance is the instance type used by all types extending GFileInfo. It is used internally by the bindings. Users should use the interface [FileInfo] instead.
type FileInfoInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileInfo = (*FileInfoInstance)(nil)

// FileInfo wraps GFileInfo
//
// Stores information about a file system object referenced by a [iface@Gio.File].
// 
// Functionality for manipulating basic metadata for files. `GFileInfo`
// implements methods for getting information that all files should
// contain, and allows for manipulation of extended attributes.
// 
// See the [file attributes](file-attributes.html) document for more
// information on how GIO handles file attributes.
// 
// To obtain a `GFileInfo` for a [iface@Gio.File], use
// [method@Gio.File.query_info] (or its async variant). To obtain a `GFileInfo`
// for a file input or output stream, use [method@Gio.FileInputStream.query_info]
// or [method@Gio.FileOutputStream.query_info] (or their async variants).
// 
// To change the actual attributes of a file, you should then set the
// attribute in the `GFileInfo` and call [method@Gio.File.set_attributes_from_info]
// or [method@Gio.File.set_attributes_async] on a `GFile`.
// 
// However, not all attributes can be changed in the file. For instance,
// the actual size of a file cannot be changed via [method@Gio.FileInfo.set_size].
// You may call [method@Gio.File.query_settable_attributes] and
// [method@Gio.File.query_writable_namespaces] to discover the settable attributes
// of a particular file at runtime.
// 
// The direct accessors, such as [method@Gio.FileInfo.get_name], are slightly more
// optimized than the generic attribute accessors, such as
// [method@Gio.FileInfo.get_attribute_byte_string].This optimization will matter
// only if calling the API in a tight loop.
// 
// It is an error to call these accessors without specifying their required file
// attributes when creating the `GFileInfo`. Use
// [method@Gio.FileInfo.has_attribute] or [method@Gio.FileInfo.list_attributes]
// to check what attributes are specified for a `GFileInfo`.
// 
// [struct@Gio.FileAttributeMatcher] allows for searching through a `GFileInfo`
// for attributes.
type FileInfo interface {
	gobject.Object
	upcastToGFileInfo() *FileInfoInstance

	// ClearStatus wraps g_file_info_clear_status
	//
	// Clears the status information from @info.
	ClearStatus()
	// CopyInto wraps g_file_info_copy_into
	// 
	// The function takes the following parameters:
	// 
	// 	- destInfo FileInfo: destination to copy attributes to. 
	//
	// First clears all of the [GFileAttribute](file-attributes.html#file-attributes) of
	// @dest_info, and then copies all of the file attributes from @src_info to @dest_info.
	CopyInto(FileInfo)
	// Dup wraps g_file_info_dup
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	//
	// Duplicates a file info structure.
	Dup() FileInfo
	// GetAttributeAsString wraps g_file_info_get_attribute_as_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the value of an attribute, formatted as a human readable string.
	// 
	// This escapes things as needed to make the string valid UTF-8 and readable by
	// humans. It&#x2019;s not meant to be a machine readable or reversible escaping
	// format.
	// 
	// To format file name attributes of type
	// [enum@Gio.FileAttributeType.BYTE_STRING] for output as UTF-8, use
	// [func@GLib.filename_to_utf8] instead:
	// ```c
	// const char *trash_orig_path_byte_string;
	// g_autofree char *trash_orig_path_utf8 = NULL;
	// 
	// trash_orig_path_byte_string = g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH);
	// trash_orig_path_utf8 = g_filename_to_utf8 (trash_orig_path_byte_string, -1, NULL, NULL, NULL);
	// if (trash_orig_path_utf8 != NULL)
	//   g_message ("Some larger UTF-8 string with filename embedded as %s", trash_orig_path_utf8);
	// ```
	GetAttributeAsString(string) string
	// GetAttributeBoolean wraps g_file_info_get_attribute_boolean
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value of a boolean attribute. If the attribute does not
	// contain a boolean value, %FALSE will be returned.
	GetAttributeBoolean(string) bool
	// GetAttributeByteString wraps g_file_info_get_attribute_byte_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the value of a byte string attribute. If the attribute does
	// not contain a byte string, %NULL will be returned.
	GetAttributeByteString(string) string
	// GetAttributeFilePath wraps g_file_info_get_attribute_file_path
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the value of a byte string attribute as a file path.
	// 
	// If the attribute does not contain a byte string, `NULL` will be returned.
	// 
	// This function is meant to be used by language bindings that have specific
	// handling for Unix paths.
	GetAttributeFilePath(string) string
	// GetAttributeInt32 wraps g_file_info_get_attribute_int32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets a signed 32-bit integer contained within the attribute. If the
	// attribute does not contain a signed 32-bit integer, or is invalid,
	// 0 will be returned.
	GetAttributeInt32(string) int32
	// GetAttributeInt64 wraps g_file_info_get_attribute_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	//
	// Gets a signed 64-bit integer contained within the attribute. If the
	// attribute does not contain a signed 64-bit integer, or is invalid,
	// 0 will be returned.
	GetAttributeInt64(string) int64
	// GetAttributeObject wraps g_file_info_get_attribute_object
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret gobject.Object (nullable) 
	//
	// Gets the value of a #GObject attribute. If the attribute does
	// not contain a #GObject, %NULL will be returned.
	GetAttributeObject(string) gobject.Object
	// GetAttributeStatus wraps g_file_info_get_attribute_status
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileAttributeStatus 
	//
	// Gets the attribute status for an attribute key.
	GetAttributeStatus(string) FileAttributeStatus
	// GetAttributeString wraps g_file_info_get_attribute_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the value of a string attribute. If the attribute does
	// not contain a string, %NULL will be returned.
	GetAttributeString(string) string
	// GetAttributeStringv wraps g_file_info_get_attribute_stringv
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string (nullable) 
	//
	// Gets the value of a stringv attribute. If the attribute does
	// not contain a stringv, %NULL will be returned.
	GetAttributeStringv(string) []string
	// GetAttributeType wraps g_file_info_get_attribute_type
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileAttributeType 
	//
	// Gets the attribute type for an attribute key.
	GetAttributeType(string) FileAttributeType
	// GetAttributeUint32 wraps g_file_info_get_attribute_uint32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint32 
	//
	// Gets an unsigned 32-bit integer contained within the attribute. If the
	// attribute does not contain an unsigned 32-bit integer, or is invalid,
	// 0 will be returned.
	GetAttributeUint32(string) uint32
	// GetAttributeUint64 wraps g_file_info_get_attribute_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint64 
	//
	// Gets a unsigned 64-bit integer contained within the attribute. If the
	// attribute does not contain an unsigned 64-bit integer, or is invalid,
	// 0 will be returned.
	GetAttributeUint64(string) uint64
	// GetContentType wraps g_file_info_get_content_type
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the file's content type.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	GetContentType() string
	// GetDisplayName wraps g_file_info_get_display_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets a display name for a file. This is guaranteed to always be set.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	GetDisplayName() string
	// GetEditName wraps g_file_info_get_edit_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the edit name for a file.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	GetEditName() string
	// GetEtag wraps g_file_info_get_etag
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the [entity tag][iface@Gio.File#entity-tags] for a given
	// #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_ETAG_VALUE.
	GetEtag() string
	// GetFileType wraps g_file_info_get_file_type
	// 
	// The function returns the following values:
	// 
	// 	- goret FileType 
	//
	// Gets a file's type (whether it is a regular file, symlink, etc).
	// This is different from the file's content type, see g_file_info_get_content_type().
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_TYPE.
	GetFileType() FileType
	// GetIcon wraps g_file_info_get_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon (nullable) 
	//
	// Gets the icon for a file.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_ICON.
	GetIcon() Icon
	// GetIsBackup wraps g_file_info_get_is_backup
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a file is a backup file.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
	GetIsBackup() bool
	// GetIsHidden wraps g_file_info_get_is_hidden
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a file is hidden.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	GetIsHidden() bool
	// GetIsSymlink wraps g_file_info_get_is_symlink
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a file is a symlink.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	GetIsSymlink() bool
	// GetName wraps g_file_info_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name for a file. This is guaranteed to always be set.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_NAME.
	GetName() string
	// GetSize wraps g_file_info_get_size
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	//
	// Gets the file's size (in bytes). The size is retrieved through the value of
	// the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
	// from #guint64 to #goffset before returning the result.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_SIZE.
	GetSize() int64
	// GetSortOrder wraps g_file_info_get_sort_order
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the value of the sort_order attribute from the #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	GetSortOrder() int32
	// GetSymbolicIcon wraps g_file_info_get_symbolic_icon
	// 
	// The function returns the following values:
	// 
	// 	- goret Icon (nullable) 
	//
	// Gets the symbolic icon for a file.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	GetSymbolicIcon() Icon
	// GetSymlinkTarget wraps g_file_info_get_symlink_target
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the symlink target for a given #GFileInfo.
	// 
	// It is an error to call this if the #GFileInfo does not contain
	// %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
	GetSymlinkTarget() string
	// HasAttribute wraps g_file_info_has_attribute
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a file info structure has an attribute named @attribute.
	HasAttribute(string) bool
	// HasNamespace wraps g_file_info_has_namespace
	// 
	// The function takes the following parameters:
	// 
	// 	- nameSpace string: a file attribute namespace. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a file info structure has an attribute in the
	// specified @name_space.
	HasNamespace(string) bool
	// ListAttributes wraps g_file_info_list_attributes
	// 
	// The function takes the following parameters:
	// 
	// 	- nameSpace string (nullable): a file attribute key's namespace, or %NULL to list
	//   all attributes. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string (nullable) 
	//
	// Lists the file info structure's attributes.
	ListAttributes(string) []string
	// RemoveAttribute wraps g_file_info_remove_attribute
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	//
	// Removes all cases of @attribute from @info if it exists.
	RemoveAttribute(string)
	// SetAttributeBoolean wraps g_file_info_set_attribute_boolean
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue bool: a boolean value. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeBoolean(string, bool)
	// SetAttributeByteString wraps g_file_info_set_attribute_byte_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue string: a byte string. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeByteString(string, string)
	// SetAttributeFilePath wraps g_file_info_set_attribute_file_path
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue string: a file path. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	// 
	// This function is meant to be used by language bindings that have specific
	// handling for Unix paths.
	SetAttributeFilePath(string, string)
	// SetAttributeInt32 wraps g_file_info_set_attribute_int32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue int32: a signed 32-bit integer 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt32(string, int32)
	// SetAttributeInt64 wraps g_file_info_set_attribute_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: attribute name to set. 
	// 	- attrValue int64: int64 value to set attribute to. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeInt64(string, int64)
	// SetAttributeMask wraps g_file_info_set_attribute_mask
	// 
	// The function takes the following parameters:
	// 
	// 	- mask *FileAttributeMatcher: a #GFileAttributeMatcher. 
	//
	// Sets @mask on @info to match specific attribute types.
	SetAttributeMask(*FileAttributeMatcher)
	// SetAttributeObject wraps g_file_info_set_attribute_object
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue gobject.Object: a #GObject. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeObject(string, gobject.Object)
	// SetAttributeStatus wraps g_file_info_set_attribute_status
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key 
	// 	- status FileAttributeStatus: a #GFileAttributeStatus 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets the attribute status for an attribute key. This is only
	// needed by external code that implement g_file_set_attributes_from_info()
	// or similar functions.
	// 
	// The attribute must exist in @info for this to work. Otherwise %FALSE
	// is returned and @info is unchanged.
	SetAttributeStatus(string, FileAttributeStatus) bool
	// SetAttributeString wraps g_file_info_set_attribute_string
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue string: a UTF-8 string. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeString(string, string)
	// SetAttributeStringv wraps g_file_info_set_attribute_stringv
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key 
	// 	- attrValue []string: a %NULL
	//   terminated array of UTF-8 strings. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	// 
	// Sinze: 2.22
	SetAttributeStringv(string, []string)
	// SetAttributeUint32 wraps g_file_info_set_attribute_uint32
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue uint32: an unsigned 32-bit integer. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint32(string, uint32)
	// SetAttributeUint64 wraps g_file_info_set_attribute_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- attribute string: a file attribute key. 
	// 	- attrValue uint64: an unsigned 64-bit integer. 
	//
	// Sets the @attribute to contain the given @attr_value,
	// if possible.
	SetAttributeUint64(string, uint64)
	// SetContentType wraps g_file_info_set_content_type
	// 
	// The function takes the following parameters:
	// 
	// 	- contentType string: a [content type](content-types.html#content-types). 
	//
	// Sets the content type attribute for a given #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
	SetContentType(string)
	// SetDisplayName wraps g_file_info_set_display_name
	// 
	// The function takes the following parameters:
	// 
	// 	- displayName string: a string containing a display name. 
	//
	// Sets the display name for the current #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
	SetDisplayName(string)
	// SetEditName wraps g_file_info_set_edit_name
	// 
	// The function takes the following parameters:
	// 
	// 	- editName string: a string containing an edit name. 
	//
	// Sets the edit name for the current file.
	// See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
	SetEditName(string)
	// SetFileType wraps g_file_info_set_file_type
	// 
	// The function takes the following parameters:
	// 
	// 	- typ FileType: a #GFileType. 
	//
	// Sets the file type in a #GFileInfo to @type.
	// See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
	SetFileType(FileType)
	// SetIcon wraps g_file_info_set_icon
	// 
	// The function takes the following parameters:
	// 
	// 	- icon Icon: a #GIcon. 
	//
	// Sets the icon for a given #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_ICON.
	SetIcon(Icon)
	// SetIsHidden wraps g_file_info_set_is_hidden
	// 
	// The function takes the following parameters:
	// 
	// 	- isHidden bool: a #gboolean. 
	//
	// Sets the "is_hidden" attribute in a #GFileInfo according to @is_hidden.
	// See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
	SetIsHidden(bool)
	// SetIsSymlink wraps g_file_info_set_is_symlink
	// 
	// The function takes the following parameters:
	// 
	// 	- isSymlink bool: a #gboolean. 
	//
	// Sets the "is_symlink" attribute in a #GFileInfo according to @is_symlink.
	// See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
	SetIsSymlink(bool)
	// SetName wraps g_file_info_set_name
	// 
	// The function takes the following parameters:
	// 
	// 	- name string: a string containing a name. 
	//
	// Sets the name attribute for the current #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_NAME.
	SetName(string)
	// SetSize wraps g_file_info_set_size
	// 
	// The function takes the following parameters:
	// 
	// 	- size int64: a #goffset containing the file's size. 
	//
	// Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
	// to the given size.
	SetSize(int64)
	// SetSortOrder wraps g_file_info_set_sort_order
	// 
	// The function takes the following parameters:
	// 
	// 	- sortOrder int32: a sort order integer. 
	//
	// Sets the sort order attribute in the file info structure. See
	// %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
	SetSortOrder(int32)
	// SetSymbolicIcon wraps g_file_info_set_symbolic_icon
	// 
	// The function takes the following parameters:
	// 
	// 	- icon Icon: a #GIcon. 
	//
	// Sets the symbolic icon for a given #GFileInfo.
	// See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
	SetSymbolicIcon(Icon)
	// SetSymlinkTarget wraps g_file_info_set_symlink_target
	// 
	// The function takes the following parameters:
	// 
	// 	- symlinkTarget string: a static string containing a path to a symlink target. 
	//
	// Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
	// to the given symlink target.
	SetSymlinkTarget(string)
	// UnsetAttributeMask wraps g_file_info_unset_attribute_mask
	//
	// Unsets a mask set by g_file_info_set_attribute_mask(), if one
	// is set.
	UnsetAttributeMask()
}

func unsafeWrapFileInfo(base *gobject.ObjectInstance) *FileInfoInstance {
	return &FileInfoInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileInfo,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInfo(inst)
		},
	)
}

func marshalFileInfoInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileInfoFromGlibNone is used to convert raw GFileInfo pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInfoFromGlibNone(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibNone(c).(FileInfo)
}

// UnsafeFileInfoFromGlibFull is used to convert raw GFileInfo pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInfoFromGlibFull(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibFull(c).(FileInfo)
}

// UnsafeFileInfoFromGlibBorrow is used to convert raw GFileInfo pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileInfoFromGlibBorrow(c unsafe.Pointer) FileInfo {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileInfo)
}

func (f *FileInfoInstance) upcastToGFileInfo() *FileInfoInstance {
	return f
}

// UnsafeFileInfoToGlibNone is used to convert the instance to it's C value GFileInfo. This is used by the bindings internally.
func UnsafeFileInfoToGlibNone(c FileInfo) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileInfoToGlibFull is used to convert the instance to it's C value GFileInfo, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileInfoToGlibFull(c FileInfo) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFileInfo wraps g_file_info_new
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
//
// Creates a new file info structure.
func NewFileInfo() FileInfo {
	var cret *C.GFileInfo // return, full, converted

	cret = C.g_file_info_new()

	var goret FileInfo

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ClearStatus wraps g_file_info_clear_status
//
// Clears the status information from @info.
func (info *FileInfoInstance) ClearStatus() {
	var carg0 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	C.g_file_info_clear_status(carg0)
	runtime.KeepAlive(info)
}

// CopyInto wraps g_file_info_copy_into
// 
// The function takes the following parameters:
// 
// 	- destInfo FileInfo: destination to copy attributes to. 
//
// First clears all of the [GFileAttribute](file-attributes.html#file-attributes) of
// @dest_info, and then copies all of the file attributes from @src_info to @dest_info.
func (srcInfo *FileInfoInstance) CopyInto(destInfo FileInfo) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(srcInfo))
	carg1 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(destInfo))

	C.g_file_info_copy_into(carg0, carg1)
	runtime.KeepAlive(srcInfo)
	runtime.KeepAlive(destInfo)
}

// Dup wraps g_file_info_dup
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
//
// Duplicates a file info structure.
func (other *FileInfoInstance) Dup() FileInfo {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GFileInfo // return, full, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(other))

	cret = C.g_file_info_dup(carg0)
	runtime.KeepAlive(other)

	var goret FileInfo

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAttributeAsString wraps g_file_info_get_attribute_as_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the value of an attribute, formatted as a human readable string.
// 
// This escapes things as needed to make the string valid UTF-8 and readable by
// humans. It&#x2019;s not meant to be a machine readable or reversible escaping
// format.
// 
// To format file name attributes of type
// [enum@Gio.FileAttributeType.BYTE_STRING] for output as UTF-8, use
// [func@GLib.filename_to_utf8] instead:
// ```c
// const char *trash_orig_path_byte_string;
// g_autofree char *trash_orig_path_utf8 = NULL;
// 
// trash_orig_path_byte_string = g_file_info_get_attribute_byte_string (info, G_FILE_ATTRIBUTE_TRASH_ORIG_PATH);
// trash_orig_path_utf8 = g_filename_to_utf8 (trash_orig_path_byte_string, -1, NULL, NULL, NULL);
// if (trash_orig_path_utf8 != NULL)
//   g_message ("Some larger UTF-8 string with filename embedded as %s", trash_orig_path_utf8);
// ```
func (info *FileInfoInstance) GetAttributeAsString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, full, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_as_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetAttributeBoolean wraps g_file_info_get_attribute_boolean
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value of a boolean attribute. If the attribute does not
// contain a boolean value, %FALSE will be returned.
func (info *FileInfoInstance) GetAttributeBoolean(attribute string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_boolean(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetAttributeByteString wraps g_file_info_get_attribute_byte_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the value of a byte string attribute. If the attribute does
// not contain a byte string, %NULL will be returned.
func (info *FileInfoInstance) GetAttributeByteString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_byte_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeFilePath wraps g_file_info_get_attribute_file_path
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the value of a byte string attribute as a file path.
// 
// If the attribute does not contain a byte string, `NULL` will be returned.
// 
// This function is meant to be used by language bindings that have specific
// handling for Unix paths.
func (info *FileInfoInstance) GetAttributeFilePath(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_file_path(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeInt32 wraps g_file_info_get_attribute_int32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets a signed 32-bit integer contained within the attribute. If the
// attribute does not contain a signed 32-bit integer, or is invalid,
// 0 will be returned.
func (info *FileInfoInstance) GetAttributeInt32(attribute string) int32 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_int32(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetAttributeInt64 wraps g_file_info_get_attribute_int64
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Gets a signed 64-bit integer contained within the attribute. If the
// attribute does not contain a signed 64-bit integer, or is invalid,
// 0 will be returned.
func (info *FileInfoInstance) GetAttributeInt64(attribute string) int64 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gint64     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_int64(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetAttributeObject wraps g_file_info_get_attribute_object
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret gobject.Object (nullable) 
//
// Gets the value of a #GObject attribute. If the attribute does
// not contain a #GObject, %NULL will be returned.
func (info *FileInfoInstance) GetAttributeObject(attribute string) gobject.Object {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.GObject   // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_object(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret gobject.Object

	if cret != nil {
		goret = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetAttributeStatus wraps g_file_info_get_attribute_status
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key 
// 
// The function returns the following values:
// 
// 	- goret FileAttributeStatus 
//
// Gets the attribute status for an attribute key.
func (info *FileInfoInstance) GetAttributeStatus(attribute string) FileAttributeStatus {
	var carg0 *C.GFileInfo           // in, none, converted
	var carg1 *C.char                // in, none, string
	var cret  C.GFileAttributeStatus // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_status(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret FileAttributeStatus

	goret = FileAttributeStatus(cret)

	return goret
}

// GetAttributeString wraps g_file_info_get_attribute_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the value of a string attribute. If the attribute does
// not contain a string, %NULL will be returned.
func (info *FileInfoInstance) GetAttributeString(attribute string) string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_string(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetAttributeStringv wraps g_file_info_get_attribute_stringv
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret []string (nullable) 
//
// Gets the value of a stringv attribute. If the attribute does
// not contain a stringv, %NULL will be returned.
func (info *FileInfoInstance) GetAttributeStringv(attribute string) []string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  **C.char     // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_stringv(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// GetAttributeType wraps g_file_info_get_attribute_type
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret FileAttributeType 
//
// Gets the attribute type for an attribute key.
func (info *FileInfoInstance) GetAttributeType(attribute string) FileAttributeType {
	var carg0 *C.GFileInfo         // in, none, converted
	var carg1 *C.char              // in, none, string
	var cret  C.GFileAttributeType // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret FileAttributeType

	goret = FileAttributeType(cret)

	return goret
}

// GetAttributeUint32 wraps g_file_info_get_attribute_uint32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Gets an unsigned 32-bit integer contained within the attribute. If the
// attribute does not contain an unsigned 32-bit integer, or is invalid,
// 0 will be returned.
func (info *FileInfoInstance) GetAttributeUint32(attribute string) uint32 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.guint32    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_uint32(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// GetAttributeUint64 wraps g_file_info_get_attribute_uint64
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret uint64 
//
// Gets a unsigned 64-bit integer contained within the attribute. If the
// attribute does not contain an unsigned 64-bit integer, or is invalid,
// 0 will be returned.
func (info *FileInfoInstance) GetAttributeUint64(attribute string) uint64 {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.guint64    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_get_attribute_uint64(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret uint64

	goret = uint64(cret)

	return goret
}

// GetContentType wraps g_file_info_get_content_type
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the file's content type.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
func (info *FileInfoInstance) GetContentType() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_content_type(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetDisplayName wraps g_file_info_get_display_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets a display name for a file. This is guaranteed to always be set.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
func (info *FileInfoInstance) GetDisplayName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_display_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetEditName wraps g_file_info_get_edit_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the edit name for a file.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
func (info *FileInfoInstance) GetEditName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_edit_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetEtag wraps g_file_info_get_etag
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the [entity tag][iface@Gio.File#entity-tags] for a given
// #GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_ETAG_VALUE.
func (info *FileInfoInstance) GetEtag() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable-string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_etag(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFileType wraps g_file_info_get_file_type
// 
// The function returns the following values:
// 
// 	- goret FileType 
//
// Gets a file's type (whether it is a regular file, symlink, etc).
// This is different from the file's content type, see g_file_info_get_content_type().
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_TYPE.
func (info *FileInfoInstance) GetFileType() FileType {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.GFileType  // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_file_type(carg0)
	runtime.KeepAlive(info)

	var goret FileType

	goret = FileType(cret)

	return goret
}

// GetIcon wraps g_file_info_get_icon
// 
// The function returns the following values:
// 
// 	- goret Icon (nullable) 
//
// Gets the icon for a file.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_ICON.
func (info *FileInfoInstance) GetIcon() Icon {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GIcon     // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_icon(carg0)
	runtime.KeepAlive(info)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetIsBackup wraps g_file_info_get_is_backup
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a file is a backup file.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP.
func (info *FileInfoInstance) GetIsBackup() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_backup(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsHidden wraps g_file_info_get_is_hidden
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a file is hidden.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
func (info *FileInfoInstance) GetIsHidden() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_hidden(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsSymlink wraps g_file_info_get_is_symlink
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a file is a symlink.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
func (info *FileInfoInstance) GetIsSymlink() bool {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_is_symlink(carg0)
	runtime.KeepAlive(info)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetName wraps g_file_info_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name for a file. This is guaranteed to always be set.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_NAME.
func (info *FileInfoInstance) GetName() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_name(carg0)
	runtime.KeepAlive(info)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSize wraps g_file_info_get_size
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Gets the file's size (in bytes). The size is retrieved through the value of
// the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
// from #guint64 to #goffset before returning the result.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_SIZE.
func (info *FileInfoInstance) GetSize() int64 {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.goffset    // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_size(carg0)
	runtime.KeepAlive(info)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetSortOrder wraps g_file_info_get_sort_order
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the value of the sort_order attribute from the #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (info *FileInfoInstance) GetSortOrder() int32 {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_sort_order(carg0)
	runtime.KeepAlive(info)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSymbolicIcon wraps g_file_info_get_symbolic_icon
// 
// The function returns the following values:
// 
// 	- goret Icon (nullable) 
//
// Gets the symbolic icon for a file.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
func (info *FileInfoInstance) GetSymbolicIcon() Icon {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.GIcon     // return, none, converted, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_symbolic_icon(carg0)
	runtime.KeepAlive(info)

	var goret Icon

	if cret != nil {
		goret = UnsafeIconFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetSymlinkTarget wraps g_file_info_get_symlink_target
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the symlink target for a given #GFileInfo.
// 
// It is an error to call this if the #GFileInfo does not contain
// %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET.
func (info *FileInfoInstance) GetSymlinkTarget() string {
	var carg0 *C.GFileInfo // in, none, converted
	var cret  *C.char      // return, none, string, nullable

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	cret = C.g_file_info_get_symlink_target(carg0)
	runtime.KeepAlive(info)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HasAttribute wraps g_file_info_has_attribute
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a file info structure has an attribute named @attribute.
func (info *FileInfoInstance) HasAttribute(attribute string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_has_attribute(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HasNamespace wraps g_file_info_has_namespace
// 
// The function takes the following parameters:
// 
// 	- nameSpace string: a file attribute namespace. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a file info structure has an attribute in the
// specified @name_space.
func (info *FileInfoInstance) HasNamespace(nameSpace string) bool {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_info_has_namespace(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListAttributes wraps g_file_info_list_attributes
// 
// The function takes the following parameters:
// 
// 	- nameSpace string (nullable): a file attribute key's namespace, or %NULL to list
//   all attributes. 
// 
// The function returns the following values:
// 
// 	- goret []string (nullable) 
//
// Lists the file info structure's attributes.
func (info *FileInfoInstance) ListAttributes(nameSpace string) []string {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string, nullable-string
	var cret  **C.char     // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if nameSpace != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_info_list_attributes(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// RemoveAttribute wraps g_file_info_remove_attribute
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
//
// Removes all cases of @attribute from @info if it exists.
func (info *FileInfoInstance) RemoveAttribute(attribute string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_remove_attribute(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
}

// SetAttributeBoolean wraps g_file_info_set_attribute_boolean
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue bool: a boolean value. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeBoolean(attribute string, attrValue bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	if attrValue {
		carg2 = C.TRUE
	}

	C.g_file_info_set_attribute_boolean(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeByteString wraps g_file_info_set_attribute_byte_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue string: a byte string. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeByteString(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_byte_string(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeFilePath wraps g_file_info_set_attribute_file_path
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue string: a file path. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
// 
// This function is meant to be used by language bindings that have specific
// handling for Unix paths.
func (info *FileInfoInstance) SetAttributeFilePath(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_file_path(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt32 wraps g_file_info_set_attribute_int32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue int32: a signed 32-bit integer 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeInt32(attribute string, attrValue int32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gint32     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint32(attrValue)

	C.g_file_info_set_attribute_int32(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeInt64 wraps g_file_info_set_attribute_int64
// 
// The function takes the following parameters:
// 
// 	- attribute string: attribute name to set. 
// 	- attrValue int64: int64 value to set attribute to. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeInt64(attribute string, attrValue int64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.gint64     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(attrValue)

	C.g_file_info_set_attribute_int64(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeMask wraps g_file_info_set_attribute_mask
// 
// The function takes the following parameters:
// 
// 	- mask *FileAttributeMatcher: a #GFileAttributeMatcher. 
//
// Sets @mask on @info to match specific attribute types.
func (info *FileInfoInstance) SetAttributeMask(mask *FileAttributeMatcher) {
	var carg0 *C.GFileInfo             // in, none, converted
	var carg1 *C.GFileAttributeMatcher // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(mask))

	C.g_file_info_set_attribute_mask(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(mask)
}

// SetAttributeObject wraps g_file_info_set_attribute_object
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue gobject.Object: a #GObject. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeObject(attribute string, attrValue gobject.Object) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.GObject   // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(attrValue))

	C.g_file_info_set_attribute_object(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStatus wraps g_file_info_set_attribute_status
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key 
// 	- status FileAttributeStatus: a #GFileAttributeStatus 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets the attribute status for an attribute key. This is only
// needed by external code that implement g_file_set_attributes_from_info()
// or similar functions.
// 
// The attribute must exist in @info for this to work. Otherwise %FALSE
// is returned and @info is unchanged.
func (info *FileInfoInstance) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var carg0 *C.GFileInfo           // in, none, converted
	var carg1 *C.char                // in, none, string
	var carg2 C.GFileAttributeStatus // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileAttributeStatus(status)

	cret = C.g_file_info_set_attribute_status(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(status)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetAttributeString wraps g_file_info_set_attribute_string
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue string: a UTF-8 string. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeString(attribute string, attrValue string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(attrValue)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_file_info_set_attribute_string(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeStringv wraps g_file_info_set_attribute_stringv
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key 
// 	- attrValue []string: a %NULL
//   terminated array of UTF-8 strings. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
// 
// Sinze: 2.22
func (info *FileInfoInstance) SetAttributeStringv(attribute string, attrValue []string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 **C.char     // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	_ = attrValue
	_ = carg2
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	C.g_file_info_set_attribute_stringv(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint32 wraps g_file_info_set_attribute_uint32
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue uint32: an unsigned 32-bit integer. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeUint32(attribute string, attrValue uint32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.guint32    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint32(attrValue)

	C.g_file_info_set_attribute_uint32(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetAttributeUint64 wraps g_file_info_set_attribute_uint64
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 	- attrValue uint64: an unsigned 64-bit integer. 
//
// Sets the @attribute to contain the given @attr_value,
// if possible.
func (info *FileInfoInstance) SetAttributeUint64(attribute string, attrValue uint64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string
	var carg2 C.guint64    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(attrValue)

	C.g_file_info_set_attribute_uint64(carg0, carg1, carg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(attrValue)
}

// SetContentType wraps g_file_info_set_content_type
// 
// The function takes the following parameters:
// 
// 	- contentType string: a [content type](content-types.html#content-types). 
//
// Sets the content type attribute for a given #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.
func (info *FileInfoInstance) SetContentType(contentType string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_content_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(contentType)
}

// SetDisplayName wraps g_file_info_set_display_name
// 
// The function takes the following parameters:
// 
// 	- displayName string: a string containing a display name. 
//
// Sets the display name for the current #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.
func (info *FileInfoInstance) SetDisplayName(displayName string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_display_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(displayName)
}

// SetEditName wraps g_file_info_set_edit_name
// 
// The function takes the following parameters:
// 
// 	- editName string: a string containing an edit name. 
//
// Sets the edit name for the current file.
// See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.
func (info *FileInfoInstance) SetEditName(editName string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(editName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_edit_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(editName)
}

// SetFileType wraps g_file_info_set_file_type
// 
// The function takes the following parameters:
// 
// 	- typ FileType: a #GFileType. 
//
// Sets the file type in a #GFileInfo to @type.
// See %G_FILE_ATTRIBUTE_STANDARD_TYPE.
func (info *FileInfoInstance) SetFileType(typ FileType) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.GFileType  // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.GFileType(typ)

	C.g_file_info_set_file_type(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(typ)
}

// SetIcon wraps g_file_info_set_icon
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a #GIcon. 
//
// Sets the icon for a given #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_ICON.
func (info *FileInfoInstance) SetIcon(icon Icon) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_file_info_set_icon(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetIsHidden wraps g_file_info_set_is_hidden
// 
// The function takes the following parameters:
// 
// 	- isHidden bool: a #gboolean. 
//
// Sets the "is_hidden" attribute in a #GFileInfo according to @is_hidden.
// See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.
func (info *FileInfoInstance) SetIsHidden(isHidden bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if isHidden {
		carg1 = C.TRUE
	}

	C.g_file_info_set_is_hidden(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isHidden)
}

// SetIsSymlink wraps g_file_info_set_is_symlink
// 
// The function takes the following parameters:
// 
// 	- isSymlink bool: a #gboolean. 
//
// Sets the "is_symlink" attribute in a #GFileInfo according to @is_symlink.
// See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.
func (info *FileInfoInstance) SetIsSymlink(isSymlink bool) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	if isSymlink {
		carg1 = C.TRUE
	}

	C.g_file_info_set_is_symlink(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(isSymlink)
}

// SetName wraps g_file_info_set_name
// 
// The function takes the following parameters:
// 
// 	- name string: a string containing a name. 
//
// Sets the name attribute for the current #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_NAME.
func (info *FileInfoInstance) SetName(name string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_name(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
}

// SetSize wraps g_file_info_set_size
// 
// The function takes the following parameters:
// 
// 	- size int64: a #goffset containing the file's size. 
//
// Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
// to the given size.
func (info *FileInfoInstance) SetSize(size int64) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.goffset    // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.goffset(size)

	C.g_file_info_set_size(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(size)
}

// SetSortOrder wraps g_file_info_set_sort_order
// 
// The function takes the following parameters:
// 
// 	- sortOrder int32: a sort order integer. 
//
// Sets the sort order attribute in the file info structure. See
// %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.
func (info *FileInfoInstance) SetSortOrder(sortOrder int32) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 C.gint32     // in, none, casted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = C.gint32(sortOrder)

	C.g_file_info_set_sort_order(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(sortOrder)
}

// SetSymbolicIcon wraps g_file_info_set_symbolic_icon
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a #GIcon. 
//
// Sets the symbolic icon for a given #GFileInfo.
// See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.
func (info *FileInfoInstance) SetSymbolicIcon(icon Icon) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_file_info_set_symbolic_icon(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(icon)
}

// SetSymlinkTarget wraps g_file_info_set_symlink_target
// 
// The function takes the following parameters:
// 
// 	- symlinkTarget string: a static string containing a path to a symlink target. 
//
// Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
// to the given symlink target.
func (info *FileInfoInstance) SetSymlinkTarget(symlinkTarget string) {
	var carg0 *C.GFileInfo // in, none, converted
	var carg1 *C.char      // in, none, string

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(symlinkTarget)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_file_info_set_symlink_target(carg0, carg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(symlinkTarget)
}

// UnsetAttributeMask wraps g_file_info_unset_attribute_mask
//
// Unsets a mask set by g_file_info_set_attribute_mask(), if one
// is set.
func (info *FileInfoInstance) UnsetAttributeMask() {
	var carg0 *C.GFileInfo // in, none, converted

	carg0 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))

	C.g_file_info_unset_attribute_mask(carg0)
	runtime.KeepAlive(info)
}

// FileMonitorInstance is the instance type used by all types extending GFileMonitor. It is used internally by the bindings. Users should use the interface [FileMonitor] instead.
type FileMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FileMonitor = (*FileMonitorInstance)(nil)

// FileMonitor wraps GFileMonitor
//
// Monitors a file or directory for changes.
// 
// To obtain a `GFileMonitor` for a file or directory, use
// [method@Gio.File.monitor], [method@Gio.File.monitor_file], or
// [method@Gio.File.monitor_directory].
// 
// To get informed about changes to the file or directory you are
// monitoring, connect to the [signal@Gio.FileMonitor::changed] signal. The
// signal will be emitted in the thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) of the thread that the monitor
// was created in (though if the global default main context is blocked, this
// may cause notifications to be blocked even if the thread-default
// context is still running).
type FileMonitor interface {
	gobject.Object
	upcastToGFileMonitor() *FileMonitorInstance

	// Cancel wraps g_file_monitor_cancel
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Cancels a file monitor.
	Cancel() bool
	// EmitEvent wraps g_file_monitor_emit_event
	// 
	// The function takes the following parameters:
	// 
	// 	- child File: a #GFile. 
	// 	- otherFile File (nullable): a #GFile, or %NULL. 
	// 	- eventType FileMonitorEvent: a set of #GFileMonitorEvent flags. 
	//
	// Emits the #GFileMonitor::changed signal if a change
	// has taken place. Should be called from file monitor
	// implementations only.
	// 
	// Implementations are responsible to call this method from the
	// thread-default main context (see [method@GLib.MainContext.push_thread_default])
	// of the thread that the monitor was created in.
	EmitEvent(File, File, FileMonitorEvent)
	// IsCancelled wraps g_file_monitor_is_cancelled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Returns whether the monitor is canceled.
	IsCancelled() bool
	// SetRateLimit wraps g_file_monitor_set_rate_limit
	// 
	// The function takes the following parameters:
	// 
	// 	- limitMsecs int32: a non-negative integer with the limit in milliseconds
	//     to poll for changes 
	//
	// Sets the rate limit to which the @monitor will report
	// consecutive change events to the same file.
	SetRateLimit(int32)
	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Emitted when @file has been changed.
	// 
	// If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
	// the information is available (and if supported by the backend),
	// @event_type may be %G_FILE_MONITOR_EVENT_RENAMED,
	// %G_FILE_MONITOR_EVENT_MOVED_IN or %G_FILE_MONITOR_EVENT_MOVED_OUT.
	// 
	// In all cases @file will be a child of the monitored directory.  For
	// renames, @file will be the old name and @other_file is the new
	// name.  For "moved in" events, @file is the name of the file that
	// appeared and @other_file is the old name that it was moved from (in
	// another directory).  For "moved out" events, @file is the name of
	// the file that used to be in this directory and @other_file is the
	// name of the file at its new location.
	// 
	// It makes sense to treat %G_FILE_MONITOR_EVENT_MOVED_IN as
	// equivalent to %G_FILE_MONITOR_EVENT_CREATED and
	// %G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
	// %G_FILE_MONITOR_EVENT_DELETED, with extra information.
	// %G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
	// pair.  This is exactly how the events will be reported in the case
	// that the %G_FILE_MONITOR_WATCH_MOVES flag is not in use.
	// 
	// If using the deprecated flag %G_FILE_MONITOR_SEND_MOVED flag and @event_type is
	// %G_FILE_MONITOR_EVENT_MOVED, @file will be set to a #GFile containing the
	// old path, and @other_file will be set to a #GFile containing the new path.
	// 
	// In all the other cases, @other_file will be set to #NULL.
	ConnectChanged(func(FileMonitor, File, File, FileMonitorEvent)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentCancel calls the default implementations of the `GFileMonitor.cancel` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Cancels a file monitor.
	ParentCancel() bool
	// ParentChanged calls the default implementations of the `GFileMonitor.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- file File 
	// 	- otherFile File 
	// 	- eventType FileMonitorEvent 
	ParentChanged(file File, otherFile File, eventType FileMonitorEvent)
}

func unsafeWrapFileMonitor(base *gobject.ObjectInstance) *FileMonitorInstance {
	return &FileMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileMonitor(inst)
		},
	)
}

func marshalFileMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileMonitorFromGlibNone is used to convert raw GFileMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibNone(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(FileMonitor)
}

// UnsafeFileMonitorFromGlibFull is used to convert raw GFileMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibFull(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(FileMonitor)
}

// UnsafeFileMonitorFromGlibBorrow is used to convert raw GFileMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileMonitorFromGlibBorrow(c unsafe.Pointer) FileMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileMonitor)
}

func (f *FileMonitorInstance) upcastToGFileMonitor() *FileMonitorInstance {
	return f
}

// UnsafeFileMonitorToGlibNone is used to convert the instance to it's C value GFileMonitor. This is used by the bindings internally.
func UnsafeFileMonitorToGlibNone(c FileMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileMonitorToGlibFull is used to convert the instance to it's C value GFileMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileMonitorToGlibFull(c FileMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Cancel wraps g_file_monitor_cancel
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Cancels a file monitor.
func (monitor *FileMonitorInstance) Cancel() bool {
	var carg0 *C.GFileMonitor // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C.g_file_monitor_cancel(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// EmitEvent wraps g_file_monitor_emit_event
// 
// The function takes the following parameters:
// 
// 	- child File: a #GFile. 
// 	- otherFile File (nullable): a #GFile, or %NULL. 
// 	- eventType FileMonitorEvent: a set of #GFileMonitorEvent flags. 
//
// Emits the #GFileMonitor::changed signal if a change
// has taken place. Should be called from file monitor
// implementations only.
// 
// Implementations are responsible to call this method from the
// thread-default main context (see [method@GLib.MainContext.push_thread_default])
// of the thread that the monitor was created in.
func (monitor *FileMonitorInstance) EmitEvent(child File, otherFile File, eventType FileMonitorEvent) {
	var carg0 *C.GFileMonitor     // in, none, converted
	var carg1 *C.GFile            // in, none, converted
	var carg2 *C.GFile            // in, none, converted, nullable
	var carg3 C.GFileMonitorEvent // in, none, casted

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(child))
	if otherFile != nil {
		carg2 = (*C.GFile)(UnsafeFileToGlibNone(otherFile))
	}
	carg3 = C.GFileMonitorEvent(eventType)

	C.g_file_monitor_emit_event(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(child)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// IsCancelled wraps g_file_monitor_is_cancelled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the monitor is canceled.
func (monitor *FileMonitorInstance) IsCancelled() bool {
	var carg0 *C.GFileMonitor // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C.g_file_monitor_is_cancelled(carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetRateLimit wraps g_file_monitor_set_rate_limit
// 
// The function takes the following parameters:
// 
// 	- limitMsecs int32: a non-negative integer with the limit in milliseconds
//     to poll for changes 
//
// Sets the rate limit to which the @monitor will report
// consecutive change events to the same file.
func (monitor *FileMonitorInstance) SetRateLimit(limitMsecs int32) {
	var carg0 *C.GFileMonitor // in, none, converted
	var carg1 C.gint          // in, none, casted

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = C.gint(limitMsecs)

	C.g_file_monitor_set_rate_limit(carg0, carg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(limitMsecs)
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Emitted when @file has been changed.
// 
// If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
// the information is available (and if supported by the backend),
// @event_type may be %G_FILE_MONITOR_EVENT_RENAMED,
// %G_FILE_MONITOR_EVENT_MOVED_IN or %G_FILE_MONITOR_EVENT_MOVED_OUT.
// 
// In all cases @file will be a child of the monitored directory.  For
// renames, @file will be the old name and @other_file is the new
// name.  For "moved in" events, @file is the name of the file that
// appeared and @other_file is the old name that it was moved from (in
// another directory).  For "moved out" events, @file is the name of
// the file that used to be in this directory and @other_file is the
// name of the file at its new location.
// 
// It makes sense to treat %G_FILE_MONITOR_EVENT_MOVED_IN as
// equivalent to %G_FILE_MONITOR_EVENT_CREATED and
// %G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent to
// %G_FILE_MONITOR_EVENT_DELETED, with extra information.
// %G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create
// pair.  This is exactly how the events will be reported in the case
// that the %G_FILE_MONITOR_WATCH_MOVES flag is not in use.
// 
// If using the deprecated flag %G_FILE_MONITOR_SEND_MOVED flag and @event_type is
// %G_FILE_MONITOR_EVENT_MOVED, @file will be set to a #GFile containing the
// old path, and @other_file will be set to a #GFile containing the new path.
// 
// In all the other cases, @other_file will be set to #NULL.
func (o *FileMonitorInstance) ConnectChanged(fn func(FileMonitor, File, File, FileMonitorEvent)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// FileMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileMonitorOverrides[Instance FileMonitor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Cancel allows you to override the implementation of the virtual method cancel.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Cancels a file monitor.
	Cancel func(Instance) bool
	// // Changed allows you to override the implementation of the virtual method changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- file File 
	// 	- otherFile File 
	// 	- eventType FileMonitorEvent 
	Changed func(Instance, File, File, FileMonitorEvent)
}

// UnsafeApplyFileMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileMonitorOverrides[Instance FileMonitor](gclass unsafe.Pointer, overrides FileMonitorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFileMonitorClass)(gclass)

	if overrides.Cancel != nil {
		pclass.cancel = (*[0]byte)(C._goglib_gio2_FileMonitor_cancel)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileMonitor_cancel",
			func(carg0 *C.GFileMonitor) (cret C.gboolean) {
				var monitor Instance // go GFileMonitor subclass
				var goret   bool     // return

				monitor = UnsafeFileMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Cancel(monitor)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_FileMonitor_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileMonitor_changed",
			func(carg0 *C.GFileMonitor, carg1 *C.GFile, carg2 *C.GFile, carg3 C.GFileMonitorEvent) {
				var monitor   Instance         // go GFileMonitor subclass
				var file      File             // in, none, converted
				var otherFile File             // in, none, converted
				var eventType FileMonitorEvent // in, none, casted

				monitor = UnsafeFileMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				file = UnsafeFileFromGlibNone(unsafe.Pointer(carg1))
				otherFile = UnsafeFileFromGlibNone(unsafe.Pointer(carg2))
				eventType = FileMonitorEvent(carg3)

				overrides.Changed(monitor, file, otherFile, eventType)
			},
		)
	}
}

// ParentCancel calls the default implementations of the `GFileMonitor.cancel` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Cancels a file monitor.
func (monitor *FileMonitorInstance) ParentCancel() bool {
	var carg0 *C.GFileMonitor
	var cret  C.gboolean // return

	parentclass := (*C.GFileMonitorClass)(classdata.PeekParentClass(UnsafeFileMonitorToGlibNone(monitor)))

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))

	cret = C._goglib_gio2_FileMonitor_virtual_cancel(unsafe.Pointer(parentclass.cancel), carg0)
	runtime.KeepAlive(monitor)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentChanged calls the default implementations of the `GFileMonitor.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- file File 
// 	- otherFile File 
// 	- eventType FileMonitorEvent 
func (monitor *FileMonitorInstance) ParentChanged(file File, otherFile File, eventType FileMonitorEvent) {
	var carg0 *C.GFileMonitor
	var carg1 *C.GFile            // in, none, converted
	var carg2 *C.GFile            // in, none, converted
	var carg3 C.GFileMonitorEvent // in, none, converted

	parentclass := (*C.GFileMonitorClass)(classdata.PeekParentClass(UnsafeFileMonitorToGlibNone(monitor)))

	carg0 = (*C.GFileMonitor)(UnsafeFileMonitorToGlibNone(monitor))
	carg1 = (*C.GFile)(UnsafeFileToGlibNone(file))
	carg2 = (*C.GFile)(UnsafeFileToGlibNone(otherFile))
	carg3 = C.GFileMonitorEvent(eventType)

	C._goglib_gio2_FileMonitor_virtual_changed(unsafe.Pointer(parentclass.changed), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(file)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// RegisterFileMonitorSubClass is used to register a go subclass of GFileMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileMonitorSubClass[InstanceT FileMonitor](
		name string,
		classInit func(class *FileMonitorClass),
		constructor func() InstanceT,
		overrides FileMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileMonitor,
		UnsafeFileMonitorClassFromGlibBorrow,
		UnsafeApplyFileMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileMonitor(obj)
		},
		interfaceInits...,
	)
}

// FilenameCompleterInstance is the instance type used by all types extending GFilenameCompleter. It is used internally by the bindings. Users should use the interface [FilenameCompleter] instead.
type FilenameCompleterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ FilenameCompleter = (*FilenameCompleterInstance)(nil)

// FilenameCompleter wraps GFilenameCompleter
//
// Completes partial file and directory names given a partial string by
// looking in the file system for clues. Can return a list of possible
// completion strings for widget implementations.
type FilenameCompleter interface {
	gobject.Object
	upcastToGFilenameCompleter() *FilenameCompleterInstance

	// GetCompletionSuffix wraps g_filename_completer_get_completion_suffix
	// 
	// The function takes the following parameters:
	// 
	// 	- initialText string: text to be completed. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Obtains a completion for @initial_text from @completer.
	GetCompletionSuffix(string) string
	// GetCompletions wraps g_filename_completer_get_completions
	// 
	// The function takes the following parameters:
	// 
	// 	- initialText string: text to be completed. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets an array of completion strings for a given initial text.
	GetCompletions(string) []string
	// SetDirsOnly wraps g_filename_completer_set_dirs_only
	// 
	// The function takes the following parameters:
	// 
	// 	- dirsOnly bool: a #gboolean. 
	//
	// If @dirs_only is %TRUE, @completer will only
	// complete directory names, and not file names.
	SetDirsOnly(bool)
	// ConnectGotCompletionData connects the provided callback to the "got-completion-data" signal
	//
	// Emitted when the file name completion information comes available.
	ConnectGotCompletionData(func(FilenameCompleter)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentGotCompletionData calls the default implementations of the `GFilenameCompleter.got_completion_data` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	ParentGotCompletionData()
}

func unsafeWrapFilenameCompleter(base *gobject.ObjectInstance) *FilenameCompleterInstance {
	return &FilenameCompleterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilenameCompleter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilenameCompleter(inst)
		},
	)
}

func marshalFilenameCompleterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilenameCompleterFromGlibNone is used to convert raw GFilenameCompleter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibNone(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibNone(c).(FilenameCompleter)
}

// UnsafeFilenameCompleterFromGlibFull is used to convert raw GFilenameCompleter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibFull(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibFull(c).(FilenameCompleter)
}

// UnsafeFilenameCompleterFromGlibBorrow is used to convert raw GFilenameCompleter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilenameCompleterFromGlibBorrow(c unsafe.Pointer) FilenameCompleter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilenameCompleter)
}

func (f *FilenameCompleterInstance) upcastToGFilenameCompleter() *FilenameCompleterInstance {
	return f
}

// UnsafeFilenameCompleterToGlibNone is used to convert the instance to it's C value GFilenameCompleter. This is used by the bindings internally.
func UnsafeFilenameCompleterToGlibNone(c FilenameCompleter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilenameCompleterToGlibFull is used to convert the instance to it's C value GFilenameCompleter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilenameCompleterToGlibFull(c FilenameCompleter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewFilenameCompleter wraps g_filename_completer_new
// 
// The function returns the following values:
// 
// 	- goret FilenameCompleter 
//
// Creates a new filename completer.
func NewFilenameCompleter() FilenameCompleter {
	var cret *C.GFilenameCompleter // return, full, converted

	cret = C.g_filename_completer_new()

	var goret FilenameCompleter

	goret = UnsafeFilenameCompleterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetCompletionSuffix wraps g_filename_completer_get_completion_suffix
// 
// The function takes the following parameters:
// 
// 	- initialText string: text to be completed. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Obtains a completion for @initial_text from @completer.
func (completer *FilenameCompleterInstance) GetCompletionSuffix(initialText string) string {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 *C.char               // in, none, string
	var cret  *C.char               // return, full, string, nullable-string

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_completer_get_completion_suffix(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetCompletions wraps g_filename_completer_get_completions
// 
// The function takes the following parameters:
// 
// 	- initialText string: text to be completed. 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets an array of completion strings for a given initial text.
func (completer *FilenameCompleterInstance) GetCompletions(initialText string) []string {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 *C.char               // in, none, string
	var cret  **C.char              // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(initialText)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_completer_get_completions(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(initialText)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (char**) because of unknown reason")

	return goret
}

// SetDirsOnly wraps g_filename_completer_set_dirs_only
// 
// The function takes the following parameters:
// 
// 	- dirsOnly bool: a #gboolean. 
//
// If @dirs_only is %TRUE, @completer will only
// complete directory names, and not file names.
func (completer *FilenameCompleterInstance) SetDirsOnly(dirsOnly bool) {
	var carg0 *C.GFilenameCompleter // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(completer))
	if dirsOnly {
		carg1 = C.TRUE
	}

	C.g_filename_completer_set_dirs_only(carg0, carg1)
	runtime.KeepAlive(completer)
	runtime.KeepAlive(dirsOnly)
}

// ConnectGotCompletionData connects the provided callback to the "got-completion-data" signal
//
// Emitted when the file name completion information comes available.
func (o *FilenameCompleterInstance) ConnectGotCompletionData(fn func(FilenameCompleter)) gobject.SignalHandle {
	return o.Connect("got-completion-data", fn)
}

// FilenameCompleterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilenameCompleterOverrides[Instance FilenameCompleter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GotCompletionData allows you to override the implementation of the virtual method got_completion_data.
	GotCompletionData func(Instance)
}

// UnsafeApplyFilenameCompleterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilenameCompleterOverrides[Instance FilenameCompleter](gclass unsafe.Pointer, overrides FilenameCompleterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GFilenameCompleterClass)(gclass)

	if overrides.GotCompletionData != nil {
		pclass.got_completion_data = (*[0]byte)(C._goglib_gio2_FilenameCompleter_got_completion_data)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FilenameCompleter_got_completion_data",
			func(carg0 *C.GFilenameCompleter) {
				var filenameCompleter Instance // go GFilenameCompleter subclass

				filenameCompleter = UnsafeFilenameCompleterFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.GotCompletionData(filenameCompleter)
			},
		)
	}
}

// ParentGotCompletionData calls the default implementations of the `GFilenameCompleter.got_completion_data` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
func (filenameCompleter *FilenameCompleterInstance) ParentGotCompletionData() {
	var carg0 *C.GFilenameCompleter

	parentclass := (*C.GFilenameCompleterClass)(classdata.PeekParentClass(UnsafeFilenameCompleterToGlibNone(filenameCompleter)))

	carg0 = (*C.GFilenameCompleter)(UnsafeFilenameCompleterToGlibNone(filenameCompleter))

	C._goglib_gio2_FilenameCompleter_virtual_got_completion_data(unsafe.Pointer(parentclass.got_completion_data), carg0)
	runtime.KeepAlive(filenameCompleter)
}

// RegisterFilenameCompleterSubClass is used to register a go subclass of GFilenameCompleter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilenameCompleterSubClass[InstanceT FilenameCompleter](
		name string,
		classInit func(class *FilenameCompleterClass),
		constructor func() InstanceT,
		overrides FilenameCompleterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilenameCompleter,
		UnsafeFilenameCompleterClassFromGlibBorrow,
		UnsafeApplyFilenameCompleterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilenameCompleter(obj)
		},
		interfaceInits...,
	)
}

// IOStreamInstance is the instance type used by all types extending GIOStream. It is used internally by the bindings. Users should use the interface [IOStream] instead.
type IOStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ IOStream = (*IOStreamInstance)(nil)

// IOStream wraps GIOStream
//
// `GIOStream` represents an object that has both read and write streams.
// Generally the two streams act as separate input and output streams,
// but they share some common resources and state. For instance, for
// seekable streams, both streams may use the same position.
// 
// Examples of `GIOStream` objects are [class@Gio.SocketConnection], which represents
// a two-way network connection; and [class@Gio.FileIOStream], which represents a
// file handle opened in read-write mode.
// 
// To do the actual reading and writing you need to get the substreams
// with [method@Gio.IOStream.get_input_stream] and
// [method@Gio.IOStream.get_output_stream].
// 
// The `GIOStream` object owns the input and the output streams, not the other
// way around, so keeping the substreams alive will not keep the `GIOStream`
// object alive. If the `GIOStream` object is freed it will be closed, thus
// closing the substreams, so even if the substreams stay alive they will
// always return `G_IO_ERROR_CLOSED` for all operations.
// 
// To close a stream use [method@Gio.IOStream.close] which will close the common
// stream object and also the individual substreams. You can also close
// the substreams themselves. In most cases this only marks the
// substream as closed, so further I/O on it fails but common state in the
// `GIOStream` may still be open. However, some streams may support
// &#x2018;half-closed&#x2019; states where one direction of the stream is actually shut down.
// 
// Operations on `GIOStream`s cannot be started while another operation on the
// `GIOStream` or its substreams is in progress. Specifically, an application can
// read from the [class@Gio.InputStream] and write to the
// [class@Gio.OutputStream] simultaneously (either in separate threads, or as
// asynchronous operations in the same thread), but an application cannot start
// any `GIOStream` operation while there is a `GIOStream`, `GInputStream` or
// `GOutputStream` operation in progress, and an application can&#x2019;t start any
// `GInputStream` or `GOutputStream` operation while there is a `GIOStream`
// operation in progress.
// 
// This is a product of individual stream operations being associated with a
// given [type@GLib.MainContext] (the thread-default context at the time the
// operation was started), rather than entire streams being associated with a
// single `GMainContext`.
// 
// GIO may run operations on `GIOStream`s from other (worker) threads, and this
// may be exposed to application code in the behaviour of wrapper streams, such
// as [class@Gio.BufferedInputStream] or [class@Gio.TlsConnection]. With such
// wrapper APIs, application code may only run operations on the base (wrapped)
// stream when the wrapper stream is idle. Note that the semantics of such
// operations may not be well-defined due to the state the wrapper stream leaves
// the base stream in (though they are guaranteed not to crash).
type IOStream interface {
	gobject.Object
	upcastToGIOStream() *IOStreamInstance

	// ClearPending wraps g_io_stream_clear_pending
	//
	// Clears the pending flag on @stream.
	ClearPending()
	// Close wraps g_io_stream_close
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes the stream, releasing resources related to it. This will also
	// close the individual input and output streams, if they are not already
	// closed.
	// 
	// Once the stream is closed, all other operations will return
	// %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
	// return an error.
	// 
	// Closing a stream will automatically flush any outstanding buffers
	// in the stream.
	// 
	// Streams will be automatically closed when the last reference
	// is dropped, but you might want to call this function to make sure
	// resources are released as early as possible.
	// 
	// Some streams might keep the backing store of the stream (e.g. a file
	// descriptor) open after the stream is closed. See the documentation for
	// the individual stream for details.
	// 
	// On failure the first error that happened will be reported, but the
	// close operation will finish as much as possible. A stream that failed
	// to close will still return %G_IO_ERROR_CLOSED for all operations.
	// Still, it is important to check and report the error to the user,
	// otherwise there might be a loss of data as all data might not be written.
	// 
	// If @cancellable is not NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	// 
	// The default implementation of this method just calls close on the
	// individual input/output streams.
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_io_stream_close_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the io priority of the request 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Requests an asynchronous close of the stream, releasing resources
	// related to it. When the operation is finished @callback will be
	// called. You can then call g_io_stream_close_finish() to get
	// the result of the operation.
	// 
	// For behaviour details see g_io_stream_close().
	// 
	// The asynchronous methods have a default fallback that uses threads
	// to implement asynchronicity, so they are optional for inheriting
	// classes. However, if you override one you must override all.
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_io_stream_close_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes a stream.
	CloseFinish(AsyncResult) (bool, error)
	// GetInputStream wraps g_io_stream_get_input_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream 
	//
	// Gets the input stream for this object. This is used
	// for reading.
	GetInputStream() InputStream
	// GetOutputStream wraps g_io_stream_get_output_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret OutputStream 
	//
	// Gets the output stream for this object. This is used for
	// writing.
	GetOutputStream() OutputStream
	// HasPending wraps g_io_stream_has_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a stream has pending actions.
	HasPending() bool
	// IsClosed wraps g_io_stream_is_closed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a stream is closed.
	IsClosed() bool
	// SetPending wraps g_io_stream_set_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return %FALSE and set
	// @error.
	SetPending() (bool, error)
	// SpliceAsync wraps g_io_stream_splice_async
	// 
	// The function takes the following parameters:
	// 
	// 	- stream2 IOStream: a #GIOStream. 
	// 	- flags IOStreamSpliceFlags: a set of #GIOStreamSpliceFlags. 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously splice the output stream of @stream1 to the input stream of
	// @stream2, and splice the output stream of @stream2 to the input stream of
	// @stream1.
	// 
	// When the operation is finished @callback will be called.
	// You can then call g_io_stream_splice_finish() to get the
	// result of the operation.
	SpliceAsync(IOStream, IOStreamSpliceFlags, int32, Cancellable, AsyncReadyCallback)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GIOStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes a stream.
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GIOStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentGetInputStream calls the default implementations of the `GIOStream.get_input_stream` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream 
	//
	// Gets the input stream for this object. This is used
	// for reading.
	ParentGetInputStream() InputStream
	// ParentGetOutputStream calls the default implementations of the `GIOStream.get_output_stream` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret OutputStream 
	//
	// Gets the output stream for this object. This is used for
	// writing.
	ParentGetOutputStream() OutputStream
}

func unsafeWrapIOStream(base *gobject.ObjectInstance) *IOStreamInstance {
	return &IOStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapIOStream(inst)
		},
	)
}

func marshalIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeIOStreamFromGlibNone is used to convert raw GIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeIOStreamFromGlibNone(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(IOStream)
}

// UnsafeIOStreamFromGlibFull is used to convert raw GIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeIOStreamFromGlibFull(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(IOStream)
}

// UnsafeIOStreamFromGlibBorrow is used to convert raw GIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeIOStreamFromGlibBorrow(c unsafe.Pointer) IOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(IOStream)
}

func (i *IOStreamInstance) upcastToGIOStream() *IOStreamInstance {
	return i
}

// UnsafeIOStreamToGlibNone is used to convert the instance to it's C value GIOStream. This is used by the bindings internally.
func UnsafeIOStreamToGlibNone(c IOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeIOStreamToGlibFull is used to convert the instance to it's C value GIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeIOStreamToGlibFull(c IOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// IOStreamSpliceFinish wraps g_io_stream_splice_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous io stream splice operation.
func IOStreamSpliceFinish(result AsyncResult) (bool, error) {
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_io_stream_splice_finish(carg1, &_cerr)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ClearPending wraps g_io_stream_clear_pending
//
// Clears the pending flag on @stream.
func (stream *IOStreamInstance) ClearPending() {
	var carg0 *C.GIOStream // in, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	C.g_io_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_io_stream_close
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes the stream, releasing resources related to it. This will also
// close the individual input and output streams, if they are not already
// closed.
// 
// Once the stream is closed, all other operations will return
// %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
// return an error.
// 
// Closing a stream will automatically flush any outstanding buffers
// in the stream.
// 
// Streams will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file
// descriptor) open after the stream is closed. See the documentation for
// the individual stream for details.
// 
// On failure the first error that happened will be reported, but the
// close operation will finish as much as possible. A stream that failed
// to close will still return %G_IO_ERROR_CLOSED for all operations.
// Still, it is important to check and report the error to the user,
// otherwise there might be a loss of data as all data might not be written.
// 
// If @cancellable is not NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
// 
// The default implementation of this method just calls close on the
// individual input/output streams.
func (stream *IOStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GIOStream    // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_io_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_io_stream_close_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the io priority of the request 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished @callback will be
// called. You can then call g_io_stream_close_finish() to get
// the result of the operation.
// 
// For behaviour details see g_io_stream_close().
// 
// The asynchronous methods have a default fallback that uses threads
// to implement asynchronicity, so they are optional for inheriting
// classes. However, if you override one you must override all.
func (stream *IOStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GIOStream          // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_io_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_io_stream_close_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes a stream.
func (stream *IOStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GIOStream    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_io_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetInputStream wraps g_io_stream_get_input_stream
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Gets the input stream for this object. This is used
// for reading.
func (stream *IOStreamInstance) GetInputStream() InputStream {
	var carg0 *C.GIOStream    // in, none, converted
	var cret  *C.GInputStream // return, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_get_input_stream(carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetOutputStream wraps g_io_stream_get_output_stream
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Gets the output stream for this object. This is used for
// writing.
func (stream *IOStreamInstance) GetOutputStream() OutputStream {
	var carg0 *C.GIOStream     // in, none, converted
	var cret  *C.GOutputStream // return, none, converted

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_get_output_stream(carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// HasPending wraps g_io_stream_has_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a stream has pending actions.
func (stream *IOStreamInstance) HasPending() bool {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_io_stream_is_closed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a stream is closed.
func (stream *IOStreamInstance) IsClosed() bool {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetPending wraps g_io_stream_set_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return %FALSE and set
// @error.
func (stream *IOStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GIOStream // in, none, converted
	var cret  C.gboolean   // return
	var _cerr *C.GError    // out, full, converted, nullable

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C.g_io_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpliceAsync wraps g_io_stream_splice_async
// 
// The function takes the following parameters:
// 
// 	- stream2 IOStream: a #GIOStream. 
// 	- flags IOStreamSpliceFlags: a set of #GIOStreamSpliceFlags. 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously splice the output stream of @stream1 to the input stream of
// @stream2, and splice the output stream of @stream2 to the input stream of
// @stream1.
// 
// When the operation is finished @callback will be called.
// You can then call g_io_stream_splice_finish() to get the
// result of the operation.
func (stream1 *IOStreamInstance) SpliceAsync(stream2 IOStream, flags IOStreamSpliceFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GIOStream           // in, none, converted
	var carg1 *C.GIOStream           // in, none, converted
	var carg2 C.GIOStreamSpliceFlags // in, none, casted
	var carg3 C.int                  // in, none, casted
	var carg4 *C.GCancellable        // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback  // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer             // implicit

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream1))
	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream2))
	carg2 = C.GIOStreamSpliceFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_io_stream_splice_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream1)
	runtime.KeepAlive(stream2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// IOStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type IOStreamOverrides[Instance IOStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes a stream.
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	CloseFn func(Instance, Cancellable) (bool, error)
	// // GetInputStream allows you to override the implementation of the virtual method get_input_stream.
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream 
	//
	// Gets the input stream for this object. This is used
	// for reading.
	GetInputStream func(Instance) InputStream
	// // GetOutputStream allows you to override the implementation of the virtual method get_output_stream.
	// 
	// The function returns the following values:
	// 
	// 	- goret OutputStream 
	//
	// Gets the output stream for this object. This is used for
	// writing.
	GetOutputStream func(Instance) OutputStream
}

// UnsafeApplyIOStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyIOStreamOverrides[Instance IOStream](gclass unsafe.Pointer, overrides IOStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GIOStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_IOStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_close_finish",
			func(carg0 *C.GIOStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GIOStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_IOStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_close_fn",
			func(carg0 *C.GIOStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GIOStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.GetInputStream != nil {
		pclass.get_input_stream = (*[0]byte)(C._goglib_gio2_IOStream_get_input_stream)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_get_input_stream",
			func(carg0 *C.GIOStream) (cret *C.GInputStream) {
				var stream Instance    // go GIOStream subclass
				var goret  InputStream // return, none, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetInputStream(stream)

				cret = (*C.GInputStream)(UnsafeInputStreamToGlibNone(goret))

				return cret
			},
		)
	}

	if overrides.GetOutputStream != nil {
		pclass.get_output_stream = (*[0]byte)(C._goglib_gio2_IOStream_get_output_stream)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_IOStream_get_output_stream",
			func(carg0 *C.GIOStream) (cret *C.GOutputStream) {
				var stream Instance     // go GIOStream subclass
				var goret  OutputStream // return, none, converted

				stream = UnsafeIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetOutputStream(stream)

				cret = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(goret))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GIOStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes a stream.
func (stream *IOStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GIOStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_IOStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GIOStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *IOStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GIOStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_IOStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentGetInputStream calls the default implementations of the `GIOStream.get_input_stream` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Gets the input stream for this object. This is used
// for reading.
func (stream *IOStreamInstance) ParentGetInputStream() InputStream {
	var carg0 *C.GIOStream
	var cret  *C.GInputStream // return, none, converted

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_IOStream_virtual_get_input_stream(unsafe.Pointer(parentclass.get_input_stream), carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ParentGetOutputStream calls the default implementations of the `GIOStream.get_output_stream` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Gets the output stream for this object. This is used for
// writing.
func (stream *IOStreamInstance) ParentGetOutputStream() OutputStream {
	var carg0 *C.GIOStream
	var cret  *C.GOutputStream // return, none, converted

	parentclass := (*C.GIOStreamClass)(classdata.PeekParentClass(UnsafeIOStreamToGlibNone(stream)))

	carg0 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_IOStream_virtual_get_output_stream(unsafe.Pointer(parentclass.get_output_stream), carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// RegisterIOStreamSubClass is used to register a go subclass of GIOStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterIOStreamSubClass[InstanceT IOStream](
		name string,
		classInit func(class *IOStreamClass),
		constructor func() InstanceT,
		overrides IOStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeIOStream,
		UnsafeIOStreamClassFromGlibBorrow,
		UnsafeApplyIOStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapIOStream(obj)
		},
		interfaceInits...,
	)
}

// InetAddressInstance is the instance type used by all types extending GInetAddress. It is used internally by the bindings. Users should use the interface [InetAddress] instead.
type InetAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InetAddress = (*InetAddressInstance)(nil)

// InetAddress wraps GInetAddress
//
// `GInetAddress` represents an IPv4 or IPv6 internet address. Use
// [method@Gio.Resolver.lookup_by_name] or
// [method@Gio.Resolver.lookup_by_name_async] to look up the `GInetAddress` for
// a hostname. Use [method@Gio.Resolver.lookup_by_address] or
// [method@Gio.Resolver.lookup_by_address_async] to look up the hostname for a
// `GInetAddress`.
// 
// To actually connect to a remote host, you will need a
// [class@Gio.InetSocketAddress] (which includes a `GInetAddress` as well as a
// port number).
type InetAddress interface {
	gobject.Object
	upcastToGInetAddress() *InetAddressInstance

	// Equal wraps g_inet_address_equal
	// 
	// The function takes the following parameters:
	// 
	// 	- otherAddress InetAddress: Another #GInetAddress. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if two #GInetAddress instances are equal, e.g. the same address.
	Equal(InetAddress) bool
	// GetFamily wraps g_inet_address_get_family
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets @address's family
	GetFamily() SocketFamily
	// GetIsAny wraps g_inet_address_get_is_any
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is the "any" address for its family.
	GetIsAny() bool
	// GetIsLinkLocal wraps g_inet_address_get_is_link_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a link-local address (that is, if it
	// identifies a host on a local network that is not connected to the
	// Internet).
	GetIsLinkLocal() bool
	// GetIsLoopback wraps g_inet_address_get_is_loopback
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is the loopback address for its family.
	GetIsLoopback() bool
	// GetIsMcGlobal wraps g_inet_address_get_is_mc_global
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a global multicast address.
	GetIsMcGlobal() bool
	// GetIsMcLinkLocal wraps g_inet_address_get_is_mc_link_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a link-local multicast address.
	GetIsMcLinkLocal() bool
	// GetIsMcNodeLocal wraps g_inet_address_get_is_mc_node_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a node-local multicast address.
	GetIsMcNodeLocal() bool
	// GetIsMcOrgLocal wraps g_inet_address_get_is_mc_org_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is an organization-local multicast address.
	GetIsMcOrgLocal() bool
	// GetIsMcSiteLocal wraps g_inet_address_get_is_mc_site_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a site-local multicast address.
	GetIsMcSiteLocal() bool
	// GetIsMulticast wraps g_inet_address_get_is_multicast
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a multicast address.
	GetIsMulticast() bool
	// GetIsSiteLocal wraps g_inet_address_get_is_site_local
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether @address is a site-local address such as 10.0.0.1
	// (that is, the address identifies a host on a local network that can
	// not be reached directly from the Internet, but which may have
	// outgoing Internet connectivity via a NAT or firewall).
	GetIsSiteLocal() bool
	// GetNativeSize wraps g_inet_address_get_native_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the size of the native raw binary address for @address. This
	// is the size of the data that you get from g_inet_address_to_bytes().
	GetNativeSize() uint
	// String wraps g_inet_address_to_string
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Converts @address to string form.
	String() string

	// chain up virtual methods:

	// ParentToString calls the default implementations of the `GInetAddress.to_string` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Converts @address to string form.
	ParentToString() string
}

func unsafeWrapInetAddress(base *gobject.ObjectInstance) *InetAddressInstance {
	return &InetAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddress(inst)
		},
	)
}

func marshalInetAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetAddressFromGlibNone is used to convert raw GInetAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressFromGlibNone(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(InetAddress)
}

// UnsafeInetAddressFromGlibFull is used to convert raw GInetAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressFromGlibFull(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(InetAddress)
}

// UnsafeInetAddressFromGlibBorrow is used to convert raw GInetAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetAddressFromGlibBorrow(c unsafe.Pointer) InetAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetAddress)
}

func (i *InetAddressInstance) upcastToGInetAddress() *InetAddressInstance {
	return i
}

// UnsafeInetAddressToGlibNone is used to convert the instance to it's C value GInetAddress. This is used by the bindings internally.
func UnsafeInetAddressToGlibNone(c InetAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetAddressToGlibFull is used to convert the instance to it's C value GInetAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetAddressToGlibFull(c InetAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetAddressAny wraps g_inet_address_new_any
// 
// The function takes the following parameters:
// 
// 	- family SocketFamily: the address family 
// 
// The function returns the following values:
// 
// 	- goret InetAddress 
//
// Creates a #GInetAddress for the "any" address (unassigned/"don't
// care") for @family.
func NewInetAddressAny(family SocketFamily) InetAddress {
	var carg1 C.GSocketFamily // in, none, casted
	var cret  *C.GInetAddress // return, full, converted

	carg1 = C.GSocketFamily(family)

	cret = C.g_inet_address_new_any(carg1)
	runtime.KeepAlive(family)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewInetAddressFromString wraps g_inet_address_new_from_string
// 
// The function takes the following parameters:
// 
// 	- str string: a string representation of an IP address 
// 
// The function returns the following values:
// 
// 	- goret InetAddress (nullable) 
//
// Parses @string as an IP address and creates a new #GInetAddress.
func NewInetAddressFromString(str string) InetAddress {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GInetAddress // return, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_inet_address_new_from_string(carg1)
	runtime.KeepAlive(str)

	var goret InetAddress

	if cret != nil {
		goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// NewInetAddressLoopback wraps g_inet_address_new_loopback
// 
// The function takes the following parameters:
// 
// 	- family SocketFamily: the address family 
// 
// The function returns the following values:
// 
// 	- goret InetAddress 
//
// Creates a #GInetAddress for the loopback address for @family.
func NewInetAddressLoopback(family SocketFamily) InetAddress {
	var carg1 C.GSocketFamily // in, none, casted
	var cret  *C.GInetAddress // return, full, converted

	carg1 = C.GSocketFamily(family)

	cret = C.g_inet_address_new_loopback(carg1)
	runtime.KeepAlive(family)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_inet_address_equal
// 
// The function takes the following parameters:
// 
// 	- otherAddress InetAddress: Another #GInetAddress. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if two #GInetAddress instances are equal, e.g. the same address.
func (address *InetAddressInstance) Equal(otherAddress InetAddress) bool {
	var carg0 *C.GInetAddress // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(otherAddress))

	cret = C.g_inet_address_equal(carg0, carg1)
	runtime.KeepAlive(address)
	runtime.KeepAlive(otherAddress)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetFamily wraps g_inet_address_get_family
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets @address's family
func (address *InetAddressInstance) GetFamily() SocketFamily {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.GSocketFamily // return, none, casted

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_family(carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetIsAny wraps g_inet_address_get_is_any
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is the "any" address for its family.
func (address *InetAddressInstance) GetIsAny() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_any(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsLinkLocal wraps g_inet_address_get_is_link_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a link-local address (that is, if it
// identifies a host on a local network that is not connected to the
// Internet).
func (address *InetAddressInstance) GetIsLinkLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_link_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsLoopback wraps g_inet_address_get_is_loopback
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is the loopback address for its family.
func (address *InetAddressInstance) GetIsLoopback() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_loopback(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcGlobal wraps g_inet_address_get_is_mc_global
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a global multicast address.
func (address *InetAddressInstance) GetIsMcGlobal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_global(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcLinkLocal wraps g_inet_address_get_is_mc_link_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a link-local multicast address.
func (address *InetAddressInstance) GetIsMcLinkLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_link_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcNodeLocal wraps g_inet_address_get_is_mc_node_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a node-local multicast address.
func (address *InetAddressInstance) GetIsMcNodeLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_node_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcOrgLocal wraps g_inet_address_get_is_mc_org_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is an organization-local multicast address.
func (address *InetAddressInstance) GetIsMcOrgLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_org_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMcSiteLocal wraps g_inet_address_get_is_mc_site_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a site-local multicast address.
func (address *InetAddressInstance) GetIsMcSiteLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_mc_site_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsMulticast wraps g_inet_address_get_is_multicast
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a multicast address.
func (address *InetAddressInstance) GetIsMulticast() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_multicast(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsSiteLocal wraps g_inet_address_get_is_site_local
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether @address is a site-local address such as 10.0.0.1
// (that is, the address identifies a host on a local network that can
// not be reached directly from the Internet, but which may have
// outgoing Internet connectivity via a NAT or firewall).
func (address *InetAddressInstance) GetIsSiteLocal() bool {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_is_site_local(carg0)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNativeSize wraps g_inet_address_get_native_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the size of the native raw binary address for @address. This
// is the size of the data that you get from g_inet_address_to_bytes().
func (address *InetAddressInstance) GetNativeSize() uint {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_get_native_size(carg0)
	runtime.KeepAlive(address)

	var goret uint

	goret = uint(cret)

	return goret
}

// String wraps g_inet_address_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts @address to string form.
func (address *InetAddressInstance) String() string {
	var carg0 *C.GInetAddress // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_to_string(carg0)
	runtime.KeepAlive(address)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InetAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetAddressOverrides[Instance InetAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // ToString allows you to override the implementation of the virtual method to_string.
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Converts @address to string form.
	ToString func(Instance) string
}

// UnsafeApplyInetAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetAddressOverrides[Instance InetAddress](gclass unsafe.Pointer, overrides InetAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GInetAddressClass)(gclass)

	if overrides.ToString != nil {
		pclass.to_string = (*[0]byte)(C._goglib_gio2_InetAddress_to_string)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InetAddress_to_string",
			func(carg0 *C.GInetAddress) (cret *C.gchar) {
				var address Instance // go GInetAddress subclass
				var goret   string   // return, full, string

				address = UnsafeInetAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.ToString(address)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))

				return cret
			},
		)
	}
}

// ParentToString calls the default implementations of the `GInetAddress.to_string` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts @address to string form.
func (address *InetAddressInstance) ParentToString() string {
	var carg0 *C.GInetAddress
	var cret  *C.gchar // return, full, string

	parentclass := (*C.GInetAddressClass)(classdata.PeekParentClass(UnsafeInetAddressToGlibNone(address)))

	carg0 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C._goglib_gio2_InetAddress_virtual_to_string(unsafe.Pointer(parentclass.to_string), carg0)
	runtime.KeepAlive(address)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegisterInetAddressSubClass is used to register a go subclass of GInetAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetAddressSubClass[InstanceT InetAddress](
		name string,
		classInit func(class *InetAddressClass),
		constructor func() InstanceT,
		overrides InetAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetAddress,
		UnsafeInetAddressClassFromGlibBorrow,
		UnsafeApplyInetAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddress(obj)
		},
		interfaceInits...,
	)
}

// InetAddressMaskInstance is the instance type used by all types extending GInetAddressMask. It is used internally by the bindings. Users should use the interface [InetAddressMask] instead.
type InetAddressMaskInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InetAddressMask = (*InetAddressMaskInstance)(nil)

// InetAddressMask wraps GInetAddressMask
//
// `GInetAddressMask` represents a range of IPv4 or IPv6 addresses
// described by a base address and a length indicating how many bits
// of the base address are relevant for matching purposes. These are
// often given in string form. For example, `10.0.0.0/8`, or `fe80::/10`.
type InetAddressMask interface {
	gobject.Object
	upcastToGInetAddressMask() *InetAddressMaskInstance

	// Equal wraps g_inet_address_mask_equal
	// 
	// The function takes the following parameters:
	// 
	// 	- mask2 InetAddressMask: another #GInetAddressMask 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests if @mask and @mask2 are the same mask.
	Equal(InetAddressMask) bool
	// GetAddress wraps g_inet_address_mask_get_address
	// 
	// The function returns the following values:
	// 
	// 	- goret InetAddress 
	//
	// Gets @mask's base address
	GetAddress() InetAddress
	// GetFamily wraps g_inet_address_mask_get_family
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the #GSocketFamily of @mask's address
	GetFamily() SocketFamily
	// GetLength wraps g_inet_address_mask_get_length
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets @mask's length
	GetLength() uint
	// Matches wraps g_inet_address_mask_matches
	// 
	// The function takes the following parameters:
	// 
	// 	- address InetAddress: a #GInetAddress 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests if @address falls within the range described by @mask.
	Matches(InetAddress) bool
	// String wraps g_inet_address_mask_to_string
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Converts @mask back to its corresponding string form.
	String() string

	// chain up virtual methods:
}

func unsafeWrapInetAddressMask(base *gobject.ObjectInstance) *InetAddressMaskInstance {
	return &InetAddressMaskInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetAddressMask,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddressMask(inst)
		},
	)
}

func marshalInetAddressMaskInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetAddressMaskFromGlibNone is used to convert raw GInetAddressMask pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibNone(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibNone(c).(InetAddressMask)
}

// UnsafeInetAddressMaskFromGlibFull is used to convert raw GInetAddressMask pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibFull(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibFull(c).(InetAddressMask)
}

// UnsafeInetAddressMaskFromGlibBorrow is used to convert raw GInetAddressMask pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetAddressMaskFromGlibBorrow(c unsafe.Pointer) InetAddressMask {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetAddressMask)
}

func (i *InetAddressMaskInstance) upcastToGInetAddressMask() *InetAddressMaskInstance {
	return i
}

// UnsafeInetAddressMaskToGlibNone is used to convert the instance to it's C value GInetAddressMask. This is used by the bindings internally.
func UnsafeInetAddressMaskToGlibNone(c InetAddressMask) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetAddressMaskToGlibFull is used to convert the instance to it's C value GInetAddressMask, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetAddressMaskToGlibFull(c InetAddressMask) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetAddressMask wraps g_inet_address_mask_new
// 
// The function takes the following parameters:
// 
// 	- addr InetAddress: a #GInetAddress 
// 	- length uint: number of bits of @addr to use 
// 
// The function returns the following values:
// 
// 	- goret InetAddressMask 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GInetAddressMask representing all addresses whose
// first @length bits match @addr.
func NewInetAddressMask(addr InetAddress, length uint) (InetAddressMask, error) {
	var carg1 *C.GInetAddress     // in, none, converted
	var carg2 C.guint             // in, none, casted
	var cret  *C.GInetAddressMask // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(addr))
	carg2 = C.guint(length)

	cret = C.g_inet_address_mask_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(addr)
	runtime.KeepAlive(length)

	var goret  InetAddressMask
	var _goerr error

	goret = UnsafeInetAddressMaskFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewInetAddressMaskFromString wraps g_inet_address_mask_new_from_string
// 
// The function takes the following parameters:
// 
// 	- maskString string: an IP address or address/length string 
// 
// The function returns the following values:
// 
// 	- goret InetAddressMask 
// 	- _goerr error (nullable): an error 
//
// Parses @mask_string as an IP address and (optional) length, and
// creates a new #GInetAddressMask. The length, if present, is
// delimited by a "/". If it is not present, then the length is
// assumed to be the full length of the address.
func NewInetAddressMaskFromString(maskString string) (InetAddressMask, error) {
	var carg1 *C.gchar            // in, none, string
	var cret  *C.GInetAddressMask // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(maskString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_inet_address_mask_new_from_string(carg1, &_cerr)
	runtime.KeepAlive(maskString)

	var goret  InetAddressMask
	var _goerr error

	goret = UnsafeInetAddressMaskFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Equal wraps g_inet_address_mask_equal
// 
// The function takes the following parameters:
// 
// 	- mask2 InetAddressMask: another #GInetAddressMask 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @mask and @mask2 are the same mask.
func (mask *InetAddressMaskInstance) Equal(mask2 InetAddressMask) bool {
	var carg0 *C.GInetAddressMask // in, none, converted
	var carg1 *C.GInetAddressMask // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))
	carg1 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask2))

	cret = C.g_inet_address_mask_equal(carg0, carg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(mask2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetAddress wraps g_inet_address_mask_get_address
// 
// The function returns the following values:
// 
// 	- goret InetAddress 
//
// Gets @mask's base address
func (mask *InetAddressMaskInstance) GetAddress() InetAddress {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  *C.GInetAddress     // return, none, converted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_address(carg0)
	runtime.KeepAlive(mask)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFamily wraps g_inet_address_mask_get_family
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets the #GSocketFamily of @mask's address
func (mask *InetAddressMaskInstance) GetFamily() SocketFamily {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  C.GSocketFamily     // return, none, casted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_family(carg0)
	runtime.KeepAlive(mask)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetLength wraps g_inet_address_mask_get_length
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets @mask's length
func (mask *InetAddressMaskInstance) GetLength() uint {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  C.guint             // return, none, casted

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_get_length(carg0)
	runtime.KeepAlive(mask)

	var goret uint

	goret = uint(cret)

	return goret
}

// Matches wraps g_inet_address_mask_matches
// 
// The function takes the following parameters:
// 
// 	- address InetAddress: a #GInetAddress 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @address falls within the range described by @mask.
func (mask *InetAddressMaskInstance) Matches(address InetAddress) bool {
	var carg0 *C.GInetAddressMask // in, none, converted
	var carg1 *C.GInetAddress     // in, none, converted
	var cret  C.gboolean          // return

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))

	cret = C.g_inet_address_mask_matches(carg0, carg1)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(address)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// String wraps g_inet_address_mask_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts @mask back to its corresponding string form.
func (mask *InetAddressMaskInstance) String() string {
	var carg0 *C.GInetAddressMask // in, none, converted
	var cret  *C.gchar            // return, full, string

	carg0 = (*C.GInetAddressMask)(UnsafeInetAddressMaskToGlibNone(mask))

	cret = C.g_inet_address_mask_to_string(carg0)
	runtime.KeepAlive(mask)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InetAddressMaskOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetAddressMaskOverrides[Instance InetAddressMask] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyInetAddressMaskOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetAddressMaskOverrides[Instance InetAddressMask](gclass unsafe.Pointer, overrides InetAddressMaskOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterInetAddressMaskSubClass is used to register a go subclass of GInetAddressMask. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetAddressMaskSubClass[InstanceT InetAddressMask](
		name string,
		classInit func(class *InetAddressMaskClass),
		constructor func() InstanceT,
		overrides InetAddressMaskOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetAddressMask,
		UnsafeInetAddressMaskClassFromGlibBorrow,
		UnsafeApplyInetAddressMaskOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetAddressMask(obj)
		},
		interfaceInits...,
	)
}

// InputStreamInstance is the instance type used by all types extending GInputStream. It is used internally by the bindings. Users should use the interface [InputStream] instead.
type InputStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ InputStream = (*InputStreamInstance)(nil)

// InputStream wraps GInputStream
//
// `GInputStream` is a base class for implementing streaming input.
// 
// It has functions to read from a stream ([method@Gio.InputStream.read]),
// to close a stream ([method@Gio.InputStream.close]) and to skip some content
// ([method@Gio.InputStream.skip]).
// 
// To copy the content of an input stream to an output stream without
// manually handling the reads and writes, use [method@Gio.OutputStream.splice].
// 
// See the documentation for [class@Gio.IOStream] for details of thread safety
// of streaming APIs.
// 
// All of these functions have async variants too.
type InputStream interface {
	gobject.Object
	upcastToGInputStream() *InputStreamInstance

	// ClearPending wraps g_input_stream_clear_pending
	//
	// Clears the pending flag on @stream.
	ClearPending()
	// Close wraps g_input_stream_close
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes the stream, releasing resources related to it.
	// 
	// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
	// Closing a stream multiple times will not return an error.
	// 
	// Streams will be automatically closed when the last reference
	// is dropped, but you might want to call this function to make sure
	// resources are released as early as possible.
	// 
	// Some streams might keep the backing store of the stream (e.g. a file descriptor)
	// open after the stream is closed. See the documentation for the individual
	// stream for details.
	// 
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to
	// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
	// is important to check and report the error to the user.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but some streams
	// can use a faster close that doesn't block to e.g. check errors.
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_input_stream_close_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Requests an asynchronous closes of the stream, releasing resources related to it.
	// When the operation is finished @callback will be called.
	// You can then call g_input_stream_close_finish() to get the result of the
	// operation.
	// 
	// For behaviour details see g_input_stream_close().
	// 
	// The asynchronous methods have a default fallback that uses threads to implement
	// asynchronicity, so they are optional for inheriting classes. However, if you
	// override one you must override all.
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_input_stream_close_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
	CloseFinish(AsyncResult) (bool, error)
	// HasPending wraps g_input_stream_has_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if an input stream has pending actions.
	HasPending() bool
	// IsClosed wraps g_input_stream_is_closed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if an input stream is closed.
	IsClosed() bool
	// ReadAllFinish wraps g_input_stream_read_all_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- bytesRead uint: location to store the number of bytes that was read from the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream read operation started with
	// [method@InputStream.read_all_async].
	// 
	// As a special exception to the normal conventions for functions that
	// use #GError, if this function returns %FALSE (and sets @error) then
	// @bytes_read will be set to the number of bytes that were successfully
	// read before the error was encountered.  This functionality is only
	// available from C.  If you need it from another language then you must
	// write your own loop around g_input_stream_read_async().
	ReadAllFinish(AsyncResult) (uint, bool, error)
	// ReadBytes wraps g_input_stream_read_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: maximum number of bytes that will be read from the stream. Common
	// values include 4096 and 8192. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Like g_input_stream_read(), this tries to read @count bytes from
	// the stream in a blocking fashion. However, rather than reading into
	// a user-supplied buffer, this will create a new #GBytes containing
	// the data that was read. This may be easier to use from language
	// bindings.
	// 
	// If count is zero, returns a zero-length #GBytes and does nothing. A
	// value of @count larger than %G_MAXSSIZE will cause a
	// %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, a new #GBytes is returned. It is not an error if the
	// size of this object is not the same as the requested size, as it
	// can happen e.g. near the end of a file. A zero-length #GBytes is
	// returned on end of file (or if @count is zero), but never
	// otherwise.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error %NULL is returned and @error is set accordingly.
	ReadBytes(uint, Cancellable) (*glib.Bytes, error)
	// ReadBytesAsync wraps g_input_stream_read_bytes_async
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: the number of bytes that will be read from the stream 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Request an asynchronous read of @count bytes from the stream into a
	// new #GBytes. When the operation is finished @callback will be
	// called. You can then call g_input_stream_read_bytes_finish() to get the
	// result of the operation.
	// 
	// During an async request no other sync and async calls are allowed
	// on @stream, and will result in %G_IO_ERROR_PENDING errors.
	// 
	// A value of @count larger than %G_MAXSSIZE will cause a
	// %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the new #GBytes will be passed to the callback. It is
	// not an error if this is smaller than the requested size, as it can
	// happen e.g. near the end of a file, but generally we try to read as
	// many bytes as requested. Zero is returned on end of file (or if
	// @count is zero), but never otherwise.
	// 
	// Any outstanding I/O request with higher priority (lower numerical
	// value) will be executed before an outstanding request with lower
	// priority. Default priority is %G_PRIORITY_DEFAULT.
	ReadBytesAsync(uint, int32, Cancellable, AsyncReadyCallback)
	// ReadBytesFinish wraps g_input_stream_read_bytes_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream read-into-#GBytes operation.
	ReadBytesFinish(AsyncResult) (*glib.Bytes, error)
	// ReadFinish wraps g_input_stream_read_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream read operation.
	ReadFinish(AsyncResult) (int, error)
	// SetPending wraps g_input_stream_set_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return %FALSE and set
	// @error.
	SetPending() (bool, error)
	// Skip wraps g_input_stream_skip
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: the number of bytes that will be skipped from the stream 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to skip @count bytes from the stream. Will block during the operation.
	// 
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some
	// streams have an implementation that is more efficient than reading the data.
	// 
	// This function is optional for inherited classes, as the default implementation
	// emulates it using read.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Skip(uint, Cancellable) (int, error)
	// SkipAsync wraps g_input_stream_skip_async
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: the number of bytes that will be skipped from the stream 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Request an asynchronous skip of @count bytes from the stream.
	// When the operation is finished @callback will be called.
	// You can then call g_input_stream_skip_finish() to get the result
	// of the operation.
	// 
	// During an async request no other sync and async calls are allowed,
	// and will result in %G_IO_ERROR_PENDING errors.
	// 
	// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the number of bytes skipped will be passed to the callback.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file, but generally we try to skip
	// as many bytes as requested. Zero is returned on end of file
	// (or if @count is zero), but never otherwise.
	// 
	// Any outstanding i/o request with higher priority (lower numerical value)
	// will be executed before an outstanding request with lower priority.
	// Default priority is %G_PRIORITY_DEFAULT.
	// 
	// The asynchronous methods have a default fallback that uses threads to
	// implement asynchronicity, so they are optional for inheriting classes.
	// However, if you override one, you must override all.
	SkipAsync(uint, int32, Cancellable, AsyncReadyCallback)
	// SkipFinish wraps g_input_stream_skip_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream skip operation.
	SkipFinish(AsyncResult) (int, error)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GInputStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GInputStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentReadFinish calls the default implementations of the `GInputStream.read_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream read operation.
	ParentReadFinish(result AsyncResult) (int, error)
	// ParentSkip calls the default implementations of the `GInputStream.skip` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: the number of bytes that will be skipped from the stream 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to skip @count bytes from the stream. Will block during the operation.
	// 
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some
	// streams have an implementation that is more efficient than reading the data.
	// 
	// This function is optional for inherited classes, as the default implementation
	// emulates it using read.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	ParentSkip(count uint, cancellable Cancellable) (int, error)
	// ParentSkipFinish calls the default implementations of the `GInputStream.skip_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream skip operation.
	ParentSkipFinish(result AsyncResult) (int, error)
}

func unsafeWrapInputStream(base *gobject.ObjectInstance) *InputStreamInstance {
	return &InputStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInputStream(inst)
		},
	)
}

func marshalInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInputStreamFromGlibNone is used to convert raw GInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInputStreamFromGlibNone(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(InputStream)
}

// UnsafeInputStreamFromGlibFull is used to convert raw GInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInputStreamFromGlibFull(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(InputStream)
}

// UnsafeInputStreamFromGlibBorrow is used to convert raw GInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInputStreamFromGlibBorrow(c unsafe.Pointer) InputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InputStream)
}

func (i *InputStreamInstance) upcastToGInputStream() *InputStreamInstance {
	return i
}

// UnsafeInputStreamToGlibNone is used to convert the instance to it's C value GInputStream. This is used by the bindings internally.
func UnsafeInputStreamToGlibNone(c InputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInputStreamToGlibFull is used to convert the instance to it's C value GInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInputStreamToGlibFull(c InputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ClearPending wraps g_input_stream_clear_pending
//
// Clears the pending flag on @stream.
func (stream *InputStreamInstance) ClearPending() {
	var carg0 *C.GInputStream // in, none, converted

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	C.g_input_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_input_stream_close
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes the stream, releasing resources related to it.
// 
// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
// Closing a stream multiple times will not return an error.
// 
// Streams will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file descriptor)
// open after the stream is closed. See the documentation for the individual
// stream for details.
// 
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to
// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
// is important to check and report the error to the user.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but some streams
// can use a faster close that doesn't block to e.g. check errors.
func (stream *InputStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_input_stream_close_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Requests an asynchronous closes of the stream, releasing resources related to it.
// When the operation is finished @callback will be called.
// You can then call g_input_stream_close_finish() to get the result of the
// operation.
// 
// For behaviour details see g_input_stream_close().
// 
// The asynchronous methods have a default fallback that uses threads to implement
// asynchronicity, so they are optional for inheriting classes. However, if you
// override one you must override all.
func (stream *InputStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_input_stream_close_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
func (stream *InputStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasPending wraps g_input_stream_has_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an input stream has pending actions.
func (stream *InputStreamInstance) HasPending() bool {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_input_stream_is_closed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an input stream is closed.
func (stream *InputStreamInstance) IsClosed() bool {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReadAllFinish wraps g_input_stream_read_all_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes that was read from the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream read operation started with
// [method@InputStream.read_all_async].
// 
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_read will be set to the number of bytes that were successfully
// read before the error was encountered.  This functionality is only
// available from C.  If you need it from another language then you must
// write your own loop around g_input_stream_read_async().
func (stream *InputStreamInstance) ReadAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.gsize         // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesRead uint
	var goret     bool
	var _goerr    error

	bytesRead = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, goret, _goerr
}

// ReadBytes wraps g_input_stream_read_bytes
// 
// The function takes the following parameters:
// 
// 	- count uint: maximum number of bytes that will be read from the stream. Common
// values include 4096 and 8192. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Like g_input_stream_read(), this tries to read @count bytes from
// the stream in a blocking fashion. However, rather than reading into
// a user-supplied buffer, this will create a new #GBytes containing
// the data that was read. This may be easier to use from language
// bindings.
// 
// If count is zero, returns a zero-length #GBytes and does nothing. A
// value of @count larger than %G_MAXSSIZE will cause a
// %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, a new #GBytes is returned. It is not an error if the
// size of this object is not the same as the requested size, as it
// can happen e.g. near the end of a file. A zero-length #GBytes is
// returned on end of file (or if @count is zero), but never
// otherwise.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error %NULL is returned and @error is set accordingly.
func (stream *InputStreamInstance) ReadBytes(count uint, cancellable Cancellable) (*glib.Bytes, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_read_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadBytesAsync wraps g_input_stream_read_bytes_async
// 
// The function takes the following parameters:
// 
// 	- count uint: the number of bytes that will be read from the stream 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Request an asynchronous read of @count bytes from the stream into a
// new #GBytes. When the operation is finished @callback will be
// called. You can then call g_input_stream_read_bytes_finish() to get the
// result of the operation.
// 
// During an async request no other sync and async calls are allowed
// on @stream, and will result in %G_IO_ERROR_PENDING errors.
// 
// A value of @count larger than %G_MAXSSIZE will cause a
// %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the new #GBytes will be passed to the callback. It is
// not an error if this is smaller than the requested size, as it can
// happen e.g. near the end of a file, but generally we try to read as
// many bytes as requested. Zero is returned on end of file (or if
// @count is zero), but never otherwise.
// 
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
func (stream *InputStreamInstance) ReadBytesAsync(count uint, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.gsize               // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_read_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadBytesFinish wraps g_input_stream_read_bytes_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream read-into-#GBytes operation.
func (stream *InputStreamInstance) ReadBytesFinish(result AsyncResult) (*glib.Bytes, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_bytes_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadFinish wraps g_input_stream_read_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream read operation.
func (stream *InputStreamInstance) ReadFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_read_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetPending wraps g_input_stream_set_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return %FALSE and set
// @error.
func (stream *InputStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GInputStream // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))

	cret = C.g_input_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Skip wraps g_input_stream_skip
// 
// The function takes the following parameters:
// 
// 	- count uint: the number of bytes that will be skipped from the stream 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to skip @count bytes from the stream. Will block during the operation.
// 
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some
// streams have an implementation that is more efficient than reading the data.
// 
// This function is optional for inherited classes, as the default implementation
// emulates it using read.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (stream *InputStreamInstance) Skip(count uint, cancellable Cancellable) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_input_stream_skip(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SkipAsync wraps g_input_stream_skip_async
// 
// The function takes the following parameters:
// 
// 	- count uint: the number of bytes that will be skipped from the stream 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Request an asynchronous skip of @count bytes from the stream.
// When the operation is finished @callback will be called.
// You can then call g_input_stream_skip_finish() to get the result
// of the operation.
// 
// During an async request no other sync and async calls are allowed,
// and will result in %G_IO_ERROR_PENDING errors.
// 
// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes skipped will be passed to the callback.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file, but generally we try to skip
// as many bytes as requested. Zero is returned on end of file
// (or if @count is zero), but never otherwise.
// 
// Any outstanding i/o request with higher priority (lower numerical value)
// will be executed before an outstanding request with lower priority.
// Default priority is %G_PRIORITY_DEFAULT.
// 
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one, you must override all.
func (stream *InputStreamInstance) SkipAsync(count uint, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GInputStream       // in, none, converted
	var carg1 C.gsize               // in, none, casted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_input_stream_skip_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SkipFinish wraps g_input_stream_skip_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream skip operation.
func (stream *InputStreamInstance) SkipFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_input_stream_skip_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InputStreamOverrides[Instance InputStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	CloseFn func(Instance, Cancellable) (bool, error)
	// // ReadFinish allows you to override the implementation of the virtual method read_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream read operation.
	ReadFinish func(Instance, AsyncResult) (int, error)
	// // Skip allows you to override the implementation of the virtual method skip.
	// 
	// The function takes the following parameters:
	// 
	// 	- count uint: the number of bytes that will be skipped from the stream 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to skip @count bytes from the stream. Will block during the operation.
	// 
	// This is identical to g_input_stream_read(), from a behaviour standpoint,
	// but the bytes that are skipped are not returned to the user. Some
	// streams have an implementation that is more efficient than reading the data.
	// 
	// This function is optional for inherited classes, as the default implementation
	// emulates it using read.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	Skip func(Instance, uint, Cancellable) (int, error)
	// // SkipFinish allows you to override the implementation of the virtual method skip_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream skip operation.
	SkipFinish func(Instance, AsyncResult) (int, error)
}

// UnsafeApplyInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInputStreamOverrides[Instance InputStream](gclass unsafe.Pointer, overrides InputStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GInputStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_InputStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_close_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_InputStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_close_fn",
			func(carg0 *C.GInputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GInputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ReadFinish != nil {
		pclass.read_finish = (*[0]byte)(C._goglib_gio2_InputStream_read_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_read_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.ReadFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Skip != nil {
		pclass.skip = (*[0]byte)(C._goglib_gio2_InputStream_skip)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_skip",
			func(carg0 *C.GInputStream, carg1 C.gsize, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GInputStream subclass
				var count       uint        // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				count = uint(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.Skip(stream, count, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.SkipFinish != nil {
		pclass.skip_finish = (*[0]byte)(C._goglib_gio2_InputStream_skip_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_InputStream_skip_finish",
			func(carg0 *C.GInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.SkipFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GInputStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
func (stream *InputStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GInputStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *InputStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_InputStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReadFinish calls the default implementations of the `GInputStream.read_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream read operation.
func (stream *InputStreamInstance) ParentReadFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_read_finish(unsafe.Pointer(parentclass.read_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSkip calls the default implementations of the `GInputStream.skip` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- count uint: the number of bytes that will be skipped from the stream 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to skip @count bytes from the stream. Will block during the operation.
// 
// This is identical to g_input_stream_read(), from a behaviour standpoint,
// but the bytes that are skipped are not returned to the user. Some
// streams have an implementation that is more efficient than reading the data.
// 
// This function is optional for inherited classes, as the default implementation
// emulates it using read.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
func (stream *InputStreamInstance) ParentSkip(count uint, cancellable Cancellable) (int, error) {
	var carg0 *C.GInputStream
	var carg1 C.gsize         // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = C.gsize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_InputStream_virtual_skip(unsafe.Pointer(parentclass.skip), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSkipFinish calls the default implementations of the `GInputStream.skip_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream skip operation.
func (stream *InputStreamInstance) ParentSkipFinish(result AsyncResult) (int, error) {
	var carg0 *C.GInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GInputStreamClass)(classdata.PeekParentClass(UnsafeInputStreamToGlibNone(stream)))

	carg0 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_InputStream_virtual_skip_finish(unsafe.Pointer(parentclass.skip_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterInputStreamSubClass is used to register a go subclass of GInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInputStreamSubClass[InstanceT InputStream](
		name string,
		classInit func(class *InputStreamClass),
		constructor func() InstanceT,
		overrides InputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInputStream,
		UnsafeInputStreamClassFromGlibBorrow,
		UnsafeApplyInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInputStream(obj)
		},
		interfaceInits...,
	)
}

// ListStoreInstance is the instance type used by all types extending GListStore. It is used internally by the bindings. Users should use the interface [ListStore] instead.
type ListStoreInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ListStore = (*ListStoreInstance)(nil)

// ListStore wraps GListStore
//
// `GListStore` is a simple implementation of [iface@Gio.ListModel] that stores
// all items in memory.
// 
// It provides insertions, deletions, and lookups in logarithmic time
// with a fast path for the common case of iterating the list linearly.
type ListStore interface {
	gobject.Object
	upcastToGListStore() *ListStoreInstance

	// Remove wraps g_list_store_remove
	// 
	// The function takes the following parameters:
	// 
	// 	- position uint: the position of the item that is to be removed 
	//
	// Removes the item from @store that is at @position. @position must be
	// smaller than the current length of the list.
	// 
	// Use g_list_store_splice() to remove multiple items at the same time
	// efficiently.
	Remove(uint)
	// RemoveAll wraps g_list_store_remove_all
	//
	// Removes all items from @store.
	RemoveAll()

	// chain up virtual methods:
}

func unsafeWrapListStore(base *gobject.ObjectInstance) *ListStoreInstance {
	return &ListStoreInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeListStore,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapListStore(inst)
		},
	)
}

func marshalListStoreInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeListStoreFromGlibNone is used to convert raw GListStore pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeListStoreFromGlibNone(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibNone(c).(ListStore)
}

// UnsafeListStoreFromGlibFull is used to convert raw GListStore pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeListStoreFromGlibFull(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibFull(c).(ListStore)
}

// UnsafeListStoreFromGlibBorrow is used to convert raw GListStore pointers to go without touching any references. This is used by the bindings internally.
func UnsafeListStoreFromGlibBorrow(c unsafe.Pointer) ListStore {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ListStore)
}

func (l *ListStoreInstance) upcastToGListStore() *ListStoreInstance {
	return l
}

// UnsafeListStoreToGlibNone is used to convert the instance to it's C value GListStore. This is used by the bindings internally.
func UnsafeListStoreToGlibNone(c ListStore) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeListStoreToGlibFull is used to convert the instance to it's C value GListStore, while removeing the finalizer. This is used by the bindings internally.
func UnsafeListStoreToGlibFull(c ListStore) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewListStore wraps g_list_store_new
// 
// The function takes the following parameters:
// 
// 	- itemType gobject.Type: the #GType of items in the list 
// 
// The function returns the following values:
// 
// 	- goret ListStore 
//
// Creates a new #GListStore with items of type @item_type. @item_type
// must be a subclass of #GObject.
func NewListStore(itemType gobject.Type) ListStore {
	var carg1 C.GType       // in, none, casted, alias
	var cret  *C.GListStore // return, full, converted

	carg1 = C.GType(itemType)

	cret = C.g_list_store_new(carg1)
	runtime.KeepAlive(itemType)

	var goret ListStore

	goret = UnsafeListStoreFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Remove wraps g_list_store_remove
// 
// The function takes the following parameters:
// 
// 	- position uint: the position of the item that is to be removed 
//
// Removes the item from @store that is at @position. @position must be
// smaller than the current length of the list.
// 
// Use g_list_store_splice() to remove multiple items at the same time
// efficiently.
func (store *ListStoreInstance) Remove(position uint) {
	var carg0 *C.GListStore // in, none, converted
	var carg1 C.guint       // in, none, casted

	carg0 = (*C.GListStore)(UnsafeListStoreToGlibNone(store))
	carg1 = C.guint(position)

	C.g_list_store_remove(carg0, carg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(position)
}

// RemoveAll wraps g_list_store_remove_all
//
// Removes all items from @store.
func (store *ListStoreInstance) RemoveAll() {
	var carg0 *C.GListStore // in, none, converted

	carg0 = (*C.GListStore)(UnsafeListStoreToGlibNone(store))

	C.g_list_store_remove_all(carg0)
	runtime.KeepAlive(store)
}

// ListStoreOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ListStoreOverrides[Instance ListStore] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyListStoreOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyListStoreOverrides[Instance ListStore](gclass unsafe.Pointer, overrides ListStoreOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterListStoreSubClass is used to register a go subclass of GListStore. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterListStoreSubClass[InstanceT ListStore](
		name string,
		classInit func(class *ListStoreClass),
		constructor func() InstanceT,
		overrides ListStoreOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeListStore,
		UnsafeListStoreClassFromGlibBorrow,
		UnsafeApplyListStoreOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapListStore(obj)
		},
		interfaceInits...,
	)
}

// MemoryInputStreamInstance is the instance type used by all types extending GMemoryInputStream. It is used internally by the bindings. Users should use the interface [MemoryInputStream] instead.
type MemoryInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
}

var _ MemoryInputStream = (*MemoryInputStreamInstance)(nil)

// MemoryInputStream wraps GMemoryInputStream
//
// `GMemoryInputStream` is a class for using arbitrary
// memory chunks as input for GIO streaming input operations.
// 
// As of GLib 2.34, `GMemoryInputStream` implements
// [iface@Gio.PollableInputStream].
type MemoryInputStream interface {
	InputStream
	upcastToGMemoryInputStream() *MemoryInputStreamInstance

	// AddBytes wraps g_memory_input_stream_add_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- bytes *glib.Bytes: input data 
	//
	// Appends @bytes to data that can be read from the input stream.
	AddBytes(*glib.Bytes)

	// chain up virtual methods:
}

func unsafeWrapMemoryInputStream(base *gobject.ObjectInstance) *MemoryInputStreamInstance {
	return &MemoryInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMemoryInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryInputStream(inst)
		},
	)
}

func marshalMemoryInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMemoryInputStreamFromGlibNone is used to convert raw GMemoryInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibNone(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryInputStream)
}

// UnsafeMemoryInputStreamFromGlibFull is used to convert raw GMemoryInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibFull(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryInputStream)
}

// UnsafeMemoryInputStreamFromGlibBorrow is used to convert raw GMemoryInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryInputStreamFromGlibBorrow(c unsafe.Pointer) MemoryInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryInputStream)
}

func (m *MemoryInputStreamInstance) upcastToGMemoryInputStream() *MemoryInputStreamInstance {
	return m
}

// UnsafeMemoryInputStreamToGlibNone is used to convert the instance to it's C value GMemoryInputStream. This is used by the bindings internally.
func UnsafeMemoryInputStreamToGlibNone(c MemoryInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMemoryInputStreamToGlibFull is used to convert the instance to it's C value GMemoryInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryInputStreamToGlibFull(c MemoryInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMemoryInputStream wraps g_memory_input_stream_new
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Creates a new empty #GMemoryInputStream.
func NewMemoryInputStream() InputStream {
	var cret *C.GInputStream // return, full, converted

	cret = C.g_memory_input_stream_new()

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMemoryInputStreamFromBytes wraps g_memory_input_stream_new_from_bytes
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: a #GBytes 
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Creates a new #GMemoryInputStream with data from the given @bytes.
func NewMemoryInputStreamFromBytes(bytes *glib.Bytes) InputStream {
	var carg1 *C.GBytes       // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	cret = C.g_memory_input_stream_new_from_bytes(carg1)
	runtime.KeepAlive(bytes)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddBytes wraps g_memory_input_stream_add_bytes
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: input data 
//
// Appends @bytes to data that can be read from the input stream.
func (stream *MemoryInputStreamInstance) AddBytes(bytes *glib.Bytes) {
	var carg0 *C.GMemoryInputStream // in, none, converted
	var carg1 *C.GBytes             // in, none, converted

	carg0 = (*C.GMemoryInputStream)(UnsafeMemoryInputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))

	C.g_memory_input_stream_add_bytes(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
}

// MemoryInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MemoryInputStreamOverrides[Instance MemoryInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

}

// UnsafeApplyMemoryInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMemoryInputStreamOverrides[Instance MemoryInputStream](gclass unsafe.Pointer, overrides MemoryInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)
}

// RegisterMemoryInputStreamSubClass is used to register a go subclass of GMemoryInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMemoryInputStreamSubClass[InstanceT MemoryInputStream](
		name string,
		classInit func(class *MemoryInputStreamClass),
		constructor func() InstanceT,
		overrides MemoryInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMemoryInputStream,
		UnsafeMemoryInputStreamClassFromGlibBorrow,
		UnsafeApplyMemoryInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryInputStream(obj)
		},
		interfaceInits...,
	)
}

// MenuAttributeIterInstance is the instance type used by all types extending GMenuAttributeIter. It is used internally by the bindings. Users should use the interface [MenuAttributeIter] instead.
type MenuAttributeIterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuAttributeIter = (*MenuAttributeIterInstance)(nil)

// MenuAttributeIter wraps GMenuAttributeIter
//
// #GMenuAttributeIter is an opaque structure type.  You must access it
// using the functions below.
type MenuAttributeIter interface {
	gobject.Object
	upcastToGMenuAttributeIter() *MenuAttributeIterInstance

	// GetName wraps g_menu_attribute_iter_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name of the attribute at the current iterator position, as
	// a string.
	// 
	// The iterator is not advanced.
	GetName() string
	// Next wraps g_menu_attribute_iter_next
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Attempts to advance the iterator to the next (possibly first)
	// attribute.
	// 
	// %TRUE is returned on success, or %FALSE if there are no more
	// attributes.
	// 
	// You must call this function when you first acquire the iterator
	// to advance it to the first attribute (and determine if the first
	// attribute exists at all).
	Next() bool

	// chain up virtual methods:
}

func unsafeWrapMenuAttributeIter(base *gobject.ObjectInstance) *MenuAttributeIterInstance {
	return &MenuAttributeIterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuAttributeIter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuAttributeIter(inst)
		},
	)
}

func marshalMenuAttributeIterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuAttributeIterFromGlibNone is used to convert raw GMenuAttributeIter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibNone(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuAttributeIter)
}

// UnsafeMenuAttributeIterFromGlibFull is used to convert raw GMenuAttributeIter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibFull(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuAttributeIter)
}

// UnsafeMenuAttributeIterFromGlibBorrow is used to convert raw GMenuAttributeIter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuAttributeIterFromGlibBorrow(c unsafe.Pointer) MenuAttributeIter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuAttributeIter)
}

func (m *MenuAttributeIterInstance) upcastToGMenuAttributeIter() *MenuAttributeIterInstance {
	return m
}

// UnsafeMenuAttributeIterToGlibNone is used to convert the instance to it's C value GMenuAttributeIter. This is used by the bindings internally.
func UnsafeMenuAttributeIterToGlibNone(c MenuAttributeIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuAttributeIterToGlibFull is used to convert the instance to it's C value GMenuAttributeIter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuAttributeIterToGlibFull(c MenuAttributeIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetName wraps g_menu_attribute_iter_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of the attribute at the current iterator position, as
// a string.
// 
// The iterator is not advanced.
func (iter *MenuAttributeIterInstance) GetName() string {
	var carg0 *C.GMenuAttributeIter // in, none, converted
	var cret  *C.gchar              // return, none, string

	carg0 = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibNone(iter))

	cret = C.g_menu_attribute_iter_get_name(carg0)
	runtime.KeepAlive(iter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Next wraps g_menu_attribute_iter_next
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Attempts to advance the iterator to the next (possibly first)
// attribute.
// 
// %TRUE is returned on success, or %FALSE if there are no more
// attributes.
// 
// You must call this function when you first acquire the iterator
// to advance it to the first attribute (and determine if the first
// attribute exists at all).
func (iter *MenuAttributeIterInstance) Next() bool {
	var carg0 *C.GMenuAttributeIter // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibNone(iter))

	cret = C.g_menu_attribute_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MenuAttributeIterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuAttributeIterOverrides[Instance MenuAttributeIter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyMenuAttributeIterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuAttributeIterOverrides[Instance MenuAttributeIter](gclass unsafe.Pointer, overrides MenuAttributeIterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterMenuAttributeIterSubClass is used to register a go subclass of GMenuAttributeIter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuAttributeIterSubClass[InstanceT MenuAttributeIter](
		name string,
		classInit func(class *MenuAttributeIterClass),
		constructor func() InstanceT,
		overrides MenuAttributeIterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuAttributeIter,
		UnsafeMenuAttributeIterClassFromGlibBorrow,
		UnsafeApplyMenuAttributeIterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuAttributeIter(obj)
		},
		interfaceInits...,
	)
}

// MenuItemInstance is the instance type used by all types extending GMenuItem. It is used internally by the bindings. Users should use the interface [MenuItem] instead.
type MenuItemInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuItem = (*MenuItemInstance)(nil)

// MenuItem wraps GMenuItem
//
// #GMenuItem is an opaque structure type.  You must access it using the
// functions below.
type MenuItem interface {
	gobject.Object
	upcastToGMenuItem() *MenuItemInstance

	// GetLink wraps g_menu_item_get_link
	// 
	// The function takes the following parameters:
	// 
	// 	- link string: the link name to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuModel (nullable) 
	//
	// Queries the named @link on @menu_item.
	GetLink(string) MenuModel
	// SetDetailedAction wraps g_menu_item_set_detailed_action
	// 
	// The function takes the following parameters:
	// 
	// 	- detailedAction string: the "detailed" action string 
	//
	// Sets the "action" and possibly the "target" attribute of @menu_item.
	// 
	// The format of @detailed_action is the same format parsed by
	// g_action_parse_detailed_name().
	// 
	// See g_menu_item_set_action_and_target() or
	// g_menu_item_set_action_and_target_value() for more flexible (but
	// slightly less convenient) alternatives.
	// 
	// See also g_menu_item_set_action_and_target_value() for a description of
	// the semantics of the action and target attributes.
	SetDetailedAction(string)
	// SetIcon wraps g_menu_item_set_icon
	// 
	// The function takes the following parameters:
	// 
	// 	- icon Icon: a #GIcon, or %NULL 
	//
	// Sets (or unsets) the icon on @menu_item.
	// 
	// This call is the same as calling g_icon_serialize() and using the
	// result as the value to g_menu_item_set_attribute_value() for
	// %G_MENU_ATTRIBUTE_ICON.
	// 
	// This API is only intended for use with "noun" menu items; things like
	// bookmarks or applications in an "Open With" menu.  Don't use it on
	// menu items corresponding to verbs (eg: stock icons for 'Save' or
	// 'Quit').
	// 
	// If @icon is %NULL then the icon is unset.
	SetIcon(Icon)
	// SetLabel wraps g_menu_item_set_label
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the label to set, or %NULL to unset 
	//
	// Sets or unsets the "label" attribute of @menu_item.
	// 
	// If @label is non-%NULL it is used as the label for the menu item.  If
	// it is %NULL then the label attribute is unset.
	SetLabel(string)
	// SetLink wraps g_menu_item_set_link
	// 
	// The function takes the following parameters:
	// 
	// 	- link string: type of link to establish or unset 
	// 	- model MenuModel (nullable): the #GMenuModel to link to (or %NULL to unset) 
	//
	// Creates a link from @menu_item to @model if non-%NULL, or unsets it.
	// 
	// Links are used to establish a relationship between a particular menu
	// item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
	// associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
	// is used to create a section. Other types of link can be used, but there
	// is no guarantee that clients will be able to make sense of them.
	// Link types are restricted to lowercase characters, numbers
	// and '-'. Furthermore, the names must begin with a lowercase character,
	// must not end with a '-', and must not contain consecutive dashes.
	SetLink(string, MenuModel)
	// SetSection wraps g_menu_item_set_section
	// 
	// The function takes the following parameters:
	// 
	// 	- section MenuModel (nullable): a #GMenuModel, or %NULL 
	//
	// Sets or unsets the "section" link of @menu_item to @section.
	// 
	// The effect of having one menu appear as a section of another is
	// exactly as it sounds: the items from @section become a direct part of
	// the menu that @menu_item is added to.  See g_menu_item_new_section()
	// for more information about what it means for a menu item to be a
	// section.
	SetSection(MenuModel)
	// SetSubmenu wraps g_menu_item_set_submenu
	// 
	// The function takes the following parameters:
	// 
	// 	- submenu MenuModel (nullable): a #GMenuModel, or %NULL 
	//
	// Sets or unsets the "submenu" link of @menu_item to @submenu.
	// 
	// If @submenu is non-%NULL, it is linked to.  If it is %NULL then the
	// link is unset.
	// 
	// The effect of having one menu appear as a submenu of another is
	// exactly as it sounds.
	SetSubmenu(MenuModel)
}

func unsafeWrapMenuItem(base *gobject.ObjectInstance) *MenuItemInstance {
	return &MenuItemInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuItem,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuItem(inst)
		},
	)
}

func marshalMenuItemInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuItemFromGlibNone is used to convert raw GMenuItem pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuItemFromGlibNone(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuItem)
}

// UnsafeMenuItemFromGlibFull is used to convert raw GMenuItem pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuItemFromGlibFull(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuItem)
}

// UnsafeMenuItemFromGlibBorrow is used to convert raw GMenuItem pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuItemFromGlibBorrow(c unsafe.Pointer) MenuItem {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuItem)
}

func (m *MenuItemInstance) upcastToGMenuItem() *MenuItemInstance {
	return m
}

// UnsafeMenuItemToGlibNone is used to convert the instance to it's C value GMenuItem. This is used by the bindings internally.
func UnsafeMenuItemToGlibNone(c MenuItem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuItemToGlibFull is used to convert the instance to it's C value GMenuItem, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuItemToGlibFull(c MenuItem) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMenuItem wraps g_menu_item_new
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- detailedAction string (nullable): the detailed action string, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret MenuItem 
//
// Creates a new #GMenuItem.
// 
// If @label is non-%NULL it is used to set the "label" attribute of the
// new item.
// 
// If @detailed_action is non-%NULL it is used to set the "action" and
// possibly the "target" attribute of the new item.  See
// g_menu_item_set_detailed_action() for more information.
func NewMenuItem(label string, detailedAction string) MenuItem {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var carg2 *C.gchar     // in, none, string, nullable-string
	var cret  *C.GMenuItem // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_menu_item_new(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemFromModel wraps g_menu_item_new_from_model
// 
// The function takes the following parameters:
// 
// 	- model MenuModel: a #GMenuModel 
// 	- itemIndex int32: the index of an item in @model 
// 
// The function returns the following values:
// 
// 	- goret MenuItem 
//
// Creates a #GMenuItem as an exact copy of an existing menu item in a
// #GMenuModel.
// 
// @item_index must be valid (ie: be sure to call
// g_menu_model_get_n_items() first).
func NewMenuItemFromModel(model MenuModel, itemIndex int32) MenuItem {
	var carg1 *C.GMenuModel // in, none, converted
	var carg2 C.gint        // in, none, casted
	var cret  *C.GMenuItem  // return, full, converted

	carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg2 = C.gint(itemIndex)

	cret = C.g_menu_item_new_from_model(carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemSection wraps g_menu_item_new_section
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- section MenuModel: a #GMenuModel with the items of the section 
// 
// The function returns the following values:
// 
// 	- goret MenuItem 
//
// Creates a new #GMenuItem representing a section.
// 
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_section().
// 
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.
// 
// Visual separation is typically displayed between two non-empty
// sections.  If @label is non-%NULL then it will be incorporated into
// this visual indication.  This allows for labeled subsections of a
// menu.
// 
// As a simple example, consider a typical "Edit" menu from a simple
// program.  It probably contains an "Undo" and "Redo" item, followed by
// a separator, followed by "Cut", "Copy" and "Paste".
// 
// This would be accomplished by creating three #GMenu instances.  The
// first would be populated with the "Undo" and "Redo" items, and the
// second with the "Cut", "Copy" and "Paste" items.  The first and
// second menus would then be added as submenus of the third.  In XML
// format, this would look something like the following:
// |[
// &lt;menu id='edit-menu'&gt;
//   &lt;section&gt;
//     &lt;item label='Undo'/&gt;
//     &lt;item label='Redo'/&gt;
//   &lt;/section&gt;
//   &lt;section&gt;
//     &lt;item label='Cut'/&gt;
//     &lt;item label='Copy'/&gt;
//     &lt;item label='Paste'/&gt;
//   &lt;/section&gt;
// &lt;/menu&gt;
// ]|
// 
// The following example is exactly equivalent.  It is more illustrative
// of the exact relationship between the menus and items (keeping in
// mind that the 'link' element defines a new menu that is linked to the
// containing one).  The style of the second example is more verbose and
// difficult to read (and therefore not recommended except for the
// purpose of understanding what is really going on).
// |[
// &lt;menu id='edit-menu'&gt;
//   &lt;item&gt;
//     &lt;link name='section'&gt;
//       &lt;item label='Undo'/&gt;
//       &lt;item label='Redo'/&gt;
//     &lt;/link&gt;
//   &lt;/item&gt;
//   &lt;item&gt;
//     &lt;link name='section'&gt;
//       &lt;item label='Cut'/&gt;
//       &lt;item label='Copy'/&gt;
//       &lt;item label='Paste'/&gt;
//     &lt;/link&gt;
//   &lt;/item&gt;
// &lt;/menu&gt;
// ]|
func NewMenuItemSection(label string, section MenuModel) MenuItem {
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted
	var cret  *C.GMenuItem  // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	cret = C.g_menu_item_new_section(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMenuItemSubmenu wraps g_menu_item_new_submenu
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
// 
// The function returns the following values:
// 
// 	- goret MenuItem 
//
// Creates a new #GMenuItem representing a submenu.
// 
// This is a convenience API around g_menu_item_new() and
// g_menu_item_set_submenu().
func NewMenuItemSubmenu(label string, submenu MenuModel) MenuItem {
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted
	var cret  *C.GMenuItem  // return, full, converted

	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	cret = C.g_menu_item_new_submenu(carg1, carg2)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)

	var goret MenuItem

	goret = UnsafeMenuItemFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetLink wraps g_menu_item_get_link
// 
// The function takes the following parameters:
// 
// 	- link string: the link name to query 
// 
// The function returns the following values:
// 
// 	- goret MenuModel (nullable) 
//
// Queries the named @link on @menu_item.
func (menuItem *MenuItemInstance) GetLink(link string) MenuModel {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.GMenuModel // return, full, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_menu_item_get_link(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// SetDetailedAction wraps g_menu_item_set_detailed_action
// 
// The function takes the following parameters:
// 
// 	- detailedAction string: the "detailed" action string 
//
// Sets the "action" and possibly the "target" attribute of @menu_item.
// 
// The format of @detailed_action is the same format parsed by
// g_action_parse_detailed_name().
// 
// See g_menu_item_set_action_and_target() or
// g_menu_item_set_action_and_target_value() for more flexible (but
// slightly less convenient) alternatives.
// 
// See also g_menu_item_set_action_and_target_value() for a description of
// the semantics of the action and target attributes.
func (menuItem *MenuItemInstance) SetDetailedAction(detailedAction string) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.gchar     // in, none, string

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_menu_item_set_detailed_action(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(detailedAction)
}

// SetIcon wraps g_menu_item_set_icon
// 
// The function takes the following parameters:
// 
// 	- icon Icon: a #GIcon, or %NULL 
//
// Sets (or unsets) the icon on @menu_item.
// 
// This call is the same as calling g_icon_serialize() and using the
// result as the value to g_menu_item_set_attribute_value() for
// %G_MENU_ATTRIBUTE_ICON.
// 
// This API is only intended for use with "noun" menu items; things like
// bookmarks or applications in an "Open With" menu.  Don't use it on
// menu items corresponding to verbs (eg: stock icons for 'Save' or
// 'Quit').
// 
// If @icon is %NULL then the icon is unset.
func (menuItem *MenuItemInstance) SetIcon(icon Icon) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.GIcon     // in, none, converted

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_menu_item_set_icon(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(icon)
}

// SetLabel wraps g_menu_item_set_label
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the label to set, or %NULL to unset 
//
// Sets or unsets the "label" attribute of @menu_item.
// 
// If @label is non-%NULL it is used as the label for the menu item.  If
// it is %NULL then the label attribute is unset.
func (menuItem *MenuItemInstance) SetLabel(label string) {
	var carg0 *C.GMenuItem // in, none, converted
	var carg1 *C.gchar     // in, none, string, nullable-string

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_menu_item_set_label(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(label)
}

// SetLink wraps g_menu_item_set_link
// 
// The function takes the following parameters:
// 
// 	- link string: type of link to establish or unset 
// 	- model MenuModel (nullable): the #GMenuModel to link to (or %NULL to unset) 
//
// Creates a link from @menu_item to @model if non-%NULL, or unsets it.
// 
// Links are used to establish a relationship between a particular menu
// item and another menu.  For example, %G_MENU_LINK_SUBMENU is used to
// associate a submenu with a particular menu item, and %G_MENU_LINK_SECTION
// is used to create a section. Other types of link can be used, but there
// is no guarantee that clients will be able to make sense of them.
// Link types are restricted to lowercase characters, numbers
// and '-'. Furthermore, the names must begin with a lowercase character,
// must not end with a '-', and must not contain consecutive dashes.
func (menuItem *MenuItemInstance) SetLink(link string, model MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg1))
	if model != nil {
		carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	}

	C.g_menu_item_set_link(carg0, carg1, carg2)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(link)
	runtime.KeepAlive(model)
}

// SetSection wraps g_menu_item_set_section
// 
// The function takes the following parameters:
// 
// 	- section MenuModel (nullable): a #GMenuModel, or %NULL 
//
// Sets or unsets the "section" link of @menu_item to @section.
// 
// The effect of having one menu appear as a section of another is
// exactly as it sounds: the items from @section become a direct part of
// the menu that @menu_item is added to.  See g_menu_item_new_section()
// for more information about what it means for a menu item to be a
// section.
func (menuItem *MenuItemInstance) SetSection(section MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if section != nil {
		carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))
	}

	C.g_menu_item_set_section(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(section)
}

// SetSubmenu wraps g_menu_item_set_submenu
// 
// The function takes the following parameters:
// 
// 	- submenu MenuModel (nullable): a #GMenuModel, or %NULL 
//
// Sets or unsets the "submenu" link of @menu_item to @submenu.
// 
// If @submenu is non-%NULL, it is linked to.  If it is %NULL then the
// link is unset.
// 
// The effect of having one menu appear as a submenu of another is
// exactly as it sounds.
func (menuItem *MenuItemInstance) SetSubmenu(submenu MenuModel) {
	var carg0 *C.GMenuItem  // in, none, converted
	var carg1 *C.GMenuModel // in, none, converted, nullable

	carg0 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(menuItem))
	if submenu != nil {
		carg1 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))
	}

	C.g_menu_item_set_submenu(carg0, carg1)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(submenu)
}

// MenuLinkIterInstance is the instance type used by all types extending GMenuLinkIter. It is used internally by the bindings. Users should use the interface [MenuLinkIter] instead.
type MenuLinkIterInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuLinkIter = (*MenuLinkIterInstance)(nil)

// MenuLinkIter wraps GMenuLinkIter
//
// #GMenuLinkIter is an opaque structure type.  You must access it using
// the functions below.
type MenuLinkIter interface {
	gobject.Object
	upcastToGMenuLinkIter() *MenuLinkIterInstance

	// GetName wraps g_menu_link_iter_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the name of the link at the current iterator position.
	// 
	// The iterator is not advanced.
	GetName() string
	// GetNext wraps g_menu_link_iter_get_next
	// 
	// The function returns the following values:
	// 
	// 	- outLink string: the name of the link 
	// 	- value MenuModel: the linked #GMenuModel 
	// 	- goret bool 
	//
	// This function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	// 
	// First the iterator is advanced to the next (possibly first) link.
	// If that fails, then %FALSE is returned and there are no other effects.
	// 
	// If successful, @out_link and @value are set to the name and #GMenuModel
	// of the link that has just been advanced to.  At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
	// same values again.
	// 
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position.  The value returned in @value must
	// be unreffed using g_object_unref() when it is no longer in use.
	GetNext() (string, MenuModel, bool)
	// GetValue wraps g_menu_link_iter_get_value
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuModel 
	//
	// Gets the linked #GMenuModel at the current iterator position.
	// 
	// The iterator is not advanced.
	GetValue() MenuModel
	// Next wraps g_menu_link_iter_next
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Attempts to advance the iterator to the next (possibly first)
	// link.
	// 
	// %TRUE is returned on success, or %FALSE if there are no more links.
	// 
	// You must call this function when you first acquire the iterator to
	// advance it to the first link (and determine if the first link exists
	// at all).
	Next() bool

	// chain up virtual methods:

	// ParentGetNext calls the default implementations of the `GMenuLinkIter.get_next` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- outLink string: the name of the link 
	// 	- value MenuModel: the linked #GMenuModel 
	// 	- goret bool 
	//
	// This function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	// 
	// First the iterator is advanced to the next (possibly first) link.
	// If that fails, then %FALSE is returned and there are no other effects.
	// 
	// If successful, @out_link and @value are set to the name and #GMenuModel
	// of the link that has just been advanced to.  At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
	// same values again.
	// 
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position.  The value returned in @value must
	// be unreffed using g_object_unref() when it is no longer in use.
	ParentGetNext() (string, MenuModel, bool)
}

func unsafeWrapMenuLinkIter(base *gobject.ObjectInstance) *MenuLinkIterInstance {
	return &MenuLinkIterInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuLinkIter,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuLinkIter(inst)
		},
	)
}

func marshalMenuLinkIterInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuLinkIterFromGlibNone is used to convert raw GMenuLinkIter pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibNone(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuLinkIter)
}

// UnsafeMenuLinkIterFromGlibFull is used to convert raw GMenuLinkIter pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibFull(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuLinkIter)
}

// UnsafeMenuLinkIterFromGlibBorrow is used to convert raw GMenuLinkIter pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuLinkIterFromGlibBorrow(c unsafe.Pointer) MenuLinkIter {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuLinkIter)
}

func (m *MenuLinkIterInstance) upcastToGMenuLinkIter() *MenuLinkIterInstance {
	return m
}

// UnsafeMenuLinkIterToGlibNone is used to convert the instance to it's C value GMenuLinkIter. This is used by the bindings internally.
func UnsafeMenuLinkIterToGlibNone(c MenuLinkIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuLinkIterToGlibFull is used to convert the instance to it's C value GMenuLinkIter, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuLinkIterToGlibFull(c MenuLinkIter) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetName wraps g_menu_link_iter_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of the link at the current iterator position.
// 
// The iterator is not advanced.
func (iter *MenuLinkIterInstance) GetName() string {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_name(carg0)
	runtime.KeepAlive(iter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetNext wraps g_menu_link_iter_get_next
// 
// The function returns the following values:
// 
// 	- outLink string: the name of the link 
// 	- value MenuModel: the linked #GMenuModel 
// 	- goret bool 
//
// This function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
// 
// First the iterator is advanced to the next (possibly first) link.
// If that fails, then %FALSE is returned and there are no other effects.
// 
// If successful, @out_link and @value are set to the name and #GMenuModel
// of the link that has just been advanced to.  At this point,
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
// same values again.
// 
// The value returned in @out_link remains valid for as long as the iterator
// remains at the current position.  The value returned in @value must
// be unreffed using g_object_unref() when it is no longer in use.
func (iter *MenuLinkIterInstance) GetNext() (string, MenuModel, bool) {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var carg1 *C.gchar         // out, none, string
	var carg2 *C.GMenuModel    // out, full, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_next(carg0, &carg1, &carg2)
	runtime.KeepAlive(iter)

	var outLink string
	var value   MenuModel
	var goret   bool

	outLink = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	value = UnsafeMenuModelFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}

	return outLink, value, goret
}

// GetValue wraps g_menu_link_iter_get_value
// 
// The function returns the following values:
// 
// 	- goret MenuModel 
//
// Gets the linked #GMenuModel at the current iterator position.
// 
// The iterator is not advanced.
func (iter *MenuLinkIterInstance) GetValue() MenuModel {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  *C.GMenuModel    // return, full, converted

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_get_value(carg0)
	runtime.KeepAlive(iter)

	var goret MenuModel

	goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Next wraps g_menu_link_iter_next
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Attempts to advance the iterator to the next (possibly first)
// link.
// 
// %TRUE is returned on success, or %FALSE if there are no more links.
// 
// You must call this function when you first acquire the iterator to
// advance it to the first link (and determine if the first link exists
// at all).
func (iter *MenuLinkIterInstance) Next() bool {
	var carg0 *C.GMenuLinkIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C.g_menu_link_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MenuLinkIterOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuLinkIterOverrides[Instance MenuLinkIter] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetNext allows you to override the implementation of the virtual method get_next.
	// 
	// The function returns the following values:
	// 
	// 	- outLink string: the name of the link 
	// 	- value MenuModel: the linked #GMenuModel 
	// 	- goret bool 
	//
	// This function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	// 
	// First the iterator is advanced to the next (possibly first) link.
	// If that fails, then %FALSE is returned and there are no other effects.
	// 
	// If successful, @out_link and @value are set to the name and #GMenuModel
	// of the link that has just been advanced to.  At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
	// same values again.
	// 
	// The value returned in @out_link remains valid for as long as the iterator
	// remains at the current position.  The value returned in @value must
	// be unreffed using g_object_unref() when it is no longer in use.
	GetNext func(Instance) (string, MenuModel, bool)
}

// UnsafeApplyMenuLinkIterOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuLinkIterOverrides[Instance MenuLinkIter](gclass unsafe.Pointer, overrides MenuLinkIterOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMenuLinkIterClass)(gclass)

	if overrides.GetNext != nil {
		pclass.get_next = (*[0]byte)(C._goglib_gio2_MenuLinkIter_get_next)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuLinkIter_get_next",
			func(carg0 *C.GMenuLinkIter, carg1 **C.gchar, carg2 **C.GMenuModel) (cret C.gboolean) {
				var iter    Instance  // go GMenuLinkIter subclass
				var outLink string    // out, none, string
				var value   MenuModel // out, full, converted
				var goret   bool      // return

				iter = UnsafeMenuLinkIterFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				outLink, value, goret = overrides.GetNext(iter)

				*carg1 = (*C.gchar)(unsafe.Pointer(C.CString(outLink)))
				defer C.free(unsafe.Pointer(carg1))
				*carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibFull(value))
				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentGetNext calls the default implementations of the `GMenuLinkIter.get_next` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- outLink string: the name of the link 
// 	- value MenuModel: the linked #GMenuModel 
// 	- goret bool 
//
// This function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
// 
// First the iterator is advanced to the next (possibly first) link.
// If that fails, then %FALSE is returned and there are no other effects.
// 
// If successful, @out_link and @value are set to the name and #GMenuModel
// of the link that has just been advanced to.  At this point,
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return the
// same values again.
// 
// The value returned in @out_link remains valid for as long as the iterator
// remains at the current position.  The value returned in @value must
// be unreffed using g_object_unref() when it is no longer in use.
func (iter *MenuLinkIterInstance) ParentGetNext() (string, MenuModel, bool) {
	var carg0 *C.GMenuLinkIter
	var carg1 *C.gchar      // out, none, string
	var carg2 *C.GMenuModel // out, full, converted
	var cret  C.gboolean    // return

	parentclass := (*C.GMenuLinkIterClass)(classdata.PeekParentClass(UnsafeMenuLinkIterToGlibNone(iter)))

	carg0 = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibNone(iter))

	cret = C._goglib_gio2_MenuLinkIter_virtual_get_next(unsafe.Pointer(parentclass.get_next), carg0, &carg1, &carg2)
	runtime.KeepAlive(iter)

	var outLink string
	var value   MenuModel
	var goret   bool

	outLink = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	value = UnsafeMenuModelFromGlibFull(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}

	return outLink, value, goret
}

// RegisterMenuLinkIterSubClass is used to register a go subclass of GMenuLinkIter. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuLinkIterSubClass[InstanceT MenuLinkIter](
		name string,
		classInit func(class *MenuLinkIterClass),
		constructor func() InstanceT,
		overrides MenuLinkIterOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuLinkIter,
		UnsafeMenuLinkIterClassFromGlibBorrow,
		UnsafeApplyMenuLinkIterOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuLinkIter(obj)
		},
		interfaceInits...,
	)
}

// MenuModelInstance is the instance type used by all types extending GMenuModel. It is used internally by the bindings. Users should use the interface [MenuModel] instead.
type MenuModelInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MenuModel = (*MenuModelInstance)(nil)

// MenuModel wraps GMenuModel
//
// `GMenuModel` represents the contents of a menu &#x2014; an ordered list of
// menu items. The items are associated with actions, which can be
// activated through them. Items can be grouped in sections, and may
// have submenus associated with them. Both items and sections usually
// have some representation data, such as labels or icons. The type of
// the associated action (ie whether it is stateful, and what kind of
// state it has) can influence the representation of the item.
// 
// The conceptual model of menus in `GMenuModel` is hierarchical:
// sections and submenus are again represented by `GMenuModel`s.
// Menus themselves do not define their own roles. Rather, the role
// of a particular `GMenuModel` is defined by the item that references
// it (or, in the case of the &#x2018;root&#x2019; menu, is defined by the context
// in which it is used).
// 
// As an example, consider the visible portions of this menu:
// 
// ## An example menu
// 
// ![](menu-example.png)
// 
// While this kind of deeply nested menu is no longer considered good UI
// practice, it serves as a good example of the concepts in `GMenuModel`.
// There are 8 &#x2018;menus&#x2019; visible in the screenshot: one menubar, two
// submenus and 5 sections:
// 
// - the toplevel menubar (containing 4 items)
// - the View submenu (containing 3 sections)
// - the first section of the View submenu (containing 2 items)
// - the second section of the View submenu (containing 1 item)
// - the final section of the View submenu (containing 1 item)
// - the Highlight Mode submenu (containing 2 sections)
// - the Sources section (containing 2 items)
// - the Markup section (containing 2 items)
// 
// The [example](#a-menu-example) illustrates the conceptual connection between
// these 8 menus. Each large block in the figure represents a menu and the
// smaller blocks within the large block represent items in that menu. Some
// items contain references to other menus.
// 
// ## A menu example
// 
// &lt;picture&gt;
//   &lt;source srcset="menu-model-dark.svg" media="(prefers-color-scheme: dark)"&gt;
//   &lt;img src="menu-model-light.svg" alt="menu model"&gt;
// &lt;/picture&gt;
// 
// Notice that the separators visible in the [example](#an-example-menu)
// appear nowhere in the [menu model](#a-menu-example). This is because
// separators are not explicitly represented in the menu model. Instead,
// a separator is inserted between any two non-empty sections of a menu.
// Section items can have labels just like any other item. In that case,
// a display system may show a section header instead of a separator.
// 
// The motivation for this abstract model of application controls is
// that modern user interfaces tend to make these controls available
// outside the application. Examples include global menus, jumplists,
// dash boards, etc. To support such uses, it is necessary to &#x2018;export&#x2019;
// information about actions and their representation in menus, which
// is exactly what the action group exporter and the menu model exporter do for
// [iface@Gio.ActionGroup] and [class@Gio.MenuModel]. The client-side
// counterparts to make use of the exported information are
// [class@Gio.DBusActionGroup] and [class@Gio.DBusMenuModel].
// 
// The API of `GMenuModel` is very generic, with iterators for the
// attributes and links of an item, see
// [method@Gio.MenuModel.iterate_item_attributes] and
// [method@Gio.MenuModel.iterate_item_links]. The &#x2018;standard&#x2019; attributes and
// link types have predefined names: `G_MENU_ATTRIBUTE_LABEL`,
// `G_MENU_ATTRIBUTE_ACTION`, `G_MENU_ATTRIBUTE_TARGET`, `G_MENU_LINK_SECTION`
// and `G_MENU_LINK_SUBMENU`.
// 
// Items in a `GMenuModel` represent active controls if they refer to
// an action that can get activated when the user interacts with the
// menu item. The reference to the action is encoded by the string ID
// in the `G_MENU_ATTRIBUTE_ACTION` attribute. An action ID uniquely
// identifies an action in an action group. Which action group(s) provide
// actions depends on the context in which the menu model is used.
// E.g. when the model is exported as the application menu of a
// [`GtkApplication`](https://docs.gtk.org/gtk4/class.Application.html),
// actions can be application-wide or window-specific (and thus come from
// two different action groups). By convention, the application-wide actions
// have names that start with `app.`, while the names of window-specific
// actions start with `win.`.
// 
// While a wide variety of stateful actions is possible, the following
// is the minimum that is expected to be supported by all users of exported
// menu information:
// - an action with no parameter type and no state
// - an action with no parameter type and boolean state
// - an action with string parameter type and string state
// 
// ## Stateless
// 
// A stateless action typically corresponds to an ordinary menu item.
// 
// Selecting such a menu item will activate the action (with no parameter).
// 
// ## Boolean State
// 
// An action with a boolean state will most typically be used with a &#x2018;toggle&#x2019;
// or &#x2018;switch&#x2019; menu item. The state can be set directly, but activating the
// action (with no parameter) results in the state being toggled.
// 
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as &#x2018;checked&#x2019; when the state is true.
// 
// ## String Parameter and State
// 
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of
// radio menu items. Activating the action with a string parameter is
// equivalent to setting that parameter as the state.
// 
// Radio menu items, in addition to being associated with the action, will
// have a target value. Selecting that menu item will result in activation
// of the action with the target value as the parameter. The menu item should
// be rendered as &#x2018;selected&#x2019; when the state of the action is equal to the
// target value of the menu item.
type MenuModel interface {
	gobject.Object
	upcastToGMenuModel() *MenuModelInstance

	// GetItemLink wraps g_menu_model_get_item_link
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 	- link string: the link to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuModel (nullable) 
	//
	// Queries the item at position @item_index in @model for the link
	// specified by @link.
	// 
	// If the link exists, the linked #GMenuModel is returned.  If the link
	// does not exist, %NULL is returned.
	GetItemLink(int32, string) MenuModel
	// GetNItems wraps g_menu_model_get_n_items
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Query the number of items in @model.
	GetNItems() int32
	// IsMutable wraps g_menu_model_is_mutable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Queries if @model is mutable.
	// 
	// An immutable #GMenuModel will never emit the #GMenuModel::items-changed
	// signal. Consumers of the model may make optimisations accordingly.
	IsMutable() bool
	// ItemsChanged wraps g_menu_model_items_changed
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position of the change 
	// 	- removed int32: the number of items removed 
	// 	- added int32: the number of items added 
	//
	// Requests emission of the #GMenuModel::items-changed signal on @model.
	// 
	// This function should never be called except by #GMenuModel
	// subclasses.  Any other calls to this function will very likely lead
	// to a violation of the interface of the model.
	// 
	// The implementation should update its internal representation of the
	// menu before emitting the signal.  The implementation should further
	// expect to receive queries about the new state of the menu (and
	// particularly added menu items) while signal handlers are running.
	// 
	// The implementation must dispatch this call directly from a mainloop
	// entry and not in response to calls -- particularly those from the
	// #GMenuModel API.  Said another way: the menu must not change while
	// user code is running without returning to the mainloop.
	ItemsChanged(int32, int32, int32)
	// IterateItemAttributes wraps g_menu_model_iterate_item_attributes
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuAttributeIter 
	//
	// Creates a #GMenuAttributeIter to iterate over the attributes of
	// the item at position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes(int32) MenuAttributeIter
	// IterateItemLinks wraps g_menu_model_iterate_item_links
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuLinkIter 
	//
	// Creates a #GMenuLinkIter to iterate over the links of the item at
	// position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks(int32) MenuLinkIter
	// ConnectItemsChanged connects the provided callback to the "items-changed" signal
	//
	// Emitted when a change has occurred to the menu.
	// 
	// The only changes that can occur to a menu is that items are removed
	// or added.  Items may not change (except by being removed and added
	// back in the same location).  This signal is capable of describing
	// both of those changes (at the same time).
	// 
	// The signal means that starting at the index @position, @removed
	// items were removed and @added items were added in their place.  If
	// @removed is zero then only items were added.  If @added is zero
	// then only items were removed.
	// 
	// As an example, if the menu contains items a, b, c, d (in that
	// order) and the signal (2, 1, 3) occurs then the new composition of
	// the menu will be a, b, _, _, _, d (with each _ representing some
	// new item).
	// 
	// Signal handlers may query the model (particularly the added items)
	// and expect to see the results of the modification that is being
	// reported.  The signal is emitted after the modification.
	ConnectItemsChanged(func(MenuModel, int32, int32, int32)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentGetItemLink calls the default implementations of the `GMenuModel.get_item_link` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 	- link string: the link to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuModel (nullable) 
	//
	// Queries the item at position @item_index in @model for the link
	// specified by @link.
	// 
	// If the link exists, the linked #GMenuModel is returned.  If the link
	// does not exist, %NULL is returned.
	ParentGetItemLink(itemIndex int32, link string) MenuModel
	// ParentGetNItems calls the default implementations of the `GMenuModel.get_n_items` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Query the number of items in @model.
	ParentGetNItems() int32
	// ParentIsMutable calls the default implementations of the `GMenuModel.is_mutable` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Queries if @model is mutable.
	// 
	// An immutable #GMenuModel will never emit the #GMenuModel::items-changed
	// signal. Consumers of the model may make optimisations accordingly.
	ParentIsMutable() bool
	// ParentIterateItemAttributes calls the default implementations of the `GMenuModel.iterate_item_attributes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuAttributeIter 
	//
	// Creates a #GMenuAttributeIter to iterate over the attributes of
	// the item at position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	ParentIterateItemAttributes(itemIndex int32) MenuAttributeIter
	// ParentIterateItemLinks calls the default implementations of the `GMenuModel.iterate_item_links` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuLinkIter 
	//
	// Creates a #GMenuLinkIter to iterate over the links of the item at
	// position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	ParentIterateItemLinks(itemIndex int32) MenuLinkIter
}

func unsafeWrapMenuModel(base *gobject.ObjectInstance) *MenuModelInstance {
	return &MenuModelInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenuModel,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuModel(inst)
		},
	)
}

func marshalMenuModelInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuModelFromGlibNone is used to convert raw GMenuModel pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuModelFromGlibNone(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibNone(c).(MenuModel)
}

// UnsafeMenuModelFromGlibFull is used to convert raw GMenuModel pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuModelFromGlibFull(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibFull(c).(MenuModel)
}

// UnsafeMenuModelFromGlibBorrow is used to convert raw GMenuModel pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuModelFromGlibBorrow(c unsafe.Pointer) MenuModel {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MenuModel)
}

func (m *MenuModelInstance) upcastToGMenuModel() *MenuModelInstance {
	return m
}

// UnsafeMenuModelToGlibNone is used to convert the instance to it's C value GMenuModel. This is used by the bindings internally.
func UnsafeMenuModelToGlibNone(c MenuModel) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuModelToGlibFull is used to convert the instance to it's C value GMenuModel, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuModelToGlibFull(c MenuModel) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetItemLink wraps g_menu_model_get_item_link
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 	- link string: the link to query 
// 
// The function returns the following values:
// 
// 	- goret MenuModel (nullable) 
//
// Queries the item at position @item_index in @model for the link
// specified by @link.
// 
// If the link exists, the linked #GMenuModel is returned.  If the link
// does not exist, %NULL is returned.
func (model *MenuModelInstance) GetItemLink(itemIndex int32, link string) MenuModel {
	var carg0 *C.GMenuModel // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GMenuModel // return, full, converted, nullable

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_menu_model_get_item_link(carg0, carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetNItems wraps g_menu_model_get_n_items
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Query the number of items in @model.
func (model *MenuModelInstance) GetNItems() int32 {
	var carg0 *C.GMenuModel // in, none, converted
	var cret  C.gint        // return, none, casted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C.g_menu_model_get_n_items(carg0)
	runtime.KeepAlive(model)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsMutable wraps g_menu_model_is_mutable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Queries if @model is mutable.
// 
// An immutable #GMenuModel will never emit the #GMenuModel::items-changed
// signal. Consumers of the model may make optimisations accordingly.
func (model *MenuModelInstance) IsMutable() bool {
	var carg0 *C.GMenuModel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C.g_menu_model_is_mutable(carg0)
	runtime.KeepAlive(model)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ItemsChanged wraps g_menu_model_items_changed
// 
// The function takes the following parameters:
// 
// 	- position int32: the position of the change 
// 	- removed int32: the number of items removed 
// 	- added int32: the number of items added 
//
// Requests emission of the #GMenuModel::items-changed signal on @model.
// 
// This function should never be called except by #GMenuModel
// subclasses.  Any other calls to this function will very likely lead
// to a violation of the interface of the model.
// 
// The implementation should update its internal representation of the
// menu before emitting the signal.  The implementation should further
// expect to receive queries about the new state of the menu (and
// particularly added menu items) while signal handlers are running.
// 
// The implementation must dispatch this call directly from a mainloop
// entry and not in response to calls -- particularly those from the
// #GMenuModel API.  Said another way: the menu must not change while
// user code is running without returning to the mainloop.
func (model *MenuModelInstance) ItemsChanged(position int32, removed int32, added int32) {
	var carg0 *C.GMenuModel // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 C.gint        // in, none, casted
	var carg3 C.gint        // in, none, casted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(position)
	carg2 = C.gint(removed)
	carg3 = C.gint(added)

	C.g_menu_model_items_changed(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// IterateItemAttributes wraps g_menu_model_iterate_item_attributes
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 
// The function returns the following values:
// 
// 	- goret MenuAttributeIter 
//
// Creates a #GMenuAttributeIter to iterate over the attributes of
// the item at position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
func (model *MenuModelInstance) IterateItemAttributes(itemIndex int32) MenuAttributeIter {
	var carg0 *C.GMenuModel         // in, none, converted
	var carg1 C.gint                // in, none, casted
	var cret  *C.GMenuAttributeIter // return, full, converted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C.g_menu_model_iterate_item_attributes(carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuAttributeIter

	goret = UnsafeMenuAttributeIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IterateItemLinks wraps g_menu_model_iterate_item_links
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 
// The function returns the following values:
// 
// 	- goret MenuLinkIter 
//
// Creates a #GMenuLinkIter to iterate over the links of the item at
// position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
func (model *MenuModelInstance) IterateItemLinks(itemIndex int32) MenuLinkIter {
	var carg0 *C.GMenuModel    // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GMenuLinkIter // return, full, converted

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C.g_menu_model_iterate_item_links(carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuLinkIter

	goret = UnsafeMenuLinkIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectItemsChanged connects the provided callback to the "items-changed" signal
//
// Emitted when a change has occurred to the menu.
// 
// The only changes that can occur to a menu is that items are removed
// or added.  Items may not change (except by being removed and added
// back in the same location).  This signal is capable of describing
// both of those changes (at the same time).
// 
// The signal means that starting at the index @position, @removed
// items were removed and @added items were added in their place.  If
// @removed is zero then only items were added.  If @added is zero
// then only items were removed.
// 
// As an example, if the menu contains items a, b, c, d (in that
// order) and the signal (2, 1, 3) occurs then the new composition of
// the menu will be a, b, _, _, _, d (with each _ representing some
// new item).
// 
// Signal handlers may query the model (particularly the added items)
// and expect to see the results of the modification that is being
// reported.  The signal is emitted after the modification.
func (o *MenuModelInstance) ConnectItemsChanged(fn func(MenuModel, int32, int32, int32)) gobject.SignalHandle {
	return o.Connect("items-changed", fn)
}

// MenuModelOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MenuModelOverrides[Instance MenuModel] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetItemLink allows you to override the implementation of the virtual method get_item_link.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 	- link string: the link to query 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuModel (nullable) 
	//
	// Queries the item at position @item_index in @model for the link
	// specified by @link.
	// 
	// If the link exists, the linked #GMenuModel is returned.  If the link
	// does not exist, %NULL is returned.
	GetItemLink func(Instance, int32, string) MenuModel
	// // GetNItems allows you to override the implementation of the virtual method get_n_items.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Query the number of items in @model.
	GetNItems func(Instance) int32
	// // IsMutable allows you to override the implementation of the virtual method is_mutable.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Queries if @model is mutable.
	// 
	// An immutable #GMenuModel will never emit the #GMenuModel::items-changed
	// signal. Consumers of the model may make optimisations accordingly.
	IsMutable func(Instance) bool
	// // IterateItemAttributes allows you to override the implementation of the virtual method iterate_item_attributes.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuAttributeIter 
	//
	// Creates a #GMenuAttributeIter to iterate over the attributes of
	// the item at position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemAttributes func(Instance, int32) MenuAttributeIter
	// // IterateItemLinks allows you to override the implementation of the virtual method iterate_item_links.
	// 
	// The function takes the following parameters:
	// 
	// 	- itemIndex int32: the index of the item 
	// 
	// The function returns the following values:
	// 
	// 	- goret MenuLinkIter 
	//
	// Creates a #GMenuLinkIter to iterate over the links of the item at
	// position @item_index in @model.
	// 
	// You must free the iterator with g_object_unref() when you are done.
	IterateItemLinks func(Instance, int32) MenuLinkIter
}

// UnsafeApplyMenuModelOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMenuModelOverrides[Instance MenuModel](gclass unsafe.Pointer, overrides MenuModelOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMenuModelClass)(gclass)

	if overrides.GetItemLink != nil {
		pclass.get_item_link = (*[0]byte)(C._goglib_gio2_MenuModel_get_item_link)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_get_item_link",
			func(carg0 *C.GMenuModel, carg1 C.gint, carg2 *C.gchar) (cret *C.GMenuModel) {
				var model     Instance  // go GMenuModel subclass
				var itemIndex int32     // in, none, casted
				var link      string    // in, none, string
				var goret     MenuModel // return, full, converted, nullable

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)
				link = C.GoString((*C.char)(unsafe.Pointer(carg2)))

				goret = overrides.GetItemLink(model, itemIndex, link)

				if goret != nil {
					cret = (*C.GMenuModel)(UnsafeMenuModelToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetNItems != nil {
		pclass.get_n_items = (*[0]byte)(C._goglib_gio2_MenuModel_get_n_items)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_get_n_items",
			func(carg0 *C.GMenuModel) (cret C.gint) {
				var model Instance // go GMenuModel subclass
				var goret int32    // return, none, casted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNItems(model)

				cret = C.gint(goret)

				return cret
			},
		)
	}

	if overrides.IsMutable != nil {
		pclass.is_mutable = (*[0]byte)(C._goglib_gio2_MenuModel_is_mutable)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_is_mutable",
			func(carg0 *C.GMenuModel) (cret C.gboolean) {
				var model Instance // go GMenuModel subclass
				var goret bool     // return

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.IsMutable(model)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.IterateItemAttributes != nil {
		pclass.iterate_item_attributes = (*[0]byte)(C._goglib_gio2_MenuModel_iterate_item_attributes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_iterate_item_attributes",
			func(carg0 *C.GMenuModel, carg1 C.gint) (cret *C.GMenuAttributeIter) {
				var model     Instance          // go GMenuModel subclass
				var itemIndex int32             // in, none, casted
				var goret     MenuAttributeIter // return, full, converted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)

				goret = overrides.IterateItemAttributes(model, itemIndex)

				cret = (*C.GMenuAttributeIter)(UnsafeMenuAttributeIterToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.IterateItemLinks != nil {
		pclass.iterate_item_links = (*[0]byte)(C._goglib_gio2_MenuModel_iterate_item_links)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MenuModel_iterate_item_links",
			func(carg0 *C.GMenuModel, carg1 C.gint) (cret *C.GMenuLinkIter) {
				var model     Instance     // go GMenuModel subclass
				var itemIndex int32        // in, none, casted
				var goret     MenuLinkIter // return, full, converted

				model = UnsafeMenuModelFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				itemIndex = int32(carg1)

				goret = overrides.IterateItemLinks(model, itemIndex)

				cret = (*C.GMenuLinkIter)(UnsafeMenuLinkIterToGlibFull(goret))

				return cret
			},
		)
	}
}

// ParentGetItemLink calls the default implementations of the `GMenuModel.get_item_link` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 	- link string: the link to query 
// 
// The function returns the following values:
// 
// 	- goret MenuModel (nullable) 
//
// Queries the item at position @item_index in @model for the link
// specified by @link.
// 
// If the link exists, the linked #GMenuModel is returned.  If the link
// does not exist, %NULL is returned.
func (model *MenuModelInstance) ParentGetItemLink(itemIndex int32, link string) MenuModel {
	var carg0 *C.GMenuModel
	var carg1 C.gint        // in, none, converted
	var carg2 *C.gchar      // in, none, casted
	var cret  *C.GMenuModel // return, full, converted, nullable

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C._goglib_gio2_MenuModel_virtual_get_item_link(unsafe.Pointer(parentclass.get_item_link), carg0, carg1, carg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var goret MenuModel

	if cret != nil {
		goret = UnsafeMenuModelFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetNItems calls the default implementations of the `GMenuModel.get_n_items` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Query the number of items in @model.
func (model *MenuModelInstance) ParentGetNItems() int32 {
	var carg0 *C.GMenuModel
	var cret  C.gint // return, none, casted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C._goglib_gio2_MenuModel_virtual_get_n_items(unsafe.Pointer(parentclass.get_n_items), carg0)
	runtime.KeepAlive(model)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentIsMutable calls the default implementations of the `GMenuModel.is_mutable` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Queries if @model is mutable.
// 
// An immutable #GMenuModel will never emit the #GMenuModel::items-changed
// signal. Consumers of the model may make optimisations accordingly.
func (model *MenuModelInstance) ParentIsMutable() bool {
	var carg0 *C.GMenuModel
	var cret  C.gboolean // return

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))

	cret = C._goglib_gio2_MenuModel_virtual_is_mutable(unsafe.Pointer(parentclass.is_mutable), carg0)
	runtime.KeepAlive(model)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentIterateItemAttributes calls the default implementations of the `GMenuModel.iterate_item_attributes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 
// The function returns the following values:
// 
// 	- goret MenuAttributeIter 
//
// Creates a #GMenuAttributeIter to iterate over the attributes of
// the item at position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
func (model *MenuModelInstance) ParentIterateItemAttributes(itemIndex int32) MenuAttributeIter {
	var carg0 *C.GMenuModel
	var carg1 C.gint                // in, none, converted
	var cret  *C.GMenuAttributeIter // return, full, converted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C._goglib_gio2_MenuModel_virtual_iterate_item_attributes(unsafe.Pointer(parentclass.iterate_item_attributes), carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuAttributeIter

	goret = UnsafeMenuAttributeIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentIterateItemLinks calls the default implementations of the `GMenuModel.iterate_item_links` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- itemIndex int32: the index of the item 
// 
// The function returns the following values:
// 
// 	- goret MenuLinkIter 
//
// Creates a #GMenuLinkIter to iterate over the links of the item at
// position @item_index in @model.
// 
// You must free the iterator with g_object_unref() when you are done.
func (model *MenuModelInstance) ParentIterateItemLinks(itemIndex int32) MenuLinkIter {
	var carg0 *C.GMenuModel
	var carg1 C.gint           // in, none, converted
	var cret  *C.GMenuLinkIter // return, full, converted

	parentclass := (*C.GMenuModelClass)(classdata.PeekParentClass(UnsafeMenuModelToGlibNone(model)))

	carg0 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(model))
	carg1 = C.gint(itemIndex)

	cret = C._goglib_gio2_MenuModel_virtual_iterate_item_links(unsafe.Pointer(parentclass.iterate_item_links), carg0, carg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var goret MenuLinkIter

	goret = UnsafeMenuLinkIterFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterMenuModelSubClass is used to register a go subclass of GMenuModel. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMenuModelSubClass[InstanceT MenuModel](
		name string,
		classInit func(class *MenuModelClass),
		constructor func() InstanceT,
		overrides MenuModelOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMenuModel,
		UnsafeMenuModelClassFromGlibBorrow,
		UnsafeApplyMenuModelOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenuModel(obj)
		},
		interfaceInits...,
	)
}

// MountOperationInstance is the instance type used by all types extending GMountOperation. It is used internally by the bindings. Users should use the interface [MountOperation] instead.
type MountOperationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ MountOperation = (*MountOperationInstance)(nil)

// MountOperation wraps GMountOperation
//
// `GMountOperation` provides a mechanism for interacting with the user.
// It can be used for authenticating mountable operations, such as loop
// mounting files, hard drive partitions or server locations. It can
// also be used to ask the user questions or show a list of applications
// preventing unmount or eject operations from completing.
// 
// Note that `GMountOperation` is used for more than just [iface@Gio.Mount]
// objects &#x2013; for example it is also used in [method@Gio.Drive.start] and
// [method@Gio.Drive.stop].
// 
// Users should instantiate a subclass of this that implements all the
// various callbacks to show the required dialogs, such as
// [`GtkMountOperation`](https://docs.gtk.org/gtk4/class.MountOperation.html).
// If no user interaction is desired (for example when automounting
// filesystems at login time), usually `NULL` can be passed, see each method
// taking a `GMountOperation` for details.
// 
// Throughout the API, the term &#x2018;TCRYPT&#x2019; is used to mean &#x2018;compatible with TrueCrypt and VeraCrypt&#x2019;.
// [TrueCrypt](https://en.wikipedia.org/wiki/TrueCrypt) is a discontinued system for
// encrypting file containers, partitions or whole disks, typically used with Windows.
// [VeraCrypt](https://www.veracrypt.fr/) is a maintained fork of TrueCrypt with various
// improvements and auditing fixes.
type MountOperation interface {
	gobject.Object
	upcastToGMountOperation() *MountOperationInstance

	// GetAnonymous wraps g_mount_operation_get_anonymous
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check to see whether the mount operation is being used
	// for an anonymous user.
	GetAnonymous() bool
	// GetChoice wraps g_mount_operation_get_choice
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets a choice from the mount operation.
	GetChoice() int32
	// GetDomain wraps g_mount_operation_get_domain
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the domain of the mount operation.
	GetDomain() string
	// GetIsTcryptHiddenVolume wraps g_mount_operation_get_is_tcrypt_hidden_volume
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check to see whether the mount operation is being used
	// for a TCRYPT hidden volume.
	GetIsTcryptHiddenVolume() bool
	// GetIsTcryptSystemVolume wraps g_mount_operation_get_is_tcrypt_system_volume
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check to see whether the mount operation is being used
	// for a TCRYPT system volume.
	GetIsTcryptSystemVolume() bool
	// GetPassword wraps g_mount_operation_get_password
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets a password from the mount operation.
	GetPassword() string
	// GetPasswordSave wraps g_mount_operation_get_password_save
	// 
	// The function returns the following values:
	// 
	// 	- goret PasswordSave 
	//
	// Gets the state of saving passwords for the mount operation.
	GetPasswordSave() PasswordSave
	// GetPim wraps g_mount_operation_get_pim
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets a PIM from the mount operation.
	GetPim() uint
	// GetUsername wraps g_mount_operation_get_username
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Get the user name from the mount operation.
	GetUsername() string
	// Reply wraps g_mount_operation_reply
	// 
	// The function takes the following parameters:
	// 
	// 	- result MountOperationResult: a #GMountOperationResult 
	//
	// Emits the #GMountOperation::reply signal.
	Reply(MountOperationResult)
	// SetAnonymous wraps g_mount_operation_set_anonymous
	// 
	// The function takes the following parameters:
	// 
	// 	- anonymous bool: boolean value. 
	//
	// Sets the mount operation to use an anonymous user if @anonymous is %TRUE.
	SetAnonymous(bool)
	// SetChoice wraps g_mount_operation_set_choice
	// 
	// The function takes the following parameters:
	// 
	// 	- choice int32: an integer. 
	//
	// Sets a default choice for the mount operation.
	SetChoice(int32)
	// SetDomain wraps g_mount_operation_set_domain
	// 
	// The function takes the following parameters:
	// 
	// 	- domain string (nullable): the domain to set. 
	//
	// Sets the mount operation's domain.
	SetDomain(string)
	// SetIsTcryptHiddenVolume wraps g_mount_operation_set_is_tcrypt_hidden_volume
	// 
	// The function takes the following parameters:
	// 
	// 	- hiddenVolume bool: boolean value. 
	//
	// Sets the mount operation to use a hidden volume if @hidden_volume is %TRUE.
	SetIsTcryptHiddenVolume(bool)
	// SetIsTcryptSystemVolume wraps g_mount_operation_set_is_tcrypt_system_volume
	// 
	// The function takes the following parameters:
	// 
	// 	- systemVolume bool: boolean value. 
	//
	// Sets the mount operation to use a system volume if @system_volume is %TRUE.
	SetIsTcryptSystemVolume(bool)
	// SetPassword wraps g_mount_operation_set_password
	// 
	// The function takes the following parameters:
	// 
	// 	- password string (nullable): password to set. 
	//
	// Sets the mount operation's password to @password.
	SetPassword(string)
	// SetPasswordSave wraps g_mount_operation_set_password_save
	// 
	// The function takes the following parameters:
	// 
	// 	- save PasswordSave: a set of #GPasswordSave flags. 
	//
	// Sets the state of saving passwords for the mount operation.
	SetPasswordSave(PasswordSave)
	// SetPim wraps g_mount_operation_set_pim
	// 
	// The function takes the following parameters:
	// 
	// 	- pim uint: an unsigned integer. 
	//
	// Sets the mount operation's PIM to @pim.
	SetPim(uint)
	// SetUsername wraps g_mount_operation_set_username
	// 
	// The function takes the following parameters:
	// 
	// 	- username string (nullable): input username. 
	//
	// Sets the user name within @op to @username.
	SetUsername(string)
	// ConnectAborted connects the provided callback to the "aborted" signal
	//
	// Emitted by the backend when e.g. a device becomes unavailable
	// while a mount operation is in progress.
	// 
	// Implementations of GMountOperation should handle this signal
	// by dismissing open password dialogs.
	ConnectAborted(func(MountOperation)) gobject.SignalHandle
	// ConnectAskPassword connects the provided callback to the "ask-password" signal
	//
	// Emitted when a mount operation asks the user for a password.
	// 
	// If the message contains a line break, the first line should be
	// presented as a heading. For example, it may be used as the
	// primary text in a #GtkMessageDialog.
	ConnectAskPassword(func(MountOperation, string, string, string, AskPasswordFlags)) gobject.SignalHandle
	// ConnectReply connects the provided callback to the "reply" signal
	//
	// Emitted when the user has replied to the mount operation.
	ConnectReply(func(MountOperation, MountOperationResult)) gobject.SignalHandle
	// ConnectShowUnmountProgress connects the provided callback to the "show-unmount-progress" signal
	//
	// Emitted when an unmount operation has been busy for more than some time
	// (typically 1.5 seconds).
	// 
	// When unmounting or ejecting a volume, the kernel might need to flush
	// pending data in its buffers to the volume stable storage, and this operation
	// can take a considerable amount of time. This signal may be emitted several
	// times as long as the unmount operation is outstanding, and then one
	// last time when the operation is completed, with @bytes_left set to zero.
	// 
	// Implementations of GMountOperation should handle this signal by
	// showing an UI notification, and then dismiss it, or show another notification
	// of completion, when @bytes_left reaches zero.
	// 
	// If the message contains a line break, the first line should be
	// presented as a heading. For example, it may be used as the
	// primary text in a #GtkMessageDialog.
	ConnectShowUnmountProgress(func(MountOperation, string, int64, int64)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentAborted calls the default implementations of the `GMountOperation.aborted` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	ParentAborted()
	// ParentAskPassword calls the default implementations of the `GMountOperation.ask_password` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string 
	// 	- defaultUser string 
	// 	- defaultDomain string 
	// 	- flags AskPasswordFlags 
	ParentAskPassword(message string, defaultUser string, defaultDomain string, flags AskPasswordFlags)
	// ParentAskQuestion calls the default implementations of the `GMountOperation.ask_question` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: string containing a message to display to the user 
	// 	- choices []string: an array of
	//    strings for each possible choice 
	//
	// Virtual implementation of #GMountOperation::ask-question.
	ParentAskQuestion(message string, choices []string)
	// ParentReply calls the default implementations of the `GMountOperation.reply` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result MountOperationResult: a #GMountOperationResult 
	//
	// Emits the #GMountOperation::reply signal.
	ParentReply(result MountOperationResult)
	// ParentShowUnmountProgress calls the default implementations of the `GMountOperation.show_unmount_progress` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string 
	// 	- timeLeft int64 
	// 	- bytesLeft int64 
	ParentShowUnmountProgress(message string, timeLeft int64, bytesLeft int64)
}

func unsafeWrapMountOperation(base *gobject.ObjectInstance) *MountOperationInstance {
	return &MountOperationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMountOperation,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMountOperation(inst)
		},
	)
}

func marshalMountOperationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMountOperationFromGlibNone is used to convert raw GMountOperation pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMountOperationFromGlibNone(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibNone(c).(MountOperation)
}

// UnsafeMountOperationFromGlibFull is used to convert raw GMountOperation pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMountOperationFromGlibFull(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibFull(c).(MountOperation)
}

// UnsafeMountOperationFromGlibBorrow is used to convert raw GMountOperation pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMountOperationFromGlibBorrow(c unsafe.Pointer) MountOperation {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MountOperation)
}

func (m *MountOperationInstance) upcastToGMountOperation() *MountOperationInstance {
	return m
}

// UnsafeMountOperationToGlibNone is used to convert the instance to it's C value GMountOperation. This is used by the bindings internally.
func UnsafeMountOperationToGlibNone(c MountOperation) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMountOperationToGlibFull is used to convert the instance to it's C value GMountOperation, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMountOperationToGlibFull(c MountOperation) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMountOperation wraps g_mount_operation_new
// 
// The function returns the following values:
// 
// 	- goret MountOperation 
//
// Creates a new mount operation.
func NewMountOperation() MountOperation {
	var cret *C.GMountOperation // return, full, converted

	cret = C.g_mount_operation_new()

	var goret MountOperation

	goret = UnsafeMountOperationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAnonymous wraps g_mount_operation_get_anonymous
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check to see whether the mount operation is being used
// for an anonymous user.
func (op *MountOperationInstance) GetAnonymous() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_anonymous(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetChoice wraps g_mount_operation_get_choice
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets a choice from the mount operation.
func (op *MountOperationInstance) GetChoice() int32 {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.int              // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_choice(carg0)
	runtime.KeepAlive(op)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetDomain wraps g_mount_operation_get_domain
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the domain of the mount operation.
func (op *MountOperationInstance) GetDomain() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_domain(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetIsTcryptHiddenVolume wraps g_mount_operation_get_is_tcrypt_hidden_volume
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check to see whether the mount operation is being used
// for a TCRYPT hidden volume.
func (op *MountOperationInstance) GetIsTcryptHiddenVolume() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_is_tcrypt_hidden_volume(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIsTcryptSystemVolume wraps g_mount_operation_get_is_tcrypt_system_volume
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check to see whether the mount operation is being used
// for a TCRYPT system volume.
func (op *MountOperationInstance) GetIsTcryptSystemVolume() bool {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_is_tcrypt_system_volume(carg0)
	runtime.KeepAlive(op)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetPassword wraps g_mount_operation_get_password
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets a password from the mount operation.
func (op *MountOperationInstance) GetPassword() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_password(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPasswordSave wraps g_mount_operation_get_password_save
// 
// The function returns the following values:
// 
// 	- goret PasswordSave 
//
// Gets the state of saving passwords for the mount operation.
func (op *MountOperationInstance) GetPasswordSave() PasswordSave {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.GPasswordSave    // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_password_save(carg0)
	runtime.KeepAlive(op)

	var goret PasswordSave

	goret = PasswordSave(cret)

	return goret
}

// GetPim wraps g_mount_operation_get_pim
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets a PIM from the mount operation.
func (op *MountOperationInstance) GetPim() uint {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  C.guint            // return, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_pim(carg0)
	runtime.KeepAlive(op)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUsername wraps g_mount_operation_get_username
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Get the user name from the mount operation.
func (op *MountOperationInstance) GetUsername() string {
	var carg0 *C.GMountOperation // in, none, converted
	var cret  *C.char            // return, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	cret = C.g_mount_operation_get_username(carg0)
	runtime.KeepAlive(op)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Reply wraps g_mount_operation_reply
// 
// The function takes the following parameters:
// 
// 	- result MountOperationResult: a #GMountOperationResult 
//
// Emits the #GMountOperation::reply signal.
func (op *MountOperationInstance) Reply(result MountOperationResult) {
	var carg0 *C.GMountOperation      // in, none, converted
	var carg1 C.GMountOperationResult // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GMountOperationResult(result)

	C.g_mount_operation_reply(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// SetAnonymous wraps g_mount_operation_set_anonymous
// 
// The function takes the following parameters:
// 
// 	- anonymous bool: boolean value. 
//
// Sets the mount operation to use an anonymous user if @anonymous is %TRUE.
func (op *MountOperationInstance) SetAnonymous(anonymous bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if anonymous {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_anonymous(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(anonymous)
}

// SetChoice wraps g_mount_operation_set_choice
// 
// The function takes the following parameters:
// 
// 	- choice int32: an integer. 
//
// Sets a default choice for the mount operation.
func (op *MountOperationInstance) SetChoice(choice int32) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.int              // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.int(choice)

	C.g_mount_operation_set_choice(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(choice)
}

// SetDomain wraps g_mount_operation_set_domain
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the domain to set. 
//
// Sets the mount operation's domain.
func (op *MountOperationInstance) SetDomain(domain string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if domain != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_domain(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(domain)
}

// SetIsTcryptHiddenVolume wraps g_mount_operation_set_is_tcrypt_hidden_volume
// 
// The function takes the following parameters:
// 
// 	- hiddenVolume bool: boolean value. 
//
// Sets the mount operation to use a hidden volume if @hidden_volume is %TRUE.
func (op *MountOperationInstance) SetIsTcryptHiddenVolume(hiddenVolume bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if hiddenVolume {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_hidden_volume(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(hiddenVolume)
}

// SetIsTcryptSystemVolume wraps g_mount_operation_set_is_tcrypt_system_volume
// 
// The function takes the following parameters:
// 
// 	- systemVolume bool: boolean value. 
//
// Sets the mount operation to use a system volume if @system_volume is %TRUE.
func (op *MountOperationInstance) SetIsTcryptSystemVolume(systemVolume bool) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.gboolean         // in

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if systemVolume {
		carg1 = C.TRUE
	}

	C.g_mount_operation_set_is_tcrypt_system_volume(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(systemVolume)
}

// SetPassword wraps g_mount_operation_set_password
// 
// The function takes the following parameters:
// 
// 	- password string (nullable): password to set. 
//
// Sets the mount operation's password to @password.
func (op *MountOperationInstance) SetPassword(password string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if password != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_password(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(password)
}

// SetPasswordSave wraps g_mount_operation_set_password_save
// 
// The function takes the following parameters:
// 
// 	- save PasswordSave: a set of #GPasswordSave flags. 
//
// Sets the state of saving passwords for the mount operation.
func (op *MountOperationInstance) SetPasswordSave(save PasswordSave) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.GPasswordSave    // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GPasswordSave(save)

	C.g_mount_operation_set_password_save(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(save)
}

// SetPim wraps g_mount_operation_set_pim
// 
// The function takes the following parameters:
// 
// 	- pim uint: an unsigned integer. 
//
// Sets the mount operation's PIM to @pim.
func (op *MountOperationInstance) SetPim(pim uint) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 C.guint            // in, none, casted

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.guint(pim)

	C.g_mount_operation_set_pim(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(pim)
}

// SetUsername wraps g_mount_operation_set_username
// 
// The function takes the following parameters:
// 
// 	- username string (nullable): input username. 
//
// Sets the user name within @op to @username.
func (op *MountOperationInstance) SetUsername(username string) {
	var carg0 *C.GMountOperation // in, none, converted
	var carg1 *C.char            // in, none, string, nullable-string

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	if username != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_mount_operation_set_username(carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(username)
}

// ConnectAborted connects the provided callback to the "aborted" signal
//
// Emitted by the backend when e.g. a device becomes unavailable
// while a mount operation is in progress.
// 
// Implementations of GMountOperation should handle this signal
// by dismissing open password dialogs.
func (o *MountOperationInstance) ConnectAborted(fn func(MountOperation)) gobject.SignalHandle {
	return o.Connect("aborted", fn)
}

// ConnectAskPassword connects the provided callback to the "ask-password" signal
//
// Emitted when a mount operation asks the user for a password.
// 
// If the message contains a line break, the first line should be
// presented as a heading. For example, it may be used as the
// primary text in a #GtkMessageDialog.
func (o *MountOperationInstance) ConnectAskPassword(fn func(MountOperation, string, string, string, AskPasswordFlags)) gobject.SignalHandle {
	return o.Connect("ask-password", fn)
}

// ConnectReply connects the provided callback to the "reply" signal
//
// Emitted when the user has replied to the mount operation.
func (o *MountOperationInstance) ConnectReply(fn func(MountOperation, MountOperationResult)) gobject.SignalHandle {
	return o.Connect("reply", fn)
}

// ConnectShowUnmountProgress connects the provided callback to the "show-unmount-progress" signal
//
// Emitted when an unmount operation has been busy for more than some time
// (typically 1.5 seconds).
// 
// When unmounting or ejecting a volume, the kernel might need to flush
// pending data in its buffers to the volume stable storage, and this operation
// can take a considerable amount of time. This signal may be emitted several
// times as long as the unmount operation is outstanding, and then one
// last time when the operation is completed, with @bytes_left set to zero.
// 
// Implementations of GMountOperation should handle this signal by
// showing an UI notification, and then dismiss it, or show another notification
// of completion, when @bytes_left reaches zero.
// 
// If the message contains a line break, the first line should be
// presented as a heading. For example, it may be used as the
// primary text in a #GtkMessageDialog.
func (o *MountOperationInstance) ConnectShowUnmountProgress(fn func(MountOperation, string, int64, int64)) gobject.SignalHandle {
	return o.Connect("show-unmount-progress", fn)
}

// MountOperationOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MountOperationOverrides[Instance MountOperation] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Aborted allows you to override the implementation of the virtual method aborted.
	Aborted func(Instance)
	// // AskPassword allows you to override the implementation of the virtual method ask_password.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string 
	// 	- defaultUser string 
	// 	- defaultDomain string 
	// 	- flags AskPasswordFlags 
	AskPassword func(Instance, string, string, string, AskPasswordFlags)
	// // AskQuestion allows you to override the implementation of the virtual method ask_question.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string: string containing a message to display to the user 
	// 	- choices []string: an array of
	//    strings for each possible choice 
	//
	// Virtual implementation of #GMountOperation::ask-question.
	AskQuestion func(Instance, string, []string)
	// // Reply allows you to override the implementation of the virtual method reply.
	// 
	// The function takes the following parameters:
	// 
	// 	- result MountOperationResult: a #GMountOperationResult 
	//
	// Emits the #GMountOperation::reply signal.
	Reply func(Instance, MountOperationResult)
	// // ShowUnmountProgress allows you to override the implementation of the virtual method show_unmount_progress.
	// 
	// The function takes the following parameters:
	// 
	// 	- message string 
	// 	- timeLeft int64 
	// 	- bytesLeft int64 
	ShowUnmountProgress func(Instance, string, int64, int64)
}

// UnsafeApplyMountOperationOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMountOperationOverrides[Instance MountOperation](gclass unsafe.Pointer, overrides MountOperationOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GMountOperationClass)(gclass)

	if overrides.Aborted != nil {
		pclass.aborted = (*[0]byte)(C._goglib_gio2_MountOperation_aborted)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_aborted",
			func(carg0 *C.GMountOperation) {
				var op Instance // go GMountOperation subclass

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Aborted(op)
			},
		)
	}

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._goglib_gio2_MountOperation_ask_password)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_ask_password",
			func(carg0 *C.GMountOperation, carg1 *C.char, carg2 *C.char, carg3 *C.char, carg4 C.GAskPasswordFlags) {
				var op            Instance         // go GMountOperation subclass
				var message       string           // in, none, string
				var defaultUser   string           // in, none, string
				var defaultDomain string           // in, none, string
				var flags         AskPasswordFlags // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				defaultUser = C.GoString((*C.char)(unsafe.Pointer(carg2)))
				defaultDomain = C.GoString((*C.char)(unsafe.Pointer(carg3)))
				flags = AskPasswordFlags(carg4)

				overrides.AskPassword(op, message, defaultUser, defaultDomain, flags)
			},
		)
	}

	if overrides.AskQuestion != nil {
		pclass.ask_question = (*[0]byte)(C._goglib_gio2_MountOperation_ask_question)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_ask_question",
			func(carg0 *C.GMountOperation, carg1 *C.char, carg2 **C.char) {
				var op      Instance // go GMountOperation subclass
				var message string   // in, none, string
				var choices []string // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				_ = choices
				_ = carg2
				panic("unimplemented conversion of []string (const char**) because of unknown reason")

				overrides.AskQuestion(op, message, choices)
			},
		)
	}

	if overrides.Reply != nil {
		pclass.reply = (*[0]byte)(C._goglib_gio2_MountOperation_reply)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_reply",
			func(carg0 *C.GMountOperation, carg1 C.GMountOperationResult) {
				var op     Instance             // go GMountOperation subclass
				var result MountOperationResult // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = MountOperationResult(carg1)

				overrides.Reply(op, result)
			},
		)
	}

	if overrides.ShowUnmountProgress != nil {
		pclass.show_unmount_progress = (*[0]byte)(C._goglib_gio2_MountOperation_show_unmount_progress)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_MountOperation_show_unmount_progress",
			func(carg0 *C.GMountOperation, carg1 *C.gchar, carg2 C.gint64, carg3 C.gint64) {
				var op        Instance // go GMountOperation subclass
				var message   string   // in, none, string
				var timeLeft  int64    // in, none, casted
				var bytesLeft int64    // in, none, casted

				op = UnsafeMountOperationFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				message = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				timeLeft = int64(carg2)
				bytesLeft = int64(carg3)

				overrides.ShowUnmountProgress(op, message, timeLeft, bytesLeft)
			},
		)
	}
}

// ParentAborted calls the default implementations of the `GMountOperation.aborted` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
func (op *MountOperationInstance) ParentAborted() {
	var carg0 *C.GMountOperation

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))

	C._goglib_gio2_MountOperation_virtual_aborted(unsafe.Pointer(parentclass.aborted), carg0)
	runtime.KeepAlive(op)
}

// ParentAskPassword calls the default implementations of the `GMountOperation.ask_password` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- message string 
// 	- defaultUser string 
// 	- defaultDomain string 
// 	- flags AskPasswordFlags 
func (op *MountOperationInstance) ParentAskPassword(message string, defaultUser string, defaultDomain string, flags AskPasswordFlags) {
	var carg0 *C.GMountOperation
	var carg1 *C.char             // in, none, converted
	var carg2 *C.char             // in, none, string
	var carg3 *C.char             // in, none, string
	var carg4 C.GAskPasswordFlags // in, none, string

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(defaultUser)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.char)(unsafe.Pointer(C.CString(defaultDomain)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.GAskPasswordFlags(flags)

	C._goglib_gio2_MountOperation_virtual_ask_password(unsafe.Pointer(parentclass.ask_password), carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(defaultUser)
	runtime.KeepAlive(defaultDomain)
	runtime.KeepAlive(flags)
}

// ParentAskQuestion calls the default implementations of the `GMountOperation.ask_question` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- message string: string containing a message to display to the user 
// 	- choices []string: an array of
//    strings for each possible choice 
//
// Virtual implementation of #GMountOperation::ask-question.
func (op *MountOperationInstance) ParentAskQuestion(message string, choices []string) {
	var carg0 *C.GMountOperation
	var carg1 *C.char  // in, none, converted
	var carg2 **C.char // in, none, string

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	_ = choices
	_ = carg2
	panic("unimplemented conversion of []string (const char**) because of unimplemented: inner pointers in array")

	C._goglib_gio2_MountOperation_virtual_ask_question(unsafe.Pointer(parentclass.ask_question), carg0, carg1, carg2)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(choices)
}

// ParentReply calls the default implementations of the `GMountOperation.reply` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result MountOperationResult: a #GMountOperationResult 
//
// Emits the #GMountOperation::reply signal.
func (op *MountOperationInstance) ParentReply(result MountOperationResult) {
	var carg0 *C.GMountOperation
	var carg1 C.GMountOperationResult // in, none, converted

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = C.GMountOperationResult(result)

	C._goglib_gio2_MountOperation_virtual_reply(unsafe.Pointer(parentclass.reply), carg0, carg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(result)
}

// ParentShowUnmountProgress calls the default implementations of the `GMountOperation.show_unmount_progress` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- message string 
// 	- timeLeft int64 
// 	- bytesLeft int64 
func (op *MountOperationInstance) ParentShowUnmountProgress(message string, timeLeft int64, bytesLeft int64) {
	var carg0 *C.GMountOperation
	var carg1 *C.gchar // in, none, converted
	var carg2 C.gint64 // in, none, string
	var carg3 C.gint64 // in, none, casted

	parentclass := (*C.GMountOperationClass)(classdata.PeekParentClass(UnsafeMountOperationToGlibNone(op)))

	carg0 = (*C.GMountOperation)(UnsafeMountOperationToGlibNone(op))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(timeLeft)
	carg3 = C.gint64(bytesLeft)

	C._goglib_gio2_MountOperation_virtual_show_unmount_progress(unsafe.Pointer(parentclass.show_unmount_progress), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(op)
	runtime.KeepAlive(message)
	runtime.KeepAlive(timeLeft)
	runtime.KeepAlive(bytesLeft)
}

// RegisterMountOperationSubClass is used to register a go subclass of GMountOperation. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMountOperationSubClass[InstanceT MountOperation](
		name string,
		classInit func(class *MountOperationClass),
		constructor func() InstanceT,
		overrides MountOperationOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMountOperation,
		UnsafeMountOperationClassFromGlibBorrow,
		UnsafeApplyMountOperationOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMountOperation(obj)
		},
		interfaceInits...,
	)
}

// NetworkAddressInstance is the instance type used by all types extending GNetworkAddress. It is used internally by the bindings. Users should use the interface [NetworkAddress] instead.
type NetworkAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ NetworkAddress = (*NetworkAddressInstance)(nil)

// NetworkAddress wraps GNetworkAddress
//
// `GNetworkAddress` provides an easy way to resolve a hostname and
// then attempt to connect to that host, handling the possibility of
// multiple IP addresses and multiple address families.
// 
// The enumeration results of resolved addresses *may* be cached as long
// as this object is kept alive which may have unexpected results if
// alive for too long.
// 
// See [iface@Gio.SocketConnectable] for an example of using the connectable
// interface.
type NetworkAddress interface {
	gobject.Object
	upcastToGNetworkAddress() *NetworkAddressInstance

	// GetHostname wraps g_network_address_get_hostname
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
	// depending on what @addr was created with.
	GetHostname() string
	// GetPort wraps g_network_address_get_port
	// 
	// The function returns the following values:
	// 
	// 	- goret uint16 
	//
	// Gets @addr's port number
	GetPort() uint16
	// GetScheme wraps g_network_address_get_scheme
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets @addr's scheme
	GetScheme() string

	// chain up virtual methods:
}

func unsafeWrapNetworkAddress(base *gobject.ObjectInstance) *NetworkAddressInstance {
	return &NetworkAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNetworkAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkAddress(inst)
		},
	)
}

func marshalNetworkAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNetworkAddressFromGlibNone is used to convert raw GNetworkAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibNone(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkAddress)
}

// UnsafeNetworkAddressFromGlibFull is used to convert raw GNetworkAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibFull(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkAddress)
}

// UnsafeNetworkAddressFromGlibBorrow is used to convert raw GNetworkAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkAddressFromGlibBorrow(c unsafe.Pointer) NetworkAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkAddress)
}

func (n *NetworkAddressInstance) upcastToGNetworkAddress() *NetworkAddressInstance {
	return n
}

// UnsafeNetworkAddressToGlibNone is used to convert the instance to it's C value GNetworkAddress. This is used by the bindings internally.
func UnsafeNetworkAddressToGlibNone(c NetworkAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNetworkAddressToGlibFull is used to convert the instance to it's C value GNetworkAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkAddressToGlibFull(c NetworkAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNetworkAddress wraps g_network_address_new
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname 
// 	- port uint16: the port 
// 
// The function returns the following values:
// 
// 	- goret NetworkAddress 
//
// Creates a new #GSocketConnectable for connecting to the given
// @hostname and @port.
// 
// Note that depending on the configuration of the machine, a
// @hostname of `localhost` may refer to the IPv4 loopback address
// only, or to both IPv4 and IPv6; use
// g_network_address_new_loopback() to create a #GNetworkAddress that
// is guaranteed to resolve to both addresses.
func NewNetworkAddress(hostname string, port uint16) NetworkAddress {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(port)

	cret = C.g_network_address_new(carg1, carg2)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)

	var goret NetworkAddress

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewNetworkAddressLoopback wraps g_network_address_new_loopback
// 
// The function takes the following parameters:
// 
// 	- port uint16: the port 
// 
// The function returns the following values:
// 
// 	- goret NetworkAddress 
//
// Creates a new #GSocketConnectable for connecting to the local host
// over a loopback connection to the given @port. This is intended for
// use in connecting to local services which may be running on IPv4 or
// IPv6.
// 
// The connectable will return IPv4 and IPv6 loopback addresses,
// regardless of how the host resolves `localhost`. By contrast,
// g_network_address_new() will often only return an IPv4 address when
// resolving `localhost`, and an IPv6 address for `localhost6`.
// 
// g_network_address_get_hostname() will always return `localhost` for
// a #GNetworkAddress created with this constructor.
func NewNetworkAddressLoopback(port uint16) NetworkAddress {
	var carg1 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = C.guint16(port)

	cret = C.g_network_address_new_loopback(carg1)
	runtime.KeepAlive(port)

	var goret NetworkAddress

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NetworkAddressParse wraps g_network_address_parse
// 
// The function takes the following parameters:
// 
// 	- hostAndPort string: the hostname and optionally a port 
// 	- defaultPort uint16: the default port if not in @host_and_port 
// 
// The function returns the following values:
// 
// 	- goret NetworkAddress 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GSocketConnectable for connecting to the given
// @hostname and @port. May fail and return %NULL in case
// parsing @host_and_port fails.
// 
// @host_and_port may be in any of a number of recognised formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS
// lookup is performed). Quoting with [] is supported for all address
// types. A port override may be specified in the usual way with a
// colon.
// 
// If no port is specified in @host_and_port then @default_port will be
// used as the port number to connect to.
// 
// In general, @host_and_port is expected to be provided by the user
// (allowing them to give the hostname, and a port override if necessary)
// and @default_port is expected to be provided by the application.
// 
// (The port component of @host_and_port can also be specified as a
// service name rather than as a numeric port, but this functionality
// is deprecated, because it depends on the contents of /etc/services,
// which is generally quite sparse on platforms other than Linux.)
func NetworkAddressParse(hostAndPort string, defaultPort uint16) (NetworkAddress, error) {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)

	cret = C.g_network_address_parse(carg1, carg2, &_cerr)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)

	var goret  NetworkAddress
	var _goerr error

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NetworkAddressParseURI wraps g_network_address_parse_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: the hostname and optionally a port 
// 	- defaultPort uint16: The default port if none is found in the URI 
// 
// The function returns the following values:
// 
// 	- goret NetworkAddress 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GSocketConnectable for connecting to the given
// @uri. May fail and return %NULL in case parsing @uri fails.
// 
// Using this rather than g_network_address_new() or
// g_network_address_parse() allows #GSocketClient to determine
// when to use application-specific proxy protocols.
func NetworkAddressParseURI(uri string, defaultPort uint16) (NetworkAddress, error) {
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var cret  *C.GSocketConnectable // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)

	cret = C.g_network_address_parse_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)

	var goret  NetworkAddress
	var _goerr error

	goret = UnsafeNetworkAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetHostname wraps g_network_address_get_hostname
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
// depending on what @addr was created with.
func (addr *NetworkAddressInstance) GetHostname() string {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_hostname(carg0)
	runtime.KeepAlive(addr)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_network_address_get_port
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @addr's port number
func (addr *NetworkAddressInstance) GetPort() uint16 {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  C.guint16          // return, none, casted

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_port(carg0)
	runtime.KeepAlive(addr)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetScheme wraps g_network_address_get_scheme
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @addr's scheme
func (addr *NetworkAddressInstance) GetScheme() string {
	var carg0 *C.GNetworkAddress // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GNetworkAddress)(UnsafeNetworkAddressToGlibNone(addr))

	cret = C.g_network_address_get_scheme(carg0)
	runtime.KeepAlive(addr)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// NetworkAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NetworkAddressOverrides[Instance NetworkAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyNetworkAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNetworkAddressOverrides[Instance NetworkAddress](gclass unsafe.Pointer, overrides NetworkAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterNetworkAddressSubClass is used to register a go subclass of GNetworkAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNetworkAddressSubClass[InstanceT NetworkAddress](
		name string,
		classInit func(class *NetworkAddressClass),
		constructor func() InstanceT,
		overrides NetworkAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNetworkAddress,
		UnsafeNetworkAddressClassFromGlibBorrow,
		UnsafeApplyNetworkAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkAddress(obj)
		},
		interfaceInits...,
	)
}

// NetworkServiceInstance is the instance type used by all types extending GNetworkService. It is used internally by the bindings. Users should use the interface [NetworkService] instead.
type NetworkServiceInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ NetworkService = (*NetworkServiceInstance)(nil)

// NetworkService wraps GNetworkService
//
// Like [class@Gio.NetworkAddress] does with hostnames, `GNetworkService`
// provides an easy way to resolve a SRV record, and then attempt to
// connect to one of the hosts that implements that service, handling
// service priority/weighting, multiple IP addresses, and multiple
// address families.
// 
// See [struct@Gio.SrvTarget] for more information about SRV records, and see
// [iface@Gio.SocketConnectable] for an example of using the connectable
// interface.
type NetworkService interface {
	gobject.Object
	upcastToGNetworkService() *NetworkServiceInstance

	// GetDomain wraps g_network_service_get_domain
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the domain that @srv serves. This might be either UTF-8 or
	// ASCII-encoded, depending on what @srv was created with.
	GetDomain() string
	// GetProtocol wraps g_network_service_get_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets @srv's protocol name (eg, "tcp").
	GetProtocol() string
	// GetScheme wraps g_network_service_get_scheme
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the URI scheme used to resolve proxies. By default, the service name
	// is used as scheme.
	GetScheme() string
	// GetService wraps g_network_service_get_service
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets @srv's service name (eg, "ldap").
	GetService() string
	// SetScheme wraps g_network_service_set_scheme
	// 
	// The function takes the following parameters:
	// 
	// 	- scheme string: a URI scheme 
	//
	// Set's the URI scheme used to resolve proxies. By default, the service name
	// is used as scheme.
	SetScheme(string)

	// chain up virtual methods:
}

func unsafeWrapNetworkService(base *gobject.ObjectInstance) *NetworkServiceInstance {
	return &NetworkServiceInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNetworkService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkService(inst)
		},
	)
}

func marshalNetworkServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNetworkServiceFromGlibNone is used to convert raw GNetworkService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibNone(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibNone(c).(NetworkService)
}

// UnsafeNetworkServiceFromGlibFull is used to convert raw GNetworkService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibFull(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibFull(c).(NetworkService)
}

// UnsafeNetworkServiceFromGlibBorrow is used to convert raw GNetworkService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNetworkServiceFromGlibBorrow(c unsafe.Pointer) NetworkService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NetworkService)
}

func (n *NetworkServiceInstance) upcastToGNetworkService() *NetworkServiceInstance {
	return n
}

// UnsafeNetworkServiceToGlibNone is used to convert the instance to it's C value GNetworkService. This is used by the bindings internally.
func UnsafeNetworkServiceToGlibNone(c NetworkService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNetworkServiceToGlibFull is used to convert the instance to it's C value GNetworkService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNetworkServiceToGlibFull(c NetworkService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNetworkService wraps g_network_service_new
// 
// The function takes the following parameters:
// 
// 	- service string: the service type to look up (eg, "ldap") 
// 	- protocol string: the networking protocol to use for @service (eg, "tcp") 
// 	- domain string: the DNS domain to look up the service in 
// 
// The function returns the following values:
// 
// 	- goret NetworkService 
//
// Creates a new #GNetworkService representing the given @service,
// @protocol, and @domain. This will initially be unresolved; use the
// #GSocketConnectable interface to resolve it.
func NewNetworkService(service string, protocol string, domain string) NetworkService {
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.gchar              // in, none, string
	var cret  *C.GSocketConnectable // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_network_service_new(carg1, carg2, carg3)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var goret NetworkService

	goret = UnsafeNetworkServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDomain wraps g_network_service_get_domain
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the domain that @srv serves. This might be either UTF-8 or
// ASCII-encoded, depending on what @srv was created with.
func (srv *NetworkServiceInstance) GetDomain() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_domain(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetProtocol wraps g_network_service_get_protocol
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @srv's protocol name (eg, "tcp").
func (srv *NetworkServiceInstance) GetProtocol() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_protocol(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetScheme wraps g_network_service_get_scheme
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the URI scheme used to resolve proxies. By default, the service name
// is used as scheme.
func (srv *NetworkServiceInstance) GetScheme() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_scheme(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetService wraps g_network_service_get_service
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @srv's service name (eg, "ldap").
func (srv *NetworkServiceInstance) GetService() string {
	var carg0 *C.GNetworkService // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))

	cret = C.g_network_service_get_service(carg0)
	runtime.KeepAlive(srv)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetScheme wraps g_network_service_set_scheme
// 
// The function takes the following parameters:
// 
// 	- scheme string: a URI scheme 
//
// Set's the URI scheme used to resolve proxies. By default, the service name
// is used as scheme.
func (srv *NetworkServiceInstance) SetScheme(scheme string) {
	var carg0 *C.GNetworkService // in, none, converted
	var carg1 *C.gchar           // in, none, string

	carg0 = (*C.GNetworkService)(UnsafeNetworkServiceToGlibNone(srv))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_network_service_set_scheme(carg0, carg1)
	runtime.KeepAlive(srv)
	runtime.KeepAlive(scheme)
}

// NetworkServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NetworkServiceOverrides[Instance NetworkService] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyNetworkServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNetworkServiceOverrides[Instance NetworkService](gclass unsafe.Pointer, overrides NetworkServiceOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterNetworkServiceSubClass is used to register a go subclass of GNetworkService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNetworkServiceSubClass[InstanceT NetworkService](
		name string,
		classInit func(class *NetworkServiceClass),
		constructor func() InstanceT,
		overrides NetworkServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNetworkService,
		UnsafeNetworkServiceClassFromGlibBorrow,
		UnsafeApplyNetworkServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNetworkService(obj)
		},
		interfaceInits...,
	)
}

// NotificationInstance is the instance type used by all types extending GNotification. It is used internally by the bindings. Users should use the interface [Notification] instead.
type NotificationInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Notification = (*NotificationInstance)(nil)

// Notification wraps GNotification
//
// `GNotification` is a mechanism for creating a notification to be shown
// to the user &#x2014; typically as a pop-up notification presented by the
// desktop environment shell.
// 
// The key difference between `GNotification` and other similar APIs is
// that, if supported by the desktop environment, notifications sent
// with `GNotification` will persist after the application has exited,
// and even across system reboots.
// 
// Since the user may click on a notification while the application is
// not running, applications using `GNotification` should be able to be
// started as a D-Bus service, using [class@Gio.Application].
// 
// In order for `GNotification` to work, the application must have installed
// a `.desktop` file. For example:
// ```
// [Desktop Entry]
// Name=Test Application
// Comment=Description of what Test Application does
// Exec=gnome-test-application
// Icon=org.gnome.TestApplication
// Terminal=false
// Type=Application
// Categories=GNOME;GTK;TestApplication Category;
// StartupNotify=true
// DBusActivatable=true
// X-GNOME-UsesNotifications=true
// ```
// 
// The `X-GNOME-UsesNotifications` key indicates to GNOME Control Center
// that this application uses notifications, so it can be listed in the
// Control Center&#x2019;s &#x2018;Notifications&#x2019; panel.
// 
// The `.desktop` file must be named as `org.gnome.TestApplication.desktop`,
// where `org.gnome.TestApplication` is the ID passed to
// [ctor@Gio.Application.new].
// 
// User interaction with a notification (either the default action, or
// buttons) must be associated with actions on the application (ie:
// `app.` actions).  It is not possible to route user interaction
// through the notification itself, because the object will not exist if
// the application is autostarted as a result of a notification being
// clicked.
// 
// A notification can be sent with [method@Gio.Application.send_notification].
type Notification interface {
	gobject.Object
	upcastToGNotification() *NotificationInstance

	// AddButton wraps g_notification_add_button
	// 
	// The function takes the following parameters:
	// 
	// 	- label string: label of the button 
	// 	- detailedAction string: a detailed action name 
	//
	// Adds a button to @notification that activates the action in
	// @detailed_action when clicked. That action must be an
	// application-wide action (starting with "app."). If @detailed_action
	// contains a target, the action will be activated with that target as
	// its parameter.
	// 
	// See g_action_parse_detailed_name() for a description of the format
	// for @detailed_action.
	AddButton(string, string)
	// SetBody wraps g_notification_set_body
	// 
	// The function takes the following parameters:
	// 
	// 	- body string (nullable): the new body for @notification, or %NULL 
	//
	// Sets the body of @notification to @body.
	SetBody(string)
	// SetCategory wraps g_notification_set_category
	// 
	// The function takes the following parameters:
	// 
	// 	- category string (nullable): the category for @notification, or %NULL for no category 
	//
	// Sets the type of @notification to @category. Categories have a main
	// type like `email`, `im` or `device` and can have a detail separated
	// by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
	// helps the notification server to select proper feedback to the user.
	// 
	// Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
	SetCategory(string)
	// SetDefaultAction wraps g_notification_set_default_action
	// 
	// The function takes the following parameters:
	// 
	// 	- detailedAction string: a detailed action name 
	//
	// Sets the default action of @notification to @detailed_action. This
	// action is activated when the notification is clicked on.
	// 
	// The action in @detailed_action must be an application-wide action (it
	// must start with "app."). If @detailed_action contains a target, the
	// given action will be activated with that target as its parameter.
	// See g_action_parse_detailed_name() for a description of the format
	// for @detailed_action.
	// 
	// When no default action is set, the application that the notification
	// was sent on is activated.
	SetDefaultAction(string)
	// SetIcon wraps g_notification_set_icon
	// 
	// The function takes the following parameters:
	// 
	// 	- icon Icon: the icon to be shown in @notification, as a #GIcon 
	//
	// Sets the icon of @notification to @icon.
	SetIcon(Icon)
	// SetPriority wraps g_notification_set_priority
	// 
	// The function takes the following parameters:
	// 
	// 	- priority NotificationPriority: a #GNotificationPriority 
	//
	// Sets the priority of @notification to @priority. See
	// #GNotificationPriority for possible values.
	SetPriority(NotificationPriority)
	// SetTitle wraps g_notification_set_title
	// 
	// The function takes the following parameters:
	// 
	// 	- title string: the new title for @notification 
	//
	// Sets the title of @notification to @title.
	SetTitle(string)
	// SetUrgent wraps g_notification_set_urgent
	// 
	// The function takes the following parameters:
	// 
	// 	- urgent bool: %TRUE if @notification is urgent 
	//
	// Deprecated in favor of g_notification_set_priority().
	//
	// Deprecated: (since 2.42.0) Since 2.42, this has been deprecated in favour of
	//    g_notification_set_priority().
	SetUrgent(bool)
}

func unsafeWrapNotification(base *gobject.ObjectInstance) *NotificationInstance {
	return &NotificationInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNotification,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNotification(inst)
		},
	)
}

func marshalNotificationInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNotificationFromGlibNone is used to convert raw GNotification pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNotificationFromGlibNone(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibNone(c).(Notification)
}

// UnsafeNotificationFromGlibFull is used to convert raw GNotification pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNotificationFromGlibFull(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibFull(c).(Notification)
}

// UnsafeNotificationFromGlibBorrow is used to convert raw GNotification pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNotificationFromGlibBorrow(c unsafe.Pointer) Notification {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Notification)
}

func (n *NotificationInstance) upcastToGNotification() *NotificationInstance {
	return n
}

// UnsafeNotificationToGlibNone is used to convert the instance to it's C value GNotification. This is used by the bindings internally.
func UnsafeNotificationToGlibNone(c Notification) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNotificationToGlibFull is used to convert the instance to it's C value GNotification, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNotificationToGlibFull(c Notification) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewNotification wraps g_notification_new
// 
// The function takes the following parameters:
// 
// 	- title string: the title of the notification 
// 
// The function returns the following values:
// 
// 	- goret Notification 
//
// Creates a new #GNotification with @title as its title.
// 
// After populating @notification with more details, it can be sent to
// the desktop shell with g_application_send_notification(). Changing
// any properties after this call will not have any effect until
// resending @notification.
func NewNotification(title string) Notification {
	var carg1 *C.gchar         // in, none, string
	var cret  *C.GNotification // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_notification_new(carg1)
	runtime.KeepAlive(title)

	var goret Notification

	goret = UnsafeNotificationFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddButton wraps g_notification_add_button
// 
// The function takes the following parameters:
// 
// 	- label string: label of the button 
// 	- detailedAction string: a detailed action name 
//
// Adds a button to @notification that activates the action in
// @detailed_action when clicked. That action must be an
// application-wide action (starting with "app."). If @detailed_action
// contains a target, the action will be activated with that target as
// its parameter.
// 
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
func (notification *NotificationInstance) AddButton(label string, detailedAction string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_notification_add_button(carg0, carg1, carg2)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// SetBody wraps g_notification_set_body
// 
// The function takes the following parameters:
// 
// 	- body string (nullable): the new body for @notification, or %NULL 
//
// Sets the body of @notification to @body.
func (notification *NotificationInstance) SetBody(body string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if body != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(body)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_notification_set_body(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(body)
}

// SetCategory wraps g_notification_set_category
// 
// The function takes the following parameters:
// 
// 	- category string (nullable): the category for @notification, or %NULL for no category 
//
// Sets the type of @notification to @category. Categories have a main
// type like `email`, `im` or `device` and can have a detail separated
// by a `.`, e.g. `im.received` or `email.arrived`. Setting the category
// helps the notification server to select proper feedback to the user.
// 
// Standard categories are [listed in the specification](https://specifications.freedesktop.org/notification-spec/latest/ar01s06.html).
func (notification *NotificationInstance) SetCategory(category string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if category != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_notification_set_category(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(category)
}

// SetDefaultAction wraps g_notification_set_default_action
// 
// The function takes the following parameters:
// 
// 	- detailedAction string: a detailed action name 
//
// Sets the default action of @notification to @detailed_action. This
// action is activated when the notification is clicked on.
// 
// The action in @detailed_action must be an application-wide action (it
// must start with "app."). If @detailed_action contains a target, the
// given action will be activated with that target as its parameter.
// See g_action_parse_detailed_name() for a description of the format
// for @detailed_action.
// 
// When no default action is set, the application that the notification
// was sent on is activated.
func (notification *NotificationInstance) SetDefaultAction(detailedAction string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_notification_set_default_action(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(detailedAction)
}

// SetIcon wraps g_notification_set_icon
// 
// The function takes the following parameters:
// 
// 	- icon Icon: the icon to be shown in @notification, as a #GIcon 
//
// Sets the icon of @notification to @icon.
func (notification *NotificationInstance) SetIcon(icon Icon) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.GIcon         // in, none, converted

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.GIcon)(UnsafeIconToGlibNone(icon))

	C.g_notification_set_icon(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(icon)
}

// SetPriority wraps g_notification_set_priority
// 
// The function takes the following parameters:
// 
// 	- priority NotificationPriority: a #GNotificationPriority 
//
// Sets the priority of @notification to @priority. See
// #GNotificationPriority for possible values.
func (notification *NotificationInstance) SetPriority(priority NotificationPriority) {
	var carg0 *C.GNotification        // in, none, converted
	var carg1 C.GNotificationPriority // in, none, casted

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = C.GNotificationPriority(priority)

	C.g_notification_set_priority(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(priority)
}

// SetTitle wraps g_notification_set_title
// 
// The function takes the following parameters:
// 
// 	- title string: the new title for @notification 
//
// Sets the title of @notification to @title.
func (notification *NotificationInstance) SetTitle(title string) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_notification_set_title(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(title)
}

// SetUrgent wraps g_notification_set_urgent
// 
// The function takes the following parameters:
// 
// 	- urgent bool: %TRUE if @notification is urgent 
//
// Deprecated in favor of g_notification_set_priority().
//
// Deprecated: (since 2.42.0) Since 2.42, this has been deprecated in favour of
//    g_notification_set_priority().
func (notification *NotificationInstance) SetUrgent(urgent bool) {
	var carg0 *C.GNotification // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GNotification)(UnsafeNotificationToGlibNone(notification))
	if urgent {
		carg1 = C.TRUE
	}

	C.g_notification_set_urgent(carg0, carg1)
	runtime.KeepAlive(notification)
	runtime.KeepAlive(urgent)
}

// OutputStreamInstance is the instance type used by all types extending GOutputStream. It is used internally by the bindings. Users should use the interface [OutputStream] instead.
type OutputStreamInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ OutputStream = (*OutputStreamInstance)(nil)

// OutputStream wraps GOutputStream
//
// `GOutputStream` is a base class for implementing streaming output.
// 
// It has functions to write to a stream ([method@Gio.OutputStream.write]),
// to close a stream ([method@Gio.OutputStream.close]) and to flush pending
// writes ([method@Gio.OutputStream.flush]).
// 
// To copy the content of an input stream to an output stream without
// manually handling the reads and writes, use [method@Gio.OutputStream.splice].
// 
// See the documentation for [class@Gio.IOStream] for details of thread safety
// of streaming APIs.
// 
// All of these functions have async variants too.
// 
// All classes derived from `GOutputStream` *should* implement synchronous
// writing, splicing, flushing and closing streams, but *may* implement
// asynchronous versions.
type OutputStream interface {
	gobject.Object
	upcastToGOutputStream() *OutputStreamInstance

	// ClearPending wraps g_output_stream_clear_pending
	//
	// Clears the pending flag on @stream.
	ClearPending()
	// Close wraps g_output_stream_close
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes the stream, releasing resources related to it.
	// 
	// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
	// Closing a stream multiple times will not return an error.
	// 
	// Closing a stream will automatically flush any outstanding buffers in the
	// stream.
	// 
	// Streams will be automatically closed when the last reference
	// is dropped, but you might want to call this function to make sure
	// resources are released as early as possible.
	// 
	// Some streams might keep the backing store of the stream (e.g. a file descriptor)
	// open after the stream is closed. See the documentation for the individual
	// stream for details.
	// 
	// On failure the first error that happened will be reported, but the close
	// operation will finish as much as possible. A stream that failed to
	// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
	// is important to check and report the error to the user, otherwise
	// there might be a loss of data as all data might not be written.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	// Cancelling a close will still leave the stream closed, but there some streams
	// can use a faster close that doesn't block to e.g. check errors. On
	// cancellation (as with any error) there is no guarantee that all written
	// data will reach the target.
	Close(Cancellable) (bool, error)
	// CloseAsync wraps g_output_stream_close_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Requests an asynchronous close of the stream, releasing resources
	// related to it. When the operation is finished @callback will be
	// called. You can then call g_output_stream_close_finish() to get
	// the result of the operation.
	// 
	// For behaviour details see g_output_stream_close().
	// 
	// The asynchronous methods have a default fallback that uses threads
	// to implement asynchronicity, so they are optional for inheriting
	// classes. However, if you override one you must override all.
	CloseAsync(int32, Cancellable, AsyncReadyCallback)
	// CloseFinish wraps g_output_stream_close_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes an output stream.
	CloseFinish(AsyncResult) (bool, error)
	// Flush wraps g_output_stream_flush
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	// 
	// This function is optional for inherited classes.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Flush(Cancellable) (bool, error)
	// FlushAsync wraps g_output_stream_flush_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Forces an asynchronous write of all user-space buffered data for
	// the given @stream.
	// For behaviour details see g_output_stream_flush().
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_output_stream_flush_finish() to get the
	// result of the operation.
	FlushAsync(int32, Cancellable, AsyncReadyCallback)
	// FlushFinish wraps g_output_stream_flush_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes flushing an output stream.
	FlushFinish(AsyncResult) (bool, error)
	// HasPending wraps g_output_stream_has_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if an output stream has pending actions.
	HasPending() bool
	// IsClosed wraps g_output_stream_is_closed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if an output stream has already been closed.
	IsClosed() bool
	// IsClosing wraps g_output_stream_is_closing
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if an output stream is being closed. This can be
	// used inside e.g. a flush implementation to see if the
	// flush (or other i/o operation) is called from within
	// the closing operation.
	IsClosing() bool
	// SetPending wraps g_output_stream_set_pending
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets @stream to have actions pending. If the pending flag is
	// already set or @stream is closed, it will return %FALSE and set
	// @error.
	SetPending() (bool, error)
	// Splice wraps g_output_stream_splice
	// 
	// The function takes the following parameters:
	// 
	// 	- source InputStream: a #GInputStream. 
	// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Splices an input stream into an output stream.
	Splice(InputStream, OutputStreamSpliceFlags, Cancellable) (int, error)
	// SpliceAsync wraps g_output_stream_splice_async
	// 
	// The function takes the following parameters:
	// 
	// 	- source InputStream: a #GInputStream. 
	// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Splices a stream asynchronously.
	// When the operation is finished @callback will be called.
	// You can then call g_output_stream_splice_finish() to get the
	// result of the operation.
	// 
	// For the synchronous, blocking version of this function, see
	// g_output_stream_splice().
	SpliceAsync(InputStream, OutputStreamSpliceFlags, int32, Cancellable, AsyncReadyCallback)
	// SpliceFinish wraps g_output_stream_splice_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream splice operation.
	SpliceFinish(AsyncResult) (int, error)
	// Write wraps g_output_stream_write
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: the buffer containing the data to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write @count bytes from @buffer into the stream. Will block
	// during the operation.
	// 
	// If count is 0, returns 0 and does nothing. A value of @count
	// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @count is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error -1 is returned and @error is set accordingly.
	Write([]byte, Cancellable) (int, error)
	// WriteAll wraps g_output_stream_write_all
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: the buffer containing the data to write. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that was
	//     written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write @count bytes from @buffer into the stream. Will block
	// during the operation.
	// 
	// This function is similar to g_output_stream_write(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	// 
	// On a successful write of @count bytes, %TRUE is returned, and @bytes_written
	// is set to @count.
	// 
	// If there is an error during the operation %FALSE is returned and @error
	// is set to indicate the error status.
	// 
	// As a special exception to the normal conventions for functions that
	// use #GError, if this function returns %FALSE (and sets @error) then
	// @bytes_written will be set to the number of bytes that were
	// successfully written before the error was encountered.  This
	// functionality is only available from C.  If you need it from another
	// language then you must write your own loop around
	// g_output_stream_write().
	WriteAll([]byte, Cancellable) (uint, bool, error)
	// WriteAllAsync wraps g_output_stream_write_all_async
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: the buffer containing the data to write 
	// 	- ioPriority int32: the io priority of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//     to call when the request is satisfied 
	//
	// Request an asynchronous write of @count bytes from @buffer into
	// the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_write_all_finish() to get the result of the
	// operation.
	// 
	// This is the asynchronous version of g_output_stream_write_all().
	// 
	// Call g_output_stream_write_all_finish() to collect the result.
	// 
	// Any outstanding I/O request with higher priority (lower numerical
	// value) will be executed before an outstanding request with lower
	// priority. Default priority is %G_PRIORITY_DEFAULT.
	// 
	// Note that no copy of @buffer will be made, so it must stay valid
	// until @callback is called.
	WriteAllAsync([]byte, int32, Cancellable, AsyncReadyCallback)
	// WriteAllFinish wraps g_output_stream_write_all_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that was written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream write operation started with
	// g_output_stream_write_all_async().
	// 
	// As a special exception to the normal conventions for functions that
	// use #GError, if this function returns %FALSE (and sets @error) then
	// @bytes_written will be set to the number of bytes that were
	// successfully written before the error was encountered.  This
	// functionality is only available from C.  If you need it from another
	// language then you must write your own loop around
	// g_output_stream_write_async().
	WriteAllFinish(AsyncResult) (uint, bool, error)
	// WriteAsync wraps g_output_stream_write_async
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: the buffer containing the data to write. 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//     to call when the request is satisfied 
	//
	// Request an asynchronous write of @count bytes from @buffer into
	// the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_write_finish() to get the result of the
	// operation.
	// 
	// During an async request no other sync and async calls are allowed,
	// and will result in %G_IO_ERROR_PENDING errors.
	// 
	// A value of @count larger than %G_MAXSSIZE will cause a
	// %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the number of bytes written will be passed to the
	// @callback. It is not an error if this is not the same as the
	// requested size, as it can happen e.g. on a partial I/O error,
	// but generally we try to write as many bytes as requested.
	// 
	// You are guaranteed that this method will never fail with
	// %G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
	// method will just wait until this changes.
	// 
	// Any outstanding I/O request with higher priority (lower numerical
	// value) will be executed before an outstanding request with lower
	// priority. Default priority is %G_PRIORITY_DEFAULT.
	// 
	// The asynchronous methods have a default fallback that uses threads
	// to implement asynchronicity, so they are optional for inheriting
	// classes. However, if you override one you must override all.
	// 
	// For the synchronous, blocking version of this function, see
	// g_output_stream_write().
	// 
	// Note that no copy of @buffer will be made, so it must stay valid
	// until @callback is called. See g_output_stream_write_bytes_async()
	// for a #GBytes version that will automatically hold a reference to
	// the contents (without copying) for the duration of the call.
	WriteAsync([]byte, int32, Cancellable, AsyncReadyCallback)
	// WriteBytes wraps g_output_stream_write_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- bytes *glib.Bytes: the #GBytes to write 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// A wrapper function for g_output_stream_write() which takes a
	// #GBytes as input.  This can be more convenient for use by language
	// bindings or in other cases where the refcounted nature of #GBytes
	// is helpful over a bare pointer interface.
	// 
	// However, note that this function may still perform partial writes,
	// just like g_output_stream_write().  If that occurs, to continue
	// writing, you will need to create a new #GBytes containing just the
	// remaining bytes, using g_bytes_new_from_bytes(). Passing the same
	// #GBytes instance multiple times potentially can result in duplicated
	// data in the output stream.
	WriteBytes(*glib.Bytes, Cancellable) (int, error)
	// WriteBytesAsync wraps g_output_stream_write_bytes_async
	// 
	// The function takes the following parameters:
	// 
	// 	- bytes *glib.Bytes: The bytes to write 
	// 	- ioPriority int32: the io priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// This function is similar to g_output_stream_write_async(), but
	// takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
	// this allows the stream to avoid taking a copy of the data.
	// 
	// However, note that this function may still perform partial writes,
	// just like g_output_stream_write_async(). If that occurs, to continue
	// writing, you will need to create a new #GBytes containing just the
	// remaining bytes, using g_bytes_new_from_bytes(). Passing the same
	// #GBytes instance multiple times potentially can result in duplicated
	// data in the output stream.
	// 
	// For the synchronous, blocking version of this function, see
	// g_output_stream_write_bytes().
	WriteBytesAsync(*glib.Bytes, int32, Cancellable, AsyncReadyCallback)
	// WriteBytesFinish wraps g_output_stream_write_bytes_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream write-from-#GBytes operation.
	WriteBytesFinish(AsyncResult) (int, error)
	// WriteFinish wraps g_output_stream_write_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream write operation.
	WriteFinish(AsyncResult) (int, error)
	// Writev wraps g_output_stream_writev
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were
	//     written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write the bytes contained in the @n_vectors @vectors into the
	// stream. Will block during the operation.
	// 
	// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
	// does nothing.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @n_vectors is 0 or the sum of all bytes in @vectors is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// Some implementations of g_output_stream_writev() may have limitations on the
	// aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
	// are exceeded. For example, when writing to a local file on UNIX platforms,
	// the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
	Writev([]OutputVector, Cancellable) (uint, bool, error)
	// WritevAll wraps g_output_stream_writev_all
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were
	//     written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write the bytes contained in the @n_vectors @vectors into the
	// stream. Will block during the operation.
	// 
	// This function is similar to g_output_stream_writev(), except it tries to
	// write as many bytes as requested, only stopping on an error.
	// 
	// On a successful write of all @n_vectors vectors, %TRUE is returned, and
	// @bytes_written is set to the sum of all the sizes of @vectors.
	// 
	// If there is an error during the operation %FALSE is returned and @error
	// is set to indicate the error status.
	// 
	// As a special exception to the normal conventions for functions that
	// use #GError, if this function returns %FALSE (and sets @error) then
	// @bytes_written will be set to the number of bytes that were
	// successfully written before the error was encountered.  This
	// functionality is only available from C. If you need it from another
	// language then you must write your own loop around
	// g_output_stream_write().
	// 
	// The content of the individual elements of @vectors might be changed by this
	// function.
	WritevAll([]OutputVector, Cancellable) (uint, bool, error)
	// WritevAllAsync wraps g_output_stream_writev_all_async
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- ioPriority int32: the I/O priority of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//     to call when the request is satisfied 
	//
	// Request an asynchronous write of the bytes contained in the @n_vectors @vectors into
	// the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_writev_all_finish() to get the result of the
	// operation.
	// 
	// This is the asynchronous version of g_output_stream_writev_all().
	// 
	// Call g_output_stream_writev_all_finish() to collect the result.
	// 
	// Any outstanding I/O request with higher priority (lower numerical
	// value) will be executed before an outstanding request with lower
	// priority. Default priority is %G_PRIORITY_DEFAULT.
	// 
	// Note that no copy of @vectors will be made, so it must stay valid
	// until @callback is called. The content of the individual elements
	// of @vectors might be changed by this function.
	WritevAllAsync([]OutputVector, int32, Cancellable, AsyncReadyCallback)
	// WritevAllFinish wraps g_output_stream_writev_all_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream write operation started with
	// g_output_stream_writev_all_async().
	// 
	// As a special exception to the normal conventions for functions that
	// use #GError, if this function returns %FALSE (and sets @error) then
	// @bytes_written will be set to the number of bytes that were
	// successfully written before the error was encountered.  This
	// functionality is only available from C.  If you need it from another
	// language then you must write your own loop around
	// g_output_stream_writev_async().
	WritevAllFinish(AsyncResult) (uint, bool, error)
	// WritevAsync wraps g_output_stream_writev_async
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- ioPriority int32: the I/O priority of the request. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//     to call when the request is satisfied 
	//
	// Request an asynchronous write of the bytes contained in @n_vectors @vectors into
	// the stream. When the operation is finished @callback will be called.
	// You can then call g_output_stream_writev_finish() to get the result of the
	// operation.
	// 
	// During an async request no other sync and async calls are allowed,
	// and will result in %G_IO_ERROR_PENDING errors.
	// 
	// On success, the number of bytes written will be passed to the
	// @callback. It is not an error if this is not the same as the
	// requested size, as it can happen e.g. on a partial I/O error,
	// but generally we try to write as many bytes as requested.
	// 
	// You are guaranteed that this method will never fail with
	// %G_IO_ERROR_WOULD_BLOCK &#x2014; if @stream can't accept more data, the
	// method will just wait until this changes.
	// 
	// Any outstanding I/O request with higher priority (lower numerical
	// value) will be executed before an outstanding request with lower
	// priority. Default priority is %G_PRIORITY_DEFAULT.
	// 
	// The asynchronous methods have a default fallback that uses threads
	// to implement asynchronicity, so they are optional for inheriting
	// classes. However, if you override one you must override all.
	// 
	// For the synchronous, blocking version of this function, see
	// g_output_stream_writev().
	// 
	// Note that no copy of @vectors will be made, so it must stay valid
	// until @callback is called.
	WritevAsync([]OutputVector, int32, Cancellable, AsyncReadyCallback)
	// WritevFinish wraps g_output_stream_writev_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream writev operation.
	WritevFinish(AsyncResult) (uint, bool, error)

	// chain up virtual methods:

	// ParentCloseFinish calls the default implementations of the `GOutputStream.close_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes an output stream.
	ParentCloseFinish(result AsyncResult) (bool, error)
	// ParentCloseFn calls the default implementations of the `GOutputStream.close_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentCloseFn(cancellable Cancellable) (bool, error)
	// ParentFlush calls the default implementations of the `GOutputStream.flush` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	// 
	// This function is optional for inherited classes.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ParentFlush(cancellable Cancellable) (bool, error)
	// ParentFlushFinish calls the default implementations of the `GOutputStream.flush_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes flushing an output stream.
	ParentFlushFinish(result AsyncResult) (bool, error)
	// ParentSplice calls the default implementations of the `GOutputStream.splice` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- source InputStream: a #GInputStream. 
	// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Splices an input stream into an output stream.
	ParentSplice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error)
	// ParentSpliceFinish calls the default implementations of the `GOutputStream.splice_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream splice operation.
	ParentSpliceFinish(result AsyncResult) (int, error)
	// ParentWriteFinish calls the default implementations of the `GOutputStream.write_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream write operation.
	ParentWriteFinish(result AsyncResult) (int, error)
	// ParentWriteFn calls the default implementations of the `GOutputStream.write_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte (nullable): the buffer containing the data to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write @count bytes from @buffer into the stream. Will block
	// during the operation.
	// 
	// If count is 0, returns 0 and does nothing. A value of @count
	// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @count is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error -1 is returned and @error is set accordingly.
	ParentWriteFn(buffer []byte, cancellable Cancellable) (int, error)
	// ParentWritevFinish calls the default implementations of the `GOutputStream.writev_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream writev operation.
	ParentWritevFinish(result AsyncResult) (uint, bool, error)
	// ParentWritevFn calls the default implementations of the `GOutputStream.writev_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were
	//     written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write the bytes contained in the @n_vectors @vectors into the
	// stream. Will block during the operation.
	// 
	// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
	// does nothing.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @n_vectors is 0 or the sum of all bytes in @vectors is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// Some implementations of g_output_stream_writev() may have limitations on the
	// aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
	// are exceeded. For example, when writing to a local file on UNIX platforms,
	// the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
	ParentWritevFn(vectors []OutputVector, cancellable Cancellable) (uint, bool, error)
}

func unsafeWrapOutputStream(base *gobject.ObjectInstance) *OutputStreamInstance {
	return &OutputStreamInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapOutputStream(inst)
		},
	)
}

func marshalOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeOutputStreamFromGlibNone is used to convert raw GOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibNone(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(OutputStream)
}

// UnsafeOutputStreamFromGlibFull is used to convert raw GOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibFull(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(OutputStream)
}

// UnsafeOutputStreamFromGlibBorrow is used to convert raw GOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeOutputStreamFromGlibBorrow(c unsafe.Pointer) OutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(OutputStream)
}

func (o *OutputStreamInstance) upcastToGOutputStream() *OutputStreamInstance {
	return o
}

// UnsafeOutputStreamToGlibNone is used to convert the instance to it's C value GOutputStream. This is used by the bindings internally.
func UnsafeOutputStreamToGlibNone(c OutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeOutputStreamToGlibFull is used to convert the instance to it's C value GOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeOutputStreamToGlibFull(c OutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ClearPending wraps g_output_stream_clear_pending
//
// Clears the pending flag on @stream.
func (stream *OutputStreamInstance) ClearPending() {
	var carg0 *C.GOutputStream // in, none, converted

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	C.g_output_stream_clear_pending(carg0)
	runtime.KeepAlive(stream)
}

// Close wraps g_output_stream_close
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes the stream, releasing resources related to it.
// 
// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
// Closing a stream multiple times will not return an error.
// 
// Closing a stream will automatically flush any outstanding buffers in the
// stream.
// 
// Streams will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
// 
// Some streams might keep the backing store of the stream (e.g. a file descriptor)
// open after the stream is closed. See the documentation for the individual
// stream for details.
// 
// On failure the first error that happened will be reported, but the close
// operation will finish as much as possible. A stream that failed to
// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
// is important to check and report the error to the user, otherwise
// there might be a loss of data as all data might not be written.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
// Cancelling a close will still leave the stream closed, but there some streams
// can use a faster close that doesn't block to e.g. check errors. On
// cancellation (as with any error) there is no guarantee that all written
// data will reach the target.
func (stream *OutputStreamInstance) Close(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_close(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CloseAsync wraps g_output_stream_close_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Requests an asynchronous close of the stream, releasing resources
// related to it. When the operation is finished @callback will be
// called. You can then call g_output_stream_close_finish() to get
// the result of the operation.
// 
// For behaviour details see g_output_stream_close().
// 
// The asynchronous methods have a default fallback that uses threads
// to implement asynchronicity, so they are optional for inheriting
// classes. However, if you override one you must override all.
func (stream *OutputStreamInstance) CloseAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_close_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// CloseFinish wraps g_output_stream_close_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes an output stream.
func (stream *OutputStreamInstance) CloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_close_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Flush wraps g_output_stream_flush
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Forces a write of all user-space buffered data for the given
// @stream. Will block during the operation. Closing the stream will
// implicitly cause a flush.
// 
// This function is optional for inherited classes.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *OutputStreamInstance) Flush(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_flush(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FlushAsync wraps g_output_stream_flush_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Forces an asynchronous write of all user-space buffered data for
// the given @stream.
// For behaviour details see g_output_stream_flush().
// 
// When the operation is finished @callback will be
// called. You can then call g_output_stream_flush_finish() to get the
// result of the operation.
func (stream *OutputStreamInstance) FlushAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_flush_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FlushFinish wraps g_output_stream_flush_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes flushing an output stream.
func (stream *OutputStreamInstance) FlushFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_flush_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasPending wraps g_output_stream_has_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an output stream has pending actions.
func (stream *OutputStreamInstance) HasPending() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_has_pending(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosed wraps g_output_stream_is_closed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an output stream has already been closed.
func (stream *OutputStreamInstance) IsClosed() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_is_closed(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsClosing wraps g_output_stream_is_closing
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an output stream is being closed. This can be
// used inside e.g. a flush implementation to see if the
// flush (or other i/o operation) is called from within
// the closing operation.
func (stream *OutputStreamInstance) IsClosing() bool {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_is_closing(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetPending wraps g_output_stream_set_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets @stream to have actions pending. If the pending flag is
// already set or @stream is closed, it will return %FALSE and set
// @error.
func (stream *OutputStreamInstance) SetPending() (bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))

	cret = C.g_output_stream_set_pending(carg0, &_cerr)
	runtime.KeepAlive(stream)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Splice wraps g_output_stream_splice
// 
// The function takes the following parameters:
// 
// 	- source InputStream: a #GInputStream. 
// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Splices an input stream into an output stream.
func (stream *OutputStreamInstance) Splice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream           // in, none, converted
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var cret  C.gssize                   // return, none, casted
	var _cerr *C.GError                  // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_splice(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpliceAsync wraps g_output_stream_splice_async
// 
// The function takes the following parameters:
// 
// 	- source InputStream: a #GInputStream. 
// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Splices a stream asynchronously.
// When the operation is finished @callback will be called.
// You can then call g_output_stream_splice_finish() to get the
// result of the operation.
// 
// For the synchronous, blocking version of this function, see
// g_output_stream_splice().
func (stream *OutputStreamInstance) SpliceAsync(source InputStream, flags OutputStreamSpliceFlags, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream           // in, none, converted
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, casted
	var carg3 C.int                      // in, none, casted
	var carg4 *C.GCancellable            // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback      // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                 // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_splice_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// SpliceFinish wraps g_output_stream_splice_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream splice operation.
func (stream *OutputStreamInstance) SpliceFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_splice_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Write wraps g_output_stream_write
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: the buffer containing the data to write. 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to write @count bytes from @buffer into the stream. Will block
// during the operation.
// 
// If count is 0, returns 0 and does nothing. A value of @count
// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes written to the stream is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. on a partial I/O error, or if there is not enough
// storage in the stream. All writes block until at least one byte
// is written or an error occurs; 0 is never returned (unless
// @count is 0).
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
func (stream *OutputStreamInstance) Write(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg3 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteAll wraps g_output_stream_write_all
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: the buffer containing the data to write. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that was
//     written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to write @count bytes from @buffer into the stream. Will block
// during the operation.
// 
// This function is similar to g_output_stream_write(), except it tries to
// write as many bytes as requested, only stopping on an error.
// 
// On a successful write of @count bytes, %TRUE is returned, and @bytes_written
// is set to @count.
// 
// If there is an error during the operation %FALSE is returned and @error
// is set to indicate the error status.
// 
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_written will be set to the number of bytes that were
// successfully written before the error was encountered.  This
// functionality is only available from C.  If you need it from another
// language then you must write your own loop around
// g_output_stream_write().
func (stream *OutputStreamInstance) WriteAll(buffer []byte, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 unsafe.Pointer   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write_all(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WriteAllAsync wraps g_output_stream_write_all_async
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: the buffer containing the data to write 
// 	- ioPriority int32: the io priority of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//     to call when the request is satisfied 
//
// Request an asynchronous write of @count bytes from @buffer into
// the stream. When the operation is finished @callback will be called.
// You can then call g_output_stream_write_all_finish() to get the result of the
// operation.
// 
// This is the asynchronous version of g_output_stream_write_all().
// 
// Call g_output_stream_write_all_finish() to collect the result.
// 
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
// 
// Note that no copy of @buffer will be made, so it must stay valid
// until @callback is called.
func (stream *OutputStreamInstance) WriteAllAsync(buffer []byte, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 unsafe.Pointer        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_all_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteAllFinish wraps g_output_stream_write_all_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that was written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream write operation started with
// g_output_stream_write_all_async().
// 
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_written will be set to the number of bytes that were
// successfully written before the error was encountered.  This
// functionality is only available from C.  If you need it from another
// language then you must write your own loop around
// g_output_stream_write_async().
func (stream *OutputStreamInstance) WriteAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WriteAsync wraps g_output_stream_write_async
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: the buffer containing the data to write. 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//     to call when the request is satisfied 
//
// Request an asynchronous write of @count bytes from @buffer into
// the stream. When the operation is finished @callback will be called.
// You can then call g_output_stream_write_finish() to get the result of the
// operation.
// 
// During an async request no other sync and async calls are allowed,
// and will result in %G_IO_ERROR_PENDING errors.
// 
// A value of @count larger than %G_MAXSSIZE will cause a
// %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes written will be passed to the
// @callback. It is not an error if this is not the same as the
// requested size, as it can happen e.g. on a partial I/O error,
// but generally we try to write as many bytes as requested.
// 
// You are guaranteed that this method will never fail with
// %G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
// method will just wait until this changes.
// 
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
// 
// The asynchronous methods have a default fallback that uses threads
// to implement asynchronicity, so they are optional for inheriting
// classes. However, if you override one you must override all.
// 
// For the synchronous, blocking version of this function, see
// g_output_stream_write().
// 
// Note that no copy of @buffer will be made, so it must stay valid
// until @callback is called. See g_output_stream_write_bytes_async()
// for a #GBytes version that will automatically hold a reference to
// the contents (without copying) for the duration of the call.
func (stream *OutputStreamInstance) WriteAsync(buffer []byte, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 unsafe.Pointer        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteBytes wraps g_output_stream_write_bytes
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: the #GBytes to write 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// A wrapper function for g_output_stream_write() which takes a
// #GBytes as input.  This can be more convenient for use by language
// bindings or in other cases where the refcounted nature of #GBytes
// is helpful over a bare pointer interface.
// 
// However, note that this function may still perform partial writes,
// just like g_output_stream_write().  If that occurs, to continue
// writing, you will need to create a new #GBytes containing just the
// remaining bytes, using g_bytes_new_from_bytes(). Passing the same
// #GBytes instance multiple times potentially can result in duplicated
// data in the output stream.
func (stream *OutputStreamInstance) WriteBytes(bytes *glib.Bytes, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GBytes        // in, none, converted
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_write_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteBytesAsync wraps g_output_stream_write_bytes_async
// 
// The function takes the following parameters:
// 
// 	- bytes *glib.Bytes: The bytes to write 
// 	- ioPriority int32: the io priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// This function is similar to g_output_stream_write_async(), but
// takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
// this allows the stream to avoid taking a copy of the data.
// 
// However, note that this function may still perform partial writes,
// just like g_output_stream_write_async(). If that occurs, to continue
// writing, you will need to create a new #GBytes containing just the
// remaining bytes, using g_bytes_new_from_bytes(). Passing the same
// #GBytes instance multiple times potentially can result in duplicated
// data in the output stream.
// 
// For the synchronous, blocking version of this function, see
// g_output_stream_write_bytes().
func (stream *OutputStreamInstance) WriteBytesAsync(bytes *glib.Bytes, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GBytes             // in, none, converted
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GBytes)(glib.UnsafeBytesToGlibNone(bytes))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_write_bytes_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WriteBytesFinish wraps g_output_stream_write_bytes_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream write-from-#GBytes operation.
func (stream *OutputStreamInstance) WriteBytesFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_bytes_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteFinish wraps g_output_stream_write_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream write operation.
func (stream *OutputStreamInstance) WriteFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  C.gssize         // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_write_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Writev wraps g_output_stream_writev
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were
//     written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to write the bytes contained in the @n_vectors @vectors into the
// stream. Will block during the operation.
// 
// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
// does nothing.
// 
// On success, the number of bytes written to the stream is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. on a partial I/O error, or if there is not enough
// storage in the stream. All writes block until at least one byte
// is written or an error occurs; 0 is never returned (unless
// @n_vectors is 0 or the sum of all bytes in @vectors is 0).
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
func (stream *OutputStreamInstance) Writev(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GOutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_writev(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAll wraps g_output_stream_writev_all
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were
//     written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to write the bytes contained in the @n_vectors @vectors into the
// stream. Will block during the operation.
// 
// This function is similar to g_output_stream_writev(), except it tries to
// write as many bytes as requested, only stopping on an error.
// 
// On a successful write of all @n_vectors vectors, %TRUE is returned, and
// @bytes_written is set to the sum of all the sizes of @vectors.
// 
// If there is an error during the operation %FALSE is returned and @error
// is set to indicate the error status.
// 
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_written will be set to the number of bytes that were
// successfully written before the error was encountered.  This
// functionality is only available from C. If you need it from another
// language then you must write your own loop around
// g_output_stream_write().
// 
// The content of the individual elements of @vectors might be changed by this
// function.
func (stream *OutputStreamInstance) WritevAll(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GOutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize          // implicit
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_output_stream_writev_all(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAllAsync wraps g_output_stream_writev_all_async
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- ioPriority int32: the I/O priority of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//     to call when the request is satisfied 
//
// Request an asynchronous write of the bytes contained in the @n_vectors @vectors into
// the stream. When the operation is finished @callback will be called.
// You can then call g_output_stream_writev_all_finish() to get the result of the
// operation.
// 
// This is the asynchronous version of g_output_stream_writev_all().
// 
// Call g_output_stream_writev_all_finish() to collect the result.
// 
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
// 
// Note that no copy of @vectors will be made, so it must stay valid
// until @callback is called. The content of the individual elements
// of @vectors might be changed by this function.
func (stream *OutputStreamInstance) WritevAllAsync(vectors []OutputVector, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GOutputVector      // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_writev_all_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WritevAllFinish wraps g_output_stream_writev_all_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream write operation started with
// g_output_stream_writev_all_async().
// 
// As a special exception to the normal conventions for functions that
// use #GError, if this function returns %FALSE (and sets @error) then
// @bytes_written will be set to the number of bytes that were
// successfully written before the error was encountered.  This
// functionality is only available from C.  If you need it from another
// language then you must write your own loop around
// g_output_stream_writev_async().
func (stream *OutputStreamInstance) WritevAllFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_writev_all_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// WritevAsync wraps g_output_stream_writev_async
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- ioPriority int32: the I/O priority of the request. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//     to call when the request is satisfied 
//
// Request an asynchronous write of the bytes contained in @n_vectors @vectors into
// the stream. When the operation is finished @callback will be called.
// You can then call g_output_stream_writev_finish() to get the result of the
// operation.
// 
// During an async request no other sync and async calls are allowed,
// and will result in %G_IO_ERROR_PENDING errors.
// 
// On success, the number of bytes written will be passed to the
// @callback. It is not an error if this is not the same as the
// requested size, as it can happen e.g. on a partial I/O error,
// but generally we try to write as many bytes as requested.
// 
// You are guaranteed that this method will never fail with
// %G_IO_ERROR_WOULD_BLOCK &#x2014; if @stream can't accept more data, the
// method will just wait until this changes.
// 
// Any outstanding I/O request with higher priority (lower numerical
// value) will be executed before an outstanding request with lower
// priority. Default priority is %G_PRIORITY_DEFAULT.
// 
// The asynchronous methods have a default fallback that uses threads
// to implement asynchronicity, so they are optional for inheriting
// classes. However, if you override one you must override all.
// 
// For the synchronous, blocking version of this function, see
// g_output_stream_writev().
// 
// Note that no copy of @vectors will be made, so it must stay valid
// until @callback is called.
func (stream *OutputStreamInstance) WritevAsync(vectors []OutputVector, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GOutputStream      // in, none, converted
	var carg1 *C.GOutputVector      // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg2 C.gsize               // implicit
	var carg3 C.int                 // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	carg3 = C.int(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_output_stream_writev_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// WritevFinish wraps g_output_stream_writev_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream writev operation.
func (stream *OutputStreamInstance) WritevFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var carg2 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_output_stream_writev_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// OutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type OutputStreamOverrides[Instance OutputStream] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CloseFinish allows you to override the implementation of the virtual method close_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes an output stream.
	CloseFinish func(Instance, AsyncResult) (bool, error)
	// // CloseFn allows you to override the implementation of the virtual method close_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	CloseFn func(Instance, Cancellable) (bool, error)
	// // Flush allows you to override the implementation of the virtual method flush.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Forces a write of all user-space buffered data for the given
	// @stream. Will block during the operation. Closing the stream will
	// implicitly cause a flush.
	// 
	// This function is optional for inherited classes.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Flush func(Instance, Cancellable) (bool, error)
	// // FlushFinish allows you to override the implementation of the virtual method flush_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes flushing an output stream.
	FlushFinish func(Instance, AsyncResult) (bool, error)
	// // Splice allows you to override the implementation of the virtual method splice.
	// 
	// The function takes the following parameters:
	// 
	// 	- source InputStream: a #GInputStream. 
	// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Splices an input stream into an output stream.
	Splice func(Instance, InputStream, OutputStreamSpliceFlags, Cancellable) (int, error)
	// // SpliceFinish allows you to override the implementation of the virtual method splice_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous stream splice operation.
	SpliceFinish func(Instance, AsyncResult) (int, error)
	// // WriteFinish allows you to override the implementation of the virtual method write_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream write operation.
	WriteFinish func(Instance, AsyncResult) (int, error)
	// // WriteFn allows you to override the implementation of the virtual method write_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte (nullable): the buffer containing the data to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write @count bytes from @buffer into the stream. Will block
	// during the operation.
	// 
	// If count is 0, returns 0 and does nothing. A value of @count
	// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @count is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error -1 is returned and @error is set accordingly.
	WriteFn func(Instance, []byte, Cancellable) (int, error)
	// // WritevFinish allows you to override the implementation of the virtual method writev_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes a stream writev operation.
	WritevFinish func(Instance, AsyncResult) (uint, bool, error)
	// // WritevFn allows you to override the implementation of the virtual method writev_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
	// 	- cancellable Cancellable (nullable): optional cancellable object 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were
	//     written to the stream 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to write the bytes contained in the @n_vectors @vectors into the
	// stream. Will block during the operation.
	// 
	// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
	// does nothing.
	// 
	// On success, the number of bytes written to the stream is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. on a partial I/O error, or if there is not enough
	// storage in the stream. All writes block until at least one byte
	// is written or an error occurs; 0 is never returned (unless
	// @n_vectors is 0 or the sum of all bytes in @vectors is 0).
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
	// operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// Some implementations of g_output_stream_writev() may have limitations on the
	// aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
	// are exceeded. For example, when writing to a local file on UNIX platforms,
	// the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
	WritevFn func(Instance, []OutputVector, Cancellable) (uint, bool, error)
}

// UnsafeApplyOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyOutputStreamOverrides[Instance OutputStream](gclass unsafe.Pointer, overrides OutputStreamOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GOutputStreamClass)(gclass)

	if overrides.CloseFinish != nil {
		pclass.close_finish = (*[0]byte)(C._goglib_gio2_OutputStream_close_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_close_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.CloseFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.CloseFn != nil {
		pclass.close_fn = (*[0]byte)(C._goglib_gio2_OutputStream_close_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_close_fn",
			func(carg0 *C.GOutputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GOutputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.CloseFn(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Flush != nil {
		pclass.flush = (*[0]byte)(C._goglib_gio2_OutputStream_flush)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_flush",
			func(carg0 *C.GOutputStream, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GOutputStream subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Flush(stream, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.FlushFinish != nil {
		pclass.flush_finish = (*[0]byte)(C._goglib_gio2_OutputStream_flush_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_flush_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.FlushFinish(stream, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Splice != nil {
		pclass.splice = (*[0]byte)(C._goglib_gio2_OutputStream_splice)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_splice",
			func(carg0 *C.GOutputStream, carg1 *C.GInputStream, carg2 C.GOutputStreamSpliceFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance                // go GOutputStream subclass
				var source      InputStream             // in, none, converted
				var flags       OutputStreamSpliceFlags // in, none, casted
				var cancellable Cancellable             // in, none, converted, nullable
				var goret       int                     // return, none, casted
				var _goerr      error                   // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				source = UnsafeInputStreamFromGlibNone(unsafe.Pointer(carg1))
				flags = OutputStreamSpliceFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Splice(stream, source, flags, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.SpliceFinish != nil {
		pclass.splice_finish = (*[0]byte)(C._goglib_gio2_OutputStream_splice_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_splice_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.SpliceFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WriteFinish != nil {
		pclass.write_finish = (*[0]byte)(C._goglib_gio2_OutputStream_write_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_write_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.WriteFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WriteFn != nil {
		pclass.write_fn = (*[0]byte)(C._goglib_gio2_OutputStream_write_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_write_fn",
			func(carg0 *C.GOutputStream, carg1 unsafe.Pointer, carg2 C.gsize, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GOutputStream subclass
				var buffer      []byte      // in, transfer: none, C Pointers: 1, Name: array[unknown], nullable, array (inner unknown, length-by: carg2)
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = buffer
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []byte (void*) because of unknown reason")
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.WriteFn(stream, buffer, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WritevFinish != nil {
		pclass.writev_finish = (*[0]byte)(C._goglib_gio2_OutputStream_writev_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_writev_finish",
			func(carg0 *C.GOutputStream, carg1 *C.GAsyncResult, carg2 *C.gsize, _cerr **C.GError) (cret C.gboolean) {
				var stream       Instance    // go GOutputStream subclass
				var result       AsyncResult // in, none, converted
				var bytesWritten uint        // out, full, casted
				var goret        bool        // return
				var _goerr       error       // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				bytesWritten, goret, _goerr = overrides.WritevFinish(stream, result)

				*carg2 = C.gsize(bytesWritten)
				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.WritevFn != nil {
		pclass.writev_fn = (*[0]byte)(C._goglib_gio2_OutputStream_writev_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_OutputStream_writev_fn",
			func(carg0 *C.GOutputStream, carg1 *C.GOutputVector, carg2 C.gsize, carg3 *C.gsize, carg4 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream       Instance       // go GOutputStream subclass
				var vectors      []OutputVector // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
				var cancellable  Cancellable    // in, none, converted, nullable
				var bytesWritten uint           // out, full, casted
				var goret        bool           // return
				var _goerr       error          // out, full, converted

				stream = UnsafeOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = vectors
				_ = carg1
				_ = carg2
				panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unknown reason")
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				bytesWritten, goret, _goerr = overrides.WritevFn(stream, vectors, cancellable)

				*carg3 = C.gsize(bytesWritten)
				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCloseFinish calls the default implementations of the `GOutputStream.close_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes an output stream.
func (stream *OutputStreamInstance) ParentCloseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_close_finish(unsafe.Pointer(parentclass.close_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentCloseFn calls the default implementations of the `GOutputStream.close_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *OutputStreamInstance) ParentCloseFn(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_close_fn(unsafe.Pointer(parentclass.close_fn), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFlush calls the default implementations of the `GOutputStream.flush` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Forces a write of all user-space buffered data for the given
// @stream. Will block during the operation. Closing the stream will
// implicitly cause a flush.
// 
// This function is optional for inherited classes.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *OutputStreamInstance) ParentFlush(cancellable Cancellable) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_flush(unsafe.Pointer(parentclass.flush), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFlushFinish calls the default implementations of the `GOutputStream.flush_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes flushing an output stream.
func (stream *OutputStreamInstance) ParentFlushFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_flush_finish(unsafe.Pointer(parentclass.flush_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSplice calls the default implementations of the `GOutputStream.splice` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- source InputStream: a #GInputStream. 
// 	- flags OutputStreamSpliceFlags: a set of #GOutputStreamSpliceFlags. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Splices an input stream into an output stream.
func (stream *OutputStreamInstance) ParentSplice(source InputStream, flags OutputStreamSpliceFlags, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GInputStream            // in, none, converted
	var carg2 C.GOutputStreamSpliceFlags // in, none, converted
	var carg3 *C.GCancellable            // in, none, casted
	var cret  C.gssize                   // return, none, casted
	var _cerr *C.GError                  // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(source))
	carg2 = C.GOutputStreamSpliceFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_splice(unsafe.Pointer(parentclass.splice), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(source)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSpliceFinish calls the default implementations of the `GOutputStream.splice_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous stream splice operation.
func (stream *OutputStreamInstance) ParentSpliceFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_splice_finish(unsafe.Pointer(parentclass.splice_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWriteFinish calls the default implementations of the `GOutputStream.write_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream write operation.
func (stream *OutputStreamInstance) ParentWriteFinish(result AsyncResult) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_write_finish(unsafe.Pointer(parentclass.write_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWriteFn calls the default implementations of the `GOutputStream.write_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- buffer []byte (nullable): the buffer containing the data to write. 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to write @count bytes from @buffer into the stream. Will block
// during the operation.
// 
// If count is 0, returns 0 and does nothing. A value of @count
// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
// 
// On success, the number of bytes written to the stream is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. on a partial I/O error, or if there is not enough
// storage in the stream. All writes block until at least one byte
// is written or an error occurs; 0 is never returned (unless
// @count is 0).
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error -1 is returned and @error is set accordingly.
func (stream *OutputStreamInstance) ParentWriteFn(buffer []byte, cancellable Cancellable) (int, error) {
	var carg0 *C.GOutputStream
	var carg1 unsafe.Pointer  // in, none, converted
	var carg2 C.gsize         // in, transfer: none, C Pointers: 1, Name: array[unknown], nullable, array (inner unknown, length-by: carg2)
	var carg3 *C.GCancellable // implicit
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_write_fn(unsafe.Pointer(parentclass.write_fn), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentWritevFinish calls the default implementations of the `GOutputStream.writev_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finishes a stream writev operation.
func (stream *OutputStreamInstance) ParentWritevFinish(result AsyncResult) (uint, bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var carg2 C.gsize         // out, full, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_OutputStream_virtual_writev_finish(unsafe.Pointer(parentclass.writev_finish), carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg2)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// ParentWritevFn calls the default implementations of the `GOutputStream.writev_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- vectors []OutputVector: the buffer containing the #GOutputVectors to write. 
// 	- cancellable Cancellable (nullable): optional cancellable object 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were
//     written to the stream 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Tries to write the bytes contained in the @n_vectors @vectors into the
// stream. Will block during the operation.
// 
// If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
// does nothing.
// 
// On success, the number of bytes written to the stream is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. on a partial I/O error, or if there is not enough
// storage in the stream. All writes block until at least one byte
// is written or an error occurs; 0 is never returned (unless
// @n_vectors is 0 or the sum of all bytes in @vectors is 0).
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
// operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed %G_MAXSSIZE bytes.
func (stream *OutputStreamInstance) ParentWritevFn(vectors []OutputVector, cancellable Cancellable) (uint, bool, error) {
	var carg0 *C.GOutputStream
	var carg1 *C.GOutputVector // in, none, converted
	var carg2 C.gsize          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg2)
	var carg4 *C.GCancellable  // implicit
	var carg3 C.gsize          // out, full, casted
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	parentclass := (*C.GOutputStreamClass)(classdata.PeekParentClass(UnsafeOutputStreamToGlibNone(stream)))

	carg0 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(stream))
	_ = vectors
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_OutputStream_virtual_writev_fn(unsafe.Pointer(parentclass.writev_fn), carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        bool
	var _goerr       error

	bytesWritten = uint(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// RegisterOutputStreamSubClass is used to register a go subclass of GOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterOutputStreamSubClass[InstanceT OutputStream](
		name string,
		classInit func(class *OutputStreamClass),
		constructor func() InstanceT,
		overrides OutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeOutputStream,
		UnsafeOutputStreamClassFromGlibBorrow,
		UnsafeApplyOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapOutputStream(obj)
		},
		interfaceInits...,
	)
}

// PermissionInstance is the instance type used by all types extending GPermission. It is used internally by the bindings. Users should use the interface [Permission] instead.
type PermissionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Permission = (*PermissionInstance)(nil)

// Permission wraps GPermission
//
// A `GPermission` represents the status of the caller&#x2019;s permission to
// perform a certain action.
// 
// You can query if the action is currently allowed and if it is
// possible to acquire the permission so that the action will be allowed
// in the future.
// 
// There is also an API to actually acquire the permission and one to
// release it.
// 
// As an example, a `GPermission` might represent the ability for the
// user to write to a [class@Gio.Settings] object.  This `GPermission` object
// could then be used to decide if it is appropriate to show a &#x201C;Click here to
// unlock&#x201D; button in a dialog and to provide the mechanism to invoke
// when that button is clicked.
type Permission interface {
	gobject.Object
	upcastToGPermission() *PermissionInstance

	// Acquire wraps g_permission_acquire
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to acquire the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  A simple example is
	// that a dialog may appear asking the user to enter their password.
	// 
	// You should check with g_permission_get_can_acquire() before calling
	// this function.
	// 
	// If the permission is acquired then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_acquire_async() for
	// the non-blocking version.
	Acquire(Cancellable) (bool, error)
	// AcquireAsync wraps g_permission_acquire_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): the #GAsyncReadyCallback to call when done 
	//
	// Attempts to acquire the permission represented by @permission.
	// 
	// This is the first half of the asynchronous version of
	// g_permission_acquire().
	AcquireAsync(Cancellable, AsyncReadyCallback)
	// AcquireFinish wraps g_permission_acquire_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to acquire the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	AcquireFinish(AsyncResult) (bool, error)
	// GetAllowed wraps g_permission_get_allowed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value of the 'allowed' property.  This property is %TRUE if
	// the caller currently has permission to perform the action that
	// @permission represents the permission to perform.
	GetAllowed() bool
	// GetCanAcquire wraps g_permission_get_can_acquire
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value of the 'can-acquire' property.  This property is %TRUE
	// if it is generally possible to acquire the permission by calling
	// g_permission_acquire().
	GetCanAcquire() bool
	// GetCanRelease wraps g_permission_get_can_release
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value of the 'can-release' property.  This property is %TRUE
	// if it is generally possible to release the permission by calling
	// g_permission_release().
	GetCanRelease() bool
	// ImplUpdate wraps g_permission_impl_update
	// 
	// The function takes the following parameters:
	// 
	// 	- allowed bool: the new value for the 'allowed' property 
	// 	- canAcquire bool: the new value for the 'can-acquire' property 
	// 	- canRelease bool: the new value for the 'can-release' property 
	//
	// This function is called by the #GPermission implementation to update
	// the properties of the permission.  You should never call this
	// function except from a #GPermission implementation.
	// 
	// GObject notify signals are generated, as appropriate.
	ImplUpdate(bool, bool, bool)
	// Release wraps g_permission_release
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to release the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  In most cases the
	// permission will be dropped immediately without further action.
	// 
	// You should check with g_permission_get_can_release() before calling
	// this function.
	// 
	// If the permission is released then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_release_async() for
	// the non-blocking version.
	Release(Cancellable) (bool, error)
	// ReleaseAsync wraps g_permission_release_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): the #GAsyncReadyCallback to call when done 
	//
	// Attempts to release the permission represented by @permission.
	// 
	// This is the first half of the asynchronous version of
	// g_permission_release().
	ReleaseAsync(Cancellable, AsyncReadyCallback)
	// ReleaseFinish wraps g_permission_release_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to release the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_release().
	ReleaseFinish(AsyncResult) (bool, error)

	// chain up virtual methods:

	// ParentAcquire calls the default implementations of the `GPermission.acquire` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to acquire the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  A simple example is
	// that a dialog may appear asking the user to enter their password.
	// 
	// You should check with g_permission_get_can_acquire() before calling
	// this function.
	// 
	// If the permission is acquired then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_acquire_async() for
	// the non-blocking version.
	ParentAcquire(cancellable Cancellable) (bool, error)
	// ParentAcquireFinish calls the default implementations of the `GPermission.acquire_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to acquire the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	ParentAcquireFinish(result AsyncResult) (bool, error)
	// ParentRelease calls the default implementations of the `GPermission.release` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to release the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  In most cases the
	// permission will be dropped immediately without further action.
	// 
	// You should check with g_permission_get_can_release() before calling
	// this function.
	// 
	// If the permission is released then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_release_async() for
	// the non-blocking version.
	ParentRelease(cancellable Cancellable) (bool, error)
	// ParentReleaseFinish calls the default implementations of the `GPermission.release_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to release the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_release().
	ParentReleaseFinish(result AsyncResult) (bool, error)
}

func unsafeWrapPermission(base *gobject.ObjectInstance) *PermissionInstance {
	return &PermissionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypePermission,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPermission(inst)
		},
	)
}

func marshalPermissionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafePermissionFromGlibNone is used to convert raw GPermission pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePermissionFromGlibNone(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibNone(c).(Permission)
}

// UnsafePermissionFromGlibFull is used to convert raw GPermission pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePermissionFromGlibFull(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibFull(c).(Permission)
}

// UnsafePermissionFromGlibBorrow is used to convert raw GPermission pointers to go without touching any references. This is used by the bindings internally.
func UnsafePermissionFromGlibBorrow(c unsafe.Pointer) Permission {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Permission)
}

func (p *PermissionInstance) upcastToGPermission() *PermissionInstance {
	return p
}

// UnsafePermissionToGlibNone is used to convert the instance to it's C value GPermission. This is used by the bindings internally.
func UnsafePermissionToGlibNone(c Permission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafePermissionToGlibFull is used to convert the instance to it's C value GPermission, while removeing the finalizer. This is used by the bindings internally.
func UnsafePermissionToGlibFull(c Permission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Acquire wraps g_permission_acquire
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts to acquire the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  A simple example is
// that a dialog may appear asking the user to enter their password.
// 
// You should check with g_permission_get_can_acquire() before calling
// this function.
// 
// If the permission is acquired then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_acquire_async() for
// the non-blocking version.
func (permission *PermissionInstance) Acquire(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_permission_acquire(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AcquireAsync wraps g_permission_acquire_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): the #GAsyncReadyCallback to call when done 
//
// Attempts to acquire the permission represented by @permission.
// 
// This is the first half of the asynchronous version of
// g_permission_acquire().
func (permission *PermissionInstance) AcquireAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GPermission        // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_permission_acquire_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcquireFinish wraps g_permission_acquire_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Collects the result of attempting to acquire the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_acquire().
func (permission *PermissionInstance) AcquireFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_permission_acquire_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetAllowed wraps g_permission_get_allowed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value of the 'allowed' property.  This property is %TRUE if
// the caller currently has permission to perform the action that
// @permission represents the permission to perform.
func (permission *PermissionInstance) GetAllowed() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_allowed(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCanAcquire wraps g_permission_get_can_acquire
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value of the 'can-acquire' property.  This property is %TRUE
// if it is generally possible to acquire the permission by calling
// g_permission_acquire().
func (permission *PermissionInstance) GetCanAcquire() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_can_acquire(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCanRelease wraps g_permission_get_can_release
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value of the 'can-release' property.  This property is %TRUE
// if it is generally possible to release the permission by calling
// g_permission_release().
func (permission *PermissionInstance) GetCanRelease() bool {
	var carg0 *C.GPermission // in, none, converted
	var cret  C.gboolean     // return

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))

	cret = C.g_permission_get_can_release(carg0)
	runtime.KeepAlive(permission)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ImplUpdate wraps g_permission_impl_update
// 
// The function takes the following parameters:
// 
// 	- allowed bool: the new value for the 'allowed' property 
// 	- canAcquire bool: the new value for the 'can-acquire' property 
// 	- canRelease bool: the new value for the 'can-release' property 
//
// This function is called by the #GPermission implementation to update
// the properties of the permission.  You should never call this
// function except from a #GPermission implementation.
// 
// GObject notify signals are generated, as appropriate.
func (permission *PermissionInstance) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	var carg0 *C.GPermission // in, none, converted
	var carg1 C.gboolean     // in
	var carg2 C.gboolean     // in
	var carg3 C.gboolean     // in

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if allowed {
		carg1 = C.TRUE
	}
	if canAcquire {
		carg2 = C.TRUE
	}
	if canRelease {
		carg3 = C.TRUE
	}

	C.g_permission_impl_update(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(allowed)
	runtime.KeepAlive(canAcquire)
	runtime.KeepAlive(canRelease)
}

// Release wraps g_permission_release
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts to release the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  In most cases the
// permission will be dropped immediately without further action.
// 
// You should check with g_permission_get_can_release() before calling
// this function.
// 
// If the permission is released then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_release_async() for
// the non-blocking version.
func (permission *PermissionInstance) Release(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_permission_release(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReleaseAsync wraps g_permission_release_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): the #GAsyncReadyCallback to call when done 
//
// Attempts to release the permission represented by @permission.
// 
// This is the first half of the asynchronous version of
// g_permission_release().
func (permission *PermissionInstance) ReleaseAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GPermission        // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_permission_release_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReleaseFinish wraps g_permission_release_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Collects the result of attempting to release the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_release().
func (permission *PermissionInstance) ReleaseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission  // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_permission_release_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PermissionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type PermissionOverrides[Instance Permission] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Acquire allows you to override the implementation of the virtual method acquire.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to acquire the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  A simple example is
	// that a dialog may appear asking the user to enter their password.
	// 
	// You should check with g_permission_get_can_acquire() before calling
	// this function.
	// 
	// If the permission is acquired then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_acquire_async() for
	// the non-blocking version.
	Acquire func(Instance, Cancellable) (bool, error)
	// // AcquireFinish allows you to override the implementation of the virtual method acquire_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to acquire the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_acquire().
	AcquireFinish func(Instance, AsyncResult) (bool, error)
	// // Release allows you to override the implementation of the virtual method release.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to release the permission represented by @permission.
	// 
	// The precise method by which this happens depends on the permission
	// and the underlying authentication mechanism.  In most cases the
	// permission will be dropped immediately without further action.
	// 
	// You should check with g_permission_get_can_release() before calling
	// this function.
	// 
	// If the permission is released then %TRUE is returned.  Otherwise,
	// %FALSE is returned and @error is set appropriately.
	// 
	// This call is blocking, likely for a very long time (in the case that
	// user interaction is required).  See g_permission_release_async() for
	// the non-blocking version.
	Release func(Instance, Cancellable) (bool, error)
	// // ReleaseFinish allows you to override the implementation of the virtual method release_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Collects the result of attempting to release the permission
	// represented by @permission.
	// 
	// This is the second half of the asynchronous version of
	// g_permission_release().
	ReleaseFinish func(Instance, AsyncResult) (bool, error)
}

// UnsafeApplyPermissionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyPermissionOverrides[Instance Permission](gclass unsafe.Pointer, overrides PermissionOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GPermissionClass)(gclass)

	if overrides.Acquire != nil {
		pclass.acquire = (*[0]byte)(C._goglib_gio2_Permission_acquire)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_acquire",
			func(carg0 *C.GPermission, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var permission  Instance    // go GPermission subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Acquire(permission, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.AcquireFinish != nil {
		pclass.acquire_finish = (*[0]byte)(C._goglib_gio2_Permission_acquire_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_acquire_finish",
			func(carg0 *C.GPermission, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var permission Instance    // go GPermission subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.AcquireFinish(permission, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Release != nil {
		pclass.release = (*[0]byte)(C._goglib_gio2_Permission_release)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_release",
			func(carg0 *C.GPermission, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var permission  Instance    // go GPermission subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Release(permission, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ReleaseFinish != nil {
		pclass.release_finish = (*[0]byte)(C._goglib_gio2_Permission_release_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Permission_release_finish",
			func(carg0 *C.GPermission, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var permission Instance    // go GPermission subclass
				var result     AsyncResult // in, none, converted
				var goret      bool        // return
				var _goerr     error       // out, full, converted

				permission = UnsafePermissionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.ReleaseFinish(permission, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAcquire calls the default implementations of the `GPermission.acquire` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts to acquire the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  A simple example is
// that a dialog may appear asking the user to enter their password.
// 
// You should check with g_permission_get_can_acquire() before calling
// this function.
// 
// If the permission is acquired then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_acquire_async() for
// the non-blocking version.
func (permission *PermissionInstance) ParentAcquire(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Permission_virtual_acquire(unsafe.Pointer(parentclass.acquire), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentAcquireFinish calls the default implementations of the `GPermission.acquire_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Collects the result of attempting to acquire the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_acquire().
func (permission *PermissionInstance) ParentAcquireFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Permission_virtual_acquire_finish(unsafe.Pointer(parentclass.acquire_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRelease calls the default implementations of the `GPermission.release` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts to release the permission represented by @permission.
// 
// The precise method by which this happens depends on the permission
// and the underlying authentication mechanism.  In most cases the
// permission will be dropped immediately without further action.
// 
// You should check with g_permission_get_can_release() before calling
// this function.
// 
// If the permission is released then %TRUE is returned.  Otherwise,
// %FALSE is returned and @error is set appropriately.
// 
// This call is blocking, likely for a very long time (in the case that
// user interaction is required).  See g_permission_release_async() for
// the non-blocking version.
func (permission *PermissionInstance) ParentRelease(cancellable Cancellable) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Permission_virtual_release(unsafe.Pointer(parentclass.release), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReleaseFinish calls the default implementations of the `GPermission.release_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult given to the #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Collects the result of attempting to release the permission
// represented by @permission.
// 
// This is the second half of the asynchronous version of
// g_permission_release().
func (permission *PermissionInstance) ParentReleaseFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GPermission
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GPermissionClass)(classdata.PeekParentClass(UnsafePermissionToGlibNone(permission)))

	carg0 = (*C.GPermission)(UnsafePermissionToGlibNone(permission))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Permission_virtual_release_finish(unsafe.Pointer(parentclass.release_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(permission)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterPermissionSubClass is used to register a go subclass of GPermission. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterPermissionSubClass[InstanceT Permission](
		name string,
		classInit func(class *PermissionClass),
		constructor func() InstanceT,
		overrides PermissionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypePermission,
		UnsafePermissionClassFromGlibBorrow,
		UnsafeApplyPermissionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPermission(obj)
		},
		interfaceInits...,
	)
}

// PropertyActionInstance is the instance type used by all types extending GPropertyAction. It is used internally by the bindings. Users should use the interface [PropertyAction] instead.
type PropertyActionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ PropertyAction = (*PropertyActionInstance)(nil)

// PropertyAction wraps GPropertyAction
//
// A `GPropertyAction` is a way to get a [iface@Gio.Action] with a state value
// reflecting and controlling the value of a [class@GObject.Object] property.
// 
// The state of the action will correspond to the value of the property.
// Changing it will change the property (assuming the requested value
// matches the requirements as specified in the [type@GObject.ParamSpec]).
// 
// Only the most common types are presently supported.  Booleans are
// mapped to booleans, strings to strings, signed/unsigned integers to
// int32/uint32 and floats and doubles to doubles.
// 
// If the property is an enum then the state will be string-typed and
// conversion will automatically be performed between the enum value and
// &#x2018;nick&#x2019; string as per the [type@GObject.EnumValue] table.
// 
// Flags types are not currently supported.
// 
// Properties of object types, boxed types and pointer types are not
// supported and probably never will be.
// 
// Properties of [type@GLib.Variant] types are not currently supported.
// 
// If the property is boolean-valued then the action will have a `NULL`
// parameter type, and activating the action (with no parameter) will
// toggle the value of the property.
// 
// In all other cases, the parameter type will correspond to the type of
// the property.
// 
// The general idea here is to reduce the number of locations where a
// particular piece of state is kept (and therefore has to be synchronised
// between). `GPropertyAction` does not have a separate state that is kept
// in sync with the property value &#x2014; its state is the property value.
// 
// For example, it might be useful to create a [iface@Gio.Action] corresponding
// to the `visible-child-name` property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html)
// so that the current page can be switched from a menu.  The active radio
// indication in the menu is then directly determined from the active page of
// the `GtkStack`.
// 
// An anti-example would be binding the `active-id` property on a
// [`GtkComboBox`](https://docs.gtk.org/gtk4/class.ComboBox.html). This is
// because the state of the combo box itself is probably uninteresting and is
// actually being used to control something else.
// 
// Another anti-example would be to bind to the `visible-child-name`
// property of a [`GtkStack`](https://docs.gtk.org/gtk4/class.Stack.html) if
// this value is actually stored in [class@Gio.Settings].  In that case, the
// real source of the value is* [class@Gio.Settings].  If you want
// a [iface@Gio.Action] to control a setting stored in [class@Gio.Settings],
// see [method@Gio.Settings.create_action] instead, and possibly combine its
// use with [method@Gio.Settings.bind].
type PropertyAction interface {
	gobject.Object
	upcastToGPropertyAction() *PropertyActionInstance
}

func unsafeWrapPropertyAction(base *gobject.ObjectInstance) *PropertyActionInstance {
	return &PropertyActionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypePropertyAction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapPropertyAction(inst)
		},
	)
}

func marshalPropertyActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafePropertyActionFromGlibNone is used to convert raw GPropertyAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafePropertyActionFromGlibNone(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibNone(c).(PropertyAction)
}

// UnsafePropertyActionFromGlibFull is used to convert raw GPropertyAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafePropertyActionFromGlibFull(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibFull(c).(PropertyAction)
}

// UnsafePropertyActionFromGlibBorrow is used to convert raw GPropertyAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafePropertyActionFromGlibBorrow(c unsafe.Pointer) PropertyAction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(PropertyAction)
}

func (p *PropertyActionInstance) upcastToGPropertyAction() *PropertyActionInstance {
	return p
}

// UnsafePropertyActionToGlibNone is used to convert the instance to it's C value GPropertyAction. This is used by the bindings internally.
func UnsafePropertyActionToGlibNone(c PropertyAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafePropertyActionToGlibFull is used to convert the instance to it's C value GPropertyAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafePropertyActionToGlibFull(c PropertyAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ResolverInstance is the instance type used by all types extending GResolver. It is used internally by the bindings. Users should use the interface [Resolver] instead.
type ResolverInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Resolver = (*ResolverInstance)(nil)

// Resolver wraps GResolver
//
// The object that handles DNS resolution. Use [func@Gio.Resolver.get_default]
// to get the default resolver.
// 
// `GResolver` provides cancellable synchronous and asynchronous DNS
// resolution, for hostnames ([method@Gio.Resolver.lookup_by_address],
// [method@Gio.Resolver.lookup_by_name] and their async variants) and SRV
// (service) records ([method@Gio.Resolver.lookup_service]).
// 
// [class@Gio.NetworkAddress] and [class@Gio.NetworkService] provide wrappers
// around `GResolver` functionality that also implement
// [iface@Gio.SocketConnectable], making it easy to connect to a remote
// host/service.
// 
// The default resolver (see [func@Gio.Resolver.get_default]) has a timeout of
// 30s set on it since GLib 2.78. Earlier versions of GLib did not support
// resolver timeouts.
// 
// This is an abstract type; subclasses of it implement different resolvers for
// different platforms and situations.
type Resolver interface {
	gobject.Object
	upcastToGResolver() *ResolverInstance

	// GetTimeout wraps g_resolver_get_timeout
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Get the timeout applied to all resolver lookups. See #GResolver:timeout.
	GetTimeout() uint
	// LookupByAddress wraps g_resolver_lookup_by_address
	// 
	// The function takes the following parameters:
	// 
	// 	- address InetAddress: the address to reverse-resolve 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously reverse-resolves @address to determine its
	// associated hostname.
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to
	// a value from #GResolverError.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	LookupByAddress(InetAddress, Cancellable) (string, error)
	// LookupByAddressAsync wraps g_resolver_lookup_by_address_async
	// 
	// The function takes the following parameters:
	// 
	// 	- address InetAddress: the address to reverse-resolve 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Begins asynchronously reverse-resolving @address to determine its
	// associated hostname, and eventually calls @callback, which must
	// call g_resolver_lookup_by_address_finish() to get the final result.
	LookupByAddressAsync(InetAddress, Cancellable, AsyncReadyCallback)
	// LookupByAddressFinish wraps g_resolver_lookup_by_address_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByAddressFinish(AsyncResult) (string, error)
	// LookupByName wraps g_resolver_lookup_by_name
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously resolves @hostname to determine its associated IP
	// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
	// the textual form of an IP address (in which case this just becomes
	// a wrapper around g_inet_address_new_from_string()).
	// 
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// #GInetAddress, sorted in order of preference and guaranteed to not
	// contain duplicates. That is, if using the result to connect to
	// @hostname, you should attempt to connect to the first address
	// first, then the second if the first fails, etc. If you are using
	// the result to listen on a socket, it is appropriate to add each
	// result using e.g. g_socket_listener_add_address().
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to a
	// value from #GResolverError and %NULL will be returned.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	// 
	// If you are planning to connect to a socket on the resolved IP
	// address, it may be easier to create a #GNetworkAddress and use its
	// #GSocketConnectable interface.
	LookupByName(string, Cancellable) ([]InetAddress, error)
	// LookupByNameAsync wraps g_resolver_lookup_by_name_async
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up the address of 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Begins asynchronously resolving @hostname to determine its
	// associated IP address(es), and eventually calls @callback, which
	// must call g_resolver_lookup_by_name_finish() to get the result.
	// See g_resolver_lookup_by_name() for more details.
	LookupByNameAsync(string, Cancellable, AsyncReadyCallback)
	// LookupByNameFinish wraps g_resolver_lookup_by_name_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByNameFinish(AsyncResult) ([]InetAddress, error)
	// LookupByNameWithFlags wraps g_resolver_lookup_by_name_with_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// This differs from g_resolver_lookup_by_name() in that you can modify
	// the lookup behavior with @flags. For example this can be used to limit
	// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	LookupByNameWithFlags(string, ResolverNameLookupFlags, Cancellable) ([]InetAddress, error)
	// LookupByNameWithFlagsAsync wraps g_resolver_lookup_by_name_with_flags_async
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up the address of 
	// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Begins asynchronously resolving @hostname to determine its
	// associated IP address(es), and eventually calls @callback, which
	// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
	// See g_resolver_lookup_by_name() for more details.
	LookupByNameWithFlagsAsync(string, ResolverNameLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupByNameWithFlagsFinish wraps g_resolver_lookup_by_name_with_flags_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByNameWithFlagsFinish(AsyncResult) ([]InetAddress, error)
	// LookupRecordsAsync wraps g_resolver_lookup_records_async
	// 
	// The function takes the following parameters:
	// 
	// 	- rrname string: the DNS name to look up the record for 
	// 	- recordType ResolverRecordType: the type of DNS record to look up 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Begins asynchronously performing a DNS lookup for the given
	// @rrname, and eventually calls @callback, which must call
	// g_resolver_lookup_records_finish() to get the final result. See
	// g_resolver_lookup_records() for more details.
	LookupRecordsAsync(string, ResolverRecordType, Cancellable, AsyncReadyCallback)
	// LookupService wraps g_resolver_lookup_service
	// 
	// The function takes the following parameters:
	// 
	// 	- service string: the service type to look up (eg, "ldap") 
	// 	- protocol string: the networking protocol to use for @service (eg, "tcp") 
	// 	- domain string: the DNS domain to look up the service in 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []*SrvTarget 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously performs a DNS SRV lookup for the given @service and
	// @protocol in the given @domain and returns an array of #GSrvTarget.
	// @domain may be an ASCII-only or UTF-8 hostname. Note also that the
	// @service and @protocol arguments do not include the leading underscore
	// that appears in the actual DNS entry.
	// 
	// On success, g_resolver_lookup_service() will return a non-empty #GList of
	// #GSrvTarget, sorted in order of preference. (That is, you should
	// attempt to connect to the first target first, then the second if
	// the first fails, etc.)
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to
	// a value from #GResolverError and %NULL will be returned.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	// 
	// If you are planning to connect to the service, it is usually easier
	// to create a #GNetworkService and use its #GSocketConnectable
	// interface.
	LookupService(string, string, string, Cancellable) ([]*SrvTarget, error)
	// LookupServiceAsync wraps g_resolver_lookup_service_async
	// 
	// The function takes the following parameters:
	// 
	// 	- service string: the service type to look up (eg, "ldap") 
	// 	- protocol string: the networking protocol to use for @service (eg, "tcp") 
	// 	- domain string: the DNS domain to look up the service in 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
	//
	// Begins asynchronously performing a DNS SRV lookup for the given
	// @service and @protocol in the given @domain, and eventually calls
	// @callback, which must call g_resolver_lookup_service_finish() to
	// get the final result. See g_resolver_lookup_service() for more
	// details.
	LookupServiceAsync(string, string, string, Cancellable, AsyncReadyCallback)
	// LookupServiceFinish wraps g_resolver_lookup_service_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []*SrvTarget 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupServiceFinish(AsyncResult) ([]*SrvTarget, error)
	// SetDefault wraps g_resolver_set_default
	//
	// Sets @resolver to be the application's default resolver (reffing
	// @resolver, and unreffing the previous default resolver, if any).
	// Future calls to g_resolver_get_default() will return this resolver.
	// 
	// This can be used if an application wants to perform any sort of DNS
	// caching or "pinning"; it can implement its own #GResolver that
	// calls the original default resolver for DNS operations, and
	// implements its own cache policies on top of that, and then set
	// itself as the default resolver for all later code to use.
	SetDefault()
	// SetTimeout wraps g_resolver_set_timeout
	// 
	// The function takes the following parameters:
	// 
	// 	- timeoutMs uint: timeout in milliseconds, or `0` for no timeouts 
	//
	// Set the timeout applied to all resolver lookups. See #GResolver:timeout.
	SetTimeout(uint)
	// ConnectReload connects the provided callback to the "reload" signal
	//
	// Emitted when the resolver notices that the system resolver
	// configuration has changed.
	ConnectReload(func(Resolver)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentLookupByAddress calls the default implementations of the `GResolver.lookup_by_address` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- address InetAddress: the address to reverse-resolve 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously reverse-resolves @address to determine its
	// associated hostname.
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to
	// a value from #GResolverError.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	ParentLookupByAddress(address InetAddress, cancellable Cancellable) (string, error)
	// ParentLookupByAddressFinish calls the default implementations of the `GResolver.lookup_by_address_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	ParentLookupByAddressFinish(result AsyncResult) (string, error)
	// ParentLookupByName calls the default implementations of the `GResolver.lookup_by_name` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously resolves @hostname to determine its associated IP
	// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
	// the textual form of an IP address (in which case this just becomes
	// a wrapper around g_inet_address_new_from_string()).
	// 
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// #GInetAddress, sorted in order of preference and guaranteed to not
	// contain duplicates. That is, if using the result to connect to
	// @hostname, you should attempt to connect to the first address
	// first, then the second if the first fails, etc. If you are using
	// the result to listen on a socket, it is appropriate to add each
	// result using e.g. g_socket_listener_add_address().
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to a
	// value from #GResolverError and %NULL will be returned.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	// 
	// If you are planning to connect to a socket on the resolved IP
	// address, it may be easier to create a #GNetworkAddress and use its
	// #GSocketConnectable interface.
	ParentLookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error)
	// ParentLookupByNameFinish calls the default implementations of the `GResolver.lookup_by_name_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	ParentLookupByNameFinish(result AsyncResult) ([]InetAddress, error)
	// ParentLookupByNameWithFlags calls the default implementations of the `GResolver.lookup_by_name_with_flags` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// This differs from g_resolver_lookup_by_name() in that you can modify
	// the lookup behavior with @flags. For example this can be used to limit
	// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	ParentLookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error)
	// ParentLookupByNameWithFlagsFinish calls the default implementations of the `GResolver.lookup_by_name_with_flags_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	ParentLookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error)
	// ParentLookupServiceFinish calls the default implementations of the `GResolver.lookup_service_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []*SrvTarget 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	ParentLookupServiceFinish(result AsyncResult) ([]*SrvTarget, error)
	// ParentReload calls the default implementations of the `GResolver.reload` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	ParentReload()
}

func unsafeWrapResolver(base *gobject.ObjectInstance) *ResolverInstance {
	return &ResolverInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeResolver,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapResolver(inst)
		},
	)
}

func marshalResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeResolverFromGlibNone is used to convert raw GResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeResolverFromGlibNone(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibNone(c).(Resolver)
}

// UnsafeResolverFromGlibFull is used to convert raw GResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeResolverFromGlibFull(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibFull(c).(Resolver)
}

// UnsafeResolverFromGlibBorrow is used to convert raw GResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeResolverFromGlibBorrow(c unsafe.Pointer) Resolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Resolver)
}

func (r *ResolverInstance) upcastToGResolver() *ResolverInstance {
	return r
}

// UnsafeResolverToGlibNone is used to convert the instance to it's C value GResolver. This is used by the bindings internally.
func UnsafeResolverToGlibNone(c Resolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeResolverToGlibFull is used to convert the instance to it's C value GResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeResolverToGlibFull(c Resolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ResolverGetDefault wraps g_resolver_get_default
// 
// The function returns the following values:
// 
// 	- goret Resolver 
//
// Gets the default #GResolver. You should unref it when you are done
// with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
func ResolverGetDefault() Resolver {
	var cret *C.GResolver // return, full, converted

	cret = C.g_resolver_get_default()

	var goret Resolver

	goret = UnsafeResolverFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetTimeout wraps g_resolver_get_timeout
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Get the timeout applied to all resolver lookups. See #GResolver:timeout.
func (resolver *ResolverInstance) GetTimeout() uint {
	var carg0 *C.GResolver // in, none, converted
	var cret  C.unsigned   // return, none, casted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	cret = C.g_resolver_get_timeout(carg0)
	runtime.KeepAlive(resolver)

	var goret uint

	goret = uint(cret)

	return goret
}

// LookupByAddress wraps g_resolver_lookup_by_address
// 
// The function takes the following parameters:
// 
// 	- address InetAddress: the address to reverse-resolve 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Synchronously reverse-resolves @address to determine its
// associated hostname.
// 
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError.
// 
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) LookupByAddress(address InetAddress, cancellable Cancellable) (string, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_address(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByAddressAsync wraps g_resolver_lookup_by_address_async
// 
// The function takes the following parameters:
// 
// 	- address InetAddress: the address to reverse-resolve 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Begins asynchronously reverse-resolving @address to determine its
// associated hostname, and eventually calls @callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
func (resolver *ResolverInstance) LookupByAddressAsync(address InetAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.GInetAddress       // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_address_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish wraps g_resolver_lookup_by_address_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) LookupByAddressFinish(result AsyncResult) (string, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_address_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByName wraps g_resolver_lookup_by_name
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Synchronously resolves @hostname to determine its associated IP
// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
// the textual form of an IP address (in which case this just becomes
// a wrapper around g_inet_address_new_from_string()).
// 
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// #GInetAddress, sorted in order of preference and guaranteed to not
// contain duplicates. That is, if using the result to connect to
// @hostname, you should attempt to connect to the first address
// first, then the second if the first fails, etc. If you are using
// the result to listen on a socket, it is appropriate to add each
// result using e.g. g_socket_listener_add_address().
// 
// If the DNS resolution fails, @error (if non-%NULL) will be set to a
// value from #GResolverError and %NULL will be returned.
// 
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
// 
// If you are planning to connect to a socket on the resolved IP
// address, it may be easier to create a #GNetworkAddress and use its
// #GSocketConnectable interface.
func (resolver *ResolverInstance) LookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_name(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameAsync wraps g_resolver_lookup_by_name_async
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up the address of 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (resolver *ResolverInstance) LookupByNameAsync(hostname string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_name_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish wraps g_resolver_lookup_by_name_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a call to
// g_resolver_lookup_by_name_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) LookupByNameFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_name_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameWithFlags wraps g_resolver_lookup_by_name_with_flags
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up 
// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// This differs from g_resolver_lookup_by_name() in that you can modify
// the lookup behavior with @flags. For example this can be used to limit
// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
func (resolver *ResolverInstance) LookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver               // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var carg2 C.GResolverNameLookupFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var cret  *C.GList                   // container, transfer: full
	var _cerr *C.GError                  // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_by_name_with_flags(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupByNameWithFlagsAsync wraps g_resolver_lookup_by_name_with_flags_async
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up the address of 
// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Begins asynchronously resolving @hostname to determine its
// associated IP address(es), and eventually calls @callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
func (resolver *ResolverInstance) LookupByNameWithFlagsAsync(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver               // in, none, converted
	var carg1 *C.gchar                   // in, none, string
	var carg2 C.GResolverNameLookupFlags // in, none, casted
	var carg3 *C.GCancellable            // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback      // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer                 // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_by_name_with_flags_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupByNameWithFlagsFinish wraps g_resolver_lookup_by_name_with_flags_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) LookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_by_name_with_flags_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupRecordsAsync wraps g_resolver_lookup_records_async
// 
// The function takes the following parameters:
// 
// 	- rrname string: the DNS name to look up the record for 
// 	- recordType ResolverRecordType: the type of DNS record to look up 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Begins asynchronously performing a DNS lookup for the given
// @rrname, and eventually calls @callback, which must call
// g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
func (resolver *ResolverInstance) LookupRecordsAsync(rrname string, recordType ResolverRecordType, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.GResolverRecordType // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverRecordType(recordType)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_records_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupService wraps g_resolver_lookup_service
// 
// The function takes the following parameters:
// 
// 	- service string: the service type to look up (eg, "ldap") 
// 	- protocol string: the networking protocol to use for @service (eg, "tcp") 
// 	- domain string: the DNS domain to look up the service in 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []*SrvTarget 
// 	- _goerr error (nullable): an error 
//
// Synchronously performs a DNS SRV lookup for the given @service and
// @protocol in the given @domain and returns an array of #GSrvTarget.
// @domain may be an ASCII-only or UTF-8 hostname. Note also that the
// @service and @protocol arguments do not include the leading underscore
// that appears in the actual DNS entry.
// 
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// #GSrvTarget, sorted in order of preference. (That is, you should
// attempt to connect to the first target first, then the second if
// the first fails, etc.)
// 
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError and %NULL will be returned.
// 
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
// 
// If you are planning to connect to the service, it is usually easier
// to create a #GNetworkService and use its #GSocketConnectable
// interface.
func (resolver *ResolverInstance) LookupService(service string, protocol string, domain string, cancellable Cancellable) ([]*SrvTarget, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 *C.gchar        // in, none, string
	var carg3 *C.gchar        // in, none, string
	var carg4 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_resolver_lookup_service(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(cancellable)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupServiceAsync wraps g_resolver_lookup_service_async
// 
// The function takes the following parameters:
// 
// 	- service string: the service type to look up (eg, "ldap") 
// 	- protocol string: the networking protocol to use for @service (eg, "tcp") 
// 	- domain string: the DNS domain to look up the service in 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call after resolution completes 
//
// Begins asynchronously performing a DNS SRV lookup for the given
// @service and @protocol in the given @domain, and eventually calls
// @callback, which must call g_resolver_lookup_service_finish() to
// get the final result. See g_resolver_lookup_service() for more
// details.
func (resolver *ResolverInstance) LookupServiceAsync(service string, protocol string, domain string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GResolver          // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.gchar              // in, none, string
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg3))
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_resolver_lookup_service_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish wraps g_resolver_lookup_service_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []*SrvTarget 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a previous call to
// g_resolver_lookup_service_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) LookupServiceFinish(result AsyncResult) ([]*SrvTarget, error) {
	var carg0 *C.GResolver    // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_resolver_lookup_service_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDefault wraps g_resolver_set_default
//
// Sets @resolver to be the application's default resolver (reffing
// @resolver, and unreffing the previous default resolver, if any).
// Future calls to g_resolver_get_default() will return this resolver.
// 
// This can be used if an application wants to perform any sort of DNS
// caching or "pinning"; it can implement its own #GResolver that
// calls the original default resolver for DNS operations, and
// implements its own cache policies on top of that, and then set
// itself as the default resolver for all later code to use.
func (resolver *ResolverInstance) SetDefault() {
	var carg0 *C.GResolver // in, none, converted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	C.g_resolver_set_default(carg0)
	runtime.KeepAlive(resolver)
}

// SetTimeout wraps g_resolver_set_timeout
// 
// The function takes the following parameters:
// 
// 	- timeoutMs uint: timeout in milliseconds, or `0` for no timeouts 
//
// Set the timeout applied to all resolver lookups. See #GResolver:timeout.
func (resolver *ResolverInstance) SetTimeout(timeoutMs uint) {
	var carg0 *C.GResolver // in, none, converted
	var carg1 C.unsigned   // in, none, casted

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = C.unsigned(timeoutMs)

	C.g_resolver_set_timeout(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(timeoutMs)
}

// ConnectReload connects the provided callback to the "reload" signal
//
// Emitted when the resolver notices that the system resolver
// configuration has changed.
func (o *ResolverInstance) ConnectReload(fn func(Resolver)) gobject.SignalHandle {
	return o.Connect("reload", fn)
}

// ResolverOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ResolverOverrides[Instance Resolver] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // LookupByAddress allows you to override the implementation of the virtual method lookup_by_address.
	// 
	// The function takes the following parameters:
	// 
	// 	- address InetAddress: the address to reverse-resolve 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously reverse-resolves @address to determine its
	// associated hostname.
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to
	// a value from #GResolverError.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	LookupByAddress func(Instance, InetAddress, Cancellable) (string, error)
	// // LookupByAddressFinish allows you to override the implementation of the virtual method lookup_by_address_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByAddressFinish func(Instance, AsyncResult) (string, error)
	// // LookupByName allows you to override the implementation of the virtual method lookup_by_name.
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Synchronously resolves @hostname to determine its associated IP
	// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
	// the textual form of an IP address (in which case this just becomes
	// a wrapper around g_inet_address_new_from_string()).
	// 
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// #GInetAddress, sorted in order of preference and guaranteed to not
	// contain duplicates. That is, if using the result to connect to
	// @hostname, you should attempt to connect to the first address
	// first, then the second if the first fails, etc. If you are using
	// the result to listen on a socket, it is appropriate to add each
	// result using e.g. g_socket_listener_add_address().
	// 
	// If the DNS resolution fails, @error (if non-%NULL) will be set to a
	// value from #GResolverError and %NULL will be returned.
	// 
	// If @cancellable is non-%NULL, it can be used to cancel the
	// operation, in which case @error (if non-%NULL) will be set to
	// %G_IO_ERROR_CANCELLED.
	// 
	// If you are planning to connect to a socket on the resolved IP
	// address, it may be easier to create a #GNetworkAddress and use its
	// #GSocketConnectable interface.
	LookupByName func(Instance, string, Cancellable) ([]InetAddress, error)
	// // LookupByNameFinish allows you to override the implementation of the virtual method lookup_by_name_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByNameFinish func(Instance, AsyncResult) ([]InetAddress, error)
	// // LookupByNameWithFlags allows you to override the implementation of the virtual method lookup_by_name_with_flags.
	// 
	// The function takes the following parameters:
	// 
	// 	- hostname string: the hostname to look up 
	// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// This differs from g_resolver_lookup_by_name() in that you can modify
	// the lookup behavior with @flags. For example this can be used to limit
	// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	LookupByNameWithFlags func(Instance, string, ResolverNameLookupFlags, Cancellable) ([]InetAddress, error)
	// // LookupByNameWithFlagsFinish allows you to override the implementation of the virtual method lookup_by_name_with_flags_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []InetAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupByNameWithFlagsFinish func(Instance, AsyncResult) ([]InetAddress, error)
	// // LookupServiceFinish allows you to override the implementation of the virtual method lookup_service_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
	// 
	// The function returns the following values:
	// 
	// 	- goret []*SrvTarget 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	// 
	// If the DNS resolution failed, @error (if non-%NULL) will be set to
	// a value from #GResolverError. If the operation was cancelled,
	// @error will be set to %G_IO_ERROR_CANCELLED.
	LookupServiceFinish func(Instance, AsyncResult) ([]*SrvTarget, error)
	// // Reload allows you to override the implementation of the virtual method reload.
	Reload func(Instance)
}

// UnsafeApplyResolverOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyResolverOverrides[Instance Resolver](gclass unsafe.Pointer, overrides ResolverOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GResolverClass)(gclass)

	if overrides.LookupByAddress != nil {
		pclass.lookup_by_address = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_address)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_address",
			func(carg0 *C.GResolver, carg1 *C.GInetAddress, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.gchar) {
				var resolver    Instance    // go GResolver subclass
				var address     InetAddress // in, none, converted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       string      // return, full, string
				var _goerr      error       // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				address = UnsafeInetAddressFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.LookupByAddress(resolver, address, cancellable)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByAddressFinish != nil {
		pclass.lookup_by_address_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_address_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_address_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.gchar) {
				var resolver Instance    // go GResolver subclass
				var result   AsyncResult // in, none, converted
				var goret    string      // return, full, string
				var _goerr   error       // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByAddressFinish(resolver, result)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByName != nil {
		pclass.lookup_by_name = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name",
			func(carg0 *C.GResolver, carg1 *C.gchar, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
				var resolver    Instance      // go GResolver subclass
				var hostname    string        // in, none, string
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr      error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				hostname = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.LookupByName(resolver, hostname, cancellable)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameFinish != nil {
		pclass.lookup_by_name_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance      // go GResolver subclass
				var result   AsyncResult   // in, none, converted
				var goret    []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByNameFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameWithFlags != nil {
		pclass.lookup_by_name_with_flags = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_with_flags)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_with_flags",
			func(carg0 *C.GResolver, carg1 *C.gchar, carg2 C.GResolverNameLookupFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
				var resolver    Instance                // go GResolver subclass
				var hostname    string                  // in, none, string
				var flags       ResolverNameLookupFlags // in, none, casted
				var cancellable Cancellable             // in, none, converted, nullable
				var goret       []InetAddress           // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr      error                   // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				hostname = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				flags = ResolverNameLookupFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.LookupByNameWithFlags(resolver, hostname, flags, cancellable)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupByNameWithFlagsFinish != nil {
		pclass.lookup_by_name_with_flags_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_by_name_with_flags_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_by_name_with_flags_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance      // go GResolver subclass
				var result   AsyncResult   // in, none, converted
				var goret    []InetAddress // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error         // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupByNameWithFlagsFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []InetAddress (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupServiceFinish != nil {
		pclass.lookup_service_finish = (*[0]byte)(C._goglib_gio2_Resolver_lookup_service_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_lookup_service_finish",
			func(carg0 *C.GResolver, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var resolver Instance     // go GResolver subclass
				var result   AsyncResult  // in, none, converted
				var goret    []*SrvTarget // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr   error        // out, full, converted

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupServiceFinish(resolver, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []*SrvTarget (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Reload != nil {
		pclass.reload = (*[0]byte)(C._goglib_gio2_Resolver_reload)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Resolver_reload",
			func(carg0 *C.GResolver) {
				var resolver Instance // go GResolver subclass

				resolver = UnsafeResolverFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Reload(resolver)
			},
		)
	}
}

// ParentLookupByAddress calls the default implementations of the `GResolver.lookup_by_address` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- address InetAddress: the address to reverse-resolve 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Synchronously reverse-resolves @address to determine its
// associated hostname.
// 
// If the DNS resolution fails, @error (if non-%NULL) will be set to
// a value from #GResolverError.
// 
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) ParentLookupByAddress(address InetAddress, cancellable Cancellable) (string, error) {
	var carg0 *C.GResolver
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GCancellable // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_address(unsafe.Pointer(parentclass.lookup_by_address), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByAddressFinish calls the default implementations of the `GResolver.lookup_by_address_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) ParentLookupByAddressFinish(result AsyncResult) (string, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.gchar        // return, full, string
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_address_finish(unsafe.Pointer(parentclass.lookup_by_address_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByName calls the default implementations of the `GResolver.lookup_by_name` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Synchronously resolves @hostname to determine its associated IP
// address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
// the textual form of an IP address (in which case this just becomes
// a wrapper around g_inet_address_new_from_string()).
// 
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// #GInetAddress, sorted in order of preference and guaranteed to not
// contain duplicates. That is, if using the result to connect to
// @hostname, you should attempt to connect to the first address
// first, then the second if the first fails, etc. If you are using
// the result to listen on a socket, it is appropriate to add each
// result using e.g. g_socket_listener_add_address().
// 
// If the DNS resolution fails, @error (if non-%NULL) will be set to a
// value from #GResolverError and %NULL will be returned.
// 
// If @cancellable is non-%NULL, it can be used to cancel the
// operation, in which case @error (if non-%NULL) will be set to
// %G_IO_ERROR_CANCELLED.
// 
// If you are planning to connect to a socket on the resolved IP
// address, it may be easier to create a #GNetworkAddress and use its
// #GSocketConnectable interface.
func (resolver *ResolverInstance) ParentLookupByName(hostname string, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.gchar        // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name(unsafe.Pointer(parentclass.lookup_by_name), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameFinish calls the default implementations of the `GResolver.lookup_by_name_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a call to
// g_resolver_lookup_by_name_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) ParentLookupByNameFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_finish(unsafe.Pointer(parentclass.lookup_by_name_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameWithFlags calls the default implementations of the `GResolver.lookup_by_name_with_flags` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- hostname string: the hostname to look up 
// 	- flags ResolverNameLookupFlags: extra #GResolverNameLookupFlags for the lookup 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// This differs from g_resolver_lookup_by_name() in that you can modify
// the lookup behavior with @flags. For example this can be used to limit
// results with %G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
func (resolver *ResolverInstance) ParentLookupByNameWithFlags(hostname string, flags ResolverNameLookupFlags, cancellable Cancellable) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.gchar                   // in, none, converted
	var carg2 C.GResolverNameLookupFlags // in, none, string
	var carg3 *C.GCancellable            // in, none, casted
	var cret  *C.GList                   // container, transfer: full
	var _cerr *C.GError                  // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GResolverNameLookupFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_with_flags(unsafe.Pointer(parentclass.lookup_by_name_with_flags), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupByNameWithFlagsFinish calls the default implementations of the `GResolver.lookup_by_name_with_flags_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []InetAddress 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) ParentLookupByNameWithFlagsFinish(result AsyncResult) ([]InetAddress, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_by_name_with_flags_finish(unsafe.Pointer(parentclass.lookup_by_name_with_flags_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []InetAddress
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) InetAddress {
			var dst InetAddress // converted
			dst = UnsafeInetAddressFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupServiceFinish calls the default implementations of the `GResolver.lookup_service_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to your #GAsyncReadyCallback 
// 
// The function returns the following values:
// 
// 	- goret []*SrvTarget 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a previous call to
// g_resolver_lookup_service_async().
// 
// If the DNS resolution failed, @error (if non-%NULL) will be set to
// a value from #GResolverError. If the operation was cancelled,
// @error will be set to %G_IO_ERROR_CANCELLED.
func (resolver *ResolverInstance) ParentLookupServiceFinish(result AsyncResult) ([]*SrvTarget, error) {
	var carg0 *C.GResolver
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_Resolver_virtual_lookup_service_finish(unsafe.Pointer(parentclass.lookup_service_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var goret  []*SrvTarget
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *SrvTarget {
			var dst *SrvTarget // converted
			dst = UnsafeSrvTargetFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentReload calls the default implementations of the `GResolver.reload` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
func (resolver *ResolverInstance) ParentReload() {
	var carg0 *C.GResolver

	parentclass := (*C.GResolverClass)(classdata.PeekParentClass(UnsafeResolverToGlibNone(resolver)))

	carg0 = (*C.GResolver)(UnsafeResolverToGlibNone(resolver))

	C._goglib_gio2_Resolver_virtual_reload(unsafe.Pointer(parentclass.reload), carg0)
	runtime.KeepAlive(resolver)
}

// RegisterResolverSubClass is used to register a go subclass of GResolver. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterResolverSubClass[InstanceT Resolver](
		name string,
		classInit func(class *ResolverClass),
		constructor func() InstanceT,
		overrides ResolverOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeResolver,
		UnsafeResolverClassFromGlibBorrow,
		UnsafeApplyResolverOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapResolver(obj)
		},
		interfaceInits...,
	)
}

// SettingsInstance is the instance type used by all types extending GSettings. It is used internally by the bindings. Users should use the interface [Settings] instead.
type SettingsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Settings = (*SettingsInstance)(nil)

// Settings wraps GSettings
//
// The `GSettings` class provides a convenient API for storing and retrieving
// application settings.
// 
// Reads and writes can be considered to be non-blocking.  Reading
// settings with `GSettings` is typically extremely fast: on
// approximately the same order of magnitude (but slower than) a
// [struct@GLib.HashTable] lookup.  Writing settings is also extremely fast in
// terms of time to return to your application, but can be extremely expensive
// for other threads and other processes.  Many settings backends
// (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings
// a lot of work can be avoided.  For dconf, the D-Bus service doesn&#x2019;t
// even need to be started in this case.  For this reason, you should
// only ever modify `GSettings` keys in response to explicit user action.
// Particular care should be paid to ensure that modifications are not
// made during startup &#x2014; for example, when setting the initial value
// of preferences widgets.  The built-in [method@Gio.Settings.bind]
// functionality is careful not to write settings in response to notify signals
// as a result of modifications that it makes to widgets.
// 
// When creating a `GSettings` instance, you have to specify a schema
// that describes the keys in your settings and their types and default
// values, as well as some other information.
// 
// Normally, a schema has a fixed path that determines where the settings
// are stored in the conceptual global tree of settings. However, schemas
// can also be &#x2018;[relocatable](#relocatable-schemas)&#x2019;, i.e. not equipped with
// a fixed path. This is
// useful e.g. when the schema describes an &#x2018;account&#x2019;, and you want to be
// able to store a arbitrary number of accounts.
// 
// Paths must start with and end with a forward slash character (`/`)
// and must not contain two sequential slash characters.  Paths should
// be chosen based on a domain name associated with the program or
// library to which the settings belong.  Examples of paths are
// `/org/gtk/settings/file-chooser/` and `/ca/desrt/dconf-editor/`.
// Paths should not start with `/apps/`, `/desktop/` or `/system/` as
// they often did in GConf.
// 
// Unlike other configuration systems (like GConf), GSettings does not
// restrict keys to basic types like strings and numbers. GSettings stores
// values as [struct@GLib.Variant], and allows any [type@GLib.VariantType] for
// keys. Key names are restricted to lowercase characters, numbers and `-`.
// Furthermore, the names must begin with a lowercase character, must not end
// with a `-`, and must not contain consecutive dashes.
// 
// Similar to GConf, the default values in GSettings schemas can be
// localized, but the localized values are stored in gettext catalogs
// and looked up with the domain that is specified in the
// `gettext-domain` attribute of the `&lt;schemalist&gt;` or `&lt;schema&gt;`
// elements and the category that is specified in the `l10n` attribute of
// the `&lt;default&gt;` element. The string which is translated includes all text in
// the `&lt;default&gt;` element, including any surrounding quotation marks.
// 
// The `l10n` attribute must be set to `messages` or `time`, and sets the
// [locale category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The `messages` category should be used by default; use `time` for
// translatable date or time formats. A translation comment can be added as an
// XML comment immediately above the `&lt;default&gt;` element &#x2014; it is recommended to
// add these comments to aid translators understand the meaning and
// implications of the default value. An optional translation `context`
// attribute can be set on the `&lt;default&gt;` element to disambiguate multiple
// defaults which use the same string.
// 
// For example:
// ```xml
//  &lt;!-- Translators: A list of words which are not allowed to be typed, in
//       GVariant serialization syntax.
//       See: https://developer.gnome.org/glib/stable/gvariant-text.html --&gt;
//  &lt;default l10n='messages' context='Banned words'&gt;['bad', 'words']&lt;/default&gt;
// ```
// 
// Translations of default values must remain syntactically valid serialized
// [struct@GLib.Variant]s (e.g. retaining any surrounding quotation marks) or
// runtime errors will occur.
// 
// GSettings uses schemas in a compact binary form that is created
// by the [`glib-compile-schemas`](glib-compile-schemas.html)
// utility. The input is a schema description in an XML format.
// 
// A DTD for the gschema XML format can be found here:
// [gschema.dtd](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/gio/gschema.dtd)
// 
// The [`glib-compile-schemas`](glib-compile-schemas.html) tool expects schema
// files to have the extension `.gschema.xml`.
// 
// At runtime, schemas are identified by their ID (as specified in the
// `id` attribute of the `&lt;schema&gt;` element). The convention for schema
// IDs is to use a dotted name, similar in style to a D-Bus bus name,
// e.g. `org.gnome.SessionManager`. In particular, if the settings are
// for a specific service that owns a D-Bus bus name, the D-Bus bus name
// and schema ID should match. For schemas which deal with settings not
// associated with one named application, the ID should not use
// StudlyCaps, e.g. `org.gnome.font-rendering`.
// 
// In addition to [struct@GLib.Variant] types, keys can have types that have
// enumerated types. These can be described by a `&lt;choice&gt;`,
// `&lt;enum&gt;` or `&lt;flags&gt;` element, as seen in the
// second example below. The underlying type of such a key
// is string, but you can use [method@Gio.Settings.get_enum],
// [method@Gio.Settings.set_enum], [method@Gio.Settings.get_flags],
// [method@Gio.Settings.set_flags] access the numeric values corresponding to
// the string value of enum and flags keys.
// 
// An example for default value:
// ```xml
// &lt;schemalist&gt;
//   &lt;schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test"&gt;
// 
//     &lt;key name="greeting" type="s"&gt;
//       &lt;default l10n="messages"&gt;"Hello, earthlings"&lt;/default&gt;
//       &lt;summary&gt;A greeting&lt;/summary&gt;
//       &lt;description&gt;
//         Greeting of the invading martians
//       &lt;/description&gt;
//     &lt;/key&gt;
// 
//     &lt;key name="box" type="(ii)"&gt;
//       &lt;default&gt;(20,30)&lt;/default&gt;
//     &lt;/key&gt;
// 
//     &lt;key name="empty-string" type="s"&gt;
//       &lt;default&gt;""&lt;/default&gt;
//       &lt;summary&gt;Empty strings have to be provided in GVariant form&lt;/summary&gt;
//     &lt;/key&gt;
// 
//   &lt;/schema&gt;
// &lt;/schemalist&gt;
// ```
// 
// An example for ranges, choices and enumerated types:
// ```xml
// &lt;schemalist&gt;
// 
//   &lt;enum id="org.gtk.Test.myenum"&gt;
//     &lt;value nick="first" value="1"/&gt;
//     &lt;value nick="second" value="2"/&gt;
//   &lt;/enum&gt;
// 
//   &lt;flags id="org.gtk.Test.myflags"&gt;
//     &lt;value nick="flag1" value="1"/&gt;
//     &lt;value nick="flag2" value="2"/&gt;
//     &lt;value nick="flag3" value="4"/&gt;
//   &lt;/flags&gt;
// 
//   &lt;schema id="org.gtk.Test"&gt;
// 
//     &lt;key name="key-with-range" type="i"&gt;
//       &lt;range min="1" max="100"/&gt;
//       &lt;default&gt;10&lt;/default&gt;
//     &lt;/key&gt;
// 
//     &lt;key name="key-with-choices" type="s"&gt;
//       &lt;choices&gt;
//         &lt;choice value='Elisabeth'/&gt;
//         &lt;choice value='Annabeth'/&gt;
//         &lt;choice value='Joe'/&gt;
//       &lt;/choices&gt;
//       &lt;aliases&gt;
//         &lt;alias value='Anna' target='Annabeth'/&gt;
//         &lt;alias value='Beth' target='Elisabeth'/&gt;
//       &lt;/aliases&gt;
//       &lt;default&gt;'Joe'&lt;/default&gt;
//     &lt;/key&gt;
// 
//     &lt;key name='enumerated-key' enum='org.gtk.Test.myenum'&gt;
//       &lt;default&gt;'first'&lt;/default&gt;
//     &lt;/key&gt;
// 
//     &lt;key name='flags-key' flags='org.gtk.Test.myflags'&gt;
//       &lt;default&gt;["flag1","flag2"]&lt;/default&gt;
//     &lt;/key&gt;
//   &lt;/schema&gt;
// &lt;/schemalist&gt;
// ```
// 
// ## Vendor overrides
// 
// Default values are defined in the schemas that get installed by
// an application. Sometimes, it is necessary for a vendor or distributor
// to adjust these defaults. Since patching the XML source for the schema
// is inconvenient and error-prone,
// [`glib-compile-schemas`](glib-compile-schemas.html) reads so-called &#x2018;vendor
// override&#x2019; files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema ID serves
// as the group name in the key file, and the values are expected in
// serialized [struct@GLib.Variant] form, as in the following example:
// ```
// [org.gtk.Example]
// key1='string'
// key2=1.5
// ```
// 
// `glib-compile-schemas` expects schema files to have the extension
// `.gschema.override`.
// 
// ## Delay-apply mode
// 
// By default, values set on a [class@Gio.Settings] instance immediately start
// to be written to the backend (although these writes may not complete by the
// time that [method@Gio.Settings.set]) returns; see [func@Gio.Settings.sync]).
// 
// In order to allow groups of settings to be changed simultaneously and
// atomically, GSettings also supports a &#x2018;delay-apply&#x2019; mode. In this mode,
// updated values are kept locally in the [class@Gio.Settings] instance until
// they are explicitly applied by calling [method@Gio.Settings.apply].
// 
// For example, this could be useful for a preferences dialog where the
// preferences all need to be applied simultaneously when the user clicks &#x2018;Save&#x2019;.
// 
// Switching a [class@Gio.Settings] instance to &#x2018;delay-apply&#x2019; mode is a one-time
// irreversible operation: from that point onwards, *all* changes made to that
// [class@Gio.Settings] have to be explicitly applied by calling
// [method@Gio.Settings.apply]. The &#x2018;delay-apply&#x2019; mode is also propagated to any
// child settings objects subsequently created using
// [method@Gio.Settings.get_child].
// 
// At any point, the set of unapplied changes can be queried using
// [property@Gio.Settings:has-unapplied], and discarded by calling
// [method@Gio.Settings.revert].
// 
// ## Binding
// 
// A very convenient feature of GSettings lets you bind [class@GObject.Object]
// properties directly to settings, using [method@Gio.Settings.bind]. Once a
// [class@GObject.Object] property has been bound to a setting, changes on
// either side are automatically propagated to the other side. GSettings handles
// details like mapping between [class@GObject.Object] and [struct@GLib.Variant]
// types, and preventing infinite cycles.
// 
// This makes it very easy to hook up a preferences dialog to the
// underlying settings. To make this even more convenient, GSettings
// looks for a boolean property with the name `sensitivity` and
// automatically binds it to the writability of the bound setting.
// If this &#x2018;magic&#x2019; gets in the way, it can be suppressed with the
// `G_SETTINGS_BIND_NO_SENSITIVITY` flag.
// 
// ## Relocatable schemas
// 
// A relocatable schema is one with no `path` attribute specified on its
// `&lt;schema&gt;` element. By using [ctor@Gio.Settings.new_with_path], a `GSettings`
// object can be instantiated for a relocatable schema, assigning a path to the
// instance. Paths passed to [ctor@Gio.Settings.new_with_path] will typically be
// constructed dynamically from a constant prefix plus some form of instance
// identifier; but they must still be valid GSettings paths. Paths could also
// be constant and used with a globally installed schema originating from a
// dependency library.
// 
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// `org.foo.MyApp.Window`, it could be instantiated for paths
// `/org/foo/MyApp/main/`, `/org/foo/MyApp/document-1/`,
// `/org/foo/MyApp/document-2/`, etc. If any of the paths are well-known
// they can be specified as `&lt;child&gt;` elements in the parent schema, e.g.:
// ```xml
// &lt;schema id="org.foo.MyApp" path="/org/foo/MyApp/"&gt;
//   &lt;child name="main" schema="org.foo.MyApp.Window"/&gt;
// &lt;/schema&gt;
// ```
// 
// ## Build system integration
// 
// ### Meson
// 
// GSettings is natively supported by Meson&#x2019;s [GNOME module](https://mesonbuild.com/Gnome-module.html).
// 
// You can install the schemas as any other data file:
// 
// ```
// install_data(
//   'org.foo.MyApp.gschema.xml',
//   install_dir: get_option('datadir') / 'glib-2.0/schemas',
// )
// ```
// 
// You can use `gnome.post_install()` function to compile the schemas on
// installation:
// 
// ```
// gnome = import('gnome')
// gnome.post_install(
//   glib_compile_schemas: true,
// )
// ```
// 
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an `&lt;enum&gt;` element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, you will need to use the `gnome.mkenums()` function
// with the following templates:
// 
// ```
// schemas_enums = gnome.mkenums('org.foo.MyApp.enums.xml',
//   comments: '&lt;!-- @comment@ --&gt;',
//   fhead: '&lt;schemalist&gt;',
//   vhead: '  &lt;@type@ id="org.foo.MyApp.@EnumName@"&gt;',
//   vprod: '    &lt;value nick="@valuenick@" value="@valuenum@"/&gt;',
//   vtail: '  &lt;/@type@&gt;',
//   ftail: '&lt;/schemalist&gt;',
//   sources: enum_sources,
//   install_header: true,
//   install_dir: get_option('datadir') / 'glib-2.0/schemas',
// )
// ```
// 
// It is recommended to validate your schemas as part of the test suite for
// your application:
// 
// ```
// test('validate-schema',
//   find_program('glib-compile-schemas'),
//   args: ['--strict', '--dry-run', meson.current_source_dir()],
// )
// ```
// 
// If your application allows running uninstalled, you should also use the
// `gnome.compile_schemas()` function to compile the schemas in the current
// build directory:
// 
// ```
// gnome.compile_schemas()
// ```
// 
// ### Autotools
// 
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your `configure.ac`:
// ```
// GLIB_GSETTINGS
// ```
// 
// In the appropriate `Makefile.am`, use the following snippet to compile and
// install the named schema:
// ```
// gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
// EXTRA_DIST = $(gsettings_SCHEMAS)
// 
// @GSETTINGS_RULES@
// ```
// 
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an `&lt;enum&gt;` element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant `Makefile.am`:
// ```
// gsettings_ENUM_NAMESPACE = org.foo.MyApp
// gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
// ```
// 
// `gsettings_ENUM_NAMESPACE` specifies the schema namespace for the enum files,
// which are specified in `gsettings_ENUM_FILES`. This will generate a
// `org.foo.MyApp.enums.xml` file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// `EXTRA_DIST`.
// 
// ## Localization
// 
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the `gettext-domain` attribute, a schema may
// be marked for translation by adding it to `POTFILES.in`, assuming gettext
// 0.19 or newer is in use (the preferred method for translation):
// ```
// data/org.foo.MyApp.gschema.xml
// ```
// 
// Alternatively, if intltool 0.50.1 is in use:
// ```
// [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
// ```
// 
// GSettings will use gettext to look up translations for the `&lt;summary&gt;` and
// `&lt;description&gt;` elements, and also any `&lt;default&gt;` elements which have a
// `l10n` attribute set.
// 
// Translations **must not** be included in the `.gschema.xml` file by the build
// system, for example by using a rule to generate the XML file from a template.
type Settings interface {
	gobject.Object
	upcastToGSettings() *SettingsInstance

	// Apply wraps g_settings_apply
	//
	// Applies any changes that have been made to the settings.
	// 
	// This function does nothing unless @settings is in
	// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).  In the normal
	// case settings are always applied immediately.
	Apply()
	// CreateAction wraps g_settings_create_action
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the name of a key in @settings 
	// 
	// The function returns the following values:
	// 
	// 	- goret Action 
	//
	// Creates a [iface@Gio.Action] corresponding to a given [class@Gio.Settings] key.
	// 
	// The action has the same name as the key.
	// 
	// The value of the key becomes the state of the action and the action
	// is enabled when the key is writable.  Changing the state of the
	// action results in the key being written to.  Changes to the value or
	// writability of the key cause appropriate change notifications to be
	// emitted for the action.
	// 
	// For boolean-valued keys, action activations take no parameter and
	// result in the toggling of the value.  For all other types,
	// activations take the new value for the key (which must have the
	// correct type).
	CreateAction(string) Action
	// Delay wraps g_settings_delay
	//
	// Changes the [class@Gio.Settings] object into
	// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).
	// 
	// In this
	// mode, changes to @settings are not immediately propagated to the
	// backend, but kept locally until [method@Gio.Settings.apply] is called.
	Delay()
	// GetBoolean wraps g_settings_get_boolean
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for booleans.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetBoolean(string) bool
	// GetChild wraps g_settings_get_child
	// 
	// The function takes the following parameters:
	// 
	// 	- name string: the name of the child schema 
	// 
	// The function returns the following values:
	// 
	// 	- goret Settings 
	//
	// Creates a child settings object which has a base path of
	// `base-path/name`, where `base-path` is the base path of
	// @settings and `name` is as specified by the caller.
	// 
	// The schema for the child settings object must have been declared
	// in the schema of @settings using a `&lt;child&gt;` element.
	// 
	// The created child settings object will inherit the
	// [property@Gio.Settings:delay-apply] mode from @settings.
	GetChild(string) Settings
	// GetDouble wraps g_settings_get_double
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret float64 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for doubles.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetDouble(string) float64
	// GetEnum wraps g_settings_get_enum
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the value that is stored in @settings for @key and converts it
	// to the enum value that it represents.
	// 
	// In order to use this function the type of the value must be a string
	// and it must be marked in the schema file as an enumerated type.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t contained in the
	// schema for @settings or is not marked as an enumerated type.
	// 
	// If the value stored in the configuration database is not a valid
	// value for the enumerated type then this function will return the
	// default value.
	GetEnum(string) int32
	// GetFlags wraps g_settings_get_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the value that is stored in @settings for @key and converts it
	// to the flags value that it represents.
	// 
	// In order to use this function the type of the value must be an array
	// of strings and it must be marked in the schema file as a flags type.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t contained in the
	// schema for @settings or is not marked as a flags type.
	// 
	// If the value stored in the configuration database is not a valid
	// value for the flags type then this function will return the default
	// value.
	GetFlags(string) uint
	// GetHasUnapplied wraps g_settings_get_has_unapplied
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Returns whether the [class@Gio.Settings] object has any unapplied
	// changes.
	// 
	// This can only be the case if it is in
	// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).
	GetHasUnapplied() bool
	// GetInt wraps g_settings_get_int
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for 32-bit integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetInt(string) int32
	// GetInt64 wraps g_settings_get_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for 64-bit integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetInt64(string) int64
	// GetString wraps g_settings_get_string
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for strings.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetString(string) string
	// GetStrv wraps g_settings_get_strv
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// A convenience variant of [method@Gio.Settings.get] for string arrays.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetStrv(string) []string
	// GetUint wraps g_settings_get_uint
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for 32-bit unsigned
	// integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetUint(string) uint
	// GetUint64 wraps g_settings_get_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to get the value for 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint64 
	//
	// Gets the value that is stored at @key in @settings.
	// 
	// A convenience variant of [method@Gio.Settings.get] for 64-bit unsigned
	// integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
	GetUint64(string) uint64
	// IsWritable wraps g_settings_is_writable
	// 
	// The function takes the following parameters:
	// 
	// 	- name string: the name of a key 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Finds out if a key can be written.
	IsWritable(string) bool
	// ListChildren wraps g_settings_list_children
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the list of children on @settings.
	// 
	// The list is exactly the list of strings for which it is not an error
	// to call [method@Gio.Settings.get_child].
	// 
	// There is little reason to call this function from &#x2018;normal&#x2019; code, since
	// you should already know what children are in your schema. This function
	// may still be useful there for introspection reasons, however.
	// 
	// You should free the return value with [func@GLib.strfreev] when you are done
	// with it.
	ListChildren() []string
	// ListKeys wraps g_settings_list_keys
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Introspects the list of keys on @settings.
	// 
	// You should probably not be calling this function from &#x2018;normal&#x2019; code
	// (since you should already know what keys are in your schema).  This
	// function is intended for introspection reasons.
	// 
	// You should free the return value with [func@GLib.strfreev] when you are done
	// with it.
	//
	// Deprecated: (since 2.46.0) Use [method@Gio.SettingsSchema.list_keys] instead.
	ListKeys() []string
	// Reset wraps g_settings_reset
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the name of a key 
	//
	// Resets @key to its default value.
	// 
	// This call resets the key, as much as possible, to its default value.
	// That might be the value specified in the schema or the one set by the
	// administrator.
	Reset(string)
	// Revert wraps g_settings_revert
	//
	// Reverts all unapplied changes to the settings.
	// 
	// This function does nothing unless @settings is in
	// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).  In the normal
	// case settings are always applied immediately.
	// 
	// Change notifications will be emitted for affected keys.
	Revert()
	// SetBoolean wraps g_settings_set_boolean
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value bool: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for booleans.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetBoolean(string, bool) bool
	// SetDouble wraps g_settings_set_double
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value float64: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for doubles.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetDouble(string, float64) bool
	// SetEnum wraps g_settings_set_enum
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value int32: an enumerated value 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Looks up the enumerated type nick for @value and writes it to @key,
	// within @settings.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t contained in the
	// schema for @settings or is not marked as an enumerated type, or for
	// @value not to be a valid value for the named type.
	// 
	// After performing the write, accessing @key directly with
	// [method@Gio.Settings.get_string] will return the &#x2018;nick&#x2019; associated with
	// @value.
	SetEnum(string, int32) bool
	// SetFlags wraps g_settings_set_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value uint: a flags value 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Looks up the flags type nicks for the bits specified by @value, puts
	// them in an array of strings and writes the array to @key, within
	// @settings.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t contained in the
	// schema for @settings or is not marked as a flags type, or for @value
	// to contain any bits that are not value for the named type.
	// 
	// After performing the write, accessing @key directly with
	// [method@Gio.Settings.get_strv] will return an array of &#x2018;nicks&#x2019;; one for each
	// bit in @value.
	SetFlags(string, uint) bool
	// SetInt wraps g_settings_set_int
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value int32: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for 32-bit integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetInt(string, int32) bool
	// SetInt64 wraps g_settings_set_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value int64: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for 64-bit integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetInt64(string, int64) bool
	// SetString wraps g_settings_set_string
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value string: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for strings.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetString(string, string) bool
	// SetStrv wraps g_settings_set_strv
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value []string (nullable): the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for string arrays.  If
	// @value is `NULL`, then @key is set to be the empty array.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetStrv(string, []string) bool
	// SetUint wraps g_settings_set_uint
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value uint: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for 32-bit unsigned
	// integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetUint(string, uint) bool
	// SetUint64 wraps g_settings_set_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- key string: the key to set the value for 
	// 	- value uint64: the value to set it to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets @key in @settings to @value.
	// 
	// A convenience variant of [method@Gio.Settings.set] for 64-bit unsigned
	// integers.
	// 
	// It is a programmer error to give a @key that isn&#x2019;t specified as
	// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
	SetUint64(string, uint64) bool
	// ConnectChangeEvent connects the provided callback to the "change-event" signal
	//
	// Emitted once per change event that affects this settings object.
	// 
	// You should connect to this signal
	// only if you are interested in viewing groups of changes before they
	// are split out into multiple emissions of the [signal@Gio.Settings::changed] signal.
	// For most use cases it is more appropriate to use the [signal@Gio.Settings::changed] signal.
	// 
	// In the event that the change event applies to one or more specified
	// keys, @keys will be an array of [alias@GLib.Quark]s of length @n_keys.  In the
	// event that the change event applies to the [class@Gio.Settings] object as a
	// whole (ie: potentially every key has been changed) then @keys will
	// be `NULL` and @n_keys will be `0`.
	// 
	// The default handler for this signal invokes the [signal@Gio.Settings::changed] signal
	// for each affected key.  If any other connected handler returns
	// true then this default functionality will be suppressed.
	ConnectChangeEvent(func(Settings, []byte, int32) bool) gobject.SignalHandle
	// ConnectChanged connects the provided callback to the "changed" signal
	//
	// Emitted when a key has potentially changed.
	// 
	// You should call one of the [method@Gio.Settings.get] calls to check the new
	// value.
	// 
	// This signal supports detailed connections.  You can connect to the
	// detailed signal `changed::x` in order to only receive callbacks
	// when key `x` changes.
	// 
	// Note that @settings only emits this signal if you have read @key at
	// least once while a signal handler was already connected for @key.
	ConnectChanged(func(Settings, string)) gobject.SignalHandle
	// ConnectWritableChangeEvent connects the provided callback to the "writable-change-event" signal
	//
	// Emitted once per writability change event that affects this settings object.
	// 
	// You should connect
	// to this signal if you are interested in viewing groups of changes
	// before they are split out into multiple emissions of the
	// [signal@Gio.Settings::writable-changed] signal.  For most use cases it is more
	// appropriate to use the [signal@Gio.Settings::writable-changed] signal.
	// 
	// In the event that the writability change applies only to a single
	// key, @key will be set to the [alias@GLib.Quark] for that key.  In the event
	// that the writability change affects the entire settings object,
	// @key will be `0`.
	// 
	// The default handler for this signal invokes the [signal@Gio.Settings::writable-changed]
	// and [signal@Gio.Settings::changed] signals for each affected key.  This is done because
	// changes in writability might also imply changes in value (if for
	// example, a new mandatory setting is introduced).  If any other
	// connected handler returns true then this default functionality
	// will be suppressed.
	ConnectWritableChangeEvent(func(Settings, uint) bool) gobject.SignalHandle
	// ConnectWritableChanged connects the provided callback to the "writable-changed" signal
	//
	// Emitted when the writability of a key has potentially changed.
	// 
	// You should call [method@Gio.Settings.is_writable] in order to determine the
	// new status.
	// 
	// This signal supports detailed connections.  You can connect to the
	// detailed signal `writable-changed::x` in order to only receive
	// callbacks when the writability of `x` changes.
	ConnectWritableChanged(func(Settings, string)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentChangeEvent calls the default implementations of the `GSettings.change_event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- keys *glib.Quark 
	// 	- nKeys int32 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentChangeEvent(keys *glib.Quark, nKeys int32) bool
	// ParentChanged calls the default implementations of the `GSettings.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- key string 
	ParentChanged(key string)
	// ParentWritableChangeEvent calls the default implementations of the `GSettings.writable_change_event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- key glib.Quark 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentWritableChangeEvent(key glib.Quark) bool
	// ParentWritableChanged calls the default implementations of the `GSettings.writable_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- key string 
	ParentWritableChanged(key string)
}

func unsafeWrapSettings(base *gobject.ObjectInstance) *SettingsInstance {
	return &SettingsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSettings,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSettings(inst)
		},
	)
}

func marshalSettingsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSettingsFromGlibNone is used to convert raw GSettings pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSettingsFromGlibNone(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibNone(c).(Settings)
}

// UnsafeSettingsFromGlibFull is used to convert raw GSettings pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSettingsFromGlibFull(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibFull(c).(Settings)
}

// UnsafeSettingsFromGlibBorrow is used to convert raw GSettings pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSettingsFromGlibBorrow(c unsafe.Pointer) Settings {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Settings)
}

func (s *SettingsInstance) upcastToGSettings() *SettingsInstance {
	return s
}

// UnsafeSettingsToGlibNone is used to convert the instance to it's C value GSettings. This is used by the bindings internally.
func UnsafeSettingsToGlibNone(c Settings) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSettingsToGlibFull is used to convert the instance to it's C value GSettings, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSettingsToGlibFull(c Settings) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSettings wraps g_settings_new
// 
// The function takes the following parameters:
// 
// 	- schemaId string: the ID of the schema 
// 
// The function returns the following values:
// 
// 	- goret Settings 
//
// Creates a new [class@Gio.Settings] object with the schema specified by
// @schema_id.
// 
// It is an error for the schema to not exist: schemas are an
// essential part of a program, as they provide type information.
// If schemas need to be dynamically loaded (for example, from an
// optional runtime dependency), [method@Gio.SettingsSchemaSource.lookup]
// can be used to test for their existence before loading them.
// 
// Signals on the newly created [class@Gio.Settings] object will be dispatched
// via the thread-default [struct@GLib.MainContext] in effect at the time of the
// call to [ctor@Gio.Settings.new].  The new [class@Gio.Settings] will hold a reference
// on the context.  See [method@GLib.MainContext.push_thread_default].
func NewSettings(schemaId string) Settings {
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_new(carg1)
	runtime.KeepAlive(schemaId)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewSettingsWithPath wraps g_settings_new_with_path
// 
// The function takes the following parameters:
// 
// 	- schemaId string: the ID of the schema 
// 	- path string: the path to use 
// 
// The function returns the following values:
// 
// 	- goret Settings 
//
// Creates a new [class@Gio.Settings] object with the relocatable schema specified
// by @schema_id and a given path.
// 
// You only need to do this if you want to directly create a settings
// object with a schema that doesn&#x2019;t have a specified path of its own.
// That&#x2019;s quite rare.
// 
// It is a programmer error to call this function for a schema that
// has an explicitly specified path.
// 
// It is a programmer error if @path is not a valid path.  A valid path
// begins and ends with `/` and does not contain two consecutive `/`
// characters.
func NewSettingsWithPath(schemaId string, path string) Settings {
	var carg1 *C.gchar     // in, none, string
	var carg2 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_settings_new_with_path(carg1, carg2)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(path)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SettingsListRelocatableSchemas wraps g_settings_list_relocatable_schemas
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Deprecated.
//
// Deprecated: (since 2.40.0) Use g_settings_schema_source_list_schemas() instead
func SettingsListRelocatableSchemas() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_settings_list_relocatable_schemas()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// SettingsListSchemas wraps g_settings_list_schemas
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Deprecated.
//
// Deprecated: (since 2.40.0) Use g_settings_schema_source_list_schemas() instead.
// If you used g_settings_list_schemas() to check for the presence of
// a particular schema, use g_settings_schema_source_lookup() instead
// of your whole loop.
func SettingsListSchemas() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_settings_list_schemas()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// SettingsSync wraps g_settings_sync
//
// Ensures that all pending operations are complete for the default backend.
// 
// Writes made to a [class@Gio.Settings] are handled asynchronously.  For this
// reason, it is very unlikely that the changes have it to disk by the
// time [method@Gio.Settings.set] returns.
// 
// This call will block until all of the writes have made it to the
// backend.  Since the main loop is not running, no change notifications
// will be dispatched during this call (but some may be queued by the
// time the call is done).
func SettingsSync() {

	C.g_settings_sync()
}

// Apply wraps g_settings_apply
//
// Applies any changes that have been made to the settings.
// 
// This function does nothing unless @settings is in
// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).  In the normal
// case settings are always applied immediately.
func (settings *SettingsInstance) Apply() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_apply(carg0)
	runtime.KeepAlive(settings)
}

// CreateAction wraps g_settings_create_action
// 
// The function takes the following parameters:
// 
// 	- key string: the name of a key in @settings 
// 
// The function returns the following values:
// 
// 	- goret Action 
//
// Creates a [iface@Gio.Action] corresponding to a given [class@Gio.Settings] key.
// 
// The action has the same name as the key.
// 
// The value of the key becomes the state of the action and the action
// is enabled when the key is writable.  Changing the state of the
// action results in the key being written to.  Changes to the value or
// writability of the key cause appropriate change notifications to be
// emitted for the action.
// 
// For boolean-valued keys, action activations take no parameter and
// result in the toggling of the value.  For all other types,
// activations take the new value for the key (which must have the
// correct type).
func (settings *SettingsInstance) CreateAction(key string) Action {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GAction   // return, full, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_create_action(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret Action

	goret = UnsafeActionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Delay wraps g_settings_delay
//
// Changes the [class@Gio.Settings] object into
// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).
// 
// In this
// mode, changes to @settings are not immediately propagated to the
// backend, but kept locally until [method@Gio.Settings.apply] is called.
func (settings *SettingsInstance) Delay() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_delay(carg0)
	runtime.KeepAlive(settings)
}

// GetBoolean wraps g_settings_get_boolean
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for booleans.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetBoolean(key string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_boolean(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetChild wraps g_settings_get_child
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the child schema 
// 
// The function returns the following values:
// 
// 	- goret Settings 
//
// Creates a child settings object which has a base path of
// `base-path/name`, where `base-path` is the base path of
// @settings and `name` is as specified by the caller.
// 
// The schema for the child settings object must have been declared
// in the schema of @settings using a `&lt;child&gt;` element.
// 
// The created child settings object will inherit the
// [property@Gio.Settings:delay-apply] mode from @settings.
func (settings *SettingsInstance) GetChild(name string) Settings {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.GSettings // return, full, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_child(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var goret Settings

	goret = UnsafeSettingsFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDouble wraps g_settings_get_double
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for doubles.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetDouble(key string) float64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gdouble    // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_double(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret float64

	goret = float64(cret)

	return goret
}

// GetEnum wraps g_settings_get_enum
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the value that is stored in @settings for @key and converts it
// to the enum value that it represents.
// 
// In order to use this function the type of the value must be a string
// and it must be marked in the schema file as an enumerated type.
// 
// It is a programmer error to give a @key that isn&#x2019;t contained in the
// schema for @settings or is not marked as an enumerated type.
// 
// If the value stored in the configuration database is not a valid
// value for the enumerated type then this function will return the
// default value.
func (settings *SettingsInstance) GetEnum(key string) int32 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_enum(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetFlags wraps g_settings_get_flags
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the value that is stored in @settings for @key and converts it
// to the flags value that it represents.
// 
// In order to use this function the type of the value must be an array
// of strings and it must be marked in the schema file as a flags type.
// 
// It is a programmer error to give a @key that isn&#x2019;t contained in the
// schema for @settings or is not marked as a flags type.
// 
// If the value stored in the configuration database is not a valid
// value for the flags type then this function will return the default
// value.
func (settings *SettingsInstance) GetFlags(key string) uint {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint      // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_flags(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetHasUnapplied wraps g_settings_get_has_unapplied
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the [class@Gio.Settings] object has any unapplied
// changes.
// 
// This can only be the case if it is in
// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).
func (settings *SettingsInstance) GetHasUnapplied() bool {
	var carg0 *C.GSettings // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_get_has_unapplied(carg0)
	runtime.KeepAlive(settings)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetInt wraps g_settings_get_int
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for 32-bit integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetInt(key string) int32 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_int(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetInt64 wraps g_settings_get_int64
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for 64-bit integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetInt64(key string) int64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gint64     // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_int64(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret int64

	goret = int64(cret)

	return goret
}

// GetString wraps g_settings_get_string
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for strings.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetString(key string) string {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  *C.gchar     // return, full, string

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_string(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetStrv wraps g_settings_get_strv
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// A convenience variant of [method@Gio.Settings.get] for string arrays.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetStrv(key string) []string {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_strv(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetUint wraps g_settings_get_uint
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for 32-bit unsigned
// integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetUint(key string) uint {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint      // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_uint(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetUint64 wraps g_settings_get_uint64
// 
// The function takes the following parameters:
// 
// 	- key string: the key to get the value for 
// 
// The function returns the following values:
// 
// 	- goret uint64 
//
// Gets the value that is stored at @key in @settings.
// 
// A convenience variant of [method@Gio.Settings.get] for 64-bit unsigned
// integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) GetUint64(key string) uint64 {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.guint64    // return, none, casted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_get_uint64(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret uint64

	goret = uint64(cret)

	return goret
}

// IsWritable wraps g_settings_is_writable
// 
// The function takes the following parameters:
// 
// 	- name string: the name of a key 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Finds out if a key can be written.
func (settings *SettingsInstance) IsWritable(name string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_is_writable(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListChildren wraps g_settings_list_children
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the list of children on @settings.
// 
// The list is exactly the list of strings for which it is not an error
// to call [method@Gio.Settings.get_child].
// 
// There is little reason to call this function from &#x2018;normal&#x2019; code, since
// you should already know what children are in your schema. This function
// may still be useful there for introspection reasons, however.
// 
// You should free the return value with [func@GLib.strfreev] when you are done
// with it.
func (settings *SettingsInstance) ListChildren() []string {
	var carg0 *C.GSettings // in, none, converted
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_list_children(carg0)
	runtime.KeepAlive(settings)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ListKeys wraps g_settings_list_keys
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Introspects the list of keys on @settings.
// 
// You should probably not be calling this function from &#x2018;normal&#x2019; code
// (since you should already know what keys are in your schema).  This
// function is intended for introspection reasons.
// 
// You should free the return value with [func@GLib.strfreev] when you are done
// with it.
//
// Deprecated: (since 2.46.0) Use [method@Gio.SettingsSchema.list_keys] instead.
func (settings *SettingsInstance) ListKeys() []string {
	var carg0 *C.GSettings // in, none, converted
	var cret  **C.gchar    // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	cret = C.g_settings_list_keys(carg0)
	runtime.KeepAlive(settings)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// Reset wraps g_settings_reset
// 
// The function takes the following parameters:
// 
// 	- key string: the name of a key 
//
// Resets @key to its default value.
// 
// This call resets the key, as much as possible, to its default value.
// That might be the value specified in the schema or the one set by the
// administrator.
func (settings *SettingsInstance) Reset(key string) {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_settings_reset(carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// Revert wraps g_settings_revert
//
// Reverts all unapplied changes to the settings.
// 
// This function does nothing unless @settings is in
// [&#x2018;delay-apply&#x2019; mode](class.Settings.html#delay-apply-mode).  In the normal
// case settings are always applied immediately.
// 
// Change notifications will be emitted for affected keys.
func (settings *SettingsInstance) Revert() {
	var carg0 *C.GSettings // in, none, converted

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))

	C.g_settings_revert(carg0)
	runtime.KeepAlive(settings)
}

// SetBoolean wraps g_settings_set_boolean
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value bool: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for booleans.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `b` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetBoolean(key string, value bool) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gboolean   // in
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	if value {
		carg2 = C.TRUE
	}

	cret = C.g_settings_set_boolean(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetDouble wraps g_settings_set_double
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value float64: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for doubles.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `d` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetDouble(key string, value float64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gdouble    // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gdouble(value)

	cret = C.g_settings_set_double(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetEnum wraps g_settings_set_enum
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value int32: an enumerated value 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks up the enumerated type nick for @value and writes it to @key,
// within @settings.
// 
// It is a programmer error to give a @key that isn&#x2019;t contained in the
// schema for @settings or is not marked as an enumerated type, or for
// @value not to be a valid value for the named type.
// 
// After performing the write, accessing @key directly with
// [method@Gio.Settings.get_string] will return the &#x2018;nick&#x2019; associated with
// @value.
func (settings *SettingsInstance) SetEnum(key string, value int32) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(value)

	cret = C.g_settings_set_enum(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetFlags wraps g_settings_set_flags
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value uint: a flags value 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks up the flags type nicks for the bits specified by @value, puts
// them in an array of strings and writes the array to @key, within
// @settings.
// 
// It is a programmer error to give a @key that isn&#x2019;t contained in the
// schema for @settings or is not marked as a flags type, or for @value
// to contain any bits that are not value for the named type.
// 
// After performing the write, accessing @key directly with
// [method@Gio.Settings.get_strv] will return an array of &#x2018;nicks&#x2019;; one for each
// bit in @value.
func (settings *SettingsInstance) SetFlags(key string, value uint) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint      // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(value)

	cret = C.g_settings_set_flags(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetInt wraps g_settings_set_int
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value int32: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for 32-bit integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `i` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetInt(key string, value int32) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(value)

	cret = C.g_settings_set_int(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetInt64 wraps g_settings_set_int64
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value int64: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for 64-bit integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `x` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetInt64(key string, value int64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.gint64     // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint64(value)

	cret = C.g_settings_set_int64(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetString wraps g_settings_set_string
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value string: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for strings.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `s` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetString(key string, value string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 *C.gchar     // in, none, string
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_settings_set_string(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetStrv wraps g_settings_set_strv
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value []string (nullable): the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for string arrays.  If
// @value is `NULL`, then @key is set to be the empty array.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having an `as` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetStrv(key string, value []string) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 **C.gchar    // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	_ = value
	_ = carg2
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_settings_set_strv(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUint wraps g_settings_set_uint
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value uint: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for 32-bit unsigned
// integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `u` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetUint(key string, value uint) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint      // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(value)

	cret = C.g_settings_set_uint(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetUint64 wraps g_settings_set_uint64
// 
// The function takes the following parameters:
// 
// 	- key string: the key to set the value for 
// 	- value uint64: the value to set it to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets @key in @settings to @value.
// 
// A convenience variant of [method@Gio.Settings.set] for 64-bit unsigned
// integers.
// 
// It is a programmer error to give a @key that isn&#x2019;t specified as
// having a `t` type in the schema for @settings (see [struct@GLib.VariantType]).
func (settings *SettingsInstance) SetUint64(key string, value uint64) bool {
	var carg0 *C.GSettings // in, none, converted
	var carg1 *C.gchar     // in, none, string
	var carg2 C.guint64    // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint64(value)

	cret = C.g_settings_set_uint64(carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ConnectChangeEvent connects the provided callback to the "change-event" signal
//
// Emitted once per change event that affects this settings object.
// 
// You should connect to this signal
// only if you are interested in viewing groups of changes before they
// are split out into multiple emissions of the [signal@Gio.Settings::changed] signal.
// For most use cases it is more appropriate to use the [signal@Gio.Settings::changed] signal.
// 
// In the event that the change event applies to one or more specified
// keys, @keys will be an array of [alias@GLib.Quark]s of length @n_keys.  In the
// event that the change event applies to the [class@Gio.Settings] object as a
// whole (ie: potentially every key has been changed) then @keys will
// be `NULL` and @n_keys will be `0`.
// 
// The default handler for this signal invokes the [signal@Gio.Settings::changed] signal
// for each affected key.  If any other connected handler returns
// true then this default functionality will be suppressed.
func (o *SettingsInstance) ConnectChangeEvent(fn func(Settings, []byte, int32) bool) gobject.SignalHandle {
	return o.Connect("change-event", fn)
}

// ConnectChanged connects the provided callback to the "changed" signal
//
// Emitted when a key has potentially changed.
// 
// You should call one of the [method@Gio.Settings.get] calls to check the new
// value.
// 
// This signal supports detailed connections.  You can connect to the
// detailed signal `changed::x` in order to only receive callbacks
// when key `x` changes.
// 
// Note that @settings only emits this signal if you have read @key at
// least once while a signal handler was already connected for @key.
func (o *SettingsInstance) ConnectChanged(fn func(Settings, string)) gobject.SignalHandle {
	return o.Connect("changed", fn)
}

// ConnectWritableChangeEvent connects the provided callback to the "writable-change-event" signal
//
// Emitted once per writability change event that affects this settings object.
// 
// You should connect
// to this signal if you are interested in viewing groups of changes
// before they are split out into multiple emissions of the
// [signal@Gio.Settings::writable-changed] signal.  For most use cases it is more
// appropriate to use the [signal@Gio.Settings::writable-changed] signal.
// 
// In the event that the writability change applies only to a single
// key, @key will be set to the [alias@GLib.Quark] for that key.  In the event
// that the writability change affects the entire settings object,
// @key will be `0`.
// 
// The default handler for this signal invokes the [signal@Gio.Settings::writable-changed]
// and [signal@Gio.Settings::changed] signals for each affected key.  This is done because
// changes in writability might also imply changes in value (if for
// example, a new mandatory setting is introduced).  If any other
// connected handler returns true then this default functionality
// will be suppressed.
func (o *SettingsInstance) ConnectWritableChangeEvent(fn func(Settings, uint) bool) gobject.SignalHandle {
	return o.Connect("writable-change-event", fn)
}

// ConnectWritableChanged connects the provided callback to the "writable-changed" signal
//
// Emitted when the writability of a key has potentially changed.
// 
// You should call [method@Gio.Settings.is_writable] in order to determine the
// new status.
// 
// This signal supports detailed connections.  You can connect to the
// detailed signal `writable-changed::x` in order to only receive
// callbacks when the writability of `x` changes.
func (o *SettingsInstance) ConnectWritableChanged(fn func(Settings, string)) gobject.SignalHandle {
	return o.Connect("writable-changed", fn)
}

// SettingsOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SettingsOverrides[Instance Settings] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // ChangeEvent allows you to override the implementation of the virtual method change_event.
	// 
	// The function takes the following parameters:
	// 
	// 	- keys *glib.Quark 
	// 	- nKeys int32 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ChangeEvent func(Instance, *glib.Quark, int32) bool
	// // Changed allows you to override the implementation of the virtual method changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- key string 
	Changed func(Instance, string)
	// // WritableChangeEvent allows you to override the implementation of the virtual method writable_change_event.
	// 
	// The function takes the following parameters:
	// 
	// 	- key glib.Quark 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	WritableChangeEvent func(Instance, glib.Quark) bool
	// // WritableChanged allows you to override the implementation of the virtual method writable_changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- key string 
	WritableChanged func(Instance, string)
}

// UnsafeApplySettingsOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySettingsOverrides[Instance Settings](gclass unsafe.Pointer, overrides SettingsOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSettingsClass)(gclass)

	if overrides.ChangeEvent != nil {
		pclass.change_event = (*[0]byte)(C._goglib_gio2_Settings_change_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_change_event",
			func(carg0 *C.GSettings, carg1 *C.GQuark, carg2 C.gint) (cret C.gboolean) {
				var settings Instance    // go GSettings subclass
				var keys     *glib.Quark // in, transfer: none, C Pointers: 1, Name: Quark
				var nKeys    int32       // in, none, casted
				var goret    bool        // return

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				_ = keys
				_ = carg1
				panic("unimplemented conversion of *glib.Quark (const GQuark*) because of unknown reason")
				nKeys = int32(carg2)

				goret = overrides.ChangeEvent(settings, keys, nKeys)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_Settings_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_changed",
			func(carg0 *C.GSettings, carg1 *C.gchar) {
				var settings Instance // go GSettings subclass
				var key      string   // in, none, string

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.Changed(settings, key)
			},
		)
	}

	if overrides.WritableChangeEvent != nil {
		pclass.writable_change_event = (*[0]byte)(C._goglib_gio2_Settings_writable_change_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_writable_change_event",
			func(carg0 *C.GSettings, carg1 C.GQuark) (cret C.gboolean) {
				var settings Instance   // go GSettings subclass
				var key      glib.Quark // in, none, casted, alias
				var goret    bool       // return

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = glib.Quark(carg1)

				goret = overrides.WritableChangeEvent(settings, key)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.WritableChanged != nil {
		pclass.writable_changed = (*[0]byte)(C._goglib_gio2_Settings_writable_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Settings_writable_changed",
			func(carg0 *C.GSettings, carg1 *C.gchar) {
				var settings Instance // go GSettings subclass
				var key      string   // in, none, string

				settings = UnsafeSettingsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				key = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.WritableChanged(settings, key)
			},
		)
	}
}

// ParentChangeEvent calls the default implementations of the `GSettings.change_event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- keys *glib.Quark 
// 	- nKeys int32 
// 
// The function returns the following values:
// 
// 	- goret bool 
func (settings *SettingsInstance) ParentChangeEvent(keys *glib.Quark, nKeys int32) bool {
	var carg0 *C.GSettings
	var carg1 *C.GQuark  // in, none, converted
	var carg2 C.gint     // in, transfer: none, C Pointers: 1, Name: Quark
	var cret  C.gboolean // return

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	_ = keys
	_ = carg1
	panic("unimplemented conversion of *glib.Quark (const GQuark*) because of unsupported aliased type")
	carg2 = C.gint(nKeys)

	cret = C._goglib_gio2_Settings_virtual_change_event(unsafe.Pointer(parentclass.change_event), carg0, carg1, carg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keys)
	runtime.KeepAlive(nKeys)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentChanged calls the default implementations of the `GSettings.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- key string 
func (settings *SettingsInstance) ParentChanged(key string) {
	var carg0 *C.GSettings
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Settings_virtual_changed(unsafe.Pointer(parentclass.changed), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// ParentWritableChangeEvent calls the default implementations of the `GSettings.writable_change_event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- key glib.Quark 
// 
// The function returns the following values:
// 
// 	- goret bool 
func (settings *SettingsInstance) ParentWritableChangeEvent(key glib.Quark) bool {
	var carg0 *C.GSettings
	var carg1 C.GQuark   // in, none, converted
	var cret  C.gboolean // return

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = C.GQuark(key)

	cret = C._goglib_gio2_Settings_virtual_writable_change_event(unsafe.Pointer(parentclass.writable_change_event), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentWritableChanged calls the default implementations of the `GSettings.writable_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- key string 
func (settings *SettingsInstance) ParentWritableChanged(key string) {
	var carg0 *C.GSettings
	var carg1 *C.gchar // in, none, converted

	parentclass := (*C.GSettingsClass)(classdata.PeekParentClass(UnsafeSettingsToGlibNone(settings)))

	carg0 = (*C.GSettings)(UnsafeSettingsToGlibNone(settings))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Settings_virtual_writable_changed(unsafe.Pointer(parentclass.writable_changed), carg0, carg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// RegisterSettingsSubClass is used to register a go subclass of GSettings. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSettingsSubClass[InstanceT Settings](
		name string,
		classInit func(class *SettingsClass),
		constructor func() InstanceT,
		overrides SettingsOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSettings,
		UnsafeSettingsClassFromGlibBorrow,
		UnsafeApplySettingsOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSettings(obj)
		},
		interfaceInits...,
	)
}

// SimpleActionInstance is the instance type used by all types extending GSimpleAction. It is used internally by the bindings. Users should use the interface [SimpleAction] instead.
type SimpleActionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleAction = (*SimpleActionInstance)(nil)

// SimpleAction wraps GSimpleAction
//
// A `GSimpleAction` is the obvious simple implementation of the
// [iface@Gio.Action] interface. This is the easiest way to create an action for
// purposes of adding it to a [class@Gio.SimpleActionGroup].
type SimpleAction interface {
	gobject.Object
	upcastToGSimpleAction() *SimpleActionInstance

	// SetEnabled wraps g_simple_action_set_enabled
	// 
	// The function takes the following parameters:
	// 
	// 	- enabled bool: whether the action is enabled 
	//
	// Sets the action as enabled or not.
	// 
	// An action must be enabled in order to be activated or in order to
	// have its state changed from outside callers.
	// 
	// This should only be called by the implementor of the action.  Users
	// of the action should not attempt to modify its enabled flag.
	SetEnabled(bool)
}

func unsafeWrapSimpleAction(base *gobject.ObjectInstance) *SimpleActionInstance {
	return &SimpleActionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleAction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleAction(inst)
		},
	)
}

func marshalSimpleActionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleActionFromGlibNone is used to convert raw GSimpleAction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibNone(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleAction)
}

// UnsafeSimpleActionFromGlibFull is used to convert raw GSimpleAction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibFull(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleAction)
}

// UnsafeSimpleActionFromGlibBorrow is used to convert raw GSimpleAction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleActionFromGlibBorrow(c unsafe.Pointer) SimpleAction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleAction)
}

func (s *SimpleActionInstance) upcastToGSimpleAction() *SimpleActionInstance {
	return s
}

// UnsafeSimpleActionToGlibNone is used to convert the instance to it's C value GSimpleAction. This is used by the bindings internally.
func UnsafeSimpleActionToGlibNone(c SimpleAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleActionToGlibFull is used to convert the instance to it's C value GSimpleAction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleActionToGlibFull(c SimpleAction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleAction wraps g_simple_action_new
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the action 
// 	- parameterType *glib.VariantType (nullable): the type of parameter that will be passed to
//   handlers for the #GSimpleAction::activate signal, or %NULL for no parameter 
// 
// The function returns the following values:
// 
// 	- goret SimpleAction 
//
// Creates a new action.
// 
// The created action is stateless. See g_simple_action_new_stateful() to create
// an action that has state.
func NewSimpleAction(name string, parameterType *glib.VariantType) SimpleAction {
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.GVariantType  // in, none, converted, nullable
	var cret  *C.GSimpleAction // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if parameterType != nil {
		carg2 = (*C.GVariantType)(glib.UnsafeVariantTypeToGlibNone(parameterType))
	}

	cret = C.g_simple_action_new(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(parameterType)

	var goret SimpleAction

	goret = UnsafeSimpleActionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetEnabled wraps g_simple_action_set_enabled
// 
// The function takes the following parameters:
// 
// 	- enabled bool: whether the action is enabled 
//
// Sets the action as enabled or not.
// 
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
// 
// This should only be called by the implementor of the action.  Users
// of the action should not attempt to modify its enabled flag.
func (simple *SimpleActionInstance) SetEnabled(enabled bool) {
	var carg0 *C.GSimpleAction // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSimpleAction)(UnsafeSimpleActionToGlibNone(simple))
	if enabled {
		carg1 = C.TRUE
	}

	C.g_simple_action_set_enabled(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(enabled)
}

// SimpleActionGroupInstance is the instance type used by all types extending GSimpleActionGroup. It is used internally by the bindings. Users should use the interface [SimpleActionGroup] instead.
type SimpleActionGroupInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleActionGroup = (*SimpleActionGroupInstance)(nil)

// SimpleActionGroup wraps GSimpleActionGroup
//
// `GSimpleActionGroup` is a hash table filled with [iface@Gio.Action] objects,
// implementing the [iface@Gio.ActionGroup] and [iface@Gio.ActionMap]
// interfaces.
type SimpleActionGroup interface {
	gobject.Object
	upcastToGSimpleActionGroup() *SimpleActionGroupInstance

	// Insert wraps g_simple_action_group_insert
	// 
	// The function takes the following parameters:
	// 
	// 	- action Action: a #GAction 
	//
	// Adds an action to the action group.
	// 
	// If the action group already contains an action with the same name as
	// @action then the old action is dropped from the group.
	// 
	// The action group takes its own reference on @action.
	//
	// Deprecated: (since 2.38.0) Use g_action_map_add_action()
	Insert(Action)
	// Lookup wraps g_simple_action_group_lookup
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of an action 
	// 
	// The function returns the following values:
	// 
	// 	- goret Action 
	//
	// Looks up the action with the name @action_name in the group.
	// 
	// If no such action exists, returns %NULL.
	//
	// Deprecated: (since 2.38.0) Use g_action_map_lookup_action()
	Lookup(string) Action
	// Remove wraps g_simple_action_group_remove
	// 
	// The function takes the following parameters:
	// 
	// 	- actionName string: the name of the action 
	//
	// Removes the named action from the action group.
	// 
	// If no action of this name is in the group then nothing happens.
	//
	// Deprecated: (since 2.38.0) Use g_action_map_remove_action()
	Remove(string)

	// chain up virtual methods:
}

func unsafeWrapSimpleActionGroup(base *gobject.ObjectInstance) *SimpleActionGroupInstance {
	return &SimpleActionGroupInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleActionGroup,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleActionGroup(inst)
		},
	)
}

func marshalSimpleActionGroupInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleActionGroupFromGlibNone is used to convert raw GSimpleActionGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibNone(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleActionGroup)
}

// UnsafeSimpleActionGroupFromGlibFull is used to convert raw GSimpleActionGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibFull(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleActionGroup)
}

// UnsafeSimpleActionGroupFromGlibBorrow is used to convert raw GSimpleActionGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleActionGroupFromGlibBorrow(c unsafe.Pointer) SimpleActionGroup {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleActionGroup)
}

func (s *SimpleActionGroupInstance) upcastToGSimpleActionGroup() *SimpleActionGroupInstance {
	return s
}

// UnsafeSimpleActionGroupToGlibNone is used to convert the instance to it's C value GSimpleActionGroup. This is used by the bindings internally.
func UnsafeSimpleActionGroupToGlibNone(c SimpleActionGroup) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleActionGroupToGlibFull is used to convert the instance to it's C value GSimpleActionGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleActionGroupToGlibFull(c SimpleActionGroup) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleActionGroup wraps g_simple_action_group_new
// 
// The function returns the following values:
// 
// 	- goret SimpleActionGroup 
//
// Creates a new, empty, #GSimpleActionGroup.
func NewSimpleActionGroup() SimpleActionGroup {
	var cret *C.GSimpleActionGroup // return, full, converted

	cret = C.g_simple_action_group_new()

	var goret SimpleActionGroup

	goret = UnsafeSimpleActionGroupFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Insert wraps g_simple_action_group_insert
// 
// The function takes the following parameters:
// 
// 	- action Action: a #GAction 
//
// Adds an action to the action group.
// 
// If the action group already contains an action with the same name as
// @action then the old action is dropped from the group.
// 
// The action group takes its own reference on @action.
//
// Deprecated: (since 2.38.0) Use g_action_map_add_action()
func (simple *SimpleActionGroupInstance) Insert(action Action) {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.GAction            // in, none, converted

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.GAction)(UnsafeActionToGlibNone(action))

	C.g_simple_action_group_insert(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(action)
}

// Lookup wraps g_simple_action_group_lookup
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of an action 
// 
// The function returns the following values:
// 
// 	- goret Action 
//
// Looks up the action with the name @action_name in the group.
// 
// If no such action exists, returns %NULL.
//
// Deprecated: (since 2.38.0) Use g_action_map_lookup_action()
func (simple *SimpleActionGroupInstance) Lookup(actionName string) Action {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var cret  *C.GAction            // return, none, converted

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_simple_action_group_lookup(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)

	var goret Action

	goret = UnsafeActionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Remove wraps g_simple_action_group_remove
// 
// The function takes the following parameters:
// 
// 	- actionName string: the name of the action 
//
// Removes the named action from the action group.
// 
// If no action of this name is in the group then nothing happens.
//
// Deprecated: (since 2.38.0) Use g_action_map_remove_action()
func (simple *SimpleActionGroupInstance) Remove(actionName string) {
	var carg0 *C.GSimpleActionGroup // in, none, converted
	var carg1 *C.gchar              // in, none, string

	carg0 = (*C.GSimpleActionGroup)(UnsafeSimpleActionGroupToGlibNone(simple))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_simple_action_group_remove(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(actionName)
}

// SimpleActionGroupOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SimpleActionGroupOverrides[Instance SimpleActionGroup] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySimpleActionGroupOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySimpleActionGroupOverrides[Instance SimpleActionGroup](gclass unsafe.Pointer, overrides SimpleActionGroupOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSimpleActionGroupSubClass is used to register a go subclass of GSimpleActionGroup. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSimpleActionGroupSubClass[InstanceT SimpleActionGroup](
		name string,
		classInit func(class *SimpleActionGroupClass),
		constructor func() InstanceT,
		overrides SimpleActionGroupOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSimpleActionGroup,
		UnsafeSimpleActionGroupClassFromGlibBorrow,
		UnsafeApplySimpleActionGroupOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleActionGroup(obj)
		},
		interfaceInits...,
	)
}

// SimpleAsyncResultInstance is the instance type used by all types extending GSimpleAsyncResult. It is used internally by the bindings. Users should use the interface [SimpleAsyncResult] instead.
type SimpleAsyncResultInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleAsyncResult = (*SimpleAsyncResultInstance)(nil)

// SimpleAsyncResult wraps GSimpleAsyncResult
//
// As of GLib 2.46, `GSimpleAsyncResult` is deprecated in favor of
// [class@Gio.Task], which provides a simpler API.
// 
// `GSimpleAsyncResult` implements [iface@Gio.AsyncResult].
// 
// `GSimpleAsyncResult` handles [type@Gio.AsyncReadyCallback]s, error
// reporting, operation cancellation and the final state of an operation,
// completely transparent to the application. Results can be returned
// as a pointer e.g. for functions that return data that is collected
// asynchronously, a boolean value for checking the success or failure
// of an operation, or a `gssize` for operations which return the number
// of bytes modified by the operation; all of the simple return cases
// are covered.
// 
// Most of the time, an application will not need to know of the details
// of this API; it is handled transparently, and any necessary operations
// are handled by [iface@Gio.AsyncResult]&#x2019;s interface. However, if implementing
// a new GIO module, for writing language bindings, or for complex
// applications that need better control of how asynchronous operations
// are completed, it is important to understand this functionality.
// 
// `GSimpleAsyncResult`s are tagged with the calling function to ensure
// that asynchronous functions and their finishing functions are used
// together correctly.
// 
// To create a new `GSimpleAsyncResult`, call [ctor@Gio.SimpleAsyncResult.new].
// If the result needs to be created for a `GError`, use
// [ctor@Gio.SimpleAsyncResult.new_from_error] or
// [ctor@Gio.SimpleAsyncResult.new_take_error]. If a `GError` is not available
// (e.g. the asynchronous operation doesn&#x2019;t take a `GError` argument),
// but the result still needs to be created for an error condition, use
// [ctor@Gio.SimpleAsyncResult.new_error] (or
// [method@Gio.SimpleAsyncResult.set_error_va] if your application or binding
// requires passing a variable argument list directly), and the error can then
// be propagated through the use of
// [method@Gio.SimpleAsyncResult.propagate_error].
// 
// An asynchronous operation can be made to ignore a cancellation event by
// calling [method@Gio.SimpleAsyncResult.set_handle_cancellation] with a
// `GSimpleAsyncResult` for the operation and `FALSE`. This is useful for
// operations that are dangerous to cancel, such as close (which would
// cause a leak if cancelled before being run).
// 
// `GSimpleAsyncResult` can integrate into GLib&#x2019;s event loop,
// [type@GLib.MainLoop], or it can use [type@GLib.Thread]s.
// [method@Gio.SimpleAsyncResult.complete] will finish an I/O task directly
// from the point where it is called.
// [method@Gio.SimpleAsyncResult.complete_in_idle] will finish it from an idle
// handler in the  thread-default main context (see
// [method@GLib.MainContext.push_thread_default]) where the `GSimpleAsyncResult`
// was created. [method@Gio.SimpleAsyncResult.run_in_thread] will run the job in
// a separate thread and then use
// [method@Gio.SimpleAsyncResult.complete_in_idle] to deliver the result.
// 
// To set the results of an asynchronous function,
// [method@Gio.SimpleAsyncResult.set_op_res_gpointer],
// [method@Gio.SimpleAsyncResult.set_op_res_gboolean], and
// [method@Gio.SimpleAsyncResult.set_op_res_gssize]
// are provided, setting the operation's result to a `gpointer`, `gboolean`, or
// `gssize`, respectively.
// 
// Likewise, to get the result of an asynchronous function,
// [method@Gio.SimpleAsyncResult.get_op_res_gpointer],
// [method@Gio.SimpleAsyncResult.get_op_res_gboolean], and
// [method@Gio.SimpleAsyncResult.get_op_res_gssize] are
// provided, getting the operation&#x2019;s result as a `gpointer`, `gboolean`, and
// `gssize`, respectively.
// 
// For the details of the requirements implementations must respect, see
// [iface@Gio.AsyncResult].  A typical implementation of an asynchronous
// operation using `GSimpleAsyncResult` looks something like this:
// 
// ```c
// static void
// baked_cb (Cake    *cake,
//           gpointer user_data)
// {
//   // In this example, this callback is not given a reference to the cake,
//   // so the GSimpleAsyncResult has to take a reference to it.
//   GSimpleAsyncResult *result = user_data;
// 
//   if (cake == NULL)
//     g_simple_async_result_set_error (result,
//                                      BAKER_ERRORS,
//                                      BAKER_ERROR_NO_FLOUR,
//                                      "Go to the supermarket");
//   else
//     g_simple_async_result_set_op_res_gpointer (result,
//                                                g_object_ref (cake),
//                                                g_object_unref);
// 
// 
//   // In this example, we assume that baked_cb is called as a callback from
//   // the mainloop, so it's safe to complete the operation synchronously here.
//   // If, however, _baker_prepare_cake () might call its callback without
//   // first returning to the mainloop &#x2014; inadvisable, but some APIs do so &#x2014;
//   // we would need to use g_simple_async_result_complete_in_idle().
//   g_simple_async_result_complete (result);
//   g_object_unref (result);
// }
// 
// void
// baker_bake_cake_async (Baker              *self,
//                        guint               radius,
//                        GAsyncReadyCallback callback,
//                        gpointer            user_data)
// {
//   GSimpleAsyncResult *simple;
//   Cake               *cake;
// 
//   if (radius &lt; 3)
//     {
//       g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                            callback,
//                                            user_data,
//                                            BAKER_ERRORS,
//                                            BAKER_ERROR_TOO_SMALL,
//                                            "%ucm radius cakes are silly",
//                                            radius);
//       return;
//     }
// 
//   simple = g_simple_async_result_new (G_OBJECT (self),
//                                       callback,
//                                       user_data,
//                                       baker_bake_cake_async);
//   cake = _baker_get_cached_cake (self, radius);
// 
//   if (cake != NULL)
//     {
//       g_simple_async_result_set_op_res_gpointer (simple,
//                                                  g_object_ref (cake),
//                                                  g_object_unref);
//       g_simple_async_result_complete_in_idle (simple);
//       g_object_unref (simple);
//       // Drop the reference returned by _baker_get_cached_cake();
//       // the GSimpleAsyncResult has taken its own reference.
//       g_object_unref (cake);
//       return;
//     }
// 
//   _baker_prepare_cake (self, radius, baked_cb, simple);
// }
// 
// Cake *
// baker_bake_cake_finish (Baker        *self,
//                         GAsyncResult *result,
//                         GError      **error)
// {
//   GSimpleAsyncResult *simple;
//   Cake               *cake;
// 
//   g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                         G_OBJECT (self),
//                                                         baker_bake_cake_async),
//                         NULL);
// 
//   simple = (GSimpleAsyncResult *) result;
// 
//   if (g_simple_async_result_propagate_error (simple, error))
//     return NULL;
// 
//   cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//   return g_object_ref (cake);
// }
// ```
type SimpleAsyncResult interface {
	gobject.Object
	upcastToGSimpleAsyncResult() *SimpleAsyncResultInstance

	// Complete wraps g_simple_async_result_complete
	//
	// Completes an asynchronous I/O job immediately. Must be called in
	// the thread where the asynchronous result was to be delivered, as it
	// invokes the callback directly. If you are in a different thread use
	// g_simple_async_result_complete_in_idle().
	// 
	// Calling this function takes a reference to @simple for as long as
	// is needed to complete the call.
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	Complete()
	// CompleteInIdle wraps g_simple_async_result_complete_in_idle
	//
	// Completes an asynchronous function in an idle handler in the
	// thread-default main context (see [method@GLib.MainContext.push_thread_default])
	// of the thread that @simple was initially created in
	// (and re-pushes that context around the invocation of the callback).
	// 
	// Calling this function takes a reference to @simple for as long as
	// is needed to complete the call.
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	CompleteInIdle()
	// GetOpResGboolean wraps g_simple_async_result_get_op_res_gboolean
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the operation result boolean from within the asynchronous result.
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_boolean() instead.
	GetOpResGboolean() bool
	// GetOpResGssize wraps g_simple_async_result_get_op_res_gssize
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	//
	// Gets a gssize from the asynchronous result.
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_int() instead.
	GetOpResGssize() int
	// PropagateError wraps g_simple_async_result_propagate_error
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Propagates an error from within the simple asynchronous result to
	// a given destination.
	// 
	// If the #GCancellable given to a prior call to
	// g_simple_async_result_set_check_cancellable() is cancelled then this
	// function will return %TRUE with @dest set appropriately.
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	PropagateError() (bool, error)
	// SetCheckCancellable wraps g_simple_async_result_set_check_cancellable
	// 
	// The function takes the following parameters:
	// 
	// 	- checkCancellable Cancellable (nullable): a #GCancellable to check, or %NULL to unset 
	//
	// Sets a #GCancellable to check before dispatching results.
	// 
	// This function has one very specific purpose: the provided cancellable
	// is checked at the time of g_simple_async_result_propagate_error() If
	// it is cancelled, these functions will return an "Operation was
	// cancelled" error (%G_IO_ERROR_CANCELLED).
	// 
	// Implementors of cancellable asynchronous functions should use this in
	// order to provide a guarantee to their callers that cancelling an
	// async operation will reliably result in an error being returned for
	// that operation (even if a positive result for the operation has
	// already been sent as an idle to the main context to be dispatched).
	// 
	// The checking described above is done regardless of any call to the
	// unrelated g_simple_async_result_set_handle_cancellation() function.
	//
	// Deprecated: (since 2.46.0) Use #GTask instead.
	SetCheckCancellable(Cancellable)
	// SetHandleCancellation wraps g_simple_async_result_set_handle_cancellation
	// 
	// The function takes the following parameters:
	// 
	// 	- handleCancellation bool: a #gboolean. 
	//
	// Sets whether to handle cancellation within the asynchronous operation.
	// 
	// This function has nothing to do with
	// g_simple_async_result_set_check_cancellable().  It only refers to the
	// #GCancellable passed to g_simple_async_result_run_in_thread().
	//
	// Deprecated: (since 2.46.0) 
	SetHandleCancellation(bool)
	// SetOpResGboolean wraps g_simple_async_result_set_op_res_gboolean
	// 
	// The function takes the following parameters:
	// 
	// 	- opRes bool: a #gboolean. 
	//
	// Sets the operation result to a boolean within the asynchronous result.
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_return_boolean() instead.
	SetOpResGboolean(bool)
	// SetOpResGssize wraps g_simple_async_result_set_op_res_gssize
	// 
	// The function takes the following parameters:
	// 
	// 	- opRes int: a #gssize. 
	//
	// Sets the operation result within the asynchronous result to
	// the given @op_res.
	//
	// Deprecated: (since 2.46.0) Use #GTask and g_task_return_int() instead.
	SetOpResGssize(int)
}

func unsafeWrapSimpleAsyncResult(base *gobject.ObjectInstance) *SimpleAsyncResultInstance {
	return &SimpleAsyncResultInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleAsyncResult,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleAsyncResult(inst)
		},
	)
}

func marshalSimpleAsyncResultInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleAsyncResultFromGlibNone is used to convert raw GSimpleAsyncResult pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibNone(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleAsyncResult)
}

// UnsafeSimpleAsyncResultFromGlibFull is used to convert raw GSimpleAsyncResult pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibFull(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleAsyncResult)
}

// UnsafeSimpleAsyncResultFromGlibBorrow is used to convert raw GSimpleAsyncResult pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleAsyncResultFromGlibBorrow(c unsafe.Pointer) SimpleAsyncResult {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleAsyncResult)
}

func (s *SimpleAsyncResultInstance) upcastToGSimpleAsyncResult() *SimpleAsyncResultInstance {
	return s
}

// UnsafeSimpleAsyncResultToGlibNone is used to convert the instance to it's C value GSimpleAsyncResult. This is used by the bindings internally.
func UnsafeSimpleAsyncResultToGlibNone(c SimpleAsyncResult) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleAsyncResultToGlibFull is used to convert the instance to it's C value GSimpleAsyncResult, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultToGlibFull(c SimpleAsyncResult) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Complete wraps g_simple_async_result_complete
//
// Completes an asynchronous I/O job immediately. Must be called in
// the thread where the asynchronous result was to be delivered, as it
// invokes the callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
// 
// Calling this function takes a reference to @simple for as long as
// is needed to complete the call.
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) Complete() {
	var carg0 *C.GSimpleAsyncResult // in, none, converted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	C.g_simple_async_result_complete(carg0)
	runtime.KeepAlive(simple)
}

// CompleteInIdle wraps g_simple_async_result_complete_in_idle
//
// Completes an asynchronous function in an idle handler in the
// thread-default main context (see [method@GLib.MainContext.push_thread_default])
// of the thread that @simple was initially created in
// (and re-pushes that context around the invocation of the callback).
// 
// Calling this function takes a reference to @simple for as long as
// is needed to complete the call.
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) CompleteInIdle() {
	var carg0 *C.GSimpleAsyncResult // in, none, converted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	C.g_simple_async_result_complete_in_idle(carg0)
	runtime.KeepAlive(simple)
}

// GetOpResGboolean wraps g_simple_async_result_get_op_res_gboolean
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the operation result boolean from within the asynchronous result.
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_boolean() instead.
func (simple *SimpleAsyncResultInstance) GetOpResGboolean() bool {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_get_op_res_gboolean(carg0)
	runtime.KeepAlive(simple)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetOpResGssize wraps g_simple_async_result_get_op_res_gssize
// 
// The function returns the following values:
// 
// 	- goret int 
//
// Gets a gssize from the asynchronous result.
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_propagate_int() instead.
func (simple *SimpleAsyncResultInstance) GetOpResGssize() int {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gssize              // return, none, casted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_get_op_res_gssize(carg0)
	runtime.KeepAlive(simple)

	var goret int

	goret = int(cret)

	return goret
}

// PropagateError wraps g_simple_async_result_propagate_error
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Propagates an error from within the simple asynchronous result to
// a given destination.
// 
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this
// function will return %TRUE with @dest set appropriately.
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) PropagateError() (bool, error) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))

	cret = C.g_simple_async_result_propagate_error(carg0, &_cerr)
	runtime.KeepAlive(simple)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetCheckCancellable wraps g_simple_async_result_set_check_cancellable
// 
// The function takes the following parameters:
// 
// 	- checkCancellable Cancellable (nullable): a #GCancellable to check, or %NULL to unset 
//
// Sets a #GCancellable to check before dispatching results.
// 
// This function has one very specific purpose: the provided cancellable
// is checked at the time of g_simple_async_result_propagate_error() If
// it is cancelled, these functions will return an "Operation was
// cancelled" error (%G_IO_ERROR_CANCELLED).
// 
// Implementors of cancellable asynchronous functions should use this in
// order to provide a guarantee to their callers that cancelling an
// async operation will reliably result in an error being returned for
// that operation (even if a positive result for the operation has
// already been sent as an idle to the main context to be dispatched).
// 
// The checking described above is done regardless of any call to the
// unrelated g_simple_async_result_set_handle_cancellation() function.
//
// Deprecated: (since 2.46.0) Use #GTask instead.
func (simple *SimpleAsyncResultInstance) SetCheckCancellable(checkCancellable Cancellable) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if checkCancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(checkCancellable))
	}

	C.g_simple_async_result_set_check_cancellable(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(checkCancellable)
}

// SetHandleCancellation wraps g_simple_async_result_set_handle_cancellation
// 
// The function takes the following parameters:
// 
// 	- handleCancellation bool: a #gboolean. 
//
// Sets whether to handle cancellation within the asynchronous operation.
// 
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable().  It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
//
// Deprecated: (since 2.46.0) 
func (simple *SimpleAsyncResultInstance) SetHandleCancellation(handleCancellation bool) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if handleCancellation {
		carg1 = C.TRUE
	}

	C.g_simple_async_result_set_handle_cancellation(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(handleCancellation)
}

// SetOpResGboolean wraps g_simple_async_result_set_op_res_gboolean
// 
// The function takes the following parameters:
// 
// 	- opRes bool: a #gboolean. 
//
// Sets the operation result to a boolean within the asynchronous result.
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_return_boolean() instead.
func (simple *SimpleAsyncResultInstance) SetOpResGboolean(opRes bool) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	if opRes {
		carg1 = C.TRUE
	}

	C.g_simple_async_result_set_op_res_gboolean(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SetOpResGssize wraps g_simple_async_result_set_op_res_gssize
// 
// The function takes the following parameters:
// 
// 	- opRes int: a #gssize. 
//
// Sets the operation result within the asynchronous result to
// the given @op_res.
//
// Deprecated: (since 2.46.0) Use #GTask and g_task_return_int() instead.
func (simple *SimpleAsyncResultInstance) SetOpResGssize(opRes int) {
	var carg0 *C.GSimpleAsyncResult // in, none, converted
	var carg1 C.gssize              // in, none, casted

	carg0 = (*C.GSimpleAsyncResult)(UnsafeSimpleAsyncResultToGlibNone(simple))
	carg1 = C.gssize(opRes)

	C.g_simple_async_result_set_op_res_gssize(carg0, carg1)
	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SimpleIOStreamInstance is the instance type used by all types extending GSimpleIOStream. It is used internally by the bindings. Users should use the interface [SimpleIOStream] instead.
type SimpleIOStreamInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ SimpleIOStream = (*SimpleIOStreamInstance)(nil)

// SimpleIOStream wraps GSimpleIOStream
//
// `GSimpleIOStream` creates a [class@Gio.IOStream] from an arbitrary
// [class@Gio.InputStream] and [class@Gio.OutputStream]. This allows any pair of
// input and output streams to be used with [class@Gio.IOStream] methods.
// 
// This is useful when you obtained a [class@Gio.InputStream] and a
// [class@Gio.OutputStream] by other means, for instance creating them with
// platform specific methods as
// [`g_unix_input_stream_new()`](../gio-unix/ctor.UnixInputStream.new.html)
// (from `gio-unix-2.0.pc` / `GioUnix-2.0`), and you want to
// take advantage of the methods provided by [class@Gio.IOStream].
type SimpleIOStream interface {
	IOStream
	upcastToGSimpleIOStream() *SimpleIOStreamInstance
}

func unsafeWrapSimpleIOStream(base *gobject.ObjectInstance) *SimpleIOStreamInstance {
	return &SimpleIOStreamInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleIOStream(inst)
		},
	)
}

func marshalSimpleIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleIOStreamFromGlibNone is used to convert raw GSimpleIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibNone(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleIOStream)
}

// UnsafeSimpleIOStreamFromGlibFull is used to convert raw GSimpleIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibFull(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleIOStream)
}

// UnsafeSimpleIOStreamFromGlibBorrow is used to convert raw GSimpleIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleIOStreamFromGlibBorrow(c unsafe.Pointer) SimpleIOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleIOStream)
}

func (s *SimpleIOStreamInstance) upcastToGSimpleIOStream() *SimpleIOStreamInstance {
	return s
}

// UnsafeSimpleIOStreamToGlibNone is used to convert the instance to it's C value GSimpleIOStream. This is used by the bindings internally.
func UnsafeSimpleIOStreamToGlibNone(c SimpleIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleIOStreamToGlibFull is used to convert the instance to it's C value GSimpleIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleIOStreamToGlibFull(c SimpleIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleIOStream wraps g_simple_io_stream_new
// 
// The function takes the following parameters:
// 
// 	- inputStream InputStream: a #GInputStream. 
// 	- outputStream OutputStream: a #GOutputStream. 
// 
// The function returns the following values:
// 
// 	- goret IOStream 
//
// Creates a new #GSimpleIOStream wrapping @input_stream and @output_stream.
// See also #GIOStream.
func NewSimpleIOStream(inputStream InputStream, outputStream OutputStream) IOStream {
	var carg1 *C.GInputStream  // in, none, converted
	var carg2 *C.GOutputStream // in, none, converted
	var cret  *C.GIOStream     // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(inputStream))
	carg2 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(outputStream))

	cret = C.g_simple_io_stream_new(carg1, carg2)
	runtime.KeepAlive(inputStream)
	runtime.KeepAlive(outputStream)

	var goret IOStream

	goret = UnsafeIOStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SimplePermissionInstance is the instance type used by all types extending GSimplePermission. It is used internally by the bindings. Users should use the interface [SimplePermission] instead.
type SimplePermissionInstance struct {
	_ [0]func() // equal guard
	PermissionInstance
}

var _ SimplePermission = (*SimplePermissionInstance)(nil)

// SimplePermission wraps GSimplePermission
//
// `GSimplePermission` is a trivial implementation of [class@Gio.Permission]
// that represents a permission that is either always or never allowed.  The
// value is given at construction and doesn&#x2019;t change.
// 
// Calling [method@Gio.Permission.acquire] or [method@Gio.Permission.release]
// on a `GSimplePermission` will result in errors.
type SimplePermission interface {
	Permission
	upcastToGSimplePermission() *SimplePermissionInstance
}

func unsafeWrapSimplePermission(base *gobject.ObjectInstance) *SimplePermissionInstance {
	return &SimplePermissionInstance{
		PermissionInstance: PermissionInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimplePermission,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimplePermission(inst)
		},
	)
}

func marshalSimplePermissionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimplePermissionFromGlibNone is used to convert raw GSimplePermission pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibNone(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibNone(c).(SimplePermission)
}

// UnsafeSimplePermissionFromGlibFull is used to convert raw GSimplePermission pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibFull(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibFull(c).(SimplePermission)
}

// UnsafeSimplePermissionFromGlibBorrow is used to convert raw GSimplePermission pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimplePermissionFromGlibBorrow(c unsafe.Pointer) SimplePermission {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimplePermission)
}

func (s *SimplePermissionInstance) upcastToGSimplePermission() *SimplePermissionInstance {
	return s
}

// UnsafeSimplePermissionToGlibNone is used to convert the instance to it's C value GSimplePermission. This is used by the bindings internally.
func UnsafeSimplePermissionToGlibNone(c SimplePermission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimplePermissionToGlibFull is used to convert the instance to it's C value GSimplePermission, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimplePermissionToGlibFull(c SimplePermission) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimplePermission wraps g_simple_permission_new
// 
// The function takes the following parameters:
// 
// 	- allowed bool: %TRUE if the action is allowed 
// 
// The function returns the following values:
// 
// 	- goret Permission 
//
// Creates a new #GPermission instance that represents an action that is
// either always or never allowed.
func NewSimplePermission(allowed bool) Permission {
	var carg1 C.gboolean     // in
	var cret  *C.GPermission // return, full, converted

	if allowed {
		carg1 = C.TRUE
	}

	cret = C.g_simple_permission_new(carg1)
	runtime.KeepAlive(allowed)

	var goret Permission

	goret = UnsafePermissionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SimpleProxyResolverInstance is the instance type used by all types extending GSimpleProxyResolver. It is used internally by the bindings. Users should use the interface [SimpleProxyResolver] instead.
type SimpleProxyResolverInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SimpleProxyResolver = (*SimpleProxyResolverInstance)(nil)

// SimpleProxyResolver wraps GSimpleProxyResolver
//
// `GSimpleProxyResolver` is a simple [iface@Gio.ProxyResolver] implementation
// that handles a single default proxy, multiple URI-scheme-specific
// proxies, and a list of hosts that proxies should not be used for.
// 
// `GSimpleProxyResolver` is never the default proxy resolver, but it
// can be used as the base class for another proxy resolver
// implementation, or it can be created and used manually, such as
// with [method@Gio.SocketClient.set_proxy_resolver].
type SimpleProxyResolver interface {
	gobject.Object
	upcastToGSimpleProxyResolver() *SimpleProxyResolverInstance

	// SetDefaultProxy wraps g_simple_proxy_resolver_set_default_proxy
	// 
	// The function takes the following parameters:
	// 
	// 	- defaultProxy string (nullable): the default proxy to use 
	//
	// Sets the default proxy on @resolver, to be used for any URIs that
	// don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
	// via g_simple_proxy_resolver_set_uri_proxy().
	// 
	// If @default_proxy starts with "socks://",
	// #GSimpleProxyResolver will treat it as referring to all three of
	// the socks5, socks4a, and socks4 proxy types.
	SetDefaultProxy(string)
	// SetIgnoreHosts wraps g_simple_proxy_resolver_set_ignore_hosts
	// 
	// The function takes the following parameters:
	// 
	// 	- ignoreHosts []string: %NULL-terminated list of hosts/IP addresses
	//     to not use a proxy for 
	//
	// Sets the list of ignored hosts.
	// 
	// See #GSimpleProxyResolver:ignore-hosts for more details on how the
	// @ignore_hosts argument is interpreted.
	SetIgnoreHosts([]string)
	// SetURIProxy wraps g_simple_proxy_resolver_set_uri_proxy
	// 
	// The function takes the following parameters:
	// 
	// 	- uriScheme string: the URI scheme to add a proxy for 
	// 	- proxy string: the proxy to use for @uri_scheme 
	//
	// Adds a URI-scheme-specific proxy to @resolver; URIs whose scheme
	// matches @uri_scheme (and which don't match
	// #GSimpleProxyResolver:ignore-hosts) will be proxied via @proxy.
	// 
	// As with #GSimpleProxyResolver:default-proxy, if @proxy starts with
	// "socks://", #GSimpleProxyResolver will treat it
	// as referring to all three of the socks5, socks4a, and socks4 proxy
	// types.
	SetURIProxy(string, string)

	// chain up virtual methods:
}

func unsafeWrapSimpleProxyResolver(base *gobject.ObjectInstance) *SimpleProxyResolverInstance {
	return &SimpleProxyResolverInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSimpleProxyResolver,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleProxyResolver(inst)
		},
	)
}

func marshalSimpleProxyResolverInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSimpleProxyResolverFromGlibNone is used to convert raw GSimpleProxyResolver pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibNone(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibNone(c).(SimpleProxyResolver)
}

// UnsafeSimpleProxyResolverFromGlibFull is used to convert raw GSimpleProxyResolver pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibFull(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibFull(c).(SimpleProxyResolver)
}

// UnsafeSimpleProxyResolverFromGlibBorrow is used to convert raw GSimpleProxyResolver pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSimpleProxyResolverFromGlibBorrow(c unsafe.Pointer) SimpleProxyResolver {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SimpleProxyResolver)
}

func (s *SimpleProxyResolverInstance) upcastToGSimpleProxyResolver() *SimpleProxyResolverInstance {
	return s
}

// UnsafeSimpleProxyResolverToGlibNone is used to convert the instance to it's C value GSimpleProxyResolver. This is used by the bindings internally.
func UnsafeSimpleProxyResolverToGlibNone(c SimpleProxyResolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSimpleProxyResolverToGlibFull is used to convert the instance to it's C value GSimpleProxyResolver, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverToGlibFull(c SimpleProxyResolver) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSimpleProxyResolver wraps g_simple_proxy_resolver_new
// 
// The function takes the following parameters:
// 
// 	- defaultProxy string (nullable): the default proxy to use, eg
//     "socks://192.168.1.1" 
// 	- ignoreHosts []string (nullable): an optional list of hosts/IP addresses
//     to not use a proxy for. 
// 
// The function returns the following values:
// 
// 	- goret ProxyResolver 
//
// Creates a new #GSimpleProxyResolver. See
// #GSimpleProxyResolver:default-proxy and
// #GSimpleProxyResolver:ignore-hosts for more details on how the
// arguments are interpreted.
func NewSimpleProxyResolver(defaultProxy string, ignoreHosts []string) ProxyResolver {
	var carg1 *C.gchar          // in, none, string, nullable-string
	var carg2 **C.gchar         // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.GProxyResolver // return, full, converted

	if defaultProxy != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = ignoreHosts
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_simple_proxy_resolver_new(carg1, carg2)
	runtime.KeepAlive(defaultProxy)
	runtime.KeepAlive(ignoreHosts)

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// SetDefaultProxy wraps g_simple_proxy_resolver_set_default_proxy
// 
// The function takes the following parameters:
// 
// 	- defaultProxy string (nullable): the default proxy to use 
//
// Sets the default proxy on @resolver, to be used for any URIs that
// don't match #GSimpleProxyResolver:ignore-hosts or a proxy set
// via g_simple_proxy_resolver_set_uri_proxy().
// 
// If @default_proxy starts with "socks://",
// #GSimpleProxyResolver will treat it as referring to all three of
// the socks5, socks4a, and socks4 proxy types.
func (resolver *SimpleProxyResolverInstance) SetDefaultProxy(defaultProxy string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 *C.gchar                // in, none, string, nullable-string

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	if defaultProxy != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(defaultProxy)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_simple_proxy_resolver_set_default_proxy(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(defaultProxy)
}

// SetIgnoreHosts wraps g_simple_proxy_resolver_set_ignore_hosts
// 
// The function takes the following parameters:
// 
// 	- ignoreHosts []string: %NULL-terminated list of hosts/IP addresses
//     to not use a proxy for 
//
// Sets the list of ignored hosts.
// 
// See #GSimpleProxyResolver:ignore-hosts for more details on how the
// @ignore_hosts argument is interpreted.
func (resolver *SimpleProxyResolverInstance) SetIgnoreHosts(ignoreHosts []string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 **C.gchar               // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	_ = ignoreHosts
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	C.g_simple_proxy_resolver_set_ignore_hosts(carg0, carg1)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ignoreHosts)
}

// SetURIProxy wraps g_simple_proxy_resolver_set_uri_proxy
// 
// The function takes the following parameters:
// 
// 	- uriScheme string: the URI scheme to add a proxy for 
// 	- proxy string: the proxy to use for @uri_scheme 
//
// Adds a URI-scheme-specific proxy to @resolver; URIs whose scheme
// matches @uri_scheme (and which don't match
// #GSimpleProxyResolver:ignore-hosts) will be proxied via @proxy.
// 
// As with #GSimpleProxyResolver:default-proxy, if @proxy starts with
// "socks://", #GSimpleProxyResolver will treat it
// as referring to all three of the socks5, socks4a, and socks4 proxy
// types.
func (resolver *SimpleProxyResolverInstance) SetURIProxy(uriScheme string, proxy string) {
	var carg0 *C.GSimpleProxyResolver // in, none, converted
	var carg1 *C.gchar                // in, none, string
	var carg2 *C.gchar                // in, none, string

	carg0 = (*C.GSimpleProxyResolver)(UnsafeSimpleProxyResolverToGlibNone(resolver))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(proxy)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_simple_proxy_resolver_set_uri_proxy(carg0, carg1, carg2)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(uriScheme)
	runtime.KeepAlive(proxy)
}

// SimpleProxyResolverOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SimpleProxyResolverOverrides[Instance SimpleProxyResolver] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySimpleProxyResolverOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySimpleProxyResolverOverrides[Instance SimpleProxyResolver](gclass unsafe.Pointer, overrides SimpleProxyResolverOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSimpleProxyResolverSubClass is used to register a go subclass of GSimpleProxyResolver. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSimpleProxyResolverSubClass[InstanceT SimpleProxyResolver](
		name string,
		classInit func(class *SimpleProxyResolverClass),
		constructor func() InstanceT,
		overrides SimpleProxyResolverOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSimpleProxyResolver,
		UnsafeSimpleProxyResolverClassFromGlibBorrow,
		UnsafeApplySimpleProxyResolverOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSimpleProxyResolver(obj)
		},
		interfaceInits...,
	)
}

// SocketInstance is the instance type used by all types extending GSocket. It is used internally by the bindings. Users should use the interface [Socket] instead.
type SocketInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Socket = (*SocketInstance)(nil)

// Socket wraps GSocket
//
// A `GSocket` is a low-level networking primitive. It is a more or less
// direct mapping of the BSD socket API in a portable GObject based API.
// It supports both the UNIX socket implementations and winsock2 on Windows.
// 
// `GSocket` is the platform independent base upon which the higher level
// network primitives are based. Applications are not typically meant to
// use it directly, but rather through classes like [class@Gio.SocketClient],
// [class@Gio.SocketService] and [class@Gio.SocketConnection]. However there may
// be cases where direct use of `GSocket` is useful.
// 
// `GSocket` implements the [iface@Gio.Initable] interface, so if it is manually
// constructed by e.g. [ctor@GObject.Object.new] you must call
// [method@Gio.Initable.init] and check the results before using the object.
// This is done automatically in [ctor@Gio.Socket.new] and
// [ctor@Gio.Socket.new_from_fd], so these functions can return `NULL`.
// 
// Sockets operate in two general modes, blocking or non-blocking. When
// in blocking mode all operations (which don&#x2019;t take an explicit blocking
// parameter) block until the requested operation
// is finished or there is an error. In non-blocking mode all calls that
// would block return immediately with a `G_IO_ERROR_WOULD_BLOCK` error.
// To know when a call would successfully run you can call
// [method@Gio.Socket.condition_check], or [method@Gio.Socket.condition_wait].
// You can also use [method@Gio.Socket.create_source] and attach it to a
// [type@GLib.MainContext] to get callbacks when I/O is possible.
// Note that all sockets are always set to non blocking mode in the system, and
// blocking mode is emulated in `GSocket`.
// 
// When working in non-blocking mode applications should always be able to
// handle getting a `G_IO_ERROR_WOULD_BLOCK` error even when some other
// function said that I/O was possible. This can easily happen in case
// of a race condition in the application, but it can also happen for other
// reasons. For instance, on Windows a socket is always seen as writable
// until a write returns `G_IO_ERROR_WOULD_BLOCK`.
// 
// `GSocket`s can be either connection oriented or datagram based.
// For connection oriented types you must first establish a connection by
// either connecting to an address or accepting a connection from another
// address. For connectionless socket types the target/source address is
// specified or received in each I/O operation.
// 
// All socket file descriptors are set to be close-on-exec.
// 
// Note that creating a `GSocket` causes the signal `SIGPIPE` to be
// ignored for the remainder of the program. If you are writing a
// command-line utility that uses `GSocket`, you may need to take into
// account the fact that your program will not automatically be killed
// if it tries to write to `stdout` after it has been closed.
// 
// Like most other APIs in GLib, `GSocket` is not inherently thread safe. To use
// a `GSocket` concurrently from multiple threads, you must implement your own
// locking.
// 
// ## Nagle&#x2019;s algorithm
// 
// Since GLib 2.80, `GSocket` will automatically set the `TCP_NODELAY` option on
// all `G_SOCKET_TYPE_STREAM` sockets. This disables
// [Nagle&#x2019;s algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) as it
// typically does more harm than good on modern networks.
// 
// If your application needs Nagle&#x2019;s algorithm enabled, call
// [method@Gio.Socket.set_option] after constructing a `GSocket` to enable it:
// ```c
// socket = g_socket_new (&#x2026;, G_SOCKET_TYPE_STREAM, &#x2026;);
// if (socket != NULL)
//   {
//     g_socket_set_option (socket, IPPROTO_TCP, TCP_NODELAY, FALSE, &amp;local_error);
//     // handle error if needed
//   }
// ```
type Socket interface {
	gobject.Object
	upcastToGSocket() *SocketInstance

	// Accept wraps g_socket_accept
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret Socket 
	// 	- _goerr error (nullable): an error 
	//
	// Accept incoming connections on a connection-based socket. This removes
	// the first outstanding connection request from the listening socket and
	// creates a #GSocket object for it.
	// 
	// The @socket must be bound to a local address with g_socket_bind() and
	// must be listening for incoming connections (g_socket_listen()).
	// 
	// If there are no outstanding connections then the operation will block
	// or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
	// To be notified of an incoming connection, wait for the %G_IO_IN condition.
	Accept(Cancellable) (Socket, error)
	// Bind wraps g_socket_bind
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress: a #GSocketAddress specifying the local address. 
	// 	- allowReuse bool: whether to allow reusing this address 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// When a socket is created it is attached to an address family, but it
	// doesn't have an address in this family. g_socket_bind() assigns the
	// address (sometimes called name) of the socket.
	// 
	// It is generally required to bind to a local address before you can
	// receive connections. (See g_socket_listen() and g_socket_accept() ).
	// In certain situations, you may also want to bind a socket that will be
	// used to initiate connections, though this is not normally required.
	// 
	// If @socket is a TCP socket, then @allow_reuse controls the setting
	// of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
	// server sockets (sockets that you will eventually call
	// g_socket_accept() on), and %FALSE for client sockets. (Failing to
	// set this flag on a server socket may cause g_socket_bind() to return
	// %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
	// immediately restarted.)
	// 
	// If @socket is a UDP socket, then @allow_reuse determines whether or
	// not other UDP sockets can be bound to the same address at the same
	// time. In particular, you can have several UDP sockets bound to the
	// same address, and they will all receive all of the multicast and
	// broadcast packets sent to that address. (The behavior of unicast
	// UDP packets to an address with multiple listeners is not defined.)
	Bind(SocketAddress, bool) (bool, error)
	// CheckConnectResult wraps g_socket_check_connect_result
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Checks and resets the pending connect error for the socket.
	// This is used to check for errors when g_socket_connect() is
	// used in non-blocking mode.
	CheckConnectResult() (bool, error)
	// Close wraps g_socket_close
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Closes the socket, shutting down any active connection.
	// 
	// Closing a socket does not wait for all outstanding I/O operations
	// to finish, so the caller should not rely on them to be guaranteed
	// to complete even if the close returns with no error.
	// 
	// Once the socket is closed, all other operations will return
	// %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
	// return an error.
	// 
	// Sockets will be automatically closed when the last reference
	// is dropped, but you might want to call this function to make sure
	// resources are released as early as possible.
	// 
	// Beware that due to the way that TCP works, it is possible for
	// recently-sent data to be lost if either you close a socket while the
	// %G_IO_IN condition is set, or else if the remote connection tries to
	// send something to you after you close the socket but before it has
	// finished reading all of the data you sent. There is no easy generic
	// way to avoid this problem; the easiest fix is to design the network
	// protocol such that the client will never send data "out of turn".
	// Another solution is for the server to half-close the connection by
	// calling g_socket_shutdown() with only the @shutdown_write flag set,
	// and then wait for the client to notice this and close its side of the
	// connection, after which the server can safely call g_socket_close().
	// (This is what #GTcpConnection does if you call
	// g_tcp_connection_set_graceful_disconnect(). But of course, this
	// only works if the client will close its connection after the server
	// does.)
	Close() (bool, error)
	// ConditionCheck wraps g_socket_condition_check
	// 
	// The function takes the following parameters:
	// 
	// 	- condition glib.IOCondition: a #GIOCondition mask to check 
	// 
	// The function returns the following values:
	// 
	// 	- goret glib.IOCondition 
	//
	// Checks on the readiness of @socket to perform operations.
	// The operations specified in @condition are checked for and masked
	// against the currently-satisfied conditions on @socket. The result
	// is returned.
	// 
	// Note that on Windows, it is possible for an operation to return
	// %G_IO_ERROR_WOULD_BLOCK even immediately after
	// g_socket_condition_check() has claimed that the socket is ready for
	// writing. Rather than calling g_socket_condition_check() and then
	// writing to the socket if it succeeds, it is generally better to
	// simply try writing to the socket right away, and try again later if
	// the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
	// 
	// It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
	// these conditions will always be set in the output if they are true.
	// 
	// This call never blocks.
	ConditionCheck(glib.IOCondition) glib.IOCondition
	// ConditionTimedWait wraps g_socket_condition_timed_wait
	// 
	// The function takes the following parameters:
	// 
	// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
	// 	- timeoutUs int64: the maximum time (in microseconds) to wait, or -1 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Waits for up to @timeout_us microseconds for @condition to become true
	// on @socket. If the condition is met, %TRUE is returned.
	// 
	// If @cancellable is cancelled before the condition is met, or if
	// @timeout_us (or the socket's #GSocket:timeout) is reached before the
	// condition is met, then %FALSE is returned and @error, if non-%NULL,
	// is set to the appropriate value (%G_IO_ERROR_CANCELLED or
	// %G_IO_ERROR_TIMED_OUT).
	// 
	// If you don't want a timeout, use g_socket_condition_wait().
	// (Alternatively, you can pass -1 for @timeout_us.)
	// 
	// Note that although @timeout_us is in microseconds for consistency with
	// other GLib APIs, this function actually only has millisecond
	// resolution, and the behavior is undefined if @timeout_us is not an
	// exact number of milliseconds.
	ConditionTimedWait(glib.IOCondition, int64, Cancellable) (bool, error)
	// ConditionWait wraps g_socket_condition_wait
	// 
	// The function takes the following parameters:
	// 
	// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Waits for @condition to become true on @socket. When the condition
	// is met, %TRUE is returned.
	// 
	// If @cancellable is cancelled before the condition is met, or if the
	// socket has a timeout set and it is reached before the condition is
	// met, then %FALSE is returned and @error, if non-%NULL, is set to
	// the appropriate value (%G_IO_ERROR_CANCELLED or
	// %G_IO_ERROR_TIMED_OUT).
	// 
	// See also g_socket_condition_timed_wait().
	ConditionWait(glib.IOCondition, Cancellable) (bool, error)
	// ConnectSocket wraps g_socket_connect
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Connect the socket to the specified remote address.
	// 
	// For connection oriented socket this generally means we attempt to make
	// a connection to the @address. For a connection-less socket it sets
	// the default address for g_socket_send() and discards all incoming datagrams
	// from other sources.
	// 
	// Generally connection oriented sockets can only connect once, but
	// connection-less sockets can connect multiple times to change the
	// default address.
	// 
	// If the connect call needs to do network I/O it will block, unless
	// non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
	// and the user can be notified of the connection finishing by waiting
	// for the G_IO_OUT condition. The result of the connection must then be
	// checked with g_socket_check_connect_result().
	ConnectSocket(SocketAddress, Cancellable) (bool, error)
	// ConnectionFactoryCreateConnection wraps g_socket_connection_factory_create_connection
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	//
	// Creates a #GSocketConnection subclass of the right type for
	// @socket.
	ConnectionFactoryCreateConnection() SocketConnection
	// GetAvailableBytes wraps g_socket_get_available_bytes
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	//
	// Get the amount of data pending in the OS input buffer, without blocking.
	// 
	// If @socket is a UDP or SCTP socket, this will return the size of
	// just the next packet, even if additional packets are buffered after
	// that one.
	// 
	// Note that on Windows, this function is rather inefficient in the
	// UDP case, and so if you know any plausible upper bound on the size
	// of the incoming packet, it is better to just do a
	// g_socket_receive() with a buffer of that size, rather than calling
	// g_socket_get_available_bytes() first and then doing a receive of
	// exactly the right size.
	GetAvailableBytes() int
	// GetBlocking wraps g_socket_get_blocking
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the blocking mode of the socket. For details on blocking I/O,
	// see g_socket_set_blocking().
	GetBlocking() bool
	// GetBroadcast wraps g_socket_get_broadcast
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the broadcast setting on @socket; if %TRUE,
	// it is possible to send packets to broadcast
	// addresses.
	GetBroadcast() bool
	// GetCredentials wraps g_socket_get_credentials
	// 
	// The function returns the following values:
	// 
	// 	- goret Credentials 
	// 	- _goerr error (nullable): an error 
	//
	// Returns the credentials of the foreign process connected to this
	// socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
	// sockets).
	// 
	// If this operation isn't supported on the OS, the method fails with
	// the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
	// by reading the %SO_PEERCRED option on the underlying socket.
	// 
	// This method can be expected to be available on the following platforms:
	// 
	// - Linux since GLib 2.26
	// - OpenBSD since GLib 2.30
	// - Solaris, Illumos and OpenSolaris since GLib 2.40
	// - NetBSD since GLib 2.42
	// - macOS, tvOS, iOS since GLib 2.66
	// 
	// Other ways to obtain credentials from a foreign peer includes the
	// #GUnixCredentialsMessage type and
	// g_unix_connection_send_credentials() /
	// g_unix_connection_receive_credentials() functions.
	GetCredentials() (Credentials, error)
	// GetFamily wraps g_socket_get_family
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the socket family of the socket.
	GetFamily() SocketFamily
	// GetFd wraps g_socket_get_fd
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Returns the underlying OS socket object. On unix this
	// is a socket file descriptor, and on Windows this is
	// a Winsock2 SOCKET handle. This may be useful for
	// doing platform specific or otherwise unusual operations
	// on the socket.
	GetFd() int32
	// GetKeepalive wraps g_socket_get_keepalive
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the keepalive mode of the socket. For details on this,
	// see g_socket_set_keepalive().
	GetKeepalive() bool
	// GetListenBacklog wraps g_socket_get_listen_backlog
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets the listen backlog setting of the socket. For details on this,
	// see g_socket_set_listen_backlog().
	GetListenBacklog() int32
	// GetLocalAddress wraps g_socket_get_local_address
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Try to get the local address of a bound socket. This is only
	// useful if the socket has been bound to a local address,
	// either explicitly or implicitly when connecting.
	GetLocalAddress() (SocketAddress, error)
	// GetMulticastLoopback wraps g_socket_get_multicast_loopback
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the multicast loopback setting on @socket; if %TRUE (the
	// default), outgoing multicast packets will be looped back to
	// multicast listeners on the same host.
	GetMulticastLoopback() bool
	// GetMulticastTtl wraps g_socket_get_multicast_ttl
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the multicast time-to-live setting on @socket; see
	// g_socket_set_multicast_ttl() for more details.
	GetMulticastTtl() uint
	// GetOption wraps g_socket_get_option
	// 
	// The function takes the following parameters:
	// 
	// 	- level int32: the "API level" of the option (eg, `SOL_SOCKET`) 
	// 	- optname int32: the "name" of the option (eg, `SO_BROADCAST`) 
	// 
	// The function returns the following values:
	// 
	// 	- value int32: return location for the option value 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the value of an integer-valued option on @socket, as with
	// getsockopt(). (If you need to fetch a  non-integer-valued option,
	// you will need to call getsockopt() directly.)
	// 
	// The [`&lt;gio/gnetworking.h&gt;`](networking.html)
	// header pulls in system headers that will define most of the
	// standard/portable socket options. For unusual socket protocols or
	// platform-dependent options, you may need to include additional
	// headers.
	// 
	// Note that even for socket options that are a single byte in size,
	// @value is still a pointer to a #gint variable, not a #guchar;
	// g_socket_get_option() will handle the conversion internally.
	GetOption(int32, int32) (int32, bool, error)
	// GetProtocol wraps g_socket_get_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketProtocol 
	//
	// Gets the socket protocol id the socket was created with.
	// In case the protocol is unknown, -1 is returned.
	GetProtocol() SocketProtocol
	// GetRemoteAddress wraps g_socket_get_remote_address
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Try to get the remote address of a connected socket. This is only
	// useful for connection oriented sockets that have been connected.
	GetRemoteAddress() (SocketAddress, error)
	// GetSocketType wraps g_socket_get_socket_type
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketType 
	//
	// Gets the socket type of the socket.
	GetSocketType() SocketType
	// GetTimeout wraps g_socket_get_timeout
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the timeout setting of the socket. For details on this, see
	// g_socket_set_timeout().
	GetTimeout() uint
	// GetTtl wraps g_socket_get_ttl
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the unicast time-to-live setting on @socket; see
	// g_socket_set_ttl() for more details.
	GetTtl() uint
	// IsClosed wraps g_socket_is_closed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks whether a socket is closed.
	IsClosed() bool
	// IsConnected wraps g_socket_is_connected
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check whether the socket is connected. This is only useful for
	// connection-oriented sockets.
	// 
	// If using g_socket_shutdown(), this function will return %TRUE until the
	// socket has been shut down for reading and writing. If you do a non-blocking
	// connect, this function will not return %TRUE until after you call
	// g_socket_check_connect_result().
	IsConnected() bool
	// JoinMulticastGroup wraps g_socket_join_multicast_group
	// 
	// The function takes the following parameters:
	// 
	// 	- group InetAddress: a #GInetAddress specifying the group address to join. 
	// 	- sourceSpecific bool: %TRUE if source-specific multicast should be used 
	// 	- iface string (nullable): Name of the interface to use, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Registers @socket to receive multicast messages sent to @group.
	// @socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with
	// g_socket_bind().
	// 
	// If @iface is %NULL, the system will automatically pick an interface
	// to bind to based on @group.
	// 
	// If @source_specific is %TRUE, source-specific multicast as defined
	// in RFC 4604 is used. Note that on older platforms this may fail
	// with a %G_IO_ERROR_NOT_SUPPORTED error.
	// 
	// To bind to a given source-specific multicast address, use
	// g_socket_join_multicast_group_ssm() instead.
	JoinMulticastGroup(InetAddress, bool, string) (bool, error)
	// JoinMulticastGroupSsm wraps g_socket_join_multicast_group_ssm
	// 
	// The function takes the following parameters:
	// 
	// 	- group InetAddress: a #GInetAddress specifying the group address to join. 
	// 	- sourceSpecific InetAddress (nullable): a #GInetAddress specifying the
	// source-specific multicast address or %NULL to ignore. 
	// 	- iface string (nullable): Name of the interface to use, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Registers @socket to receive multicast messages sent to @group.
	// @socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
	// been bound to an appropriate interface and port with
	// g_socket_bind().
	// 
	// If @iface is %NULL, the system will automatically pick an interface
	// to bind to based on @group.
	// 
	// If @source_specific is not %NULL, use source-specific multicast as
	// defined in RFC 4604. Note that on older platforms this may fail
	// with a %G_IO_ERROR_NOT_SUPPORTED error.
	// 
	// Note that this function can be called multiple times for the same
	// @group with different @source_specific in order to receive multicast
	// packets from more than one source.
	JoinMulticastGroupSsm(InetAddress, InetAddress, string) (bool, error)
	// LeaveMulticastGroup wraps g_socket_leave_multicast_group
	// 
	// The function takes the following parameters:
	// 
	// 	- group InetAddress: a #GInetAddress specifying the group address to leave. 
	// 	- sourceSpecific bool: %TRUE if source-specific multicast was used 
	// 	- iface string (nullable): Interface used 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Removes @socket from the multicast group defined by @group, @iface,
	// and @source_specific (which must all have the same values they had
	// when you joined the group).
	// 
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	// 
	// To unbind to a given source-specific multicast address, use
	// g_socket_leave_multicast_group_ssm() instead.
	LeaveMulticastGroup(InetAddress, bool, string) (bool, error)
	// LeaveMulticastGroupSsm wraps g_socket_leave_multicast_group_ssm
	// 
	// The function takes the following parameters:
	// 
	// 	- group InetAddress: a #GInetAddress specifying the group address to leave. 
	// 	- sourceSpecific InetAddress (nullable): a #GInetAddress specifying the
	// source-specific multicast address or %NULL to ignore. 
	// 	- iface string (nullable): Name of the interface to use, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Removes @socket from the multicast group defined by @group, @iface,
	// and @source_specific (which must all have the same values they had
	// when you joined the group).
	// 
	// @socket remains bound to its address and port, and can still receive
	// unicast messages after calling this.
	LeaveMulticastGroupSsm(InetAddress, InetAddress, string) (bool, error)
	// Listen wraps g_socket_listen
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Marks the socket as a server socket, i.e. a socket that is used
	// to accept incoming requests using g_socket_accept().
	// 
	// Before calling this the socket must be bound to a local address using
	// g_socket_bind().
	// 
	// To set the maximum amount of outstanding clients, use
	// g_socket_set_listen_backlog().
	Listen() (bool, error)
	// ReceiveBytes wraps g_socket_receive_bytes
	// 
	// The function takes the following parameters:
	// 
	// 	- size uint: the number of bytes you want to read from the socket 
	// 	- timeoutUs int64: the timeout to wait for, in microseconds, or `-1` to block
	//   indefinitely 
	// 	- cancellable Cancellable (nullable): a %GCancellable, or `NULL` 
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Receives data (up to @size bytes) from a socket.
	// 
	// This function is a variant of [method@Gio.Socket.receive] which returns a
	// [struct@GLib.Bytes] rather than a plain buffer.
	// 
	// Pass `-1` to @timeout_us to block indefinitely until data is received (or
	// the connection is closed, or there is an error). Pass `0` to use the default
	// timeout from [property@Gio.Socket:timeout], or pass a positive number to wait
	// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
	ReceiveBytes(uint, int64, Cancellable) (*glib.Bytes, error)
	// ReceiveBytesFrom wraps g_socket_receive_bytes_from
	// 
	// The function takes the following parameters:
	// 
	// 	- size uint: the number of bytes you want to read from the socket 
	// 	- timeoutUs int64: the timeout to wait for, in microseconds, or `-1` to block
	//   indefinitely 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or `NULL` 
	// 
	// The function returns the following values:
	// 
	// 	- address SocketAddress: return location for a #GSocketAddress 
	// 	- goret *glib.Bytes 
	// 	- _goerr error (nullable): an error 
	//
	// Receive data (up to @size bytes) from a socket.
	// 
	// This function is a variant of [method@Gio.Socket.receive_from] which returns
	// a [struct@GLib.Bytes] rather than a plain buffer.
	// 
	// If @address is non-%NULL then @address will be set equal to the
	// source address of the received packet.
	// 
	// The @address is owned by the caller.
	// 
	// Pass `-1` to @timeout_us to block indefinitely until data is received (or
	// the connection is closed, or there is an error). Pass `0` to use the default
	// timeout from [property@Gio.Socket:timeout], or pass a positive number to wait
	// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
	ReceiveBytesFrom(uint, int64, Cancellable) (SocketAddress, *glib.Bytes, error)
	// ReceiveMessages wraps g_socket_receive_messages
	// 
	// The function takes the following parameters:
	// 
	// 	- messages []InputMessage: an array of #GInputMessage structs 
	// 	- flags int32: an int containing #GSocketMsgFlags flags for the overall operation,
	//    which may additionally contain
	//    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Receive multiple data messages from @socket in one go.  This is the most
	// complicated and fully-featured version of this call. For easier use, see
	// g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
	// 
	// @messages must point to an array of #GInputMessage structs and
	// @num_messages must be the length of this array. Each #GInputMessage
	// contains a pointer to an array of #GInputVector structs describing the
	// buffers that the data received in each message will be written to. Using
	// multiple #GInputVectors is more memory-efficient than manually copying data
	// out of a single buffer to multiple sources, and more system-call-efficient
	// than making multiple calls to g_socket_receive(), such as in scenarios where
	// a lot of data packets need to be received (e.g. high-bandwidth video
	// streaming over RTP/UDP).
	// 
	// @flags modify how all messages are received. The commonly available
	// arguments for this are available in the #GSocketMsgFlags enum, but the
	// values there are the same as the system values, and the flags
	// are passed in as-is, so you can pass in system-specific flags too. These
	// flags affect the overall receive operation. Flags affecting individual
	// messages are returned in #GInputMessage.flags.
	// 
	// The other members of #GInputMessage are treated as described in its
	// documentation.
	// 
	// If #GSocket:blocking is %TRUE the call will block until @num_messages have
	// been received, or the end of the stream is reached.
	// 
	// If #GSocket:blocking is %FALSE the call will return up to @num_messages
	// without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
	// operating system to be received.
	// 
	// In blocking mode, if #GSocket:timeout is positive and is reached before any
	// messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
	// @num_messages are returned. (Note: This is effectively the
	// behaviour of `MSG_WAITFORONE` with recvmmsg().)
	// 
	// To be notified when messages are available, wait for the
	// %G_IO_IN condition. Note though that you may still receive
	// %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
	// previously notified of a %G_IO_IN condition.
	// 
	// If the remote peer closes the connection, any messages queued in the
	// operating system will be returned, and subsequent calls to
	// g_socket_receive_messages() will return 0 (with no error set).
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be received; otherwise the number of
	// messages successfully received before the error will be returned.
	ReceiveMessages([]InputMessage, int32, Cancellable) (int32, error)
	// Send wraps g_socket_send
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer string: the buffer
	//     containing the data to send. 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to send @size bytes from @buffer on the socket. This is
	// mainly used by connection-oriented sockets; it is identical to
	// g_socket_send_to() with @address set to %NULL.
	// 
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// %G_IO_OUT condition. Note though that you may still receive
	// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a %G_IO_OUT condition. (On Windows in particular, this is
	// very common due to the way the underlying APIs work.)
	// 
	// On error -1 is returned and @error is set accordingly.
	Send(string, Cancellable) (int, error)
	// SendMessage wraps g_socket_send_message
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
	// 	- vectors []OutputVector: an array of #GOutputVector structs 
	// 	- messages []SocketControlMessage (nullable): a pointer to an
	//   array of #GSocketControlMessages, or %NULL. 
	// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
	//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Send data to @address on @socket.  For sending multiple messages see
	// g_socket_send_messages(); for easier use, see
	// g_socket_send() and g_socket_send_to().
	// 
	// If @address is %NULL then the message is sent to the default receiver
	// (set by g_socket_connect()).
	// 
	// @vectors must point to an array of #GOutputVector structs and
	// @num_vectors must be the length of this array. (If @num_vectors is -1,
	// then @vectors is assumed to be terminated by a #GOutputVector with a
	// %NULL buffer pointer.) The #GOutputVector structs describe the buffers
	// that the sent data will be gathered from. Using multiple
	// #GOutputVectors is more memory-efficient than manually copying
	// data from multiple sources into a single buffer, and more
	// network-efficient than making multiple calls to g_socket_send().
	// 
	// @messages, if non-%NULL, is taken to point to an array of @num_messages
	// #GSocketControlMessage instances. These correspond to the control
	// messages to be sent on the socket.
	// If @num_messages is -1 then @messages is treated as a %NULL-terminated
	// array.
	// 
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the #GSocketMsgFlags enum, but the
	// values there are the same as the system values, and the flags
	// are passed in as-is, so you can pass in system-specific flags too.
	// 
	// If the socket is in blocking mode the call will block until there is
	// space for the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
	// will be returned. To be notified when space is available, wait for the
	// %G_IO_OUT condition. Note though that you may still receive
	// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a %G_IO_OUT condition. (On Windows in particular, this is
	// very common due to the way the underlying APIs work.)
	// 
	// The sum of the sizes of each #GOutputVector in vectors must not be
	// greater than %G_MAXSSIZE. If the message can be larger than this,
	// then it is mandatory to use the g_socket_send_message_with_timeout()
	// function.
	// 
	// On error -1 is returned and @error is set accordingly.
	SendMessage(SocketAddress, []OutputVector, []SocketControlMessage, int32, Cancellable) (int, error)
	// SendMessageWithTimeout wraps g_socket_send_message_with_timeout
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
	// 	- vectors []OutputVector: an array of #GOutputVector structs 
	// 	- messages []SocketControlMessage (nullable): a pointer to an
	//   array of #GSocketControlMessages, or %NULL. 
	// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
	//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
	// 	- timeoutUs int64: the maximum time (in microseconds) to wait, or -1 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- bytesWritten uint: location to store the number of bytes that were written to the socket 
	// 	- goret PollableReturn 
	// 	- _goerr error (nullable): an error 
	//
	// This behaves exactly the same as g_socket_send_message(), except that
	// the choice of timeout behavior is determined by the @timeout_us argument
	// rather than by @socket's properties.
	// 
	// On error %G_POLLABLE_RETURN_FAILED is returned and @error is set accordingly, or
	// if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
	// returned. @bytes_written will contain 0 in both cases.
	SendMessageWithTimeout(SocketAddress, []OutputVector, []SocketControlMessage, int32, int64, Cancellable) (uint, PollableReturn, error)
	// SendMessages wraps g_socket_send_messages
	// 
	// The function takes the following parameters:
	// 
	// 	- messages []OutputMessage: an array of #GOutputMessage structs 
	// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
	//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Send multiple data messages from @socket in one go.  This is the most
	// complicated and fully-featured version of this call. For easier use, see
	// g_socket_send(), g_socket_send_to(), and g_socket_send_message().
	// 
	// @messages must point to an array of #GOutputMessage structs and
	// @num_messages must be the length of this array. Each #GOutputMessage
	// contains an address to send the data to, and a pointer to an array of
	// #GOutputVector structs to describe the buffers that the data to be sent
	// for each message will be gathered from. Using multiple #GOutputVectors is
	// more memory-efficient than manually copying data from multiple sources
	// into a single buffer, and more network-efficient than making multiple
	// calls to g_socket_send(). Sending multiple messages in one go avoids the
	// overhead of making a lot of syscalls in scenarios where a lot of data
	// packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
	// or where the same data needs to be sent to multiple recipients.
	// 
	// @flags modify how the message is sent. The commonly available arguments
	// for this are available in the #GSocketMsgFlags enum, but the
	// values there are the same as the system values, and the flags
	// are passed in as-is, so you can pass in system-specific flags too.
	// 
	// If the socket is in blocking mode the call will block until there is
	// space for all the data in the socket queue. If there is no space available
	// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
	// will be returned if no data was written at all, otherwise the number of
	// messages sent will be returned. To be notified when space is available,
	// wait for the %G_IO_OUT condition. Note though that you may still receive
	// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
	// notified of a %G_IO_OUT condition. (On Windows in particular, this is
	// very common due to the way the underlying APIs work.)
	// 
	// On error -1 is returned and @error is set accordingly. An error will only
	// be returned if zero messages could be sent; otherwise the number of messages
	// successfully sent before the error will be returned.
	SendMessages([]OutputMessage, int32, Cancellable) (int32, error)
	// SendTo wraps g_socket_send_to
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
	// 	- buffer string: the buffer
	//     containing the data to send. 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to send @size bytes from @buffer to @address. If @address is
	// %NULL then the message is sent to the default receiver (set by
	// g_socket_connect()).
	// 
	// See g_socket_send() for additional information.
	SendTo(SocketAddress, string, Cancellable) (int, error)
	// SendWithBlocking wraps g_socket_send_with_blocking
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer string: the buffer
	//     containing the data to send. 
	// 	- blocking bool: whether to do blocking or non-blocking I/O 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// This behaves exactly the same as g_socket_send(), except that
	// the choice of blocking or non-blocking behavior is determined by
	// the @blocking argument rather than by @socket's properties.
	SendWithBlocking(string, bool, Cancellable) (int, error)
	// SetBlocking wraps g_socket_set_blocking
	// 
	// The function takes the following parameters:
	// 
	// 	- blocking bool: Whether to use blocking I/O or not. 
	//
	// Sets the blocking mode of the socket. In blocking mode
	// all operations (which don&#x2019;t take an explicit blocking parameter) block until
	// they succeed or there is an error. In
	// non-blocking mode all functions return results immediately or
	// with a %G_IO_ERROR_WOULD_BLOCK error.
	// 
	// All sockets are created in blocking mode. However, note that the
	// platform level socket is always non-blocking, and blocking mode
	// is a GSocket level feature.
	SetBlocking(bool)
	// SetBroadcast wraps g_socket_set_broadcast
	// 
	// The function takes the following parameters:
	// 
	// 	- broadcast bool: whether @socket should allow sending to broadcast
	//     addresses 
	//
	// Sets whether @socket should allow sending to broadcast addresses.
	// This is %FALSE by default.
	SetBroadcast(bool)
	// SetKeepalive wraps g_socket_set_keepalive
	// 
	// The function takes the following parameters:
	// 
	// 	- keepalive bool: Value for the keepalive flag 
	//
	// Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
	// this flag is set on a socket, the system will attempt to verify that the
	// remote socket endpoint is still present if a sufficiently long period of
	// time passes with no data being exchanged. If the system is unable to
	// verify the presence of the remote endpoint, it will automatically close
	// the connection.
	// 
	// This option is only functional on certain kinds of sockets. (Notably,
	// %G_SOCKET_PROTOCOL_TCP sockets.)
	// 
	// The exact time between pings is system- and protocol-dependent, but will
	// normally be at least two hours. Most commonly, you would set this flag
	// on a server socket if you want to allow clients to remain idle for long
	// periods of time, but also want to ensure that connections are eventually
	// garbage-collected if clients crash or become unreachable.
	SetKeepalive(bool)
	// SetListenBacklog wraps g_socket_set_listen_backlog
	// 
	// The function takes the following parameters:
	// 
	// 	- backlog int32: the maximum number of pending connections. 
	//
	// Sets the maximum number of outstanding connections allowed
	// when listening on this socket. If more clients than this are
	// connecting to the socket and the application is not handling them
	// on time then the new connections will be refused.
	// 
	// Note that this must be called before g_socket_listen() and has no
	// effect if called after that.
	SetListenBacklog(int32)
	// SetMulticastLoopback wraps g_socket_set_multicast_loopback
	// 
	// The function takes the following parameters:
	// 
	// 	- loopback bool: whether @socket should receive messages sent to its
	//   multicast groups from the local host 
	//
	// Sets whether outgoing multicast packets will be received by sockets
	// listening on that multicast address on the same host. This is %TRUE
	// by default.
	SetMulticastLoopback(bool)
	// SetMulticastTtl wraps g_socket_set_multicast_ttl
	// 
	// The function takes the following parameters:
	// 
	// 	- ttl uint: the time-to-live value for all multicast datagrams on @socket 
	//
	// Sets the time-to-live for outgoing multicast datagrams on @socket.
	// By default, this is 1, meaning that multicast packets will not leave
	// the local network.
	SetMulticastTtl(uint)
	// SetOption wraps g_socket_set_option
	// 
	// The function takes the following parameters:
	// 
	// 	- level int32: the "API level" of the option (eg, `SOL_SOCKET`) 
	// 	- optname int32: the "name" of the option (eg, `SO_BROADCAST`) 
	// 	- value int32: the value to set the option to 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Sets the value of an integer-valued option on @socket, as with
	// setsockopt(). (If you need to set a non-integer-valued option,
	// you will need to call setsockopt() directly.)
	// 
	// The [`&lt;gio/gnetworking.h&gt;`](networking.html)
	// header pulls in system headers that will define most of the
	// standard/portable socket options. For unusual socket protocols or
	// platform-dependent options, you may need to include additional
	// headers.
	SetOption(int32, int32, int32) (bool, error)
	// SetTimeout wraps g_socket_set_timeout
	// 
	// The function takes the following parameters:
	// 
	// 	- timeout uint: the timeout for @socket, in seconds, or 0 for none 
	//
	// Sets the time in seconds after which I/O operations on @socket will
	// time out if they have not yet completed.
	// 
	// On a blocking socket, this means that any blocking #GSocket
	// operation will time out after @timeout seconds of inactivity,
	// returning %G_IO_ERROR_TIMED_OUT.
	// 
	// On a non-blocking socket, calls to g_socket_condition_wait() will
	// also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
	// created with g_socket_create_source() will trigger after
	// @timeout seconds of inactivity, with the requested condition
	// set, at which point calling g_socket_receive(), g_socket_send(),
	// g_socket_check_connect_result(), etc, will fail with
	// %G_IO_ERROR_TIMED_OUT.
	// 
	// If @timeout is 0 (the default), operations will never time out
	// on their own.
	// 
	// Note that if an I/O operation is interrupted by a signal, this may
	// cause the timeout to be reset.
	SetTimeout(uint)
	// SetTtl wraps g_socket_set_ttl
	// 
	// The function takes the following parameters:
	// 
	// 	- ttl uint: the time-to-live value for all unicast packets on @socket 
	//
	// Sets the time-to-live for outgoing unicast packets on @socket.
	// By default the platform-specific default value is used.
	SetTtl(uint)
	// Shutdown wraps g_socket_shutdown
	// 
	// The function takes the following parameters:
	// 
	// 	- shutdownRead bool: whether to shut down the read side 
	// 	- shutdownWrite bool: whether to shut down the write side 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Shut down part or all of a full-duplex connection.
	// 
	// If @shutdown_read is %TRUE then the receiving side of the connection
	// is shut down, and further reading is disallowed.
	// 
	// If @shutdown_write is %TRUE then the sending side of the connection
	// is shut down, and further writing is disallowed.
	// 
	// It is allowed for both @shutdown_read and @shutdown_write to be %TRUE.
	// 
	// One example where it is useful to shut down only one side of a connection is
	// graceful disconnect for TCP connections where you close the sending side,
	// then wait for the other side to close the connection, thus ensuring that the
	// other side saw all sent data.
	Shutdown(bool, bool) (bool, error)
	// SpeaksIpv4 wraps g_socket_speaks_ipv4
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if a socket is capable of speaking IPv4.
	// 
	// IPv4 sockets are capable of speaking IPv4.  On some operating systems
	// and under some combinations of circumstances IPv6 sockets are also
	// capable of speaking IPv4.  See RFC 3493 section 3.7 for more
	// information.
	// 
	// No other types of sockets are currently considered as being capable
	// of speaking IPv4.
	SpeaksIpv4() bool

	// chain up virtual methods:
}

func unsafeWrapSocket(base *gobject.ObjectInstance) *SocketInstance {
	return &SocketInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocket,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocket(inst)
		},
	)
}

func marshalSocketInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketFromGlibNone is used to convert raw GSocket pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketFromGlibNone(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibNone(c).(Socket)
}

// UnsafeSocketFromGlibFull is used to convert raw GSocket pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketFromGlibFull(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibFull(c).(Socket)
}

// UnsafeSocketFromGlibBorrow is used to convert raw GSocket pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketFromGlibBorrow(c unsafe.Pointer) Socket {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Socket)
}

func (s *SocketInstance) upcastToGSocket() *SocketInstance {
	return s
}

// UnsafeSocketToGlibNone is used to convert the instance to it's C value GSocket. This is used by the bindings internally.
func UnsafeSocketToGlibNone(c Socket) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketToGlibFull is used to convert the instance to it's C value GSocket, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketToGlibFull(c Socket) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocket wraps g_socket_new
// 
// The function takes the following parameters:
// 
// 	- family SocketFamily: the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4. 
// 	- typ SocketType: the socket type to use. 
// 	- protocol SocketProtocol: the id of the protocol to use, or 0 for default. 
// 
// The function returns the following values:
// 
// 	- goret Socket 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GSocket with the defined family, type and protocol.
// If @protocol is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
// for the family and type is used.
// 
// The @protocol is a family and type specific int that specifies what
// kind of protocol to use. #GSocketProtocol lists several common ones.
// Many families only support one protocol, and use 0 for this, others
// support several and using 0 means to use the default protocol for
// the family and type.
// 
// The protocol id is passed directly to the operating
// system, so you can use protocols not listed in #GSocketProtocol if you
// know the protocol number used for it.
func NewSocket(family SocketFamily, typ SocketType, protocol SocketProtocol) (Socket, error) {
	var carg1 C.GSocketFamily   // in, none, casted
	var carg2 C.GSocketType     // in, none, casted
	var carg3 C.GSocketProtocol // in, none, casted
	var cret  *C.GSocket        // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg1 = C.GSocketFamily(family)
	carg2 = C.GSocketType(typ)
	carg3 = C.GSocketProtocol(protocol)

	cret = C.g_socket_new(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewSocketFromFd wraps g_socket_new_from_fd
// 
// The function takes the following parameters:
// 
// 	- fd int32: a native socket file descriptor. 
// 
// The function returns the following values:
// 
// 	- goret Socket 
// 	- _goerr error (nullable): an error 
//
// Creates a new #GSocket from a native file descriptor
// or winsock SOCKET handle.
// 
// This reads all the settings from the file descriptor so that
// all properties should work. Note that the file descriptor
// will be set to non-blocking mode, independent on the blocking
// mode of the #GSocket.
// 
// On success, the returned #GSocket takes ownership of @fd. On failure, the
// caller must close @fd themselves.
// 
// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
// descriptor.  Instead, a GError will be set with code %G_IO_ERROR_FAILED
func NewSocketFromFd(fd int32) (Socket, error) {
	var carg1 C.gint     // in, none, casted
	var cret  *C.GSocket // return, full, converted
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = C.gint(fd)

	cret = C.g_socket_new_from_fd(carg1, &_cerr)
	runtime.KeepAlive(fd)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Accept wraps g_socket_accept
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret Socket 
// 	- _goerr error (nullable): an error 
//
// Accept incoming connections on a connection-based socket. This removes
// the first outstanding connection request from the listening socket and
// creates a #GSocket object for it.
// 
// The @socket must be bound to a local address with g_socket_bind() and
// must be listening for incoming connections (g_socket_listen()).
// 
// If there are no outstanding connections then the operation will block
// or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
// To be notified of an incoming connection, wait for the %G_IO_IN condition.
func (socket *SocketInstance) Accept(cancellable Cancellable) (Socket, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GSocket      // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_accept(carg0, carg1, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(cancellable)

	var goret  Socket
	var _goerr error

	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Bind wraps g_socket_bind
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress: a #GSocketAddress specifying the local address. 
// 	- allowReuse bool: whether to allow reusing this address 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// When a socket is created it is attached to an address family, but it
// doesn't have an address in this family. g_socket_bind() assigns the
// address (sometimes called name) of the socket.
// 
// It is generally required to bind to a local address before you can
// receive connections. (See g_socket_listen() and g_socket_accept() ).
// In certain situations, you may also want to bind a socket that will be
// used to initiate connections, though this is not normally required.
// 
// If @socket is a TCP socket, then @allow_reuse controls the setting
// of the `SO_REUSEADDR` socket option; normally it should be %TRUE for
// server sockets (sockets that you will eventually call
// g_socket_accept() on), and %FALSE for client sockets. (Failing to
// set this flag on a server socket may cause g_socket_bind() to return
// %G_IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then
// immediately restarted.)
// 
// If @socket is a UDP socket, then @allow_reuse determines whether or
// not other UDP sockets can be bound to the same address at the same
// time. In particular, you can have several UDP sockets bound to the
// same address, and they will all receive all of the multicast and
// broadcast packets sent to that address. (The behavior of unicast
// UDP packets to an address with multiple listeners is not defined.)
func (socket *SocketInstance) Bind(address SocketAddress, allowReuse bool) (bool, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted
	var carg2 C.gboolean        // in
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if allowReuse {
		carg2 = C.TRUE
	}

	cret = C.g_socket_bind(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(allowReuse)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// CheckConnectResult wraps g_socket_check_connect_result
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Checks and resets the pending connect error for the socket.
// This is used to check for errors when g_socket_connect() is
// used in non-blocking mode.
func (socket *SocketInstance) CheckConnectResult() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_check_connect_result(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_socket_close
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Closes the socket, shutting down any active connection.
// 
// Closing a socket does not wait for all outstanding I/O operations
// to finish, so the caller should not rely on them to be guaranteed
// to complete even if the close returns with no error.
// 
// Once the socket is closed, all other operations will return
// %G_IO_ERROR_CLOSED. Closing a socket multiple times will not
// return an error.
// 
// Sockets will be automatically closed when the last reference
// is dropped, but you might want to call this function to make sure
// resources are released as early as possible.
// 
// Beware that due to the way that TCP works, it is possible for
// recently-sent data to be lost if either you close a socket while the
// %G_IO_IN condition is set, or else if the remote connection tries to
// send something to you after you close the socket but before it has
// finished reading all of the data you sent. There is no easy generic
// way to avoid this problem; the easiest fix is to design the network
// protocol such that the client will never send data "out of turn".
// Another solution is for the server to half-close the connection by
// calling g_socket_shutdown() with only the @shutdown_write flag set,
// and then wait for the client to notice this and close its side of the
// connection, after which the server can safely call g_socket_close().
// (This is what #GTcpConnection does if you call
// g_tcp_connection_set_graceful_disconnect(). But of course, this
// only works if the client will close its connection after the server
// does.)
func (socket *SocketInstance) Close() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_close(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConditionCheck wraps g_socket_condition_check
// 
// The function takes the following parameters:
// 
// 	- condition glib.IOCondition: a #GIOCondition mask to check 
// 
// The function returns the following values:
// 
// 	- goret glib.IOCondition 
//
// Checks on the readiness of @socket to perform operations.
// The operations specified in @condition are checked for and masked
// against the currently-satisfied conditions on @socket. The result
// is returned.
// 
// Note that on Windows, it is possible for an operation to return
// %G_IO_ERROR_WOULD_BLOCK even immediately after
// g_socket_condition_check() has claimed that the socket is ready for
// writing. Rather than calling g_socket_condition_check() and then
// writing to the socket if it succeeds, it is generally better to
// simply try writing to the socket right away, and try again later if
// the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
// 
// It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
// these conditions will always be set in the output if they are true.
// 
// This call never blocks.
func (socket *SocketInstance) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var carg0 *C.GSocket     // in, none, converted
	var carg1 C.GIOCondition // in, none, casted
	var cret  C.GIOCondition // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)

	cret = C.g_socket_condition_check(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)

	var goret glib.IOCondition

	goret = glib.IOCondition(cret)

	return goret
}

// ConditionTimedWait wraps g_socket_condition_timed_wait
// 
// The function takes the following parameters:
// 
// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
// 	- timeoutUs int64: the maximum time (in microseconds) to wait, or -1 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Waits for up to @timeout_us microseconds for @condition to become true
// on @socket. If the condition is met, %TRUE is returned.
// 
// If @cancellable is cancelled before the condition is met, or if
// @timeout_us (or the socket's #GSocket:timeout) is reached before the
// condition is met, then %FALSE is returned and @error, if non-%NULL,
// is set to the appropriate value (%G_IO_ERROR_CANCELLED or
// %G_IO_ERROR_TIMED_OUT).
// 
// If you don't want a timeout, use g_socket_condition_wait().
// (Alternatively, you can pass -1 for @timeout_us.)
// 
// Note that although @timeout_us is in microseconds for consistency with
// other GLib APIs, this function actually only has millisecond
// resolution, and the behavior is undefined if @timeout_us is not an
// exact number of milliseconds.
func (socket *SocketInstance) ConditionTimedWait(condition glib.IOCondition, timeoutUs int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.GIOCondition  // in, none, casted
	var carg2 C.gint64        // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)
	carg2 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_condition_timed_wait(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConditionWait wraps g_socket_condition_wait
// 
// The function takes the following parameters:
// 
// 	- condition glib.IOCondition: a #GIOCondition mask to wait for 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Waits for @condition to become true on @socket. When the condition
// is met, %TRUE is returned.
// 
// If @cancellable is cancelled before the condition is met, or if the
// socket has a timeout set and it is reached before the condition is
// met, then %FALSE is returned and @error, if non-%NULL, is set to
// the appropriate value (%G_IO_ERROR_CANCELLED or
// %G_IO_ERROR_TIMED_OUT).
// 
// See also g_socket_condition_timed_wait().
func (socket *SocketInstance) ConditionWait(condition glib.IOCondition, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.GIOCondition  // in, none, casted
	var carg2 *C.GCancellable // in, none, converted, nullable
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.GIOCondition(condition)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_condition_wait(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectSocket wraps g_socket_connect
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Connect the socket to the specified remote address.
// 
// For connection oriented socket this generally means we attempt to make
// a connection to the @address. For a connection-less socket it sets
// the default address for g_socket_send() and discards all incoming datagrams
// from other sources.
// 
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the
// default address.
// 
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
// and the user can be notified of the connection finishing by waiting
// for the G_IO_OUT condition. The result of the connection must then be
// checked with g_socket_check_connect_result().
func (socket *SocketInstance) ConnectSocket(address SocketAddress, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted
	var carg2 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectionFactoryCreateConnection wraps g_socket_connection_factory_create_connection
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
//
// Creates a #GSocketConnection subclass of the right type for
// @socket.
func (socket *SocketInstance) ConnectionFactoryCreateConnection() SocketConnection {
	var carg0 *C.GSocket           // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_connection_factory_create_connection(carg0)
	runtime.KeepAlive(socket)

	var goret SocketConnection

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAvailableBytes wraps g_socket_get_available_bytes
// 
// The function returns the following values:
// 
// 	- goret int 
//
// Get the amount of data pending in the OS input buffer, without blocking.
// 
// If @socket is a UDP or SCTP socket, this will return the size of
// just the next packet, even if additional packets are buffered after
// that one.
// 
// Note that on Windows, this function is rather inefficient in the
// UDP case, and so if you know any plausible upper bound on the size
// of the incoming packet, it is better to just do a
// g_socket_receive() with a buffer of that size, rather than calling
// g_socket_get_available_bytes() first and then doing a receive of
// exactly the right size.
func (socket *SocketInstance) GetAvailableBytes() int {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gssize   // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_available_bytes(carg0)
	runtime.KeepAlive(socket)

	var goret int

	goret = int(cret)

	return goret
}

// GetBlocking wraps g_socket_get_blocking
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the blocking mode of the socket. For details on blocking I/O,
// see g_socket_set_blocking().
func (socket *SocketInstance) GetBlocking() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_blocking(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetBroadcast wraps g_socket_get_broadcast
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the broadcast setting on @socket; if %TRUE,
// it is possible to send packets to broadcast
// addresses.
func (socket *SocketInstance) GetBroadcast() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_broadcast(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCredentials wraps g_socket_get_credentials
// 
// The function returns the following values:
// 
// 	- goret Credentials 
// 	- _goerr error (nullable): an error 
//
// Returns the credentials of the foreign process connected to this
// socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
// sockets).
// 
// If this operation isn't supported on the OS, the method fails with
// the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
// by reading the %SO_PEERCRED option on the underlying socket.
// 
// This method can be expected to be available on the following platforms:
// 
// - Linux since GLib 2.26
// - OpenBSD since GLib 2.30
// - Solaris, Illumos and OpenSolaris since GLib 2.40
// - NetBSD since GLib 2.42
// - macOS, tvOS, iOS since GLib 2.66
// 
// Other ways to obtain credentials from a foreign peer includes the
// #GUnixCredentialsMessage type and
// g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
func (socket *SocketInstance) GetCredentials() (Credentials, error) {
	var carg0 *C.GSocket      // in, none, converted
	var cret  *C.GCredentials // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_credentials(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  Credentials
	var _goerr error

	goret = UnsafeCredentialsFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetFamily wraps g_socket_get_family
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets the socket family of the socket.
func (socket *SocketInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocket      // in, none, converted
	var cret  C.GSocketFamily // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_family(carg0)
	runtime.KeepAlive(socket)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetFd wraps g_socket_get_fd
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the underlying OS socket object. On unix this
// is a socket file descriptor, and on Windows this is
// a Winsock2 SOCKET handle. This may be useful for
// doing platform specific or otherwise unusual operations
// on the socket.
func (socket *SocketInstance) GetFd() int32 {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.int      // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_fd(carg0)
	runtime.KeepAlive(socket)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetKeepalive wraps g_socket_get_keepalive
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the keepalive mode of the socket. For details on this,
// see g_socket_set_keepalive().
func (socket *SocketInstance) GetKeepalive() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_keepalive(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetListenBacklog wraps g_socket_get_listen_backlog
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the listen backlog setting of the socket. For details on this,
// see g_socket_set_listen_backlog().
func (socket *SocketInstance) GetListenBacklog() int32 {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gint     // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_listen_backlog(carg0)
	runtime.KeepAlive(socket)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetLocalAddress wraps g_socket_get_local_address
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
// 	- _goerr error (nullable): an error 
//
// Try to get the local address of a bound socket. This is only
// useful if the socket has been bound to a local address,
// either explicitly or implicitly when connecting.
func (socket *SocketInstance) GetLocalAddress() (SocketAddress, error) {
	var carg0 *C.GSocket        // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_local_address(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetMulticastLoopback wraps g_socket_get_multicast_loopback
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the multicast loopback setting on @socket; if %TRUE (the
// default), outgoing multicast packets will be looped back to
// multicast listeners on the same host.
func (socket *SocketInstance) GetMulticastLoopback() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_multicast_loopback(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMulticastTtl wraps g_socket_get_multicast_ttl
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the multicast time-to-live setting on @socket; see
// g_socket_set_multicast_ttl() for more details.
func (socket *SocketInstance) GetMulticastTtl() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_multicast_ttl(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetOption wraps g_socket_get_option
// 
// The function takes the following parameters:
// 
// 	- level int32: the "API level" of the option (eg, `SOL_SOCKET`) 
// 	- optname int32: the "name" of the option (eg, `SO_BROADCAST`) 
// 
// The function returns the following values:
// 
// 	- value int32: return location for the option value 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets the value of an integer-valued option on @socket, as with
// getsockopt(). (If you need to fetch a  non-integer-valued option,
// you will need to call getsockopt() directly.)
// 
// The [`&lt;gio/gnetworking.h&gt;`](networking.html)
// header pulls in system headers that will define most of the
// standard/portable socket options. For unusual socket protocols or
// platform-dependent options, you may need to include additional
// headers.
// 
// Note that even for socket options that are a single byte in size,
// @value is still a pointer to a #gint variable, not a #guchar;
// g_socket_get_option() will handle the conversion internally.
func (socket *SocketInstance) GetOption(level int32, optname int32) (int32, bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted
	var carg2 C.gint     // in, none, casted
	var carg3 C.gint     // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(level)
	carg2 = C.gint(optname)

	cret = C.g_socket_get_option(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)

	var value  int32
	var goret  bool
	var _goerr error

	value = int32(carg3)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return value, goret, _goerr
}

// GetProtocol wraps g_socket_get_protocol
// 
// The function returns the following values:
// 
// 	- goret SocketProtocol 
//
// Gets the socket protocol id the socket was created with.
// In case the protocol is unknown, -1 is returned.
func (socket *SocketInstance) GetProtocol() SocketProtocol {
	var carg0 *C.GSocket        // in, none, converted
	var cret  C.GSocketProtocol // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_protocol(carg0)
	runtime.KeepAlive(socket)

	var goret SocketProtocol

	goret = SocketProtocol(cret)

	return goret
}

// GetRemoteAddress wraps g_socket_get_remote_address
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
// 	- _goerr error (nullable): an error 
//
// Try to get the remote address of a connected socket. This is only
// useful for connection oriented sockets that have been connected.
func (socket *SocketInstance) GetRemoteAddress() (SocketAddress, error) {
	var carg0 *C.GSocket        // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_remote_address(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSocketType wraps g_socket_get_socket_type
// 
// The function returns the following values:
// 
// 	- goret SocketType 
//
// Gets the socket type of the socket.
func (socket *SocketInstance) GetSocketType() SocketType {
	var carg0 *C.GSocket    // in, none, converted
	var cret  C.GSocketType // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_socket_type(carg0)
	runtime.KeepAlive(socket)

	var goret SocketType

	goret = SocketType(cret)

	return goret
}

// GetTimeout wraps g_socket_get_timeout
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
func (socket *SocketInstance) GetTimeout() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_timeout(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetTtl wraps g_socket_get_ttl
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the unicast time-to-live setting on @socket; see
// g_socket_set_ttl() for more details.
func (socket *SocketInstance) GetTtl() uint {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.guint    // return, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_get_ttl(carg0)
	runtime.KeepAlive(socket)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsClosed wraps g_socket_is_closed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks whether a socket is closed.
func (socket *SocketInstance) IsClosed() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_is_closed(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsConnected wraps g_socket_is_connected
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether the socket is connected. This is only useful for
// connection-oriented sockets.
// 
// If using g_socket_shutdown(), this function will return %TRUE until the
// socket has been shut down for reading and writing. If you do a non-blocking
// connect, this function will not return %TRUE until after you call
// g_socket_check_connect_result().
func (socket *SocketInstance) IsConnected() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_is_connected(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// JoinMulticastGroup wraps g_socket_join_multicast_group
// 
// The function takes the following parameters:
// 
// 	- group InetAddress: a #GInetAddress specifying the group address to join. 
// 	- sourceSpecific bool: %TRUE if source-specific multicast should be used 
// 	- iface string (nullable): Name of the interface to use, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Registers @socket to receive multicast messages sent to @group.
// @socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
// been bound to an appropriate interface and port with
// g_socket_bind().
// 
// If @iface is %NULL, the system will automatically pick an interface
// to bind to based on @group.
// 
// If @source_specific is %TRUE, source-specific multicast as defined
// in RFC 4604 is used. Note that on older platforms this may fail
// with a %G_IO_ERROR_NOT_SUPPORTED error.
// 
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
func (socket *SocketInstance) JoinMulticastGroup(group InetAddress, sourceSpecific bool, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 C.gboolean      // in
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific {
		carg2 = C.TRUE
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_join_multicast_group(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// JoinMulticastGroupSsm wraps g_socket_join_multicast_group_ssm
// 
// The function takes the following parameters:
// 
// 	- group InetAddress: a #GInetAddress specifying the group address to join. 
// 	- sourceSpecific InetAddress (nullable): a #GInetAddress specifying the
// source-specific multicast address or %NULL to ignore. 
// 	- iface string (nullable): Name of the interface to use, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Registers @socket to receive multicast messages sent to @group.
// @socket must be a %G_SOCKET_TYPE_DATAGRAM socket, and must have
// been bound to an appropriate interface and port with
// g_socket_bind().
// 
// If @iface is %NULL, the system will automatically pick an interface
// to bind to based on @group.
// 
// If @source_specific is not %NULL, use source-specific multicast as
// defined in RFC 4604. Note that on older platforms this may fail
// with a %G_IO_ERROR_NOT_SUPPORTED error.
// 
// Note that this function can be called multiple times for the same
// @group with different @source_specific in order to receive multicast
// packets from more than one source.
func (socket *SocketInstance) JoinMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GInetAddress // in, none, converted, nullable
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific != nil {
		carg2 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(sourceSpecific))
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_join_multicast_group_ssm(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LeaveMulticastGroup wraps g_socket_leave_multicast_group
// 
// The function takes the following parameters:
// 
// 	- group InetAddress: a #GInetAddress specifying the group address to leave. 
// 	- sourceSpecific bool: %TRUE if source-specific multicast was used 
// 	- iface string (nullable): Interface used 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes @socket from the multicast group defined by @group, @iface,
// and @source_specific (which must all have the same values they had
// when you joined the group).
// 
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
// 
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
func (socket *SocketInstance) LeaveMulticastGroup(group InetAddress, sourceSpecific bool, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 C.gboolean      // in
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific {
		carg2 = C.TRUE
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_leave_multicast_group(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LeaveMulticastGroupSsm wraps g_socket_leave_multicast_group_ssm
// 
// The function takes the following parameters:
// 
// 	- group InetAddress: a #GInetAddress specifying the group address to leave. 
// 	- sourceSpecific InetAddress (nullable): a #GInetAddress specifying the
// source-specific multicast address or %NULL to ignore. 
// 	- iface string (nullable): Name of the interface to use, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes @socket from the multicast group defined by @group, @iface,
// and @source_specific (which must all have the same values they had
// when you joined the group).
// 
// @socket remains bound to its address and port, and can still receive
// unicast messages after calling this.
func (socket *SocketInstance) LeaveMulticastGroupSsm(group InetAddress, sourceSpecific InetAddress, iface string) (bool, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.GInetAddress // in, none, converted
	var carg2 *C.GInetAddress // in, none, converted, nullable
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(group))
	if sourceSpecific != nil {
		carg2 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(sourceSpecific))
	}
	if iface != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_socket_leave_multicast_group_ssm(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Listen wraps g_socket_listen
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Marks the socket as a server socket, i.e. a socket that is used
// to accept incoming requests using g_socket_accept().
// 
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
// 
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
func (socket *SocketInstance) Listen() (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_listen(carg0, &_cerr)
	runtime.KeepAlive(socket)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveBytes wraps g_socket_receive_bytes
// 
// The function takes the following parameters:
// 
// 	- size uint: the number of bytes you want to read from the socket 
// 	- timeoutUs int64: the timeout to wait for, in microseconds, or `-1` to block
//   indefinitely 
// 	- cancellable Cancellable (nullable): a %GCancellable, or `NULL` 
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Receives data (up to @size bytes) from a socket.
// 
// This function is a variant of [method@Gio.Socket.receive] which returns a
// [struct@GLib.Bytes] rather than a plain buffer.
// 
// Pass `-1` to @timeout_us to block indefinitely until data is received (or
// the connection is closed, or there is an error). Pass `0` to use the default
// timeout from [property@Gio.Socket:timeout], or pass a positive number to wait
// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
func (socket *SocketInstance) ReceiveBytes(size uint, timeoutUs int64, cancellable Cancellable) (*glib.Bytes, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 C.gint64        // in, none, casted
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  *C.GBytes       // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gsize(size)
	carg2 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_bytes(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var goret  *glib.Bytes
	var _goerr error

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReceiveBytesFrom wraps g_socket_receive_bytes_from
// 
// The function takes the following parameters:
// 
// 	- size uint: the number of bytes you want to read from the socket 
// 	- timeoutUs int64: the timeout to wait for, in microseconds, or `-1` to block
//   indefinitely 
// 	- cancellable Cancellable (nullable): a #GCancellable, or `NULL` 
// 
// The function returns the following values:
// 
// 	- address SocketAddress: return location for a #GSocketAddress 
// 	- goret *glib.Bytes 
// 	- _goerr error (nullable): an error 
//
// Receive data (up to @size bytes) from a socket.
// 
// This function is a variant of [method@Gio.Socket.receive_from] which returns
// a [struct@GLib.Bytes] rather than a plain buffer.
// 
// If @address is non-%NULL then @address will be set equal to the
// source address of the received packet.
// 
// The @address is owned by the caller.
// 
// Pass `-1` to @timeout_us to block indefinitely until data is received (or
// the connection is closed, or there is an error). Pass `0` to use the default
// timeout from [property@Gio.Socket:timeout], or pass a positive number to wait
// for that many microseconds for data before returning `G_IO_ERROR_TIMED_OUT`.
func (socket *SocketInstance) ReceiveBytesFrom(size uint, timeoutUs int64, cancellable Cancellable) (SocketAddress, *glib.Bytes, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg2 C.gsize           // in, none, casted
	var carg3 C.gint64          // in, none, casted
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var carg1 *C.GSocketAddress // out, full, converted
	var cret  *C.GBytes         // return, full, converted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg2 = C.gsize(size)
	carg3 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_bytes_from(carg0, &carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(size)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var address SocketAddress
	var goret   *glib.Bytes
	var _goerr  error

	address = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(carg1))
	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return address, goret, _goerr
}

// ReceiveMessages wraps g_socket_receive_messages
// 
// The function takes the following parameters:
// 
// 	- messages []InputMessage: an array of #GInputMessage structs 
// 	- flags int32: an int containing #GSocketMsgFlags flags for the overall operation,
//    which may additionally contain
//    [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Receive multiple data messages from @socket in one go.  This is the most
// complicated and fully-featured version of this call. For easier use, see
// g_socket_receive(), g_socket_receive_from(), and g_socket_receive_message().
// 
// @messages must point to an array of #GInputMessage structs and
// @num_messages must be the length of this array. Each #GInputMessage
// contains a pointer to an array of #GInputVector structs describing the
// buffers that the data received in each message will be written to. Using
// multiple #GInputVectors is more memory-efficient than manually copying data
// out of a single buffer to multiple sources, and more system-call-efficient
// than making multiple calls to g_socket_receive(), such as in scenarios where
// a lot of data packets need to be received (e.g. high-bandwidth video
// streaming over RTP/UDP).
// 
// @flags modify how all messages are received. The commonly available
// arguments for this are available in the #GSocketMsgFlags enum, but the
// values there are the same as the system values, and the flags
// are passed in as-is, so you can pass in system-specific flags too. These
// flags affect the overall receive operation. Flags affecting individual
// messages are returned in #GInputMessage.flags.
// 
// The other members of #GInputMessage are treated as described in its
// documentation.
// 
// If #GSocket:blocking is %TRUE the call will block until @num_messages have
// been received, or the end of the stream is reached.
// 
// If #GSocket:blocking is %FALSE the call will return up to @num_messages
// without blocking, or %G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
// operating system to be received.
// 
// In blocking mode, if #GSocket:timeout is positive and is reached before any
// messages are received, %G_IO_ERROR_TIMED_OUT is returned, otherwise up to
// @num_messages are returned. (Note: This is effectively the
// behaviour of `MSG_WAITFORONE` with recvmmsg().)
// 
// To be notified when messages are available, wait for the
// %G_IO_IN condition. Note though that you may still receive
// %G_IO_ERROR_WOULD_BLOCK from g_socket_receive_messages() even if you were
// previously notified of a %G_IO_IN condition.
// 
// If the remote peer closes the connection, any messages queued in the
// operating system will be returned, and subsequent calls to
// g_socket_receive_messages() will return 0 (with no error set).
// 
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be received; otherwise the number of
// messages successfully received before the error will be returned.
func (socket *SocketInstance) ReceiveMessages(messages []InputMessage, flags int32, cancellable Cancellable) (int32, error) {
	var carg0 *C.GSocket       // in, none, converted
	var carg1 *C.GInputMessage // in, transfer: none, C Pointers: 1, Name: array[InputMessage], array (inner GInputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint          // implicit
	var carg3 C.gint           // in, none, casted
	var carg4 *C.GCancellable  // in, none, converted, nullable
	var cret  C.gint           // return, none, casted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []InputMessage (GInputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_receive_messages(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Send wraps g_socket_send
// 
// The function takes the following parameters:
// 
// 	- buffer string: the buffer
//     containing the data to send. 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to send @size bytes from @buffer on the socket. This is
// mainly used by connection-oriented sockets; it is identical to
// g_socket_send_to() with @address set to %NULL.
// 
// If the socket is in blocking mode the call will block until there is
// space for the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
// will be returned. To be notified when space is available, wait for the
// %G_IO_OUT condition. Note though that you may still receive
// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a %G_IO_OUT condition. (On Windows in particular, this is
// very common due to the way the underlying APIs work.)
// 
// On error -1 is returned and @error is set accordingly.
func (socket *SocketInstance) Send(buffer string, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.gchar        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize         // implicit
	var carg3 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessage wraps g_socket_send_message
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
// 	- vectors []OutputVector: an array of #GOutputVector structs 
// 	- messages []SocketControlMessage (nullable): a pointer to an
//   array of #GSocketControlMessages, or %NULL. 
// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Send data to @address on @socket.  For sending multiple messages see
// g_socket_send_messages(); for easier use, see
// g_socket_send() and g_socket_send_to().
// 
// If @address is %NULL then the message is sent to the default receiver
// (set by g_socket_connect()).
// 
// @vectors must point to an array of #GOutputVector structs and
// @num_vectors must be the length of this array. (If @num_vectors is -1,
// then @vectors is assumed to be terminated by a #GOutputVector with a
// %NULL buffer pointer.) The #GOutputVector structs describe the buffers
// that the sent data will be gathered from. Using multiple
// #GOutputVectors is more memory-efficient than manually copying
// data from multiple sources into a single buffer, and more
// network-efficient than making multiple calls to g_socket_send().
// 
// @messages, if non-%NULL, is taken to point to an array of @num_messages
// #GSocketControlMessage instances. These correspond to the control
// messages to be sent on the socket.
// If @num_messages is -1 then @messages is treated as a %NULL-terminated
// array.
// 
// @flags modify how the message is sent. The commonly available arguments
// for this are available in the #GSocketMsgFlags enum, but the
// values there are the same as the system values, and the flags
// are passed in as-is, so you can pass in system-specific flags too.
// 
// If the socket is in blocking mode the call will block until there is
// space for the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
// will be returned. To be notified when space is available, wait for the
// %G_IO_OUT condition. Note though that you may still receive
// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a %G_IO_OUT condition. (On Windows in particular, this is
// very common due to the way the underlying APIs work.)
// 
// The sum of the sizes of each #GOutputVector in vectors must not be
// greater than %G_MAXSSIZE. If the message can be larger than this,
// then it is mandatory to use the g_socket_send_message_with_timeout()
// function.
// 
// On error -1 is returned and @error is set accordingly.
func (socket *SocketInstance) SendMessage(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int32, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket                // in, none, converted
	var carg1 *C.GSocketAddress         // in, none, converted, nullable
	var carg2 *C.GOutputVector          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg3)
	var carg3 C.gint                    // implicit
	var carg4 **C.GSocketControlMessage // in, transfer: none, C Pointers: 2, Name: array[SocketControlMessage], nullable, array (inner GSocketControlMessage* (*typesystem.Class), length-by: carg5)
	var carg5 C.gint                    // implicit
	var carg6 C.gint                    // in, none, casted
	var carg7 *C.GCancellable           // in, none, converted, nullable
	var cret  C.gssize                  // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = vectors
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []OutputVector (GOutputVector*) because of unimplemented: non-fixed size array")
	_ = messages
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []SocketControlMessage (GSocketControlMessage**) because of unimplemented: inner pointers in array")
	carg6 = C.gint(flags)
	if cancellable != nil {
		carg7 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_message(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendMessageWithTimeout wraps g_socket_send_message_with_timeout
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
// 	- vectors []OutputVector: an array of #GOutputVector structs 
// 	- messages []SocketControlMessage (nullable): a pointer to an
//   array of #GSocketControlMessages, or %NULL. 
// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
// 	- timeoutUs int64: the maximum time (in microseconds) to wait, or -1 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- bytesWritten uint: location to store the number of bytes that were written to the socket 
// 	- goret PollableReturn 
// 	- _goerr error (nullable): an error 
//
// This behaves exactly the same as g_socket_send_message(), except that
// the choice of timeout behavior is determined by the @timeout_us argument
// rather than by @socket's properties.
// 
// On error %G_POLLABLE_RETURN_FAILED is returned and @error is set accordingly, or
// if the socket is currently not writable %G_POLLABLE_RETURN_WOULD_BLOCK is
// returned. @bytes_written will contain 0 in both cases.
func (socket *SocketInstance) SendMessageWithTimeout(address SocketAddress, vectors []OutputVector, messages []SocketControlMessage, flags int32, timeoutUs int64, cancellable Cancellable) (uint, PollableReturn, error) {
	var carg0 *C.GSocket                // in, none, converted
	var carg1 *C.GSocketAddress         // in, none, converted, nullable
	var carg2 *C.GOutputVector          // in, transfer: none, C Pointers: 1, Name: array[OutputVector], array (inner GOutputVector (*typesystem.Record), length-by: carg3)
	var carg3 C.gint                    // implicit
	var carg4 **C.GSocketControlMessage // in, transfer: none, C Pointers: 2, Name: array[SocketControlMessage], nullable, array (inner GSocketControlMessage* (*typesystem.Class), length-by: carg5)
	var carg5 C.gint                    // implicit
	var carg6 C.gint                    // in, none, casted
	var carg7 C.gint64                  // in, none, casted
	var carg9 *C.GCancellable           // in, none, converted, nullable
	var carg8 C.gsize                   // out, full, casted
	var cret  C.GPollableReturn         // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = vectors
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []OutputVector (const GOutputVector*) because of unimplemented: non-fixed size array")
	_ = messages
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []SocketControlMessage (GSocketControlMessage**) because of unimplemented: inner pointers in array")
	carg6 = C.gint(flags)
	carg7 = C.gint64(timeoutUs)
	if cancellable != nil {
		carg9 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_message_with_timeout(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, &carg8, carg9, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutUs)
	runtime.KeepAlive(cancellable)

	var bytesWritten uint
	var goret        PollableReturn
	var _goerr       error

	bytesWritten = uint(carg8)
	goret = PollableReturn(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesWritten, goret, _goerr
}

// SendMessages wraps g_socket_send_messages
// 
// The function takes the following parameters:
// 
// 	- messages []OutputMessage: an array of #GOutputMessage structs 
// 	- flags int32: an int containing #GSocketMsgFlags flags, which may additionally
//    contain [other platform specific flags](http://man7.org/linux/man-pages/man2/recv.2.html) 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Send multiple data messages from @socket in one go.  This is the most
// complicated and fully-featured version of this call. For easier use, see
// g_socket_send(), g_socket_send_to(), and g_socket_send_message().
// 
// @messages must point to an array of #GOutputMessage structs and
// @num_messages must be the length of this array. Each #GOutputMessage
// contains an address to send the data to, and a pointer to an array of
// #GOutputVector structs to describe the buffers that the data to be sent
// for each message will be gathered from. Using multiple #GOutputVectors is
// more memory-efficient than manually copying data from multiple sources
// into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send(). Sending multiple messages in one go avoids the
// overhead of making a lot of syscalls in scenarios where a lot of data
// packets need to be sent (e.g. high-bandwidth video streaming over RTP/UDP),
// or where the same data needs to be sent to multiple recipients.
// 
// @flags modify how the message is sent. The commonly available arguments
// for this are available in the #GSocketMsgFlags enum, but the
// values there are the same as the system values, and the flags
// are passed in as-is, so you can pass in system-specific flags too.
// 
// If the socket is in blocking mode the call will block until there is
// space for all the data in the socket queue. If there is no space available
// and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
// will be returned if no data was written at all, otherwise the number of
// messages sent will be returned. To be notified when space is available,
// wait for the %G_IO_OUT condition. Note though that you may still receive
// %G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a %G_IO_OUT condition. (On Windows in particular, this is
// very common due to the way the underlying APIs work.)
// 
// On error -1 is returned and @error is set accordingly. An error will only
// be returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned.
func (socket *SocketInstance) SendMessages(messages []OutputMessage, flags int32, cancellable Cancellable) (int32, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GOutputMessage // in, transfer: none, C Pointers: 1, Name: array[OutputMessage], array (inner GOutputMessage (*typesystem.Record), length-by: carg2)
	var carg2 C.guint           // implicit
	var carg3 C.gint            // in, none, casted
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gint            // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = messages
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []OutputMessage (GOutputMessage*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_messages(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendTo wraps g_socket_send_to
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
// 	- buffer string: the buffer
//     containing the data to send. 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to send @size bytes from @buffer to @address. If @address is
// %NULL then the message is sent to the default receiver (set by
// g_socket_connect()).
// 
// See g_socket_send() for additional information.
func (socket *SocketInstance) SendTo(address SocketAddress, buffer string, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket        // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted, nullable
	var carg2 *C.gchar          // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize           // implicit
	var carg4 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gssize          // return, none, casted
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}
	_ = buffer
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_to(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SendWithBlocking wraps g_socket_send_with_blocking
// 
// The function takes the following parameters:
// 
// 	- buffer string: the buffer
//     containing the data to send. 
// 	- blocking bool: whether to do blocking or non-blocking I/O 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// This behaves exactly the same as g_socket_send(), except that
// the choice of blocking or non-blocking behavior is determined by
// the @blocking argument rather than by @socket's properties.
func (socket *SocketInstance) SendWithBlocking(buffer string, blocking bool, cancellable Cancellable) (int, error) {
	var carg0 *C.GSocket      // in, none, converted
	var carg1 *C.gchar        // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize         // implicit
	var carg3 C.gboolean      // in
	var carg4 *C.GCancellable // in, none, converted, nullable
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	_ = buffer
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	if blocking {
		carg3 = C.TRUE
	}
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_send_with_blocking(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBlocking wraps g_socket_set_blocking
// 
// The function takes the following parameters:
// 
// 	- blocking bool: Whether to use blocking I/O or not. 
//
// Sets the blocking mode of the socket. In blocking mode
// all operations (which don&#x2019;t take an explicit blocking parameter) block until
// they succeed or there is an error. In
// non-blocking mode all functions return results immediately or
// with a %G_IO_ERROR_WOULD_BLOCK error.
// 
// All sockets are created in blocking mode. However, note that the
// platform level socket is always non-blocking, and blocking mode
// is a GSocket level feature.
func (socket *SocketInstance) SetBlocking(blocking bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if blocking {
		carg1 = C.TRUE
	}

	C.g_socket_set_blocking(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(blocking)
}

// SetBroadcast wraps g_socket_set_broadcast
// 
// The function takes the following parameters:
// 
// 	- broadcast bool: whether @socket should allow sending to broadcast
//     addresses 
//
// Sets whether @socket should allow sending to broadcast addresses.
// This is %FALSE by default.
func (socket *SocketInstance) SetBroadcast(broadcast bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if broadcast {
		carg1 = C.TRUE
	}

	C.g_socket_set_broadcast(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(broadcast)
}

// SetKeepalive wraps g_socket_set_keepalive
// 
// The function takes the following parameters:
// 
// 	- keepalive bool: Value for the keepalive flag 
//
// Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
// this flag is set on a socket, the system will attempt to verify that the
// remote socket endpoint is still present if a sufficiently long period of
// time passes with no data being exchanged. If the system is unable to
// verify the presence of the remote endpoint, it will automatically close
// the connection.
// 
// This option is only functional on certain kinds of sockets. (Notably,
// %G_SOCKET_PROTOCOL_TCP sockets.)
// 
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag
// on a server socket if you want to allow clients to remain idle for long
// periods of time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
func (socket *SocketInstance) SetKeepalive(keepalive bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if keepalive {
		carg1 = C.TRUE
	}

	C.g_socket_set_keepalive(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(keepalive)
}

// SetListenBacklog wraps g_socket_set_listen_backlog
// 
// The function takes the following parameters:
// 
// 	- backlog int32: the maximum number of pending connections. 
//
// Sets the maximum number of outstanding connections allowed
// when listening on this socket. If more clients than this are
// connecting to the socket and the application is not handling them
// on time then the new connections will be refused.
// 
// Note that this must be called before g_socket_listen() and has no
// effect if called after that.
func (socket *SocketInstance) SetListenBacklog(backlog int32) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(backlog)

	C.g_socket_set_listen_backlog(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(backlog)
}

// SetMulticastLoopback wraps g_socket_set_multicast_loopback
// 
// The function takes the following parameters:
// 
// 	- loopback bool: whether @socket should receive messages sent to its
//   multicast groups from the local host 
//
// Sets whether outgoing multicast packets will be received by sockets
// listening on that multicast address on the same host. This is %TRUE
// by default.
func (socket *SocketInstance) SetMulticastLoopback(loopback bool) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if loopback {
		carg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(loopback)
}

// SetMulticastTtl wraps g_socket_set_multicast_ttl
// 
// The function takes the following parameters:
// 
// 	- ttl uint: the time-to-live value for all multicast datagrams on @socket 
//
// Sets the time-to-live for outgoing multicast datagrams on @socket.
// By default, this is 1, meaning that multicast packets will not leave
// the local network.
func (socket *SocketInstance) SetMulticastTtl(ttl uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// SetOption wraps g_socket_set_option
// 
// The function takes the following parameters:
// 
// 	- level int32: the "API level" of the option (eg, `SOL_SOCKET`) 
// 	- optname int32: the "name" of the option (eg, `SO_BROADCAST`) 
// 	- value int32: the value to set the option to 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Sets the value of an integer-valued option on @socket, as with
// setsockopt(). (If you need to set a non-integer-valued option,
// you will need to call setsockopt() directly.)
// 
// The [`&lt;gio/gnetworking.h&gt;`](networking.html)
// header pulls in system headers that will define most of the
// standard/portable socket options. For unusual socket protocols or
// platform-dependent options, you may need to include additional
// headers.
func (socket *SocketInstance) SetOption(level int32, optname int32, value int32) (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gint     // in, none, casted
	var carg2 C.gint     // in, none, casted
	var carg3 C.gint     // in, none, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.gint(level)
	carg2 = C.gint(optname)
	carg3 = C.gint(value)

	cret = C.g_socket_set_option(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)
	runtime.KeepAlive(value)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetTimeout wraps g_socket_set_timeout
// 
// The function takes the following parameters:
// 
// 	- timeout uint: the timeout for @socket, in seconds, or 0 for none 
//
// Sets the time in seconds after which I/O operations on @socket will
// time out if they have not yet completed.
// 
// On a blocking socket, this means that any blocking #GSocket
// operation will time out after @timeout seconds of inactivity,
// returning %G_IO_ERROR_TIMED_OUT.
// 
// On a non-blocking socket, calls to g_socket_condition_wait() will
// also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
// created with g_socket_create_source() will trigger after
// @timeout seconds of inactivity, with the requested condition
// set, at which point calling g_socket_receive(), g_socket_send(),
// g_socket_check_connect_result(), etc, will fail with
// %G_IO_ERROR_TIMED_OUT.
// 
// If @timeout is 0 (the default), operations will never time out
// on their own.
// 
// Note that if an I/O operation is interrupted by a signal, this may
// cause the timeout to be reset.
func (socket *SocketInstance) SetTimeout(timeout uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(timeout)

	C.g_socket_set_timeout(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(timeout)
}

// SetTtl wraps g_socket_set_ttl
// 
// The function takes the following parameters:
// 
// 	- ttl uint: the time-to-live value for all unicast packets on @socket 
//
// Sets the time-to-live for outgoing unicast packets on @socket.
// By default the platform-specific default value is used.
func (socket *SocketInstance) SetTtl(ttl uint) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.guint    // in, none, casted

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	carg1 = C.guint(ttl)

	C.g_socket_set_ttl(carg0, carg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// Shutdown wraps g_socket_shutdown
// 
// The function takes the following parameters:
// 
// 	- shutdownRead bool: whether to shut down the read side 
// 	- shutdownWrite bool: whether to shut down the write side 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Shut down part or all of a full-duplex connection.
// 
// If @shutdown_read is %TRUE then the receiving side of the connection
// is shut down, and further reading is disallowed.
// 
// If @shutdown_write is %TRUE then the sending side of the connection
// is shut down, and further writing is disallowed.
// 
// It is allowed for both @shutdown_read and @shutdown_write to be %TRUE.
// 
// One example where it is useful to shut down only one side of a connection is
// graceful disconnect for TCP connections where you close the sending side,
// then wait for the other side to close the connection, thus ensuring that the
// other side saw all sent data.
func (socket *SocketInstance) Shutdown(shutdownRead bool, shutdownWrite bool) (bool, error) {
	var carg0 *C.GSocket // in, none, converted
	var carg1 C.gboolean // in
	var carg2 C.gboolean // in
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if shutdownRead {
		carg1 = C.TRUE
	}
	if shutdownWrite {
		carg2 = C.TRUE
	}

	cret = C.g_socket_shutdown(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpeaksIpv4 wraps g_socket_speaks_ipv4
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a socket is capable of speaking IPv4.
// 
// IPv4 sockets are capable of speaking IPv4.  On some operating systems
// and under some combinations of circumstances IPv6 sockets are also
// capable of speaking IPv4.  See RFC 3493 section 3.7 for more
// information.
// 
// No other types of sockets are currently considered as being capable
// of speaking IPv4.
func (socket *SocketInstance) SpeaksIpv4() bool {
	var carg0 *C.GSocket // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_socket_speaks_ipv4(carg0)
	runtime.KeepAlive(socket)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SocketOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketOverrides[Instance Socket] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplySocketOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketOverrides[Instance Socket](gclass unsafe.Pointer, overrides SocketOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterSocketSubClass is used to register a go subclass of GSocket. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketSubClass[InstanceT Socket](
		name string,
		classInit func(class *SocketClass),
		constructor func() InstanceT,
		overrides SocketOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocket,
		UnsafeSocketClassFromGlibBorrow,
		UnsafeApplySocketOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocket(obj)
		},
		interfaceInits...,
	)
}

// SocketAddressInstance is the instance type used by all types extending GSocketAddress. It is used internally by the bindings. Users should use the interface [SocketAddress] instead.
type SocketAddressInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketAddress = (*SocketAddressInstance)(nil)

// SocketAddress wraps GSocketAddress
//
// `GSocketAddress` is the equivalent of
// [`struct sockaddr`](man:sockaddr(3type)) and its subtypes in the BSD sockets
// API. This is an abstract class; use [class@Gio.InetSocketAddress] for
// internet sockets, or [class@Gio.UnixSocketAddress] for UNIX domain sockets.
type SocketAddress interface {
	gobject.Object
	upcastToGSocketAddress() *SocketAddressInstance

	// GetFamily wraps g_socket_address_get_family
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the socket family type of @address.
	GetFamily() SocketFamily
	// GetNativeSize wraps g_socket_address_get_native_size
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	//
	// Gets the size of @address's native struct sockaddr.
	// You can use this to allocate memory to pass to
	// g_socket_address_to_native().
	GetNativeSize() int

	// chain up virtual methods:

	// ParentGetFamily calls the default implementations of the `GSocketAddress.get_family` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the socket family type of @address.
	ParentGetFamily() SocketFamily
	// ParentGetNativeSize calls the default implementations of the `GSocketAddress.get_native_size` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	//
	// Gets the size of @address's native struct sockaddr.
	// You can use this to allocate memory to pass to
	// g_socket_address_to_native().
	ParentGetNativeSize() int
}

func unsafeWrapSocketAddress(base *gobject.ObjectInstance) *SocketAddressInstance {
	return &SocketAddressInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddress(inst)
		},
	)
}

func marshalSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketAddressFromGlibNone is used to convert raw GSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibNone(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketAddress)
}

// UnsafeSocketAddressFromGlibFull is used to convert raw GSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibFull(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketAddress)
}

// UnsafeSocketAddressFromGlibBorrow is used to convert raw GSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketAddressFromGlibBorrow(c unsafe.Pointer) SocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketAddress)
}

func (s *SocketAddressInstance) upcastToGSocketAddress() *SocketAddressInstance {
	return s
}

// UnsafeSocketAddressToGlibNone is used to convert the instance to it's C value GSocketAddress. This is used by the bindings internally.
func UnsafeSocketAddressToGlibNone(c SocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketAddressToGlibFull is used to convert the instance to it's C value GSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketAddressToGlibFull(c SocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetFamily wraps g_socket_address_get_family
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets the socket family type of @address.
func (address *SocketAddressInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocketAddress // in, none, converted
	var cret  C.GSocketFamily   // return, none, casted

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C.g_socket_address_get_family(carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetNativeSize wraps g_socket_address_get_native_size
// 
// The function returns the following values:
// 
// 	- goret int 
//
// Gets the size of @address's native struct sockaddr.
// You can use this to allocate memory to pass to
// g_socket_address_to_native().
func (address *SocketAddressInstance) GetNativeSize() int {
	var carg0 *C.GSocketAddress // in, none, converted
	var cret  C.gssize          // return, none, casted

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C.g_socket_address_get_native_size(carg0)
	runtime.KeepAlive(address)

	var goret int

	goret = int(cret)

	return goret
}

// SocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketAddressOverrides[Instance SocketAddress] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetFamily allows you to override the implementation of the virtual method get_family.
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the socket family type of @address.
	GetFamily func(Instance) SocketFamily
	// // GetNativeSize allows you to override the implementation of the virtual method get_native_size.
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	//
	// Gets the size of @address's native struct sockaddr.
	// You can use this to allocate memory to pass to
	// g_socket_address_to_native().
	GetNativeSize func(Instance) int
}

// UnsafeApplySocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketAddressOverrides[Instance SocketAddress](gclass unsafe.Pointer, overrides SocketAddressOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketAddressClass)(gclass)

	if overrides.GetFamily != nil {
		pclass.get_family = (*[0]byte)(C._goglib_gio2_SocketAddress_get_family)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddress_get_family",
			func(carg0 *C.GSocketAddress) (cret C.GSocketFamily) {
				var address Instance     // go GSocketAddress subclass
				var goret   SocketFamily // return, none, casted

				address = UnsafeSocketAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetFamily(address)

				cret = C.GSocketFamily(goret)

				return cret
			},
		)
	}

	if overrides.GetNativeSize != nil {
		pclass.get_native_size = (*[0]byte)(C._goglib_gio2_SocketAddress_get_native_size)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddress_get_native_size",
			func(carg0 *C.GSocketAddress) (cret C.gssize) {
				var address Instance // go GSocketAddress subclass
				var goret   int      // return, none, casted

				address = UnsafeSocketAddressFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNativeSize(address)

				cret = C.gssize(goret)

				return cret
			},
		)
	}
}

// ParentGetFamily calls the default implementations of the `GSocketAddress.get_family` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets the socket family type of @address.
func (address *SocketAddressInstance) ParentGetFamily() SocketFamily {
	var carg0 *C.GSocketAddress
	var cret  C.GSocketFamily // return, none, casted

	parentclass := (*C.GSocketAddressClass)(classdata.PeekParentClass(UnsafeSocketAddressToGlibNone(address)))

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C._goglib_gio2_SocketAddress_virtual_get_family(unsafe.Pointer(parentclass.get_family), carg0)
	runtime.KeepAlive(address)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// ParentGetNativeSize calls the default implementations of the `GSocketAddress.get_native_size` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int 
//
// Gets the size of @address's native struct sockaddr.
// You can use this to allocate memory to pass to
// g_socket_address_to_native().
func (address *SocketAddressInstance) ParentGetNativeSize() int {
	var carg0 *C.GSocketAddress
	var cret  C.gssize // return, none, casted

	parentclass := (*C.GSocketAddressClass)(classdata.PeekParentClass(UnsafeSocketAddressToGlibNone(address)))

	carg0 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))

	cret = C._goglib_gio2_SocketAddress_virtual_get_native_size(unsafe.Pointer(parentclass.get_native_size), carg0)
	runtime.KeepAlive(address)

	var goret int

	goret = int(cret)

	return goret
}

// RegisterSocketAddressSubClass is used to register a go subclass of GSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketAddressSubClass[InstanceT SocketAddress](
		name string,
		classInit func(class *SocketAddressClass),
		constructor func() InstanceT,
		overrides SocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketAddress,
		UnsafeSocketAddressClassFromGlibBorrow,
		UnsafeApplySocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// SocketAddressEnumeratorInstance is the instance type used by all types extending GSocketAddressEnumerator. It is used internally by the bindings. Users should use the interface [SocketAddressEnumerator] instead.
type SocketAddressEnumeratorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketAddressEnumerator = (*SocketAddressEnumeratorInstance)(nil)

// SocketAddressEnumerator wraps GSocketAddressEnumerator
//
// `GSocketAddressEnumerator` is an enumerator type for
// [class@Gio.SocketAddress] instances. It is returned by enumeration functions
// such as [method@Gio.SocketConnectable.enumerate], which returns a
// `GSocketAddressEnumerator` to list each [class@Gio.SocketAddress] which could
// be used to connect to that [iface@Gio.SocketConnectable].
// 
// Enumeration is typically a blocking operation, so the asynchronous methods
// [method@Gio.SocketAddressEnumerator.next_async] and
// [method@Gio.SocketAddressEnumerator.next_finish] should be used where
// possible.
// 
// Each `GSocketAddressEnumerator` can only be enumerated once. Once
// [method@Gio.SocketAddressEnumerator.next] has returned `NULL`, further
// enumeration with that `GSocketAddressEnumerator` is not possible, and it can
// be unreffed.
type SocketAddressEnumerator interface {
	gobject.Object
	upcastToGSocketAddressEnumerator() *SocketAddressEnumeratorInstance

	// Next wraps g_socket_address_enumerator_next
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the next #GSocketAddress from @enumerator. Note that this
	// may block for some amount of time. (Eg, a #GNetworkAddress may need
	// to do a DNS lookup before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid
	// blocking.
	// 
	// If @enumerator is expected to yield addresses, but for some reason
	// is unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error
	// in `*error`. However, if the first call to
	// g_socket_address_enumerator_next() succeeds, then any further
	// internal errors (other than @cancellable being triggered) will be
	// ignored.
	Next(Cancellable) (SocketAddress, error)
	// NextAsync wraps g_socket_address_enumerator_next_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
	//   when the request is satisfied 
	//
	// Asynchronously retrieves the next #GSocketAddress from @enumerator
	// and then calls @callback, which must call
	// g_socket_address_enumerator_next_finish() to get the result.
	// 
	// It is an error to call this multiple times before the previous callback has finished.
	NextAsync(Cancellable, AsyncReadyCallback)
	// NextFinish wraps g_socket_address_enumerator_next_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a completed call to
	// g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about
	// error handling.
	NextFinish(AsyncResult) (SocketAddress, error)

	// chain up virtual methods:

	// ParentNext calls the default implementations of the `GSocketAddressEnumerator.next` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the next #GSocketAddress from @enumerator. Note that this
	// may block for some amount of time. (Eg, a #GNetworkAddress may need
	// to do a DNS lookup before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid
	// blocking.
	// 
	// If @enumerator is expected to yield addresses, but for some reason
	// is unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error
	// in `*error`. However, if the first call to
	// g_socket_address_enumerator_next() succeeds, then any further
	// internal errors (other than @cancellable being triggered) will be
	// ignored.
	ParentNext(cancellable Cancellable) (SocketAddress, error)
	// ParentNextFinish calls the default implementations of the `GSocketAddressEnumerator.next_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a completed call to
	// g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about
	// error handling.
	ParentNextFinish(result AsyncResult) (SocketAddress, error)
}

func unsafeWrapSocketAddressEnumerator(base *gobject.ObjectInstance) *SocketAddressEnumeratorInstance {
	return &SocketAddressEnumeratorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketAddressEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddressEnumerator(inst)
		},
	)
}

func marshalSocketAddressEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketAddressEnumeratorFromGlibNone is used to convert raw GSocketAddressEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibNone(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketAddressEnumerator)
}

// UnsafeSocketAddressEnumeratorFromGlibFull is used to convert raw GSocketAddressEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibFull(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketAddressEnumerator)
}

// UnsafeSocketAddressEnumeratorFromGlibBorrow is used to convert raw GSocketAddressEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorFromGlibBorrow(c unsafe.Pointer) SocketAddressEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketAddressEnumerator)
}

func (s *SocketAddressEnumeratorInstance) upcastToGSocketAddressEnumerator() *SocketAddressEnumeratorInstance {
	return s
}

// UnsafeSocketAddressEnumeratorToGlibNone is used to convert the instance to it's C value GSocketAddressEnumerator. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorToGlibNone(c SocketAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketAddressEnumeratorToGlibFull is used to convert the instance to it's C value GSocketAddressEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorToGlibFull(c SocketAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// Next wraps g_socket_address_enumerator_next
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
// 	- _goerr error (nullable): an error 
//
// Retrieves the next #GSocketAddress from @enumerator. Note that this
// may block for some amount of time. (Eg, a #GNetworkAddress may need
// to do a DNS lookup before it can return an address.) Use
// g_socket_address_enumerator_next_async() if you need to avoid
// blocking.
// 
// If @enumerator is expected to yield addresses, but for some reason
// is unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error
// in `*error`. However, if the first call to
// g_socket_address_enumerator_next() succeeds, then any further
// internal errors (other than @cancellable being triggered) will be
// ignored.
func (enumerator *SocketAddressEnumeratorInstance) Next(cancellable Cancellable) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GCancellable             // in, none, converted, nullable
	var cret  *C.GSocketAddress           // return, full, converted, nullable
	var _cerr *C.GError                   // out, full, converted, nullable

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_address_enumerator_next(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NextAsync wraps g_socket_address_enumerator_next_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback to call
//   when the request is satisfied 
//
// Asynchronously retrieves the next #GSocketAddress from @enumerator
// and then calls @callback, which must call
// g_socket_address_enumerator_next_finish() to get the result.
// 
// It is an error to call this multiple times before the previous callback has finished.
func (enumerator *SocketAddressEnumeratorInstance) NextAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GCancellable             // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback       // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer                  // implicit

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_address_enumerator_next_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// NextFinish wraps g_socket_address_enumerator_next_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a completed call to
// g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about
// error handling.
func (enumerator *SocketAddressEnumeratorInstance) NextFinish(result AsyncResult) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator // in, none, converted
	var carg1 *C.GAsyncResult             // in, none, converted
	var cret  *C.GSocketAddress           // return, full, converted, nullable
	var _cerr *C.GError                   // out, full, converted, nullable

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_address_enumerator_next_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SocketAddressEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketAddressEnumeratorOverrides[Instance SocketAddressEnumerator] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Next allows you to override the implementation of the virtual method next.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the next #GSocketAddress from @enumerator. Note that this
	// may block for some amount of time. (Eg, a #GNetworkAddress may need
	// to do a DNS lookup before it can return an address.) Use
	// g_socket_address_enumerator_next_async() if you need to avoid
	// blocking.
	// 
	// If @enumerator is expected to yield addresses, but for some reason
	// is unable to (eg, because of a DNS error), then the first call to
	// g_socket_address_enumerator_next() will return an appropriate error
	// in `*error`. However, if the first call to
	// g_socket_address_enumerator_next() succeeds, then any further
	// internal errors (other than @cancellable being triggered) will be
	// ignored.
	Next func(Instance, Cancellable) (SocketAddress, error)
	// // NextFinish allows you to override the implementation of the virtual method next_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Retrieves the result of a completed call to
	// g_socket_address_enumerator_next_async(). See
	// g_socket_address_enumerator_next() for more information about
	// error handling.
	NextFinish func(Instance, AsyncResult) (SocketAddress, error)
}

// UnsafeApplySocketAddressEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketAddressEnumeratorOverrides[Instance SocketAddressEnumerator](gclass unsafe.Pointer, overrides SocketAddressEnumeratorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketAddressEnumeratorClass)(gclass)

	if overrides.Next != nil {
		pclass.next = (*[0]byte)(C._goglib_gio2_SocketAddressEnumerator_next)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddressEnumerator_next",
			func(carg0 *C.GSocketAddressEnumerator, carg1 *C.GCancellable, _cerr **C.GError) (cret *C.GSocketAddress) {
				var enumerator  Instance      // go GSocketAddressEnumerator subclass
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       SocketAddress // return, full, converted, nullable
				var _goerr      error         // out, full, converted

				enumerator = UnsafeSocketAddressEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Next(enumerator, cancellable)

				if goret != nil {
					cret = (*C.GSocketAddress)(UnsafeSocketAddressToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.NextFinish != nil {
		pclass.next_finish = (*[0]byte)(C._goglib_gio2_SocketAddressEnumerator_next_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketAddressEnumerator_next_finish",
			func(carg0 *C.GSocketAddressEnumerator, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GSocketAddress) {
				var enumerator Instance      // go GSocketAddressEnumerator subclass
				var result     AsyncResult   // in, none, converted
				var goret      SocketAddress // return, full, converted, nullable
				var _goerr     error         // out, full, converted

				enumerator = UnsafeSocketAddressEnumeratorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.NextFinish(enumerator, result)

				if goret != nil {
					cret = (*C.GSocketAddress)(UnsafeSocketAddressToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentNext calls the default implementations of the `GSocketAddressEnumerator.next` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
// 	- _goerr error (nullable): an error 
//
// Retrieves the next #GSocketAddress from @enumerator. Note that this
// may block for some amount of time. (Eg, a #GNetworkAddress may need
// to do a DNS lookup before it can return an address.) Use
// g_socket_address_enumerator_next_async() if you need to avoid
// blocking.
// 
// If @enumerator is expected to yield addresses, but for some reason
// is unable to (eg, because of a DNS error), then the first call to
// g_socket_address_enumerator_next() will return an appropriate error
// in `*error`. However, if the first call to
// g_socket_address_enumerator_next() succeeds, then any further
// internal errors (other than @cancellable being triggered) will be
// ignored.
func (enumerator *SocketAddressEnumeratorInstance) ParentNext(cancellable Cancellable) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator
	var carg1 *C.GCancellable   // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted, nullable
	var _cerr *C.GError         // out, full, converted, nullable

	parentclass := (*C.GSocketAddressEnumeratorClass)(classdata.PeekParentClass(UnsafeSocketAddressEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_SocketAddressEnumerator_virtual_next(unsafe.Pointer(parentclass.next), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(cancellable)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentNextFinish calls the default implementations of the `GSocketAddressEnumerator.next_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
// 	- _goerr error (nullable): an error 
//
// Retrieves the result of a completed call to
// g_socket_address_enumerator_next_async(). See
// g_socket_address_enumerator_next() for more information about
// error handling.
func (enumerator *SocketAddressEnumeratorInstance) ParentNextFinish(result AsyncResult) (SocketAddress, error) {
	var carg0 *C.GSocketAddressEnumerator
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  *C.GSocketAddress // return, full, converted, nullable
	var _cerr *C.GError         // out, full, converted, nullable

	parentclass := (*C.GSocketAddressEnumeratorClass)(classdata.PeekParentClass(UnsafeSocketAddressEnumeratorToGlibNone(enumerator)))

	carg0 = (*C.GSocketAddressEnumerator)(UnsafeSocketAddressEnumeratorToGlibNone(enumerator))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_SocketAddressEnumerator_virtual_next_finish(unsafe.Pointer(parentclass.next_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(enumerator)
	runtime.KeepAlive(result)

	var goret  SocketAddress
	var _goerr error

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterSocketAddressEnumeratorSubClass is used to register a go subclass of GSocketAddressEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketAddressEnumeratorSubClass[InstanceT SocketAddressEnumerator](
		name string,
		classInit func(class *SocketAddressEnumeratorClass),
		constructor func() InstanceT,
		overrides SocketAddressEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketAddressEnumerator,
		UnsafeSocketAddressEnumeratorClassFromGlibBorrow,
		UnsafeApplySocketAddressEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketAddressEnumerator(obj)
		},
		interfaceInits...,
	)
}

// SocketClientInstance is the instance type used by all types extending GSocketClient. It is used internally by the bindings. Users should use the interface [SocketClient] instead.
type SocketClientInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketClient = (*SocketClientInstance)(nil)

// SocketClient wraps GSocketClient
//
// `GSocketClient` is a lightweight high-level utility class for connecting to
// a network host using a connection oriented socket type.
// 
// You create a `GSocketClient` object, set any options you want, and then
// call a sync or async connect operation, which returns a
// [class@Gio.SocketConnection] subclass on success.
// 
// The type of the [class@Gio.SocketConnection] object returned depends on the
// type of the underlying socket that is in use. For instance, for a TCP/IP
// connection it will be a [class@Gio.TcpConnection].
// 
// As `GSocketClient` is a lightweight object, you don't need to cache it. You
// can just create a new one any time you need one.
type SocketClient interface {
	gobject.Object
	upcastToGSocketClient() *SocketClientInstance

	// AddApplicationProxy wraps g_socket_client_add_application_proxy
	// 
	// The function takes the following parameters:
	// 
	// 	- protocol string: The proxy protocol 
	//
	// Enable proxy protocols to be handled by the application. When the
	// indicated proxy protocol is returned by the #GProxyResolver,
	// #GSocketClient will consider this protocol as supported but will
	// not try to find a #GProxy instance to handle handshaking. The
	// application must check for this case by calling
	// g_socket_connection_get_remote_address() on the returned
	// #GSocketConnection, and seeing if it's a #GProxyAddress of the
	// appropriate type, to determine whether or not it needs to handle
	// the proxy handshaking itself.
	// 
	// This should be used for proxy protocols that are dialects of
	// another protocol such as HTTP proxy. It also allows cohabitation of
	// proxy protocols that are reused between protocols. A good example
	// is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
	// be use as generic socket proxy through the HTTP CONNECT method.
	// 
	// When the proxy is detected as being an application proxy, TLS handshake
	// will be skipped. This is required to let the application do the proxy
	// specific handshake.
	AddApplicationProxy(string)
	// ConnectSocketClient wraps g_socket_client_connect
	// 
	// The function takes the following parameters:
	// 
	// 	- connectable SocketConnectable: a #GSocketConnectable specifying the remote address. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to resolve the @connectable and make a network connection to it.
	// 
	// Upon a successful connection, a new #GSocketConnection is constructed
	// and returned.  The caller owns this new object and must drop their
	// reference to it when finished with it.
	// 
	// The type of the #GSocketConnection object returned depends on the type of
	// the underlying socket that is used. For instance, for a TCP/IP connection
	// it will be a #GTcpConnection.
	// 
	// The socket created will be the same family as the address that the
	// @connectable resolves to, unless family is set with g_socket_client_set_family()
	// or indirectly via g_socket_client_set_local_address(). The socket type
	// defaults to %G_SOCKET_TYPE_STREAM but can be set with
	// g_socket_client_set_socket_type().
	// 
	// If a local address is specified with g_socket_client_set_local_address() the
	// socket will be bound to this address before connecting.
	ConnectSocketClient(SocketConnectable, Cancellable) (SocketConnection, error)
	// ConnectAsync wraps g_socket_client_connect_async
	// 
	// The function takes the following parameters:
	// 
	// 	- connectable SocketConnectable: a #GSocketConnectable specifying the remote address. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of g_socket_client_connect().
	// 
	// You may wish to prefer the asynchronous version even in synchronous
	// command line programs because, since 2.60, it implements
	// [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
	// recommendations to work around long connection timeouts in networks
	// where IPv6 is broken by performing an IPv4 connection simultaneously
	// without waiting for IPv6 to time out, which is not supported by the
	// synchronous call. (This is not an API guarantee, and may change in
	// the future.)
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_socket_client_connect_finish() to get
	// the result of the operation.
	ConnectAsync(SocketConnectable, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_socket_client_connect_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async connect operation. See g_socket_client_connect_async()
	ConnectFinish(AsyncResult) (SocketConnection, error)
	// ConnectToHost wraps g_socket_client_connect_to_host
	// 
	// The function takes the following parameters:
	// 
	// 	- hostAndPort string: the name and optionally port of the host to connect to 
	// 	- defaultPort uint16: the default port to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// This is a helper function for g_socket_client_connect().
	// 
	// Attempts to create a TCP connection to the named host.
	// 
	// @host_and_port may be in any of a number of recognized formats; an IPv6
	// address, an IPv4 address, or a domain name (in which case a DNS
	// lookup is performed).  Quoting with [] is supported for all address
	// types.  A port override may be specified in the usual way with a
	// colon.  Ports may be given as decimal numbers or symbolic names (in
	// which case an /etc/services lookup is performed).
	// 
	// If no port override is given in @host_and_port then @default_port will be
	// used as the port number to connect to.
	// 
	// In general, @host_and_port is expected to be provided by the user (allowing
	// them to give the hostname, and a port override if necessary) and
	// @default_port is expected to be provided by the application.
	// 
	// In the case that an IP address is given, a single connection
	// attempt is made.  In the case that a name is given, multiple
	// connection attempts may be made, in turn and according to the
	// number of address records in DNS, until a connection succeeds.
	// 
	// Upon a successful connection, a new #GSocketConnection is constructed
	// and returned.  The caller owns this new object and must drop their
	// reference to it when finished with it.
	// 
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) %NULL is returned and @error (if non-%NULL) is set
	// accordingly.
	ConnectToHost(string, uint16, Cancellable) (SocketConnection, error)
	// ConnectToHostAsync wraps g_socket_client_connect_to_host_async
	// 
	// The function takes the following parameters:
	// 
	// 	- hostAndPort string: the name and optionally the port of the host to connect to 
	// 	- defaultPort uint16: the default port to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of g_socket_client_connect_to_host().
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_socket_client_connect_to_host_finish() to get
	// the result of the operation.
	ConnectToHostAsync(string, uint16, Cancellable, AsyncReadyCallback)
	// ConnectToHostFinish wraps g_socket_client_connect_to_host_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async connect operation. See g_socket_client_connect_to_host_async()
	ConnectToHostFinish(AsyncResult) (SocketConnection, error)
	// ConnectToService wraps g_socket_client_connect_to_service
	// 
	// The function takes the following parameters:
	// 
	// 	- domain string: a domain name 
	// 	- service string: the name of the service to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts to create a TCP connection to a service.
	// 
	// This call looks up the SRV record for @service at @domain for the
	// "tcp" protocol.  It then attempts to connect, in turn, to each of
	// the hosts providing the service until either a connection succeeds
	// or there are no hosts remaining.
	// 
	// Upon a successful connection, a new #GSocketConnection is constructed
	// and returned.  The caller owns this new object and must drop their
	// reference to it when finished with it.
	// 
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) %NULL is returned and @error (if non-%NULL) is set
	// accordingly.
	ConnectToService(string, string, Cancellable) (SocketConnection, error)
	// ConnectToServiceAsync wraps g_socket_client_connect_to_service_async
	// 
	// The function takes the following parameters:
	// 
	// 	- domain string: a domain name 
	// 	- service string: the name of the service to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of
	// g_socket_client_connect_to_service().
	ConnectToServiceAsync(string, string, Cancellable, AsyncReadyCallback)
	// ConnectToServiceFinish wraps g_socket_client_connect_to_service_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async connect operation. See g_socket_client_connect_to_service_async()
	ConnectToServiceFinish(AsyncResult) (SocketConnection, error)
	// ConnectToURI wraps g_socket_client_connect_to_uri
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: A network URI 
	// 	- defaultPort uint16: the default port to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// This is a helper function for g_socket_client_connect().
	// 
	// Attempts to create a TCP connection with a network URI.
	// 
	// @uri may be any valid URI containing an "authority" (hostname/port)
	// component. If a port is not specified in the URI, @default_port
	// will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
	// (#GSocketClient does not know to automatically assume TLS for
	// certain URI schemes.)
	// 
	// Using this rather than g_socket_client_connect() or
	// g_socket_client_connect_to_host() allows #GSocketClient to
	// determine when to use application-specific proxy protocols.
	// 
	// Upon a successful connection, a new #GSocketConnection is constructed
	// and returned.  The caller owns this new object and must drop their
	// reference to it when finished with it.
	// 
	// In the event of any failure (DNS error, service not found, no hosts
	// connectable) %NULL is returned and @error (if non-%NULL) is set
	// accordingly.
	ConnectToURI(string, uint16, Cancellable) (SocketConnection, error)
	// ConnectToURIAsync wraps g_socket_client_connect_to_uri_async
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a network uri 
	// 	- defaultPort uint16: the default port to connect to 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of g_socket_client_connect_to_uri().
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_socket_client_connect_to_uri_finish() to get
	// the result of the operation.
	ConnectToURIAsync(string, uint16, Cancellable, AsyncReadyCallback)
	// ConnectToURIFinish wraps g_socket_client_connect_to_uri_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
	ConnectToURIFinish(AsyncResult) (SocketConnection, error)
	// GetEnableProxy wraps g_socket_client_get_enable_proxy
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the proxy enable state; see g_socket_client_set_enable_proxy()
	GetEnableProxy() bool
	// GetFamily wraps g_socket_client_get_family
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketFamily 
	//
	// Gets the socket family of the socket client.
	// 
	// See g_socket_client_set_family() for details.
	GetFamily() SocketFamily
	// GetLocalAddress wraps g_socket_client_get_local_address
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress (nullable) 
	//
	// Gets the local address of the socket client.
	// 
	// See g_socket_client_set_local_address() for details.
	GetLocalAddress() SocketAddress
	// GetProtocol wraps g_socket_client_get_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketProtocol 
	//
	// Gets the protocol name type of the socket client.
	// 
	// See g_socket_client_set_protocol() for details.
	GetProtocol() SocketProtocol
	// GetProxyResolver wraps g_socket_client_get_proxy_resolver
	// 
	// The function returns the following values:
	// 
	// 	- goret ProxyResolver 
	//
	// Gets the #GProxyResolver being used by @client. Normally, this will
	// be the resolver returned by g_proxy_resolver_get_default(), but you
	// can override it with g_socket_client_set_proxy_resolver().
	GetProxyResolver() ProxyResolver
	// GetSocketType wraps g_socket_client_get_socket_type
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketType 
	//
	// Gets the socket type of the socket client.
	// 
	// See g_socket_client_set_socket_type() for details.
	GetSocketType() SocketType
	// GetTimeout wraps g_socket_client_get_timeout
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the I/O timeout time for sockets created by @client.
	// 
	// See g_socket_client_set_timeout() for details.
	GetTimeout() uint
	// GetTls wraps g_socket_client_get_tls
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets whether @client creates TLS connections. See
	// g_socket_client_set_tls() for details.
	GetTls() bool
	// GetTlsValidationFlags wraps g_socket_client_get_tls_validation_flags
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// Gets the TLS validation flags used creating TLS connections via
	// @client.
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GSocketClient:tls-validation-flags for more
	// information.
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	GetTlsValidationFlags() TlsCertificateFlags
	// SetEnableProxy wraps g_socket_client_set_enable_proxy
	// 
	// The function takes the following parameters:
	// 
	// 	- enable bool: whether to enable proxies 
	//
	// Sets whether or not @client attempts to make connections via a
	// proxy server. When enabled (the default), #GSocketClient will use a
	// #GProxyResolver to determine if a proxy protocol such as SOCKS is
	// needed, and automatically do the necessary proxy negotiation.
	// 
	// See also g_socket_client_set_proxy_resolver().
	SetEnableProxy(bool)
	// SetFamily wraps g_socket_client_set_family
	// 
	// The function takes the following parameters:
	// 
	// 	- family SocketFamily: a #GSocketFamily 
	//
	// Sets the socket family of the socket client.
	// If this is set to something other than %G_SOCKET_FAMILY_INVALID
	// then the sockets created by this object will be of the specified
	// family.
	// 
	// This might be useful for instance if you want to force the local
	// connection to be an ipv4 socket, even though the address might
	// be an ipv6 mapped to ipv4 address.
	SetFamily(SocketFamily)
	// SetLocalAddress wraps g_socket_client_set_local_address
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
	//
	// Sets the local address of the socket client.
	// The sockets created by this object will bound to the
	// specified address (if not %NULL) before connecting.
	// 
	// This is useful if you want to ensure that the local
	// side of the connection is on a specific port, or on
	// a specific interface.
	SetLocalAddress(SocketAddress)
	// SetProtocol wraps g_socket_client_set_protocol
	// 
	// The function takes the following parameters:
	// 
	// 	- protocol SocketProtocol: a #GSocketProtocol 
	//
	// Sets the protocol of the socket client.
	// The sockets created by this object will use of the specified
	// protocol.
	// 
	// If @protocol is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
	// protocol for the socket family and type.
	SetProtocol(SocketProtocol)
	// SetProxyResolver wraps g_socket_client_set_proxy_resolver
	// 
	// The function takes the following parameters:
	// 
	// 	- proxyResolver ProxyResolver (nullable): a #GProxyResolver, or %NULL for the
	//   default. 
	//
	// Overrides the #GProxyResolver used by @client. You can call this if
	// you want to use specific proxies, rather than using the system
	// default proxy settings.
	// 
	// Note that whether or not the proxy resolver is actually used
	// depends on the setting of #GSocketClient:enable-proxy, which is not
	// changed by this function (but which is %TRUE by default)
	SetProxyResolver(ProxyResolver)
	// SetSocketType wraps g_socket_client_set_socket_type
	// 
	// The function takes the following parameters:
	// 
	// 	- typ SocketType: a #GSocketType 
	//
	// Sets the socket type of the socket client.
	// The sockets created by this object will be of the specified
	// type.
	// 
	// It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
	// as GSocketClient is used for connection oriented services.
	SetSocketType(SocketType)
	// SetTimeout wraps g_socket_client_set_timeout
	// 
	// The function takes the following parameters:
	// 
	// 	- timeout uint: the timeout 
	//
	// Sets the I/O timeout for sockets created by @client. @timeout is a
	// time in seconds, or 0 for no timeout (the default).
	// 
	// The timeout value affects the initial connection attempt as well,
	// so setting this may cause calls to g_socket_client_connect(), etc,
	// to fail with %G_IO_ERROR_TIMED_OUT.
	SetTimeout(uint)
	// SetTls wraps g_socket_client_set_tls
	// 
	// The function takes the following parameters:
	// 
	// 	- tls bool: whether to use TLS 
	//
	// Sets whether @client creates TLS (aka SSL) connections. If @tls is
	// %TRUE, @client will wrap its connections in a #GTlsClientConnection
	// and perform a TLS handshake when connecting.
	// 
	// Note that since #GSocketClient must return a #GSocketConnection,
	// but #GTlsClientConnection is not a #GSocketConnection, this
	// actually wraps the resulting #GTlsClientConnection in a
	// #GTcpWrapperConnection when returning it. You can use
	// g_tcp_wrapper_connection_get_base_io_stream() on the return value
	// to extract the #GTlsClientConnection.
	// 
	// If you need to modify the behavior of the TLS handshake (eg, by
	// setting a client-side certificate to use, or connecting to the
	// #GTlsConnection::accept-certificate signal), you can connect to
	// @client's #GSocketClient::event signal and wait for it to be
	// emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
	// a chance to see the #GTlsClientConnection before the handshake
	// starts.
	SetTls(bool)
	// SetTlsValidationFlags wraps g_socket_client_set_tls_validation_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- flags TlsCertificateFlags: the validation flags 
	//
	// Sets the TLS validation flags used when creating TLS connections
	// via @client. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
	// 
	// This function does not work as originally designed and is impossible
	// to use correctly. See #GSocketClient:tls-validation-flags for more
	// information.
	//
	// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
	SetTlsValidationFlags(TlsCertificateFlags)
	// ConnectEvent connects the provided callback to the "event" signal
	//
	// Emitted when @client's activity on @connectable changes state.
	// Among other things, this can be used to provide progress
	// information about a network connection in the UI. The meanings of
	// the different @event values are as follows:
	// 
	// - %G_SOCKET_CLIENT_RESOLVING: @client is about to look up @connectable
	//   in DNS. @connection will be %NULL.
	// 
	// - %G_SOCKET_CLIENT_RESOLVED:  @client has successfully resolved
	//   @connectable in DNS. @connection will be %NULL.
	// 
	// - %G_SOCKET_CLIENT_CONNECTING: @client is about to make a connection
	//   to a remote host; either a proxy server or the destination server
	//   itself. @connection is the #GSocketConnection, which is not yet
	//   connected.  Since GLib 2.40, you can access the remote
	//   address via g_socket_connection_get_remote_address().
	// 
	// - %G_SOCKET_CLIENT_CONNECTED: @client has successfully connected
	//   to a remote host. @connection is the connected #GSocketConnection.
	// 
	// - %G_SOCKET_CLIENT_PROXY_NEGOTIATING: @client is about to negotiate
	//   with a proxy to get it to connect to @connectable. @connection is
	//   the #GSocketConnection to the proxy server.
	// 
	// - %G_SOCKET_CLIENT_PROXY_NEGOTIATED: @client has negotiated a
	//   connection to @connectable through a proxy server. @connection is
	//   the stream returned from g_proxy_connect(), which may or may not
	//   be a #GSocketConnection.
	// 
	// - %G_SOCKET_CLIENT_TLS_HANDSHAKING: @client is about to begin a TLS
	//   handshake. @connection is a #GTlsClientConnection.
	// 
	// - %G_SOCKET_CLIENT_TLS_HANDSHAKED: @client has successfully completed
	//   the TLS handshake. @connection is a #GTlsClientConnection.
	// 
	// - %G_SOCKET_CLIENT_COMPLETE: @client has either successfully connected
	//   to @connectable (in which case @connection is the #GSocketConnection
	//   that it will be returning to the caller) or has failed (in which
	//   case @connection is %NULL and the client is about to return an error).
	// 
	// Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted
	// multiple times (or not at all) for a given connectable (in
	// particular, if @client ends up attempting to connect to more than
	// one address). However, if @client emits the #GSocketClient::event
	// signal at all for a given connectable, then it will always emit
	// it with %G_SOCKET_CLIENT_COMPLETE when it is done.
	// 
	// Note that there may be additional #GSocketClientEvent values in
	// the future; unrecognized @event values should be ignored.
	ConnectEvent(func(SocketClient, SocketClientEvent, SocketConnectable, IOStream)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentEvent calls the default implementations of the `GSocketClient.event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- event SocketClientEvent 
	// 	- connectable SocketConnectable 
	// 	- connection IOStream 
	ParentEvent(event SocketClientEvent, connectable SocketConnectable, connection IOStream)
}

func unsafeWrapSocketClient(base *gobject.ObjectInstance) *SocketClientInstance {
	return &SocketClientInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketClient,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketClient(inst)
		},
	)
}

func marshalSocketClientInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketClientFromGlibNone is used to convert raw GSocketClient pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketClientFromGlibNone(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketClient)
}

// UnsafeSocketClientFromGlibFull is used to convert raw GSocketClient pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketClientFromGlibFull(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketClient)
}

// UnsafeSocketClientFromGlibBorrow is used to convert raw GSocketClient pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketClientFromGlibBorrow(c unsafe.Pointer) SocketClient {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketClient)
}

func (s *SocketClientInstance) upcastToGSocketClient() *SocketClientInstance {
	return s
}

// UnsafeSocketClientToGlibNone is used to convert the instance to it's C value GSocketClient. This is used by the bindings internally.
func UnsafeSocketClientToGlibNone(c SocketClient) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketClientToGlibFull is used to convert the instance to it's C value GSocketClient, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketClientToGlibFull(c SocketClient) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketClient wraps g_socket_client_new
// 
// The function returns the following values:
// 
// 	- goret SocketClient 
//
// Creates a new #GSocketClient with the default options.
func NewSocketClient() SocketClient {
	var cret *C.GSocketClient // return, full, converted

	cret = C.g_socket_client_new()

	var goret SocketClient

	goret = UnsafeSocketClientFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AddApplicationProxy wraps g_socket_client_add_application_proxy
// 
// The function takes the following parameters:
// 
// 	- protocol string: The proxy protocol 
//
// Enable proxy protocols to be handled by the application. When the
// indicated proxy protocol is returned by the #GProxyResolver,
// #GSocketClient will consider this protocol as supported but will
// not try to find a #GProxy instance to handle handshaking. The
// application must check for this case by calling
// g_socket_connection_get_remote_address() on the returned
// #GSocketConnection, and seeing if it's a #GProxyAddress of the
// appropriate type, to determine whether or not it needs to handle
// the proxy handshaking itself.
// 
// This should be used for proxy protocols that are dialects of
// another protocol such as HTTP proxy. It also allows cohabitation of
// proxy protocols that are reused between protocols. A good example
// is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
// be use as generic socket proxy through the HTTP CONNECT method.
// 
// When the proxy is detected as being an application proxy, TLS handshake
// will be skipped. This is required to let the application do the proxy
// specific handshake.
func (client *SocketClientInstance) AddApplicationProxy(protocol string) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 *C.gchar         // in, none, string

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_socket_client_add_application_proxy(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// ConnectSocketClient wraps g_socket_client_connect
// 
// The function takes the following parameters:
// 
// 	- connectable SocketConnectable: a #GSocketConnectable specifying the remote address. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Tries to resolve the @connectable and make a network connection to it.
// 
// Upon a successful connection, a new #GSocketConnection is constructed
// and returned.  The caller owns this new object and must drop their
// reference to it when finished with it.
// 
// The type of the #GSocketConnection object returned depends on the type of
// the underlying socket that is used. For instance, for a TCP/IP connection
// it will be a #GTcpConnection.
// 
// The socket created will be the same family as the address that the
// @connectable resolves to, unless family is set with g_socket_client_set_family()
// or indirectly via g_socket_client_set_local_address(). The socket type
// defaults to %G_SOCKET_TYPE_STREAM but can be set with
// g_socket_client_set_socket_type().
// 
// If a local address is specified with g_socket_client_set_local_address() the
// socket will be bound to this address before connecting.
func (client *SocketClientInstance) ConnectSocketClient(connectable SocketConnectable, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var cret  *C.GSocketConnection  // return, full, converted
	var _cerr *C.GError             // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_socket_client_connect_async
// 
// The function takes the following parameters:
// 
// 	- connectable SocketConnectable: a #GSocketConnectable specifying the remote address. 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of g_socket_client_connect().
// 
// You may wish to prefer the asynchronous version even in synchronous
// command line programs because, since 2.60, it implements
// [RFC 8305](https://tools.ietf.org/html/rfc8305) "Happy Eyeballs"
// recommendations to work around long connection timeouts in networks
// where IPv6 is broken by performing an IPv4 connection simultaneously
// without waiting for IPv6 to time out, which is not supported by the
// synchronous call. (This is not an API guarantee, and may change in
// the future.)
// 
// When the operation is finished @callback will be
// called. You can then call g_socket_client_connect_finish() to get
// the result of the operation.
func (client *SocketClientInstance) ConnectAsync(connectable SocketConnectable, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.GSocketConnectable // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(client)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_socket_client_connect_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Finishes an async connect operation. See g_socket_client_connect_async()
func (client *SocketClientInstance) ConnectFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToHost wraps g_socket_client_connect_to_host
// 
// The function takes the following parameters:
// 
// 	- hostAndPort string: the name and optionally port of the host to connect to 
// 	- defaultPort uint16: the default port to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// This is a helper function for g_socket_client_connect().
// 
// Attempts to create a TCP connection to the named host.
// 
// @host_and_port may be in any of a number of recognized formats; an IPv6
// address, an IPv4 address, or a domain name (in which case a DNS
// lookup is performed).  Quoting with [] is supported for all address
// types.  A port override may be specified in the usual way with a
// colon.  Ports may be given as decimal numbers or symbolic names (in
// which case an /etc/services lookup is performed).
// 
// If no port override is given in @host_and_port then @default_port will be
// used as the port number to connect to.
// 
// In general, @host_and_port is expected to be provided by the user (allowing
// them to give the hostname, and a port override if necessary) and
// @default_port is expected to be provided by the application.
// 
// In the case that an IP address is given, a single connection
// attempt is made.  In the case that a name is given, multiple
// connection attempts may be made, in turn and according to the
// number of address records in DNS, until a connection succeeds.
// 
// Upon a successful connection, a new #GSocketConnection is constructed
// and returned.  The caller owns this new object and must drop their
// reference to it when finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) %NULL is returned and @error (if non-%NULL) is set
// accordingly.
func (client *SocketClientInstance) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 C.guint16            // in, none, casted
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_host(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToHostAsync wraps g_socket_client_connect_to_host_async
// 
// The function takes the following parameters:
// 
// 	- hostAndPort string: the name and optionally the port of the host to connect to 
// 	- defaultPort uint16: the default port to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of g_socket_client_connect_to_host().
// 
// When the operation is finished @callback will be
// called. You can then call g_socket_client_connect_to_host_finish() to get
// the result of the operation.
func (client *SocketClientInstance) ConnectToHostAsync(hostAndPort string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostAndPort)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_host_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(hostAndPort)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToHostFinish wraps g_socket_client_connect_to_host_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Finishes an async connect operation. See g_socket_client_connect_to_host_async()
func (client *SocketClientInstance) ConnectToHostFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_host_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToService wraps g_socket_client_connect_to_service
// 
// The function takes the following parameters:
// 
// 	- domain string: a domain name 
// 	- service string: the name of the service to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Attempts to create a TCP connection to a service.
// 
// This call looks up the SRV record for @service at @domain for the
// "tcp" protocol.  It then attempts to connect, in turn, to each of
// the hosts providing the service until either a connection succeeds
// or there are no hosts remaining.
// 
// Upon a successful connection, a new #GSocketConnection is constructed
// and returned.  The caller owns this new object and must drop their
// reference to it when finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) %NULL is returned and @error (if non-%NULL) is set
// accordingly.
func (client *SocketClientInstance) ConnectToService(domain string, service string, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg2))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_service(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToServiceAsync wraps g_socket_client_connect_to_service_async
// 
// The function takes the following parameters:
// 
// 	- domain string: a domain name 
// 	- service string: the name of the service to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of
// g_socket_client_connect_to_service().
func (client *SocketClientInstance) ConnectToServiceAsync(domain string, service string, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 *C.gchar              // in, none, string
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(carg2))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_service_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(service)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToServiceFinish wraps g_socket_client_connect_to_service_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Finishes an async connect operation. See g_socket_client_connect_to_service_async()
func (client *SocketClientInstance) ConnectToServiceFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_service_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToURI wraps g_socket_client_connect_to_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: A network URI 
// 	- defaultPort uint16: the default port to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// This is a helper function for g_socket_client_connect().
// 
// Attempts to create a TCP connection with a network URI.
// 
// @uri may be any valid URI containing an "authority" (hostname/port)
// component. If a port is not specified in the URI, @default_port
// will be used. TLS will be negotiated if #GSocketClient:tls is %TRUE.
// (#GSocketClient does not know to automatically assume TLS for
// certain URI schemes.)
// 
// Using this rather than g_socket_client_connect() or
// g_socket_client_connect_to_host() allows #GSocketClient to
// determine when to use application-specific proxy protocols.
// 
// Upon a successful connection, a new #GSocketConnection is constructed
// and returned.  The caller owns this new object and must drop their
// reference to it when finished with it.
// 
// In the event of any failure (DNS error, service not found, no hosts
// connectable) %NULL is returned and @error (if non-%NULL) is set
// accordingly.
func (client *SocketClientInstance) ConnectToURI(uri string, defaultPort uint16, cancellable Cancellable) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.gchar             // in, none, string
	var carg2 C.guint16            // in, none, casted
	var carg3 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_client_connect_to_uri(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectToURIAsync wraps g_socket_client_connect_to_uri_async
// 
// The function takes the following parameters:
// 
// 	- uri string: a network uri 
// 	- defaultPort uint16: the default port to connect to 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of g_socket_client_connect_to_uri().
// 
// When the operation is finished @callback will be
// called. You can then call g_socket_client_connect_to_uri_finish() to get
// the result of the operation.
func (client *SocketClientInstance) ConnectToURIAsync(uri string, defaultPort uint16, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketClient      // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.guint16             // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(defaultPort)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_client_connect_to_uri_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectToURIFinish wraps g_socket_client_connect_to_uri_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Finishes an async connect operation. See g_socket_client_connect_to_uri_async()
func (client *SocketClientInstance) ConnectToURIFinish(result AsyncResult) (SocketConnection, error) {
	var carg0 *C.GSocketClient     // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_client_connect_to_uri_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var goret  SocketConnection
	var _goerr error

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetEnableProxy wraps g_socket_client_get_enable_proxy
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the proxy enable state; see g_socket_client_set_enable_proxy()
func (client *SocketClientInstance) GetEnableProxy() bool {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_enable_proxy(carg0)
	runtime.KeepAlive(client)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetFamily wraps g_socket_client_get_family
// 
// The function returns the following values:
// 
// 	- goret SocketFamily 
//
// Gets the socket family of the socket client.
// 
// See g_socket_client_set_family() for details.
func (client *SocketClientInstance) GetFamily() SocketFamily {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.GSocketFamily  // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_family(carg0)
	runtime.KeepAlive(client)

	var goret SocketFamily

	goret = SocketFamily(cret)

	return goret
}

// GetLocalAddress wraps g_socket_client_get_local_address
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
//
// Gets the local address of the socket client.
// 
// See g_socket_client_set_local_address() for details.
func (client *SocketClientInstance) GetLocalAddress() SocketAddress {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  *C.GSocketAddress // return, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_local_address(carg0)
	runtime.KeepAlive(client)

	var goret SocketAddress

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetProtocol wraps g_socket_client_get_protocol
// 
// The function returns the following values:
// 
// 	- goret SocketProtocol 
//
// Gets the protocol name type of the socket client.
// 
// See g_socket_client_set_protocol() for details.
func (client *SocketClientInstance) GetProtocol() SocketProtocol {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  C.GSocketProtocol // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_protocol(carg0)
	runtime.KeepAlive(client)

	var goret SocketProtocol

	goret = SocketProtocol(cret)

	return goret
}

// GetProxyResolver wraps g_socket_client_get_proxy_resolver
// 
// The function returns the following values:
// 
// 	- goret ProxyResolver 
//
// Gets the #GProxyResolver being used by @client. Normally, this will
// be the resolver returned by g_proxy_resolver_get_default(), but you
// can override it with g_socket_client_set_proxy_resolver().
func (client *SocketClientInstance) GetProxyResolver() ProxyResolver {
	var carg0 *C.GSocketClient  // in, none, converted
	var cret  *C.GProxyResolver // return, none, converted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_proxy_resolver(carg0)
	runtime.KeepAlive(client)

	var goret ProxyResolver

	goret = UnsafeProxyResolverFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetSocketType wraps g_socket_client_get_socket_type
// 
// The function returns the following values:
// 
// 	- goret SocketType 
//
// Gets the socket type of the socket client.
// 
// See g_socket_client_set_socket_type() for details.
func (client *SocketClientInstance) GetSocketType() SocketType {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.GSocketType    // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_socket_type(carg0)
	runtime.KeepAlive(client)

	var goret SocketType

	goret = SocketType(cret)

	return goret
}

// GetTimeout wraps g_socket_client_get_timeout
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the I/O timeout time for sockets created by @client.
// 
// See g_socket_client_set_timeout() for details.
func (client *SocketClientInstance) GetTimeout() uint {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.guint          // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_timeout(carg0)
	runtime.KeepAlive(client)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetTls wraps g_socket_client_get_tls
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets whether @client creates TLS connections. See
// g_socket_client_set_tls() for details.
func (client *SocketClientInstance) GetTls() bool {
	var carg0 *C.GSocketClient // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_tls(carg0)
	runtime.KeepAlive(client)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetTlsValidationFlags wraps g_socket_client_get_tls_validation_flags
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// Gets the TLS validation flags used creating TLS connections via
// @client.
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GSocketClient:tls-validation-flags for more
// information.
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (client *SocketClientInstance) GetTlsValidationFlags() TlsCertificateFlags {
	var carg0 *C.GSocketClient       // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))

	cret = C.g_socket_client_get_tls_validation_flags(carg0)
	runtime.KeepAlive(client)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// SetEnableProxy wraps g_socket_client_set_enable_proxy
// 
// The function takes the following parameters:
// 
// 	- enable bool: whether to enable proxies 
//
// Sets whether or not @client attempts to make connections via a
// proxy server. When enabled (the default), #GSocketClient will use a
// #GProxyResolver to determine if a proxy protocol such as SOCKS is
// needed, and automatically do the necessary proxy negotiation.
// 
// See also g_socket_client_set_proxy_resolver().
func (client *SocketClientInstance) SetEnableProxy(enable bool) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if enable {
		carg1 = C.TRUE
	}

	C.g_socket_client_set_enable_proxy(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(enable)
}

// SetFamily wraps g_socket_client_set_family
// 
// The function takes the following parameters:
// 
// 	- family SocketFamily: a #GSocketFamily 
//
// Sets the socket family of the socket client.
// If this is set to something other than %G_SOCKET_FAMILY_INVALID
// then the sockets created by this object will be of the specified
// family.
// 
// This might be useful for instance if you want to force the local
// connection to be an ipv4 socket, even though the address might
// be an ipv6 mapped to ipv4 address.
func (client *SocketClientInstance) SetFamily(family SocketFamily) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.GSocketFamily  // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketFamily(family)

	C.g_socket_client_set_family(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(family)
}

// SetLocalAddress wraps g_socket_client_set_local_address
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress (nullable): a #GSocketAddress, or %NULL 
//
// Sets the local address of the socket client.
// The sockets created by this object will bound to the
// specified address (if not %NULL) before connecting.
// 
// This is useful if you want to ensure that the local
// side of the connection is on a specific port, or on
// a specific interface.
func (client *SocketClientInstance) SetLocalAddress(address SocketAddress) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 *C.GSocketAddress // in, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if address != nil {
		carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	}

	C.g_socket_client_set_local_address(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(address)
}

// SetProtocol wraps g_socket_client_set_protocol
// 
// The function takes the following parameters:
// 
// 	- protocol SocketProtocol: a #GSocketProtocol 
//
// Sets the protocol of the socket client.
// The sockets created by this object will use of the specified
// protocol.
// 
// If @protocol is %G_SOCKET_PROTOCOL_DEFAULT that means to use the default
// protocol for the socket family and type.
func (client *SocketClientInstance) SetProtocol(protocol SocketProtocol) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 C.GSocketProtocol // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketProtocol(protocol)

	C.g_socket_client_set_protocol(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(protocol)
}

// SetProxyResolver wraps g_socket_client_set_proxy_resolver
// 
// The function takes the following parameters:
// 
// 	- proxyResolver ProxyResolver (nullable): a #GProxyResolver, or %NULL for the
//   default. 
//
// Overrides the #GProxyResolver used by @client. You can call this if
// you want to use specific proxies, rather than using the system
// default proxy settings.
// 
// Note that whether or not the proxy resolver is actually used
// depends on the setting of #GSocketClient:enable-proxy, which is not
// changed by this function (but which is %TRUE by default)
func (client *SocketClientInstance) SetProxyResolver(proxyResolver ProxyResolver) {
	var carg0 *C.GSocketClient  // in, none, converted
	var carg1 *C.GProxyResolver // in, none, converted, nullable

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if proxyResolver != nil {
		carg1 = (*C.GProxyResolver)(UnsafeProxyResolverToGlibNone(proxyResolver))
	}

	C.g_socket_client_set_proxy_resolver(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(proxyResolver)
}

// SetSocketType wraps g_socket_client_set_socket_type
// 
// The function takes the following parameters:
// 
// 	- typ SocketType: a #GSocketType 
//
// Sets the socket type of the socket client.
// The sockets created by this object will be of the specified
// type.
// 
// It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
// as GSocketClient is used for connection oriented services.
func (client *SocketClientInstance) SetSocketType(typ SocketType) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.GSocketType    // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketType(typ)

	C.g_socket_client_set_socket_type(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(typ)
}

// SetTimeout wraps g_socket_client_set_timeout
// 
// The function takes the following parameters:
// 
// 	- timeout uint: the timeout 
//
// Sets the I/O timeout for sockets created by @client. @timeout is a
// time in seconds, or 0 for no timeout (the default).
// 
// The timeout value affects the initial connection attempt as well,
// so setting this may cause calls to g_socket_client_connect(), etc,
// to fail with %G_IO_ERROR_TIMED_OUT.
func (client *SocketClientInstance) SetTimeout(timeout uint) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.guint          // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.guint(timeout)

	C.g_socket_client_set_timeout(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(timeout)
}

// SetTls wraps g_socket_client_set_tls
// 
// The function takes the following parameters:
// 
// 	- tls bool: whether to use TLS 
//
// Sets whether @client creates TLS (aka SSL) connections. If @tls is
// %TRUE, @client will wrap its connections in a #GTlsClientConnection
// and perform a TLS handshake when connecting.
// 
// Note that since #GSocketClient must return a #GSocketConnection,
// but #GTlsClientConnection is not a #GSocketConnection, this
// actually wraps the resulting #GTlsClientConnection in a
// #GTcpWrapperConnection when returning it. You can use
// g_tcp_wrapper_connection_get_base_io_stream() on the return value
// to extract the #GTlsClientConnection.
// 
// If you need to modify the behavior of the TLS handshake (eg, by
// setting a client-side certificate to use, or connecting to the
// #GTlsConnection::accept-certificate signal), you can connect to
// @client's #GSocketClient::event signal and wait for it to be
// emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you
// a chance to see the #GTlsClientConnection before the handshake
// starts.
func (client *SocketClientInstance) SetTls(tls bool) {
	var carg0 *C.GSocketClient // in, none, converted
	var carg1 C.gboolean       // in

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	if tls {
		carg1 = C.TRUE
	}

	C.g_socket_client_set_tls(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(tls)
}

// SetTlsValidationFlags wraps g_socket_client_set_tls_validation_flags
// 
// The function takes the following parameters:
// 
// 	- flags TlsCertificateFlags: the validation flags 
//
// Sets the TLS validation flags used when creating TLS connections
// via @client. The default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
// 
// This function does not work as originally designed and is impossible
// to use correctly. See #GSocketClient:tls-validation-flags for more
// information.
//
// Deprecated: (since 2.72.0) Do not attempt to ignore validation errors.
func (client *SocketClientInstance) SetTlsValidationFlags(flags TlsCertificateFlags) {
	var carg0 *C.GSocketClient       // in, none, converted
	var carg1 C.GTlsCertificateFlags // in, none, casted

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GTlsCertificateFlags(flags)

	C.g_socket_client_set_tls_validation_flags(carg0, carg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(flags)
}

// ConnectEvent connects the provided callback to the "event" signal
//
// Emitted when @client's activity on @connectable changes state.
// Among other things, this can be used to provide progress
// information about a network connection in the UI. The meanings of
// the different @event values are as follows:
// 
// - %G_SOCKET_CLIENT_RESOLVING: @client is about to look up @connectable
//   in DNS. @connection will be %NULL.
// 
// - %G_SOCKET_CLIENT_RESOLVED:  @client has successfully resolved
//   @connectable in DNS. @connection will be %NULL.
// 
// - %G_SOCKET_CLIENT_CONNECTING: @client is about to make a connection
//   to a remote host; either a proxy server or the destination server
//   itself. @connection is the #GSocketConnection, which is not yet
//   connected.  Since GLib 2.40, you can access the remote
//   address via g_socket_connection_get_remote_address().
// 
// - %G_SOCKET_CLIENT_CONNECTED: @client has successfully connected
//   to a remote host. @connection is the connected #GSocketConnection.
// 
// - %G_SOCKET_CLIENT_PROXY_NEGOTIATING: @client is about to negotiate
//   with a proxy to get it to connect to @connectable. @connection is
//   the #GSocketConnection to the proxy server.
// 
// - %G_SOCKET_CLIENT_PROXY_NEGOTIATED: @client has negotiated a
//   connection to @connectable through a proxy server. @connection is
//   the stream returned from g_proxy_connect(), which may or may not
//   be a #GSocketConnection.
// 
// - %G_SOCKET_CLIENT_TLS_HANDSHAKING: @client is about to begin a TLS
//   handshake. @connection is a #GTlsClientConnection.
// 
// - %G_SOCKET_CLIENT_TLS_HANDSHAKED: @client has successfully completed
//   the TLS handshake. @connection is a #GTlsClientConnection.
// 
// - %G_SOCKET_CLIENT_COMPLETE: @client has either successfully connected
//   to @connectable (in which case @connection is the #GSocketConnection
//   that it will be returning to the caller) or has failed (in which
//   case @connection is %NULL and the client is about to return an error).
// 
// Each event except %G_SOCKET_CLIENT_COMPLETE may be emitted
// multiple times (or not at all) for a given connectable (in
// particular, if @client ends up attempting to connect to more than
// one address). However, if @client emits the #GSocketClient::event
// signal at all for a given connectable, then it will always emit
// it with %G_SOCKET_CLIENT_COMPLETE when it is done.
// 
// Note that there may be additional #GSocketClientEvent values in
// the future; unrecognized @event values should be ignored.
func (o *SocketClientInstance) ConnectEvent(fn func(SocketClient, SocketClientEvent, SocketConnectable, IOStream)) gobject.SignalHandle {
	return o.Connect("event", fn)
}

// SocketClientOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketClientOverrides[Instance SocketClient] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Event allows you to override the implementation of the virtual method event.
	// 
	// The function takes the following parameters:
	// 
	// 	- event SocketClientEvent 
	// 	- connectable SocketConnectable 
	// 	- connection IOStream 
	Event func(Instance, SocketClientEvent, SocketConnectable, IOStream)
}

// UnsafeApplySocketClientOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketClientOverrides[Instance SocketClient](gclass unsafe.Pointer, overrides SocketClientOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketClientClass)(gclass)

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._goglib_gio2_SocketClient_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketClient_event",
			func(carg0 *C.GSocketClient, carg1 C.GSocketClientEvent, carg2 *C.GSocketConnectable, carg3 *C.GIOStream) {
				var client      Instance          // go GSocketClient subclass
				var event       SocketClientEvent // in, none, casted
				var connectable SocketConnectable // in, none, converted
				var connection  IOStream          // in, none, converted

				client = UnsafeSocketClientFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				event = SocketClientEvent(carg1)
				connectable = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg2))
				connection = UnsafeIOStreamFromGlibNone(unsafe.Pointer(carg3))

				overrides.Event(client, event, connectable, connection)
			},
		)
	}
}

// ParentEvent calls the default implementations of the `GSocketClient.event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- event SocketClientEvent 
// 	- connectable SocketConnectable 
// 	- connection IOStream 
func (client *SocketClientInstance) ParentEvent(event SocketClientEvent, connectable SocketConnectable, connection IOStream) {
	var carg0 *C.GSocketClient
	var carg1 C.GSocketClientEvent  // in, none, converted
	var carg2 *C.GSocketConnectable // in, none, casted
	var carg3 *C.GIOStream          // in, none, converted

	parentclass := (*C.GSocketClientClass)(classdata.PeekParentClass(UnsafeSocketClientToGlibNone(client)))

	carg0 = (*C.GSocketClient)(UnsafeSocketClientToGlibNone(client))
	carg1 = C.GSocketClientEvent(event)
	carg2 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(connectable))
	carg3 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(connection))

	C._goglib_gio2_SocketClient_virtual_event(unsafe.Pointer(parentclass.event), carg0, carg1, carg2, carg3)
	runtime.KeepAlive(client)
	runtime.KeepAlive(event)
	runtime.KeepAlive(connectable)
	runtime.KeepAlive(connection)
}

// RegisterSocketClientSubClass is used to register a go subclass of GSocketClient. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketClientSubClass[InstanceT SocketClient](
		name string,
		classInit func(class *SocketClientClass),
		constructor func() InstanceT,
		overrides SocketClientOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketClient,
		UnsafeSocketClientClassFromGlibBorrow,
		UnsafeApplySocketClientOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketClient(obj)
		},
		interfaceInits...,
	)
}

// SocketConnectionInstance is the instance type used by all types extending GSocketConnection. It is used internally by the bindings. Users should use the interface [SocketConnection] instead.
type SocketConnectionInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ SocketConnection = (*SocketConnectionInstance)(nil)

// SocketConnection wraps GSocketConnection
//
// `GSocketConnection` is a [class@Gio.IOStream] for a connected socket. They
// can be created either by [class@Gio.SocketClient] when connecting to a host,
// or by [class@Gio.SocketListener] when accepting a new client.
// 
// The type of the `GSocketConnection` object returned from these calls
// depends on the type of the underlying socket that is in use. For
// instance, for a TCP/IP connection it will be a [class@Gio.TcpConnection].
// 
// Choosing what type of object to construct is done with the socket
// connection factory, and it is possible for third parties to register
// custom socket connection types for specific combination of socket
// family/type/protocol using [func@Gio.SocketConnection.factory_register_type].
// 
// To close a `GSocketConnection`, use [method@Gio.IOStream.close]. Closing both
// substreams of the [class@Gio.IOStream] separately will not close the
// underlying [class@Gio.Socket].
type SocketConnection interface {
	IOStream
	upcastToGSocketConnection() *SocketConnectionInstance

	// ConnectSocketConnection wraps g_socket_connection_connect
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Connect @connection to the specified remote address.
	ConnectSocketConnection(SocketAddress, Cancellable) (bool, error)
	// ConnectAsync wraps g_socket_connection_connect_async
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
	// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// Asynchronously connect @connection to the specified remote address.
	// 
	// This clears the #GSocket:blocking flag on @connection's underlying
	// socket if it is currently set.
	// 
	// If #GSocket:timeout is set, the operation will time out and return
	// %G_IO_ERROR_TIMED_OUT after that period. Otherwise, it will continue
	// indefinitely until operating system timeouts (if any) are hit.
	// 
	// Use g_socket_connection_connect_finish() to retrieve the result.
	ConnectAsync(SocketAddress, Cancellable, AsyncReadyCallback)
	// ConnectFinish wraps g_socket_connection_connect_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the result of a g_socket_connection_connect_async() call.
	ConnectFinish(AsyncResult) (bool, error)
	// GetLocalAddress wraps g_socket_connection_get_local_address
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Try to get the local address of a socket connection.
	GetLocalAddress() (SocketAddress, error)
	// GetRemoteAddress wraps g_socket_connection_get_remote_address
	// 
	// The function returns the following values:
	// 
	// 	- goret SocketAddress 
	// 	- _goerr error (nullable): an error 
	//
	// Try to get the remote address of a socket connection.
	// 
	// Since GLib 2.40, when used with g_socket_client_connect() or
	// g_socket_client_connect_async(), during emission of
	// %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
	// address that will be used for the connection.  This allows
	// applications to print e.g. "Connecting to example.com
	// (10.42.77.3)...".
	GetRemoteAddress() (SocketAddress, error)
	// GetSocket wraps g_socket_connection_get_socket
	// 
	// The function returns the following values:
	// 
	// 	- goret Socket 
	//
	// Gets the underlying #GSocket object of the connection.
	// This can be useful if you want to do something unusual on it
	// not supported by the #GSocketConnection APIs.
	GetSocket() Socket
	// IsConnected wraps g_socket_connection_is_connected
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @connection is connected. This is equivalent to calling
	// g_socket_is_connected() on @connection's underlying #GSocket.
	IsConnected() bool

	// chain up virtual methods:
}

func unsafeWrapSocketConnection(base *gobject.ObjectInstance) *SocketConnectionInstance {
	return &SocketConnectionInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketConnection(inst)
		},
	)
}

func marshalSocketConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketConnectionFromGlibNone is used to convert raw GSocketConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibNone(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketConnection)
}

// UnsafeSocketConnectionFromGlibFull is used to convert raw GSocketConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibFull(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketConnection)
}

// UnsafeSocketConnectionFromGlibBorrow is used to convert raw GSocketConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketConnectionFromGlibBorrow(c unsafe.Pointer) SocketConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketConnection)
}

func (s *SocketConnectionInstance) upcastToGSocketConnection() *SocketConnectionInstance {
	return s
}

// UnsafeSocketConnectionToGlibNone is used to convert the instance to it's C value GSocketConnection. This is used by the bindings internally.
func UnsafeSocketConnectionToGlibNone(c SocketConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketConnectionToGlibFull is used to convert the instance to it's C value GSocketConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketConnectionToGlibFull(c SocketConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// SocketConnectionFactoryLookupType wraps g_socket_connection_factory_lookup_type
// 
// The function takes the following parameters:
// 
// 	- family SocketFamily: a #GSocketFamily 
// 	- typ SocketType: a #GSocketType 
// 	- protocolId int32: a protocol id 
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Looks up the #GType to be used when creating socket connections on
// sockets with the specified @family, @type and @protocol_id.
// 
// If no type is registered, the #GSocketConnection base type is returned.
func SocketConnectionFactoryLookupType(family SocketFamily, typ SocketType, protocolId int32) gobject.Type {
	var carg1 C.GSocketFamily // in, none, casted
	var carg2 C.GSocketType   // in, none, casted
	var carg3 C.gint          // in, none, casted
	var cret  C.GType         // return, none, casted, alias

	carg1 = C.GSocketFamily(family)
	carg2 = C.GSocketType(typ)
	carg3 = C.gint(protocolId)

	cret = C.g_socket_connection_factory_lookup_type(carg1, carg2, carg3)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocolId)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SocketConnectionFactoryRegisterType wraps g_socket_connection_factory_register_type
// 
// The function takes the following parameters:
// 
// 	- gType gobject.Type: a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION 
// 	- family SocketFamily: a #GSocketFamily 
// 	- typ SocketType: a #GSocketType 
// 	- protocol int32: a protocol id 
//
// Looks up the #GType to be used when creating socket connections on
// sockets with the specified @family, @type and @protocol.
// 
// If no type is registered, the #GSocketConnection base type is returned.
func SocketConnectionFactoryRegisterType(gType gobject.Type, family SocketFamily, typ SocketType, protocol int32) {
	var carg1 C.GType         // in, none, casted, alias
	var carg2 C.GSocketFamily // in, none, casted
	var carg3 C.GSocketType   // in, none, casted
	var carg4 C.gint          // in, none, casted

	carg1 = C.GType(gType)
	carg2 = C.GSocketFamily(family)
	carg3 = C.GSocketType(typ)
	carg4 = C.gint(protocol)

	C.g_socket_connection_factory_register_type(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(gType)
	runtime.KeepAlive(family)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
}

// ConnectSocketConnection wraps g_socket_connection_connect
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Connect @connection to the specified remote address.
func (connection *SocketConnectionInstance) ConnectSocketConnection(address SocketAddress, cancellable Cancellable) (bool, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var carg1 *C.GSocketAddress    // in, none, converted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_connection_connect(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ConnectAsync wraps g_socket_connection_connect_async
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress: a #GSocketAddress specifying the remote address. 
// 	- cancellable Cancellable (nullable): a %GCancellable or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// Asynchronously connect @connection to the specified remote address.
// 
// This clears the #GSocket:blocking flag on @connection's underlying
// socket if it is currently set.
// 
// If #GSocket:timeout is set, the operation will time out and return
// %G_IO_ERROR_TIMED_OUT after that period. Otherwise, it will continue
// indefinitely until operating system timeouts (if any) are hit.
// 
// Use g_socket_connection_connect_finish() to retrieve the result.
func (connection *SocketConnectionInstance) ConnectAsync(address SocketAddress, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketConnection  // in, none, converted
	var carg1 *C.GSocketAddress     // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_connection_connect_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(address)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ConnectFinish wraps g_socket_connection_connect_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets the result of a g_socket_connection_connect_async() call.
func (connection *SocketConnectionInstance) ConnectFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_connection_connect_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetLocalAddress wraps g_socket_connection_get_local_address
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
// 	- _goerr error (nullable): an error 
//
// Try to get the local address of a socket connection.
func (connection *SocketConnectionInstance) GetLocalAddress() (SocketAddress, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocketAddress    // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_local_address(carg0, &_cerr)
	runtime.KeepAlive(connection)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetRemoteAddress wraps g_socket_connection_get_remote_address
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
// 	- _goerr error (nullable): an error 
//
// Try to get the remote address of a socket connection.
// 
// Since GLib 2.40, when used with g_socket_client_connect() or
// g_socket_client_connect_async(), during emission of
// %G_SOCKET_CLIENT_CONNECTING, this function will return the remote
// address that will be used for the connection.  This allows
// applications to print e.g. "Connecting to example.com
// (10.42.77.3)...".
func (connection *SocketConnectionInstance) GetRemoteAddress() (SocketAddress, error) {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocketAddress    // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_remote_address(carg0, &_cerr)
	runtime.KeepAlive(connection)

	var goret  SocketAddress
	var _goerr error

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSocket wraps g_socket_connection_get_socket
// 
// The function returns the following values:
// 
// 	- goret Socket 
//
// Gets the underlying #GSocket object of the connection.
// This can be useful if you want to do something unusual on it
// not supported by the #GSocketConnection APIs.
func (connection *SocketConnectionInstance) GetSocket() Socket {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  *C.GSocket           // return, none, converted

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_get_socket(carg0)
	runtime.KeepAlive(connection)

	var goret Socket

	goret = UnsafeSocketFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsConnected wraps g_socket_connection_is_connected
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @connection is connected. This is equivalent to calling
// g_socket_is_connected() on @connection's underlying #GSocket.
func (connection *SocketConnectionInstance) IsConnected() bool {
	var carg0 *C.GSocketConnection // in, none, converted
	var cret  C.gboolean           // return

	carg0 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))

	cret = C.g_socket_connection_is_connected(carg0)
	runtime.KeepAlive(connection)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SocketConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketConnectionOverrides[Instance SocketConnection] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

}

// UnsafeApplySocketConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketConnectionOverrides[Instance SocketConnection](gclass unsafe.Pointer, overrides SocketConnectionOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)
}

// RegisterSocketConnectionSubClass is used to register a go subclass of GSocketConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketConnectionSubClass[InstanceT SocketConnection](
		name string,
		classInit func(class *SocketConnectionClass),
		constructor func() InstanceT,
		overrides SocketConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketConnection,
		UnsafeSocketConnectionClassFromGlibBorrow,
		UnsafeApplySocketConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketConnection(obj)
		},
		interfaceInits...,
	)
}

// SocketControlMessageInstance is the instance type used by all types extending GSocketControlMessage. It is used internally by the bindings. Users should use the interface [SocketControlMessage] instead.
type SocketControlMessageInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketControlMessage = (*SocketControlMessageInstance)(nil)

// SocketControlMessage wraps GSocketControlMessage
//
// A `GSocketControlMessage` is a special-purpose utility message that
// can be sent to or received from a [class@Gio.Socket]. These types of
// messages are often called &#x2018;ancillary data&#x2019;.
// 
// The message can represent some sort of special instruction to or
// information from the socket or can represent a special kind of
// transfer to the peer (for example, sending a file descriptor over
// a UNIX socket).
// 
// These messages are sent with [method@Gio.Socket.send_message] and received
// with [method@Gio.Socket.receive_message].
// 
// To extend the set of control message that can be sent, subclass this
// class and override the `get_size`, `get_level`, `get_type` and `serialize`
// methods.
// 
// To extend the set of control messages that can be received, subclass
// this class and implement the `deserialize` method. Also, make sure your
// class is registered with the [type@GObject.Type] type system before calling
// [method@Gio.Socket.receive_message] to read such a message.
type SocketControlMessage interface {
	gobject.Object
	upcastToGSocketControlMessage() *SocketControlMessageInstance

	// GetLevel wraps g_socket_control_message_get_level
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Returns the "level" (i.e. the originating protocol) of the control message.
	// This is often SOL_SOCKET.
	GetLevel() int32
	// GetMsgType wraps g_socket_control_message_get_msg_type
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Returns the protocol specific type of the control message.
	// For instance, for UNIX fd passing this would be SCM_RIGHTS.
	GetMsgType() int32
	// GetSize wraps g_socket_control_message_get_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Returns the space required for the control message, not including
	// headers or alignment.
	GetSize() uint

	// chain up virtual methods:

	// ParentGetLevel calls the default implementations of the `GSocketControlMessage.get_level` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Returns the "level" (i.e. the originating protocol) of the control message.
	// This is often SOL_SOCKET.
	ParentGetLevel() int32
	// ParentGetSize calls the default implementations of the `GSocketControlMessage.get_size` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Returns the space required for the control message, not including
	// headers or alignment.
	ParentGetSize() uint
	// ParentGetType calls the default implementations of the `GSocketControlMessage.get_type` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// gets the protocol specific type of the message.
	ParentGetType() int32
}

func unsafeWrapSocketControlMessage(base *gobject.ObjectInstance) *SocketControlMessageInstance {
	return &SocketControlMessageInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketControlMessage,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketControlMessage(inst)
		},
	)
}

func marshalSocketControlMessageInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketControlMessageFromGlibNone is used to convert raw GSocketControlMessage pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibNone(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketControlMessage)
}

// UnsafeSocketControlMessageFromGlibFull is used to convert raw GSocketControlMessage pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibFull(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketControlMessage)
}

// UnsafeSocketControlMessageFromGlibBorrow is used to convert raw GSocketControlMessage pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketControlMessageFromGlibBorrow(c unsafe.Pointer) SocketControlMessage {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketControlMessage)
}

func (s *SocketControlMessageInstance) upcastToGSocketControlMessage() *SocketControlMessageInstance {
	return s
}

// UnsafeSocketControlMessageToGlibNone is used to convert the instance to it's C value GSocketControlMessage. This is used by the bindings internally.
func UnsafeSocketControlMessageToGlibNone(c SocketControlMessage) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketControlMessageToGlibFull is used to convert the instance to it's C value GSocketControlMessage, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketControlMessageToGlibFull(c SocketControlMessage) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetLevel wraps g_socket_control_message_get_level
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the "level" (i.e. the originating protocol) of the control message.
// This is often SOL_SOCKET.
func (message *SocketControlMessageInstance) GetLevel() int32 {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.int                    // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_level(carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetMsgType wraps g_socket_control_message_get_msg_type
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the protocol specific type of the control message.
// For instance, for UNIX fd passing this would be SCM_RIGHTS.
func (message *SocketControlMessageInstance) GetMsgType() int32 {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.int                    // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_msg_type(carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSize wraps g_socket_control_message_get_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the space required for the control message, not including
// headers or alignment.
func (message *SocketControlMessageInstance) GetSize() uint {
	var carg0 *C.GSocketControlMessage // in, none, converted
	var cret  C.gsize                  // return, none, casted

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C.g_socket_control_message_get_size(carg0)
	runtime.KeepAlive(message)

	var goret uint

	goret = uint(cret)

	return goret
}

// SocketControlMessageOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketControlMessageOverrides[Instance SocketControlMessage] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetLevel allows you to override the implementation of the virtual method get_level.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Returns the "level" (i.e. the originating protocol) of the control message.
	// This is often SOL_SOCKET.
	GetLevel func(Instance) int32
	// // GetSize allows you to override the implementation of the virtual method get_size.
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Returns the space required for the control message, not including
	// headers or alignment.
	GetSize func(Instance) uint
	// // GetType allows you to override the implementation of the virtual method get_type.
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// gets the protocol specific type of the message.
	GetType func(Instance) int32
}

// UnsafeApplySocketControlMessageOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketControlMessageOverrides[Instance SocketControlMessage](gclass unsafe.Pointer, overrides SocketControlMessageOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketControlMessageClass)(gclass)

	if overrides.GetLevel != nil {
		pclass.get_level = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_level)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_level",
			func(carg0 *C.GSocketControlMessage) (cret C.int) {
				var message Instance // go GSocketControlMessage subclass
				var goret   int32    // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetLevel(message)

				cret = C.int(goret)

				return cret
			},
		)
	}

	if overrides.GetSize != nil {
		pclass.get_size = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_size)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_size",
			func(carg0 *C.GSocketControlMessage) (cret C.gsize) {
				var message Instance // go GSocketControlMessage subclass
				var goret   uint     // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetSize(message)

				cret = C.gsize(goret)

				return cret
			},
		)
	}

	if overrides.GetType != nil {
		pclass.get_type = (*[0]byte)(C._goglib_gio2_SocketControlMessage_get_type)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketControlMessage_get_type",
			func(carg0 *C.GSocketControlMessage) (cret C.int) {
				var message Instance // go GSocketControlMessage subclass
				var goret   int32    // return, none, casted

				message = UnsafeSocketControlMessageFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetType(message)

				cret = C.int(goret)

				return cret
			},
		)
	}
}

// ParentGetLevel calls the default implementations of the `GSocketControlMessage.get_level` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the "level" (i.e. the originating protocol) of the control message.
// This is often SOL_SOCKET.
func (message *SocketControlMessageInstance) ParentGetLevel() int32 {
	var carg0 *C.GSocketControlMessage
	var cret  C.int // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_level(unsafe.Pointer(parentclass.get_level), carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// ParentGetSize calls the default implementations of the `GSocketControlMessage.get_size` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the space required for the control message, not including
// headers or alignment.
func (message *SocketControlMessageInstance) ParentGetSize() uint {
	var carg0 *C.GSocketControlMessage
	var cret  C.gsize // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_size(unsafe.Pointer(parentclass.get_size), carg0)
	runtime.KeepAlive(message)

	var goret uint

	goret = uint(cret)

	return goret
}

// ParentGetType calls the default implementations of the `GSocketControlMessage.get_type` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// gets the protocol specific type of the message.
func (message *SocketControlMessageInstance) ParentGetType() int32 {
	var carg0 *C.GSocketControlMessage
	var cret  C.int // return, none, casted

	parentclass := (*C.GSocketControlMessageClass)(classdata.PeekParentClass(UnsafeSocketControlMessageToGlibNone(message)))

	carg0 = (*C.GSocketControlMessage)(UnsafeSocketControlMessageToGlibNone(message))

	cret = C._goglib_gio2_SocketControlMessage_virtual_get_type(unsafe.Pointer(parentclass.get_type), carg0)
	runtime.KeepAlive(message)

	var goret int32

	goret = int32(cret)

	return goret
}

// RegisterSocketControlMessageSubClass is used to register a go subclass of GSocketControlMessage. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketControlMessageSubClass[InstanceT SocketControlMessage](
		name string,
		classInit func(class *SocketControlMessageClass),
		constructor func() InstanceT,
		overrides SocketControlMessageOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketControlMessage,
		UnsafeSocketControlMessageClassFromGlibBorrow,
		UnsafeApplySocketControlMessageOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketControlMessage(obj)
		},
		interfaceInits...,
	)
}

// SocketListenerInstance is the instance type used by all types extending GSocketListener. It is used internally by the bindings. Users should use the interface [SocketListener] instead.
type SocketListenerInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ SocketListener = (*SocketListenerInstance)(nil)

// SocketListener wraps GSocketListener
//
// A `GSocketListener` is an object that keeps track of a set
// of server sockets and helps you accept sockets from any of the
// socket, either sync or async.
// 
// Add addresses and ports to listen on using
// [method@Gio.SocketListener.add_address] and
// [method@Gio.SocketListener.add_inet_port]. These will be listened on until
// [method@Gio.SocketListener.close] is called. Dropping your final reference to
// the `GSocketListener` will not cause [method@Gio.SocketListener.close] to be
// called implicitly, as some references to the `GSocketListener` may be held
// internally.
// 
// If you want to implement a network server, also look at
// [class@Gio.SocketService] and [class@Gio.ThreadedSocketService] which are
// subclasses of `GSocketListener` that make this even easier.
type SocketListener interface {
	gobject.Object
	upcastToGSocketListener() *SocketListenerInstance

	// Accept wraps g_socket_listener_accept
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- sourceObject gobject.Object (nullable): location where #GObject pointer will be stored, or %NULL 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns a #GSocketConnection for the socket that was
	// accepted.
	// 
	// If @source_object is not %NULL it will be filled out with the source
	// object specified when the corresponding socket or address was added
	// to the listener.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	Accept(Cancellable) (gobject.Object, SocketConnection, error)
	// AcceptAsync wraps g_socket_listener_accept_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of g_socket_listener_accept().
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_socket_listener_accept_finish()
	// to get the result of the operation.
	AcceptAsync(Cancellable, AsyncReadyCallback)
	// AcceptFinish wraps g_socket_listener_accept_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 	- goret SocketConnection 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async accept operation. See g_socket_listener_accept_async()
	AcceptFinish(AsyncResult) (gobject.Object, SocketConnection, error)
	// AcceptSocket wraps g_socket_listener_accept_socket
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- sourceObject gobject.Object (nullable): location where #GObject pointer will be stored, or %NULL. 
	// 	- goret Socket 
	// 	- _goerr error (nullable): an error 
	//
	// Blocks waiting for a client to connect to any of the sockets added
	// to the listener. Returns the #GSocket that was accepted.
	// 
	// If you want to accept the high-level #GSocketConnection, not a #GSocket,
	// which is often the case, then you should use g_socket_listener_accept()
	// instead.
	// 
	// If @source_object is not %NULL it will be filled out with the source
	// object specified when the corresponding socket or address was added
	// to the listener.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	AcceptSocket(Cancellable) (gobject.Object, Socket, error)
	// AcceptSocketAsync wraps g_socket_listener_accept_socket_async
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
	//
	// This is the asynchronous version of g_socket_listener_accept_socket().
	// 
	// When the operation is finished @callback will be
	// called. You can then call g_socket_listener_accept_socket_finish()
	// to get the result of the operation.
	AcceptSocketAsync(Cancellable, AsyncReadyCallback)
	// AcceptSocketFinish wraps g_socket_listener_accept_socket_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 	- goret Socket 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an async accept operation. See g_socket_listener_accept_socket_async()
	AcceptSocketFinish(AsyncResult) (gobject.Object, Socket, error)
	// AddAddress wraps g_socket_listener_add_address
	// 
	// The function takes the following parameters:
	// 
	// 	- address SocketAddress: a #GSocketAddress 
	// 	- typ SocketType: a #GSocketType 
	// 	- protocol SocketProtocol: a #GSocketProtocol 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 
	// The function returns the following values:
	// 
	// 	- effectiveAddress SocketAddress: location to store the address that was bound to, or %NULL. 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Creates a socket of type @type and protocol @protocol, binds
	// it to @address and adds it to the set of sockets we're accepting
	// sockets from.
	// 
	// Note that adding an IPv6 address, depending on the platform,
	// may or may not result in a listener that also accepts IPv4
	// connections.  For more deterministic behavior, see
	// g_socket_listener_add_inet_port().
	// 
	// @source_object will be passed out in the various calls
	// to accept to identify this particular source, which is
	// useful if you're listening on multiple addresses and do
	// different things depending on what address is connected to.
	// 
	// If successful and @effective_address is non-%NULL then it will
	// be set to the address that the binding actually occurred at.  This
	// is helpful for determining the port number that was used for when
	// requesting a binding to port 0 (ie: "any port").  This address, if
	// requested, belongs to the caller and must be freed.
	// 
	// Call g_socket_listener_close() to stop listening on @address; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddAddress(SocketAddress, SocketType, SocketProtocol, gobject.Object) (SocketAddress, bool, error)
	// AddAnyInetPort wraps g_socket_listener_add_any_inet_port
	// 
	// The function takes the following parameters:
	// 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint16 
	// 	- _goerr error (nullable): an error 
	//
	// Listens for TCP connections on any available port number for both
	// IPv6 and IPv4 (if each is available).
	// 
	// This is useful if you need to have a socket for incoming connections
	// but don't care about the specific port number.
	// 
	// If possible, the [class@Gio.SocketListener] will listen on both IPv4 and
	// IPv6 (listening on the same port on both). If listening on one of the socket
	// families fails, the [class@Gio.SocketListener] will only listen on the other.
	// If listening on both fails, an error will be returned.
	// 
	// If you need to distinguish whether listening on IPv4 or IPv6 or both was
	// successful, connect to [signal@Gio.SocketListener::event].
	// 
	// @source_object will be passed out in the various calls
	// to accept to identify this particular source, which is
	// useful if you're listening on multiple addresses and do
	// different things depending on what address is connected to.
	AddAnyInetPort(gobject.Object) (uint16, error)
	// AddInetPort wraps g_socket_listener_add_inet_port
	// 
	// The function takes the following parameters:
	// 
	// 	- port uint16: an IP port number (non-zero) 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Helper function for g_socket_listener_add_address() that
	// creates a TCP/IP socket listening on IPv4 and IPv6 (if
	// supported) on the specified port on all interfaces.
	// 
	// If possible, the [class@Gio.SocketListener] will listen on both IPv4 and
	// IPv6 (listening on the same port on both). If listening on one of the socket
	// families fails, the [class@Gio.SocketListener] will only listen on the other.
	// If listening on both fails, an error will be returned.
	// 
	// If you need to distinguish whether listening on IPv4 or IPv6 or both was
	// successful, connect to [signal@Gio.SocketListener::event].
	// 
	// @source_object will be passed out in the various calls
	// to accept to identify this particular source, which is
	// useful if you're listening on multiple addresses and do
	// different things depending on what address is connected to.
	// 
	// Call g_socket_listener_close() to stop listening on @port; this will not
	// be done automatically when you drop your final reference to @listener, as
	// references may be held internally.
	AddInetPort(uint16, gobject.Object) (bool, error)
	// AddSocket wraps g_socket_listener_add_socket
	// 
	// The function takes the following parameters:
	// 
	// 	- socket Socket: a listening #GSocket 
	// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Adds @socket to the set of sockets that we try to accept
	// new clients from. The socket must be bound to a local
	// address and listened to.
	// 
	// @source_object will be passed out in the various calls
	// to accept to identify this particular source, which is
	// useful if you're listening on multiple addresses and do
	// different things depending on what address is connected to.
	// 
	// The @socket will not be automatically closed when the @listener is finalized
	// unless the listener held the final reference to the socket. Before GLib 2.42,
	// the @socket was automatically closed on finalization of the @listener, even
	// if references to it were held elsewhere.
	AddSocket(Socket, gobject.Object) (bool, error)
	// Close wraps g_socket_listener_close
	//
	// Closes all the sockets in the listener.
	Close()
	// SetBacklog wraps g_socket_listener_set_backlog
	// 
	// The function takes the following parameters:
	// 
	// 	- listenBacklog int32: an integer 
	//
	// Sets the listen backlog on the sockets in the listener. This must be called
	// before adding any sockets, addresses or ports to the #GSocketListener (for
	// example, by calling g_socket_listener_add_inet_port()) to be effective.
	// 
	// See g_socket_set_listen_backlog() for details
	SetBacklog(int32)
	// ConnectEvent connects the provided callback to the "event" signal
	//
	// Emitted when @listener's activity on @socket changes state.
	// Note that when @listener is used to listen on both IPv4 and
	// IPv6, a separate set of signals will be emitted for each, and
	// the order they happen in is undefined.
	ConnectEvent(func(SocketListener, SocketListenerEvent, Socket)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentChanged calls the default implementations of the `GSocketListener.changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	//
	// virtual method called when the set of socket listened to changes
	ParentChanged()
	// ParentEvent calls the default implementations of the `GSocketListener.event` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- event SocketListenerEvent 
	// 	- socket Socket 
	ParentEvent(event SocketListenerEvent, socket Socket)
}

func unsafeWrapSocketListener(base *gobject.ObjectInstance) *SocketListenerInstance {
	return &SocketListenerInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketListener,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketListener(inst)
		},
	)
}

func marshalSocketListenerInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketListenerFromGlibNone is used to convert raw GSocketListener pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibNone(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketListener)
}

// UnsafeSocketListenerFromGlibFull is used to convert raw GSocketListener pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibFull(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketListener)
}

// UnsafeSocketListenerFromGlibBorrow is used to convert raw GSocketListener pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketListenerFromGlibBorrow(c unsafe.Pointer) SocketListener {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketListener)
}

func (s *SocketListenerInstance) upcastToGSocketListener() *SocketListenerInstance {
	return s
}

// UnsafeSocketListenerToGlibNone is used to convert the instance to it's C value GSocketListener. This is used by the bindings internally.
func UnsafeSocketListenerToGlibNone(c SocketListener) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketListenerToGlibFull is used to convert the instance to it's C value GSocketListener, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketListenerToGlibFull(c SocketListener) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketListener wraps g_socket_listener_new
// 
// The function returns the following values:
// 
// 	- goret SocketListener 
//
// Creates a new #GSocketListener with no sockets to listen for.
// New listeners can be added with e.g. g_socket_listener_add_address()
// or g_socket_listener_add_inet_port().
func NewSocketListener() SocketListener {
	var cret *C.GSocketListener // return, full, converted

	cret = C.g_socket_listener_new()

	var goret SocketListener

	goret = UnsafeSocketListenerFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Accept wraps g_socket_listener_accept
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- sourceObject gobject.Object (nullable): location where #GObject pointer will be stored, or %NULL 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns a #GSocketConnection for the socket that was
// accepted.
// 
// If @source_object is not %NULL it will be filled out with the source
// object specified when the corresponding socket or address was added
// to the listener.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (listener *SocketListenerInstance) Accept(cancellable Cancellable) (gobject.Object, SocketConnection, error) {
	var carg0 *C.GSocketListener   // in, none, converted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var carg1 *C.GObject           // out, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_listener_accept(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)

	var sourceObject gobject.Object
	var goret        SocketConnection
	var _goerr       error

	if carg1 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg1))
	}
	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptAsync wraps g_socket_listener_accept_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of g_socket_listener_accept().
// 
// When the operation is finished @callback will be
// called. You can then call g_socket_listener_accept_finish()
// to get the result of the operation.
func (listener *SocketListenerInstance) AcceptAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketListener    // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_listener_accept_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcceptFinish wraps g_socket_listener_accept_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 	- goret SocketConnection 
// 	- _goerr error (nullable): an error 
//
// Finishes an async accept operation. See g_socket_listener_accept_async()
func (listener *SocketListenerInstance) AcceptFinish(result AsyncResult) (gobject.Object, SocketConnection, error) {
	var carg0 *C.GSocketListener   // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var carg2 *C.GObject           // out, none, converted, nullable
	var cret  *C.GSocketConnection // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_listener_accept_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var sourceObject gobject.Object
	var goret        SocketConnection
	var _goerr       error

	if carg2 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))
	}
	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptSocket wraps g_socket_listener_accept_socket
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- sourceObject gobject.Object (nullable): location where #GObject pointer will be stored, or %NULL. 
// 	- goret Socket 
// 	- _goerr error (nullable): an error 
//
// Blocks waiting for a client to connect to any of the sockets added
// to the listener. Returns the #GSocket that was accepted.
// 
// If you want to accept the high-level #GSocketConnection, not a #GSocket,
// which is often the case, then you should use g_socket_listener_accept()
// instead.
// 
// If @source_object is not %NULL it will be filled out with the source
// object specified when the corresponding socket or address was added
// to the listener.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (listener *SocketListenerInstance) AcceptSocket(cancellable Cancellable) (gobject.Object, Socket, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg2 *C.GCancellable    // in, none, converted, nullable
	var carg1 *C.GObject         // out, none, converted, nullable
	var cret  *C.GSocket         // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_socket_listener_accept_socket(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)

	var sourceObject gobject.Object
	var goret        Socket
	var _goerr       error

	if carg1 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg1))
	}
	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AcceptSocketAsync wraps g_socket_listener_accept_socket_async
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback 
//
// This is the asynchronous version of g_socket_listener_accept_socket().
// 
// When the operation is finished @callback will be
// called. You can then call g_socket_listener_accept_socket_finish()
// to get the result of the operation.
func (listener *SocketListenerInstance) AcceptSocketAsync(cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GSocketListener    // in, none, converted
	var carg1 *C.GCancellable       // in, none, converted, nullable
	var carg2 C.GAsyncReadyCallback // callback, scope: async, closure: carg3, nullable
	var carg3 C.gpointer            // implicit

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg3 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_socket_listener_accept_socket_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AcceptSocketFinish wraps g_socket_listener_accept_socket_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 	- goret Socket 
// 	- _goerr error (nullable): an error 
//
// Finishes an async accept operation. See g_socket_listener_accept_socket_async()
func (listener *SocketListenerInstance) AcceptSocketFinish(result AsyncResult) (gobject.Object, Socket, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var carg2 *C.GObject         // out, none, converted, nullable
	var cret  *C.GSocket         // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_socket_listener_accept_socket_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(result)

	var sourceObject gobject.Object
	var goret        Socket
	var _goerr       error

	if carg2 != nil {
		sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))
	}
	goret = UnsafeSocketFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return sourceObject, goret, _goerr
}

// AddAddress wraps g_socket_listener_add_address
// 
// The function takes the following parameters:
// 
// 	- address SocketAddress: a #GSocketAddress 
// 	- typ SocketType: a #GSocketType 
// 	- protocol SocketProtocol: a #GSocketProtocol 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 
// The function returns the following values:
// 
// 	- effectiveAddress SocketAddress: location to store the address that was bound to, or %NULL. 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Creates a socket of type @type and protocol @protocol, binds
// it to @address and adds it to the set of sockets we're accepting
// sockets from.
// 
// Note that adding an IPv6 address, depending on the platform,
// may or may not result in a listener that also accepts IPv4
// connections.  For more deterministic behavior, see
// g_socket_listener_add_inet_port().
// 
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
// 
// If successful and @effective_address is non-%NULL then it will
// be set to the address that the binding actually occurred at.  This
// is helpful for determining the port number that was used for when
// requesting a binding to port 0 (ie: "any port").  This address, if
// requested, belongs to the caller and must be freed.
// 
// Call g_socket_listener_close() to stop listening on @address; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (listener *SocketListenerInstance) AddAddress(address SocketAddress, typ SocketType, protocol SocketProtocol, sourceObject gobject.Object) (SocketAddress, bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GSocketAddress  // in, none, converted
	var carg2 C.GSocketType      // in, none, casted
	var carg3 C.GSocketProtocol  // in, none, casted
	var carg4 *C.GObject         // in, none, converted, nullable
	var carg5 *C.GSocketAddress  // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GSocketAddress)(UnsafeSocketAddressToGlibNone(address))
	carg2 = C.GSocketType(typ)
	carg3 = C.GSocketProtocol(protocol)
	if sourceObject != nil {
		carg4 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_address(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(address)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(sourceObject)

	var effectiveAddress SocketAddress
	var goret            bool
	var _goerr           error

	effectiveAddress = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return effectiveAddress, goret, _goerr
}

// AddAnyInetPort wraps g_socket_listener_add_any_inet_port
// 
// The function takes the following parameters:
// 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 
// The function returns the following values:
// 
// 	- goret uint16 
// 	- _goerr error (nullable): an error 
//
// Listens for TCP connections on any available port number for both
// IPv6 and IPv4 (if each is available).
// 
// This is useful if you need to have a socket for incoming connections
// but don't care about the specific port number.
// 
// If possible, the [class@Gio.SocketListener] will listen on both IPv4 and
// IPv6 (listening on the same port on both). If listening on one of the socket
// families fails, the [class@Gio.SocketListener] will only listen on the other.
// If listening on both fails, an error will be returned.
// 
// If you need to distinguish whether listening on IPv4 or IPv6 or both was
// successful, connect to [signal@Gio.SocketListener::event].
// 
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
func (listener *SocketListenerInstance) AddAnyInetPort(sourceObject gobject.Object) (uint16, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GObject         // in, none, converted, nullable
	var cret  C.guint16          // return, none, casted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	if sourceObject != nil {
		carg1 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_any_inet_port(carg0, carg1, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(sourceObject)

	var goret  uint16
	var _goerr error

	goret = uint16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AddInetPort wraps g_socket_listener_add_inet_port
// 
// The function takes the following parameters:
// 
// 	- port uint16: an IP port number (non-zero) 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Helper function for g_socket_listener_add_address() that
// creates a TCP/IP socket listening on IPv4 and IPv6 (if
// supported) on the specified port on all interfaces.
// 
// If possible, the [class@Gio.SocketListener] will listen on both IPv4 and
// IPv6 (listening on the same port on both). If listening on one of the socket
// families fails, the [class@Gio.SocketListener] will only listen on the other.
// If listening on both fails, an error will be returned.
// 
// If you need to distinguish whether listening on IPv4 or IPv6 or both was
// successful, connect to [signal@Gio.SocketListener::event].
// 
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
// 
// Call g_socket_listener_close() to stop listening on @port; this will not
// be done automatically when you drop your final reference to @listener, as
// references may be held internally.
func (listener *SocketListenerInstance) AddInetPort(port uint16, sourceObject gobject.Object) (bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 C.guint16          // in, none, casted
	var carg2 *C.GObject         // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.guint16(port)
	if sourceObject != nil {
		carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_inet_port(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(port)
	runtime.KeepAlive(sourceObject)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AddSocket wraps g_socket_listener_add_socket
// 
// The function takes the following parameters:
// 
// 	- socket Socket: a listening #GSocket 
// 	- sourceObject gobject.Object (nullable): Optional #GObject identifying this source 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Adds @socket to the set of sockets that we try to accept
// new clients from. The socket must be bound to a local
// address and listened to.
// 
// @source_object will be passed out in the various calls
// to accept to identify this particular source, which is
// useful if you're listening on multiple addresses and do
// different things depending on what address is connected to.
// 
// The @socket will not be automatically closed when the @listener is finalized
// unless the listener held the final reference to the socket. Before GLib 2.42,
// the @socket was automatically closed on finalization of the @listener, even
// if references to it were held elsewhere.
func (listener *SocketListenerInstance) AddSocket(socket Socket, sourceObject gobject.Object) (bool, error) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 *C.GSocket         // in, none, converted
	var carg2 *C.GObject         // in, none, converted, nullable
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))
	if sourceObject != nil {
		carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))
	}

	cret = C.g_socket_listener_add_socket(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(sourceObject)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_socket_listener_close
//
// Closes all the sockets in the listener.
func (listener *SocketListenerInstance) Close() {
	var carg0 *C.GSocketListener // in, none, converted

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))

	C.g_socket_listener_close(carg0)
	runtime.KeepAlive(listener)
}

// SetBacklog wraps g_socket_listener_set_backlog
// 
// The function takes the following parameters:
// 
// 	- listenBacklog int32: an integer 
//
// Sets the listen backlog on the sockets in the listener. This must be called
// before adding any sockets, addresses or ports to the #GSocketListener (for
// example, by calling g_socket_listener_add_inet_port()) to be effective.
// 
// See g_socket_set_listen_backlog() for details
func (listener *SocketListenerInstance) SetBacklog(listenBacklog int32) {
	var carg0 *C.GSocketListener // in, none, converted
	var carg1 C.int              // in, none, casted

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.int(listenBacklog)

	C.g_socket_listener_set_backlog(carg0, carg1)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(listenBacklog)
}

// ConnectEvent connects the provided callback to the "event" signal
//
// Emitted when @listener's activity on @socket changes state.
// Note that when @listener is used to listen on both IPv4 and
// IPv6, a separate set of signals will be emitted for each, and
// the order they happen in is undefined.
func (o *SocketListenerInstance) ConnectEvent(fn func(SocketListener, SocketListenerEvent, Socket)) gobject.SignalHandle {
	return o.Connect("event", fn)
}

// SocketListenerOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketListenerOverrides[Instance SocketListener] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Changed allows you to override the implementation of the virtual method changed.
	//
	// virtual method called when the set of socket listened to changes
	Changed func(Instance)
	// // Event allows you to override the implementation of the virtual method event.
	// 
	// The function takes the following parameters:
	// 
	// 	- event SocketListenerEvent 
	// 	- socket Socket 
	Event func(Instance, SocketListenerEvent, Socket)
}

// UnsafeApplySocketListenerOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketListenerOverrides[Instance SocketListener](gclass unsafe.Pointer, overrides SocketListenerOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GSocketListenerClass)(gclass)

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._goglib_gio2_SocketListener_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketListener_changed",
			func(carg0 *C.GSocketListener) {
				var listener Instance // go GSocketListener subclass

				listener = UnsafeSocketListenerFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				overrides.Changed(listener)
			},
		)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._goglib_gio2_SocketListener_event)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketListener_event",
			func(carg0 *C.GSocketListener, carg1 C.GSocketListenerEvent, carg2 *C.GSocket) {
				var listener Instance            // go GSocketListener subclass
				var event    SocketListenerEvent // in, none, casted
				var socket   Socket              // in, none, converted

				listener = UnsafeSocketListenerFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				event = SocketListenerEvent(carg1)
				socket = UnsafeSocketFromGlibNone(unsafe.Pointer(carg2))

				overrides.Event(listener, event, socket)
			},
		)
	}
}

// ParentChanged calls the default implementations of the `GSocketListener.changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
//
// virtual method called when the set of socket listened to changes
func (listener *SocketListenerInstance) ParentChanged() {
	var carg0 *C.GSocketListener

	parentclass := (*C.GSocketListenerClass)(classdata.PeekParentClass(UnsafeSocketListenerToGlibNone(listener)))

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))

	C._goglib_gio2_SocketListener_virtual_changed(unsafe.Pointer(parentclass.changed), carg0)
	runtime.KeepAlive(listener)
}

// ParentEvent calls the default implementations of the `GSocketListener.event` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- event SocketListenerEvent 
// 	- socket Socket 
func (listener *SocketListenerInstance) ParentEvent(event SocketListenerEvent, socket Socket) {
	var carg0 *C.GSocketListener
	var carg1 C.GSocketListenerEvent // in, none, converted
	var carg2 *C.GSocket             // in, none, casted

	parentclass := (*C.GSocketListenerClass)(classdata.PeekParentClass(UnsafeSocketListenerToGlibNone(listener)))

	carg0 = (*C.GSocketListener)(UnsafeSocketListenerToGlibNone(listener))
	carg1 = C.GSocketListenerEvent(event)
	carg2 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	C._goglib_gio2_SocketListener_virtual_event(unsafe.Pointer(parentclass.event), carg0, carg1, carg2)
	runtime.KeepAlive(listener)
	runtime.KeepAlive(event)
	runtime.KeepAlive(socket)
}

// RegisterSocketListenerSubClass is used to register a go subclass of GSocketListener. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketListenerSubClass[InstanceT SocketListener](
		name string,
		classInit func(class *SocketListenerClass),
		constructor func() InstanceT,
		overrides SocketListenerOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketListener,
		UnsafeSocketListenerClassFromGlibBorrow,
		UnsafeApplySocketListenerOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketListener(obj)
		},
		interfaceInits...,
	)
}

// SocketServiceInstance is the instance type used by all types extending GSocketService. It is used internally by the bindings. Users should use the interface [SocketService] instead.
type SocketServiceInstance struct {
	_ [0]func() // equal guard
	SocketListenerInstance
}

var _ SocketService = (*SocketServiceInstance)(nil)

// SocketService wraps GSocketService
//
// A `GSocketService` is an object that represents a service that
// is provided to the network or over local sockets.  When a new
// connection is made to the service the [signal@Gio.SocketService::incoming]
// signal is emitted.
// 
// A `GSocketService` is a subclass of [class@Gio.SocketListener] and you need
// to add the addresses you want to accept connections on with the
// [class@Gio.SocketListener] APIs.
// 
// There are two options for implementing a network service based on
// `GSocketService`. The first is to create the service using
// [ctor@Gio.SocketService.new] and to connect to the
// [signal@Gio.SocketService::incoming] signal. The second is to subclass
// `GSocketService` and override the default signal handler implementation.
// 
// In either case, the handler must immediately return, or else it
// will block additional incoming connections from being serviced.
// If you are interested in writing connection handlers that contain
// blocking code then see [class@Gio.ThreadedSocketService].
// 
// The socket service runs on the main loop of the
// thread-default context (see
// [method@GLib.MainContext.push_thread_default]) of the thread it is
// created in, and is not threadsafe in general. However, the calls to start and
// stop the service are thread-safe so these can be used from threads that
// handle incoming clients.
type SocketService interface {
	SocketListener
	upcastToGSocketService() *SocketServiceInstance

	// IsActive wraps g_socket_service_is_active
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check whether the service is active or not. An active
	// service will accept new clients that connect, while
	// a non-active service will let connecting clients queue
	// up until the service is started.
	IsActive() bool
	// Start wraps g_socket_service_start
	//
	// Restarts the service, i.e. start accepting connections
	// from the added sockets when the mainloop runs. This only needs
	// to be called after the service has been stopped from
	// g_socket_service_stop().
	// 
	// This call is thread-safe, so it may be called from a thread
	// handling an incoming client request.
	Start()
	// Stop wraps g_socket_service_stop
	//
	// Stops the service, i.e. stops accepting connections
	// from the added sockets when the mainloop runs.
	// 
	// This call is thread-safe, so it may be called from a thread
	// handling an incoming client request.
	// 
	// Note that this only stops accepting new connections; it does not
	// close the listening sockets, and you can call
	// g_socket_service_start() again later to begin listening again. To
	// close the listening sockets, call g_socket_listener_close(). (This
	// will happen automatically when the #GSocketService is finalized.)
	// 
	// This must be called before calling g_socket_listener_close() as
	// the socket service will start accepting connections immediately
	// when a new socket is added.
	Stop()
	// ConnectIncoming connects the provided callback to the "incoming" signal
	//
	// The ::incoming signal is emitted when a new incoming connection
	// to @service needs to be handled. The handler must initiate the
	// handling of @connection, but may not block; in essence,
	// asynchronous operations must be used.
	// 
	// @connection will be unreffed once the signal handler returns,
	// so you need to ref it yourself if you are planning to use it.
	ConnectIncoming(func(SocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentIncoming calls the default implementations of the `GSocketService.incoming` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection SocketConnection 
	// 	- sourceObject gobject.Object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// signal emitted when new connections are accepted
	ParentIncoming(connection SocketConnection, sourceObject gobject.Object) bool
}

func unsafeWrapSocketService(base *gobject.ObjectInstance) *SocketServiceInstance {
	return &SocketServiceInstance{
		SocketListenerInstance: SocketListenerInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeSocketService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketService(inst)
		},
	)
}

func marshalSocketServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeSocketServiceFromGlibNone is used to convert raw GSocketService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibNone(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibNone(c).(SocketService)
}

// UnsafeSocketServiceFromGlibFull is used to convert raw GSocketService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibFull(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibFull(c).(SocketService)
}

// UnsafeSocketServiceFromGlibBorrow is used to convert raw GSocketService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeSocketServiceFromGlibBorrow(c unsafe.Pointer) SocketService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(SocketService)
}

func (s *SocketServiceInstance) upcastToGSocketService() *SocketServiceInstance {
	return s
}

// UnsafeSocketServiceToGlibNone is used to convert the instance to it's C value GSocketService. This is used by the bindings internally.
func UnsafeSocketServiceToGlibNone(c SocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeSocketServiceToGlibFull is used to convert the instance to it's C value GSocketService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeSocketServiceToGlibFull(c SocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewSocketService wraps g_socket_service_new
// 
// The function returns the following values:
// 
// 	- goret SocketService 
//
// Creates a new #GSocketService with no sockets to listen for.
// New listeners can be added with e.g. g_socket_listener_add_address()
// or g_socket_listener_add_inet_port().
// 
// New services are created active, there is no need to call
// g_socket_service_start(), unless g_socket_service_stop() has been
// called before.
func NewSocketService() SocketService {
	var cret *C.GSocketService // return, full, converted

	cret = C.g_socket_service_new()

	var goret SocketService

	goret = UnsafeSocketServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// IsActive wraps g_socket_service_is_active
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether the service is active or not. An active
// service will accept new clients that connect, while
// a non-active service will let connecting clients queue
// up until the service is started.
func (service *SocketServiceInstance) IsActive() bool {
	var carg0 *C.GSocketService // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	cret = C.g_socket_service_is_active(carg0)
	runtime.KeepAlive(service)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Start wraps g_socket_service_start
//
// Restarts the service, i.e. start accepting connections
// from the added sockets when the mainloop runs. This only needs
// to be called after the service has been stopped from
// g_socket_service_stop().
// 
// This call is thread-safe, so it may be called from a thread
// handling an incoming client request.
func (service *SocketServiceInstance) Start() {
	var carg0 *C.GSocketService // in, none, converted

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	C.g_socket_service_start(carg0)
	runtime.KeepAlive(service)
}

// Stop wraps g_socket_service_stop
//
// Stops the service, i.e. stops accepting connections
// from the added sockets when the mainloop runs.
// 
// This call is thread-safe, so it may be called from a thread
// handling an incoming client request.
// 
// Note that this only stops accepting new connections; it does not
// close the listening sockets, and you can call
// g_socket_service_start() again later to begin listening again. To
// close the listening sockets, call g_socket_listener_close(). (This
// will happen automatically when the #GSocketService is finalized.)
// 
// This must be called before calling g_socket_listener_close() as
// the socket service will start accepting connections immediately
// when a new socket is added.
func (service *SocketServiceInstance) Stop() {
	var carg0 *C.GSocketService // in, none, converted

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))

	C.g_socket_service_stop(carg0)
	runtime.KeepAlive(service)
}

// ConnectIncoming connects the provided callback to the "incoming" signal
//
// The ::incoming signal is emitted when a new incoming connection
// to @service needs to be handled. The handler must initiate the
// handling of @connection, but may not block; in essence,
// asynchronous operations must be used.
// 
// @connection will be unreffed once the signal handler returns,
// so you need to ref it yourself if you are planning to use it.
func (o *SocketServiceInstance) ConnectIncoming(fn func(SocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle {
	return o.Connect("incoming", fn)
}

// SocketServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type SocketServiceOverrides[Instance SocketService] struct {
	// SocketListenerOverrides allows you to override virtual methods from the parent class SocketListener
	SocketListenerOverrides[Instance]

	// // Incoming allows you to override the implementation of the virtual method incoming.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection SocketConnection 
	// 	- sourceObject gobject.Object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// signal emitted when new connections are accepted
	Incoming func(Instance, SocketConnection, gobject.Object) bool
}

// UnsafeApplySocketServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplySocketServiceOverrides[Instance SocketService](gclass unsafe.Pointer, overrides SocketServiceOverrides[Instance]) {
	UnsafeApplySocketListenerOverrides(gclass, overrides.SocketListenerOverrides)

	pclass := (*C.GSocketServiceClass)(gclass)

	if overrides.Incoming != nil {
		pclass.incoming = (*[0]byte)(C._goglib_gio2_SocketService_incoming)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_SocketService_incoming",
			func(carg0 *C.GSocketService, carg1 *C.GSocketConnection, carg2 *C.GObject) (cret C.gboolean) {
				var service      Instance         // go GSocketService subclass
				var connection   SocketConnection // in, none, converted
				var sourceObject gobject.Object   // in, none, converted
				var goret        bool             // return

				service = UnsafeSocketServiceFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeSocketConnectionFromGlibNone(unsafe.Pointer(carg1))
				sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))

				goret = overrides.Incoming(service, connection, sourceObject)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentIncoming calls the default implementations of the `GSocketService.incoming` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- connection SocketConnection 
// 	- sourceObject gobject.Object 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// signal emitted when new connections are accepted
func (service *SocketServiceInstance) ParentIncoming(connection SocketConnection, sourceObject gobject.Object) bool {
	var carg0 *C.GSocketService
	var carg1 *C.GSocketConnection // in, none, converted
	var carg2 *C.GObject           // in, none, converted
	var cret  C.gboolean           // return

	parentclass := (*C.GSocketServiceClass)(classdata.PeekParentClass(UnsafeSocketServiceToGlibNone(service)))

	carg0 = (*C.GSocketService)(UnsafeSocketServiceToGlibNone(service))
	carg1 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))

	cret = C._goglib_gio2_SocketService_virtual_incoming(unsafe.Pointer(parentclass.incoming), carg0, carg1, carg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegisterSocketServiceSubClass is used to register a go subclass of GSocketService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterSocketServiceSubClass[InstanceT SocketService](
		name string,
		classInit func(class *SocketServiceClass),
		constructor func() InstanceT,
		overrides SocketServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeSocketService,
		UnsafeSocketServiceClassFromGlibBorrow,
		UnsafeApplySocketServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapSocketService(obj)
		},
		interfaceInits...,
	)
}

// TaskInstance is the instance type used by all types extending GTask. It is used internally by the bindings. Users should use the interface [Task] instead.
type TaskInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Task = (*TaskInstance)(nil)

// Task wraps GTask
//
// A `GTask` represents and manages a cancellable &#x2018;task&#x2019;.
// 
// ## Asynchronous operations
// 
// The most common usage of `GTask` is as a [iface@Gio.AsyncResult], to
// manage data during an asynchronous operation. You call
// [ctor@Gio.Task.new] in the &#x2018;start&#x2019; method, followed by
// [method@Gio.Task.set_task_data] and the like if you need to keep some
// additional data associated with the task, and then pass the
// task object around through your asynchronous operation.
// Eventually, you will call a method such as
// [method@Gio.Task.return_pointer] or [method@Gio.Task.return_error], which
// will save the value you give it and then invoke the task&#x2019;s callback
// function in the thread-default main context (see
// [method@GLib.MainContext.push_thread_default])
// where it was created (waiting until the next iteration of the main
// loop first, if necessary). The caller will pass the `GTask` back to
// the operation&#x2019;s finish function (as a [iface@Gio.AsyncResult]), and you can
// use [method@Gio.Task.propagate_pointer] or the like to extract the
// return value.
// 
// Using `GTask` requires the thread-default [struct@GLib.MainContext] from when
// the `GTask` was constructed to be running at least until the task has
// completed and its data has been freed.
// 
// If a `GTask` has been constructed and its callback set, it is an error to
// not call `g_task_return_*()` on it. GLib will warn at runtime if this happens
// (since 2.76).
// 
// Here is an example for using `GTask` as a [iface@Gio.AsyncResult]:
// ```c
// typedef struct {
//   CakeFrostingType frosting;
//   char *message;
// } DecorationData;
// 
// static void
// decoration_data_free (DecorationData *decoration)
// {
//   g_free (decoration-&gt;message);
//   g_slice_free (DecorationData, decoration);
// }
// 
// static void
// baked_cb (Cake     *cake,
//           gpointer  user_data)
// {
//   GTask *task = user_data;
//   DecorationData *decoration = g_task_get_task_data (task);
//   GError *error = NULL;
// 
//   if (cake == NULL)
//     {
//       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//                                "Go to the supermarket");
//       g_object_unref (task);
//       return;
//     }
// 
//   if (!cake_decorate (cake, decoration-&gt;frosting, decoration-&gt;message, &amp;error))
//     {
//       g_object_unref (cake);
//       // g_task_return_error() takes ownership of error
//       g_task_return_error (task, error);
//       g_object_unref (task);
//       return;
//     }
// 
//   g_task_return_pointer (task, cake, g_object_unref);
//   g_object_unref (task);
// }
// 
// void
// baker_bake_cake_async (Baker               *self,
//                        guint                radius,
//                        CakeFlavor           flavor,
//                        CakeFrostingType     frosting,
//                        const char          *message,
//                        GCancellable        *cancellable,
//                        GAsyncReadyCallback  callback,
//                        gpointer             user_data)
// {
//   GTask *task;
//   DecorationData *decoration;
//   Cake  *cake;
// 
//   task = g_task_new (self, cancellable, callback, user_data);
//   if (radius &lt; 3)
//     {
//       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
//                                "%ucm radius cakes are silly",
//                                radius);
//       g_object_unref (task);
//       return;
//     }
// 
//   cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
//   if (cake != NULL)
//     {
//       // _baker_get_cached_cake() returns a reffed cake
//       g_task_return_pointer (task, cake, g_object_unref);
//       g_object_unref (task);
//       return;
//     }
// 
//   decoration = g_slice_new (DecorationData);
//   decoration-&gt;frosting = frosting;
//   decoration-&gt;message = g_strdup (message);
//   g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);
// 
//   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
// }
// 
// Cake *
// baker_bake_cake_finish (Baker         *self,
//                         GAsyncResult  *result,
//                         GError       **error)
// {
//   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
// 
//   return g_task_propagate_pointer (G_TASK (result), error);
// }
// ```
// 
// ## Chained asynchronous operations
// 
// `GTask` also tries to simplify asynchronous operations that
// internally chain together several smaller asynchronous
// operations. [method@Gio.Task.get_cancellable], [method@Gio.Task.get_context],
// and [method@Gio.Task.get_priority] allow you to get back the task&#x2019;s
// [class@Gio.Cancellable], [struct@GLib.MainContext], and
// [I/O priority](iface.AsyncResult.html#io-priority)
// when starting a new subtask, so you don&#x2019;t have to keep track
// of them yourself. [method@Gio.Task.attach_source] simplifies the case
// of waiting for a source to fire (automatically using the correct
// [struct@GLib.MainContext] and priority).
// 
// Here is an example for chained asynchronous operations:
// ```c
// typedef struct {
//   Cake *cake;
//   CakeFrostingType frosting;
//   char *message;
// } BakingData;
// 
// static void
// decoration_data_free (BakingData *bd)
// {
//   if (bd-&gt;cake)
//     g_object_unref (bd-&gt;cake);
//   g_free (bd-&gt;message);
//   g_slice_free (BakingData, bd);
// }
// 
// static void
// decorated_cb (Cake         *cake,
//               GAsyncResult *result,
//               gpointer      user_data)
// {
//   GTask *task = user_data;
//   GError *error = NULL;
// 
//   if (!cake_decorate_finish (cake, result, &amp;error))
//     {
//       g_object_unref (cake);
//       g_task_return_error (task, error);
//       g_object_unref (task);
//       return;
//     }
// 
//   // baking_data_free() will drop its ref on the cake, so we have to
//   // take another here to give to the caller.
//   g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
//   g_object_unref (task);
// }
// 
// static gboolean
// decorator_ready (gpointer user_data)
// {
//   GTask *task = user_data;
//   BakingData *bd = g_task_get_task_data (task);
// 
//   cake_decorate_async (bd-&gt;cake, bd-&gt;frosting, bd-&gt;message,
//                        g_task_get_cancellable (task),
//                        decorated_cb, task);
// 
//   return G_SOURCE_REMOVE;
// }
// 
// static void
// baked_cb (Cake     *cake,
//           gpointer  user_data)
// {
//   GTask *task = user_data;
//   BakingData *bd = g_task_get_task_data (task);
//   GError *error = NULL;
// 
//   if (cake == NULL)
//     {
//       g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
//                                "Go to the supermarket");
//       g_object_unref (task);
//       return;
//     }
// 
//   bd-&gt;cake = cake;
// 
//   // Bail out now if the user has already cancelled
//   if (g_task_return_error_if_cancelled (task))
//     {
//       g_object_unref (task);
//       return;
//     }
// 
//   if (cake_decorator_available (cake))
//     decorator_ready (task);
//   else
//     {
//       GSource *source;
// 
//       source = cake_decorator_wait_source_new (cake);
//       // Attach @source to @task&#x2019;s GMainContext and have it call
//       // decorator_ready() when it is ready.
//       g_task_attach_source (task, source, decorator_ready);
//       g_source_unref (source);
//     }
// }
// 
// void
// baker_bake_cake_async (Baker               *self,
//                        guint                radius,
//                        CakeFlavor           flavor,
//                        CakeFrostingType     frosting,
//                        const char          *message,
//                        gint                 priority,
//                        GCancellable        *cancellable,
//                        GAsyncReadyCallback  callback,
//                        gpointer             user_data)
// {
//   GTask *task;
//   BakingData *bd;
// 
//   task = g_task_new (self, cancellable, callback, user_data);
//   g_task_set_priority (task, priority);
// 
//   bd = g_slice_new0 (BakingData);
//   bd-&gt;frosting = frosting;
//   bd-&gt;message = g_strdup (message);
//   g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);
// 
//   _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
// }
// 
// Cake *
// baker_bake_cake_finish (Baker         *self,
//                         GAsyncResult  *result,
//                         GError       **error)
// {
//   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
// 
//   return g_task_propagate_pointer (G_TASK (result), error);
// }
// ```
// 
// ## Asynchronous operations from synchronous ones
// 
// You can use [method@Gio.Task.run_in_thread] to turn a synchronous
// operation into an asynchronous one, by running it in a thread.
// When it completes, the result will be dispatched to the thread-default
// main context (see [method@GLib.MainContext.push_thread_default])
// where the `GTask` was created.
// 
// Running a task in a thread:
// ```c
// typedef struct {
//   guint radius;
//   CakeFlavor flavor;
//   CakeFrostingType frosting;
//   char *message;
// } CakeData;
// 
// static void
// cake_data_free (CakeData *cake_data)
// {
//   g_free (cake_data-&gt;message);
//   g_slice_free (CakeData, cake_data);
// }
// 
// static void
// bake_cake_thread (GTask         *task,
//                   gpointer       source_object,
//                   gpointer       task_data,
//                   GCancellable  *cancellable)
// {
//   Baker *self = source_object;
//   CakeData *cake_data = task_data;
//   Cake *cake;
//   GError *error = NULL;
// 
//   cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
//                     cake_data-&gt;frosting, cake_data-&gt;message,
//                     cancellable, &amp;error);
//   if (cake)
//     g_task_return_pointer (task, cake, g_object_unref);
//   else
//     g_task_return_error (task, error);
// }
// 
// void
// baker_bake_cake_async (Baker               *self,
//                        guint                radius,
//                        CakeFlavor           flavor,
//                        CakeFrostingType     frosting,
//                        const char          *message,
//                        GCancellable        *cancellable,
//                        GAsyncReadyCallback  callback,
//                        gpointer             user_data)
// {
//   CakeData *cake_data;
//   GTask *task;
// 
//   cake_data = g_slice_new (CakeData);
//   cake_data-&gt;radius = radius;
//   cake_data-&gt;flavor = flavor;
//   cake_data-&gt;frosting = frosting;
//   cake_data-&gt;message = g_strdup (message);
//   task = g_task_new (self, cancellable, callback, user_data);
//   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//   g_task_run_in_thread (task, bake_cake_thread);
//   g_object_unref (task);
// }
// 
// Cake *
// baker_bake_cake_finish (Baker         *self,
//                         GAsyncResult  *result,
//                         GError       **error)
// {
//   g_return_val_if_fail (g_task_is_valid (result, self), NULL);
// 
//   return g_task_propagate_pointer (G_TASK (result), error);
// }
// ```
// 
// ## Adding cancellability to uncancellable tasks
// 
// Finally, [method@Gio.Task.run_in_thread] and
// [method@Gio.Task.run_in_thread_sync] can be used to turn an uncancellable
// operation into a cancellable one. If you call
// [method@Gio.Task.set_return_on_cancel], passing `TRUE`, then if the task&#x2019;s
// [class@Gio.Cancellable] is cancelled, it will return control back to the
// caller immediately, while allowing the task thread to continue running in the
// background (and simply discarding its result when it finally does finish).
// Provided that the task thread is careful about how it uses
// locks and other externally-visible resources, this allows you
// to make &#x2018;GLib-friendly&#x2019; asynchronous and cancellable
// synchronous variants of blocking APIs.
// 
// Cancelling a task:
// ```c
// static void
// bake_cake_thread (GTask         *task,
//                   gpointer       source_object,
//                   gpointer       task_data,
//                   GCancellable  *cancellable)
// {
//   Baker *self = source_object;
//   CakeData *cake_data = task_data;
//   Cake *cake;
//   GError *error = NULL;
// 
//   cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
//                     cake_data-&gt;frosting, cake_data-&gt;message,
//                     &amp;error);
//   if (error)
//     {
//       g_task_return_error (task, error);
//       return;
//     }
// 
//   // If the task has already been cancelled, then we don&#x2019;t want to add
//   // the cake to the cake cache. Likewise, we don&#x2019;t  want to have the
//   // task get cancelled in the middle of updating the cache.
//   // g_task_set_return_on_cancel() will return %TRUE here if it managed
//   // to disable return-on-cancel, or %FALSE if the task was cancelled
//   // before it could.
//   if (g_task_set_return_on_cancel (task, FALSE))
//     {
//       // If the caller cancels at this point, their
//       // GAsyncReadyCallback won&#x2019;t be invoked until we return,
//       // so we don&#x2019;t have to worry that this code will run at
//       // the same time as that code does. But if there were
//       // other functions that might look at the cake cache,
//       // then we&#x2019;d probably need a GMutex here as well.
//       baker_add_cake_to_cache (baker, cake);
//       g_task_return_pointer (task, cake, g_object_unref);
//     }
// }
// 
// void
// baker_bake_cake_async (Baker               *self,
//                        guint                radius,
//                        CakeFlavor           flavor,
//                        CakeFrostingType     frosting,
//                        const char          *message,
//                        GCancellable        *cancellable,
//                        GAsyncReadyCallback  callback,
//                        gpointer             user_data)
// {
//   CakeData *cake_data;
//   GTask *task;
// 
//   cake_data = g_slice_new (CakeData);
// 
//   ...
// 
//   task = g_task_new (self, cancellable, callback, user_data);
//   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//   g_task_set_return_on_cancel (task, TRUE);
//   g_task_run_in_thread (task, bake_cake_thread);
// }
// 
// Cake *
// baker_bake_cake_sync (Baker               *self,
//                       guint                radius,
//                       CakeFlavor           flavor,
//                       CakeFrostingType     frosting,
//                       const char          *message,
//                       GCancellable        *cancellable,
//                       GError             **error)
// {
//   CakeData *cake_data;
//   GTask *task;
//   Cake *cake;
// 
//   cake_data = g_slice_new (CakeData);
// 
//   ...
// 
//   task = g_task_new (self, cancellable, NULL, NULL);
//   g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
//   g_task_set_return_on_cancel (task, TRUE);
//   g_task_run_in_thread_sync (task, bake_cake_thread);
// 
//   cake = g_task_propagate_pointer (task, error);
//   g_object_unref (task);
//   return cake;
// }
// ```
// 
// ## Porting from [class@Gio.SimpleAsyncResult]
// 
// `GTask`&#x2019;s API attempts to be simpler than [class@Gio.SimpleAsyncResult]&#x2019;s
// in several ways:
// 
// - You can save task-specific data with [method@Gio.Task.set_task_data], and
//   retrieve it later with [method@Gio.Task.get_task_data]. This replaces the
//   abuse of [method@Gio.SimpleAsyncResult.set_op_res_gpointer] for the same
//   purpose with [class@Gio.SimpleAsyncResult].
// - In addition to the task data, `GTask` also keeps track of the
//   [priority](iface.AsyncResult.html#io-priority), [class@Gio.Cancellable],
//   and [struct@GLib.MainContext] associated with the task, so tasks that
//   consist of a chain of simpler asynchronous operations will have easy access
//   to those values when starting each sub-task.
// - [method@Gio.Task.return_error_if_cancelled] provides simplified
//   handling for cancellation. In addition, cancellation
//   overrides any other `GTask` return value by default, like
//   [class@Gio.SimpleAsyncResult] does when
//   [method@Gio.SimpleAsyncResult.set_check_cancellable] is called.
//   (You can use [method@Gio.Task.set_check_cancellable] to turn off that
//   behavior.) On the other hand, [method@Gio.Task.run_in_thread]
//   guarantees that it will always run your
//   `task_func`, even if the task&#x2019;s [class@Gio.Cancellable]
//   is already cancelled before the task gets a chance to run;
//   you can start your `task_func` with a
//   [method@Gio.Task.return_error_if_cancelled] check if you need the
//   old behavior.
// - The &#x2018;return&#x2019; methods (eg, [method@Gio.Task.return_pointer])
//   automatically cause the task to be &#x2018;completed&#x2019; as well, and
//   there is no need to worry about the &#x2018;complete&#x2019; vs &#x2018;complete in idle&#x2019;
//   distinction. (`GTask` automatically figures out
//   whether the task&#x2019;s callback can be invoked directly, or
//   if it needs to be sent to another [struct@GLib.MainContext], or delayed
//   until the next iteration of the current [struct@GLib.MainContext].)
// - The &#x2018;finish&#x2019; functions for `GTask` based operations are generally
//   much simpler than [class@Gio.SimpleAsyncResult] ones, normally consisting
//   of only a single call to [method@Gio.Task.propagate_pointer] or the like.
//   Since [method@Gio.Task.propagate_pointer] &#x2018;steals&#x2019; the return value from
//   the `GTask`, it is not necessary to juggle pointers around to
//   prevent it from being freed twice.
// - With [class@Gio.SimpleAsyncResult], it was common to call
//   [method@Gio.SimpleAsyncResult.propagate_error] from the
//   `_finish()` wrapper function, and have
//   virtual method implementations only deal with successful
//   returns. This behavior is deprecated, because it makes it
//   difficult for a subclass to chain to a parent class&#x2019;s async
//   methods. Instead, the wrapper function should just be a
//   simple wrapper, and the virtual method should call an
//   appropriate `g_task_propagate_` function.
//   Note that wrapper methods can now use
//   [method@Gio.AsyncResult.legacy_propagate_error] to do old-style
//   [class@Gio.SimpleAsyncResult] error-returning behavior, and
//   [method@Gio.AsyncResult.is_tagged] to check if a result is tagged as
//   having come from the `_async()` wrapper
//   function (for &#x2018;short-circuit&#x2019; results, such as when passing
//   `0` to [method@Gio.InputStream.read_async]).
// 
// ## Thread-safety considerations
// 
// Due to some infelicities in the API design, there is a
// thread-safety concern that users of `GTask` have to be aware of:
// 
// If the `main` thread drops its last reference to the source object
// or the task data before the task is finalized, then the finalizers
// of these objects may be called on the worker thread.
// 
// This is a problem if the finalizers use non-threadsafe API, and
// can lead to hard-to-debug crashes. Possible workarounds include:
// 
// - Clear task data in a signal handler for `notify::completed`
// - Keep iterating a main context in the main thread and defer
//   dropping the reference to the source object to that main
//   context when the task is finalized
type Task interface {
	gobject.Object
	upcastToGTask() *TaskInstance

	// GetCancellable wraps g_task_get_cancellable
	// 
	// The function returns the following values:
	// 
	// 	- goret Cancellable (nullable) 
	//
	// Gets @task's #GCancellable
	GetCancellable() Cancellable
	// GetCheckCancellable wraps g_task_get_check_cancellable
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets @task's check-cancellable flag. See
	// g_task_set_check_cancellable() for more details.
	GetCheckCancellable() bool
	// GetCompleted wraps g_task_get_completed
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
	// the task&#x2019;s callback is invoked, and will return %FALSE if called from inside
	// the callback.
	GetCompleted() bool
	// GetContext wraps g_task_get_context
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.MainContext 
	//
	// Gets the #GMainContext that @task will return its result in (that
	// is, the context that was the thread-default main context
	// (see [method@GLib.MainContext.push_thread_default])
	// at the point when @task was created).
	// 
	// This will always return a non-%NULL value, even if the task's
	// context is the default #GMainContext.
	GetContext() *glib.MainContext
	// GetName wraps g_task_get_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets @task&#x2019;s name. See g_task_set_name().
	GetName() string
	// GetPriority wraps g_task_get_priority
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	//
	// Gets @task's priority
	GetPriority() int32
	// GetReturnOnCancel wraps g_task_get_return_on_cancel
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets @task's return-on-cancel flag. See
	// g_task_set_return_on_cancel() for more details.
	GetReturnOnCancel() bool
	// HadError wraps g_task_had_error
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests if @task resulted in an error.
	HadError() bool
	// PropagateBoolean wraps g_task_propagate_boolean
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the result of @task as a #gboolean.
	// 
	// If the task resulted in an error, or was cancelled, then this will
	// instead return %FALSE and set @error.
	// 
	// Since this method transfers ownership of the return value (or
	// error) to the caller, you may only call it once.
	PropagateBoolean() (bool, error)
	// PropagateInt wraps g_task_propagate_int
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the result of @task as an integer (#gssize).
	// 
	// If the task resulted in an error, or was cancelled, then this will
	// instead return -1 and set @error.
	// 
	// Since this method transfers ownership of the return value (or
	// error) to the caller, you may only call it once.
	PropagateInt() (int, error)
	// PropagateValue wraps g_task_propagate_value
	// 
	// The function returns the following values:
	// 
	// 	- value gobject.Value: return location for the #GValue 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Gets the result of @task as a #GValue, and transfers ownership of
	// that value to the caller. As with g_task_return_value(), this is
	// a generic low-level method; g_task_propagate_pointer() and the like
	// will usually be more useful for C code.
	// 
	// If the task resulted in an error, or was cancelled, then this will
	// instead set @error and return %FALSE.
	// 
	// Since this method transfers ownership of the return value (or
	// error) to the caller, you may only call it once.
	PropagateValue() (gobject.Value, bool, error)
	// ReturnBoolean wraps g_task_return_boolean
	// 
	// The function takes the following parameters:
	// 
	// 	- result bool: the #gboolean result of a task function. 
	//
	// Sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this
	// means).
	ReturnBoolean(bool)
	// ReturnError wraps g_task_return_error
	// 
	// The function takes the following parameters:
	// 
	// 	- err error: the #GError result of a task function. 
	//
	// Sets @task's result to @error (which @task assumes ownership of)
	// and completes the task (see g_task_return_pointer() for more
	// discussion of exactly what this means).
	// 
	// Note that since the task takes ownership of @error, and since the
	// task may be completed before returning from g_task_return_error(),
	// you cannot assume that @error is still valid after calling this.
	// Call g_error_copy() on the error if you need to keep a local copy
	// as well.
	// 
	// See also [method@Gio.Task.return_new_error],
	// [method@Gio.Task.return_new_error_literal].
	ReturnError(error)
	// ReturnErrorIfCancelled wraps g_task_return_error_if_cancelled
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if @task's #GCancellable has been cancelled, and if so, sets
	// @task's error accordingly and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this
	// means).
	ReturnErrorIfCancelled() bool
	// ReturnInt wraps g_task_return_int
	// 
	// The function takes the following parameters:
	// 
	// 	- result int: the integer (#gssize) result of a task function. 
	//
	// Sets @task's result to @result and completes the task (see
	// g_task_return_pointer() for more discussion of exactly what this
	// means).
	ReturnInt(int)
	// ReturnNewErrorLiteral wraps g_task_return_new_error_literal
	// 
	// The function takes the following parameters:
	// 
	// 	- domain glib.Quark: a #GQuark. 
	// 	- code int32: an error code. 
	// 	- message string: an error message 
	//
	// Sets @task&#x2019;s result to a new [type@GLib.Error] created from @domain, @code,
	// @message and completes the task.
	// 
	// See [method@Gio.Task.return_pointer] for more discussion of exactly what
	// &#x2018;completing the task&#x2019; means.
	// 
	// See also [method@Gio.Task.return_new_error].
	ReturnNewErrorLiteral(glib.Quark, int32, string)
	// ReturnValue wraps g_task_return_value
	// 
	// The function takes the following parameters:
	// 
	// 	- result *gobject.Value (nullable): the #GValue result of
	//                                      a task function 
	//
	// Sets @task's result to @result (by copying it) and completes the task.
	// 
	// If @result is %NULL then a #GValue of type %G_TYPE_POINTER
	// with a value of %NULL will be used for the result.
	// 
	// This is a very generic low-level method intended primarily for use
	// by language bindings; for C code, g_task_return_pointer() and the
	// like will normally be much easier to use.
	ReturnValue(*gobject.Value)
	// SetCheckCancellable wraps g_task_set_check_cancellable
	// 
	// The function takes the following parameters:
	// 
	// 	- checkCancellable bool: whether #GTask will check the state of
	//   its #GCancellable for you. 
	//
	// Sets or clears @task's check-cancellable flag. If this is %TRUE
	// (the default), then g_task_propagate_pointer(), etc, and
	// g_task_had_error() will check the task's #GCancellable first, and
	// if it has been cancelled, then they will consider the task to have
	// returned an "Operation was cancelled" error
	// (%G_IO_ERROR_CANCELLED), regardless of any other error or return
	// value the task may have had.
	// 
	// If @check_cancellable is %FALSE, then the #GTask will not check the
	// cancellable itself, and it is up to @task's owner to do this (eg,
	// via g_task_return_error_if_cancelled()).
	// 
	// If you are using g_task_set_return_on_cancel() as well, then
	// you must leave check-cancellable set %TRUE.
	SetCheckCancellable(bool)
	// SetName wraps g_task_set_name
	// 
	// The function takes the following parameters:
	// 
	// 	- name string (nullable): a human readable name for the task, or %NULL to unset it 
	//
	// Sets @task&#x2019;s name, used in debugging and profiling. The name defaults to
	// %NULL.
	// 
	// The task name should describe in a human readable way what the task does.
	// For example, &#x2018;Open file&#x2019; or &#x2018;Connect to network host&#x2019;. It is used to set the
	// name of the #GSource used for idle completion of the task.
	// 
	// This function may only be called before the @task is first used in a thread
	// other than the one it was constructed in.
	SetName(string)
	// SetPriority wraps g_task_set_priority
	// 
	// The function takes the following parameters:
	// 
	// 	- priority int32: the [priority](iface.AsyncResult.html#io-priority) of the request 
	//
	// Sets @task's priority. If you do not call this, it will default to
	// %G_PRIORITY_DEFAULT.
	// 
	// This will affect the priority of #GSources created with
	// g_task_attach_source() and the scheduling of tasks run in threads,
	// and can also be explicitly retrieved later via
	// g_task_get_priority().
	SetPriority(int32)
	// SetReturnOnCancel wraps g_task_set_return_on_cancel
	// 
	// The function takes the following parameters:
	// 
	// 	- returnOnCancel bool: whether the task returns automatically when
	//   it is cancelled. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Sets or clears @task's return-on-cancel flag. This is only
	// meaningful for tasks run via g_task_run_in_thread() or
	// g_task_run_in_thread_sync().
	// 
	// If @return_on_cancel is %TRUE, then cancelling @task's
	// #GCancellable will immediately cause it to return, as though the
	// task's #GTaskThreadFunc had called
	// g_task_return_error_if_cancelled() and then returned.
	// 
	// This allows you to create a cancellable wrapper around an
	// uninterruptible function. The #GTaskThreadFunc just needs to be
	// careful that it does not modify any externally-visible state after
	// it has been cancelled. To do that, the thread should call
	// g_task_set_return_on_cancel() again to (atomically) set
	// return-on-cancel %FALSE before making externally-visible changes;
	// if the task gets cancelled before the return-on-cancel flag could
	// be changed, g_task_set_return_on_cancel() will indicate this by
	// returning %FALSE.
	// 
	// You can disable and re-enable this flag multiple times if you wish.
	// If the task's #GCancellable is cancelled while return-on-cancel is
	// %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
	// again will cause the task to be cancelled at that point.
	// 
	// If the task's #GCancellable is already cancelled before you call
	// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
	// #GTaskThreadFunc will still be run (for consistency), but the task
	// will also be completed right away.
	SetReturnOnCancel(bool) bool
	// SetStaticName wraps g_task_set_static_name
	// 
	// The function takes the following parameters:
	// 
	// 	- name string (nullable): a human readable name for the task. Must be a string literal 
	//
	// Sets @task&#x2019;s name, used in debugging and profiling.
	// 
	// This is a variant of g_task_set_name() that avoids copying @name.
	// 
	// This function is called automatically by [method@Gio.Task.set_source_tag]
	// unless a name is set.
	SetStaticName(string)
}

func unsafeWrapTask(base *gobject.ObjectInstance) *TaskInstance {
	return &TaskInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTask,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTask(inst)
		},
	)
}

func marshalTaskInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTaskFromGlibNone is used to convert raw GTask pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTaskFromGlibNone(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibNone(c).(Task)
}

// UnsafeTaskFromGlibFull is used to convert raw GTask pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTaskFromGlibFull(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibFull(c).(Task)
}

// UnsafeTaskFromGlibBorrow is used to convert raw GTask pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTaskFromGlibBorrow(c unsafe.Pointer) Task {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Task)
}

func (t *TaskInstance) upcastToGTask() *TaskInstance {
	return t
}

// UnsafeTaskToGlibNone is used to convert the instance to it's C value GTask. This is used by the bindings internally.
func UnsafeTaskToGlibNone(c Task) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTaskToGlibFull is used to convert the instance to it's C value GTask, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTaskToGlibFull(c Task) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetCancellable wraps g_task_get_cancellable
// 
// The function returns the following values:
// 
// 	- goret Cancellable (nullable) 
//
// Gets @task's #GCancellable
func (task *TaskInstance) GetCancellable() Cancellable {
	var carg0 *C.GTask        // in, none, converted
	var cret  *C.GCancellable // return, none, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_cancellable(carg0)
	runtime.KeepAlive(task)

	var goret Cancellable

	if cret != nil {
		goret = UnsafeCancellableFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCheckCancellable wraps g_task_get_check_cancellable
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets @task's check-cancellable flag. See
// g_task_set_check_cancellable() for more details.
func (task *TaskInstance) GetCheckCancellable() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_check_cancellable(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCompleted wraps g_task_get_completed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
// the task&#x2019;s callback is invoked, and will return %FALSE if called from inside
// the callback.
func (task *TaskInstance) GetCompleted() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_completed(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetContext wraps g_task_get_context
// 
// The function returns the following values:
// 
// 	- goret *glib.MainContext 
//
// Gets the #GMainContext that @task will return its result in (that
// is, the context that was the thread-default main context
// (see [method@GLib.MainContext.push_thread_default])
// at the point when @task was created).
// 
// This will always return a non-%NULL value, even if the task's
// context is the default #GMainContext.
func (task *TaskInstance) GetContext() *glib.MainContext {
	var carg0 *C.GTask        // in, none, converted
	var cret  *C.GMainContext // return, none, converted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_context(carg0)
	runtime.KeepAlive(task)

	var goret *glib.MainContext

	goret = glib.UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetName wraps g_task_get_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @task&#x2019;s name. See g_task_set_name().
func (task *TaskInstance) GetName() string {
	var carg0 *C.GTask // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_name(carg0)
	runtime.KeepAlive(task)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPriority wraps g_task_get_priority
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets @task's priority
func (task *TaskInstance) GetPriority() int32 {
	var carg0 *C.GTask // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_priority(carg0)
	runtime.KeepAlive(task)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetReturnOnCancel wraps g_task_get_return_on_cancel
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets @task's return-on-cancel flag. See
// g_task_set_return_on_cancel() for more details.
func (task *TaskInstance) GetReturnOnCancel() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_get_return_on_cancel(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HadError wraps g_task_had_error
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @task resulted in an error.
func (task *TaskInstance) HadError() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_had_error(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PropagateBoolean wraps g_task_propagate_boolean
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets the result of @task as a #gboolean.
// 
// If the task resulted in an error, or was cancelled, then this will
// instead return %FALSE and set @error.
// 
// Since this method transfers ownership of the return value (or
// error) to the caller, you may only call it once.
func (task *TaskInstance) PropagateBoolean() (bool, error) {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_boolean(carg0, &_cerr)
	runtime.KeepAlive(task)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PropagateInt wraps g_task_propagate_int
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Gets the result of @task as an integer (#gssize).
// 
// If the task resulted in an error, or was cancelled, then this will
// instead return -1 and set @error.
// 
// Since this method transfers ownership of the return value (or
// error) to the caller, you may only call it once.
func (task *TaskInstance) PropagateInt() (int, error) {
	var carg0 *C.GTask  // in, none, converted
	var cret  C.gssize  // return, none, casted
	var _cerr *C.GError // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_int(carg0, &_cerr)
	runtime.KeepAlive(task)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PropagateValue wraps g_task_propagate_value
// 
// The function returns the following values:
// 
// 	- value gobject.Value: return location for the #GValue 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets the result of @task as a #GValue, and transfers ownership of
// that value to the caller. As with g_task_return_value(), this is
// a generic low-level method; g_task_propagate_pointer() and the like
// will usually be more useful for C code.
// 
// If the task resulted in an error, or was cancelled, then this will
// instead set @error and return %FALSE.
// 
// Since this method transfers ownership of the return value (or
// error) to the caller, you may only call it once.
func (task *TaskInstance) PropagateValue() (gobject.Value, bool, error) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.GValue   // out, transfer: none, C Pointers: 0, Name: Value, caller-allocates
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_propagate_value(carg0, &carg1, &_cerr)
	runtime.KeepAlive(task)

	var value  gobject.Value
	var goret  bool
	var _goerr error

	_ = value
	_ = carg1
	panic("unimplemented conversion of gobject.Value (GValue) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return value, goret, _goerr
}

// ReturnBoolean wraps g_task_return_boolean
// 
// The function takes the following parameters:
// 
// 	- result bool: the #gboolean result of a task function. 
//
// Sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this
// means).
func (task *TaskInstance) ReturnBoolean(result bool) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if result {
		carg1 = C.TRUE
	}

	C.g_task_return_boolean(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnError wraps g_task_return_error
// 
// The function takes the following parameters:
// 
// 	- err error: the #GError result of a task function. 
//
// Sets @task's result to @error (which @task assumes ownership of)
// and completes the task (see g_task_return_pointer() for more
// discussion of exactly what this means).
// 
// Note that since the task takes ownership of @error, and since the
// task may be completed before returning from g_task_return_error(),
// you cannot assume that @error is still valid after calling this.
// Call g_error_copy() on the error if you need to keep a local copy
// as well.
// 
// See also [method@Gio.Task.return_new_error],
// [method@Gio.Task.return_new_error_literal].
func (task *TaskInstance) ReturnError(err error) {
	var carg0 *C.GTask  // in, none, converted
	var carg1 *C.GError // in, full, converted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = (*C.GError)(glib.UnsafeErrorToGlibFull(err))

	C.g_task_return_error(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(err)
}

// ReturnErrorIfCancelled wraps g_task_return_error_if_cancelled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @task's #GCancellable has been cancelled, and if so, sets
// @task's error accordingly and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this
// means).
func (task *TaskInstance) ReturnErrorIfCancelled() bool {
	var carg0 *C.GTask   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))

	cret = C.g_task_return_error_if_cancelled(carg0)
	runtime.KeepAlive(task)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReturnInt wraps g_task_return_int
// 
// The function takes the following parameters:
// 
// 	- result int: the integer (#gssize) result of a task function. 
//
// Sets @task's result to @result and completes the task (see
// g_task_return_pointer() for more discussion of exactly what this
// means).
func (task *TaskInstance) ReturnInt(result int) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.gssize // in, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.gssize(result)

	C.g_task_return_int(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// ReturnNewErrorLiteral wraps g_task_return_new_error_literal
// 
// The function takes the following parameters:
// 
// 	- domain glib.Quark: a #GQuark. 
// 	- code int32: an error code. 
// 	- message string: an error message 
//
// Sets @task&#x2019;s result to a new [type@GLib.Error] created from @domain, @code,
// @message and completes the task.
// 
// See [method@Gio.Task.return_pointer] for more discussion of exactly what
// &#x2018;completing the task&#x2019; means.
// 
// See also [method@Gio.Task.return_new_error].
func (task *TaskInstance) ReturnNewErrorLiteral(domain glib.Quark, code int32, message string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.GQuark // in, none, casted, alias
	var carg2 C.gint   // in, none, casted
	var carg3 *C.char  // in, none, string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.GQuark(domain)
	carg2 = C.gint(code)
	carg3 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_task_return_new_error_literal(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(task)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)
}

// ReturnValue wraps g_task_return_value
// 
// The function takes the following parameters:
// 
// 	- result *gobject.Value (nullable): the #GValue result of
//                                      a task function 
//
// Sets @task's result to @result (by copying it) and completes the task.
// 
// If @result is %NULL then a #GValue of type %G_TYPE_POINTER
// with a value of %NULL will be used for the result.
// 
// This is a very generic low-level method intended primarily for use
// by language bindings; for C code, g_task_return_pointer() and the
// like will normally be much easier to use.
func (task *TaskInstance) ReturnValue(result *gobject.Value) {
	var carg0 *C.GTask  // in, none, converted
	var carg1 *C.GValue // in, none, converted, nullable

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if result != nil {
		carg1 = (*C.GValue)(gobject.UnsafeValueToGlibUseAnyInstead(result))
	}

	C.g_task_return_value(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

// SetCheckCancellable wraps g_task_set_check_cancellable
// 
// The function takes the following parameters:
// 
// 	- checkCancellable bool: whether #GTask will check the state of
//   its #GCancellable for you. 
//
// Sets or clears @task's check-cancellable flag. If this is %TRUE
// (the default), then g_task_propagate_pointer(), etc, and
// g_task_had_error() will check the task's #GCancellable first, and
// if it has been cancelled, then they will consider the task to have
// returned an "Operation was cancelled" error
// (%G_IO_ERROR_CANCELLED), regardless of any other error or return
// value the task may have had.
// 
// If @check_cancellable is %FALSE, then the #GTask will not check the
// cancellable itself, and it is up to @task's owner to do this (eg,
// via g_task_return_error_if_cancelled()).
// 
// If you are using g_task_set_return_on_cancel() as well, then
// you must leave check-cancellable set %TRUE.
func (task *TaskInstance) SetCheckCancellable(checkCancellable bool) {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if checkCancellable {
		carg1 = C.TRUE
	}

	C.g_task_set_check_cancellable(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(checkCancellable)
}

// SetName wraps g_task_set_name
// 
// The function takes the following parameters:
// 
// 	- name string (nullable): a human readable name for the task, or %NULL to unset it 
//
// Sets @task&#x2019;s name, used in debugging and profiling. The name defaults to
// %NULL.
// 
// The task name should describe in a human readable way what the task does.
// For example, &#x2018;Open file&#x2019; or &#x2018;Connect to network host&#x2019;. It is used to set the
// name of the #GSource used for idle completion of the task.
// 
// This function may only be called before the @task is first used in a thread
// other than the one it was constructed in.
func (task *TaskInstance) SetName(name string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if name != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_task_set_name(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// SetPriority wraps g_task_set_priority
// 
// The function takes the following parameters:
// 
// 	- priority int32: the [priority](iface.AsyncResult.html#io-priority) of the request 
//
// Sets @task's priority. If you do not call this, it will default to
// %G_PRIORITY_DEFAULT.
// 
// This will affect the priority of #GSources created with
// g_task_attach_source() and the scheduling of tasks run in threads,
// and can also be explicitly retrieved later via
// g_task_get_priority().
func (task *TaskInstance) SetPriority(priority int32) {
	var carg0 *C.GTask // in, none, converted
	var carg1 C.gint   // in, none, casted

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	carg1 = C.gint(priority)

	C.g_task_set_priority(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(priority)
}

// SetReturnOnCancel wraps g_task_set_return_on_cancel
// 
// The function takes the following parameters:
// 
// 	- returnOnCancel bool: whether the task returns automatically when
//   it is cancelled. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets or clears @task's return-on-cancel flag. This is only
// meaningful for tasks run via g_task_run_in_thread() or
// g_task_run_in_thread_sync().
// 
// If @return_on_cancel is %TRUE, then cancelling @task's
// #GCancellable will immediately cause it to return, as though the
// task's #GTaskThreadFunc had called
// g_task_return_error_if_cancelled() and then returned.
// 
// This allows you to create a cancellable wrapper around an
// uninterruptible function. The #GTaskThreadFunc just needs to be
// careful that it does not modify any externally-visible state after
// it has been cancelled. To do that, the thread should call
// g_task_set_return_on_cancel() again to (atomically) set
// return-on-cancel %FALSE before making externally-visible changes;
// if the task gets cancelled before the return-on-cancel flag could
// be changed, g_task_set_return_on_cancel() will indicate this by
// returning %FALSE.
// 
// You can disable and re-enable this flag multiple times if you wish.
// If the task's #GCancellable is cancelled while return-on-cancel is
// %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
// again will cause the task to be cancelled at that point.
// 
// If the task's #GCancellable is already cancelled before you call
// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
// #GTaskThreadFunc will still be run (for consistency), but the task
// will also be completed right away.
func (task *TaskInstance) SetReturnOnCancel(returnOnCancel bool) bool {
	var carg0 *C.GTask   // in, none, converted
	var carg1 C.gboolean // in
	var cret  C.gboolean // return

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if returnOnCancel {
		carg1 = C.TRUE
	}

	cret = C.g_task_set_return_on_cancel(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(returnOnCancel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetStaticName wraps g_task_set_static_name
// 
// The function takes the following parameters:
// 
// 	- name string (nullable): a human readable name for the task. Must be a string literal 
//
// Sets @task&#x2019;s name, used in debugging and profiling.
// 
// This is a variant of g_task_set_name() that avoids copying @name.
// 
// This function is called automatically by [method@Gio.Task.set_source_tag]
// unless a name is set.
func (task *TaskInstance) SetStaticName(name string) {
	var carg0 *C.GTask // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GTask)(UnsafeTaskToGlibNone(task))
	if name != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_task_set_static_name(carg0, carg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(name)
}

// TcpConnectionInstance is the instance type used by all types extending GTcpConnection. It is used internally by the bindings. Users should use the interface [TcpConnection] instead.
type TcpConnectionInstance struct {
	_ [0]func() // equal guard
	SocketConnectionInstance
}

var _ TcpConnection = (*TcpConnectionInstance)(nil)

// TcpConnection wraps GTcpConnection
//
// This is the subclass of [class@Gio.SocketConnection] that is created
// for TCP/IP sockets.
type TcpConnection interface {
	SocketConnection
	upcastToGTcpConnection() *TcpConnectionInstance

	// GetGracefulDisconnect wraps g_tcp_connection_get_graceful_disconnect
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if graceful disconnects are used. See
	// g_tcp_connection_set_graceful_disconnect().
	GetGracefulDisconnect() bool
	// SetGracefulDisconnect wraps g_tcp_connection_set_graceful_disconnect
	// 
	// The function takes the following parameters:
	// 
	// 	- gracefulDisconnect bool: Whether to do graceful disconnects or not 
	//
	// This enables graceful disconnects on close. A graceful disconnect
	// means that we signal the receiving end that the connection is terminated
	// and wait for it to close the connection before closing the connection.
	// 
	// A graceful disconnect means that we can be sure that we successfully sent
	// all the outstanding data to the other end, or get an error reported.
	// However, it also means we have to wait for all the data to reach the
	// other side and for it to acknowledge this by closing the socket, which may
	// take a while. For this reason it is disabled by default.
	SetGracefulDisconnect(bool)

	// chain up virtual methods:
}

func unsafeWrapTcpConnection(base *gobject.ObjectInstance) *TcpConnectionInstance {
	return &TcpConnectionInstance{
		SocketConnectionInstance: SocketConnectionInstance{
			IOStreamInstance: IOStreamInstance{
				ObjectInstance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTcpConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpConnection(inst)
		},
	)
}

func marshalTcpConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTcpConnectionFromGlibNone is used to convert raw GTcpConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibNone(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TcpConnection)
}

// UnsafeTcpConnectionFromGlibFull is used to convert raw GTcpConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibFull(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TcpConnection)
}

// UnsafeTcpConnectionFromGlibBorrow is used to convert raw GTcpConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTcpConnectionFromGlibBorrow(c unsafe.Pointer) TcpConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TcpConnection)
}

func (t *TcpConnectionInstance) upcastToGTcpConnection() *TcpConnectionInstance {
	return t
}

// UnsafeTcpConnectionToGlibNone is used to convert the instance to it's C value GTcpConnection. This is used by the bindings internally.
func UnsafeTcpConnectionToGlibNone(c TcpConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTcpConnectionToGlibFull is used to convert the instance to it's C value GTcpConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTcpConnectionToGlibFull(c TcpConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetGracefulDisconnect wraps g_tcp_connection_get_graceful_disconnect
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if graceful disconnects are used. See
// g_tcp_connection_set_graceful_disconnect().
func (connection *TcpConnectionInstance) GetGracefulDisconnect() bool {
	var carg0 *C.GTcpConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTcpConnection)(UnsafeTcpConnectionToGlibNone(connection))

	cret = C.g_tcp_connection_get_graceful_disconnect(carg0)
	runtime.KeepAlive(connection)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetGracefulDisconnect wraps g_tcp_connection_set_graceful_disconnect
// 
// The function takes the following parameters:
// 
// 	- gracefulDisconnect bool: Whether to do graceful disconnects or not 
//
// This enables graceful disconnects on close. A graceful disconnect
// means that we signal the receiving end that the connection is terminated
// and wait for it to close the connection before closing the connection.
// 
// A graceful disconnect means that we can be sure that we successfully sent
// all the outstanding data to the other end, or get an error reported.
// However, it also means we have to wait for all the data to reach the
// other side and for it to acknowledge this by closing the socket, which may
// take a while. For this reason it is disabled by default.
func (connection *TcpConnectionInstance) SetGracefulDisconnect(gracefulDisconnect bool) {
	var carg0 *C.GTcpConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTcpConnection)(UnsafeTcpConnectionToGlibNone(connection))
	if gracefulDisconnect {
		carg1 = C.TRUE
	}

	C.g_tcp_connection_set_graceful_disconnect(carg0, carg1)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(gracefulDisconnect)
}

// TcpConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TcpConnectionOverrides[Instance TcpConnection] struct {
	// SocketConnectionOverrides allows you to override virtual methods from the parent class SocketConnection
	SocketConnectionOverrides[Instance]

}

// UnsafeApplyTcpConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTcpConnectionOverrides[Instance TcpConnection](gclass unsafe.Pointer, overrides TcpConnectionOverrides[Instance]) {
	UnsafeApplySocketConnectionOverrides(gclass, overrides.SocketConnectionOverrides)
}

// RegisterTcpConnectionSubClass is used to register a go subclass of GTcpConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTcpConnectionSubClass[InstanceT TcpConnection](
		name string,
		classInit func(class *TcpConnectionClass),
		constructor func() InstanceT,
		overrides TcpConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTcpConnection,
		UnsafeTcpConnectionClassFromGlibBorrow,
		UnsafeApplyTcpConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpConnection(obj)
		},
		interfaceInits...,
	)
}

// TcpWrapperConnectionInstance is the instance type used by all types extending GTcpWrapperConnection. It is used internally by the bindings. Users should use the interface [TcpWrapperConnection] instead.
type TcpWrapperConnectionInstance struct {
	_ [0]func() // equal guard
	TcpConnectionInstance
}

var _ TcpWrapperConnection = (*TcpWrapperConnectionInstance)(nil)

// TcpWrapperConnection wraps GTcpWrapperConnection
//
// A `GTcpWrapperConnection` can be used to wrap a [class@Gio.IOStream] that is
// based on a [class@Gio.Socket], but which is not actually a
// [class@Gio.SocketConnection]. This is used by [class@Gio.SocketClient] so
// that it can always return a [class@Gio.SocketConnection], even when the
// connection it has actually created is not directly a
// [class@Gio.SocketConnection].
type TcpWrapperConnection interface {
	TcpConnection
	upcastToGTcpWrapperConnection() *TcpWrapperConnectionInstance

	// GetBaseIOStream wraps g_tcp_wrapper_connection_get_base_io_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret IOStream 
	//
	// Gets @conn's base #GIOStream
	GetBaseIOStream() IOStream

	// chain up virtual methods:
}

func unsafeWrapTcpWrapperConnection(base *gobject.ObjectInstance) *TcpWrapperConnectionInstance {
	return &TcpWrapperConnectionInstance{
		TcpConnectionInstance: TcpConnectionInstance{
			SocketConnectionInstance: SocketConnectionInstance{
				IOStreamInstance: IOStreamInstance{
					ObjectInstance: *base,
				},
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTcpWrapperConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpWrapperConnection(inst)
		},
	)
}

func marshalTcpWrapperConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTcpWrapperConnectionFromGlibNone is used to convert raw GTcpWrapperConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibNone(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TcpWrapperConnection)
}

// UnsafeTcpWrapperConnectionFromGlibFull is used to convert raw GTcpWrapperConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibFull(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TcpWrapperConnection)
}

// UnsafeTcpWrapperConnectionFromGlibBorrow is used to convert raw GTcpWrapperConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionFromGlibBorrow(c unsafe.Pointer) TcpWrapperConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TcpWrapperConnection)
}

func (t *TcpWrapperConnectionInstance) upcastToGTcpWrapperConnection() *TcpWrapperConnectionInstance {
	return t
}

// UnsafeTcpWrapperConnectionToGlibNone is used to convert the instance to it's C value GTcpWrapperConnection. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionToGlibNone(c TcpWrapperConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTcpWrapperConnectionToGlibFull is used to convert the instance to it's C value GTcpWrapperConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionToGlibFull(c TcpWrapperConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTcpWrapperConnection wraps g_tcp_wrapper_connection_new
// 
// The function takes the following parameters:
// 
// 	- baseIoStream IOStream: the #GIOStream to wrap 
// 	- socket Socket: the #GSocket associated with @base_io_stream 
// 
// The function returns the following values:
// 
// 	- goret SocketConnection 
//
// Wraps @base_io_stream and @socket together as a #GSocketConnection.
func NewTcpWrapperConnection(baseIoStream IOStream, socket Socket) SocketConnection {
	var carg1 *C.GIOStream         // in, none, converted
	var carg2 *C.GSocket           // in, none, converted
	var cret  *C.GSocketConnection // return, full, converted

	carg1 = (*C.GIOStream)(UnsafeIOStreamToGlibNone(baseIoStream))
	carg2 = (*C.GSocket)(UnsafeSocketToGlibNone(socket))

	cret = C.g_tcp_wrapper_connection_new(carg1, carg2)
	runtime.KeepAlive(baseIoStream)
	runtime.KeepAlive(socket)

	var goret SocketConnection

	goret = UnsafeSocketConnectionFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetBaseIOStream wraps g_tcp_wrapper_connection_get_base_io_stream
// 
// The function returns the following values:
// 
// 	- goret IOStream 
//
// Gets @conn's base #GIOStream
func (conn *TcpWrapperConnectionInstance) GetBaseIOStream() IOStream {
	var carg0 *C.GTcpWrapperConnection // in, none, converted
	var cret  *C.GIOStream             // return, none, converted

	carg0 = (*C.GTcpWrapperConnection)(UnsafeTcpWrapperConnectionToGlibNone(conn))

	cret = C.g_tcp_wrapper_connection_get_base_io_stream(carg0)
	runtime.KeepAlive(conn)

	var goret IOStream

	goret = UnsafeIOStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// TcpWrapperConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TcpWrapperConnectionOverrides[Instance TcpWrapperConnection] struct {
	// TcpConnectionOverrides allows you to override virtual methods from the parent class TcpConnection
	TcpConnectionOverrides[Instance]

}

// UnsafeApplyTcpWrapperConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTcpWrapperConnectionOverrides[Instance TcpWrapperConnection](gclass unsafe.Pointer, overrides TcpWrapperConnectionOverrides[Instance]) {
	UnsafeApplyTcpConnectionOverrides(gclass, overrides.TcpConnectionOverrides)
}

// RegisterTcpWrapperConnectionSubClass is used to register a go subclass of GTcpWrapperConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTcpWrapperConnectionSubClass[InstanceT TcpWrapperConnection](
		name string,
		classInit func(class *TcpWrapperConnectionClass),
		constructor func() InstanceT,
		overrides TcpWrapperConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTcpWrapperConnection,
		UnsafeTcpWrapperConnectionClassFromGlibBorrow,
		UnsafeApplyTcpWrapperConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTcpWrapperConnection(obj)
		},
		interfaceInits...,
	)
}

// ThemedIconInstance is the instance type used by all types extending GThemedIcon. It is used internally by the bindings. Users should use the interface [ThemedIcon] instead.
type ThemedIconInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ThemedIcon = (*ThemedIconInstance)(nil)

// ThemedIcon wraps GThemedIcon
//
// `GThemedIcon` is an implementation of [iface@Gio.Icon] that supports icon
// themes.
// 
// `GThemedIcon` contains a list of all of the icons present in an icon
// theme, so that icons can be looked up quickly. `GThemedIcon` does
// not provide actual pixmaps for icons, just the icon names.
// Ideally something like [method@Gtk.IconTheme.choose_icon] should be used to
// resolve the list of names so that fallback icons work nicely with
// themes that inherit other themes.
type ThemedIcon interface {
	gobject.Object
	upcastToGThemedIcon() *ThemedIconInstance

	// AppendName wraps g_themed_icon_append_name
	// 
	// The function takes the following parameters:
	// 
	// 	- iconname string: name of icon to append to list of icons from within @icon. 
	//
	// Append a name to the list of icons from within @icon.
	// 
	// Note that doing so invalidates the hash computed by prior calls
	// to g_icon_hash().
	AppendName(string)
	// GetNames wraps g_themed_icon_get_names
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets the names of icons from within @icon.
	GetNames() []string
	// PrependName wraps g_themed_icon_prepend_name
	// 
	// The function takes the following parameters:
	// 
	// 	- iconname string: name of icon to prepend to list of icons from within @icon. 
	//
	// Prepend a name to the list of icons from within @icon.
	// 
	// Note that doing so invalidates the hash computed by prior calls
	// to g_icon_hash().
	PrependName(string)
}

func unsafeWrapThemedIcon(base *gobject.ObjectInstance) *ThemedIconInstance {
	return &ThemedIconInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeThemedIcon,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThemedIcon(inst)
		},
	)
}

func marshalThemedIconInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeThemedIconFromGlibNone is used to convert raw GThemedIcon pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeThemedIconFromGlibNone(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibNone(c).(ThemedIcon)
}

// UnsafeThemedIconFromGlibFull is used to convert raw GThemedIcon pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeThemedIconFromGlibFull(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibFull(c).(ThemedIcon)
}

// UnsafeThemedIconFromGlibBorrow is used to convert raw GThemedIcon pointers to go without touching any references. This is used by the bindings internally.
func UnsafeThemedIconFromGlibBorrow(c unsafe.Pointer) ThemedIcon {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ThemedIcon)
}

func (t *ThemedIconInstance) upcastToGThemedIcon() *ThemedIconInstance {
	return t
}

// UnsafeThemedIconToGlibNone is used to convert the instance to it's C value GThemedIcon. This is used by the bindings internally.
func UnsafeThemedIconToGlibNone(c ThemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeThemedIconToGlibFull is used to convert the instance to it's C value GThemedIcon, while removeing the finalizer. This is used by the bindings internally.
func UnsafeThemedIconToGlibFull(c ThemedIcon) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewThemedIcon wraps g_themed_icon_new
// 
// The function takes the following parameters:
// 
// 	- iconname string: a string containing an icon name. 
// 
// The function returns the following values:
// 
// 	- goret ThemedIcon 
//
// Creates a new themed icon for @iconname.
func NewThemedIcon(iconname string) ThemedIcon {
	var carg1 *C.char  // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_themed_icon_new(carg1)
	runtime.KeepAlive(iconname)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewThemedIconFromNames wraps g_themed_icon_new_from_names
// 
// The function takes the following parameters:
// 
// 	- iconnames []string: an array of strings containing icon names. 
// 
// The function returns the following values:
// 
// 	- goret ThemedIcon 
//
// Creates a new themed icon for @iconnames.
func NewThemedIconFromNames(iconnames []string) ThemedIcon {
	var carg1 **C.char // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), length-by: carg2)
	var carg2 C.int    // implicit
	var cret  *C.GIcon // return, full, converted

	_ = iconnames
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []string (char**) because of unimplemented: inner pointers in array")

	cret = C.g_themed_icon_new_from_names(carg1, carg2)
	runtime.KeepAlive(iconnames)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewThemedIconWithDefaultFallbacks wraps g_themed_icon_new_with_default_fallbacks
// 
// The function takes the following parameters:
// 
// 	- iconname string: a string containing an icon name 
// 
// The function returns the following values:
// 
// 	- goret ThemedIcon 
//
// Creates a new themed icon for @iconname, and all the names
// that can be created by shortening @iconname at '-' characters.
// 
// In the following example, @icon1 and @icon2 are equivalent:
// |[&lt;!-- language="C" --&gt;
// const char *names[] = {
//   "gnome-dev-cdrom-audio",
//   "gnome-dev-cdrom",
//   "gnome-dev",
//   "gnome"
// };
// 
// icon1 = g_themed_icon_new_from_names (names, 4);
// icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
// ]|
func NewThemedIconWithDefaultFallbacks(iconname string) ThemedIcon {
	var carg1 *C.char  // in, none, string
	var cret  *C.GIcon // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_themed_icon_new_with_default_fallbacks(carg1)
	runtime.KeepAlive(iconname)

	var goret ThemedIcon

	goret = UnsafeThemedIconFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// AppendName wraps g_themed_icon_append_name
// 
// The function takes the following parameters:
// 
// 	- iconname string: name of icon to append to list of icons from within @icon. 
//
// Append a name to the list of icons from within @icon.
// 
// Note that doing so invalidates the hash computed by prior calls
// to g_icon_hash().
func (icon *ThemedIconInstance) AppendName(iconname string) {
	var carg0 *C.GThemedIcon // in, none, converted
	var carg1 *C.char        // in, none, string

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_themed_icon_append_name(carg0, carg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// GetNames wraps g_themed_icon_get_names
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the names of icons from within @icon.
func (icon *ThemedIconInstance) GetNames() []string {
	var carg0 *C.GThemedIcon // in, none, converted
	var cret  **C.gchar      // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))

	cret = C.g_themed_icon_get_names(carg0)
	runtime.KeepAlive(icon)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// PrependName wraps g_themed_icon_prepend_name
// 
// The function takes the following parameters:
// 
// 	- iconname string: name of icon to prepend to list of icons from within @icon. 
//
// Prepend a name to the list of icons from within @icon.
// 
// Note that doing so invalidates the hash computed by prior calls
// to g_icon_hash().
func (icon *ThemedIconInstance) PrependName(iconname string) {
	var carg0 *C.GThemedIcon // in, none, converted
	var carg1 *C.char        // in, none, string

	carg0 = (*C.GThemedIcon)(UnsafeThemedIconToGlibNone(icon))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(iconname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_themed_icon_prepend_name(carg0, carg1)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(iconname)
}

// ThreadedSocketServiceInstance is the instance type used by all types extending GThreadedSocketService. It is used internally by the bindings. Users should use the interface [ThreadedSocketService] instead.
type ThreadedSocketServiceInstance struct {
	_ [0]func() // equal guard
	SocketServiceInstance
}

var _ ThreadedSocketService = (*ThreadedSocketServiceInstance)(nil)

// ThreadedSocketService wraps GThreadedSocketService
//
// A `GThreadedSocketService` is a simple subclass of [class@Gio.SocketService]
// that handles incoming connections by creating a worker thread and
// dispatching the connection to it by emitting the
// [signal@Gio.ThreadedSocketService::run signal] in the new thread.
// 
// The signal handler may perform blocking I/O and need not return
// until the connection is closed.
// 
// The service is implemented using a thread pool, so there is a
// limited amount of threads available to serve incoming requests.
// The service automatically stops the [class@Gio.SocketService] from accepting
// new connections when all threads are busy.
// 
// As with [class@Gio.SocketService], you may connect to
// [signal@Gio.ThreadedSocketService::run], or subclass and override the default
// handler.
type ThreadedSocketService interface {
	SocketService
	upcastToGThreadedSocketService() *ThreadedSocketServiceInstance

	// ConnectRun connects the provided callback to the "run" signal
	//
	// The ::run signal is emitted in a worker thread in response to an
	// incoming connection. This thread is dedicated to handling
	// @connection and may perform blocking IO. The signal handler need
	// not return until the connection is closed.
	ConnectRun(func(ThreadedSocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentRun calls the default implementations of the `GThreadedSocketService.run` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection SocketConnection 
	// 	- sourceObject gobject.Object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentRun(connection SocketConnection, sourceObject gobject.Object) bool
}

func unsafeWrapThreadedSocketService(base *gobject.ObjectInstance) *ThreadedSocketServiceInstance {
	return &ThreadedSocketServiceInstance{
		SocketServiceInstance: SocketServiceInstance{
			SocketListenerInstance: SocketListenerInstance{
				ObjectInstance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeThreadedSocketService,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThreadedSocketService(inst)
		},
	)
}

func marshalThreadedSocketServiceInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeThreadedSocketServiceFromGlibNone is used to convert raw GThreadedSocketService pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibNone(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibNone(c).(ThreadedSocketService)
}

// UnsafeThreadedSocketServiceFromGlibFull is used to convert raw GThreadedSocketService pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibFull(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibFull(c).(ThreadedSocketService)
}

// UnsafeThreadedSocketServiceFromGlibBorrow is used to convert raw GThreadedSocketService pointers to go without touching any references. This is used by the bindings internally.
func UnsafeThreadedSocketServiceFromGlibBorrow(c unsafe.Pointer) ThreadedSocketService {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ThreadedSocketService)
}

func (t *ThreadedSocketServiceInstance) upcastToGThreadedSocketService() *ThreadedSocketServiceInstance {
	return t
}

// UnsafeThreadedSocketServiceToGlibNone is used to convert the instance to it's C value GThreadedSocketService. This is used by the bindings internally.
func UnsafeThreadedSocketServiceToGlibNone(c ThreadedSocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeThreadedSocketServiceToGlibFull is used to convert the instance to it's C value GThreadedSocketService, while removeing the finalizer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceToGlibFull(c ThreadedSocketService) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewThreadedSocketService wraps g_threaded_socket_service_new
// 
// The function takes the following parameters:
// 
// 	- maxThreads int32: the maximal number of threads to execute concurrently
//   handling incoming clients, -1 means no limit 
// 
// The function returns the following values:
// 
// 	- goret SocketService 
//
// Creates a new #GThreadedSocketService with no listeners. Listeners
// must be added with one of the #GSocketListener "add" methods.
func NewThreadedSocketService(maxThreads int32) SocketService {
	var carg1 C.int             // in, none, casted
	var cret  *C.GSocketService // return, full, converted

	carg1 = C.int(maxThreads)

	cret = C.g_threaded_socket_service_new(carg1)
	runtime.KeepAlive(maxThreads)

	var goret SocketService

	goret = UnsafeSocketServiceFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ConnectRun connects the provided callback to the "run" signal
//
// The ::run signal is emitted in a worker thread in response to an
// incoming connection. This thread is dedicated to handling
// @connection and may perform blocking IO. The signal handler need
// not return until the connection is closed.
func (o *ThreadedSocketServiceInstance) ConnectRun(fn func(ThreadedSocketService, SocketConnection, gobject.Object) bool) gobject.SignalHandle {
	return o.Connect("run", fn)
}

// ThreadedSocketServiceOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ThreadedSocketServiceOverrides[Instance ThreadedSocketService] struct {
	// SocketServiceOverrides allows you to override virtual methods from the parent class SocketService
	SocketServiceOverrides[Instance]

	// // Run allows you to override the implementation of the virtual method run.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection SocketConnection 
	// 	- sourceObject gobject.Object 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	Run func(Instance, SocketConnection, gobject.Object) bool
}

// UnsafeApplyThreadedSocketServiceOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyThreadedSocketServiceOverrides[Instance ThreadedSocketService](gclass unsafe.Pointer, overrides ThreadedSocketServiceOverrides[Instance]) {
	UnsafeApplySocketServiceOverrides(gclass, overrides.SocketServiceOverrides)

	pclass := (*C.GThreadedSocketServiceClass)(gclass)

	if overrides.Run != nil {
		pclass.run = (*[0]byte)(C._goglib_gio2_ThreadedSocketService_run)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_ThreadedSocketService_run",
			func(carg0 *C.GThreadedSocketService, carg1 *C.GSocketConnection, carg2 *C.GObject) (cret C.gboolean) {
				var service      Instance         // go GThreadedSocketService subclass
				var connection   SocketConnection // in, none, converted
				var sourceObject gobject.Object   // in, none, converted
				var goret        bool             // return

				service = UnsafeThreadedSocketServiceFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeSocketConnectionFromGlibNone(unsafe.Pointer(carg1))
				sourceObject = gobject.UnsafeObjectFromGlibNone(unsafe.Pointer(carg2))

				goret = overrides.Run(service, connection, sourceObject)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}
}

// ParentRun calls the default implementations of the `GThreadedSocketService.run` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- connection SocketConnection 
// 	- sourceObject gobject.Object 
// 
// The function returns the following values:
// 
// 	- goret bool 
func (service *ThreadedSocketServiceInstance) ParentRun(connection SocketConnection, sourceObject gobject.Object) bool {
	var carg0 *C.GThreadedSocketService
	var carg1 *C.GSocketConnection // in, none, converted
	var carg2 *C.GObject           // in, none, converted
	var cret  C.gboolean           // return

	parentclass := (*C.GThreadedSocketServiceClass)(classdata.PeekParentClass(UnsafeThreadedSocketServiceToGlibNone(service)))

	carg0 = (*C.GThreadedSocketService)(UnsafeThreadedSocketServiceToGlibNone(service))
	carg1 = (*C.GSocketConnection)(UnsafeSocketConnectionToGlibNone(connection))
	carg2 = (*C.GObject)(gobject.UnsafeObjectToGlibNone(sourceObject))

	cret = C._goglib_gio2_ThreadedSocketService_virtual_run(unsafe.Pointer(parentclass.run), carg0, carg1, carg2)
	runtime.KeepAlive(service)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(sourceObject)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegisterThreadedSocketServiceSubClass is used to register a go subclass of GThreadedSocketService. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterThreadedSocketServiceSubClass[InstanceT ThreadedSocketService](
		name string,
		classInit func(class *ThreadedSocketServiceClass),
		constructor func() InstanceT,
		overrides ThreadedSocketServiceOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeThreadedSocketService,
		UnsafeThreadedSocketServiceClassFromGlibBorrow,
		UnsafeApplyThreadedSocketServiceOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapThreadedSocketService(obj)
		},
		interfaceInits...,
	)
}

// TlsCertificateInstance is the instance type used by all types extending GTlsCertificate. It is used internally by the bindings. Users should use the interface [TlsCertificate] instead.
type TlsCertificateInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsCertificate = (*TlsCertificateInstance)(nil)

// TlsCertificate wraps GTlsCertificate
//
// A certificate used for TLS authentication and encryption.
// This can represent either a certificate only (eg, the certificate
// received by a client from a server), or the combination of
// a certificate and a private key (which is needed when acting as a
// [iface@Gio.TlsServerConnection]).
type TlsCertificate interface {
	gobject.Object
	upcastToGTlsCertificate() *TlsCertificateInstance

	// GetIssuer wraps g_tls_certificate_get_issuer
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	//
	// Gets the #GTlsCertificate representing @cert's issuer, if known
	GetIssuer() TlsCertificate
	// GetIssuerName wraps g_tls_certificate_get_issuer_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Returns the issuer name from the certificate.
	GetIssuerName() string
	// GetSubjectName wraps g_tls_certificate_get_subject_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Returns the subject name from the certificate.
	GetSubjectName() string
	// IsSame wraps g_tls_certificate_is_same
	// 
	// The function takes the following parameters:
	// 
	// 	- certTwo TlsCertificate: second certificate to compare 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check if two #GTlsCertificate objects represent the same certificate.
	// The raw DER byte data of the two certificates are checked for equality.
	// This has the effect that two certificates may compare equal even if
	// their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
	// #GTlsCertificate:private-key-pem properties differ.
	IsSame(TlsCertificate) bool
	// Verify wraps g_tls_certificate_verify
	// 
	// The function takes the following parameters:
	// 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- trustedCa TlsCertificate (nullable): the certificate of a trusted authority 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// This verifies @cert and returns a set of #GTlsCertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to
	// check a certificate against a CA that is not part of the system
	// CA database.
	// 
	// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
	// 
	// If @identity is not %NULL, @cert's name(s) will be compared against
	// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
	// value if it does not match. If @identity is %NULL, that bit will
	// never be set in the return value.
	// 
	// If @trusted_ca is not %NULL, then @cert (or one of the certificates
	// in its chain) must be signed by it, or else
	// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
	// @trusted_ca is %NULL, that bit will never be set in the return
	// value.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Because TLS session context is not used, #GTlsCertificate may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	Verify(SocketConnectable, TlsCertificate) TlsCertificateFlags

	// chain up virtual methods:

	// ParentVerify calls the default implementations of the `GTlsCertificate.verify` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- trustedCa TlsCertificate (nullable): the certificate of a trusted authority 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// This verifies @cert and returns a set of #GTlsCertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to
	// check a certificate against a CA that is not part of the system
	// CA database.
	// 
	// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
	// 
	// If @identity is not %NULL, @cert's name(s) will be compared against
	// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
	// value if it does not match. If @identity is %NULL, that bit will
	// never be set in the return value.
	// 
	// If @trusted_ca is not %NULL, then @cert (or one of the certificates
	// in its chain) must be signed by it, or else
	// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
	// @trusted_ca is %NULL, that bit will never be set in the return
	// value.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Because TLS session context is not used, #GTlsCertificate may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	ParentVerify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags
}

func unsafeWrapTlsCertificate(base *gobject.ObjectInstance) *TlsCertificateInstance {
	return &TlsCertificateInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsCertificate,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsCertificate(inst)
		},
	)
}

func marshalTlsCertificateInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsCertificateFromGlibNone is used to convert raw GTlsCertificate pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibNone(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsCertificate)
}

// UnsafeTlsCertificateFromGlibFull is used to convert raw GTlsCertificate pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibFull(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsCertificate)
}

// UnsafeTlsCertificateFromGlibBorrow is used to convert raw GTlsCertificate pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsCertificateFromGlibBorrow(c unsafe.Pointer) TlsCertificate {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsCertificate)
}

func (t *TlsCertificateInstance) upcastToGTlsCertificate() *TlsCertificateInstance {
	return t
}

// UnsafeTlsCertificateToGlibNone is used to convert the instance to it's C value GTlsCertificate. This is used by the bindings internally.
func UnsafeTlsCertificateToGlibNone(c TlsCertificate) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsCertificateToGlibFull is used to convert the instance to it's C value GTlsCertificate, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsCertificateToGlibFull(c TlsCertificate) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTlsCertificateFromFile wraps g_tls_certificate_new_from_file
// 
// The function takes the following parameters:
// 
// 	- file string: file containing a certificate to import 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from the data in @file.
// 
// As of 2.72, if the filename ends in `.p12` or `.pfx` the data is loaded by
// g_tls_certificate_new_from_pkcs12() otherwise it is loaded by
// g_tls_certificate_new_from_pem(). See those functions for
// exact details.
// 
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
func NewTlsCertificateFromFile(file string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_certificate_new_from_file(carg1, &_cerr)
	runtime.KeepAlive(file)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromFileWithPassword wraps g_tls_certificate_new_from_file_with_password
// 
// The function takes the following parameters:
// 
// 	- file string: file containing a certificate to import 
// 	- password string: password for PKCS #12 files 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from the data in @file.
// 
// If @file cannot be read or parsed, the function will return %NULL and
// set @error.
// 
// Any unknown file types will error with %G_IO_ERROR_NOT_SUPPORTED.
// Currently only `.p12` and `.pfx` files are supported.
// See g_tls_certificate_new_from_pkcs12() for more details.
func NewTlsCertificateFromFileWithPassword(file string, password string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_certificate_new_from_file_with_password(carg1, carg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(password)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromFiles wraps g_tls_certificate_new_from_files
// 
// The function takes the following parameters:
// 
// 	- certFile string: file containing one or more PEM-encoded
//     certificates to import 
// 	- keyFile string: file containing a PEM-encoded private key
//     to import 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from the PEM-encoded data in @cert_file
// and @key_file. The returned certificate will be the first certificate
// found in @cert_file. As of GLib 2.44, if @cert_file contains more
// certificates it will try to load a certificate chain. All
// certificates will be verified in the order found (top-level
// certificate should be the last one in the file) and the
// #GTlsCertificate:issuer property of each certificate will be set
// accordingly if the verification succeeds. If any certificate in the
// chain cannot be verified, the first certificate in the file will
// still be returned.
// 
// If either file cannot be read or parsed, the function will return
// %NULL and set @error. Otherwise, this behaves like
// g_tls_certificate_new_from_pem().
func NewTlsCertificateFromFiles(certFile string, keyFile string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(certFile)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(keyFile)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_certificate_new_from_files(carg1, carg2, &_cerr)
	runtime.KeepAlive(certFile)
	runtime.KeepAlive(keyFile)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPem wraps g_tls_certificate_new_from_pem
// 
// The function takes the following parameters:
// 
// 	- data string: PEM-encoded certificate data 
// 	- length int: the length of @data, or -1 if it's 0-terminated. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from the PEM-encoded data in @data. If
// @data includes both a certificate and a private key, then the
// returned certificate will include the private key data as well. (See
// the #GTlsCertificate:private-key-pem property for information about
// supported formats.)
// 
// The returned certificate will be the first certificate found in
// @data. As of GLib 2.44, if @data contains more certificates it will
// try to load a certificate chain. All certificates will be verified in
// the order found (top-level certificate should be the last one in the
// file) and the #GTlsCertificate:issuer property of each certificate
// will be set accordingly if the verification succeeds. If any
// certificate in the chain cannot be verified, the first certificate in
// the file will still be returned.
func NewTlsCertificateFromPem(data string, length int) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 C.gssize           // in, none, casted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(data)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)

	cret = C.g_tls_certificate_new_from_pem(carg1, carg2, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPkcs11Uris wraps g_tls_certificate_new_from_pkcs11_uris
// 
// The function takes the following parameters:
// 
// 	- pkcs11Uri string: A PKCS \#11 URI 
// 	- privateKeyPkcs11Uri string (nullable): A PKCS \#11 URI 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from a
// [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html) URI.
// 
// An example @pkcs11_uri would be `pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01`
// 
// Where the token&#x2019;s layout is:
// 
// |[
// Object 0:
//   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=private%20key;type=private
//   Type: Private key (RSA-2048)
//   ID: 01
// 
// Object 1:
//   URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My%20Client%20Certificate;id=%01;object=Certificate%20for%20Authentication;type=cert
//   Type: X.509 Certificate (RSA-2048)
//   ID: 01
// ]|
// 
// In this case the certificate and private key would both be detected and used as expected.
// @pkcs_uri may also just reference an X.509 certificate object and then optionally
// @private_key_pkcs11_uri allows using a private key exposed under a different URI.
// 
// Note that the private key is not accessed until usage and may fail or require a PIN later.
func NewTlsCertificateFromPkcs11Uris(pkcs11Uri string, privateKeyPkcs11Uri string) (TlsCertificate, error) {
	var carg1 *C.gchar           // in, none, string
	var carg2 *C.gchar           // in, none, string, nullable-string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pkcs11Uri)))
	defer C.free(unsafe.Pointer(carg1))
	if privateKeyPkcs11Uri != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(privateKeyPkcs11Uri)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_tls_certificate_new_from_pkcs11_uris(carg1, carg2, &_cerr)
	runtime.KeepAlive(pkcs11Uri)
	runtime.KeepAlive(privateKeyPkcs11Uri)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewTlsCertificateFromPkcs12 wraps g_tls_certificate_new_from_pkcs12
// 
// The function takes the following parameters:
// 
// 	- data []uint8: DER-encoded PKCS #12 format certificate data 
// 	- password string (nullable): optional password for encrypted certificate data 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates a #GTlsCertificate from the data in @data. It must contain
// a certificate and matching private key.
// 
// If extra certificates are included they will be verified as a chain
// and the #GTlsCertificate:issuer property will be set.
// All other data will be ignored.
// 
// You can pass as single password for all of the data which will be
// used both for the PKCS #12 container as well as encrypted
// private keys. If decryption fails it will error with
// %G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD.
// 
// This constructor requires support in the current #GTlsBackend.
// If support is missing it will error with
// %G_IO_ERROR_NOT_SUPPORTED.
// 
// Other parsing failures will error with %G_TLS_ERROR_BAD_CERTIFICATE.
func NewTlsCertificateFromPkcs12(data []uint8, password string) (TlsCertificate, error) {
	var carg1 *C.guint8          // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize            // implicit
	var carg3 *C.gchar           // in, none, string, nullable-string
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")
	if password != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_tls_certificate_new_from_pkcs12(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(password)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsCertificateListNewFromFile wraps g_tls_certificate_list_new_from_file
// 
// The function takes the following parameters:
// 
// 	- file string: file containing PEM-encoded certificates to import 
// 
// The function returns the following values:
// 
// 	- goret []TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Creates one or more #GTlsCertificates from the PEM-encoded
// data in @file. If @file cannot be read or parsed, the function will
// return %NULL and set @error. If @file does not contain any
// PEM-encoded certificates, this will return an empty list and not
// set @error.
func TlsCertificateListNewFromFile(file string) ([]TlsCertificate, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.GList  // container, transfer: full
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_tls_certificate_list_new_from_file(carg1, &_cerr)
	runtime.KeepAlive(file)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetIssuer wraps g_tls_certificate_get_issuer
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
//
// Gets the #GTlsCertificate representing @cert's issuer, if known
func (cert *TlsCertificateInstance) GetIssuer() TlsCertificate {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_issuer(carg0)
	runtime.KeepAlive(cert)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetIssuerName wraps g_tls_certificate_get_issuer_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the issuer name from the certificate.
func (cert *TlsCertificateInstance) GetIssuerName() string {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_issuer_name(carg0)
	runtime.KeepAlive(cert)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetSubjectName wraps g_tls_certificate_get_subject_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the subject name from the certificate.
func (cert *TlsCertificateInstance) GetSubjectName() string {
	var carg0 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))

	cret = C.g_tls_certificate_get_subject_name(carg0)
	runtime.KeepAlive(cert)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// IsSame wraps g_tls_certificate_is_same
// 
// The function takes the following parameters:
// 
// 	- certTwo TlsCertificate: second certificate to compare 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check if two #GTlsCertificate objects represent the same certificate.
// The raw DER byte data of the two certificates are checked for equality.
// This has the effect that two certificates may compare equal even if
// their #GTlsCertificate:issuer, #GTlsCertificate:private-key, or
// #GTlsCertificate:private-key-pem properties differ.
func (certOne *TlsCertificateInstance) IsSame(certTwo TlsCertificate) bool {
	var carg0 *C.GTlsCertificate // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certOne))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certTwo))

	cret = C.g_tls_certificate_is_same(carg0, carg1)
	runtime.KeepAlive(certOne)
	runtime.KeepAlive(certTwo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Verify wraps g_tls_certificate_verify
// 
// The function takes the following parameters:
// 
// 	- identity SocketConnectable (nullable): the expected peer identity 
// 	- trustedCa TlsCertificate (nullable): the certificate of a trusted authority 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// This verifies @cert and returns a set of #GTlsCertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to
// check a certificate against a CA that is not part of the system
// CA database.
// 
// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
// 
// If @identity is not %NULL, @cert's name(s) will be compared against
// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
// value if it does not match. If @identity is %NULL, that bit will
// never be set in the return value.
// 
// If @trusted_ca is not %NULL, then @cert (or one of the certificates
// in its chain) must be signed by it, or else
// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
// @trusted_ca is %NULL, that bit will never be set in the return
// value.
// 
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
// 
// Because TLS session context is not used, #GTlsCertificate may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
func (cert *TlsCertificateInstance) Verify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags {
	var carg0 *C.GTlsCertificate     // in, none, converted
	var carg1 *C.GSocketConnectable  // in, none, converted, nullable
	var carg2 *C.GTlsCertificate     // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))
	if identity != nil {
		carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if trustedCa != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(trustedCa))
	}

	cret = C.g_tls_certificate_verify(carg0, carg1, carg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// TlsCertificateOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsCertificateOverrides[Instance TlsCertificate] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // Verify allows you to override the implementation of the virtual method verify.
	// 
	// The function takes the following parameters:
	// 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- trustedCa TlsCertificate (nullable): the certificate of a trusted authority 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// This verifies @cert and returns a set of #GTlsCertificateFlags
	// indicating any problems found with it. This can be used to verify a
	// certificate outside the context of making a connection, or to
	// check a certificate against a CA that is not part of the system
	// CA database.
	// 
	// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
	// 
	// If @identity is not %NULL, @cert's name(s) will be compared against
	// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
	// value if it does not match. If @identity is %NULL, that bit will
	// never be set in the return value.
	// 
	// If @trusted_ca is not %NULL, then @cert (or one of the certificates
	// in its chain) must be signed by it, or else
	// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
	// @trusted_ca is %NULL, that bit will never be set in the return
	// value.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Because TLS session context is not used, #GTlsCertificate may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	Verify func(Instance, SocketConnectable, TlsCertificate) TlsCertificateFlags
}

// UnsafeApplyTlsCertificateOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsCertificateOverrides[Instance TlsCertificate](gclass unsafe.Pointer, overrides TlsCertificateOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsCertificateClass)(gclass)

	if overrides.Verify != nil {
		pclass.verify = (*[0]byte)(C._goglib_gio2_TlsCertificate_verify)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsCertificate_verify",
			func(carg0 *C.GTlsCertificate, carg1 *C.GSocketConnectable, carg2 *C.GTlsCertificate) (cret C.GTlsCertificateFlags) {
				var cert      Instance            // go GTlsCertificate subclass
				var identity  SocketConnectable   // in, none, converted, nullable
				var trustedCa TlsCertificate      // in, none, converted, nullable
				var goret     TlsCertificateFlags // return, none, casted

				cert = UnsafeTlsCertificateFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					identity = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg1))
				}
				if carg2 != nil {
					trustedCa = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg2))
				}

				goret = overrides.Verify(cert, identity, trustedCa)

				cret = C.GTlsCertificateFlags(goret)

				return cret
			},
		)
	}
}

// ParentVerify calls the default implementations of the `GTlsCertificate.verify` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- identity SocketConnectable (nullable): the expected peer identity 
// 	- trustedCa TlsCertificate (nullable): the certificate of a trusted authority 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// This verifies @cert and returns a set of #GTlsCertificateFlags
// indicating any problems found with it. This can be used to verify a
// certificate outside the context of making a connection, or to
// check a certificate against a CA that is not part of the system
// CA database.
// 
// If @cert is valid, %G_TLS_CERTIFICATE_NO_FLAGS is returned.
// 
// If @identity is not %NULL, @cert's name(s) will be compared against
// it, and %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the return
// value if it does not match. If @identity is %NULL, that bit will
// never be set in the return value.
// 
// If @trusted_ca is not %NULL, then @cert (or one of the certificates
// in its chain) must be signed by it, or else
// %G_TLS_CERTIFICATE_UNKNOWN_CA will be set in the return value. If
// @trusted_ca is %NULL, that bit will never be set in the return
// value.
// 
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
// 
// Because TLS session context is not used, #GTlsCertificate may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
func (cert *TlsCertificateInstance) ParentVerify(identity SocketConnectable, trustedCa TlsCertificate) TlsCertificateFlags {
	var carg0 *C.GTlsCertificate
	var carg1 *C.GSocketConnectable  // in, none, converted
	var carg2 *C.GTlsCertificate     // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags // return, none, casted

	parentclass := (*C.GTlsCertificateClass)(classdata.PeekParentClass(UnsafeTlsCertificateToGlibNone(cert)))

	carg0 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(cert))
	if identity != nil {
		carg1 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if trustedCa != nil {
		carg2 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(trustedCa))
	}

	cret = C._goglib_gio2_TlsCertificate_virtual_verify(unsafe.Pointer(parentclass.verify), carg0, carg1, carg2)
	runtime.KeepAlive(cert)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(trustedCa)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// RegisterTlsCertificateSubClass is used to register a go subclass of GTlsCertificate. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsCertificateSubClass[InstanceT TlsCertificate](
		name string,
		classInit func(class *TlsCertificateClass),
		constructor func() InstanceT,
		overrides TlsCertificateOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsCertificate,
		UnsafeTlsCertificateClassFromGlibBorrow,
		UnsafeApplyTlsCertificateOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsCertificate(obj)
		},
		interfaceInits...,
	)
}

// TlsConnectionInstance is the instance type used by all types extending GTlsConnection. It is used internally by the bindings. Users should use the interface [TlsConnection] instead.
type TlsConnectionInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
}

var _ TlsConnection = (*TlsConnectionInstance)(nil)

// TlsConnection wraps GTlsConnection
//
// `GTlsConnection` is the base TLS connection class type, which wraps
// a [class@Gio.IOStream] and provides TLS encryption on top of it. Its
// subclasses, [iface@Gio.TlsClientConnection] and
// [iface@Gio.TlsServerConnection], implement client-side and server-side TLS,
// respectively.
// 
// For DTLS (Datagram TLS) support, see [iface@Gio.DtlsConnection].
type TlsConnection interface {
	IOStream
	upcastToGTlsConnection() *TlsConnectionInstance

	// EmitAcceptCertificate wraps g_tls_connection_emit_accept_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- peerCert TlsCertificate: the peer's #GTlsCertificate 
	// 	- errors TlsCertificateFlags: the problems with @peer_cert 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Used by #GTlsConnection implementations to emit the
	// #GTlsConnection::accept-certificate signal.
	EmitAcceptCertificate(TlsCertificate, TlsCertificateFlags) bool
	// GetCertificate wraps g_tls_connection_get_certificate
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	//
	// Gets @conn's certificate, as set by
	// g_tls_connection_set_certificate().
	GetCertificate() TlsCertificate
	// GetCiphersuiteName wraps g_tls_connection_get_ciphersuite_name
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Returns the name of the current TLS ciphersuite, or %NULL if the
	// connection has not handshaked or has been closed. Beware that the TLS
	// backend may use any of multiple different naming conventions, because
	// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
	// are different from each other and different from the standard, IANA-
	// registered ciphersuite names. The ciphersuite name is intended to be
	// displayed to the user for informative purposes only, and parsing it
	// is not recommended.
	GetCiphersuiteName() string
	// GetDatabase wraps g_tls_connection_get_database
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsDatabase (nullable) 
	//
	// Gets the certificate database that @conn uses to verify
	// peer certificates. See g_tls_connection_set_database().
	GetDatabase() TlsDatabase
	// GetInteraction wraps g_tls_connection_get_interaction
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteraction (nullable) 
	//
	// Get the object that will be used to interact with the user. It will be used
	// for things like prompting the user for passwords. If %NULL is returned, then
	// no user interaction will occur for this connection.
	GetInteraction() TlsInteraction
	// GetNegotiatedProtocol wraps g_tls_connection_get_negotiated_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the name of the application-layer protocol negotiated during
	// the handshake.
	// 
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend
	// does not support ALPN, then this will be %NULL. See
	// g_tls_connection_set_advertised_protocols().
	GetNegotiatedProtocol() string
	// GetPeerCertificate wraps g_tls_connection_get_peer_certificate
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	//
	// Gets @conn's peer's certificate after the handshake has completed
	// or failed. (It is not set during the emission of
	// #GTlsConnection::accept-certificate.)
	GetPeerCertificate() TlsCertificate
	// GetPeerCertificateErrors wraps g_tls_connection_get_peer_certificate_errors
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	//
	// Gets the errors associated with validating @conn's peer's
	// certificate, after the handshake has completed or failed. (It is
	// not set during the emission of #GTlsConnection::accept-certificate.)
	// 
	// See #GTlsConnection:peer-certificate-errors for more information.
	GetPeerCertificateErrors() TlsCertificateFlags
	// GetProtocolVersion wraps g_tls_connection_get_protocol_version
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsProtocolVersion 
	//
	// Returns the current TLS protocol version, which may be
	// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
	// has been closed, or if the TLS backend has implemented a protocol version
	// that is not a recognized #GTlsProtocolVersion.
	GetProtocolVersion() TlsProtocolVersion
	// GetRehandshakeMode wraps g_tls_connection_get_rehandshake_mode
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsRehandshakeMode 
	//
	// Gets @conn rehandshaking mode. See
	// g_tls_connection_set_rehandshake_mode() for details.
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	GetRehandshakeMode() TlsRehandshakeMode
	// GetRequireCloseNotify wraps g_tls_connection_get_require_close_notify
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Tests whether or not @conn expects a proper TLS close notification
	// when the connection is closed. See
	// g_tls_connection_set_require_close_notify() for details.
	GetRequireCloseNotify() bool
	// GetUseSystemCertdb wraps g_tls_connection_get_use_system_certdb
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Gets whether @conn uses the system certificate database to verify
	// peer certificates. See g_tls_connection_set_use_system_certdb().
	//
	// Deprecated: (since 2.30.0) Use g_tls_connection_get_database() instead
	GetUseSystemCertdb() bool
	// Handshake wraps g_tls_connection_handshake
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts a TLS handshake on @conn.
	// 
	// On the client side, it is never necessary to call this method;
	// although the connection needs to perform a handshake after
	// connecting (or after sending a "STARTTLS"-type command),
	// #GTlsConnection will handle this for you automatically when you try
	// to send or receive data on the connection. You can call
	// g_tls_connection_handshake() manually if you want to know whether
	// the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case,
	// if it fails, it may not be possible to tell if it failed before or
	// after completing the handshake), but beware that servers may reject
	// client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	// 
	// Likewise, on the server side, although a handshake is necessary at
	// the beginning of the communication, you do not need to call this
	// function explicitly unless you want clearer error reporting.
	// 
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was
	// deprecated in GLib 2.60 because rehandshaking was removed from the
	// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
	// the initial handshake will no longer do anything.
	// 
	// When using a #GTlsConnection created by #GSocketClient, the
	// #GSocketClient performs the initial handshake, so calling this
	// function manually is not recommended.
	// 
	// #GTlsConnection::accept_certificate may be emitted during the
	// handshake.
	Handshake(Cancellable) (bool, error)
	// HandshakeAsync wraps g_tls_connection_handshake_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the handshake is complete 
	//
	// Asynchronously performs a TLS handshake on @conn. See
	// g_tls_connection_handshake() for more information.
	HandshakeAsync(int32, Cancellable, AsyncReadyCallback)
	// HandshakeFinish wraps g_tls_connection_handshake_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS handshake operation. See
	// g_tls_connection_handshake() for more information.
	HandshakeFinish(AsyncResult) (bool, error)
	// SetAdvertisedProtocols wraps g_tls_connection_set_advertised_protocols
	// 
	// The function takes the following parameters:
	// 
	// 	- protocols []string (nullable): a %NULL-terminated
	//   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL 
	//
	// Sets the list of application-layer protocols to advertise that the
	// caller is willing to speak on this connection. The
	// Application-Layer Protocol Negotiation (ALPN) extension will be
	// used to negotiate a compatible protocol with the peer; use
	// g_tls_connection_get_negotiated_protocol() to find the negotiated
	// protocol after the handshake.  Specifying %NULL for the the value
	// of @protocols will disable ALPN negotiation.
	// 
	// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
	// for a list of registered protocol IDs.
	SetAdvertisedProtocols([]string)
	// SetCertificate wraps g_tls_connection_set_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: the certificate to use for @conn 
	//
	// This sets the certificate that @conn will present to its peer
	// during the TLS handshake. For a #GTlsServerConnection, it is
	// mandatory to set this, and that will normally be done at construct
	// time.
	// 
	// For a #GTlsClientConnection, this is optional. If a handshake fails
	// with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
	// requires a certificate, and if you try connecting again, you should
	// call this method first. You can call
	// g_tls_client_connection_get_accepted_cas() on the failed connection
	// to get a list of Certificate Authorities that the server will
	// accept certificates from.
	// 
	// (It is also possible that a server will allow the connection with
	// or without a certificate; in that case, if you don't provide a
	// certificate, you can tell that the server requested one by the fact
	// that g_tls_client_connection_get_accepted_cas() will return
	// non-%NULL.)
	SetCertificate(TlsCertificate)
	// SetDatabase wraps g_tls_connection_set_database
	// 
	// The function takes the following parameters:
	// 
	// 	- database TlsDatabase (nullable): a #GTlsDatabase 
	//
	// Sets the certificate database that is used to verify peer certificates.
	// This is set to the default database by default. See
	// g_tls_backend_get_default_database(). If set to %NULL, then
	// peer certificate validation will always set the
	// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// #GTlsConnection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// #GTlsClientConnection:validation-flags).
	// 
	// There are nonintuitive security implications when using a non-default
	// database. See #GTlsConnection:database for details.
	SetDatabase(TlsDatabase)
	// SetInteraction wraps g_tls_connection_set_interaction
	// 
	// The function takes the following parameters:
	// 
	// 	- interaction TlsInteraction (nullable): an interaction object, or %NULL 
	//
	// Set the object that will be used to interact with the user. It will be used
	// for things like prompting the user for passwords.
	// 
	// The @interaction argument will normally be a derived subclass of
	// #GTlsInteraction. %NULL can also be provided if no user interaction
	// should occur for this connection.
	SetInteraction(TlsInteraction)
	// SetRehandshakeMode wraps g_tls_connection_set_rehandshake_mode
	// 
	// The function takes the following parameters:
	// 
	// 	- mode TlsRehandshakeMode: the rehandshaking mode 
	//
	// Since GLib 2.64, changing the rehandshake mode is no longer supported
	// and will have no effect. With TLS 1.3, rehandshaking has been removed from
	// the TLS protocol, replaced by separate post-handshake authentication and
	// rekey operations.
	//
	// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
	//   required for compatibility. Also, rehandshaking has been removed
	//   from the TLS protocol in TLS 1.3.
	SetRehandshakeMode(TlsRehandshakeMode)
	// SetRequireCloseNotify wraps g_tls_connection_set_require_close_notify
	// 
	// The function takes the following parameters:
	// 
	// 	- requireCloseNotify bool: whether or not to require close notification 
	//
	// Sets whether or not @conn expects a proper TLS close notification
	// before the connection is closed. If this is %TRUE (the default),
	// then @conn will expect to receive a TLS close notification from its
	// peer before the connection is closed, and will return a
	// %G_TLS_ERROR_EOF error if the connection is closed without proper
	// notification (since this may indicate a network error, or
	// man-in-the-middle attack).
	// 
	// In some protocols, the application will know whether or not the
	// connection was closed cleanly based on application-level data
	// (because the application-level data includes a length field, or is
	// somehow self-delimiting); in this case, the close notify is
	// redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
	// in TLS 1.0 it is technically an error, but often done anyway.) You
	// can use g_tls_connection_set_require_close_notify() to tell @conn
	// to allow an "unannounced" connection close, in which case the close
	// will show up as a 0-length read, as in a non-TLS
	// #GSocketConnection, and it is up to the application to check that
	// the data has been fully received.
	// 
	// Note that this only affects the behavior when the peer closes the
	// connection; when the application calls g_io_stream_close() itself
	// on @conn, this will send a close notification regardless of the
	// setting of this property. If you explicitly want to do an unclean
	// close, you can close @conn's #GTlsConnection:base-io-stream rather
	// than closing @conn itself, but note that this may only be done when no other
	// operations are pending on @conn or the base I/O stream.
	SetRequireCloseNotify(bool)
	// SetUseSystemCertdb wraps g_tls_connection_set_use_system_certdb
	// 
	// The function takes the following parameters:
	// 
	// 	- useSystemCertdb bool: whether to use the system certificate database 
	//
	// Sets whether @conn uses the system certificate database to verify
	// peer certificates. This is %TRUE by default. If set to %FALSE, then
	// peer certificate validation will always set the
	// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
	// #GTlsConnection::accept-certificate will always be emitted on
	// client-side connections, unless that bit is not set in
	// #GTlsClientConnection:validation-flags).
	//
	// Deprecated: (since 2.30.0) Use g_tls_connection_set_database() instead
	SetUseSystemCertdb(bool)
	// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
	//
	// Emitted during the TLS handshake after the peer certificate has
	// been received. You can examine @peer_cert's certification path by
	// calling g_tls_certificate_get_issuer() on it.
	// 
	// For a client-side connection, @peer_cert is the server's
	// certificate, and the signal will only be emitted if the
	// certificate was not acceptable according to @conn's
	// #GTlsClientConnection:validation_flags. If you would like the
	// certificate to be accepted despite @errors, return %TRUE from the
	// signal handler. Otherwise, if no handler accepts the certificate,
	// the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
	// 
	// GLib guarantees that if certificate verification fails, this signal
	// will be emitted with at least one error will be set in @errors, but
	// it does not guarantee that all possible errors will be set.
	// Accordingly, you may not safely decide to ignore any particular
	// type of error. For example, it would be incorrect to ignore
	// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
	// certificates, because this could potentially be the only error flag
	// set even if other problems exist with the certificate.
	// 
	// For a server-side connection, @peer_cert is the certificate
	// presented by the client, if this was requested via the server's
	// #GTlsServerConnection:authentication_mode. On the server side,
	// the signal is always emitted when the client presents a
	// certificate, and the certificate will only be accepted if a
	// handler returns %TRUE.
	// 
	// Note that if this signal is emitted as part of asynchronous I/O
	// in the main thread, then you should not attempt to interact with
	// the user before returning from the signal handler. If you want to
	// let the user decide whether or not to accept the certificate, you
	// would have to return %FALSE from the signal handler on the first
	// attempt, and then after the connection attempt returns a
	// %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
	// if the user decides to accept the certificate, remember that fact,
	// create a new connection, and return %TRUE from the signal handler
	// the next time.
	// 
	// If you are doing I/O in another thread, you do not
	// need to worry about this, and can simply block in the signal
	// handler until the UI thread returns an answer.
	ConnectAcceptCertificate(func(TlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle

	// chain up virtual methods:

	// ParentAcceptCertificate calls the default implementations of the `GTlsConnection.accept_certificate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- peerCert TlsCertificate 
	// 	- errors TlsCertificateFlags 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check whether to accept a certificate.
	ParentAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool
	// ParentGetNegotiatedProtocol calls the default implementations of the `GTlsConnection.get_negotiated_protocol` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the name of the application-layer protocol negotiated during
	// the handshake.
	// 
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend
	// does not support ALPN, then this will be %NULL. See
	// g_tls_connection_set_advertised_protocols().
	ParentGetNegotiatedProtocol() string
	// ParentHandshake calls the default implementations of the `GTlsConnection.handshake` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts a TLS handshake on @conn.
	// 
	// On the client side, it is never necessary to call this method;
	// although the connection needs to perform a handshake after
	// connecting (or after sending a "STARTTLS"-type command),
	// #GTlsConnection will handle this for you automatically when you try
	// to send or receive data on the connection. You can call
	// g_tls_connection_handshake() manually if you want to know whether
	// the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case,
	// if it fails, it may not be possible to tell if it failed before or
	// after completing the handshake), but beware that servers may reject
	// client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	// 
	// Likewise, on the server side, although a handshake is necessary at
	// the beginning of the communication, you do not need to call this
	// function explicitly unless you want clearer error reporting.
	// 
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was
	// deprecated in GLib 2.60 because rehandshaking was removed from the
	// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
	// the initial handshake will no longer do anything.
	// 
	// When using a #GTlsConnection created by #GSocketClient, the
	// #GSocketClient performs the initial handshake, so calling this
	// function manually is not recommended.
	// 
	// #GTlsConnection::accept_certificate may be emitted during the
	// handshake.
	ParentHandshake(cancellable Cancellable) (bool, error)
	// ParentHandshakeFinish calls the default implementations of the `GTlsConnection.handshake_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS handshake operation. See
	// g_tls_connection_handshake() for more information.
	ParentHandshakeFinish(result AsyncResult) (bool, error)
}

func unsafeWrapTlsConnection(base *gobject.ObjectInstance) *TlsConnectionInstance {
	return &TlsConnectionInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsConnection,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsConnection(inst)
		},
	)
}

func marshalTlsConnectionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsConnectionFromGlibNone is used to convert raw GTlsConnection pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibNone(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsConnection)
}

// UnsafeTlsConnectionFromGlibFull is used to convert raw GTlsConnection pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibFull(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsConnection)
}

// UnsafeTlsConnectionFromGlibBorrow is used to convert raw GTlsConnection pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsConnectionFromGlibBorrow(c unsafe.Pointer) TlsConnection {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsConnection)
}

func (t *TlsConnectionInstance) upcastToGTlsConnection() *TlsConnectionInstance {
	return t
}

// UnsafeTlsConnectionToGlibNone is used to convert the instance to it's C value GTlsConnection. This is used by the bindings internally.
func UnsafeTlsConnectionToGlibNone(c TlsConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsConnectionToGlibFull is used to convert the instance to it's C value GTlsConnection, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsConnectionToGlibFull(c TlsConnection) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// EmitAcceptCertificate wraps g_tls_connection_emit_accept_certificate
// 
// The function takes the following parameters:
// 
// 	- peerCert TlsCertificate: the peer's #GTlsCertificate 
// 	- errors TlsCertificateFlags: the problems with @peer_cert 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Used by #GTlsConnection implementations to emit the
// #GTlsConnection::accept-certificate signal.
func (conn *TlsConnectionInstance) EmitAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GTlsConnection      // in, none, converted
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, casted
	var cret  C.gboolean             // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C.g_tls_connection_emit_accept_certificate(carg0, carg1, carg2)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCertificate wraps g_tls_connection_get_certificate
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
//
// Gets @conn's certificate, as set by
// g_tls_connection_set_certificate().
func (conn *TlsConnectionInstance) GetCertificate() TlsCertificate {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetCiphersuiteName wraps g_tls_connection_get_ciphersuite_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the name of the current TLS ciphersuite, or %NULL if the
// connection has not handshaked or has been closed. Beware that the TLS
// backend may use any of multiple different naming conventions, because
// OpenSSL and GnuTLS have their own ciphersuite naming conventions that
// are different from each other and different from the standard, IANA-
// registered ciphersuite names. The ciphersuite name is intended to be
// displayed to the user for informative purposes only, and parsing it
// is not recommended.
func (conn *TlsConnectionInstance) GetCiphersuiteName() string {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.gchar          // return, full, string, nullable-string

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_ciphersuite_name(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetDatabase wraps g_tls_connection_get_database
// 
// The function returns the following values:
// 
// 	- goret TlsDatabase (nullable) 
//
// Gets the certificate database that @conn uses to verify
// peer certificates. See g_tls_connection_set_database().
func (conn *TlsConnectionInstance) GetDatabase() TlsDatabase {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.GTlsDatabase   // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_database(carg0)
	runtime.KeepAlive(conn)

	var goret TlsDatabase

	if cret != nil {
		goret = UnsafeTlsDatabaseFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetInteraction wraps g_tls_connection_get_interaction
// 
// The function returns the following values:
// 
// 	- goret TlsInteraction (nullable) 
//
// Get the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords. If %NULL is returned, then
// no user interaction will occur for this connection.
func (conn *TlsConnectionInstance) GetInteraction() TlsInteraction {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsInteraction // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_interaction(carg0)
	runtime.KeepAlive(conn)

	var goret TlsInteraction

	if cret != nil {
		goret = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetNegotiatedProtocol wraps g_tls_connection_get_negotiated_protocol
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the name of the application-layer protocol negotiated during
// the handshake.
// 
// If the peer did not use the ALPN extension, or did not advertise a
// protocol that matched one of @conn's protocols, or the TLS backend
// does not support ALPN, then this will be %NULL. See
// g_tls_connection_set_advertised_protocols().
func (conn *TlsConnectionInstance) GetNegotiatedProtocol() string {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  *C.gchar          // return, none, string, nullable-string

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_negotiated_protocol(carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPeerCertificate wraps g_tls_connection_get_peer_certificate
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
//
// Gets @conn's peer's certificate after the handshake has completed
// or failed. (It is not set during the emission of
// #GTlsConnection::accept-certificate.)
func (conn *TlsConnectionInstance) GetPeerCertificate() TlsCertificate {
	var carg0 *C.GTlsConnection  // in, none, converted
	var cret  *C.GTlsCertificate // return, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_peer_certificate(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificate

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetPeerCertificateErrors wraps g_tls_connection_get_peer_certificate_errors
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
//
// Gets the errors associated with validating @conn's peer's
// certificate, after the handshake has completed or failed. (It is
// not set during the emission of #GTlsConnection::accept-certificate.)
// 
// See #GTlsConnection:peer-certificate-errors for more information.
func (conn *TlsConnectionInstance) GetPeerCertificateErrors() TlsCertificateFlags {
	var carg0 *C.GTlsConnection      // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_peer_certificate_errors(carg0)
	runtime.KeepAlive(conn)

	var goret TlsCertificateFlags

	goret = TlsCertificateFlags(cret)

	return goret
}

// GetProtocolVersion wraps g_tls_connection_get_protocol_version
// 
// The function returns the following values:
// 
// 	- goret TlsProtocolVersion 
//
// Returns the current TLS protocol version, which may be
// %G_TLS_PROTOCOL_VERSION_UNKNOWN if the connection has not handshaked, or
// has been closed, or if the TLS backend has implemented a protocol version
// that is not a recognized #GTlsProtocolVersion.
func (conn *TlsConnectionInstance) GetProtocolVersion() TlsProtocolVersion {
	var carg0 *C.GTlsConnection     // in, none, converted
	var cret  C.GTlsProtocolVersion // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_protocol_version(carg0)
	runtime.KeepAlive(conn)

	var goret TlsProtocolVersion

	goret = TlsProtocolVersion(cret)

	return goret
}

// GetRehandshakeMode wraps g_tls_connection_get_rehandshake_mode
// 
// The function returns the following values:
// 
// 	- goret TlsRehandshakeMode 
//
// Gets @conn rehandshaking mode. See
// g_tls_connection_set_rehandshake_mode() for details.
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *TlsConnectionInstance) GetRehandshakeMode() TlsRehandshakeMode {
	var carg0 *C.GTlsConnection     // in, none, converted
	var cret  C.GTlsRehandshakeMode // return, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_rehandshake_mode(carg0)
	runtime.KeepAlive(conn)

	var goret TlsRehandshakeMode

	goret = TlsRehandshakeMode(cret)

	return goret
}

// GetRequireCloseNotify wraps g_tls_connection_get_require_close_notify
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests whether or not @conn expects a proper TLS close notification
// when the connection is closed. See
// g_tls_connection_set_require_close_notify() for details.
func (conn *TlsConnectionInstance) GetRequireCloseNotify() bool {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_require_close_notify(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetUseSystemCertdb wraps g_tls_connection_get_use_system_certdb
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Gets whether @conn uses the system certificate database to verify
// peer certificates. See g_tls_connection_set_use_system_certdb().
//
// Deprecated: (since 2.30.0) Use g_tls_connection_get_database() instead
func (conn *TlsConnectionInstance) GetUseSystemCertdb() bool {
	var carg0 *C.GTlsConnection // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C.g_tls_connection_get_use_system_certdb(carg0)
	runtime.KeepAlive(conn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Handshake wraps g_tls_connection_handshake
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts a TLS handshake on @conn.
// 
// On the client side, it is never necessary to call this method;
// although the connection needs to perform a handshake after
// connecting (or after sending a "STARTTLS"-type command),
// #GTlsConnection will handle this for you automatically when you try
// to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether
// the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case,
// if it fails, it may not be possible to tell if it failed before or
// after completing the handshake), but beware that servers may reject
// client authentication after the handshake has completed, so a
// successful handshake does not indicate the connection will be usable.
// 
// Likewise, on the server side, although a handshake is necessary at
// the beginning of the communication, you do not need to call this
// function explicitly unless you want clearer error reporting.
// 
// Previously, calling g_tls_connection_handshake() after the initial
// handshake would trigger a rehandshake; however, this usage was
// deprecated in GLib 2.60 because rehandshaking was removed from the
// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
// the initial handshake will no longer do anything.
// 
// When using a #GTlsConnection created by #GSocketClient, the
// #GSocketClient performs the initial handshake, so calling this
// function manually is not recommended.
// 
// #GTlsConnection::accept_certificate may be emitted during the
// handshake.
func (conn *TlsConnectionInstance) Handshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GCancellable   // in, none, converted, nullable
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_connection_handshake(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HandshakeAsync wraps g_tls_connection_handshake_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the handshake is complete 
//
// Asynchronously performs a TLS handshake on @conn. See
// g_tls_connection_handshake() for more information.
func (conn *TlsConnectionInstance) HandshakeAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsConnection     // in, none, converted
	var carg1 C.int                 // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = C.int(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_connection_handshake_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// HandshakeFinish wraps g_tls_connection_handshake_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
func (conn *TlsConnectionInstance) HandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GAsyncResult   // in, none, converted
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_connection_handshake_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetAdvertisedProtocols wraps g_tls_connection_set_advertised_protocols
// 
// The function takes the following parameters:
// 
// 	- protocols []string (nullable): a %NULL-terminated
//   array of ALPN protocol names (eg, "http/1.1", "h2"), or %NULL 
//
// Sets the list of application-layer protocols to advertise that the
// caller is willing to speak on this connection. The
// Application-Layer Protocol Negotiation (ALPN) extension will be
// used to negotiate a compatible protocol with the peer; use
// g_tls_connection_get_negotiated_protocol() to find the negotiated
// protocol after the handshake.  Specifying %NULL for the the value
// of @protocols will disable ALPN negotiation.
// 
// See [IANA TLS ALPN Protocol IDs](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)
// for a list of registered protocol IDs.
func (conn *TlsConnectionInstance) SetAdvertisedProtocols(protocols []string) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 **C.gchar         // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	_ = protocols
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_tls_connection_set_advertised_protocols(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(protocols)
}

// SetCertificate wraps g_tls_connection_set_certificate
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: the certificate to use for @conn 
//
// This sets the certificate that @conn will present to its peer
// during the TLS handshake. For a #GTlsServerConnection, it is
// mandatory to set this, and that will normally be done at construct
// time.
// 
// For a #GTlsClientConnection, this is optional. If a handshake fails
// with %G_TLS_ERROR_CERTIFICATE_REQUIRED, that means that the server
// requires a certificate, and if you try connecting again, you should
// call this method first. You can call
// g_tls_client_connection_get_accepted_cas() on the failed connection
// to get a list of Certificate Authorities that the server will
// accept certificates from.
// 
// (It is also possible that a server will allow the connection with
// or without a certificate; in that case, if you don't provide a
// certificate, you can tell that the server requested one by the fact
// that g_tls_client_connection_get_accepted_cas() will return
// non-%NULL.)
func (conn *TlsConnectionInstance) SetCertificate(certificate TlsCertificate) {
	var carg0 *C.GTlsConnection  // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	C.g_tls_connection_set_certificate(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(certificate)
}

// SetDatabase wraps g_tls_connection_set_database
// 
// The function takes the following parameters:
// 
// 	- database TlsDatabase (nullable): a #GTlsDatabase 
//
// Sets the certificate database that is used to verify peer certificates.
// This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to %NULL, then
// peer certificate validation will always set the
// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// #GTlsConnection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// #GTlsClientConnection:validation-flags).
// 
// There are nonintuitive security implications when using a non-default
// database. See #GTlsConnection:database for details.
func (conn *TlsConnectionInstance) SetDatabase(database TlsDatabase) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 *C.GTlsDatabase   // in, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if database != nil {
		carg1 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(database))
	}

	C.g_tls_connection_set_database(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction wraps g_tls_connection_set_interaction
// 
// The function takes the following parameters:
// 
// 	- interaction TlsInteraction (nullable): an interaction object, or %NULL 
//
// Set the object that will be used to interact with the user. It will be used
// for things like prompting the user for passwords.
// 
// The @interaction argument will normally be a derived subclass of
// #GTlsInteraction. %NULL can also be provided if no user interaction
// should occur for this connection.
func (conn *TlsConnectionInstance) SetInteraction(interaction TlsInteraction) {
	var carg0 *C.GTlsConnection  // in, none, converted
	var carg1 *C.GTlsInteraction // in, none, converted, nullable

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if interaction != nil {
		carg1 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}

	C.g_tls_connection_set_interaction(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

// SetRehandshakeMode wraps g_tls_connection_set_rehandshake_mode
// 
// The function takes the following parameters:
// 
// 	- mode TlsRehandshakeMode: the rehandshaking mode 
//
// Since GLib 2.64, changing the rehandshake mode is no longer supported
// and will have no effect. With TLS 1.3, rehandshaking has been removed from
// the TLS protocol, replaced by separate post-handshake authentication and
// rekey operations.
//
// Deprecated: (since 2.60.0) Changing the rehandshake mode is no longer
//   required for compatibility. Also, rehandshaking has been removed
//   from the TLS protocol in TLS 1.3.
func (conn *TlsConnectionInstance) SetRehandshakeMode(mode TlsRehandshakeMode) {
	var carg0 *C.GTlsConnection     // in, none, converted
	var carg1 C.GTlsRehandshakeMode // in, none, casted

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = C.GTlsRehandshakeMode(mode)

	C.g_tls_connection_set_rehandshake_mode(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(mode)
}

// SetRequireCloseNotify wraps g_tls_connection_set_require_close_notify
// 
// The function takes the following parameters:
// 
// 	- requireCloseNotify bool: whether or not to require close notification 
//
// Sets whether or not @conn expects a proper TLS close notification
// before the connection is closed. If this is %TRUE (the default),
// then @conn will expect to receive a TLS close notification from its
// peer before the connection is closed, and will return a
// %G_TLS_ERROR_EOF error if the connection is closed without proper
// notification (since this may indicate a network error, or
// man-in-the-middle attack).
// 
// In some protocols, the application will know whether or not the
// connection was closed cleanly based on application-level data
// (because the application-level data includes a length field, or is
// somehow self-delimiting); in this case, the close notify is
// redundant and sometimes omitted. (TLS 1.1 explicitly allows this;
// in TLS 1.0 it is technically an error, but often done anyway.) You
// can use g_tls_connection_set_require_close_notify() to tell @conn
// to allow an "unannounced" connection close, in which case the close
// will show up as a 0-length read, as in a non-TLS
// #GSocketConnection, and it is up to the application to check that
// the data has been fully received.
// 
// Note that this only affects the behavior when the peer closes the
// connection; when the application calls g_io_stream_close() itself
// on @conn, this will send a close notification regardless of the
// setting of this property. If you explicitly want to do an unclean
// close, you can close @conn's #GTlsConnection:base-io-stream rather
// than closing @conn itself, but note that this may only be done when no other
// operations are pending on @conn or the base I/O stream.
func (conn *TlsConnectionInstance) SetRequireCloseNotify(requireCloseNotify bool) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if requireCloseNotify {
		carg1 = C.TRUE
	}

	C.g_tls_connection_set_require_close_notify(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(requireCloseNotify)
}

// SetUseSystemCertdb wraps g_tls_connection_set_use_system_certdb
// 
// The function takes the following parameters:
// 
// 	- useSystemCertdb bool: whether to use the system certificate database 
//
// Sets whether @conn uses the system certificate database to verify
// peer certificates. This is %TRUE by default. If set to %FALSE, then
// peer certificate validation will always set the
// %G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// #GTlsConnection::accept-certificate will always be emitted on
// client-side connections, unless that bit is not set in
// #GTlsClientConnection:validation-flags).
//
// Deprecated: (since 2.30.0) Use g_tls_connection_set_database() instead
func (conn *TlsConnectionInstance) SetUseSystemCertdb(useSystemCertdb bool) {
	var carg0 *C.GTlsConnection // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if useSystemCertdb {
		carg1 = C.TRUE
	}

	C.g_tls_connection_set_use_system_certdb(carg0, carg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(useSystemCertdb)
}

// ConnectAcceptCertificate connects the provided callback to the "accept-certificate" signal
//
// Emitted during the TLS handshake after the peer certificate has
// been received. You can examine @peer_cert's certification path by
// calling g_tls_certificate_get_issuer() on it.
// 
// For a client-side connection, @peer_cert is the server's
// certificate, and the signal will only be emitted if the
// certificate was not acceptable according to @conn's
// #GTlsClientConnection:validation_flags. If you would like the
// certificate to be accepted despite @errors, return %TRUE from the
// signal handler. Otherwise, if no handler accepts the certificate,
// the handshake will fail with %G_TLS_ERROR_BAD_CERTIFICATE.
// 
// GLib guarantees that if certificate verification fails, this signal
// will be emitted with at least one error will be set in @errors, but
// it does not guarantee that all possible errors will be set.
// Accordingly, you may not safely decide to ignore any particular
// type of error. For example, it would be incorrect to ignore
// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired
// certificates, because this could potentially be the only error flag
// set even if other problems exist with the certificate.
// 
// For a server-side connection, @peer_cert is the certificate
// presented by the client, if this was requested via the server's
// #GTlsServerConnection:authentication_mode. On the server side,
// the signal is always emitted when the client presents a
// certificate, and the certificate will only be accepted if a
// handler returns %TRUE.
// 
// Note that if this signal is emitted as part of asynchronous I/O
// in the main thread, then you should not attempt to interact with
// the user before returning from the signal handler. If you want to
// let the user decide whether or not to accept the certificate, you
// would have to return %FALSE from the signal handler on the first
// attempt, and then after the connection attempt returns a
// %G_TLS_ERROR_BAD_CERTIFICATE, you can interact with the user, and
// if the user decides to accept the certificate, remember that fact,
// create a new connection, and return %TRUE from the signal handler
// the next time.
// 
// If you are doing I/O in another thread, you do not
// need to worry about this, and can simply block in the signal
// handler until the UI thread returns an answer.
func (o *TlsConnectionInstance) ConnectAcceptCertificate(fn func(TlsConnection, TlsCertificate, TlsCertificateFlags) bool) gobject.SignalHandle {
	return o.Connect("accept-certificate", fn)
}

// TlsConnectionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsConnectionOverrides[Instance TlsConnection] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

	// // AcceptCertificate allows you to override the implementation of the virtual method accept_certificate.
	// 
	// The function takes the following parameters:
	// 
	// 	- peerCert TlsCertificate 
	// 	- errors TlsCertificateFlags 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Check whether to accept a certificate.
	AcceptCertificate func(Instance, TlsCertificate, TlsCertificateFlags) bool
	// // GetNegotiatedProtocol allows you to override the implementation of the virtual method get_negotiated_protocol.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the name of the application-layer protocol negotiated during
	// the handshake.
	// 
	// If the peer did not use the ALPN extension, or did not advertise a
	// protocol that matched one of @conn's protocols, or the TLS backend
	// does not support ALPN, then this will be %NULL. See
	// g_tls_connection_set_advertised_protocols().
	GetNegotiatedProtocol func(Instance) string
	// // Handshake allows you to override the implementation of the virtual method handshake.
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Attempts a TLS handshake on @conn.
	// 
	// On the client side, it is never necessary to call this method;
	// although the connection needs to perform a handshake after
	// connecting (or after sending a "STARTTLS"-type command),
	// #GTlsConnection will handle this for you automatically when you try
	// to send or receive data on the connection. You can call
	// g_tls_connection_handshake() manually if you want to know whether
	// the initial handshake succeeded or failed (as opposed to just
	// immediately trying to use @conn to read or write, in which case,
	// if it fails, it may not be possible to tell if it failed before or
	// after completing the handshake), but beware that servers may reject
	// client authentication after the handshake has completed, so a
	// successful handshake does not indicate the connection will be usable.
	// 
	// Likewise, on the server side, although a handshake is necessary at
	// the beginning of the communication, you do not need to call this
	// function explicitly unless you want clearer error reporting.
	// 
	// Previously, calling g_tls_connection_handshake() after the initial
	// handshake would trigger a rehandshake; however, this usage was
	// deprecated in GLib 2.60 because rehandshaking was removed from the
	// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
	// the initial handshake will no longer do anything.
	// 
	// When using a #GTlsConnection created by #GSocketClient, the
	// #GSocketClient performs the initial handshake, so calling this
	// function manually is not recommended.
	// 
	// #GTlsConnection::accept_certificate may be emitted during the
	// handshake.
	Handshake func(Instance, Cancellable) (bool, error)
	// // HandshakeFinish allows you to override the implementation of the virtual method handshake_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous TLS handshake operation. See
	// g_tls_connection_handshake() for more information.
	HandshakeFinish func(Instance, AsyncResult) (bool, error)
}

// UnsafeApplyTlsConnectionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsConnectionOverrides[Instance TlsConnection](gclass unsafe.Pointer, overrides TlsConnectionOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)

	pclass := (*C.GTlsConnectionClass)(gclass)

	if overrides.AcceptCertificate != nil {
		pclass.accept_certificate = (*[0]byte)(C._goglib_gio2_TlsConnection_accept_certificate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_accept_certificate",
			func(carg0 *C.GTlsConnection, carg1 *C.GTlsCertificate, carg2 C.GTlsCertificateFlags) (cret C.gboolean) {
				var connection Instance            // go GTlsConnection subclass
				var peerCert   TlsCertificate      // in, none, converted
				var errors     TlsCertificateFlags // in, none, casted
				var goret      bool                // return

				connection = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				peerCert = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				errors = TlsCertificateFlags(carg2)

				goret = overrides.AcceptCertificate(connection, peerCert, errors)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetNegotiatedProtocol != nil {
		pclass.get_negotiated_protocol = (*[0]byte)(C._goglib_gio2_TlsConnection_get_negotiated_protocol)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_get_negotiated_protocol",
			func(carg0 *C.GTlsConnection) (cret *C.gchar) {
				var conn  Instance // go GTlsConnection subclass
				var goret string   // return, none, string, nullable-string

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetNegotiatedProtocol(conn)

				if goret != "" {
					cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
					defer C.free(unsafe.Pointer(cret))
				}

				return cret
			},
		)
	}

	if overrides.Handshake != nil {
		pclass.handshake = (*[0]byte)(C._goglib_gio2_TlsConnection_handshake)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_handshake",
			func(carg0 *C.GTlsConnection, carg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var conn        Instance    // go GTlsConnection subclass
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				if carg1 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg1))
				}

				goret, _goerr = overrides.Handshake(conn, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.HandshakeFinish != nil {
		pclass.handshake_finish = (*[0]byte)(C._goglib_gio2_TlsConnection_handshake_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsConnection_handshake_finish",
			func(carg0 *C.GTlsConnection, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gboolean) {
				var conn   Instance    // go GTlsConnection subclass
				var result AsyncResult // in, none, converted
				var goret  bool        // return
				var _goerr error       // out, full, converted

				conn = UnsafeTlsConnectionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.HandshakeFinish(conn, result)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAcceptCertificate calls the default implementations of the `GTlsConnection.accept_certificate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- peerCert TlsCertificate 
// 	- errors TlsCertificateFlags 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether to accept a certificate.
func (connection *TlsConnectionInstance) ParentAcceptCertificate(peerCert TlsCertificate, errors TlsCertificateFlags) bool {
	var carg0 *C.GTlsConnection
	var carg1 *C.GTlsCertificate     // in, none, converted
	var carg2 C.GTlsCertificateFlags // in, none, converted
	var cret  C.gboolean             // return

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(connection)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(peerCert))
	carg2 = C.GTlsCertificateFlags(errors)

	cret = C._goglib_gio2_TlsConnection_virtual_accept_certificate(unsafe.Pointer(parentclass.accept_certificate), carg0, carg1, carg2)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(peerCert)
	runtime.KeepAlive(errors)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetNegotiatedProtocol calls the default implementations of the `GTlsConnection.get_negotiated_protocol` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the name of the application-layer protocol negotiated during
// the handshake.
// 
// If the peer did not use the ALPN extension, or did not advertise a
// protocol that matched one of @conn's protocols, or the TLS backend
// does not support ALPN, then this will be %NULL. See
// g_tls_connection_set_advertised_protocols().
func (conn *TlsConnectionInstance) ParentGetNegotiatedProtocol() string {
	var carg0 *C.GTlsConnection
	var cret  *C.gchar // return, none, string, nullable-string

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))

	cret = C._goglib_gio2_TlsConnection_virtual_get_negotiated_protocol(unsafe.Pointer(parentclass.get_negotiated_protocol), carg0)
	runtime.KeepAlive(conn)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ParentHandshake calls the default implementations of the `GTlsConnection.handshake` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Attempts a TLS handshake on @conn.
// 
// On the client side, it is never necessary to call this method;
// although the connection needs to perform a handshake after
// connecting (or after sending a "STARTTLS"-type command),
// #GTlsConnection will handle this for you automatically when you try
// to send or receive data on the connection. You can call
// g_tls_connection_handshake() manually if you want to know whether
// the initial handshake succeeded or failed (as opposed to just
// immediately trying to use @conn to read or write, in which case,
// if it fails, it may not be possible to tell if it failed before or
// after completing the handshake), but beware that servers may reject
// client authentication after the handshake has completed, so a
// successful handshake does not indicate the connection will be usable.
// 
// Likewise, on the server side, although a handshake is necessary at
// the beginning of the communication, you do not need to call this
// function explicitly unless you want clearer error reporting.
// 
// Previously, calling g_tls_connection_handshake() after the initial
// handshake would trigger a rehandshake; however, this usage was
// deprecated in GLib 2.60 because rehandshaking was removed from the
// TLS protocol in TLS 1.3. Since GLib 2.64, calling this function after
// the initial handshake will no longer do anything.
// 
// When using a #GTlsConnection created by #GSocketClient, the
// #GSocketClient performs the initial handshake, so calling this
// function manually is not recommended.
// 
// #GTlsConnection::accept_certificate may be emitted during the
// handshake.
func (conn *TlsConnectionInstance) ParentHandshake(cancellable Cancellable) (bool, error) {
	var carg0 *C.GTlsConnection
	var carg1 *C.GCancellable // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsConnection_virtual_handshake(unsafe.Pointer(parentclass.handshake), carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentHandshakeFinish calls the default implementations of the `GTlsConnection.handshake_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous TLS handshake operation. See
// g_tls_connection_handshake() for more information.
func (conn *TlsConnectionInstance) ParentHandshakeFinish(result AsyncResult) (bool, error) {
	var carg0 *C.GTlsConnection
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsConnectionClass)(classdata.PeekParentClass(UnsafeTlsConnectionToGlibNone(conn)))

	carg0 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(conn))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsConnection_virtual_handshake_finish(unsafe.Pointer(parentclass.handshake_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(result)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsConnectionSubClass is used to register a go subclass of GTlsConnection. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsConnectionSubClass[InstanceT TlsConnection](
		name string,
		classInit func(class *TlsConnectionClass),
		constructor func() InstanceT,
		overrides TlsConnectionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsConnection,
		UnsafeTlsConnectionClassFromGlibBorrow,
		UnsafeApplyTlsConnectionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsConnection(obj)
		},
		interfaceInits...,
	)
}

// TlsDatabaseInstance is the instance type used by all types extending GTlsDatabase. It is used internally by the bindings. Users should use the interface [TlsDatabase] instead.
type TlsDatabaseInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsDatabase = (*TlsDatabaseInstance)(nil)

// TlsDatabase wraps GTlsDatabase
//
// `GTlsDatabase` is used to look up certificates and other information
// from a certificate or key store. It is an abstract base class which
// TLS library specific subtypes override.
// 
// A `GTlsDatabase` may be accessed from multiple threads by the TLS backend.
// All implementations are required to be fully thread-safe.
// 
// Most common client applications will not directly interact with
// `GTlsDatabase`. It is used internally by [class@Gio.TlsConnection].
type TlsDatabase interface {
	gobject.Object
	upcastToGTlsDatabase() *TlsDatabaseInstance

	// CreateCertificateHandle wraps g_tls_database_create_certificate_handle
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: certificate for which to create a handle. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Create a handle string for the certificate. The database will only be able
	// to create a handle for certificates that originate from the database. In
	// cases where the database cannot create a handle for a certificate, %NULL
	// will be returned.
	// 
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	CreateCertificateHandle(TlsCertificate) string
	// LookupCertificateForHandle wraps g_tls_database_lookup_certificate_for_handle
	// 
	// The function takes the following parameters:
	// 
	// 	- handle string: a certificate handle 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Look up a certificate by its handle.
	// 
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
	// the same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	// 
	// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
	// the lookup operation asynchronously.
	LookupCertificateForHandle(string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// LookupCertificateForHandleAsync wraps g_tls_database_lookup_certificate_for_handle_async
	// 
	// The function takes the following parameters:
	// 
	// 	- handle string: a certificate handle 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
	//
	// Asynchronously look up a certificate by its handle in the database. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	LookupCertificateForHandleAsync(string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupCertificateForHandleFinish wraps g_tls_database_lookup_certificate_for_handle_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of a certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	LookupCertificateForHandleFinish(AsyncResult) (TlsCertificate, error)
	// LookupCertificateIssuer wraps g_tls_database_lookup_certificate_issuer
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: a #GTlsCertificate 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Look up the issuer of @certificate in the database. The
	// #GTlsCertificate:issuer property of @certificate is not modified, and
	// the two certificates are not hooked into a chain.
	// 
	// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
	// to perform the lookup operation asynchronously.
	// 
	// Beware this function cannot be used to build certification paths. The
	// issuer certificate returned by this function may not be the same as
	// the certificate that would actually be used to construct a valid
	// certification path during certificate verification.
	// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
	// why an issuer certificate cannot be naively assumed to be part of the
	// the certification path (though GLib's TLS backends may not follow the
	// path building strategies outlined in this RFC). Due to the complexity
	// of certification path building, GLib does not provide any way to know
	// which certification path will actually be used when verifying a TLS
	// certificate. Accordingly, this function cannot be used to make
	// security-related decisions. Only GLib itself should make security
	// decisions about TLS certificates.
	LookupCertificateIssuer(TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// LookupCertificateIssuerAsync wraps g_tls_database_lookup_certificate_issuer_async
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: a #GTlsCertificate 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
	//
	// Asynchronously look up the issuer of @certificate in the database. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	LookupCertificateIssuerAsync(TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable, AsyncReadyCallback)
	// LookupCertificateIssuerFinish wraps g_tls_database_lookup_certificate_issuer_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup issuer operation. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	LookupCertificateIssuerFinish(AsyncResult) (TlsCertificate, error)
	// LookupCertificatesIssuedByFinish wraps g_tls_database_lookup_certificates_issued_by_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of certificates. See
	// g_tls_database_lookup_certificates_issued_by() for more information.
	LookupCertificatesIssuedByFinish(AsyncResult) ([]TlsCertificate, error)
	// VerifyChain wraps g_tls_database_verify_chain
	// 
	// The function takes the following parameters:
	// 
	// 	- chain TlsCertificate: a #GTlsCertificate chain 
	// 	- purpose string: the purpose that this certificate chain will be used for. 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Determines the validity of a certificate chain, outside the context
	// of a TLS session.
	// 
	// @chain is a chain of #GTlsCertificate objects each pointing to the next
	// certificate in the chain by its #GTlsCertificate:issuer property.
	// 
	// @purpose describes the purpose (or usage) for which the certificate
	// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
	// which means that the certificate is being used to authenticate a server
	// (and we are acting as the client).
	// 
	// The @identity is used to ensure the server certificate is valid for
	// the expected peer identity. If the identity does not match the
	// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
	// return value. If @identity is %NULL, that bit will never be set in
	// the return value. The peer identity may also be used to check for
	// pinned certificates (trust exceptions) in the database. These may
	// override the normal verification process on a host-by-host basis.
	// 
	// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate at
	// least one problem found. If the function is unable to determine
	// whether @chain is valid (for example, because @cancellable is
	// triggered before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
	// @error is not set when @chain is successfully analyzed but found to
	// be invalid.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
	// represent the certification path built by #GTlsDatabase during
	// certificate verification by adjusting the #GTlsCertificate:issuer
	// property of each certificate in @chain. Since GLib 2.48, this no
	// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
	// represent the actual certification path used during certificate
	// verification.
	// 
	// Because TLS session context is not used, #GTlsDatabase may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	// 
	// The TLS backend may attempt to look up and add missing certificates
	// to the chain. This may involve HTTP requests to download missing
	// certificates.
	// 
	// This function can block. Use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	VerifyChain(TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable) (TlsCertificateFlags, error)
	// VerifyChainAsync wraps g_tls_database_verify_chain_async
	// 
	// The function takes the following parameters:
	// 
	// 	- chain TlsCertificate: a #GTlsCertificate chain 
	// 	- purpose string: the purpose that this certificate chain will be used for. 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
	//
	// Asynchronously determines the validity of a certificate chain after
	// looking up and adding any missing certificates to the chain. See
	// g_tls_database_verify_chain() for more information.
	VerifyChainAsync(TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable, AsyncReadyCallback)
	// VerifyChainFinish wraps g_tls_database_verify_chain_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous verify chain operation. See
	// g_tls_database_verify_chain() for more information.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate
	// the problems found. If the function is unable to determine whether
	// @chain is valid or not (eg, because @cancellable is triggered
	// before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
	// accordingly. @error is not set when @chain is successfully analyzed
	// but found to be invalid.
	VerifyChainFinish(AsyncResult) (TlsCertificateFlags, error)

	// chain up virtual methods:

	// ParentCreateCertificateHandle calls the default implementations of the `GTlsDatabase.create_certificate_handle` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: certificate for which to create a handle. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Create a handle string for the certificate. The database will only be able
	// to create a handle for certificates that originate from the database. In
	// cases where the database cannot create a handle for a certificate, %NULL
	// will be returned.
	// 
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	ParentCreateCertificateHandle(certificate TlsCertificate) string
	// ParentLookupCertificateForHandle calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- handle string: a certificate handle 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Look up a certificate by its handle.
	// 
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
	// the same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	// 
	// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
	// the lookup operation asynchronously.
	ParentLookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error)
	// ParentLookupCertificateForHandleFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of a certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	ParentLookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error)
	// ParentLookupCertificateIssuer calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: a #GTlsCertificate 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Look up the issuer of @certificate in the database. The
	// #GTlsCertificate:issuer property of @certificate is not modified, and
	// the two certificates are not hooked into a chain.
	// 
	// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
	// to perform the lookup operation asynchronously.
	// 
	// Beware this function cannot be used to build certification paths. The
	// issuer certificate returned by this function may not be the same as
	// the certificate that would actually be used to construct a valid
	// certification path during certificate verification.
	// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
	// why an issuer certificate cannot be naively assumed to be part of the
	// the certification path (though GLib's TLS backends may not follow the
	// path building strategies outlined in this RFC). Due to the complexity
	// of certification path building, GLib does not provide any way to know
	// which certification path will actually be used when verifying a TLS
	// certificate. Accordingly, this function cannot be used to make
	// security-related decisions. Only GLib itself should make security
	// decisions about TLS certificates.
	ParentLookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error)
	// ParentLookupCertificateIssuerFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup issuer operation. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	ParentLookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error)
	// ParentLookupCertificatesIssuedByFinish calls the default implementations of the `GTlsDatabase.lookup_certificates_issued_by_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of certificates. See
	// g_tls_database_lookup_certificates_issued_by() for more information.
	ParentLookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error)
	// ParentVerifyChain calls the default implementations of the `GTlsDatabase.verify_chain` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- chain TlsCertificate: a #GTlsCertificate chain 
	// 	- purpose string: the purpose that this certificate chain will be used for. 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Determines the validity of a certificate chain, outside the context
	// of a TLS session.
	// 
	// @chain is a chain of #GTlsCertificate objects each pointing to the next
	// certificate in the chain by its #GTlsCertificate:issuer property.
	// 
	// @purpose describes the purpose (or usage) for which the certificate
	// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
	// which means that the certificate is being used to authenticate a server
	// (and we are acting as the client).
	// 
	// The @identity is used to ensure the server certificate is valid for
	// the expected peer identity. If the identity does not match the
	// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
	// return value. If @identity is %NULL, that bit will never be set in
	// the return value. The peer identity may also be used to check for
	// pinned certificates (trust exceptions) in the database. These may
	// override the normal verification process on a host-by-host basis.
	// 
	// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate at
	// least one problem found. If the function is unable to determine
	// whether @chain is valid (for example, because @cancellable is
	// triggered before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
	// @error is not set when @chain is successfully analyzed but found to
	// be invalid.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
	// represent the certification path built by #GTlsDatabase during
	// certificate verification by adjusting the #GTlsCertificate:issuer
	// property of each certificate in @chain. Since GLib 2.48, this no
	// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
	// represent the actual certification path used during certificate
	// verification.
	// 
	// Because TLS session context is not used, #GTlsDatabase may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	// 
	// The TLS backend may attempt to look up and add missing certificates
	// to the chain. This may involve HTTP requests to download missing
	// certificates.
	// 
	// This function can block. Use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	ParentVerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error)
	// ParentVerifyChainFinish calls the default implementations of the `GTlsDatabase.verify_chain_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous verify chain operation. See
	// g_tls_database_verify_chain() for more information.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate
	// the problems found. If the function is unable to determine whether
	// @chain is valid or not (eg, because @cancellable is triggered
	// before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
	// accordingly. @error is not set when @chain is successfully analyzed
	// but found to be invalid.
	ParentVerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error)
}

func unsafeWrapTlsDatabase(base *gobject.ObjectInstance) *TlsDatabaseInstance {
	return &TlsDatabaseInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsDatabase,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsDatabase(inst)
		},
	)
}

func marshalTlsDatabaseInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsDatabaseFromGlibNone is used to convert raw GTlsDatabase pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibNone(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsDatabase)
}

// UnsafeTlsDatabaseFromGlibFull is used to convert raw GTlsDatabase pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibFull(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsDatabase)
}

// UnsafeTlsDatabaseFromGlibBorrow is used to convert raw GTlsDatabase pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsDatabaseFromGlibBorrow(c unsafe.Pointer) TlsDatabase {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsDatabase)
}

func (t *TlsDatabaseInstance) upcastToGTlsDatabase() *TlsDatabaseInstance {
	return t
}

// UnsafeTlsDatabaseToGlibNone is used to convert the instance to it's C value GTlsDatabase. This is used by the bindings internally.
func UnsafeTlsDatabaseToGlibNone(c TlsDatabase) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsDatabaseToGlibFull is used to convert the instance to it's C value GTlsDatabase, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsDatabaseToGlibFull(c TlsDatabase) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// CreateCertificateHandle wraps g_tls_database_create_certificate_handle
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: certificate for which to create a handle. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Create a handle string for the certificate. The database will only be able
// to create a handle for certificates that originate from the database. In
// cases where the database cannot create a handle for a certificate, %NULL
// will be returned.
// 
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
func (self *TlsDatabaseInstance) CreateCertificateHandle(certificate TlsCertificate) string {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	cret = C.g_tls_database_create_certificate_handle(carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// LookupCertificateForHandle wraps g_tls_database_lookup_certificate_for_handle
// 
// The function takes the following parameters:
// 
// 	- handle string: a certificate handle 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
// 	- _goerr error (nullable): an error 
//
// Look up a certificate by its handle.
// 
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
// the same TLS backend. The handle is designed to remain valid across
// instantiations of the database.
// 
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
// 
// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
// the lookup operation asynchronously.
func (self *TlsDatabaseInstance) LookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.gchar                  // in, none, string
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GTlsCertificate        // return, full, converted, nullable
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_lookup_certificate_for_handle(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateForHandleAsync wraps g_tls_database_lookup_certificate_for_handle_async
// 
// The function takes the following parameters:
// 
// 	- handle string: a certificate handle 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
//
// Asynchronously look up a certificate by its handle in the database. See
// g_tls_database_lookup_certificate_for_handle() for more information.
func (self *TlsDatabaseInstance) LookupCertificateForHandleAsync(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.gchar                  // in, none, string
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback     // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_lookup_certificate_for_handle_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupCertificateForHandleFinish wraps g_tls_database_lookup_certificate_for_handle_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup of a certificate by its handle. See
// g_tls_database_lookup_certificate_for_handle() for more information.
// 
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
func (self *TlsDatabaseInstance) LookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificate_for_handle_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateIssuer wraps g_tls_database_lookup_certificate_issuer
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: a #GTlsCertificate 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Look up the issuer of @certificate in the database. The
// #GTlsCertificate:issuer property of @certificate is not modified, and
// the two certificates are not hooked into a chain.
// 
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
// 
// Beware this function cannot be used to build certification paths. The
// issuer certificate returned by this function may not be the same as
// the certificate that would actually be used to construct a valid
// certification path during certificate verification.
// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
// why an issuer certificate cannot be naively assumed to be part of the
// the certification path (though GLib's TLS backends may not follow the
// path building strategies outlined in this RFC). Due to the complexity
// of certification path building, GLib does not provide any way to know
// which certification path will actually be used when verifying a TLS
// certificate. Accordingly, this function cannot be used to make
// security-related decisions. Only GLib itself should make security
// decisions about TLS certificates.
func (self *TlsDatabaseInstance) LookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var cret  *C.GTlsCertificate        // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_lookup_certificate_issuer(carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificateIssuerAsync wraps g_tls_database_lookup_certificate_issuer_async
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: a #GTlsCertificate 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
//
// Asynchronously look up the issuer of @certificate in the database. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (self *TlsDatabaseInstance) LookupCertificateIssuerAsync(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted, nullable
	var carg3 C.GTlsDatabaseLookupFlags // in, none, casted
	var carg4 *C.GCancellable           // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback     // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_lookup_certificate_issuer_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// LookupCertificateIssuerFinish wraps g_tls_database_lookup_certificate_issuer_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup issuer operation. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (self *TlsDatabaseInstance) LookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase    // in, none, converted
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificate_issuer_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LookupCertificatesIssuedByFinish wraps g_tls_database_lookup_certificates_issued_by_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret []TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup of certificates. See
// g_tls_database_lookup_certificates_issued_by() for more information.
func (self *TlsDatabaseInstance) LookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error) {
	var carg0 *C.GTlsDatabase // in, none, converted
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_lookup_certificates_issued_by_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VerifyChain wraps g_tls_database_verify_chain
// 
// The function takes the following parameters:
// 
// 	- chain TlsCertificate: a #GTlsCertificate chain 
// 	- purpose string: the purpose that this certificate chain will be used for. 
// 	- identity SocketConnectable (nullable): the expected peer identity 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
// 	- _goerr error (nullable): an error 
//
// Determines the validity of a certificate chain, outside the context
// of a TLS session.
// 
// @chain is a chain of #GTlsCertificate objects each pointing to the next
// certificate in the chain by its #GTlsCertificate:issuer property.
// 
// @purpose describes the purpose (or usage) for which the certificate
// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
// which means that the certificate is being used to authenticate a server
// (and we are acting as the client).
// 
// The @identity is used to ensure the server certificate is valid for
// the expected peer identity. If the identity does not match the
// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
// return value. If @identity is %NULL, that bit will never be set in
// the return value. The peer identity may also be used to check for
// pinned certificates (trust exceptions) in the database. These may
// override the normal verification process on a host-by-host basis.
// 
// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
// used.
// 
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate at
// least one problem found. If the function is unable to determine
// whether @chain is valid (for example, because @cancellable is
// triggered before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to
// be invalid.
// 
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
// 
// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
// represent the certification path built by #GTlsDatabase during
// certificate verification by adjusting the #GTlsCertificate:issuer
// property of each certificate in @chain. Since GLib 2.48, this no
// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
// represent the actual certification path used during certificate
// verification.
// 
// Because TLS session context is not used, #GTlsDatabase may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
// 
// The TLS backend may attempt to look up and add missing certificates
// to the chain. This may involve HTTP requests to download missing
// certificates.
// 
// This function can block. Use g_tls_database_verify_chain_async() to
// perform the verification operation asynchronously.
func (self *TlsDatabaseInstance) VerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, string
	var carg3 *C.GSocketConnectable     // in, none, converted, nullable
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, casted
	var carg6 *C.GCancellable           // in, none, converted, nullable
	var cret  C.GTlsCertificateFlags    // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_database_verify_chain(carg0, carg1, carg2, carg3, carg4, carg5, carg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// VerifyChainAsync wraps g_tls_database_verify_chain_async
// 
// The function takes the following parameters:
// 
// 	- chain TlsCertificate: a #GTlsCertificate chain 
// 	- purpose string: the purpose that this certificate chain will be used for. 
// 	- identity SocketConnectable (nullable): the expected peer identity 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 	- callback AsyncReadyCallback (nullable): callback to call when the operation completes 
//
// Asynchronously determines the validity of a certificate chain after
// looking up and adding any missing certificates to the chain. See
// g_tls_database_verify_chain() for more information.
func (self *TlsDatabaseInstance) VerifyChainAsync(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsDatabase           // in, none, converted
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, string
	var carg3 *C.GSocketConnectable     // in, none, converted, nullable
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, casted
	var carg6 *C.GCancellable           // in, none, converted, nullable
	var carg7 C.GAsyncReadyCallback     // callback, scope: async, closure: carg8, nullable
	var carg8 C.gpointer                // implicit

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg7 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg8 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_database_verify_chain_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// VerifyChainFinish wraps g_tls_database_verify_chain_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
// 
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate
// the problems found. If the function is unable to determine whether
// @chain is valid or not (eg, because @cancellable is triggered
// before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
// accordingly. @error is not set when @chain is successfully analyzed
// but found to be invalid.
func (self *TlsDatabaseInstance) VerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase        // in, none, converted
	var carg1 *C.GAsyncResult        // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_database_verify_chain_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsDatabaseOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsDatabaseOverrides[Instance TlsDatabase] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // CreateCertificateHandle allows you to override the implementation of the virtual method create_certificate_handle.
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: certificate for which to create a handle. 
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Create a handle string for the certificate. The database will only be able
	// to create a handle for certificates that originate from the database. In
	// cases where the database cannot create a handle for a certificate, %NULL
	// will be returned.
	// 
	// This handle should be stable across various instances of the application,
	// and between applications. If a certificate is modified in the database,
	// then it is not guaranteed that this handle will continue to point to it.
	CreateCertificateHandle func(Instance, TlsCertificate) string
	// // LookupCertificateForHandle allows you to override the implementation of the virtual method lookup_certificate_for_handle.
	// 
	// The function takes the following parameters:
	// 
	// 	- handle string: a certificate handle 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Look up a certificate by its handle.
	// 
	// The handle should have been created by calling
	// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
	// the same TLS backend. The handle is designed to remain valid across
	// instantiations of the database.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	// 
	// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
	// the lookup operation asynchronously.
	LookupCertificateForHandle func(Instance, string, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// // LookupCertificateForHandleFinish allows you to override the implementation of the virtual method lookup_certificate_for_handle_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of a certificate by its handle. See
	// g_tls_database_lookup_certificate_for_handle() for more information.
	// 
	// If the handle is no longer valid, or does not point to a certificate in
	// this database, then %NULL will be returned.
	LookupCertificateForHandleFinish func(Instance, AsyncResult) (TlsCertificate, error)
	// // LookupCertificateIssuer allows you to override the implementation of the virtual method lookup_certificate_issuer.
	// 
	// The function takes the following parameters:
	// 
	// 	- certificate TlsCertificate: a #GTlsCertificate 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Look up the issuer of @certificate in the database. The
	// #GTlsCertificate:issuer property of @certificate is not modified, and
	// the two certificates are not hooked into a chain.
	// 
	// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
	// to perform the lookup operation asynchronously.
	// 
	// Beware this function cannot be used to build certification paths. The
	// issuer certificate returned by this function may not be the same as
	// the certificate that would actually be used to construct a valid
	// certification path during certificate verification.
	// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
	// why an issuer certificate cannot be naively assumed to be part of the
	// the certification path (though GLib's TLS backends may not follow the
	// path building strategies outlined in this RFC). Due to the complexity
	// of certification path building, GLib does not provide any way to know
	// which certification path will actually be used when verifying a TLS
	// certificate. Accordingly, this function cannot be used to make
	// security-related decisions. Only GLib itself should make security
	// decisions about TLS certificates.
	LookupCertificateIssuer func(Instance, TlsCertificate, TlsInteraction, TlsDatabaseLookupFlags, Cancellable) (TlsCertificate, error)
	// // LookupCertificateIssuerFinish allows you to override the implementation of the virtual method lookup_certificate_issuer_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup issuer operation. See
	// g_tls_database_lookup_certificate_issuer() for more information.
	LookupCertificateIssuerFinish func(Instance, AsyncResult) (TlsCertificate, error)
	// // LookupCertificatesIssuedByFinish allows you to override the implementation of the virtual method lookup_certificates_issued_by_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret []TlsCertificate 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous lookup of certificates. See
	// g_tls_database_lookup_certificates_issued_by() for more information.
	LookupCertificatesIssuedByFinish func(Instance, AsyncResult) ([]TlsCertificate, error)
	// // VerifyChain allows you to override the implementation of the virtual method verify_chain.
	// 
	// The function takes the following parameters:
	// 
	// 	- chain TlsCertificate: a #GTlsCertificate chain 
	// 	- purpose string: the purpose that this certificate chain will be used for. 
	// 	- identity SocketConnectable (nullable): the expected peer identity 
	// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
	// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
	// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Determines the validity of a certificate chain, outside the context
	// of a TLS session.
	// 
	// @chain is a chain of #GTlsCertificate objects each pointing to the next
	// certificate in the chain by its #GTlsCertificate:issuer property.
	// 
	// @purpose describes the purpose (or usage) for which the certificate
	// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
	// which means that the certificate is being used to authenticate a server
	// (and we are acting as the client).
	// 
	// The @identity is used to ensure the server certificate is valid for
	// the expected peer identity. If the identity does not match the
	// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
	// return value. If @identity is %NULL, that bit will never be set in
	// the return value. The peer identity may also be used to check for
	// pinned certificates (trust exceptions) in the database. These may
	// override the normal verification process on a host-by-host basis.
	// 
	// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
	// used.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate at
	// least one problem found. If the function is unable to determine
	// whether @chain is valid (for example, because @cancellable is
	// triggered before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
	// @error is not set when @chain is successfully analyzed but found to
	// be invalid.
	// 
	// GLib guarantees that if certificate verification fails, at least one
	// error will be set in the return value, but it does not guarantee
	// that all possible errors will be set. Accordingly, you may not safely
	// decide to ignore any particular type of error. For example, it would
	// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
	// expired certificates, because this could potentially be the only
	// error flag set even if other problems exist with the certificate.
	// 
	// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
	// represent the certification path built by #GTlsDatabase during
	// certificate verification by adjusting the #GTlsCertificate:issuer
	// property of each certificate in @chain. Since GLib 2.48, this no
	// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
	// represent the actual certification path used during certificate
	// verification.
	// 
	// Because TLS session context is not used, #GTlsDatabase may not
	// perform as many checks on the certificates as #GTlsConnection would.
	// For example, certificate constraints may not be honored, and
	// revocation checks may not be performed. The best way to verify TLS
	// certificates used by a TLS connection is to let #GTlsConnection
	// handle the verification.
	// 
	// The TLS backend may attempt to look up and add missing certificates
	// to the chain. This may involve HTTP requests to download missing
	// certificates.
	// 
	// This function can block. Use g_tls_database_verify_chain_async() to
	// perform the verification operation asynchronously.
	VerifyChain func(Instance, TlsCertificate, string, SocketConnectable, TlsInteraction, TlsDatabaseVerifyFlags, Cancellable) (TlsCertificateFlags, error)
	// // VerifyChainFinish allows you to override the implementation of the virtual method verify_chain_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsCertificateFlags 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous verify chain operation. See
	// g_tls_database_verify_chain() for more information.
	// 
	// If @chain is found to be valid, then the return value will be 0. If
	// @chain is found to be invalid, then the return value will indicate
	// the problems found. If the function is unable to determine whether
	// @chain is valid or not (eg, because @cancellable is triggered
	// before it completes) then the return value will be
	// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
	// accordingly. @error is not set when @chain is successfully analyzed
	// but found to be invalid.
	VerifyChainFinish func(Instance, AsyncResult) (TlsCertificateFlags, error)
}

// UnsafeApplyTlsDatabaseOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsDatabaseOverrides[Instance TlsDatabase](gclass unsafe.Pointer, overrides TlsDatabaseOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsDatabaseClass)(gclass)

	if overrides.CreateCertificateHandle != nil {
		pclass.create_certificate_handle = (*[0]byte)(C._goglib_gio2_TlsDatabase_create_certificate_handle)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_create_certificate_handle",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate) (cret *C.gchar) {
				var self        Instance       // go GTlsDatabase subclass
				var certificate TlsCertificate // in, none, converted
				var goret       string         // return, full, string, nullable-string

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				certificate = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))

				goret = overrides.CreateCertificateHandle(self, certificate)

				if goret != "" {
					cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.LookupCertificateForHandle != nil {
		pclass.lookup_certificate_for_handle = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_for_handle)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_for_handle",
			func(carg0 *C.GTlsDatabase, carg1 *C.gchar, carg2 *C.GTlsInteraction, carg3 C.GTlsDatabaseLookupFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self        Instance               // go GTlsDatabase subclass
				var handle      string                 // in, none, string
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseLookupFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificate         // return, full, converted, nullable
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				handle = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg2))
				}
				flags = TlsDatabaseLookupFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LookupCertificateForHandle(self, handle, interaction, flags, cancellable)

				if goret != nil {
					cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateForHandleFinish != nil {
		pclass.lookup_certificate_for_handle_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_for_handle_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self   Instance       // go GTlsDatabase subclass
				var result AsyncResult    // in, none, converted
				var goret  TlsCertificate // return, full, converted
				var _goerr error          // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificateForHandleFinish(self, result)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateIssuer != nil {
		pclass.lookup_certificate_issuer = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_issuer)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_issuer",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate, carg2 *C.GTlsInteraction, carg3 C.GTlsDatabaseLookupFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self        Instance               // go GTlsDatabase subclass
				var certificate TlsCertificate         // in, none, converted
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseLookupFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificate         // return, full, converted
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				certificate = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg2))
				}
				flags = TlsDatabaseLookupFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LookupCertificateIssuer(self, certificate, interaction, flags, cancellable)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificateIssuerFinish != nil {
		pclass.lookup_certificate_issuer_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificate_issuer_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GTlsCertificate) {
				var self   Instance       // go GTlsDatabase subclass
				var result AsyncResult    // in, none, converted
				var goret  TlsCertificate // return, full, converted
				var _goerr error          // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificateIssuerFinish(self, result)

				cret = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.LookupCertificatesIssuedByFinish != nil {
		pclass.lookup_certificates_issued_by_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_lookup_certificates_issued_by_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
				var self   Instance         // go GTlsDatabase subclass
				var result AsyncResult      // in, none, converted
				var goret  []TlsCertificate // return, transfer: full, C Pointers: 1, Name: List, scope: 
				var _goerr error            // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.LookupCertificatesIssuedByFinish(self, result)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []TlsCertificate (GList*) because of no basic converter found")
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.VerifyChain != nil {
		pclass.verify_chain = (*[0]byte)(C._goglib_gio2_TlsDatabase_verify_chain)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_verify_chain",
			func(carg0 *C.GTlsDatabase, carg1 *C.GTlsCertificate, carg2 *C.gchar, carg3 *C.GSocketConnectable, carg4 *C.GTlsInteraction, carg5 C.GTlsDatabaseVerifyFlags, carg6 *C.GCancellable, _cerr **C.GError) (cret C.GTlsCertificateFlags) {
				var self        Instance               // go GTlsDatabase subclass
				var chain       TlsCertificate         // in, none, converted
				var purpose     string                 // in, none, string
				var identity    SocketConnectable      // in, none, converted, nullable
				var interaction TlsInteraction         // in, none, converted, nullable
				var flags       TlsDatabaseVerifyFlags // in, none, casted
				var cancellable Cancellable            // in, none, converted, nullable
				var goret       TlsCertificateFlags    // return, none, casted
				var _goerr      error                  // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				chain = UnsafeTlsCertificateFromGlibNone(unsafe.Pointer(carg1))
				purpose = C.GoString((*C.char)(unsafe.Pointer(carg2)))
				if carg3 != nil {
					identity = UnsafeSocketConnectableFromGlibNone(unsafe.Pointer(carg3))
				}
				if carg4 != nil {
					interaction = UnsafeTlsInteractionFromGlibNone(unsafe.Pointer(carg4))
				}
				flags = TlsDatabaseVerifyFlags(carg5)
				if carg6 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg6))
				}

				goret, _goerr = overrides.VerifyChain(self, chain, purpose, identity, interaction, flags, cancellable)

				cret = C.GTlsCertificateFlags(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.VerifyChainFinish != nil {
		pclass.verify_chain_finish = (*[0]byte)(C._goglib_gio2_TlsDatabase_verify_chain_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsDatabase_verify_chain_finish",
			func(carg0 *C.GTlsDatabase, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsCertificateFlags) {
				var self   Instance            // go GTlsDatabase subclass
				var result AsyncResult         // in, none, converted
				var goret  TlsCertificateFlags // return, none, casted
				var _goerr error               // out, full, converted

				self = UnsafeTlsDatabaseFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.VerifyChainFinish(self, result)

				cret = C.GTlsCertificateFlags(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCreateCertificateHandle calls the default implementations of the `GTlsDatabase.create_certificate_handle` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: certificate for which to create a handle. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Create a handle string for the certificate. The database will only be able
// to create a handle for certificates that originate from the database. In
// cases where the database cannot create a handle for a certificate, %NULL
// will be returned.
// 
// This handle should be stable across various instances of the application,
// and between applications. If a certificate is modified in the database,
// then it is not guaranteed that this handle will continue to point to it.
func (self *TlsDatabaseInstance) ParentCreateCertificateHandle(certificate TlsCertificate) string {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate // in, none, converted
	var cret  *C.gchar           // return, full, string, nullable-string

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))

	cret = C._goglib_gio2_TlsDatabase_virtual_create_certificate_handle(unsafe.Pointer(parentclass.create_certificate_handle), carg0, carg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentLookupCertificateForHandle calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- handle string: a certificate handle 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: Flags which affect the lookup. 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate (nullable) 
// 	- _goerr error (nullable): an error 
//
// Look up a certificate by its handle.
// 
// The handle should have been created by calling
// g_tls_database_create_certificate_handle() on a #GTlsDatabase object of
// the same TLS backend. The handle is designed to remain valid across
// instantiations of the database.
// 
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
// 
// This function can block, use g_tls_database_lookup_certificate_for_handle_async() to perform
// the lookup operation asynchronously.
func (self *TlsDatabaseInstance) ParentLookupCertificateForHandle(handle string, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.gchar                  // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, string
	var carg3 C.GTlsDatabaseLookupFlags // in, none, converted, nullable
	var carg4 *C.GCancellable           // in, none, casted
	var cret  *C.GTlsCertificate        // return, full, converted, nullable
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(handle)))
	defer C.free(unsafe.Pointer(carg1))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle(unsafe.Pointer(parentclass.lookup_certificate_for_handle), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	if cret != nil {
		goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateForHandleFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_for_handle_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup of a certificate by its handle. See
// g_tls_database_lookup_certificate_for_handle() for more information.
// 
// If the handle is no longer valid, or does not point to a certificate in
// this database, then %NULL will be returned.
func (self *TlsDatabaseInstance) ParentLookupCertificateForHandleFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_for_handle_finish(unsafe.Pointer(parentclass.lookup_certificate_for_handle_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateIssuer calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- certificate TlsCertificate: a #GTlsCertificate 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseLookupFlags: flags which affect the lookup operation 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Look up the issuer of @certificate in the database. The
// #GTlsCertificate:issuer property of @certificate is not modified, and
// the two certificates are not hooked into a chain.
// 
// This function can block. Use g_tls_database_lookup_certificate_issuer_async()
// to perform the lookup operation asynchronously.
// 
// Beware this function cannot be used to build certification paths. The
// issuer certificate returned by this function may not be the same as
// the certificate that would actually be used to construct a valid
// certification path during certificate verification.
// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
// why an issuer certificate cannot be naively assumed to be part of the
// the certification path (though GLib's TLS backends may not follow the
// path building strategies outlined in this RFC). Due to the complexity
// of certification path building, GLib does not provide any way to know
// which certification path will actually be used when verifying a TLS
// certificate. Accordingly, this function cannot be used to make
// security-related decisions. Only GLib itself should make security
// decisions about TLS certificates.
func (self *TlsDatabaseInstance) ParentLookupCertificateIssuer(certificate TlsCertificate, interaction TlsInteraction, flags TlsDatabaseLookupFlags, cancellable Cancellable) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.GTlsInteraction        // in, none, converted
	var carg3 C.GTlsDatabaseLookupFlags // in, none, converted, nullable
	var carg4 *C.GCancellable           // in, none, casted
	var cret  *C.GTlsCertificate        // return, full, converted
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(certificate))
	if interaction != nil {
		carg2 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg3 = C.GTlsDatabaseLookupFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer(unsafe.Pointer(parentclass.lookup_certificate_issuer), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(certificate)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificateIssuerFinish calls the default implementations of the `GTlsDatabase.lookup_certificate_issuer_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup issuer operation. See
// g_tls_database_lookup_certificate_issuer() for more information.
func (self *TlsDatabaseInstance) ParentLookupCertificateIssuerFinish(result AsyncResult) (TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult    // in, none, converted
	var cret  *C.GTlsCertificate // return, full, converted
	var _cerr *C.GError          // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificate_issuer_finish(unsafe.Pointer(parentclass.lookup_certificate_issuer_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificate
	var _goerr error

	goret = UnsafeTlsCertificateFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentLookupCertificatesIssuedByFinish calls the default implementations of the `GTlsDatabase.lookup_certificates_issued_by_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret []TlsCertificate 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous lookup of certificates. See
// g_tls_database_lookup_certificates_issued_by() for more information.
func (self *TlsDatabaseInstance) ParentLookupCertificatesIssuedByFinish(result AsyncResult) ([]TlsCertificate, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GList        // container, transfer: full
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_lookup_certificates_issued_by_finish(unsafe.Pointer(parentclass.lookup_certificates_issued_by_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  []TlsCertificate
	var _goerr error

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) TlsCertificate {
			var dst TlsCertificate // converted
			dst = UnsafeTlsCertificateFromGlibFull(v)
			return dst
		},
	)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentVerifyChain calls the default implementations of the `GTlsDatabase.verify_chain` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- chain TlsCertificate: a #GTlsCertificate chain 
// 	- purpose string: the purpose that this certificate chain will be used for. 
// 	- identity SocketConnectable (nullable): the expected peer identity 
// 	- interaction TlsInteraction (nullable): used to interact with the user if necessary 
// 	- flags TlsDatabaseVerifyFlags: additional verify flags 
// 	- cancellable Cancellable (nullable): a #GCancellable, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
// 	- _goerr error (nullable): an error 
//
// Determines the validity of a certificate chain, outside the context
// of a TLS session.
// 
// @chain is a chain of #GTlsCertificate objects each pointing to the next
// certificate in the chain by its #GTlsCertificate:issuer property.
// 
// @purpose describes the purpose (or usage) for which the certificate
// is being used. Typically @purpose will be set to %G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
// which means that the certificate is being used to authenticate a server
// (and we are acting as the client).
// 
// The @identity is used to ensure the server certificate is valid for
// the expected peer identity. If the identity does not match the
// certificate, %G_TLS_CERTIFICATE_BAD_IDENTITY will be set in the
// return value. If @identity is %NULL, that bit will never be set in
// the return value. The peer identity may also be used to check for
// pinned certificates (trust exceptions) in the database. These may
// override the normal verification process on a host-by-host basis.
// 
// Currently there are no @flags, and %G_TLS_DATABASE_VERIFY_NONE should be
// used.
// 
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate at
// least one problem found. If the function is unable to determine
// whether @chain is valid (for example, because @cancellable is
// triggered before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set accordingly.
// @error is not set when @chain is successfully analyzed but found to
// be invalid.
// 
// GLib guarantees that if certificate verification fails, at least one
// error will be set in the return value, but it does not guarantee
// that all possible errors will be set. Accordingly, you may not safely
// decide to ignore any particular type of error. For example, it would
// be incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
// expired certificates, because this could potentially be the only
// error flag set even if other problems exist with the certificate.
// 
// Prior to GLib 2.48, GLib's default TLS backend modified @chain to
// represent the certification path built by #GTlsDatabase during
// certificate verification by adjusting the #GTlsCertificate:issuer
// property of each certificate in @chain. Since GLib 2.48, this no
// longer occurs, so you cannot rely on #GTlsCertificate:issuer to
// represent the actual certification path used during certificate
// verification.
// 
// Because TLS session context is not used, #GTlsDatabase may not
// perform as many checks on the certificates as #GTlsConnection would.
// For example, certificate constraints may not be honored, and
// revocation checks may not be performed. The best way to verify TLS
// certificates used by a TLS connection is to let #GTlsConnection
// handle the verification.
// 
// The TLS backend may attempt to look up and add missing certificates
// to the chain. This may involve HTTP requests to download missing
// certificates.
// 
// This function can block. Use g_tls_database_verify_chain_async() to
// perform the verification operation asynchronously.
func (self *TlsDatabaseInstance) ParentVerifyChain(chain TlsCertificate, purpose string, identity SocketConnectable, interaction TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable Cancellable) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GTlsCertificate        // in, none, converted
	var carg2 *C.gchar                  // in, none, converted
	var carg3 *C.GSocketConnectable     // in, none, string
	var carg4 *C.GTlsInteraction        // in, none, converted, nullable
	var carg5 C.GTlsDatabaseVerifyFlags // in, none, converted, nullable
	var carg6 *C.GCancellable           // in, none, casted
	var cret  C.GTlsCertificateFlags    // return, none, casted
	var _cerr *C.GError                 // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GTlsCertificate)(UnsafeTlsCertificateToGlibNone(chain))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(purpose)))
	defer C.free(unsafe.Pointer(carg2))
	if identity != nil {
		carg3 = (*C.GSocketConnectable)(UnsafeSocketConnectableToGlibNone(identity))
	}
	if interaction != nil {
		carg4 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	}
	carg5 = C.GTlsDatabaseVerifyFlags(flags)
	if cancellable != nil {
		carg6 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsDatabase_virtual_verify_chain(unsafe.Pointer(parentclass.verify_chain), carg0, carg1, carg2, carg3, carg4, carg5, carg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(chain)
	runtime.KeepAlive(purpose)
	runtime.KeepAlive(identity)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentVerifyChainFinish calls the default implementations of the `GTlsDatabase.verify_chain_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret TlsCertificateFlags 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous verify chain operation. See
// g_tls_database_verify_chain() for more information.
// 
// If @chain is found to be valid, then the return value will be 0. If
// @chain is found to be invalid, then the return value will indicate
// the problems found. If the function is unable to determine whether
// @chain is valid or not (eg, because @cancellable is triggered
// before it completes) then the return value will be
// %G_TLS_CERTIFICATE_GENERIC_ERROR and @error will be set
// accordingly. @error is not set when @chain is successfully analyzed
// but found to be invalid.
func (self *TlsDatabaseInstance) ParentVerifyChainFinish(result AsyncResult) (TlsCertificateFlags, error) {
	var carg0 *C.GTlsDatabase
	var carg1 *C.GAsyncResult        // in, none, converted
	var cret  C.GTlsCertificateFlags // return, none, casted
	var _cerr *C.GError              // out, full, converted, nullable

	parentclass := (*C.GTlsDatabaseClass)(classdata.PeekParentClass(UnsafeTlsDatabaseToGlibNone(self)))

	carg0 = (*C.GTlsDatabase)(UnsafeTlsDatabaseToGlibNone(self))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsDatabase_virtual_verify_chain_finish(unsafe.Pointer(parentclass.verify_chain_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(result)

	var goret  TlsCertificateFlags
	var _goerr error

	goret = TlsCertificateFlags(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsDatabaseSubClass is used to register a go subclass of GTlsDatabase. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsDatabaseSubClass[InstanceT TlsDatabase](
		name string,
		classInit func(class *TlsDatabaseClass),
		constructor func() InstanceT,
		overrides TlsDatabaseOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsDatabase,
		UnsafeTlsDatabaseClassFromGlibBorrow,
		UnsafeApplyTlsDatabaseOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsDatabase(obj)
		},
		interfaceInits...,
	)
}

// TlsInteractionInstance is the instance type used by all types extending GTlsInteraction. It is used internally by the bindings. Users should use the interface [TlsInteraction] instead.
type TlsInteractionInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsInteraction = (*TlsInteractionInstance)(nil)

// TlsInteraction wraps GTlsInteraction
//
// `GTlsInteraction` provides a mechanism for the TLS connection and database
// code to interact with the user. It can be used to ask the user for passwords.
// 
// To use a `GTlsInteraction` with a TLS connection use
// [method@Gio.TlsConnection.set_interaction].
// 
// Callers should instantiate a derived class that implements the various
// interaction methods to show the required dialogs.
// 
// Callers should use the 'invoke' functions like
// [method@Gio.TlsInteraction.invoke_ask_password] to run interaction methods.
// These functions make sure that the interaction is invoked in the main loop
// and not in the current thread, if the current thread is not running the
// main loop.
// 
// Derived classes can choose to implement whichever interactions methods they&#x2019;d
// like to support by overriding those virtual methods in their class
// initialization function. Any interactions not implemented will return
// `G_TLS_INTERACTION_UNHANDLED`. If a derived class implements an async method,
// it must also implement the corresponding finish method.
type TlsInteraction interface {
	gobject.Object
	upcastToGTlsInteraction() *TlsInteractionInstance

	// AskPassword wraps g_tls_interaction_ask_password
	// 
	// The function takes the following parameters:
	// 
	// 	- password TlsPassword: a #GTlsPassword object 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user for a password. In general,
	// g_tls_interaction_invoke_ask_password() should be used instead of this
	// function.
	// 
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value will
	// be filled in and then @callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	AskPassword(TlsPassword, Cancellable) (TlsInteractionResult, error)
	// AskPasswordAsync wraps g_tls_interaction_ask_password_async
	// 
	// The function takes the following parameters:
	// 
	// 	- password TlsPassword: a #GTlsPassword object 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 	- callback AsyncReadyCallback (nullable): will be called when the interaction completes 
	//
	// Run asynchronous interaction to ask the user for a password. In general,
	// g_tls_interaction_invoke_ask_password() should be used instead of this
	// function.
	// 
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value will
	// be filled in and then @callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	// 
	// Certain implementations may not support immediate cancellation.
	AskPasswordAsync(TlsPassword, Cancellable, AsyncReadyCallback)
	// AskPasswordFinish wraps g_tls_interaction_ask_password_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete an ask password user interaction request. This should be once
	// the g_tls_interaction_ask_password_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
	// to g_tls_interaction_ask_password() will have its password filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	AskPasswordFinish(AsyncResult) (TlsInteractionResult, error)
	// InvokeAskPassword wraps g_tls_interaction_invoke_ask_password
	// 
	// The function takes the following parameters:
	// 
	// 	- password TlsPassword: a #GTlsPassword object 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Invoke the interaction to ask the user for a password. It invokes this
	// interaction in the main loop, specifically the #GMainContext returned by
	// g_main_context_get_thread_default() when the interaction is created. This
	// is called by called by #GTlsConnection or #GTlsDatabase to ask the user
	// for a password.
	// 
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value will
	// be filled in and then @callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	// 
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeAskPassword(TlsPassword, Cancellable) (TlsInteractionResult, error)
	// InvokeRequestCertificate wraps g_tls_interaction_invoke_request_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- connection TlsConnection: a #GTlsConnection object 
	// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Invoke the interaction to ask the user to choose a certificate to
	// use with the connection. It invokes this interaction in the main
	// loop, specifically the #GMainContext returned by
	// g_main_context_get_thread_default() when the interaction is
	// created. This is called by called by #GTlsConnection when the peer
	// requests a certificate during the handshake.
	// 
	// Derived subclasses usually implement a certificate selector,
	// although they may also choose to provide a certificate from
	// elsewhere. Alternatively the user may abort this certificate
	// request, which may or may not abort the TLS connection.
	// 
	// The implementation can either be a synchronous (eg: modal dialog) or an
	// asynchronous one (eg: modeless dialog). This function will take care of
	// calling which ever one correctly.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	InvokeRequestCertificate(TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// RequestCertificate wraps g_tls_interaction_request_certificate
	// 
	// The function takes the following parameters:
	// 
	// 	- connection TlsConnection: a #GTlsConnection object 
	// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user to choose a certificate to use
	// with the connection. In general, g_tls_interaction_invoke_request_certificate()
	// should be used instead of this function.
	// 
	// Derived subclasses usually implement a certificate selector, although they may
	// also choose to provide a certificate from elsewhere. Alternatively the user may
	// abort this certificate request, which will usually abort the TLS connection.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	RequestCertificate(TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// RequestCertificateAsync wraps g_tls_interaction_request_certificate_async
	// 
	// The function takes the following parameters:
	// 
	// 	- connection TlsConnection: a #GTlsConnection object 
	// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 	- callback AsyncReadyCallback (nullable): will be called when the interaction completes 
	//
	// Run asynchronous interaction to ask the user for a certificate to use with
	// the connection. In general, g_tls_interaction_invoke_request_certificate() should
	// be used instead of this function.
	// 
	// Derived subclasses usually implement a certificate selector, although they may
	// also choose to provide a certificate from elsewhere. @callback will be called
	// when the operation completes. Alternatively the user may abort this certificate
	// request, which will usually abort the TLS connection.
	RequestCertificateAsync(TlsConnection, TlsCertificateRequestFlags, Cancellable, AsyncReadyCallback)
	// RequestCertificateFinish wraps g_tls_interaction_request_certificate_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete a request certificate user interaction request. This should be once
	// the g_tls_interaction_request_certificate_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate_async() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	RequestCertificateFinish(AsyncResult) (TlsInteractionResult, error)

	// chain up virtual methods:

	// ParentAskPassword calls the default implementations of the `GTlsInteraction.ask_password` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- password TlsPassword: a #GTlsPassword object 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user for a password. In general,
	// g_tls_interaction_invoke_ask_password() should be used instead of this
	// function.
	// 
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value will
	// be filled in and then @callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	ParentAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error)
	// ParentAskPasswordFinish calls the default implementations of the `GTlsInteraction.ask_password_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete an ask password user interaction request. This should be once
	// the g_tls_interaction_ask_password_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
	// to g_tls_interaction_ask_password() will have its password filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	ParentAskPasswordFinish(result AsyncResult) (TlsInteractionResult, error)
	// ParentRequestCertificate calls the default implementations of the `GTlsInteraction.request_certificate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection TlsConnection: a #GTlsConnection object 
	// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user to choose a certificate to use
	// with the connection. In general, g_tls_interaction_invoke_request_certificate()
	// should be used instead of this function.
	// 
	// Derived subclasses usually implement a certificate selector, although they may
	// also choose to provide a certificate from elsewhere. Alternatively the user may
	// abort this certificate request, which will usually abort the TLS connection.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	ParentRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error)
	// ParentRequestCertificateFinish calls the default implementations of the `GTlsInteraction.request_certificate_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete a request certificate user interaction request. This should be once
	// the g_tls_interaction_request_certificate_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate_async() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	ParentRequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error)
}

func unsafeWrapTlsInteraction(base *gobject.ObjectInstance) *TlsInteractionInstance {
	return &TlsInteractionInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsInteraction,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsInteraction(inst)
		},
	)
}

func marshalTlsInteractionInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsInteractionFromGlibNone is used to convert raw GTlsInteraction pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibNone(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsInteraction)
}

// UnsafeTlsInteractionFromGlibFull is used to convert raw GTlsInteraction pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibFull(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsInteraction)
}

// UnsafeTlsInteractionFromGlibBorrow is used to convert raw GTlsInteraction pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsInteractionFromGlibBorrow(c unsafe.Pointer) TlsInteraction {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsInteraction)
}

func (t *TlsInteractionInstance) upcastToGTlsInteraction() *TlsInteractionInstance {
	return t
}

// UnsafeTlsInteractionToGlibNone is used to convert the instance to it's C value GTlsInteraction. This is used by the bindings internally.
func UnsafeTlsInteractionToGlibNone(c TlsInteraction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsInteractionToGlibFull is used to convert the instance to it's C value GTlsInteraction, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsInteractionToGlibFull(c TlsInteraction) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// AskPassword wraps g_tls_interaction_ask_password
// 
// The function takes the following parameters:
// 
// 	- password TlsPassword: a #GTlsPassword object 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Run synchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) AskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_ask_password(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// AskPasswordAsync wraps g_tls_interaction_ask_password_async
// 
// The function takes the following parameters:
// 
// 	- password TlsPassword: a #GTlsPassword object 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 	- callback AsyncReadyCallback (nullable): will be called when the interaction completes 
//
// Run asynchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
// 
// Certain implementations may not support immediate cancellation.
func (interaction *TlsInteractionInstance) AskPasswordAsync(password TlsPassword, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsInteraction    // in, none, converted
	var carg1 *C.GTlsPassword       // in, none, converted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_interaction_ask_password_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// AskPasswordFinish wraps g_tls_interaction_ask_password_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to the callback 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Complete an ask password user interaction request. This should be once
// the g_tls_interaction_ask_password_async() completion callback is called.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
// to g_tls_interaction_ask_password() will have its password filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (interaction *TlsInteractionInstance) AskPasswordFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_interaction_ask_password_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InvokeAskPassword wraps g_tls_interaction_invoke_ask_password
// 
// The function takes the following parameters:
// 
// 	- password TlsPassword: a #GTlsPassword object 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Invoke the interaction to ask the user for a password. It invokes this
// interaction in the main loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is created. This
// is called by called by #GTlsConnection or #GTlsDatabase to ask the user
// for a password.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
// 
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) InvokeAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_invoke_ask_password(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// InvokeRequestCertificate wraps g_tls_interaction_invoke_request_certificate
// 
// The function takes the following parameters:
// 
// 	- connection TlsConnection: a #GTlsConnection object 
// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Invoke the interaction to ask the user to choose a certificate to
// use with the connection. It invokes this interaction in the main
// loop, specifically the #GMainContext returned by
// g_main_context_get_thread_default() when the interaction is
// created. This is called by called by #GTlsConnection when the peer
// requests a certificate during the handshake.
// 
// Derived subclasses usually implement a certificate selector,
// although they may also choose to provide a certificate from
// elsewhere. Alternatively the user may abort this certificate
// request, which may or may not abort the TLS connection.
// 
// The implementation can either be a synchronous (eg: modal dialog) or an
// asynchronous one (eg: modeless dialog). This function will take care of
// calling which ever one correctly.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) InvokeRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_invoke_request_certificate(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RequestCertificate wraps g_tls_interaction_request_certificate
// 
// The function takes the following parameters:
// 
// 	- connection TlsConnection: a #GTlsConnection object 
// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Run synchronous interaction to ask the user to choose a certificate to use
// with the connection. In general, g_tls_interaction_invoke_request_certificate()
// should be used instead of this function.
// 
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. Alternatively the user may
// abort this certificate request, which will usually abort the TLS connection.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate() will have had its
// #GTlsConnection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) RequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_tls_interaction_request_certificate(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RequestCertificateAsync wraps g_tls_interaction_request_certificate_async
// 
// The function takes the following parameters:
// 
// 	- connection TlsConnection: a #GTlsConnection object 
// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 	- callback AsyncReadyCallback (nullable): will be called when the interaction completes 
//
// Run asynchronous interaction to ask the user for a certificate to use with
// the connection. In general, g_tls_interaction_invoke_request_certificate() should
// be used instead of this function.
// 
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. @callback will be called
// when the operation completes. Alternatively the user may abort this certificate
// request, which will usually abort the TLS connection.
func (interaction *TlsInteractionInstance) RequestCertificateAsync(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GTlsInteraction            // in, none, converted
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, casted
	var carg3 *C.GCancellable               // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback         // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer                    // implicit

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_tls_interaction_request_certificate_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// RequestCertificateFinish wraps g_tls_interaction_request_certificate_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to the callback 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Complete a request certificate user interaction request. This should be once
// the g_tls_interaction_request_certificate_async() completion callback is called.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate_async() will have had its
// #GTlsConnection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (interaction *TlsInteractionInstance) RequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction      // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_tls_interaction_request_certificate_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TlsInteractionOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsInteractionOverrides[Instance TlsInteraction] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // AskPassword allows you to override the implementation of the virtual method ask_password.
	// 
	// The function takes the following parameters:
	// 
	// 	- password TlsPassword: a #GTlsPassword object 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user for a password. In general,
	// g_tls_interaction_invoke_ask_password() should be used instead of this
	// function.
	// 
	// Derived subclasses usually implement a password prompt, although they may
	// also choose to provide a password from elsewhere. The @password value will
	// be filled in and then @callback will be called. Alternatively the user may
	// abort this password request, which will usually abort the TLS connection.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	AskPassword func(Instance, TlsPassword, Cancellable) (TlsInteractionResult, error)
	// // AskPasswordFinish allows you to override the implementation of the virtual method ask_password_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete an ask password user interaction request. This should be once
	// the g_tls_interaction_ask_password_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
	// to g_tls_interaction_ask_password() will have its password filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	AskPasswordFinish func(Instance, AsyncResult) (TlsInteractionResult, error)
	// // RequestCertificate allows you to override the implementation of the virtual method request_certificate.
	// 
	// The function takes the following parameters:
	// 
	// 	- connection TlsConnection: a #GTlsConnection object 
	// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
	// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Run synchronous interaction to ask the user to choose a certificate to use
	// with the connection. In general, g_tls_interaction_invoke_request_certificate()
	// should be used instead of this function.
	// 
	// Derived subclasses usually implement a certificate selector, although they may
	// also choose to provide a certificate from elsewhere. Alternatively the user may
	// abort this certificate request, which will usually abort the TLS connection.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
	// not support immediate cancellation.
	RequestCertificate func(Instance, TlsConnection, TlsCertificateRequestFlags, Cancellable) (TlsInteractionResult, error)
	// // RequestCertificateFinish allows you to override the implementation of the virtual method request_certificate_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the result passed to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsInteractionResult 
	// 	- _goerr error (nullable): an error 
	//
	// Complete a request certificate user interaction request. This should be once
	// the g_tls_interaction_request_certificate_async() completion callback is called.
	// 
	// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
	// passed to g_tls_interaction_request_certificate_async() will have had its
	// #GTlsConnection:certificate filled in.
	// 
	// If the interaction is cancelled by the cancellation object, or by the
	// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
	// contains a %G_IO_ERROR_CANCELLED error code.
	RequestCertificateFinish func(Instance, AsyncResult) (TlsInteractionResult, error)
}

// UnsafeApplyTlsInteractionOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsInteractionOverrides[Instance TlsInteraction](gclass unsafe.Pointer, overrides TlsInteractionOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsInteractionClass)(gclass)

	if overrides.AskPassword != nil {
		pclass.ask_password = (*[0]byte)(C._goglib_gio2_TlsInteraction_ask_password)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_ask_password",
			func(carg0 *C.GTlsInteraction, carg1 *C.GTlsPassword, carg2 *C.GCancellable, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var password    TlsPassword          // in, none, converted
				var cancellable Cancellable          // in, none, converted, nullable
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				password = UnsafeTlsPasswordFromGlibNone(unsafe.Pointer(carg1))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.AskPassword(interaction, password, cancellable)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.AskPasswordFinish != nil {
		pclass.ask_password_finish = (*[0]byte)(C._goglib_gio2_TlsInteraction_ask_password_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_ask_password_finish",
			func(carg0 *C.GTlsInteraction, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var result      AsyncResult          // in, none, converted
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.AskPasswordFinish(interaction, result)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.RequestCertificate != nil {
		pclass.request_certificate = (*[0]byte)(C._goglib_gio2_TlsInteraction_request_certificate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_request_certificate",
			func(carg0 *C.GTlsInteraction, carg1 *C.GTlsConnection, carg2 C.GTlsCertificateRequestFlags, carg3 *C.GCancellable, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance                   // go GTlsInteraction subclass
				var connection  TlsConnection              // in, none, converted
				var flags       TlsCertificateRequestFlags // in, none, casted
				var cancellable Cancellable                // in, none, converted, nullable
				var goret       TlsInteractionResult       // return, none, casted
				var _goerr      error                      // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				connection = UnsafeTlsConnectionFromGlibNone(unsafe.Pointer(carg1))
				flags = TlsCertificateRequestFlags(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.RequestCertificate(interaction, connection, flags, cancellable)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.RequestCertificateFinish != nil {
		pclass.request_certificate_finish = (*[0]byte)(C._goglib_gio2_TlsInteraction_request_certificate_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsInteraction_request_certificate_finish",
			func(carg0 *C.GTlsInteraction, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.GTlsInteractionResult) {
				var interaction Instance             // go GTlsInteraction subclass
				var result      AsyncResult          // in, none, converted
				var goret       TlsInteractionResult // return, none, casted
				var _goerr      error                // out, full, converted

				interaction = UnsafeTlsInteractionFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.RequestCertificateFinish(interaction, result)

				cret = C.GTlsInteractionResult(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentAskPassword calls the default implementations of the `GTlsInteraction.ask_password` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- password TlsPassword: a #GTlsPassword object 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Run synchronous interaction to ask the user for a password. In general,
// g_tls_interaction_invoke_ask_password() should be used instead of this
// function.
// 
// Derived subclasses usually implement a password prompt, although they may
// also choose to provide a password from elsewhere. The @password value will
// be filled in and then @callback will be called. Alternatively the user may
// abort this password request, which will usually abort the TLS connection.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) ParentAskPassword(password TlsPassword, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GTlsPassword         // in, none, converted
	var carg2 *C.GCancellable         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsInteraction_virtual_ask_password(unsafe.Pointer(parentclass.ask_password), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(password)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentAskPasswordFinish calls the default implementations of the `GTlsInteraction.ask_password_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to the callback 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Complete an ask password user interaction request. This should be once
// the g_tls_interaction_ask_password_async() completion callback is called.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsPassword passed
// to g_tls_interaction_ask_password() will have its password filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (interaction *TlsInteractionInstance) ParentAskPasswordFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsInteraction_virtual_ask_password_finish(unsafe.Pointer(parentclass.ask_password_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRequestCertificate calls the default implementations of the `GTlsInteraction.request_certificate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- connection TlsConnection: a #GTlsConnection object 
// 	- flags TlsCertificateRequestFlags: flags providing more information about the request 
// 	- cancellable Cancellable (nullable): an optional #GCancellable cancellation object 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Run synchronous interaction to ask the user to choose a certificate to use
// with the connection. In general, g_tls_interaction_invoke_request_certificate()
// should be used instead of this function.
// 
// Derived subclasses usually implement a certificate selector, although they may
// also choose to provide a certificate from elsewhere. Alternatively the user may
// abort this certificate request, which will usually abort the TLS connection.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate() will have had its
// #GTlsConnection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code. Certain implementations may
// not support immediate cancellation.
func (interaction *TlsInteractionInstance) ParentRequestCertificate(connection TlsConnection, flags TlsCertificateRequestFlags, cancellable Cancellable) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GTlsConnection             // in, none, converted
	var carg2 C.GTlsCertificateRequestFlags // in, none, converted
	var carg3 *C.GCancellable               // in, none, casted
	var cret  C.GTlsInteractionResult       // return, none, casted
	var _cerr *C.GError                     // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GTlsConnection)(UnsafeTlsConnectionToGlibNone(connection))
	carg2 = C.GTlsCertificateRequestFlags(flags)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_TlsInteraction_virtual_request_certificate(unsafe.Pointer(parentclass.request_certificate), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentRequestCertificateFinish calls the default implementations of the `GTlsInteraction.request_certificate_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the result passed to the callback 
// 
// The function returns the following values:
// 
// 	- goret TlsInteractionResult 
// 	- _goerr error (nullable): an error 
//
// Complete a request certificate user interaction request. This should be once
// the g_tls_interaction_request_certificate_async() completion callback is called.
// 
// If %G_TLS_INTERACTION_HANDLED is returned, then the #GTlsConnection
// passed to g_tls_interaction_request_certificate_async() will have had its
// #GTlsConnection:certificate filled in.
// 
// If the interaction is cancelled by the cancellation object, or by the
// user then %G_TLS_INTERACTION_FAILED will be returned with an error that
// contains a %G_IO_ERROR_CANCELLED error code.
func (interaction *TlsInteractionInstance) ParentRequestCertificateFinish(result AsyncResult) (TlsInteractionResult, error) {
	var carg0 *C.GTlsInteraction
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.GTlsInteractionResult // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	parentclass := (*C.GTlsInteractionClass)(classdata.PeekParentClass(UnsafeTlsInteractionToGlibNone(interaction)))

	carg0 = (*C.GTlsInteraction)(UnsafeTlsInteractionToGlibNone(interaction))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_TlsInteraction_virtual_request_certificate_finish(unsafe.Pointer(parentclass.request_certificate_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(interaction)
	runtime.KeepAlive(result)

	var goret  TlsInteractionResult
	var _goerr error

	goret = TlsInteractionResult(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterTlsInteractionSubClass is used to register a go subclass of GTlsInteraction. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsInteractionSubClass[InstanceT TlsInteraction](
		name string,
		classInit func(class *TlsInteractionClass),
		constructor func() InstanceT,
		overrides TlsInteractionOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsInteraction,
		UnsafeTlsInteractionClassFromGlibBorrow,
		UnsafeApplyTlsInteractionOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsInteraction(obj)
		},
		interfaceInits...,
	)
}

// TlsPasswordInstance is the instance type used by all types extending GTlsPassword. It is used internally by the bindings. Users should use the interface [TlsPassword] instead.
type TlsPasswordInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ TlsPassword = (*TlsPasswordInstance)(nil)

// TlsPassword wraps GTlsPassword
//
// An abstract interface representing a password used in TLS. Often used in
// user interaction such as unlocking a key storage token.
type TlsPassword interface {
	gobject.Object
	upcastToGTlsPassword() *TlsPasswordInstance

	// GetDescription wraps g_tls_password_get_description
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Get a description string about what the password will be used for.
	GetDescription() string
	// GetFlags wraps g_tls_password_get_flags
	// 
	// The function returns the following values:
	// 
	// 	- goret TlsPasswordFlags 
	//
	// Get flags about the password.
	GetFlags() TlsPasswordFlags
	// GetValue wraps g_tls_password_get_value
	// 
	// The function returns the following values:
	// 
	// 	- length uint: location to place the length of the password. 
	// 	- goret []byte 
	//
	// Get the password value. If @length is not %NULL then it will be
	// filled in with the length of the password value. (Note that the
	// password value is not nul-terminated, so you can only pass %NULL
	// for @length in contexts where you know the password will have a
	// certain fixed length.)
	GetValue() (uint, []byte)
	// GetWarning wraps g_tls_password_get_warning
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Get a user readable translated warning. Usually this warning is a
	// representation of the password flags returned from
	// g_tls_password_get_flags().
	GetWarning() string
	// SetDescription wraps g_tls_password_set_description
	// 
	// The function takes the following parameters:
	// 
	// 	- description string: The description of the password 
	//
	// Set a description string about what the password will be used for.
	SetDescription(string)
	// SetFlags wraps g_tls_password_set_flags
	// 
	// The function takes the following parameters:
	// 
	// 	- flags TlsPasswordFlags: The flags about the password 
	//
	// Set flags about the password.
	SetFlags(TlsPasswordFlags)
	// SetValue wraps g_tls_password_set_value
	// 
	// The function takes the following parameters:
	// 
	// 	- value []byte: the new password value 
	//
	// Set the value for this password. The @value will be copied by the password
	// object.
	// 
	// Specify the @length, for a non-nul-terminated password. Pass -1 as
	// @length if using a nul-terminated password, and @length will be
	// calculated automatically. (Note that the terminating nul is not
	// considered part of the password in this case.)
	SetValue([]byte)
	// SetWarning wraps g_tls_password_set_warning
	// 
	// The function takes the following parameters:
	// 
	// 	- warning string: The user readable warning 
	//
	// Set a user readable translated warning. Usually this warning is a
	// representation of the password flags returned from
	// g_tls_password_get_flags().
	SetWarning(string)

	// chain up virtual methods:

	// ParentGetDefaultWarning calls the default implementations of the `GTlsPassword.get_default_warning` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// virtual method for g_tls_password_get_warning() if no
	//  value has been set using g_tls_password_set_warning()
	ParentGetDefaultWarning() string
	// ParentGetValue calls the default implementations of the `GTlsPassword.get_value` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- length uint: location to place the length of the password. 
	// 	- goret []byte 
	//
	// Get the password value. If @length is not %NULL then it will be
	// filled in with the length of the password value. (Note that the
	// password value is not nul-terminated, so you can only pass %NULL
	// for @length in contexts where you know the password will have a
	// certain fixed length.)
	ParentGetValue() (uint, []byte)
}

func unsafeWrapTlsPassword(base *gobject.ObjectInstance) *TlsPasswordInstance {
	return &TlsPasswordInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeTlsPassword,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsPassword(inst)
		},
	)
}

func marshalTlsPasswordInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeTlsPasswordFromGlibNone is used to convert raw GTlsPassword pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibNone(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibNone(c).(TlsPassword)
}

// UnsafeTlsPasswordFromGlibFull is used to convert raw GTlsPassword pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibFull(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibFull(c).(TlsPassword)
}

// UnsafeTlsPasswordFromGlibBorrow is used to convert raw GTlsPassword pointers to go without touching any references. This is used by the bindings internally.
func UnsafeTlsPasswordFromGlibBorrow(c unsafe.Pointer) TlsPassword {
	return gobject.UnsafeObjectFromGlibBorrow(c).(TlsPassword)
}

func (t *TlsPasswordInstance) upcastToGTlsPassword() *TlsPasswordInstance {
	return t
}

// UnsafeTlsPasswordToGlibNone is used to convert the instance to it's C value GTlsPassword. This is used by the bindings internally.
func UnsafeTlsPasswordToGlibNone(c TlsPassword) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeTlsPasswordToGlibFull is used to convert the instance to it's C value GTlsPassword, while removeing the finalizer. This is used by the bindings internally.
func UnsafeTlsPasswordToGlibFull(c TlsPassword) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewTlsPassword wraps g_tls_password_new
// 
// The function takes the following parameters:
// 
// 	- flags TlsPasswordFlags: the password flags 
// 	- description string: description of what the password is for 
// 
// The function returns the following values:
// 
// 	- goret TlsPassword 
//
// Create a new #GTlsPassword object.
func NewTlsPassword(flags TlsPasswordFlags, description string) TlsPassword {
	var carg1 C.GTlsPasswordFlags // in, none, casted
	var carg2 *C.gchar            // in, none, string
	var cret  *C.GTlsPassword     // return, full, converted

	carg1 = C.GTlsPasswordFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_tls_password_new(carg1, carg2)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(description)

	var goret TlsPassword

	goret = UnsafeTlsPasswordFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDescription wraps g_tls_password_get_description
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Get a description string about what the password will be used for.
func (password *TlsPasswordInstance) GetDescription() string {
	var carg0 *C.GTlsPassword // in, none, converted
	var cret  *C.gchar        // return, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_description(carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetFlags wraps g_tls_password_get_flags
// 
// The function returns the following values:
// 
// 	- goret TlsPasswordFlags 
//
// Get flags about the password.
func (password *TlsPasswordInstance) GetFlags() TlsPasswordFlags {
	var carg0 *C.GTlsPassword     // in, none, converted
	var cret  C.GTlsPasswordFlags // return, none, casted

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_flags(carg0)
	runtime.KeepAlive(password)

	var goret TlsPasswordFlags

	goret = TlsPasswordFlags(cret)

	return goret
}

// GetValue wraps g_tls_password_get_value
// 
// The function returns the following values:
// 
// 	- length uint: location to place the length of the password. 
// 	- goret []byte 
//
// Get the password value. If @length is not %NULL then it will be
// filled in with the length of the password value. (Note that the
// password value is not nul-terminated, so you can only pass %NULL
// for @length in contexts where you know the password will have a
// certain fixed length.)
func (password *TlsPasswordInstance) GetValue() (uint, []byte) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 C.gsize         // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
	var cret  *C.guchar       // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_value(carg0, &carg1)
	runtime.KeepAlive(password)

	var length uint
	var goret  []byte

	_ = length
	_ = carg1
	panic("unimplemented conversion of uint (gsize) because of unknown reason")
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (const guchar*) because of unknown reason")

	return length, goret
}

// GetWarning wraps g_tls_password_get_warning
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Get a user readable translated warning. Usually this warning is a
// representation of the password flags returned from
// g_tls_password_get_flags().
func (password *TlsPasswordInstance) GetWarning() string {
	var carg0 *C.GTlsPassword // in, none, converted
	var cret  *C.gchar        // return, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C.g_tls_password_get_warning(carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetDescription wraps g_tls_password_set_description
// 
// The function takes the following parameters:
// 
// 	- description string: The description of the password 
//
// Set a description string about what the password will be used for.
func (password *TlsPasswordInstance) SetDescription(description string) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_tls_password_set_description(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(description)
}

// SetFlags wraps g_tls_password_set_flags
// 
// The function takes the following parameters:
// 
// 	- flags TlsPasswordFlags: The flags about the password 
//
// Set flags about the password.
func (password *TlsPasswordInstance) SetFlags(flags TlsPasswordFlags) {
	var carg0 *C.GTlsPassword     // in, none, converted
	var carg1 C.GTlsPasswordFlags // in, none, casted

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = C.GTlsPasswordFlags(flags)

	C.g_tls_password_set_flags(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(flags)
}

// SetValue wraps g_tls_password_set_value
// 
// The function takes the following parameters:
// 
// 	- value []byte: the new password value 
//
// Set the value for this password. The @value will be copied by the password
// object.
// 
// Specify the @length, for a non-nul-terminated password. Pass -1 as
// @length if using a nul-terminated password, and @length will be
// calculated automatically. (Note that the terminating nul is not
// considered part of the password in this case.)
func (password *TlsPasswordInstance) SetValue(value []byte) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize        // implicit

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	_ = value
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	C.g_tls_password_set_value(carg0, carg1, carg2)
	runtime.KeepAlive(password)
	runtime.KeepAlive(value)
}

// SetWarning wraps g_tls_password_set_warning
// 
// The function takes the following parameters:
// 
// 	- warning string: The user readable warning 
//
// Set a user readable translated warning. Usually this warning is a
// representation of the password flags returned from
// g_tls_password_get_flags().
func (password *TlsPasswordInstance) SetWarning(warning string) {
	var carg0 *C.GTlsPassword // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(warning)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_tls_password_set_warning(carg0, carg1)
	runtime.KeepAlive(password)
	runtime.KeepAlive(warning)
}

// TlsPasswordOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type TlsPasswordOverrides[Instance TlsPassword] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // GetDefaultWarning allows you to override the implementation of the virtual method get_default_warning.
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// virtual method for g_tls_password_get_warning() if no
	//  value has been set using g_tls_password_set_warning()
	GetDefaultWarning func(Instance) string
	// // GetValue allows you to override the implementation of the virtual method get_value.
	// 
	// The function returns the following values:
	// 
	// 	- length uint: location to place the length of the password. 
	// 	- goret []byte 
	//
	// Get the password value. If @length is not %NULL then it will be
	// filled in with the length of the password value. (Note that the
	// password value is not nul-terminated, so you can only pass %NULL
	// for @length in contexts where you know the password will have a
	// certain fixed length.)
	GetValue func(Instance) (uint, []byte)
}

// UnsafeApplyTlsPasswordOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyTlsPasswordOverrides[Instance TlsPassword](gclass unsafe.Pointer, overrides TlsPasswordOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GTlsPasswordClass)(gclass)

	if overrides.GetDefaultWarning != nil {
		pclass.get_default_warning = (*[0]byte)(C._goglib_gio2_TlsPassword_get_default_warning)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsPassword_get_default_warning",
			func(carg0 *C.GTlsPassword) (cret *C.gchar) {
				var password Instance // go GTlsPassword subclass
				var goret    string   // return, none, string

				password = UnsafeTlsPasswordFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetDefaultWarning(password)

				cret = (*C.gchar)(unsafe.Pointer(C.CString(goret)))
				defer C.free(unsafe.Pointer(cret))

				return cret
			},
		)
	}

	if overrides.GetValue != nil {
		pclass.get_value = (*[0]byte)(C._goglib_gio2_TlsPassword_get_value)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_TlsPassword_get_value",
			func(carg0 *C.GTlsPassword, carg1 *C.gsize) (cret *C.guchar) {
				var password Instance // go GTlsPassword subclass
				var length   uint     // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
				var goret    []byte   // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

				password = UnsafeTlsPasswordFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				length, goret = overrides.GetValue(password)

				_ = length
				_ = carg1
				panic("unimplemented conversion of uint (gsize) because of caller-allocates not implemented")
				_ = goret
				_ = cret
				panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

				return cret
			},
		)
	}
}

// ParentGetDefaultWarning calls the default implementations of the `GTlsPassword.get_default_warning` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret string 
//
// virtual method for g_tls_password_get_warning() if no
//  value has been set using g_tls_password_set_warning()
func (password *TlsPasswordInstance) ParentGetDefaultWarning() string {
	var carg0 *C.GTlsPassword
	var cret  *C.gchar // return, none, string

	parentclass := (*C.GTlsPasswordClass)(classdata.PeekParentClass(UnsafeTlsPasswordToGlibNone(password)))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C._goglib_gio2_TlsPassword_virtual_get_default_warning(unsafe.Pointer(parentclass.get_default_warning), carg0)
	runtime.KeepAlive(password)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// ParentGetValue calls the default implementations of the `GTlsPassword.get_value` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- length uint: location to place the length of the password. 
// 	- goret []byte 
//
// Get the password value. If @length is not %NULL then it will be
// filled in with the length of the password value. (Note that the
// password value is not nul-terminated, so you can only pass %NULL
// for @length in contexts where you know the password will have a
// certain fixed length.)
func (password *TlsPasswordInstance) ParentGetValue() (uint, []byte) {
	var carg0 *C.GTlsPassword
	var carg1 C.gsize   // out, transfer: full, C Pointers: 0, Name: gsize, optional, caller-allocates
	var cret  *C.guchar // return, transfer: none, C Pointers: 1, Name: array[guchar], scope: , array (inner guchar (*typesystem.CastablePrimitive))

	parentclass := (*C.GTlsPasswordClass)(classdata.PeekParentClass(UnsafeTlsPasswordToGlibNone(password)))

	carg0 = (*C.GTlsPassword)(UnsafeTlsPasswordToGlibNone(password))

	cret = C._goglib_gio2_TlsPassword_virtual_get_value(unsafe.Pointer(parentclass.get_value), carg0, &carg1)
	runtime.KeepAlive(password)

	var length uint
	var goret  []byte

	_ = length
	_ = carg1
	panic("unimplemented conversion of uint (gsize) because of unknown reason")
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (const guchar*) because of unknown reason")

	return length, goret
}

// RegisterTlsPasswordSubClass is used to register a go subclass of GTlsPassword. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterTlsPasswordSubClass[InstanceT TlsPassword](
		name string,
		classInit func(class *TlsPasswordClass),
		constructor func() InstanceT,
		overrides TlsPasswordOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeTlsPassword,
		UnsafeTlsPasswordClassFromGlibBorrow,
		UnsafeApplyTlsPasswordOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapTlsPassword(obj)
		},
		interfaceInits...,
	)
}

// VfsInstance is the instance type used by all types extending GVfs. It is used internally by the bindings. Users should use the interface [Vfs] instead.
type VfsInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ Vfs = (*VfsInstance)(nil)

// Vfs wraps GVfs
//
// Entry point for using GIO functionality.
type Vfs interface {
	gobject.Object
	upcastToGVfs() *VfsInstance

	// GetFileForPath wraps g_vfs_get_file_for_path
	// 
	// The function takes the following parameters:
	// 
	// 	- path string: a string containing a VFS path. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @path.
	GetFileForPath(string) File
	// GetFileForURI wraps g_vfs_get_file_for_uri
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a string containing a URI 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @uri.
	// 
	// This operation never fails, but the returned object
	// might not support any I/O operation if the URI
	// is malformed or if the URI scheme is not supported.
	GetFileForURI(string) File
	// GetSupportedURISchemes wraps g_vfs_get_supported_uri_schemes
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets a list of URI schemes supported by @vfs.
	GetSupportedURISchemes() []string
	// IsActive wraps g_vfs_is_active
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the VFS is active.
	IsActive() bool
	// ParseName wraps g_vfs_parse_name
	// 
	// The function takes the following parameters:
	// 
	// 	- parseName string: a string to be parsed by the VFS module. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// This operation never fails, but the returned object might
	// not support any I/O operations if the @parse_name cannot
	// be parsed by the #GVfs module.
	ParseName(string) File
	// RegisterURIScheme wraps g_vfs_register_uri_scheme
	// 
	// The function takes the following parameters:
	// 
	// 	- scheme string: an URI scheme, e.g. "http" 
	// 	- uriFunc VfsFileLookupFunc (nullable): a #GVfsFileLookupFunc 
	// 	- parseNameFunc VfsFileLookupFunc (nullable): a #GVfsFileLookupFunc 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Registers @uri_func and @parse_name_func as the #GFile URI and parse name
	// lookup functions for URIs with a scheme matching @scheme.
	// Note that @scheme is registered only within the running application, as
	// opposed to desktop-wide as it happens with GVfs backends.
	// 
	// When a #GFile is requested with an URI containing @scheme (e.g. through
	// g_file_new_for_uri()), @uri_func will be called to allow a custom
	// constructor. The implementation of @uri_func should not be blocking, and
	// must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
	// 
	// When g_file_parse_name() is called with a parse name obtained from such file,
	// @parse_name_func will be called to allow the #GFile to be created again. In
	// that case, it's responsibility of @parse_name_func to make sure the parse
	// name matches what the custom #GFile implementation returned when
	// g_file_get_parse_name() was previously called. The implementation of
	// @parse_name_func should not be blocking, and must not call
	// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
	// 
	// It's an error to call this function twice with the same scheme. To unregister
	// a custom URI scheme, use g_vfs_unregister_uri_scheme().
	RegisterURIScheme(string, VfsFileLookupFunc, VfsFileLookupFunc) bool
	// UnregisterURIScheme wraps g_vfs_unregister_uri_scheme
	// 
	// The function takes the following parameters:
	// 
	// 	- scheme string: an URI scheme, e.g. "http" 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Unregisters the URI handler for @scheme previously registered with
	// g_vfs_register_uri_scheme().
	UnregisterURIScheme(string) bool

	// chain up virtual methods:

	// ParentAddWritableNamespaces calls the default implementations of the `GVfs.add_writable_namespaces` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- list *FileAttributeInfoList 
	ParentAddWritableNamespaces(list *FileAttributeInfoList)
	// ParentGetFileForPath calls the default implementations of the `GVfs.get_file_for_path` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- path string: a string containing a VFS path. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @path.
	ParentGetFileForPath(path string) File
	// ParentGetFileForURI calls the default implementations of the `GVfs.get_file_for_uri` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a string containing a URI 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @uri.
	// 
	// This operation never fails, but the returned object
	// might not support any I/O operation if the URI
	// is malformed or if the URI scheme is not supported.
	ParentGetFileForURI(uri string) File
	// ParentGetSupportedURISchemes calls the default implementations of the `GVfs.get_supported_uri_schemes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets a list of URI schemes supported by @vfs.
	ParentGetSupportedURISchemes() []string
	// ParentIsActive calls the default implementations of the `GVfs.is_active` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the VFS is active.
	ParentIsActive() bool
	// ParentLocalFileMoved calls the default implementations of the `GVfs.local_file_moved` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- source string 
	// 	- dest string 
	ParentLocalFileMoved(source string, dest string)
	// ParentLocalFileRemoved calls the default implementations of the `GVfs.local_file_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- filename string 
	ParentLocalFileRemoved(filename string)
	// ParentLocalFileSetAttributes calls the default implementations of the `GVfs.local_file_set_attributes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- filename string 
	// 	- info FileInfo 
	// 	- flags FileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentLocalFileSetAttributes(filename string, info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error)
	// ParentParseName calls the default implementations of the `GVfs.parse_name` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- parseName string: a string to be parsed by the VFS module. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// This operation never fails, but the returned object might
	// not support any I/O operations if the @parse_name cannot
	// be parsed by the #GVfs module.
	ParentParseName(parseName string) File
}

func unsafeWrapVfs(base *gobject.ObjectInstance) *VfsInstance {
	return &VfsInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeVfs,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVfs(inst)
		},
	)
}

func marshalVfsInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeVfsFromGlibNone is used to convert raw GVfs pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVfsFromGlibNone(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibNone(c).(Vfs)
}

// UnsafeVfsFromGlibFull is used to convert raw GVfs pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVfsFromGlibFull(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibFull(c).(Vfs)
}

// UnsafeVfsFromGlibBorrow is used to convert raw GVfs pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVfsFromGlibBorrow(c unsafe.Pointer) Vfs {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Vfs)
}

func (v *VfsInstance) upcastToGVfs() *VfsInstance {
	return v
}

// UnsafeVfsToGlibNone is used to convert the instance to it's C value GVfs. This is used by the bindings internally.
func UnsafeVfsToGlibNone(c Vfs) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeVfsToGlibFull is used to convert the instance to it's C value GVfs, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVfsToGlibFull(c Vfs) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// VfsGetDefault wraps g_vfs_get_default
// 
// The function returns the following values:
// 
// 	- goret Vfs 
//
// Gets the default #GVfs for the system.
func VfsGetDefault() Vfs {
	var cret *C.GVfs // return, none, converted

	cret = C.g_vfs_get_default()

	var goret Vfs

	goret = UnsafeVfsFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// VfsGetLocal wraps g_vfs_get_local
// 
// The function returns the following values:
// 
// 	- goret Vfs 
//
// Gets the local #GVfs for the system.
func VfsGetLocal() Vfs {
	var cret *C.GVfs // return, none, converted

	cret = C.g_vfs_get_local()

	var goret Vfs

	goret = UnsafeVfsFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFileForPath wraps g_vfs_get_file_for_path
// 
// The function takes the following parameters:
// 
// 	- path string: a string containing a VFS path. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets a #GFile for @path.
func (vfs *VfsInstance) GetFileForPath(path string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_get_file_for_path(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFileForURI wraps g_vfs_get_file_for_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: a string containing a URI 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets a #GFile for @uri.
// 
// This operation never fails, but the returned object
// might not support any I/O operation if the URI
// is malformed or if the URI scheme is not supported.
func (vfs *VfsInstance) GetFileForURI(uri string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_get_file_for_uri(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetSupportedURISchemes wraps g_vfs_get_supported_uri_schemes
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets a list of URI schemes supported by @vfs.
func (vfs *VfsInstance) GetSupportedURISchemes() []string {
	var carg0 *C.GVfs   // in, none, converted
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C.g_vfs_get_supported_uri_schemes(carg0)
	runtime.KeepAlive(vfs)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// IsActive wraps g_vfs_is_active
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the VFS is active.
func (vfs *VfsInstance) IsActive() bool {
	var carg0 *C.GVfs    // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C.g_vfs_is_active(carg0)
	runtime.KeepAlive(vfs)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParseName wraps g_vfs_parse_name
// 
// The function takes the following parameters:
// 
// 	- parseName string: a string to be parsed by the VFS module. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// This operation never fails, but the returned object might
// not support any I/O operations if the @parse_name cannot
// be parsed by the #GVfs module.
func (vfs *VfsInstance) ParseName(parseName string) File {
	var carg0 *C.GVfs  // in, none, converted
	var carg1 *C.char  // in, none, string
	var cret  *C.GFile // return, full, converted

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_parse_name(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterURIScheme wraps g_vfs_register_uri_scheme
// 
// The function takes the following parameters:
// 
// 	- scheme string: an URI scheme, e.g. "http" 
// 	- uriFunc VfsFileLookupFunc (nullable): a #GVfsFileLookupFunc 
// 	- parseNameFunc VfsFileLookupFunc (nullable): a #GVfsFileLookupFunc 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Registers @uri_func and @parse_name_func as the #GFile URI and parse name
// lookup functions for URIs with a scheme matching @scheme.
// Note that @scheme is registered only within the running application, as
// opposed to desktop-wide as it happens with GVfs backends.
// 
// When a #GFile is requested with an URI containing @scheme (e.g. through
// g_file_new_for_uri()), @uri_func will be called to allow a custom
// constructor. The implementation of @uri_func should not be blocking, and
// must not call g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
// 
// When g_file_parse_name() is called with a parse name obtained from such file,
// @parse_name_func will be called to allow the #GFile to be created again. In
// that case, it's responsibility of @parse_name_func to make sure the parse
// name matches what the custom #GFile implementation returned when
// g_file_get_parse_name() was previously called. The implementation of
// @parse_name_func should not be blocking, and must not call
// g_vfs_register_uri_scheme() or g_vfs_unregister_uri_scheme().
// 
// It's an error to call this function twice with the same scheme. To unregister
// a custom URI scheme, use g_vfs_unregister_uri_scheme().
func (vfs *VfsInstance) RegisterURIScheme(scheme string, uriFunc VfsFileLookupFunc, parseNameFunc VfsFileLookupFunc) bool {
	var carg0 *C.GVfs              // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 C.GVfsFileLookupFunc // callback, scope: notified, closure: carg3, destroy: carg4, nullable
	var carg3 C.gpointer           // implicit
	var carg4 C.GDestroyNotify     // implicit
	var carg5 C.GVfsFileLookupFunc // callback, scope: notified, closure: carg6, destroy: carg7, nullable
	var carg6 C.gpointer           // implicit
	var carg7 C.GDestroyNotify     // implicit
	var cret  C.gboolean           // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))
	if uriFunc != nil {
		carg2 = (*[0]byte)(C._goglib_gio2_VfsFileLookupFunc)
		carg3 = C.gpointer(userdata.Register(uriFunc))
		carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))
	}
	if parseNameFunc != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_VfsFileLookupFunc)
		carg6 = C.gpointer(userdata.Register(parseNameFunc))
		carg7 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))
	}

	cret = C.g_vfs_register_uri_scheme(carg0, carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(uriFunc)
	runtime.KeepAlive(parseNameFunc)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnregisterURIScheme wraps g_vfs_unregister_uri_scheme
// 
// The function takes the following parameters:
// 
// 	- scheme string: an URI scheme, e.g. "http" 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Unregisters the URI handler for @scheme previously registered with
// g_vfs_register_uri_scheme().
func (vfs *VfsInstance) UnregisterURIScheme(scheme string) bool {
	var carg0 *C.GVfs    // in, none, converted
	var carg1 *C.char    // in, none, string
	var cret  C.gboolean // return

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_vfs_unregister_uri_scheme(carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(scheme)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VfsOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type VfsOverrides[Instance Vfs] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // AddWritableNamespaces allows you to override the implementation of the virtual method add_writable_namespaces.
	// 
	// The function takes the following parameters:
	// 
	// 	- list *FileAttributeInfoList 
	AddWritableNamespaces func(Instance, *FileAttributeInfoList)
	// // GetFileForPath allows you to override the implementation of the virtual method get_file_for_path.
	// 
	// The function takes the following parameters:
	// 
	// 	- path string: a string containing a VFS path. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @path.
	GetFileForPath func(Instance, string) File
	// // GetFileForURI allows you to override the implementation of the virtual method get_file_for_uri.
	// 
	// The function takes the following parameters:
	// 
	// 	- uri string: a string containing a URI 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// Gets a #GFile for @uri.
	// 
	// This operation never fails, but the returned object
	// might not support any I/O operation if the URI
	// is malformed or if the URI scheme is not supported.
	GetFileForURI func(Instance, string) File
	// // GetSupportedURISchemes allows you to override the implementation of the virtual method get_supported_uri_schemes.
	// 
	// The function returns the following values:
	// 
	// 	- goret []string 
	//
	// Gets a list of URI schemes supported by @vfs.
	GetSupportedURISchemes func(Instance) []string
	// // IsActive allows you to override the implementation of the virtual method is_active.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the VFS is active.
	IsActive func(Instance) bool
	// // LocalFileMoved allows you to override the implementation of the virtual method local_file_moved.
	// 
	// The function takes the following parameters:
	// 
	// 	- source string 
	// 	- dest string 
	LocalFileMoved func(Instance, string, string)
	// // LocalFileRemoved allows you to override the implementation of the virtual method local_file_removed.
	// 
	// The function takes the following parameters:
	// 
	// 	- filename string 
	LocalFileRemoved func(Instance, string)
	// // LocalFileSetAttributes allows you to override the implementation of the virtual method local_file_set_attributes.
	// 
	// The function takes the following parameters:
	// 
	// 	- filename string 
	// 	- info FileInfo 
	// 	- flags FileQueryInfoFlags 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	LocalFileSetAttributes func(Instance, string, FileInfo, FileQueryInfoFlags, Cancellable) (bool, error)
	// // ParseName allows you to override the implementation of the virtual method parse_name.
	// 
	// The function takes the following parameters:
	// 
	// 	- parseName string: a string to be parsed by the VFS module. 
	// 
	// The function returns the following values:
	// 
	// 	- goret File 
	//
	// This operation never fails, but the returned object might
	// not support any I/O operations if the @parse_name cannot
	// be parsed by the #GVfs module.
	ParseName func(Instance, string) File
}

// UnsafeApplyVfsOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyVfsOverrides[Instance Vfs](gclass unsafe.Pointer, overrides VfsOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GVfsClass)(gclass)

	if overrides.AddWritableNamespaces != nil {
		pclass.add_writable_namespaces = (*[0]byte)(C._goglib_gio2_Vfs_add_writable_namespaces)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_add_writable_namespaces",
			func(carg0 *C.GVfs, carg1 *C.GFileAttributeInfoList) {
				var vfs  Instance               // go GVfs subclass
				var list *FileAttributeInfoList // in, none, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				list = UnsafeFileAttributeInfoListFromGlibNone(unsafe.Pointer(carg1))

				overrides.AddWritableNamespaces(vfs, list)
			},
		)
	}

	if overrides.GetFileForPath != nil {
		pclass.get_file_for_path = (*[0]byte)(C._goglib_gio2_Vfs_get_file_for_path)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_file_for_path",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs   Instance // go GVfs subclass
				var path  string   // in, none, string
				var goret File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				path = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetFileForPath(vfs, path)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.GetFileForURI != nil {
		pclass.get_file_for_uri = (*[0]byte)(C._goglib_gio2_Vfs_get_file_for_uri)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_file_for_uri",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs   Instance // go GVfs subclass
				var uri   string   // in, none, string
				var goret File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uri = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetFileForURI(vfs, uri)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}

	if overrides.GetSupportedURISchemes != nil {
		pclass.get_supported_uri_schemes = (*[0]byte)(C._goglib_gio2_Vfs_get_supported_uri_schemes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_get_supported_uri_schemes",
			func(carg0 *C.GVfs) (cret **C.gchar) {
				var vfs   Instance // go GVfs subclass
				var goret []string // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetSupportedURISchemes(vfs)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

				return cret
			},
		)
	}

	if overrides.IsActive != nil {
		pclass.is_active = (*[0]byte)(C._goglib_gio2_Vfs_is_active)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_is_active",
			func(carg0 *C.GVfs) (cret C.gboolean) {
				var vfs   Instance // go GVfs subclass
				var goret bool     // return

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.IsActive(vfs)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.LocalFileMoved != nil {
		pclass.local_file_moved = (*[0]byte)(C._goglib_gio2_Vfs_local_file_moved)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_moved",
			func(carg0 *C.GVfs, carg1 *C.char, carg2 *C.char) {
				var vfs    Instance // go GVfs subclass
				var source string   // in, none, string
				var dest   string   // in, none, string

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				source = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				dest = C.GoString((*C.char)(unsafe.Pointer(carg2)))

				overrides.LocalFileMoved(vfs, source, dest)
			},
		)
	}

	if overrides.LocalFileRemoved != nil {
		pclass.local_file_removed = (*[0]byte)(C._goglib_gio2_Vfs_local_file_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_removed",
			func(carg0 *C.GVfs, carg1 *C.char) {
				var vfs      Instance // go GVfs subclass
				var filename string   // in, none, string

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				filename = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				overrides.LocalFileRemoved(vfs, filename)
			},
		)
	}

	if overrides.LocalFileSetAttributes != nil {
		pclass.local_file_set_attributes = (*[0]byte)(C._goglib_gio2_Vfs_local_file_set_attributes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_local_file_set_attributes",
			func(carg0 *C.GVfs, carg1 *C.char, carg2 *C.GFileInfo, carg3 C.GFileQueryInfoFlags, carg4 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var vfs         Instance           // go GVfs subclass
				var filename    string             // in, none, string
				var info        FileInfo           // in, none, converted
				var flags       FileQueryInfoFlags // in, none, casted
				var cancellable Cancellable        // in, none, converted, nullable
				var goret       bool               // return
				var _goerr      error              // out, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				filename = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				info = UnsafeFileInfoFromGlibNone(unsafe.Pointer(carg2))
				flags = FileQueryInfoFlags(carg3)
				if carg4 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg4))
				}

				goret, _goerr = overrides.LocalFileSetAttributes(vfs, filename, info, flags, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.ParseName != nil {
		pclass.parse_name = (*[0]byte)(C._goglib_gio2_Vfs_parse_name)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_Vfs_parse_name",
			func(carg0 *C.GVfs, carg1 *C.char) (cret *C.GFile) {
				var vfs       Instance // go GVfs subclass
				var parseName string   // in, none, string
				var goret     File     // return, full, converted

				vfs = UnsafeVfsFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				parseName = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.ParseName(vfs, parseName)

				cret = (*C.GFile)(UnsafeFileToGlibFull(goret))

				return cret
			},
		)
	}
}

// ParentAddWritableNamespaces calls the default implementations of the `GVfs.add_writable_namespaces` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- list *FileAttributeInfoList 
func (vfs *VfsInstance) ParentAddWritableNamespaces(list *FileAttributeInfoList) {
	var carg0 *C.GVfs
	var carg1 *C.GFileAttributeInfoList // in, none, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))

	C._goglib_gio2_Vfs_virtual_add_writable_namespaces(unsafe.Pointer(parentclass.add_writable_namespaces), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(list)
}

// ParentGetFileForPath calls the default implementations of the `GVfs.get_file_for_path` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- path string: a string containing a VFS path. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets a #GFile for @path.
func (vfs *VfsInstance) ParentGetFileForPath(path string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_get_file_for_path(unsafe.Pointer(parentclass.get_file_for_path), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(path)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentGetFileForURI calls the default implementations of the `GVfs.get_file_for_uri` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- uri string: a string containing a URI 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// Gets a #GFile for @uri.
// 
// This operation never fails, but the returned object
// might not support any I/O operation if the URI
// is malformed or if the URI scheme is not supported.
func (vfs *VfsInstance) ParentGetFileForURI(uri string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_get_file_for_uri(unsafe.Pointer(parentclass.get_file_for_uri), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(uri)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParentGetSupportedURISchemes calls the default implementations of the `GVfs.get_supported_uri_schemes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets a list of URI schemes supported by @vfs.
func (vfs *VfsInstance) ParentGetSupportedURISchemes() []string {
	var carg0 *C.GVfs
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C._goglib_gio2_Vfs_virtual_get_supported_uri_schemes(unsafe.Pointer(parentclass.get_supported_uri_schemes), carg0)
	runtime.KeepAlive(vfs)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// ParentIsActive calls the default implementations of the `GVfs.is_active` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the VFS is active.
func (vfs *VfsInstance) ParentIsActive() bool {
	var carg0 *C.GVfs
	var cret  C.gboolean // return

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))

	cret = C._goglib_gio2_Vfs_virtual_is_active(unsafe.Pointer(parentclass.is_active), carg0)
	runtime.KeepAlive(vfs)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentLocalFileMoved calls the default implementations of the `GVfs.local_file_moved` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- source string 
// 	- dest string 
func (vfs *VfsInstance) ParentLocalFileMoved(source string, dest string) {
	var carg0 *C.GVfs
	var carg1 *C.char // in, none, converted
	var carg2 *C.char // in, none, string

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg2))

	C._goglib_gio2_Vfs_virtual_local_file_moved(unsafe.Pointer(parentclass.local_file_moved), carg0, carg1, carg2)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(source)
	runtime.KeepAlive(dest)
}

// ParentLocalFileRemoved calls the default implementations of the `GVfs.local_file_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- filename string 
func (vfs *VfsInstance) ParentLocalFileRemoved(filename string) {
	var carg0 *C.GVfs
	var carg1 *C.char // in, none, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	C._goglib_gio2_Vfs_virtual_local_file_removed(unsafe.Pointer(parentclass.local_file_removed), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(filename)
}

// ParentLocalFileSetAttributes calls the default implementations of the `GVfs.local_file_set_attributes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- filename string 
// 	- info FileInfo 
// 	- flags FileQueryInfoFlags 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (vfs *VfsInstance) ParentLocalFileSetAttributes(filename string, info FileInfo, flags FileQueryInfoFlags, cancellable Cancellable) (bool, error) {
	var carg0 *C.GVfs
	var carg1 *C.char               // in, none, converted
	var carg2 *C.GFileInfo          // in, none, string
	var carg3 C.GFileQueryInfoFlags // in, none, converted
	var carg4 *C.GCancellable       // in, none, casted
	var cret  C.gboolean            // return
	var _cerr *C.GError             // out, full, converted, nullable

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.GFileInfo)(UnsafeFileInfoToGlibNone(info))
	carg3 = C.GFileQueryInfoFlags(flags)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_Vfs_virtual_local_file_set_attributes(unsafe.Pointer(parentclass.local_file_set_attributes), carg0, carg1, carg2, carg3, carg4, &_cerr)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentParseName calls the default implementations of the `GVfs.parse_name` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- parseName string: a string to be parsed by the VFS module. 
// 
// The function returns the following values:
// 
// 	- goret File 
//
// This operation never fails, but the returned object might
// not support any I/O operations if the @parse_name cannot
// be parsed by the #GVfs module.
func (vfs *VfsInstance) ParentParseName(parseName string) File {
	var carg0 *C.GVfs
	var carg1 *C.char  // in, none, converted
	var cret  *C.GFile // return, full, converted

	parentclass := (*C.GVfsClass)(classdata.PeekParentClass(UnsafeVfsToGlibNone(vfs)))

	carg0 = (*C.GVfs)(UnsafeVfsToGlibNone(vfs))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_Vfs_virtual_parse_name(unsafe.Pointer(parentclass.parse_name), carg0, carg1)
	runtime.KeepAlive(vfs)
	runtime.KeepAlive(parseName)

	var goret File

	goret = UnsafeFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// RegisterVfsSubClass is used to register a go subclass of GVfs. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterVfsSubClass[InstanceT Vfs](
		name string,
		classInit func(class *VfsClass),
		constructor func() InstanceT,
		overrides VfsOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeVfs,
		UnsafeVfsClassFromGlibBorrow,
		UnsafeApplyVfsOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVfs(obj)
		},
		interfaceInits...,
	)
}

// VolumeMonitorInstance is the instance type used by all types extending GVolumeMonitor. It is used internally by the bindings. Users should use the interface [VolumeMonitor] instead.
type VolumeMonitorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ VolumeMonitor = (*VolumeMonitorInstance)(nil)

// VolumeMonitor wraps GVolumeMonitor
//
// `GVolumeMonitor` is for listing the user interesting devices and volumes
// on the computer. In other words, what a file selector or file manager
// would show in a sidebar.
// 
// `GVolumeMonitor` is not
// thread-default-context aware (see
// [method@GLib.MainContext.push_thread_default]), and so should not be used
// other than from the main thread, with no thread-default-context active.
// 
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor interface {
	gobject.Object
	upcastToGVolumeMonitor() *VolumeMonitorInstance

	// GetConnectedDrives wraps g_volume_monitor_get_connected_drives
	// 
	// The function returns the following values:
	// 
	// 	- goret []Drive 
	//
	// Gets a list of drives connected to the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetConnectedDrives() []Drive
	// GetMountForUuid wraps g_volume_monitor_get_mount_for_uuid
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount (nullable) 
	//
	// Finds a #GMount object by its UUID (see g_mount_get_uuid())
	GetMountForUuid(string) Mount
	// GetMounts wraps g_volume_monitor_get_mounts
	// 
	// The function returns the following values:
	// 
	// 	- goret []Mount 
	//
	// Gets a list of the mounts on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetMounts() []Mount
	// GetVolumeForUuid wraps g_volume_monitor_get_volume_for_uuid
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Volume (nullable) 
	//
	// Finds a #GVolume object by its UUID (see g_volume_get_uuid())
	GetVolumeForUuid(string) Volume
	// GetVolumes wraps g_volume_monitor_get_volumes
	// 
	// The function returns the following values:
	// 
	// 	- goret []Volume 
	//
	// Gets a list of the volumes on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetVolumes() []Volume
	// ConnectDriveChanged connects the provided callback to the "drive-changed" signal
	//
	// Emitted when a drive changes.
	ConnectDriveChanged(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveConnected connects the provided callback to the "drive-connected" signal
	//
	// Emitted when a drive is connected to the system.
	ConnectDriveConnected(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveDisconnected connects the provided callback to the "drive-disconnected" signal
	//
	// Emitted when a drive is disconnected from the system.
	ConnectDriveDisconnected(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveEjectButton connects the provided callback to the "drive-eject-button" signal
	//
	// Emitted when the eject button is pressed on @drive.
	ConnectDriveEjectButton(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectDriveStopButton connects the provided callback to the "drive-stop-button" signal
	//
	// Emitted when the stop button is pressed on @drive.
	ConnectDriveStopButton(func(VolumeMonitor, Drive)) gobject.SignalHandle
	// ConnectMountAdded connects the provided callback to the "mount-added" signal
	//
	// Emitted when a mount is added.
	ConnectMountAdded(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountChanged connects the provided callback to the "mount-changed" signal
	//
	// Emitted when a mount changes.
	ConnectMountChanged(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountPreUnmount connects the provided callback to the "mount-pre-unmount" signal
	//
	// May be emitted when a mount is about to be removed.
	// 
	// This signal depends on the backend and is only emitted if
	// GIO was used to unmount.
	ConnectMountPreUnmount(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectMountRemoved connects the provided callback to the "mount-removed" signal
	//
	// Emitted when a mount is removed.
	ConnectMountRemoved(func(VolumeMonitor, Mount)) gobject.SignalHandle
	// ConnectVolumeAdded connects the provided callback to the "volume-added" signal
	//
	// Emitted when a mountable volume is added to the system.
	ConnectVolumeAdded(func(VolumeMonitor, Volume)) gobject.SignalHandle
	// ConnectVolumeChanged connects the provided callback to the "volume-changed" signal
	//
	// Emitted when mountable volume is changed.
	ConnectVolumeChanged(func(VolumeMonitor, Volume)) gobject.SignalHandle
	// ConnectVolumeRemoved connects the provided callback to the "volume-removed" signal
	//
	// Emitted when a mountable volume is removed from the system.
	ConnectVolumeRemoved(func(VolumeMonitor, Volume)) gobject.SignalHandle

	// chain up virtual methods:

	// ParentDriveChanged calls the default implementations of the `GVolumeMonitor.drive_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	ParentDriveChanged(drive Drive)
	// ParentDriveConnected calls the default implementations of the `GVolumeMonitor.drive_connected` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	ParentDriveConnected(drive Drive)
	// ParentDriveDisconnected calls the default implementations of the `GVolumeMonitor.drive_disconnected` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	ParentDriveDisconnected(drive Drive)
	// ParentDriveEjectButton calls the default implementations of the `GVolumeMonitor.drive_eject_button` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	ParentDriveEjectButton(drive Drive)
	// ParentDriveStopButton calls the default implementations of the `GVolumeMonitor.drive_stop_button` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	ParentDriveStopButton(drive Drive)
	// ParentGetConnectedDrives calls the default implementations of the `GVolumeMonitor.get_connected_drives` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Drive 
	//
	// Gets a list of drives connected to the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	ParentGetConnectedDrives() []Drive
	// ParentGetMountForUuid calls the default implementations of the `GVolumeMonitor.get_mount_for_uuid` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount (nullable) 
	//
	// Finds a #GMount object by its UUID (see g_mount_get_uuid())
	ParentGetMountForUuid(uuid string) Mount
	// ParentGetMounts calls the default implementations of the `GVolumeMonitor.get_mounts` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Mount 
	//
	// Gets a list of the mounts on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	ParentGetMounts() []Mount
	// ParentGetVolumeForUuid calls the default implementations of the `GVolumeMonitor.get_volume_for_uuid` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Volume (nullable) 
	//
	// Finds a #GVolume object by its UUID (see g_volume_get_uuid())
	ParentGetVolumeForUuid(uuid string) Volume
	// ParentGetVolumes calls the default implementations of the `GVolumeMonitor.get_volumes` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Volume 
	//
	// Gets a list of the volumes on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	ParentGetVolumes() []Volume
	// ParentMountAdded calls the default implementations of the `GVolumeMonitor.mount_added` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	ParentMountAdded(mount Mount)
	// ParentMountChanged calls the default implementations of the `GVolumeMonitor.mount_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	ParentMountChanged(mount Mount)
	// ParentMountPreUnmount calls the default implementations of the `GVolumeMonitor.mount_pre_unmount` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	ParentMountPreUnmount(mount Mount)
	// ParentMountRemoved calls the default implementations of the `GVolumeMonitor.mount_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	ParentMountRemoved(mount Mount)
	// ParentVolumeAdded calls the default implementations of the `GVolumeMonitor.volume_added` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	ParentVolumeAdded(volume Volume)
	// ParentVolumeChanged calls the default implementations of the `GVolumeMonitor.volume_changed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	ParentVolumeChanged(volume Volume)
	// ParentVolumeRemoved calls the default implementations of the `GVolumeMonitor.volume_removed` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	ParentVolumeRemoved(volume Volume)
}

func unsafeWrapVolumeMonitor(base *gobject.ObjectInstance) *VolumeMonitorInstance {
	return &VolumeMonitorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeVolumeMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVolumeMonitor(inst)
		},
	)
}

func marshalVolumeMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeVolumeMonitorFromGlibNone is used to convert raw GVolumeMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibNone(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(VolumeMonitor)
}

// UnsafeVolumeMonitorFromGlibFull is used to convert raw GVolumeMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibFull(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(VolumeMonitor)
}

// UnsafeVolumeMonitorFromGlibBorrow is used to convert raw GVolumeMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeVolumeMonitorFromGlibBorrow(c unsafe.Pointer) VolumeMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(VolumeMonitor)
}

func (v *VolumeMonitorInstance) upcastToGVolumeMonitor() *VolumeMonitorInstance {
	return v
}

// UnsafeVolumeMonitorToGlibNone is used to convert the instance to it's C value GVolumeMonitor. This is used by the bindings internally.
func UnsafeVolumeMonitorToGlibNone(c VolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeVolumeMonitorToGlibFull is used to convert the instance to it's C value GVolumeMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeVolumeMonitorToGlibFull(c VolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// VolumeMonitorAdoptOrphanMount wraps g_volume_monitor_adopt_orphan_mount
// 
// The function takes the following parameters:
// 
// 	- mount Mount: a #GMount object to find a parent for 
// 
// The function returns the following values:
// 
// 	- goret Volume 
//
// This function should be called by any #GVolumeMonitor
// implementation when a new #GMount object is created that is not
// associated with a #GVolume object. It must be called just before
// emitting the @mount_added signal.
// 
// If the return value is not %NULL, the caller must associate the
// returned #GVolume object with the #GMount. This involves returning
// it in its g_mount_get_volume() implementation. The caller must
// also listen for the "removed" signal on the returned object
// and give up its reference when handling that signal
// 
// Similarly, if implementing g_volume_monitor_adopt_orphan_mount(),
// the implementor must take a reference to @mount and return it in
// its g_volume_get_mount() implemented. Also, the implementor must
// listen for the "unmounted" signal on @mount and give up its
// reference upon handling that signal.
// 
// There are two main use cases for this function.
// 
// One is when implementing a user space file system driver that reads
// blocks of a block device that is already represented by the native
// volume monitor (for example a CD Audio file system driver). Such
// a driver will generate its own #GMount object that needs to be
// associated with the #GVolume object that represents the volume.
// 
// The other is for implementing a #GVolumeMonitor whose sole purpose
// is to return #GVolume objects representing entries in the users
// "favorite servers" list or similar.
//
// Deprecated: (since 2.20.0) Instead of using this function, #GVolumeMonitor
// implementations should instead create shadow mounts with the URI of
// the mount they intend to adopt. See the proxy volume monitor in
// gvfs for an example of this. Also see g_mount_is_shadowed(),
// g_mount_shadow() and g_mount_unshadow() functions.
func VolumeMonitorAdoptOrphanMount(mount Mount) Volume {
	var carg1 *C.GMount  // in, none, converted
	var cret  *C.GVolume // return, full, converted

	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	cret = C.g_volume_monitor_adopt_orphan_mount(carg1)
	runtime.KeepAlive(mount)

	var goret Volume

	goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// VolumeMonitorGet wraps g_volume_monitor_get
// 
// The function returns the following values:
// 
// 	- goret VolumeMonitor 
//
// Gets the volume monitor used by gio.
func VolumeMonitorGet() VolumeMonitor {
	var cret *C.GVolumeMonitor // return, full, converted

	cret = C.g_volume_monitor_get()

	var goret VolumeMonitor

	goret = UnsafeVolumeMonitorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConnectedDrives wraps g_volume_monitor_get_connected_drives
// 
// The function returns the following values:
// 
// 	- goret []Drive 
//
// Gets a list of drives connected to the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) GetConnectedDrives() []Drive {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_connected_drives(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Drive

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Drive {
			var dst Drive // converted
			dst = UnsafeDriveFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// GetMountForUuid wraps g_volume_monitor_get_mount_for_uuid
// 
// The function takes the following parameters:
// 
// 	- uuid string: the UUID to look for 
// 
// The function returns the following values:
// 
// 	- goret Mount (nullable) 
//
// Finds a #GMount object by its UUID (see g_mount_get_uuid())
func (volumeMonitor *VolumeMonitorInstance) GetMountForUuid(uuid string) Mount {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var carg1 *C.char           // in, none, string
	var cret  *C.GMount         // return, full, converted, nullable

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_monitor_get_mount_for_uuid(carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetMounts wraps g_volume_monitor_get_mounts
// 
// The function returns the following values:
// 
// 	- goret []Mount 
//
// Gets a list of the mounts on the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) GetMounts() []Mount {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_mounts(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Mount

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Mount {
			var dst Mount // converted
			dst = UnsafeMountFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// GetVolumeForUuid wraps g_volume_monitor_get_volume_for_uuid
// 
// The function takes the following parameters:
// 
// 	- uuid string: the UUID to look for 
// 
// The function returns the following values:
// 
// 	- goret Volume (nullable) 
//
// Finds a #GVolume object by its UUID (see g_volume_get_uuid())
func (volumeMonitor *VolumeMonitorInstance) GetVolumeForUuid(uuid string) Volume {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var carg1 *C.char           // in, none, string
	var cret  *C.GVolume        // return, full, converted, nullable

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_volume_monitor_get_volume_for_uuid(carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetVolumes wraps g_volume_monitor_get_volumes
// 
// The function returns the following values:
// 
// 	- goret []Volume 
//
// Gets a list of the volumes on the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) GetVolumes() []Volume {
	var carg0 *C.GVolumeMonitor // in, none, converted
	var cret  *C.GList          // container, transfer: full

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C.g_volume_monitor_get_volumes(carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ConnectDriveChanged connects the provided callback to the "drive-changed" signal
//
// Emitted when a drive changes.
func (o *VolumeMonitorInstance) ConnectDriveChanged(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-changed", fn)
}

// ConnectDriveConnected connects the provided callback to the "drive-connected" signal
//
// Emitted when a drive is connected to the system.
func (o *VolumeMonitorInstance) ConnectDriveConnected(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-connected", fn)
}

// ConnectDriveDisconnected connects the provided callback to the "drive-disconnected" signal
//
// Emitted when a drive is disconnected from the system.
func (o *VolumeMonitorInstance) ConnectDriveDisconnected(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-disconnected", fn)
}

// ConnectDriveEjectButton connects the provided callback to the "drive-eject-button" signal
//
// Emitted when the eject button is pressed on @drive.
func (o *VolumeMonitorInstance) ConnectDriveEjectButton(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-eject-button", fn)
}

// ConnectDriveStopButton connects the provided callback to the "drive-stop-button" signal
//
// Emitted when the stop button is pressed on @drive.
func (o *VolumeMonitorInstance) ConnectDriveStopButton(fn func(VolumeMonitor, Drive)) gobject.SignalHandle {
	return o.Connect("drive-stop-button", fn)
}

// ConnectMountAdded connects the provided callback to the "mount-added" signal
//
// Emitted when a mount is added.
func (o *VolumeMonitorInstance) ConnectMountAdded(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-added", fn)
}

// ConnectMountChanged connects the provided callback to the "mount-changed" signal
//
// Emitted when a mount changes.
func (o *VolumeMonitorInstance) ConnectMountChanged(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-changed", fn)
}

// ConnectMountPreUnmount connects the provided callback to the "mount-pre-unmount" signal
//
// May be emitted when a mount is about to be removed.
// 
// This signal depends on the backend and is only emitted if
// GIO was used to unmount.
func (o *VolumeMonitorInstance) ConnectMountPreUnmount(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-pre-unmount", fn)
}

// ConnectMountRemoved connects the provided callback to the "mount-removed" signal
//
// Emitted when a mount is removed.
func (o *VolumeMonitorInstance) ConnectMountRemoved(fn func(VolumeMonitor, Mount)) gobject.SignalHandle {
	return o.Connect("mount-removed", fn)
}

// ConnectVolumeAdded connects the provided callback to the "volume-added" signal
//
// Emitted when a mountable volume is added to the system.
func (o *VolumeMonitorInstance) ConnectVolumeAdded(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-added", fn)
}

// ConnectVolumeChanged connects the provided callback to the "volume-changed" signal
//
// Emitted when mountable volume is changed.
func (o *VolumeMonitorInstance) ConnectVolumeChanged(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-changed", fn)
}

// ConnectVolumeRemoved connects the provided callback to the "volume-removed" signal
//
// Emitted when a mountable volume is removed from the system.
func (o *VolumeMonitorInstance) ConnectVolumeRemoved(fn func(VolumeMonitor, Volume)) gobject.SignalHandle {
	return o.Connect("volume-removed", fn)
}

// VolumeMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type VolumeMonitorOverrides[Instance VolumeMonitor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

	// // DriveChanged allows you to override the implementation of the virtual method drive_changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	DriveChanged func(Instance, Drive)
	// // DriveConnected allows you to override the implementation of the virtual method drive_connected.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	DriveConnected func(Instance, Drive)
	// // DriveDisconnected allows you to override the implementation of the virtual method drive_disconnected.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	DriveDisconnected func(Instance, Drive)
	// // DriveEjectButton allows you to override the implementation of the virtual method drive_eject_button.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	DriveEjectButton func(Instance, Drive)
	// // DriveStopButton allows you to override the implementation of the virtual method drive_stop_button.
	// 
	// The function takes the following parameters:
	// 
	// 	- drive Drive 
	DriveStopButton func(Instance, Drive)
	// // GetConnectedDrives allows you to override the implementation of the virtual method get_connected_drives.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Drive 
	//
	// Gets a list of drives connected to the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetConnectedDrives func(Instance) []Drive
	// // GetMountForUuid allows you to override the implementation of the virtual method get_mount_for_uuid.
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Mount (nullable) 
	//
	// Finds a #GMount object by its UUID (see g_mount_get_uuid())
	GetMountForUuid func(Instance, string) Mount
	// // GetMounts allows you to override the implementation of the virtual method get_mounts.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Mount 
	//
	// Gets a list of the mounts on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetMounts func(Instance) []Mount
	// // GetVolumeForUuid allows you to override the implementation of the virtual method get_volume_for_uuid.
	// 
	// The function takes the following parameters:
	// 
	// 	- uuid string: the UUID to look for 
	// 
	// The function returns the following values:
	// 
	// 	- goret Volume (nullable) 
	//
	// Finds a #GVolume object by its UUID (see g_volume_get_uuid())
	GetVolumeForUuid func(Instance, string) Volume
	// // GetVolumes allows you to override the implementation of the virtual method get_volumes.
	// 
	// The function returns the following values:
	// 
	// 	- goret []Volume 
	//
	// Gets a list of the volumes on the system.
	// 
	// The returned list should be freed with g_list_free(), after
	// its elements have been unreffed with g_object_unref().
	GetVolumes func(Instance) []Volume
	// // MountAdded allows you to override the implementation of the virtual method mount_added.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	MountAdded func(Instance, Mount)
	// // MountChanged allows you to override the implementation of the virtual method mount_changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	MountChanged func(Instance, Mount)
	// // MountPreUnmount allows you to override the implementation of the virtual method mount_pre_unmount.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	MountPreUnmount func(Instance, Mount)
	// // MountRemoved allows you to override the implementation of the virtual method mount_removed.
	// 
	// The function takes the following parameters:
	// 
	// 	- mount Mount 
	MountRemoved func(Instance, Mount)
	// // VolumeAdded allows you to override the implementation of the virtual method volume_added.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	VolumeAdded func(Instance, Volume)
	// // VolumeChanged allows you to override the implementation of the virtual method volume_changed.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	VolumeChanged func(Instance, Volume)
	// // VolumeRemoved allows you to override the implementation of the virtual method volume_removed.
	// 
	// The function takes the following parameters:
	// 
	// 	- volume Volume 
	VolumeRemoved func(Instance, Volume)
}

// UnsafeApplyVolumeMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyVolumeMonitorOverrides[Instance VolumeMonitor](gclass unsafe.Pointer, overrides VolumeMonitorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)

	pclass := (*C.GVolumeMonitorClass)(gclass)

	if overrides.DriveChanged != nil {
		pclass.drive_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveChanged(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveConnected != nil {
		pclass.drive_connected = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_connected)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_connected",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveConnected(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveDisconnected != nil {
		pclass.drive_disconnected = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_disconnected)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_disconnected",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveDisconnected(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveEjectButton != nil {
		pclass.drive_eject_button = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_eject_button)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_eject_button",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveEjectButton(volumeMonitor, drive)
			},
		)
	}

	if overrides.DriveStopButton != nil {
		pclass.drive_stop_button = (*[0]byte)(C._goglib_gio2_VolumeMonitor_drive_stop_button)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_drive_stop_button",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GDrive) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var drive         Drive    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				drive = UnsafeDriveFromGlibNone(unsafe.Pointer(carg1))

				overrides.DriveStopButton(volumeMonitor, drive)
			},
		)
	}

	if overrides.GetConnectedDrives != nil {
		pclass.get_connected_drives = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_connected_drives)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_connected_drives",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Drive  // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetConnectedDrives(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Drive (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.GetMountForUuid != nil {
		pclass.get_mount_for_uuid = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_mount_for_uuid)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_mount_for_uuid",
			func(carg0 *C.GVolumeMonitor, carg1 *C.char) (cret *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var uuid          string   // in, none, string
				var goret         Mount    // return, full, converted, nullable

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uuid = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetMountForUuid(volumeMonitor, uuid)

				if goret != nil {
					cret = (*C.GMount)(UnsafeMountToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetMounts != nil {
		pclass.get_mounts = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_mounts)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_mounts",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Mount  // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetMounts(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Mount (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.GetVolumeForUuid != nil {
		pclass.get_volume_for_uuid = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_volume_for_uuid)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_volume_for_uuid",
			func(carg0 *C.GVolumeMonitor, carg1 *C.char) (cret *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var uuid          string   // in, none, string
				var goret         Volume   // return, full, converted, nullable

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				uuid = C.GoString((*C.char)(unsafe.Pointer(carg1)))

				goret = overrides.GetVolumeForUuid(volumeMonitor, uuid)

				if goret != nil {
					cret = (*C.GVolume)(UnsafeVolumeToGlibFull(goret))
				}

				return cret
			},
		)
	}

	if overrides.GetVolumes != nil {
		pclass.get_volumes = (*[0]byte)(C._goglib_gio2_VolumeMonitor_get_volumes)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_get_volumes",
			func(carg0 *C.GVolumeMonitor) (cret *C.GList) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var goret         []Volume // return, transfer: full, C Pointers: 1, Name: List, scope: 

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetVolumes(volumeMonitor)

				_ = goret
				_ = cret
				panic("unimplemented conversion of []Volume (GList*) because of no basic converter found")

				return cret
			},
		)
	}

	if overrides.MountAdded != nil {
		pclass.mount_added = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_added)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_added",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountAdded(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountChanged != nil {
		pclass.mount_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountChanged(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountPreUnmount != nil {
		pclass.mount_pre_unmount = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_pre_unmount)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_pre_unmount",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountPreUnmount(volumeMonitor, mount)
			},
		)
	}

	if overrides.MountRemoved != nil {
		pclass.mount_removed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_mount_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_mount_removed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GMount) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var mount         Mount    // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				mount = UnsafeMountFromGlibNone(unsafe.Pointer(carg1))

				overrides.MountRemoved(volumeMonitor, mount)
			},
		)
	}

	if overrides.VolumeAdded != nil {
		pclass.volume_added = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_added)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_added",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeAdded(volumeMonitor, volume)
			},
		)
	}

	if overrides.VolumeChanged != nil {
		pclass.volume_changed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_changed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_changed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeChanged(volumeMonitor, volume)
			},
		)
	}

	if overrides.VolumeRemoved != nil {
		pclass.volume_removed = (*[0]byte)(C._goglib_gio2_VolumeMonitor_volume_removed)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_VolumeMonitor_volume_removed",
			func(carg0 *C.GVolumeMonitor, carg1 *C.GVolume) {
				var volumeMonitor Instance // go GVolumeMonitor subclass
				var volume        Volume   // in, none, converted

				volumeMonitor = UnsafeVolumeMonitorFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				volume = UnsafeVolumeFromGlibNone(unsafe.Pointer(carg1))

				overrides.VolumeRemoved(volumeMonitor, volume)
			},
		)
	}
}

// ParentDriveChanged calls the default implementations of the `GVolumeMonitor.drive_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- drive Drive 
func (volumeMonitor *VolumeMonitorInstance) ParentDriveChanged(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_changed(unsafe.Pointer(parentclass.drive_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveConnected calls the default implementations of the `GVolumeMonitor.drive_connected` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- drive Drive 
func (volumeMonitor *VolumeMonitorInstance) ParentDriveConnected(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_connected(unsafe.Pointer(parentclass.drive_connected), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveDisconnected calls the default implementations of the `GVolumeMonitor.drive_disconnected` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- drive Drive 
func (volumeMonitor *VolumeMonitorInstance) ParentDriveDisconnected(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_disconnected(unsafe.Pointer(parentclass.drive_disconnected), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveEjectButton calls the default implementations of the `GVolumeMonitor.drive_eject_button` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- drive Drive 
func (volumeMonitor *VolumeMonitorInstance) ParentDriveEjectButton(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_eject_button(unsafe.Pointer(parentclass.drive_eject_button), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentDriveStopButton calls the default implementations of the `GVolumeMonitor.drive_stop_button` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- drive Drive 
func (volumeMonitor *VolumeMonitorInstance) ParentDriveStopButton(drive Drive) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GDrive // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GDrive)(UnsafeDriveToGlibNone(drive))

	C._goglib_gio2_VolumeMonitor_virtual_drive_stop_button(unsafe.Pointer(parentclass.drive_stop_button), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// ParentGetConnectedDrives calls the default implementations of the `GVolumeMonitor.get_connected_drives` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret []Drive 
//
// Gets a list of drives connected to the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) ParentGetConnectedDrives() []Drive {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_connected_drives(unsafe.Pointer(parentclass.get_connected_drives), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Drive

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Drive {
			var dst Drive // converted
			dst = UnsafeDriveFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentGetMountForUuid calls the default implementations of the `GVolumeMonitor.get_mount_for_uuid` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- uuid string: the UUID to look for 
// 
// The function returns the following values:
// 
// 	- goret Mount (nullable) 
//
// Finds a #GMount object by its UUID (see g_mount_get_uuid())
func (volumeMonitor *VolumeMonitorInstance) ParentGetMountForUuid(uuid string) Mount {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.char   // in, none, converted
	var cret  *C.GMount // return, full, converted, nullable

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_mount_for_uuid(unsafe.Pointer(parentclass.get_mount_for_uuid), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Mount

	if cret != nil {
		goret = UnsafeMountFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetMounts calls the default implementations of the `GVolumeMonitor.get_mounts` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret []Mount 
//
// Gets a list of the mounts on the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) ParentGetMounts() []Mount {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_mounts(unsafe.Pointer(parentclass.get_mounts), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Mount

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Mount {
			var dst Mount // converted
			dst = UnsafeMountFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentGetVolumeForUuid calls the default implementations of the `GVolumeMonitor.get_volume_for_uuid` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- uuid string: the UUID to look for 
// 
// The function returns the following values:
// 
// 	- goret Volume (nullable) 
//
// Finds a #GVolume object by its UUID (see g_volume_get_uuid())
func (volumeMonitor *VolumeMonitorInstance) ParentGetVolumeForUuid(uuid string) Volume {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.char    // in, none, converted
	var cret  *C.GVolume // return, full, converted, nullable

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_volume_for_uuid(unsafe.Pointer(parentclass.get_volume_for_uuid), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var goret Volume

	if cret != nil {
		goret = UnsafeVolumeFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ParentGetVolumes calls the default implementations of the `GVolumeMonitor.get_volumes` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret []Volume 
//
// Gets a list of the volumes on the system.
// 
// The returned list should be freed with g_list_free(), after
// its elements have been unreffed with g_object_unref().
func (volumeMonitor *VolumeMonitorInstance) ParentGetVolumes() []Volume {
	var carg0 *C.GVolumeMonitor
	var cret  *C.GList // container, transfer: full

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))

	cret = C._goglib_gio2_VolumeMonitor_virtual_get_volumes(unsafe.Pointer(parentclass.get_volumes), carg0)
	runtime.KeepAlive(volumeMonitor)

	var goret []Volume

	goret = glib.UnsafeListFromGlibFull(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) Volume {
			var dst Volume // converted
			dst = UnsafeVolumeFromGlibFull(v)
			return dst
		},
	)

	return goret
}

// ParentMountAdded calls the default implementations of the `GVolumeMonitor.mount_added` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- mount Mount 
func (volumeMonitor *VolumeMonitorInstance) ParentMountAdded(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_added(unsafe.Pointer(parentclass.mount_added), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountChanged calls the default implementations of the `GVolumeMonitor.mount_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- mount Mount 
func (volumeMonitor *VolumeMonitorInstance) ParentMountChanged(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_changed(unsafe.Pointer(parentclass.mount_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountPreUnmount calls the default implementations of the `GVolumeMonitor.mount_pre_unmount` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- mount Mount 
func (volumeMonitor *VolumeMonitorInstance) ParentMountPreUnmount(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_pre_unmount(unsafe.Pointer(parentclass.mount_pre_unmount), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentMountRemoved calls the default implementations of the `GVolumeMonitor.mount_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- mount Mount 
func (volumeMonitor *VolumeMonitorInstance) ParentMountRemoved(mount Mount) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GMount // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GMount)(UnsafeMountToGlibNone(mount))

	C._goglib_gio2_VolumeMonitor_virtual_mount_removed(unsafe.Pointer(parentclass.mount_removed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// ParentVolumeAdded calls the default implementations of the `GVolumeMonitor.volume_added` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- volume Volume 
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeAdded(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_added(unsafe.Pointer(parentclass.volume_added), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// ParentVolumeChanged calls the default implementations of the `GVolumeMonitor.volume_changed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- volume Volume 
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeChanged(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_changed(unsafe.Pointer(parentclass.volume_changed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// ParentVolumeRemoved calls the default implementations of the `GVolumeMonitor.volume_removed` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- volume Volume 
func (volumeMonitor *VolumeMonitorInstance) ParentVolumeRemoved(volume Volume) {
	var carg0 *C.GVolumeMonitor
	var carg1 *C.GVolume // in, none, converted

	parentclass := (*C.GVolumeMonitorClass)(classdata.PeekParentClass(UnsafeVolumeMonitorToGlibNone(volumeMonitor)))

	carg0 = (*C.GVolumeMonitor)(UnsafeVolumeMonitorToGlibNone(volumeMonitor))
	carg1 = (*C.GVolume)(UnsafeVolumeToGlibNone(volume))

	C._goglib_gio2_VolumeMonitor_virtual_volume_removed(unsafe.Pointer(parentclass.volume_removed), carg0, carg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// RegisterVolumeMonitorSubClass is used to register a go subclass of GVolumeMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterVolumeMonitorSubClass[InstanceT VolumeMonitor](
		name string,
		classInit func(class *VolumeMonitorClass),
		constructor func() InstanceT,
		overrides VolumeMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeVolumeMonitor,
		UnsafeVolumeMonitorClassFromGlibBorrow,
		UnsafeApplyVolumeMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapVolumeMonitor(obj)
		},
		interfaceInits...,
	)
}

// ZlibDecompressorInstance is the instance type used by all types extending GZlibDecompressor. It is used internally by the bindings. Users should use the interface [ZlibDecompressor] instead.
type ZlibDecompressorInstance struct {
	_ [0]func() // equal guard
	gobject.ObjectInstance
}

var _ ZlibDecompressor = (*ZlibDecompressorInstance)(nil)

// ZlibDecompressor wraps GZlibDecompressor
//
// `GZlibDecompressor` is an implementation of [iface@Gio.Converter] that
// decompresses data compressed with zlib.
type ZlibDecompressor interface {
	gobject.Object
	upcastToGZlibDecompressor() *ZlibDecompressorInstance

	// GetFileInfo wraps g_zlib_decompressor_get_file_info
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo (nullable) 
	//
	// Gets the [property@Gio.ZlibDecompressor:file-info] property.
	GetFileInfo() FileInfo

	// chain up virtual methods:
}

func unsafeWrapZlibDecompressor(base *gobject.ObjectInstance) *ZlibDecompressorInstance {
	return &ZlibDecompressorInstance{
		ObjectInstance: *base,
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeZlibDecompressor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapZlibDecompressor(inst)
		},
	)
}

func marshalZlibDecompressorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeZlibDecompressorFromGlibNone is used to convert raw GZlibDecompressor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibNone(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibNone(c).(ZlibDecompressor)
}

// UnsafeZlibDecompressorFromGlibFull is used to convert raw GZlibDecompressor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibFull(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibFull(c).(ZlibDecompressor)
}

// UnsafeZlibDecompressorFromGlibBorrow is used to convert raw GZlibDecompressor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeZlibDecompressorFromGlibBorrow(c unsafe.Pointer) ZlibDecompressor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ZlibDecompressor)
}

func (z *ZlibDecompressorInstance) upcastToGZlibDecompressor() *ZlibDecompressorInstance {
	return z
}

// UnsafeZlibDecompressorToGlibNone is used to convert the instance to it's C value GZlibDecompressor. This is used by the bindings internally.
func UnsafeZlibDecompressorToGlibNone(c ZlibDecompressor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeZlibDecompressorToGlibFull is used to convert the instance to it's C value GZlibDecompressor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeZlibDecompressorToGlibFull(c ZlibDecompressor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewZlibDecompressor wraps g_zlib_decompressor_new
// 
// The function takes the following parameters:
// 
// 	- format ZlibCompressorFormat: the format to use for the compressed data 
// 
// The function returns the following values:
// 
// 	- goret ZlibDecompressor 
//
// Creates a new decompressor.
func NewZlibDecompressor(format ZlibCompressorFormat) ZlibDecompressor {
	var carg1 C.GZlibCompressorFormat // in, none, casted
	var cret  *C.GZlibDecompressor    // return, full, converted

	carg1 = C.GZlibCompressorFormat(format)

	cret = C.g_zlib_decompressor_new(carg1)
	runtime.KeepAlive(format)

	var goret ZlibDecompressor

	goret = UnsafeZlibDecompressorFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetFileInfo wraps g_zlib_decompressor_get_file_info
// 
// The function returns the following values:
// 
// 	- goret FileInfo (nullable) 
//
// Gets the [property@Gio.ZlibDecompressor:file-info] property.
func (decompressor *ZlibDecompressorInstance) GetFileInfo() FileInfo {
	var carg0 *C.GZlibDecompressor // in, none, converted
	var cret  *C.GFileInfo         // return, none, converted, nullable

	carg0 = (*C.GZlibDecompressor)(UnsafeZlibDecompressorToGlibNone(decompressor))

	cret = C.g_zlib_decompressor_get_file_info(carg0)
	runtime.KeepAlive(decompressor)

	var goret FileInfo

	if cret != nil {
		goret = UnsafeFileInfoFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// ZlibDecompressorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ZlibDecompressorOverrides[Instance ZlibDecompressor] struct {
	// gobject.ObjectOverrides allows you to override virtual methods from the parent class gobject.Object
	gobject.ObjectOverrides[Instance]

}

// UnsafeApplyZlibDecompressorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyZlibDecompressorOverrides[Instance ZlibDecompressor](gclass unsafe.Pointer, overrides ZlibDecompressorOverrides[Instance]) {
	gobject.UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterZlibDecompressorSubClass is used to register a go subclass of GZlibDecompressor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterZlibDecompressorSubClass[InstanceT ZlibDecompressor](
		name string,
		classInit func(class *ZlibDecompressorClass),
		constructor func() InstanceT,
		overrides ZlibDecompressorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeZlibDecompressor,
		UnsafeZlibDecompressorClassFromGlibBorrow,
		UnsafeApplyZlibDecompressorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapZlibDecompressor(obj)
		},
		interfaceInits...,
	)
}

// FileIOStreamInstance is the instance type used by all types extending GFileIOStream. It is used internally by the bindings. Users should use the interface [FileIOStream] instead.
type FileIOStreamInstance struct {
	_ [0]func() // equal guard
	IOStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileIOStream = (*FileIOStreamInstance)(nil)

// FileIOStream wraps GFileIOStream
//
// `GFileIOStream` provides I/O streams that both read and write to the same
// file handle.
// 
// `GFileIOStream` implements [iface@Gio.Seekable], which allows the I/O
// stream to jump to arbitrary positions in the file and to truncate
// the file, provided the filesystem of the file supports these
// operations.
// 
// To find the position of a file I/O stream, use [method@Gio.Seekable.tell].
// 
// To find out if a file I/O stream supports seeking, use
// [method@Gio.Seekable.can_seek]. To position a file I/O stream, use
// [method@Gio.Seekable.seek]. To find out if a file I/O stream supports
// truncating, use [method@Gio.Seekable.can_truncate]. To truncate a file I/O
// stream, use [method@Gio.Seekable.truncate].
// 
// The default implementation of all the `GFileIOStream` operations
// and the implementation of [iface@Gio.Seekable] just call into the same
// operations on the output stream.
type FileIOStream interface {
	IOStream
	Seekable
	upcastToGFileIOStream() *FileIOStreamInstance

	// GetEtag wraps g_file_io_stream_get_etag
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	GetEtag() string
	// QueryInfo wraps g_file_io_stream_query_info
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file io stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_io_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_io_stream_query_info_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the
	//   request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Asynchronously queries the @stream for a #GFileInfo. When completed,
	// @callback will be called with a #GAsyncResult which can be used to
	// finish the operation with g_file_io_stream_query_info_finish().
	// 
	// For the synchronous version of this function, see
	// g_file_io_stream_query_info().
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_io_stream_query_info_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_io_stream_query_info_async().
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileIOStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentCanSeek() bool
	// ParentCanTruncate calls the default implementations of the `GFileIOStream.can_truncate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentCanTruncate() bool
	// ParentGetEtag calls the default implementations of the `GFileIOStream.get_etag` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	ParentGetEtag() string
	// ParentQueryInfo calls the default implementations of the `GFileIOStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file io stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_io_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileIOStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_io_stream_query_info_async().
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileIOStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileIOStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	ParentTell() int64
	// ParentTruncateFn calls the default implementations of the `GFileIOStream.truncate_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- size int64 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentTruncateFn(size int64, cancellable Cancellable) (bool, error)
}

func unsafeWrapFileIOStream(base *gobject.ObjectInstance) *FileIOStreamInstance {
	return &FileIOStreamInstance{
		IOStreamInstance: IOStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileIOStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIOStream(inst)
		},
	)
}

func marshalFileIOStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileIOStreamFromGlibNone is used to convert raw GFileIOStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibNone(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileIOStream)
}

// UnsafeFileIOStreamFromGlibFull is used to convert raw GFileIOStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibFull(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileIOStream)
}

// UnsafeFileIOStreamFromGlibBorrow is used to convert raw GFileIOStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileIOStreamFromGlibBorrow(c unsafe.Pointer) FileIOStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileIOStream)
}

func (f *FileIOStreamInstance) upcastToGFileIOStream() *FileIOStreamInstance {
	return f
}

// UnsafeFileIOStreamToGlibNone is used to convert the instance to it's C value GFileIOStream. This is used by the bindings internally.
func UnsafeFileIOStreamToGlibNone(c FileIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileIOStreamToGlibFull is used to convert the instance to it's C value GFileIOStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileIOStreamToGlibFull(c FileIOStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetEtag wraps g_file_io_stream_get_etag
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (stream *FileIOStreamInstance) GetEtag() string {
	var carg0 *C.GFileIOStream // in, none, converted
	var cret  *C.char          // return, full, string, nullable-string

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C.g_file_io_stream_get_etag(carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// QueryInfo wraps g_file_io_stream_query_info
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file io stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_io_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
// all cases of failure, %NULL will be returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (stream *FileIOStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileIOStream // in, none, converted
	var carg1 *C.char          // in, none, string
	var carg2 *C.GCancellable  // in, none, converted, nullable
	var cret  *C.GFileInfo     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_io_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_io_stream_query_info_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the
//   request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Asynchronously queries the @stream for a #GFileInfo. When completed,
// @callback will be called with a #GAsyncResult which can be used to
// finish the operation with g_file_io_stream_query_info_finish().
// 
// For the synchronous version of this function, see
// g_file_io_stream_query_info().
func (stream *FileIOStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileIOStream      // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_io_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_io_stream_query_info_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finalizes the asynchronous query started
// by g_file_io_stream_query_info_async().
func (stream *FileIOStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileIOStream // in, none, converted
	var carg1 *C.GAsyncResult  // in, none, converted
	var cret  *C.GFileInfo     // return, full, converted
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_io_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileIOStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileIOStreamOverrides[Instance FileIOStream] struct {
	// IOStreamOverrides allows you to override virtual methods from the parent class IOStream
	IOStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	CanSeek func(Instance) bool
	// // CanTruncate allows you to override the implementation of the virtual method can_truncate.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	CanTruncate func(Instance) bool
	// // GetEtag allows you to override the implementation of the virtual method get_etag.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	GetEtag func(Instance) string
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file io stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_io_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_io_stream_query_info_async().
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	Tell func(Instance) int64
	// // TruncateFn allows you to override the implementation of the virtual method truncate_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- size int64 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	TruncateFn func(Instance, int64, Cancellable) (bool, error)
}

// UnsafeApplyFileIOStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileIOStreamOverrides[Instance FileIOStream](gclass unsafe.Pointer, overrides FileIOStreamOverrides[Instance]) {
	UnsafeApplyIOStreamOverrides(gclass, overrides.IOStreamOverrides)

	pclass := (*C.GFileIOStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileIOStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_can_seek",
			func(carg0 *C.GFileIOStream) (cret C.gboolean) {
				var stream Instance // go GFileIOStream subclass
				var goret  bool     // return

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._goglib_gio2_FileIOStream_can_truncate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_can_truncate",
			func(carg0 *C.GFileIOStream) (cret C.gboolean) {
				var stream Instance // go GFileIOStream subclass
				var goret  bool     // return

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanTruncate(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetEtag != nil {
		pclass.get_etag = (*[0]byte)(C._goglib_gio2_FileIOStream_get_etag)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_get_etag",
			func(carg0 *C.GFileIOStream) (cret *C.char) {
				var stream Instance // go GFileIOStream subclass
				var goret  string   // return, full, string, nullable-string

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetEtag(stream)

				if goret != "" {
					cret = (*C.char)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileIOStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_query_info",
			func(carg0 *C.GFileIOStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileIOStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileIOStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_query_info_finish",
			func(carg0 *C.GFileIOStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileIOStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileIOStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_seek",
			func(carg0 *C.GFileIOStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileIOStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileIOStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_tell",
			func(carg0 *C.GFileIOStream) (cret C.goffset) {
				var stream Instance // go GFileIOStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._goglib_gio2_FileIOStream_truncate_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileIOStream_truncate_fn",
			func(carg0 *C.GFileIOStream, carg1 C.goffset, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GFileIOStream subclass
				var size        int64       // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeFileIOStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				size = int64(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.TruncateFn(stream, size, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileIOStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
func (stream *FileIOStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileIOStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentCanTruncate calls the default implementations of the `GFileIOStream.can_truncate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
func (stream *FileIOStreamInstance) ParentCanTruncate() bool {
	var carg0 *C.GFileIOStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_can_truncate(unsafe.Pointer(parentclass.can_truncate), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetEtag calls the default implementations of the `GFileIOStream.get_etag` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (stream *FileIOStreamInstance) ParentGetEtag() string {
	var carg0 *C.GFileIOStream
	var cret  *C.char // return, full, string, nullable-string

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_get_etag(unsafe.Pointer(parentclass.get_etag), carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileIOStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file io stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_io_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
// all cases of failure, %NULL will be returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (stream *FileIOStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileIOStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileIOStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finalizes the asynchronous query started
// by g_file_io_stream_query_info_async().
func (stream *FileIOStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileIOStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileIOStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileIOStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- offset int64 
// 	- typ glib.SeekType 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *FileIOStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileIOStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileIOStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int64 
func (stream *FileIOStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileIOStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileIOStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// ParentTruncateFn calls the default implementations of the `GFileIOStream.truncate_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- size int64 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *FileIOStreamInstance) ParentTruncateFn(size int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileIOStream
	var carg1 C.goffset       // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileIOStreamClass)(classdata.PeekParentClass(UnsafeFileIOStreamToGlibNone(stream)))

	carg0 = (*C.GFileIOStream)(UnsafeFileIOStreamToGlibNone(stream))
	carg1 = C.goffset(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileIOStream_virtual_truncate_fn(unsafe.Pointer(parentclass.truncate_fn), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileIOStreamSubClass is used to register a go subclass of GFileIOStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileIOStreamSubClass[InstanceT FileIOStream](
		name string,
		classInit func(class *FileIOStreamClass),
		constructor func() InstanceT,
		overrides FileIOStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileIOStream,
		UnsafeFileIOStreamClassFromGlibBorrow,
		UnsafeApplyFileIOStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileIOStream(obj)
		},
		interfaceInits...,
	)
}

// FileInputStreamInstance is the instance type used by all types extending GFileInputStream. It is used internally by the bindings. Users should use the interface [FileInputStream] instead.
type FileInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileInputStream = (*FileInputStreamInstance)(nil)

// FileInputStream wraps GFileInputStream
//
// `GFileInputStream` provides input streams that take their
// content from a file.
// 
// `GFileInputStream` implements [iface@Gio.Seekable], which allows the input
// stream to jump to arbitrary positions in the file, provided the
// filesystem of the file allows it. To find the position of a file
// input stream, use [method@Gio.Seekable.tell]. To find out if a file input
// stream supports seeking, use [vfunc@Gio.Seekable.can_seek].
// To position a file input stream, use [vfunc@Gio.Seekable.seek].
type FileInputStream interface {
	InputStream
	Seekable
	upcastToGFileInputStream() *FileInputStreamInstance

	// QueryInfo wraps g_file_input_stream_query_info
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file input stream the given @attributes. This function blocks
	// while querying the stream. For the asynchronous (non-blocking) version
	// of this function, see g_file_input_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_input_stream_query_info_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
	//   to call when the request is satisfied 
	//
	// Queries the stream information asynchronously.
	// When the operation is finished @callback will be called.
	// You can then call g_file_input_stream_query_info_finish()
	// to get the result of the operation.
	// 
	// For the synchronous version of this function,
	// see g_file_input_stream_query_info().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_input_stream_query_info_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous info query operation.
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileInputStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentCanSeek() bool
	// ParentQueryInfo calls the default implementations of the `GFileInputStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file input stream the given @attributes. This function blocks
	// while querying the stream. For the asynchronous (non-blocking) version
	// of this function, see g_file_input_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileInputStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous info query operation.
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileInputStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileInputStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	ParentTell() int64
}

func unsafeWrapFileInputStream(base *gobject.ObjectInstance) *FileInputStreamInstance {
	return &FileInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInputStream(inst)
		},
	)
}

func marshalFileInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileInputStreamFromGlibNone is used to convert raw GFileInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibNone(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileInputStream)
}

// UnsafeFileInputStreamFromGlibFull is used to convert raw GFileInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibFull(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileInputStream)
}

// UnsafeFileInputStreamFromGlibBorrow is used to convert raw GFileInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileInputStreamFromGlibBorrow(c unsafe.Pointer) FileInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileInputStream)
}

func (f *FileInputStreamInstance) upcastToGFileInputStream() *FileInputStreamInstance {
	return f
}

// UnsafeFileInputStreamToGlibNone is used to convert the instance to it's C value GFileInputStream. This is used by the bindings internally.
func UnsafeFileInputStreamToGlibNone(c FileInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileInputStreamToGlibFull is used to convert the instance to it's C value GFileInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileInputStreamToGlibFull(c FileInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// QueryInfo wraps g_file_input_stream_query_info
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file input stream the given @attributes. This function blocks
// while querying the stream. For the asynchronous (non-blocking) version
// of this function, see g_file_input_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and
// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
func (stream *FileInputStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileInputStream // in, none, converted
	var carg1 *C.char             // in, none, string
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var cret  *C.GFileInfo        // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_input_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_input_stream_query_info_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): a #GAsyncReadyCallback
//   to call when the request is satisfied 
//
// Queries the stream information asynchronously.
// When the operation is finished @callback will be called.
// You can then call g_file_input_stream_query_info_finish()
// to get the result of the operation.
// 
// For the synchronous version of this function,
// see g_file_input_stream_query_info().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set
func (stream *FileInputStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileInputStream   // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_input_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_input_stream_query_info_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous info query operation.
func (stream *FileInputStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var cret  *C.GFileInfo        // return, full, converted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_input_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileInputStreamOverrides[Instance FileInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	CanSeek func(Instance) bool
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file input stream the given @attributes. This function blocks
	// while querying the stream. For the asynchronous (non-blocking) version
	// of this function, see g_file_input_stream_query_info_async(). While the
	// stream is blocked, the stream will set the pending flag internally, and
	// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous info query operation.
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	Tell func(Instance) int64
}

// UnsafeApplyFileInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileInputStreamOverrides[Instance FileInputStream](gclass unsafe.Pointer, overrides FileInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)

	pclass := (*C.GFileInputStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileInputStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_can_seek",
			func(carg0 *C.GFileInputStream) (cret C.gboolean) {
				var stream Instance // go GFileInputStream subclass
				var goret  bool     // return

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileInputStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_query_info",
			func(carg0 *C.GFileInputStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileInputStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileInputStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_query_info_finish",
			func(carg0 *C.GFileInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileInputStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_seek",
			func(carg0 *C.GFileInputStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileInputStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileInputStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileInputStream_tell",
			func(carg0 *C.GFileInputStream) (cret C.goffset) {
				var stream Instance // go GFileInputStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileInputStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
func (stream *FileInputStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileInputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileInputStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileInputStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file input stream the given @attributes. This function blocks
// while querying the stream. For the asynchronous (non-blocking) version
// of this function, see g_file_input_stream_query_info_async(). While the
// stream is blocked, the stream will set the pending flag internally, and
// any other operations on the stream will fail with %G_IO_ERROR_PENDING.
func (stream *FileInputStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileInputStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileInputStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileInputStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous info query operation.
func (stream *FileInputStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileInputStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileInputStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- offset int64 
// 	- typ glib.SeekType 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *FileInputStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileInputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileInputStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileInputStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int64 
func (stream *FileInputStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileInputStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileInputStreamClass)(classdata.PeekParentClass(UnsafeFileInputStreamToGlibNone(stream)))

	carg0 = (*C.GFileInputStream)(UnsafeFileInputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileInputStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// RegisterFileInputStreamSubClass is used to register a go subclass of GFileInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileInputStreamSubClass[InstanceT FileInputStream](
		name string,
		classInit func(class *FileInputStreamClass),
		constructor func() InstanceT,
		overrides FileInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileInputStream,
		UnsafeFileInputStreamClassFromGlibBorrow,
		UnsafeApplyFileInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileInputStream(obj)
		},
		interfaceInits...,
	)
}

// FileOutputStreamInstance is the instance type used by all types extending GFileOutputStream. It is used internally by the bindings. Users should use the interface [FileOutputStream] instead.
type FileOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ FileOutputStream = (*FileOutputStreamInstance)(nil)

// FileOutputStream wraps GFileOutputStream
//
// `GFileOutputStream` provides output streams that write their
// content to a file.
// 
// `GFileOutputStream` implements [iface@Gio.Seekable], which allows the output
// stream to jump to arbitrary positions in the file and to truncate
// the file, provided the filesystem of the file supports these
// operations.
// 
// To find the position of a file output stream, use [method@Gio.Seekable.tell].
// To find out if a file output stream supports seeking, use
// [method@Gio.Seekable.can_seek].To position a file output stream, use
// [method@Gio.Seekable.seek]. To find out if a file output stream supports
// truncating, use [method@Gio.Seekable.can_truncate]. To truncate a file output
// stream, use [method@Gio.Seekable.truncate].
type FileOutputStream interface {
	OutputStream
	Seekable
	upcastToGFileOutputStream() *FileOutputStreamInstance

	// GetEtag wraps g_file_output_stream_get_etag
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	GetEtag() string
	// QueryInfo wraps g_file_output_stream_query_info
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file output stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_output_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	QueryInfo(string, Cancellable) (FileInfo, error)
	// QueryInfoAsync wraps g_file_output_stream_query_info_async
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the
	//   request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied 
	//
	// Asynchronously queries the @stream for a #GFileInfo. When completed,
	// @callback will be called with a #GAsyncResult which can be used to
	// finish the operation with g_file_output_stream_query_info_finish().
	// 
	// For the synchronous version of this function, see
	// g_file_output_stream_query_info().
	QueryInfoAsync(string, int32, Cancellable, AsyncReadyCallback)
	// QueryInfoFinish wraps g_file_output_stream_query_info_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_output_stream_query_info_async().
	QueryInfoFinish(AsyncResult) (FileInfo, error)

	// chain up virtual methods:

	// ParentCanSeek calls the default implementations of the `GFileOutputStream.can_seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentCanSeek() bool
	// ParentCanTruncate calls the default implementations of the `GFileOutputStream.can_truncate` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	ParentCanTruncate() bool
	// ParentGetEtag calls the default implementations of the `GFileOutputStream.get_etag` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	ParentGetEtag() string
	// ParentQueryInfo calls the default implementations of the `GFileOutputStream.query_info` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file output stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_output_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error)
	// ParentQueryInfoFinish calls the default implementations of the `GFileOutputStream.query_info_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_output_stream_query_info_async().
	ParentQueryInfoFinish(result AsyncResult) (FileInfo, error)
	// ParentSeek calls the default implementations of the `GFileOutputStream.seek` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error)
	// ParentTell calls the default implementations of the `GFileOutputStream.tell` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	ParentTell() int64
	// ParentTruncateFn calls the default implementations of the `GFileOutputStream.truncate_fn` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- size int64 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	ParentTruncateFn(size int64, cancellable Cancellable) (bool, error)
}

func unsafeWrapFileOutputStream(base *gobject.ObjectInstance) *FileOutputStreamInstance {
	return &FileOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFileOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileOutputStream(inst)
		},
	)
}

func marshalFileOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFileOutputStreamFromGlibNone is used to convert raw GFileOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibNone(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FileOutputStream)
}

// UnsafeFileOutputStreamFromGlibFull is used to convert raw GFileOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibFull(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FileOutputStream)
}

// UnsafeFileOutputStreamFromGlibBorrow is used to convert raw GFileOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFileOutputStreamFromGlibBorrow(c unsafe.Pointer) FileOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FileOutputStream)
}

func (f *FileOutputStreamInstance) upcastToGFileOutputStream() *FileOutputStreamInstance {
	return f
}

// UnsafeFileOutputStreamToGlibNone is used to convert the instance to it's C value GFileOutputStream. This is used by the bindings internally.
func UnsafeFileOutputStreamToGlibNone(c FileOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFileOutputStreamToGlibFull is used to convert the instance to it's C value GFileOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFileOutputStreamToGlibFull(c FileOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetEtag wraps g_file_output_stream_get_etag
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (stream *FileOutputStreamInstance) GetEtag() string {
	var carg0 *C.GFileOutputStream // in, none, converted
	var cret  *C.char              // return, full, string, nullable-string

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C.g_file_output_stream_get_etag(carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// QueryInfo wraps g_file_output_stream_query_info
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file output stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_output_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
// all cases of failure, %NULL will be returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (stream *FileOutputStreamInstance) QueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileOutputStream // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  *C.GFileInfo         // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_file_output_stream_query_info(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// QueryInfoAsync wraps g_file_output_stream_query_info_async
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the
//   request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied 
//
// Asynchronously queries the @stream for a #GFileInfo. When completed,
// @callback will be called with a #GAsyncResult which can be used to
// finish the operation with g_file_output_stream_query_info_finish().
// 
// For the synchronous version of this function, see
// g_file_output_stream_query_info().
func (stream *FileOutputStreamInstance) QueryInfoAsync(attributes string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GFileOutputStream  // in, none, converted
	var carg1 *C.char               // in, none, string
	var carg2 C.int                 // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_file_output_stream_query_info_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// QueryInfoFinish wraps g_file_output_stream_query_info_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finalizes the asynchronous query started
// by g_file_output_stream_query_info_async().
func (stream *FileOutputStreamInstance) QueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileOutputStream // in, none, converted
	var carg1 *C.GAsyncResult      // in, none, converted
	var cret  *C.GFileInfo         // return, full, converted
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_file_output_stream_query_info_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FileOutputStreamOverrides[Instance FileOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

	// // CanSeek allows you to override the implementation of the virtual method can_seek.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	CanSeek func(Instance) bool
	// // CanTruncate allows you to override the implementation of the virtual method can_truncate.
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	CanTruncate func(Instance) bool
	// // GetEtag allows you to override the implementation of the virtual method get_etag.
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the entity tag for the file when it has been written.
	// This must be called after the stream has been written
	// and closed, as the etag can change while writing.
	GetEtag func(Instance) string
	// // QueryInfo allows you to override the implementation of the virtual method query_info.
	// 
	// The function takes the following parameters:
	// 
	// 	- attributes string: a file attribute query string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Queries a file output stream for the given @attributes.
	// This function blocks while querying the stream. For the asynchronous
	// version of this function, see g_file_output_stream_query_info_async().
	// While the stream is blocked, the stream will set the pending flag
	// internally, and any other operations on the stream will fail with
	// %G_IO_ERROR_PENDING.
	// 
	// Can fail if the stream was already closed (with @error being set to
	// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
	// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
	// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
	// all cases of failure, %NULL will be returned.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
	// be returned.
	QueryInfo func(Instance, string, Cancellable) (FileInfo, error)
	// // QueryInfoFinish allows you to override the implementation of the virtual method query_info_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a #GAsyncResult. 
	// 
	// The function returns the following values:
	// 
	// 	- goret FileInfo 
	// 	- _goerr error (nullable): an error 
	//
	// Finalizes the asynchronous query started
	// by g_file_output_stream_query_info_async().
	QueryInfoFinish func(Instance, AsyncResult) (FileInfo, error)
	// // Seek allows you to override the implementation of the virtual method seek.
	// 
	// The function takes the following parameters:
	// 
	// 	- offset int64 
	// 	- typ glib.SeekType 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	Seek func(Instance, int64, glib.SeekType, Cancellable) (bool, error)
	// // Tell allows you to override the implementation of the virtual method tell.
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	Tell func(Instance) int64
	// // TruncateFn allows you to override the implementation of the virtual method truncate_fn.
	// 
	// The function takes the following parameters:
	// 
	// 	- size int64 
	// 	- cancellable Cancellable (nullable) 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	TruncateFn func(Instance, int64, Cancellable) (bool, error)
}

// UnsafeApplyFileOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFileOutputStreamOverrides[Instance FileOutputStream](gclass unsafe.Pointer, overrides FileOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)

	pclass := (*C.GFileOutputStreamClass)(gclass)

	if overrides.CanSeek != nil {
		pclass.can_seek = (*[0]byte)(C._goglib_gio2_FileOutputStream_can_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_can_seek",
			func(carg0 *C.GFileOutputStream) (cret C.gboolean) {
				var stream Instance // go GFileOutputStream subclass
				var goret  bool     // return

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanSeek(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.CanTruncate != nil {
		pclass.can_truncate = (*[0]byte)(C._goglib_gio2_FileOutputStream_can_truncate)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_can_truncate",
			func(carg0 *C.GFileOutputStream) (cret C.gboolean) {
				var stream Instance // go GFileOutputStream subclass
				var goret  bool     // return

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.CanTruncate(stream)

				if goret {
					cret = C.TRUE
				}

				return cret
			},
		)
	}

	if overrides.GetEtag != nil {
		pclass.get_etag = (*[0]byte)(C._goglib_gio2_FileOutputStream_get_etag)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_get_etag",
			func(carg0 *C.GFileOutputStream) (cret *C.char) {
				var stream Instance // go GFileOutputStream subclass
				var goret  string   // return, full, string, nullable-string

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.GetEtag(stream)

				if goret != "" {
					cret = (*C.char)(unsafe.Pointer(C.CString(goret)))
				}

				return cret
			},
		)
	}

	if overrides.QueryInfo != nil {
		pclass.query_info = (*[0]byte)(C._goglib_gio2_FileOutputStream_query_info)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_query_info",
			func(carg0 *C.GFileOutputStream, carg1 *C.char, carg2 *C.GCancellable, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream      Instance    // go GFileOutputStream subclass
				var attributes  string      // in, none, string
				var cancellable Cancellable // in, none, converted, nullable
				var goret       FileInfo    // return, full, converted
				var _goerr      error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				attributes = C.GoString((*C.char)(unsafe.Pointer(carg1)))
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.QueryInfo(stream, attributes, cancellable)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.QueryInfoFinish != nil {
		pclass.query_info_finish = (*[0]byte)(C._goglib_gio2_FileOutputStream_query_info_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_query_info_finish",
			func(carg0 *C.GFileOutputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GFileInfo) {
				var stream Instance    // go GFileOutputStream subclass
				var result AsyncResult // in, none, converted
				var goret  FileInfo    // return, full, converted
				var _goerr error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.QueryInfoFinish(stream, result)

				cret = (*C.GFileInfo)(UnsafeFileInfoToGlibFull(goret))
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._goglib_gio2_FileOutputStream_seek)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_seek",
			func(carg0 *C.GFileOutputStream, carg1 C.goffset, carg2 C.GSeekType, carg3 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance      // go GFileOutputStream subclass
				var offset      int64         // in, none, casted
				var typ         glib.SeekType // in, none, casted
				var cancellable Cancellable   // in, none, converted, nullable
				var goret       bool          // return
				var _goerr      error         // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				offset = int64(carg1)
				typ = glib.SeekType(carg2)
				if carg3 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg3))
				}

				goret, _goerr = overrides.Seek(stream, offset, typ, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.Tell != nil {
		pclass.tell = (*[0]byte)(C._goglib_gio2_FileOutputStream_tell)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_tell",
			func(carg0 *C.GFileOutputStream) (cret C.goffset) {
				var stream Instance // go GFileOutputStream subclass
				var goret  int64    // return, none, casted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)

				goret = overrides.Tell(stream)

				cret = C.goffset(goret)

				return cret
			},
		)
	}

	if overrides.TruncateFn != nil {
		pclass.truncate_fn = (*[0]byte)(C._goglib_gio2_FileOutputStream_truncate_fn)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_FileOutputStream_truncate_fn",
			func(carg0 *C.GFileOutputStream, carg1 C.goffset, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
				var stream      Instance    // go GFileOutputStream subclass
				var size        int64       // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       bool        // return
				var _goerr      error       // out, full, converted

				stream = UnsafeFileOutputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				size = int64(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.TruncateFn(stream, size, cancellable)

				if goret {
					cret = C.TRUE
				}
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentCanSeek calls the default implementations of the `GFileOutputStream.can_seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
func (stream *FileOutputStreamInstance) ParentCanSeek() bool {
	var carg0 *C.GFileOutputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_can_seek(unsafe.Pointer(parentclass.can_seek), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentCanTruncate calls the default implementations of the `GFileOutputStream.can_truncate` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret bool 
func (stream *FileOutputStreamInstance) ParentCanTruncate() bool {
	var carg0 *C.GFileOutputStream
	var cret  C.gboolean // return

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_can_truncate(unsafe.Pointer(parentclass.can_truncate), carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParentGetEtag calls the default implementations of the `GFileOutputStream.get_etag` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the entity tag for the file when it has been written.
// This must be called after the stream has been written
// and closed, as the etag can change while writing.
func (stream *FileOutputStreamInstance) ParentGetEtag() string {
	var carg0 *C.GFileOutputStream
	var cret  *C.char // return, full, string, nullable-string

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_get_etag(unsafe.Pointer(parentclass.get_etag), carg0)
	runtime.KeepAlive(stream)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ParentQueryInfo calls the default implementations of the `GFileOutputStream.query_info` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- attributes string: a file attribute query string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Queries a file output stream for the given @attributes.
// This function blocks while querying the stream. For the asynchronous
// version of this function, see g_file_output_stream_query_info_async().
// While the stream is blocked, the stream will set the pending flag
// internally, and any other operations on the stream will fail with
// %G_IO_ERROR_PENDING.
// 
// Can fail if the stream was already closed (with @error being set to
// %G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
// set to %G_IO_ERROR_PENDING), or if querying info is not supported for
// the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
// all cases of failure, %NULL will be returned.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
// be returned.
func (stream *FileOutputStreamInstance) ParentQueryInfo(attributes string, cancellable Cancellable) (FileInfo, error) {
	var carg0 *C.GFileOutputStream
	var carg1 *C.char         // in, none, converted
	var carg2 *C.GCancellable // in, none, string
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_query_info(unsafe.Pointer(parentclass.query_info), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(cancellable)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentQueryInfoFinish calls the default implementations of the `GFileOutputStream.query_info_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a #GAsyncResult. 
// 
// The function returns the following values:
// 
// 	- goret FileInfo 
// 	- _goerr error (nullable): an error 
//
// Finalizes the asynchronous query started
// by g_file_output_stream_query_info_async().
func (stream *FileOutputStreamInstance) ParentQueryInfoFinish(result AsyncResult) (FileInfo, error) {
	var carg0 *C.GFileOutputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  *C.GFileInfo    // return, full, converted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_FileOutputStream_virtual_query_info_finish(unsafe.Pointer(parentclass.query_info_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  FileInfo
	var _goerr error

	goret = UnsafeFileInfoFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentSeek calls the default implementations of the `GFileOutputStream.seek` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- offset int64 
// 	- typ glib.SeekType 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *FileOutputStreamInstance) ParentSeek(offset int64, typ glib.SeekType, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileOutputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 C.GSeekType     // in, none, casted
	var carg3 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = C.goffset(offset)
	carg2 = C.GSeekType(typ)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_seek(unsafe.Pointer(parentclass.seek), carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentTell calls the default implementations of the `GFileOutputStream.tell` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function returns the following values:
// 
// 	- goret int64 
func (stream *FileOutputStreamInstance) ParentTell() int64 {
	var carg0 *C.GFileOutputStream
	var cret  C.goffset // return, none, casted

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))

	cret = C._goglib_gio2_FileOutputStream_virtual_tell(unsafe.Pointer(parentclass.tell), carg0)
	runtime.KeepAlive(stream)

	var goret int64

	goret = int64(cret)

	return goret
}

// ParentTruncateFn calls the default implementations of the `GFileOutputStream.truncate_fn` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- size int64 
// 	- cancellable Cancellable (nullable) 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
func (stream *FileOutputStreamInstance) ParentTruncateFn(size int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GFileOutputStream
	var carg1 C.goffset       // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GFileOutputStreamClass)(classdata.PeekParentClass(UnsafeFileOutputStreamToGlibNone(stream)))

	carg0 = (*C.GFileOutputStream)(UnsafeFileOutputStreamToGlibNone(stream))
	carg1 = C.goffset(size)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_FileOutputStream_virtual_truncate_fn(unsafe.Pointer(parentclass.truncate_fn), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterFileOutputStreamSubClass is used to register a go subclass of GFileOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFileOutputStreamSubClass[InstanceT FileOutputStream](
		name string,
		classInit func(class *FileOutputStreamClass),
		constructor func() InstanceT,
		overrides FileOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFileOutputStream,
		UnsafeFileOutputStreamClassFromGlibBorrow,
		UnsafeApplyFileOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFileOutputStream(obj)
		},
		interfaceInits...,
	)
}

// FilterInputStreamInstance is the instance type used by all types extending GFilterInputStream. It is used internally by the bindings. Users should use the interface [FilterInputStream] instead.
type FilterInputStreamInstance struct {
	_ [0]func() // equal guard
	InputStreamInstance
}

var _ FilterInputStream = (*FilterInputStreamInstance)(nil)

// FilterInputStream wraps GFilterInputStream
//
// Base class for input stream implementations that perform some
// kind of filtering operation on a base stream. Typical examples
// of filtering operations are character set conversion, compression
// and byte order flipping.
type FilterInputStream interface {
	InputStream
	upcastToGFilterInputStream() *FilterInputStreamInstance

	// GetBaseStream wraps g_filter_input_stream_get_base_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret InputStream 
	//
	// Gets the base stream for the filter stream.
	GetBaseStream() InputStream
	// GetCloseBaseStream wraps g_filter_input_stream_get_close_base_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Returns whether the base stream will be closed when @stream is
	// closed.
	GetCloseBaseStream() bool
	// SetCloseBaseStream wraps g_filter_input_stream_set_close_base_stream
	// 
	// The function takes the following parameters:
	// 
	// 	- closeBase bool: %TRUE to close the base stream. 
	//
	// Sets whether the base stream will be closed when @stream is closed.
	SetCloseBaseStream(bool)

	// chain up virtual methods:
}

func unsafeWrapFilterInputStream(base *gobject.ObjectInstance) *FilterInputStreamInstance {
	return &FilterInputStreamInstance{
		InputStreamInstance: InputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilterInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterInputStream(inst)
		},
	)
}

func marshalFilterInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilterInputStreamFromGlibNone is used to convert raw GFilterInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibNone(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FilterInputStream)
}

// UnsafeFilterInputStreamFromGlibFull is used to convert raw GFilterInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibFull(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FilterInputStream)
}

// UnsafeFilterInputStreamFromGlibBorrow is used to convert raw GFilterInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilterInputStreamFromGlibBorrow(c unsafe.Pointer) FilterInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilterInputStream)
}

func (f *FilterInputStreamInstance) upcastToGFilterInputStream() *FilterInputStreamInstance {
	return f
}

// UnsafeFilterInputStreamToGlibNone is used to convert the instance to it's C value GFilterInputStream. This is used by the bindings internally.
func UnsafeFilterInputStreamToGlibNone(c FilterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilterInputStreamToGlibFull is used to convert the instance to it's C value GFilterInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilterInputStreamToGlibFull(c FilterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetBaseStream wraps g_filter_input_stream_get_base_stream
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Gets the base stream for the filter stream.
func (stream *FilterInputStreamInstance) GetBaseStream() InputStream {
	var carg0 *C.GFilterInputStream // in, none, converted
	var cret  *C.GInputStream       // return, none, converted

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))

	cret = C.g_filter_input_stream_get_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCloseBaseStream wraps g_filter_input_stream_get_close_base_stream
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the base stream will be closed when @stream is
// closed.
func (stream *FilterInputStreamInstance) GetCloseBaseStream() bool {
	var carg0 *C.GFilterInputStream // in, none, converted
	var cret  C.gboolean            // return

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))

	cret = C.g_filter_input_stream_get_close_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetCloseBaseStream wraps g_filter_input_stream_set_close_base_stream
// 
// The function takes the following parameters:
// 
// 	- closeBase bool: %TRUE to close the base stream. 
//
// Sets whether the base stream will be closed when @stream is closed.
func (stream *FilterInputStreamInstance) SetCloseBaseStream(closeBase bool) {
	var carg0 *C.GFilterInputStream // in, none, converted
	var carg1 C.gboolean            // in

	carg0 = (*C.GFilterInputStream)(UnsafeFilterInputStreamToGlibNone(stream))
	if closeBase {
		carg1 = C.TRUE
	}

	C.g_filter_input_stream_set_close_base_stream(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// FilterInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilterInputStreamOverrides[Instance FilterInputStream] struct {
	// InputStreamOverrides allows you to override virtual methods from the parent class InputStream
	InputStreamOverrides[Instance]

}

// UnsafeApplyFilterInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilterInputStreamOverrides[Instance FilterInputStream](gclass unsafe.Pointer, overrides FilterInputStreamOverrides[Instance]) {
	UnsafeApplyInputStreamOverrides(gclass, overrides.InputStreamOverrides)
}

// RegisterFilterInputStreamSubClass is used to register a go subclass of GFilterInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilterInputStreamSubClass[InstanceT FilterInputStream](
		name string,
		classInit func(class *FilterInputStreamClass),
		constructor func() InstanceT,
		overrides FilterInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilterInputStream,
		UnsafeFilterInputStreamClassFromGlibBorrow,
		UnsafeApplyFilterInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterInputStream(obj)
		},
		interfaceInits...,
	)
}

// FilterOutputStreamInstance is the instance type used by all types extending GFilterOutputStream. It is used internally by the bindings. Users should use the interface [FilterOutputStream] instead.
type FilterOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
}

var _ FilterOutputStream = (*FilterOutputStreamInstance)(nil)

// FilterOutputStream wraps GFilterOutputStream
//
// Base class for output stream implementations that perform some
// kind of filtering operation on a base stream. Typical examples
// of filtering operations are character set conversion, compression
// and byte order flipping.
type FilterOutputStream interface {
	OutputStream
	upcastToGFilterOutputStream() *FilterOutputStreamInstance

	// GetBaseStream wraps g_filter_output_stream_get_base_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret OutputStream 
	//
	// Gets the base stream for the filter stream.
	GetBaseStream() OutputStream
	// GetCloseBaseStream wraps g_filter_output_stream_get_close_base_stream
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Returns whether the base stream will be closed when @stream is
	// closed.
	GetCloseBaseStream() bool
	// SetCloseBaseStream wraps g_filter_output_stream_set_close_base_stream
	// 
	// The function takes the following parameters:
	// 
	// 	- closeBase bool: `TRUE` to close the base stream. 
	//
	// Sets whether the base stream will be closed when @stream is closed.
	SetCloseBaseStream(bool)

	// chain up virtual methods:
}

func unsafeWrapFilterOutputStream(base *gobject.ObjectInstance) *FilterOutputStreamInstance {
	return &FilterOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeFilterOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterOutputStream(inst)
		},
	)
}

func marshalFilterOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeFilterOutputStreamFromGlibNone is used to convert raw GFilterOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibNone(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(FilterOutputStream)
}

// UnsafeFilterOutputStreamFromGlibFull is used to convert raw GFilterOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibFull(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(FilterOutputStream)
}

// UnsafeFilterOutputStreamFromGlibBorrow is used to convert raw GFilterOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeFilterOutputStreamFromGlibBorrow(c unsafe.Pointer) FilterOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(FilterOutputStream)
}

func (f *FilterOutputStreamInstance) upcastToGFilterOutputStream() *FilterOutputStreamInstance {
	return f
}

// UnsafeFilterOutputStreamToGlibNone is used to convert the instance to it's C value GFilterOutputStream. This is used by the bindings internally.
func UnsafeFilterOutputStreamToGlibNone(c FilterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeFilterOutputStreamToGlibFull is used to convert the instance to it's C value GFilterOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeFilterOutputStreamToGlibFull(c FilterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// GetBaseStream wraps g_filter_output_stream_get_base_stream
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Gets the base stream for the filter stream.
func (stream *FilterOutputStreamInstance) GetBaseStream() OutputStream {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var cret  *C.GOutputStream       // return, none, converted

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))

	cret = C.g_filter_output_stream_get_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetCloseBaseStream wraps g_filter_output_stream_get_close_base_stream
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the base stream will be closed when @stream is
// closed.
func (stream *FilterOutputStreamInstance) GetCloseBaseStream() bool {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var cret  C.gboolean             // return

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))

	cret = C.g_filter_output_stream_get_close_base_stream(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetCloseBaseStream wraps g_filter_output_stream_set_close_base_stream
// 
// The function takes the following parameters:
// 
// 	- closeBase bool: `TRUE` to close the base stream. 
//
// Sets whether the base stream will be closed when @stream is closed.
func (stream *FilterOutputStreamInstance) SetCloseBaseStream(closeBase bool) {
	var carg0 *C.GFilterOutputStream // in, none, converted
	var carg1 C.gboolean             // in

	carg0 = (*C.GFilterOutputStream)(UnsafeFilterOutputStreamToGlibNone(stream))
	if closeBase {
		carg1 = C.TRUE
	}

	C.g_filter_output_stream_set_close_base_stream(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(closeBase)
}

// FilterOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type FilterOutputStreamOverrides[Instance FilterOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

}

// UnsafeApplyFilterOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyFilterOutputStreamOverrides[Instance FilterOutputStream](gclass unsafe.Pointer, overrides FilterOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)
}

// RegisterFilterOutputStreamSubClass is used to register a go subclass of GFilterOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterFilterOutputStreamSubClass[InstanceT FilterOutputStream](
		name string,
		classInit func(class *FilterOutputStreamClass),
		constructor func() InstanceT,
		overrides FilterOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeFilterOutputStream,
		UnsafeFilterOutputStreamClassFromGlibBorrow,
		UnsafeApplyFilterOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapFilterOutputStream(obj)
		},
		interfaceInits...,
	)
}

// InetSocketAddressInstance is the instance type used by all types extending GInetSocketAddress. It is used internally by the bindings. Users should use the interface [InetSocketAddress] instead.
type InetSocketAddressInstance struct {
	_ [0]func() // equal guard
	SocketAddressInstance
	// implemented interfaces:
	SocketConnectableInstance
}

var _ InetSocketAddress = (*InetSocketAddressInstance)(nil)

// InetSocketAddress wraps GInetSocketAddress
//
// An IPv4 or IPv6 socket address. That is, the combination of a
// [class@Gio.InetAddress] and a port number.
// 
// In UNIX terms, `GInetSocketAddress` corresponds to a
// [`struct sockaddr_in` or `struct sockaddr_in6`](man:sockaddr(3type)).
type InetSocketAddress interface {
	SocketAddress
	SocketConnectable
	upcastToGInetSocketAddress() *InetSocketAddressInstance

	// GetAddress wraps g_inet_socket_address_get_address
	// 
	// The function returns the following values:
	// 
	// 	- goret InetAddress 
	//
	// Gets @address's #GInetAddress.
	GetAddress() InetAddress
	// GetFlowinfo wraps g_inet_socket_address_get_flowinfo
	// 
	// The function returns the following values:
	// 
	// 	- goret uint32 
	//
	// Gets the `sin6_flowinfo` field from @address,
	// which must be an IPv6 address.
	GetFlowinfo() uint32
	// GetPort wraps g_inet_socket_address_get_port
	// 
	// The function returns the following values:
	// 
	// 	- goret uint16 
	//
	// Gets @address's port.
	GetPort() uint16
	// GetScopeID wraps g_inet_socket_address_get_scope_id
	// 
	// The function returns the following values:
	// 
	// 	- goret uint32 
	//
	// Gets the `sin6_scope_id` field from @address,
	// which must be an IPv6 address.
	GetScopeID() uint32

	// chain up virtual methods:
}

func unsafeWrapInetSocketAddress(base *gobject.ObjectInstance) *InetSocketAddressInstance {
	return &InetSocketAddressInstance{
		SocketAddressInstance: SocketAddressInstance{
			ObjectInstance: *base,
		},
		SocketConnectableInstance: SocketConnectableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeInetSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetSocketAddress(inst)
		},
	)
}

func marshalInetSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeInetSocketAddressFromGlibNone is used to convert raw GInetSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibNone(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(InetSocketAddress)
}

// UnsafeInetSocketAddressFromGlibFull is used to convert raw GInetSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibFull(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(InetSocketAddress)
}

// UnsafeInetSocketAddressFromGlibBorrow is used to convert raw GInetSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInetSocketAddressFromGlibBorrow(c unsafe.Pointer) InetSocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(InetSocketAddress)
}

func (i *InetSocketAddressInstance) upcastToGInetSocketAddress() *InetSocketAddressInstance {
	return i
}

// UnsafeInetSocketAddressToGlibNone is used to convert the instance to it's C value GInetSocketAddress. This is used by the bindings internally.
func UnsafeInetSocketAddressToGlibNone(c InetSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeInetSocketAddressToGlibFull is used to convert the instance to it's C value GInetSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInetSocketAddressToGlibFull(c InetSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewInetSocketAddress wraps g_inet_socket_address_new
// 
// The function takes the following parameters:
// 
// 	- address InetAddress: a #GInetAddress 
// 	- port uint16: a port number 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
//
// Creates a new #GInetSocketAddress for @address and @port.
func NewInetSocketAddress(address InetAddress, port uint16) SocketAddress {
	var carg1 *C.GInetAddress   // in, none, converted
	var carg2 C.guint16         // in, none, casted
	var cret  *C.GSocketAddress // return, full, converted

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(address))
	carg2 = C.guint16(port)

	cret = C.g_inet_socket_address_new(carg1, carg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var goret SocketAddress

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewInetSocketAddressFromString wraps g_inet_socket_address_new_from_string
// 
// The function takes the following parameters:
// 
// 	- address string: the string form of an IP address 
// 	- port uint: a port number 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress (nullable) 
//
// Creates a new #GInetSocketAddress for @address and @port.
// 
// If @address is an IPv6 address, it can also contain a scope ID
// (separated from the address by a `%`).
func NewInetSocketAddressFromString(address string, port uint) SocketAddress {
	var carg1 *C.char           // in, none, string
	var carg2 C.guint           // in, none, casted
	var cret  *C.GSocketAddress // return, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(port)

	cret = C.g_inet_socket_address_new_from_string(carg1, carg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var goret SocketAddress

	if cret != nil {
		goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// GetAddress wraps g_inet_socket_address_get_address
// 
// The function returns the following values:
// 
// 	- goret InetAddress 
//
// Gets @address's #GInetAddress.
func (address *InetSocketAddressInstance) GetAddress() InetAddress {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  *C.GInetAddress       // return, none, converted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_address(carg0)
	runtime.KeepAlive(address)

	var goret InetAddress

	goret = UnsafeInetAddressFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetFlowinfo wraps g_inet_socket_address_get_flowinfo
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Gets the `sin6_flowinfo` field from @address,
// which must be an IPv6 address.
func (address *InetSocketAddressInstance) GetFlowinfo() uint32 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint32             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_flowinfo(carg0)
	runtime.KeepAlive(address)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// GetPort wraps g_inet_socket_address_get_port
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @address's port.
func (address *InetSocketAddressInstance) GetPort() uint16 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint16             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_port(carg0)
	runtime.KeepAlive(address)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetScopeID wraps g_inet_socket_address_get_scope_id
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Gets the `sin6_scope_id` field from @address,
// which must be an IPv6 address.
func (address *InetSocketAddressInstance) GetScopeID() uint32 {
	var carg0 *C.GInetSocketAddress // in, none, converted
	var cret  C.guint32             // return, none, casted

	carg0 = (*C.GInetSocketAddress)(UnsafeInetSocketAddressToGlibNone(address))

	cret = C.g_inet_socket_address_get_scope_id(carg0)
	runtime.KeepAlive(address)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// InetSocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InetSocketAddressOverrides[Instance InetSocketAddress] struct {
	// SocketAddressOverrides allows you to override virtual methods from the parent class SocketAddress
	SocketAddressOverrides[Instance]

}

// UnsafeApplyInetSocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInetSocketAddressOverrides[Instance InetSocketAddress](gclass unsafe.Pointer, overrides InetSocketAddressOverrides[Instance]) {
	UnsafeApplySocketAddressOverrides(gclass, overrides.SocketAddressOverrides)
}

// RegisterInetSocketAddressSubClass is used to register a go subclass of GInetSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInetSocketAddressSubClass[InstanceT InetSocketAddress](
		name string,
		classInit func(class *InetSocketAddressClass),
		constructor func() InstanceT,
		overrides InetSocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInetSocketAddress,
		UnsafeInetSocketAddressClassFromGlibBorrow,
		UnsafeApplyInetSocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapInetSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// MemoryOutputStreamInstance is the instance type used by all types extending GMemoryOutputStream. It is used internally by the bindings. Users should use the interface [MemoryOutputStream] instead.
type MemoryOutputStreamInstance struct {
	_ [0]func() // equal guard
	OutputStreamInstance
	// implemented interfaces:
	PollableOutputStreamInstance
	SeekableInstance
}

var _ MemoryOutputStream = (*MemoryOutputStreamInstance)(nil)

// MemoryOutputStream wraps GMemoryOutputStream
//
// `GMemoryOutputStream` is a class for using arbitrary
// memory chunks as output for GIO streaming output operations.
// 
// As of GLib 2.34, `GMemoryOutputStream` trivially implements
// [iface@Gio.PollableOutputStream]: it always polls as ready.
type MemoryOutputStream interface {
	OutputStream
	PollableOutputStream
	Seekable
	upcastToGMemoryOutputStream() *MemoryOutputStreamInstance

	// GetDataSize wraps g_memory_output_stream_get_data_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Returns the number of bytes from the start up to including the last
	// byte written in the stream that has not been truncated away.
	GetDataSize() uint
	// GetSize wraps g_memory_output_stream_get_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the size of the currently allocated data area (available from
	// g_memory_output_stream_get_data()).
	// 
	// You probably don't want to use this function on resizable streams.
	// See g_memory_output_stream_get_data_size() instead.  For resizable
	// streams the size returned by this function is an implementation
	// detail and may be change at any time in response to operations on the
	// stream.
	// 
	// If the stream is fixed-sized (ie: no realloc was passed to
	// g_memory_output_stream_new()) then this is the maximum size of the
	// stream and further writes will return %G_IO_ERROR_NO_SPACE.
	// 
	// In any case, if you want the number of bytes currently written to the
	// stream, use g_memory_output_stream_get_data_size().
	GetSize() uint
	// StealAsBytes wraps g_memory_output_stream_steal_as_bytes
	// 
	// The function returns the following values:
	// 
	// 	- goret *glib.Bytes 
	//
	// Returns data from the @ostream as a #GBytes. @ostream must be
	// closed before calling this function.
	StealAsBytes() *glib.Bytes

	// chain up virtual methods:
}

func unsafeWrapMemoryOutputStream(base *gobject.ObjectInstance) *MemoryOutputStreamInstance {
	return &MemoryOutputStreamInstance{
		OutputStreamInstance: OutputStreamInstance{
			ObjectInstance: *base,
		},
		PollableOutputStreamInstance: PollableOutputStreamInstance{
			Instance: *base,
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMemoryOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryOutputStream(inst)
		},
	)
}

func marshalMemoryOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMemoryOutputStreamFromGlibNone is used to convert raw GMemoryOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibNone(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(MemoryOutputStream)
}

// UnsafeMemoryOutputStreamFromGlibFull is used to convert raw GMemoryOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibFull(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(MemoryOutputStream)
}

// UnsafeMemoryOutputStreamFromGlibBorrow is used to convert raw GMemoryOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMemoryOutputStreamFromGlibBorrow(c unsafe.Pointer) MemoryOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(MemoryOutputStream)
}

func (m *MemoryOutputStreamInstance) upcastToGMemoryOutputStream() *MemoryOutputStreamInstance {
	return m
}

// UnsafeMemoryOutputStreamToGlibNone is used to convert the instance to it's C value GMemoryOutputStream. This is used by the bindings internally.
func UnsafeMemoryOutputStreamToGlibNone(c MemoryOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMemoryOutputStreamToGlibFull is used to convert the instance to it's C value GMemoryOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamToGlibFull(c MemoryOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMemoryOutputStreamResizable wraps g_memory_output_stream_new_resizable
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Creates a new #GMemoryOutputStream, using g_realloc() and g_free()
// for memory allocation.
func NewMemoryOutputStreamResizable() OutputStream {
	var cret *C.GOutputStream // return, full, converted

	cret = C.g_memory_output_stream_new_resizable()

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDataSize wraps g_memory_output_stream_get_data_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the number of bytes from the start up to including the last
// byte written in the stream that has not been truncated away.
func (ostream *MemoryOutputStreamInstance) GetDataSize() uint {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  C.gsize                // return, none, casted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_get_data_size(carg0)
	runtime.KeepAlive(ostream)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetSize wraps g_memory_output_stream_get_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the size of the currently allocated data area (available from
// g_memory_output_stream_get_data()).
// 
// You probably don't want to use this function on resizable streams.
// See g_memory_output_stream_get_data_size() instead.  For resizable
// streams the size returned by this function is an implementation
// detail and may be change at any time in response to operations on the
// stream.
// 
// If the stream is fixed-sized (ie: no realloc was passed to
// g_memory_output_stream_new()) then this is the maximum size of the
// stream and further writes will return %G_IO_ERROR_NO_SPACE.
// 
// In any case, if you want the number of bytes currently written to the
// stream, use g_memory_output_stream_get_data_size().
func (ostream *MemoryOutputStreamInstance) GetSize() uint {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  C.gsize                // return, none, casted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_get_size(carg0)
	runtime.KeepAlive(ostream)

	var goret uint

	goret = uint(cret)

	return goret
}

// StealAsBytes wraps g_memory_output_stream_steal_as_bytes
// 
// The function returns the following values:
// 
// 	- goret *glib.Bytes 
//
// Returns data from the @ostream as a #GBytes. @ostream must be
// closed before calling this function.
func (ostream *MemoryOutputStreamInstance) StealAsBytes() *glib.Bytes {
	var carg0 *C.GMemoryOutputStream // in, none, converted
	var cret  *C.GBytes              // return, full, converted

	carg0 = (*C.GMemoryOutputStream)(UnsafeMemoryOutputStreamToGlibNone(ostream))

	cret = C.g_memory_output_stream_steal_as_bytes(carg0)
	runtime.KeepAlive(ostream)

	var goret *glib.Bytes

	goret = glib.UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// MemoryOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type MemoryOutputStreamOverrides[Instance MemoryOutputStream] struct {
	// OutputStreamOverrides allows you to override virtual methods from the parent class OutputStream
	OutputStreamOverrides[Instance]

}

// UnsafeApplyMemoryOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyMemoryOutputStreamOverrides[Instance MemoryOutputStream](gclass unsafe.Pointer, overrides MemoryOutputStreamOverrides[Instance]) {
	UnsafeApplyOutputStreamOverrides(gclass, overrides.OutputStreamOverrides)
}

// RegisterMemoryOutputStreamSubClass is used to register a go subclass of GMemoryOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterMemoryOutputStreamSubClass[InstanceT MemoryOutputStream](
		name string,
		classInit func(class *MemoryOutputStreamClass),
		constructor func() InstanceT,
		overrides MemoryOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeMemoryOutputStream,
		UnsafeMemoryOutputStreamClassFromGlibBorrow,
		UnsafeApplyMemoryOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMemoryOutputStream(obj)
		},
		interfaceInits...,
	)
}

// MenuInstance is the instance type used by all types extending GMenu. It is used internally by the bindings. Users should use the interface [Menu] instead.
type MenuInstance struct {
	_ [0]func() // equal guard
	MenuModelInstance
}

var _ Menu = (*MenuInstance)(nil)

// Menu wraps GMenu
//
// `GMenu` is a simple implementation of [class@Gio.MenuModel].
// You populate a `GMenu` by adding [class@Gio.MenuItem] instances to it.
// 
// There are some convenience functions to allow you to directly
// add items (avoiding [class@Gio.MenuItem]) for the common cases. To add
// a regular item, use [method@Gio.Menu.insert]. To add a section, use
// [method@Gio.Menu.insert_section]. To add a submenu, use
// [method@Gio.Menu.insert_submenu].
type Menu interface {
	MenuModel
	upcastToGMenu() *MenuInstance

	// Append wraps g_menu_append
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- detailedAction string (nullable): the detailed action string, or %NULL 
	//
	// Convenience function for appending a normal menu item to the end of
	// @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Append(string, string)
	// AppendItem wraps g_menu_append_item
	// 
	// The function takes the following parameters:
	// 
	// 	- item MenuItem: a #GMenuItem to append 
	//
	// Appends @item to the end of @menu.
	// 
	// See g_menu_insert_item() for more information.
	AppendItem(MenuItem)
	// AppendSection wraps g_menu_append_section
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- section MenuModel: a #GMenuModel with the items of the section 
	//
	// Convenience function for appending a section menu item to the end of
	// @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
	// more flexible alternative.
	AppendSection(string, MenuModel)
	// AppendSubmenu wraps g_menu_append_submenu
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
	//
	// Convenience function for appending a submenu menu item to the end of
	// @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
	// more flexible alternative.
	AppendSubmenu(string, MenuModel)
	// Freeze wraps g_menu_freeze
	//
	// Marks @menu as frozen.
	// 
	// After the menu is frozen, it is an error to attempt to make any
	// changes to it.  In effect this means that the #GMenu API must no
	// longer be used.
	// 
	// This function causes g_menu_model_is_mutable() to begin returning
	// %FALSE, which has some positive performance implications.
	Freeze()
	// Insert wraps g_menu_insert
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position at which to insert the item 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- detailedAction string (nullable): the detailed action string, or %NULL 
	//
	// Convenience function for inserting a normal menu item into @menu.
	// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
	// alternative.
	Insert(int32, string, string)
	// InsertItem wraps g_menu_insert_item
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position at which to insert the item 
	// 	- item MenuItem: the #GMenuItem to insert 
	//
	// Inserts @item into @menu.
	// 
	// The "insertion" is actually done by copying all of the attribute and
	// link values of @item and using them to form a new item within @menu.
	// As such, @item itself is not really inserted, but rather, a menu item
	// that is exactly the same as the one presently described by @item.
	// 
	// This means that @item is essentially useless after the insertion
	// occurs.  Any changes you make to it are ignored unless it is inserted
	// again (at which point its updated values will be copied).
	// 
	// You should probably just free @item once you're done.
	// 
	// There are many convenience functions to take care of common cases.
	// See g_menu_insert(), g_menu_insert_section() and
	// g_menu_insert_submenu() as well as "prepend" and "append" variants of
	// each of these functions.
	InsertItem(int32, MenuItem)
	// InsertSection wraps g_menu_insert_section
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position at which to insert the item 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- section MenuModel: a #GMenuModel with the items of the section 
	//
	// Convenience function for inserting a section menu item into @menu.
	// Combine g_menu_item_new_section() and g_menu_insert_item() for a more
	// flexible alternative.
	InsertSection(int32, string, MenuModel)
	// InsertSubmenu wraps g_menu_insert_submenu
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position at which to insert the item 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
	//
	// Convenience function for inserting a submenu menu item into @menu.
	// Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
	// flexible alternative.
	InsertSubmenu(int32, string, MenuModel)
	// Prepend wraps g_menu_prepend
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- detailedAction string (nullable): the detailed action string, or %NULL 
	//
	// Convenience function for prepending a normal menu item to the start
	// of @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
	// flexible alternative.
	Prepend(string, string)
	// PrependItem wraps g_menu_prepend_item
	// 
	// The function takes the following parameters:
	// 
	// 	- item MenuItem: a #GMenuItem to prepend 
	//
	// Prepends @item to the start of @menu.
	// 
	// See g_menu_insert_item() for more information.
	PrependItem(MenuItem)
	// PrependSection wraps g_menu_prepend_section
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- section MenuModel: a #GMenuModel with the items of the section 
	//
	// Convenience function for prepending a section menu item to the start
	// of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
	// a more flexible alternative.
	PrependSection(string, MenuModel)
	// PrependSubmenu wraps g_menu_prepend_submenu
	// 
	// The function takes the following parameters:
	// 
	// 	- label string (nullable): the section label, or %NULL 
	// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
	//
	// Convenience function for prepending a submenu menu item to the start
	// of @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
	// a more flexible alternative.
	PrependSubmenu(string, MenuModel)
	// Remove wraps g_menu_remove
	// 
	// The function takes the following parameters:
	// 
	// 	- position int32: the position of the item to remove 
	//
	// Removes an item from the menu.
	// 
	// @position gives the index of the item to remove.
	// 
	// It is an error if position is not in range the range from 0 to one
	// less than the number of items in the menu.
	// 
	// It is not possible to remove items by identity since items are added
	// to the menu simply by copying their links and attributes (ie:
	// identity of the item itself is not preserved).
	Remove(int32)
	// RemoveAll wraps g_menu_remove_all
	//
	// Removes all items in the menu.
	RemoveAll()
}

func unsafeWrapMenu(base *gobject.ObjectInstance) *MenuInstance {
	return &MenuInstance{
		MenuModelInstance: MenuModelInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeMenu,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapMenu(inst)
		},
	)
}

func marshalMenuInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeMenuFromGlibNone is used to convert raw GMenu pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuFromGlibNone(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibNone(c).(Menu)
}

// UnsafeMenuFromGlibFull is used to convert raw GMenu pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeMenuFromGlibFull(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibFull(c).(Menu)
}

// UnsafeMenuFromGlibBorrow is used to convert raw GMenu pointers to go without touching any references. This is used by the bindings internally.
func UnsafeMenuFromGlibBorrow(c unsafe.Pointer) Menu {
	return gobject.UnsafeObjectFromGlibBorrow(c).(Menu)
}

func (m *MenuInstance) upcastToGMenu() *MenuInstance {
	return m
}

// UnsafeMenuToGlibNone is used to convert the instance to it's C value GMenu. This is used by the bindings internally.
func UnsafeMenuToGlibNone(c Menu) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeMenuToGlibFull is used to convert the instance to it's C value GMenu, while removeing the finalizer. This is used by the bindings internally.
func UnsafeMenuToGlibFull(c Menu) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewMenu wraps g_menu_new
// 
// The function returns the following values:
// 
// 	- goret Menu 
//
// Creates a new #GMenu.
// 
// The new menu has no items.
func NewMenu() Menu {
	var cret *C.GMenu // return, full, converted

	cret = C.g_menu_new()

	var goret Menu

	goret = UnsafeMenuFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Append wraps g_menu_append
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- detailedAction string (nullable): the detailed action string, or %NULL 
//
// Convenience function for appending a normal menu item to the end of
// @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *MenuInstance) Append(label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_menu_append(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// AppendItem wraps g_menu_append_item
// 
// The function takes the following parameters:
// 
// 	- item MenuItem: a #GMenuItem to append 
//
// Appends @item to the end of @menu.
// 
// See g_menu_insert_item() for more information.
func (menu *MenuInstance) AppendItem(item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_append_item(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// AppendSection wraps g_menu_append_section
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- section MenuModel: a #GMenuModel with the items of the section 
//
// Convenience function for appending a section menu item to the end of
// @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for a
// more flexible alternative.
func (menu *MenuInstance) AppendSection(label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_append_section(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// AppendSubmenu wraps g_menu_append_submenu
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
//
// Convenience function for appending a submenu menu item to the end of
// @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for a
// more flexible alternative.
func (menu *MenuInstance) AppendSubmenu(label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_append_submenu(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Freeze wraps g_menu_freeze
//
// Marks @menu as frozen.
// 
// After the menu is frozen, it is an error to attempt to make any
// changes to it.  In effect this means that the #GMenu API must no
// longer be used.
// 
// This function causes g_menu_model_is_mutable() to begin returning
// %FALSE, which has some positive performance implications.
func (menu *MenuInstance) Freeze() {
	var carg0 *C.GMenu // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))

	C.g_menu_freeze(carg0)
	runtime.KeepAlive(menu)
}

// Insert wraps g_menu_insert
// 
// The function takes the following parameters:
// 
// 	- position int32: the position at which to insert the item 
// 	- label string (nullable): the section label, or %NULL 
// 	- detailedAction string (nullable): the detailed action string, or %NULL 
//
// Convenience function for inserting a normal menu item into @menu.
// Combine g_menu_item_new() and g_menu_insert_item() for a more flexible
// alternative.
func (menu *MenuInstance) Insert(position int32, label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 C.gint   // in, none, casted
	var carg2 *C.gchar // in, none, string, nullable-string
	var carg3 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if detailedAction != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg3))
	}

	C.g_menu_insert(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// InsertItem wraps g_menu_insert_item
// 
// The function takes the following parameters:
// 
// 	- position int32: the position at which to insert the item 
// 	- item MenuItem: the #GMenuItem to insert 
//
// Inserts @item into @menu.
// 
// The "insertion" is actually done by copying all of the attribute and
// link values of @item and using them to form a new item within @menu.
// As such, @item itself is not really inserted, but rather, a menu item
// that is exactly the same as the one presently described by @item.
// 
// This means that @item is essentially useless after the insertion
// occurs.  Any changes you make to it are ignored unless it is inserted
// again (at which point its updated values will be copied).
// 
// You should probably just free @item once you're done.
// 
// There are many convenience functions to take care of common cases.
// See g_menu_insert(), g_menu_insert_section() and
// g_menu_insert_submenu() as well as "prepend" and "append" variants of
// each of these functions.
func (menu *MenuInstance) InsertItem(position int32, item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 C.gint       // in, none, casted
	var carg2 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	carg2 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_insert_item(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(item)
}

// InsertSection wraps g_menu_insert_section
// 
// The function takes the following parameters:
// 
// 	- position int32: the position at which to insert the item 
// 	- label string (nullable): the section label, or %NULL 
// 	- section MenuModel: a #GMenuModel with the items of the section 
//
// Convenience function for inserting a section menu item into @menu.
// Combine g_menu_item_new_section() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *MenuInstance) InsertSection(position int32, label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_insert_section(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// InsertSubmenu wraps g_menu_insert_submenu
// 
// The function takes the following parameters:
// 
// 	- position int32: the position at which to insert the item 
// 	- label string (nullable): the section label, or %NULL 
// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
//
// Convenience function for inserting a submenu menu item into @menu.
// Combine g_menu_item_new_submenu() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *MenuInstance) InsertSubmenu(position int32, label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)
	if label != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_insert_submenu(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Prepend wraps g_menu_prepend
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- detailedAction string (nullable): the detailed action string, or %NULL 
//
// Convenience function for prepending a normal menu item to the start
// of @menu.  Combine g_menu_item_new() and g_menu_insert_item() for a more
// flexible alternative.
func (menu *MenuInstance) Prepend(label string, detailedAction string) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string, nullable-string

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if detailedAction != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(detailedAction)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_menu_prepend(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(detailedAction)
}

// PrependItem wraps g_menu_prepend_item
// 
// The function takes the following parameters:
// 
// 	- item MenuItem: a #GMenuItem to prepend 
//
// Prepends @item to the start of @menu.
// 
// See g_menu_insert_item() for more information.
func (menu *MenuInstance) PrependItem(item MenuItem) {
	var carg0 *C.GMenu     // in, none, converted
	var carg1 *C.GMenuItem // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = (*C.GMenuItem)(UnsafeMenuItemToGlibNone(item))

	C.g_menu_prepend_item(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(item)
}

// PrependSection wraps g_menu_prepend_section
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- section MenuModel: a #GMenuModel with the items of the section 
//
// Convenience function for prepending a section menu item to the start
// of @menu.  Combine g_menu_item_new_section() and g_menu_insert_item() for
// a more flexible alternative.
func (menu *MenuInstance) PrependSection(label string, section MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(section))

	C.g_menu_prepend_section(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(section)
}

// PrependSubmenu wraps g_menu_prepend_submenu
// 
// The function takes the following parameters:
// 
// 	- label string (nullable): the section label, or %NULL 
// 	- submenu MenuModel: a #GMenuModel with the items of the submenu 
//
// Convenience function for prepending a submenu menu item to the start
// of @menu.  Combine g_menu_item_new_submenu() and g_menu_insert_item() for
// a more flexible alternative.
func (menu *MenuInstance) PrependSubmenu(label string, submenu MenuModel) {
	var carg0 *C.GMenu      // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 *C.GMenuModel // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	if label != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.GMenuModel)(UnsafeMenuModelToGlibNone(submenu))

	C.g_menu_prepend_submenu(carg0, carg1, carg2)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(label)
	runtime.KeepAlive(submenu)
}

// Remove wraps g_menu_remove
// 
// The function takes the following parameters:
// 
// 	- position int32: the position of the item to remove 
//
// Removes an item from the menu.
// 
// @position gives the index of the item to remove.
// 
// It is an error if position is not in range the range from 0 to one
// less than the number of items in the menu.
// 
// It is not possible to remove items by identity since items are added
// to the menu simply by copying their links and attributes (ie:
// identity of the item itself is not preserved).
func (menu *MenuInstance) Remove(position int32) {
	var carg0 *C.GMenu // in, none, converted
	var carg1 C.gint   // in, none, casted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))
	carg1 = C.gint(position)

	C.g_menu_remove(carg0, carg1)
	runtime.KeepAlive(menu)
	runtime.KeepAlive(position)
}

// RemoveAll wraps g_menu_remove_all
//
// Removes all items in the menu.
func (menu *MenuInstance) RemoveAll() {
	var carg0 *C.GMenu // in, none, converted

	carg0 = (*C.GMenu)(UnsafeMenuToGlibNone(menu))

	C.g_menu_remove_all(carg0)
	runtime.KeepAlive(menu)
}

// NativeSocketAddressInstance is the instance type used by all types extending GNativeSocketAddress. It is used internally by the bindings. Users should use the interface [NativeSocketAddress] instead.
type NativeSocketAddressInstance struct {
	_ [0]func() // equal guard
	SocketAddressInstance
	// implemented interfaces:
	SocketConnectableInstance
}

var _ NativeSocketAddress = (*NativeSocketAddressInstance)(nil)

// NativeSocketAddress wraps GNativeSocketAddress
//
// A socket address of some unknown native type.
// 
// This corresponds to a general `struct sockaddr` of a type not otherwise
// handled by GLib.
type NativeSocketAddress interface {
	SocketAddress
	SocketConnectable
	upcastToGNativeSocketAddress() *NativeSocketAddressInstance

	// chain up virtual methods:
}

func unsafeWrapNativeSocketAddress(base *gobject.ObjectInstance) *NativeSocketAddressInstance {
	return &NativeSocketAddressInstance{
		SocketAddressInstance: SocketAddressInstance{
			ObjectInstance: *base,
		},
		SocketConnectableInstance: SocketConnectableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNativeSocketAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeSocketAddress(inst)
		},
	)
}

func marshalNativeSocketAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNativeSocketAddressFromGlibNone is used to convert raw GNativeSocketAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibNone(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(NativeSocketAddress)
}

// UnsafeNativeSocketAddressFromGlibFull is used to convert raw GNativeSocketAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibFull(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(NativeSocketAddress)
}

// UnsafeNativeSocketAddressFromGlibBorrow is used to convert raw GNativeSocketAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNativeSocketAddressFromGlibBorrow(c unsafe.Pointer) NativeSocketAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NativeSocketAddress)
}

func (n *NativeSocketAddressInstance) upcastToGNativeSocketAddress() *NativeSocketAddressInstance {
	return n
}

// UnsafeNativeSocketAddressToGlibNone is used to convert the instance to it's C value GNativeSocketAddress. This is used by the bindings internally.
func UnsafeNativeSocketAddressToGlibNone(c NativeSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNativeSocketAddressToGlibFull is used to convert the instance to it's C value GNativeSocketAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNativeSocketAddressToGlibFull(c NativeSocketAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NativeSocketAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NativeSocketAddressOverrides[Instance NativeSocketAddress] struct {
	// SocketAddressOverrides allows you to override virtual methods from the parent class SocketAddress
	SocketAddressOverrides[Instance]

}

// UnsafeApplyNativeSocketAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNativeSocketAddressOverrides[Instance NativeSocketAddress](gclass unsafe.Pointer, overrides NativeSocketAddressOverrides[Instance]) {
	UnsafeApplySocketAddressOverrides(gclass, overrides.SocketAddressOverrides)
}

// RegisterNativeSocketAddressSubClass is used to register a go subclass of GNativeSocketAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNativeSocketAddressSubClass[InstanceT NativeSocketAddress](
		name string,
		classInit func(class *NativeSocketAddressClass),
		constructor func() InstanceT,
		overrides NativeSocketAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNativeSocketAddress,
		UnsafeNativeSocketAddressClassFromGlibBorrow,
		UnsafeApplyNativeSocketAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeSocketAddress(obj)
		},
		interfaceInits...,
	)
}

// NativeVolumeMonitorInstance is the instance type used by all types extending GNativeVolumeMonitor. It is used internally by the bindings. Users should use the interface [NativeVolumeMonitor] instead.
type NativeVolumeMonitorInstance struct {
	_ [0]func() // equal guard
	VolumeMonitorInstance
}

var _ NativeVolumeMonitor = (*NativeVolumeMonitorInstance)(nil)

// NativeVolumeMonitor wraps GNativeVolumeMonitor
type NativeVolumeMonitor interface {
	VolumeMonitor
	upcastToGNativeVolumeMonitor() *NativeVolumeMonitorInstance

	// chain up virtual methods:
}

func unsafeWrapNativeVolumeMonitor(base *gobject.ObjectInstance) *NativeVolumeMonitorInstance {
	return &NativeVolumeMonitorInstance{
		VolumeMonitorInstance: VolumeMonitorInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeNativeVolumeMonitor,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeVolumeMonitor(inst)
		},
	)
}

func marshalNativeVolumeMonitorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeNativeVolumeMonitorFromGlibNone is used to convert raw GNativeVolumeMonitor pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibNone(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibNone(c).(NativeVolumeMonitor)
}

// UnsafeNativeVolumeMonitorFromGlibFull is used to convert raw GNativeVolumeMonitor pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibFull(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibFull(c).(NativeVolumeMonitor)
}

// UnsafeNativeVolumeMonitorFromGlibBorrow is used to convert raw GNativeVolumeMonitor pointers to go without touching any references. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorFromGlibBorrow(c unsafe.Pointer) NativeVolumeMonitor {
	return gobject.UnsafeObjectFromGlibBorrow(c).(NativeVolumeMonitor)
}

func (n *NativeVolumeMonitorInstance) upcastToGNativeVolumeMonitor() *NativeVolumeMonitorInstance {
	return n
}

// UnsafeNativeVolumeMonitorToGlibNone is used to convert the instance to it's C value GNativeVolumeMonitor. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorToGlibNone(c NativeVolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeNativeVolumeMonitorToGlibFull is used to convert the instance to it's C value GNativeVolumeMonitor, while removeing the finalizer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorToGlibFull(c NativeVolumeMonitor) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NativeVolumeMonitorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type NativeVolumeMonitorOverrides[Instance NativeVolumeMonitor] struct {
	// VolumeMonitorOverrides allows you to override virtual methods from the parent class VolumeMonitor
	VolumeMonitorOverrides[Instance]

}

// UnsafeApplyNativeVolumeMonitorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyNativeVolumeMonitorOverrides[Instance NativeVolumeMonitor](gclass unsafe.Pointer, overrides NativeVolumeMonitorOverrides[Instance]) {
	UnsafeApplyVolumeMonitorOverrides(gclass, overrides.VolumeMonitorOverrides)
}

// RegisterNativeVolumeMonitorSubClass is used to register a go subclass of GNativeVolumeMonitor. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterNativeVolumeMonitorSubClass[InstanceT NativeVolumeMonitor](
		name string,
		classInit func(class *NativeVolumeMonitorClass),
		constructor func() InstanceT,
		overrides NativeVolumeMonitorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeNativeVolumeMonitor,
		UnsafeNativeVolumeMonitorClassFromGlibBorrow,
		UnsafeApplyNativeVolumeMonitorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapNativeVolumeMonitor(obj)
		},
		interfaceInits...,
	)
}

// ProxyAddressInstance is the instance type used by all types extending GProxyAddress. It is used internally by the bindings. Users should use the interface [ProxyAddress] instead.
type ProxyAddressInstance struct {
	_ [0]func() // equal guard
	InetSocketAddressInstance
}

var _ ProxyAddress = (*ProxyAddressInstance)(nil)

// ProxyAddress wraps GProxyAddress
//
// A [class@Gio.InetSocketAddress] representing a connection via a proxy server.
type ProxyAddress interface {
	InetSocketAddress
	upcastToGProxyAddress() *ProxyAddressInstance

	// GetDestinationHostname wraps g_proxy_address_get_destination_hostname
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets @proxy's destination hostname; that is, the name of the host
	// that will be connected to via the proxy, not the name of the proxy
	// itself.
	GetDestinationHostname() string
	// GetDestinationPort wraps g_proxy_address_get_destination_port
	// 
	// The function returns the following values:
	// 
	// 	- goret uint16 
	//
	// Gets @proxy's destination port; that is, the port on the
	// destination host that will be connected to via the proxy, not the
	// port number of the proxy itself.
	GetDestinationPort() uint16
	// GetDestinationProtocol wraps g_proxy_address_get_destination_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets the protocol that is being spoken to the destination
	// server; eg, "http" or "ftp".
	GetDestinationProtocol() string
	// GetPassword wraps g_proxy_address_get_password
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets @proxy's password.
	GetPassword() string
	// GetProtocol wraps g_proxy_address_get_protocol
	// 
	// The function returns the following values:
	// 
	// 	- goret string 
	//
	// Gets @proxy's protocol. eg, "socks" or "http"
	GetProtocol() string
	// GetURI wraps g_proxy_address_get_uri
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets the proxy URI that @proxy was constructed from.
	GetURI() string
	// GetUsername wraps g_proxy_address_get_username
	// 
	// The function returns the following values:
	// 
	// 	- goret string (nullable) 
	//
	// Gets @proxy's username.
	GetUsername() string

	// chain up virtual methods:
}

func unsafeWrapProxyAddress(base *gobject.ObjectInstance) *ProxyAddressInstance {
	return &ProxyAddressInstance{
		InetSocketAddressInstance: InetSocketAddressInstance{
			SocketAddressInstance: SocketAddressInstance{
				ObjectInstance: *base,
			},
			SocketConnectableInstance: SocketConnectableInstance{
				Instance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeProxyAddress,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddress(inst)
		},
	)
}

func marshalProxyAddressInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeProxyAddressFromGlibNone is used to convert raw GProxyAddress pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibNone(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyAddress)
}

// UnsafeProxyAddressFromGlibFull is used to convert raw GProxyAddress pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibFull(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyAddress)
}

// UnsafeProxyAddressFromGlibBorrow is used to convert raw GProxyAddress pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyAddressFromGlibBorrow(c unsafe.Pointer) ProxyAddress {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyAddress)
}

func (p *ProxyAddressInstance) upcastToGProxyAddress() *ProxyAddressInstance {
	return p
}

// UnsafeProxyAddressToGlibNone is used to convert the instance to it's C value GProxyAddress. This is used by the bindings internally.
func UnsafeProxyAddressToGlibNone(c ProxyAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeProxyAddressToGlibFull is used to convert the instance to it's C value GProxyAddress, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyAddressToGlibFull(c ProxyAddress) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewProxyAddress wraps g_proxy_address_new
// 
// The function takes the following parameters:
// 
// 	- inetaddr InetAddress: The proxy server #GInetAddress. 
// 	- port uint16: The proxy server port. 
// 	- protocol string: The proxy protocol to support, in lower case (e.g. socks, http). 
// 	- destHostname string: The destination hostname the proxy should tunnel to. 
// 	- destPort uint16: The destination port to tunnel to. 
// 	- username string (nullable): The username to authenticate to the proxy server
//     (or %NULL). 
// 	- password string (nullable): The password to authenticate to the proxy server
//     (or %NULL). 
// 
// The function returns the following values:
// 
// 	- goret SocketAddress 
//
// Creates a new #GProxyAddress for @inetaddr with @protocol that should
// tunnel through @dest_hostname and @dest_port.
// 
// (Note that this method doesn't set the #GProxyAddress:uri or
// #GProxyAddress:destination-protocol fields; use g_object_new()
// directly if you want to set those.)
func NewProxyAddress(inetaddr InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) SocketAddress {
	var carg1 *C.GInetAddress   // in, none, converted
	var carg2 C.guint16         // in, none, casted
	var carg3 *C.gchar          // in, none, string
	var carg4 *C.gchar          // in, none, string
	var carg5 C.guint16         // in, none, casted
	var carg6 *C.gchar          // in, none, string, nullable-string
	var carg7 *C.gchar          // in, none, string, nullable-string
	var cret  *C.GSocketAddress // return, full, converted

	carg1 = (*C.GInetAddress)(UnsafeInetAddressToGlibNone(inetaddr))
	carg2 = C.guint16(port)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(destHostname)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.guint16(destPort)
	if username != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(username)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if password != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg7))
	}

	cret = C.g_proxy_address_new(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(inetaddr)
	runtime.KeepAlive(port)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(destHostname)
	runtime.KeepAlive(destPort)
	runtime.KeepAlive(username)
	runtime.KeepAlive(password)

	var goret SocketAddress

	goret = UnsafeSocketAddressFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetDestinationHostname wraps g_proxy_address_get_destination_hostname
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @proxy's destination hostname; that is, the name of the host
// that will be connected to via the proxy, not the name of the proxy
// itself.
func (proxy *ProxyAddressInstance) GetDestinationHostname() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_hostname(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetDestinationPort wraps g_proxy_address_get_destination_port
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @proxy's destination port; that is, the port on the
// destination host that will be connected to via the proxy, not the
// port number of the proxy itself.
func (proxy *ProxyAddressInstance) GetDestinationPort() uint16 {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  C.guint16        // return, none, casted

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_port(carg0)
	runtime.KeepAlive(proxy)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetDestinationProtocol wraps g_proxy_address_get_destination_protocol
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the protocol that is being spoken to the destination
// server; eg, "http" or "ftp".
func (proxy *ProxyAddressInstance) GetDestinationProtocol() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_destination_protocol(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPassword wraps g_proxy_address_get_password
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @proxy's password.
func (proxy *ProxyAddressInstance) GetPassword() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_password(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetProtocol wraps g_proxy_address_get_protocol
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @proxy's protocol. eg, "socks" or "http"
func (proxy *ProxyAddressInstance) GetProtocol() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_protocol(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetURI wraps g_proxy_address_get_uri
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the proxy URI that @proxy was constructed from.
func (proxy *ProxyAddressInstance) GetURI() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_uri(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUsername wraps g_proxy_address_get_username
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @proxy's username.
func (proxy *ProxyAddressInstance) GetUsername() string {
	var carg0 *C.GProxyAddress // in, none, converted
	var cret  *C.gchar         // return, none, string, nullable-string

	carg0 = (*C.GProxyAddress)(UnsafeProxyAddressToGlibNone(proxy))

	cret = C.g_proxy_address_get_username(carg0)
	runtime.KeepAlive(proxy)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ProxyAddressOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ProxyAddressOverrides[Instance ProxyAddress] struct {
	// InetSocketAddressOverrides allows you to override virtual methods from the parent class InetSocketAddress
	InetSocketAddressOverrides[Instance]

}

// UnsafeApplyProxyAddressOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyProxyAddressOverrides[Instance ProxyAddress](gclass unsafe.Pointer, overrides ProxyAddressOverrides[Instance]) {
	UnsafeApplyInetSocketAddressOverrides(gclass, overrides.InetSocketAddressOverrides)
}

// RegisterProxyAddressSubClass is used to register a go subclass of GProxyAddress. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterProxyAddressSubClass[InstanceT ProxyAddress](
		name string,
		classInit func(class *ProxyAddressClass),
		constructor func() InstanceT,
		overrides ProxyAddressOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeProxyAddress,
		UnsafeProxyAddressClassFromGlibBorrow,
		UnsafeApplyProxyAddressOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddress(obj)
		},
		interfaceInits...,
	)
}

// ProxyAddressEnumeratorInstance is the instance type used by all types extending GProxyAddressEnumerator. It is used internally by the bindings. Users should use the interface [ProxyAddressEnumerator] instead.
type ProxyAddressEnumeratorInstance struct {
	_ [0]func() // equal guard
	SocketAddressEnumeratorInstance
}

var _ ProxyAddressEnumerator = (*ProxyAddressEnumeratorInstance)(nil)

// ProxyAddressEnumerator wraps GProxyAddressEnumerator
//
// `GProxyAddressEnumerator` is a wrapper around
// [class@Gio.SocketAddressEnumerator] which takes the [class@Gio.SocketAddress]
// instances returned by the [class@Gio.SocketAddressEnumerator]
// and wraps them in [class@Gio.ProxyAddress] instances, using the given
// [property@Gio.ProxyAddressEnumerator:proxy-resolver].
// 
// This enumerator will be returned (for example, by
// [method@Gio.SocketConnectable.enumerate]) as appropriate when a proxy is
// configured; there should be no need to manually wrap a
// [class@Gio.SocketAddressEnumerator] instance with one.
type ProxyAddressEnumerator interface {
	SocketAddressEnumerator
	upcastToGProxyAddressEnumerator() *ProxyAddressEnumeratorInstance

	// chain up virtual methods:
}

func unsafeWrapProxyAddressEnumerator(base *gobject.ObjectInstance) *ProxyAddressEnumeratorInstance {
	return &ProxyAddressEnumeratorInstance{
		SocketAddressEnumeratorInstance: SocketAddressEnumeratorInstance{
			ObjectInstance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeProxyAddressEnumerator,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddressEnumerator(inst)
		},
	)
}

func marshalProxyAddressEnumeratorInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeProxyAddressEnumeratorFromGlibNone is used to convert raw GProxyAddressEnumerator pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibNone(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibNone(c).(ProxyAddressEnumerator)
}

// UnsafeProxyAddressEnumeratorFromGlibFull is used to convert raw GProxyAddressEnumerator pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibFull(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibFull(c).(ProxyAddressEnumerator)
}

// UnsafeProxyAddressEnumeratorFromGlibBorrow is used to convert raw GProxyAddressEnumerator pointers to go without touching any references. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorFromGlibBorrow(c unsafe.Pointer) ProxyAddressEnumerator {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ProxyAddressEnumerator)
}

func (p *ProxyAddressEnumeratorInstance) upcastToGProxyAddressEnumerator() *ProxyAddressEnumeratorInstance {
	return p
}

// UnsafeProxyAddressEnumeratorToGlibNone is used to convert the instance to it's C value GProxyAddressEnumerator. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorToGlibNone(c ProxyAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeProxyAddressEnumeratorToGlibFull is used to convert the instance to it's C value GProxyAddressEnumerator, while removeing the finalizer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorToGlibFull(c ProxyAddressEnumerator) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// ProxyAddressEnumeratorOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ProxyAddressEnumeratorOverrides[Instance ProxyAddressEnumerator] struct {
	// SocketAddressEnumeratorOverrides allows you to override virtual methods from the parent class SocketAddressEnumerator
	SocketAddressEnumeratorOverrides[Instance]

}

// UnsafeApplyProxyAddressEnumeratorOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyProxyAddressEnumeratorOverrides[Instance ProxyAddressEnumerator](gclass unsafe.Pointer, overrides ProxyAddressEnumeratorOverrides[Instance]) {
	UnsafeApplySocketAddressEnumeratorOverrides(gclass, overrides.SocketAddressEnumeratorOverrides)
}

// RegisterProxyAddressEnumeratorSubClass is used to register a go subclass of GProxyAddressEnumerator. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterProxyAddressEnumeratorSubClass[InstanceT ProxyAddressEnumerator](
		name string,
		classInit func(class *ProxyAddressEnumeratorClass),
		constructor func() InstanceT,
		overrides ProxyAddressEnumeratorOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeProxyAddressEnumerator,
		UnsafeProxyAddressEnumeratorClassFromGlibBorrow,
		UnsafeApplyProxyAddressEnumeratorOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapProxyAddressEnumerator(obj)
		},
		interfaceInits...,
	)
}

// BufferedInputStreamInstance is the instance type used by all types extending GBufferedInputStream. It is used internally by the bindings. Users should use the interface [BufferedInputStream] instead.
type BufferedInputStreamInstance struct {
	_ [0]func() // equal guard
	FilterInputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ BufferedInputStream = (*BufferedInputStreamInstance)(nil)

// BufferedInputStream wraps GBufferedInputStream
//
// Buffered input stream implements [class@Gio.FilterInputStream] and provides
// for buffered reads.
// 
// By default, `GBufferedInputStream`'s buffer size is set at 4 kilobytes.
// 
// To create a buffered input stream, use [ctor@Gio.BufferedInputStream.new],
// or [ctor@Gio.BufferedInputStream.new_sized] to specify the buffer's size at
// construction.
// 
// To get the size of a buffer within a buffered input stream, use
// [method@Gio.BufferedInputStream.get_buffer_size]. To change the size of a
// buffered input stream's buffer, use [method@Gio.BufferedInputStream.set_buffer_size].
// Note that the buffer's size cannot be reduced below the size of the data within the buffer.
type BufferedInputStream interface {
	FilterInputStream
	Seekable
	upcastToGBufferedInputStream() *BufferedInputStreamInstance

	// Fill wraps g_buffered_input_stream_fill
	// 
	// The function takes the following parameters:
	// 
	// 	- count int: the number of bytes that will be read from the stream 
	// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to read @count bytes from the stream into the buffer.
	// Will block during this read.
	// 
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than `G_MAXSSIZE` will cause a
	// [error@Gio.IOErrorEnum.INVALID_ARGUMENT] error.
	// 
	// On success, the number of bytes read into the buffer is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file. Zero is returned on end of file
	// (or if @count is zero),  but never otherwise.
	// 
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	// 
	// If @cancellable is not `NULL`, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
	// If an operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error `-1` is returned and @error is set accordingly.
	// 
	// For the asynchronous, non-blocking, version of this function, see
	// [method@Gio.BufferedInputStream.fill_async].
	Fill(int, Cancellable) (int, error)
	// FillAsync wraps g_buffered_input_stream_fill_async
	// 
	// The function takes the following parameters:
	// 
	// 	- count int: the number of bytes that will be read from the stream 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object 
	// 	- callback AsyncReadyCallback (nullable): a [callback@Gio.AsyncReadyCallback] 
	//
	// Reads data into @stream's buffer asynchronously, up to @count size.
	// @io_priority can be used to prioritize reads. For the synchronous
	// version of this function, see [method@Gio.BufferedInputStream.fill].
	// 
	// If @count is `-1` then the attempted read size is equal to the number
	// of bytes that are required to fill the buffer.
	FillAsync(int, int32, Cancellable, AsyncReadyCallback)
	// FillFinish wraps g_buffered_input_stream_fill_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a [iface@Gio.AsyncResult] 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous read.
	FillFinish(AsyncResult) (int, error)
	// GetAvailable wraps g_buffered_input_stream_get_available
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the size of the available data within the stream.
	GetAvailable() uint
	// GetBufferSize wraps g_buffered_input_stream_get_buffer_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the size of the input buffer.
	GetBufferSize() uint
	// Peek wraps g_buffered_input_stream_peek
	// 
	// The function takes the following parameters:
	// 
	// 	- buffer []byte: a pointer to
	//   an allocated chunk of memory 
	// 	- offset uint: a #gsize 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Peeks in the buffer, copying data of size @count into @buffer,
	// offset @offset bytes.
	Peek([]byte, uint) uint
	// PeekBuffer wraps g_buffered_input_stream_peek_buffer
	// 
	// The function returns the following values:
	// 
	// 	- count uint: a #gsize to get the number of bytes available in the buffer 
	// 	- goret []byte 
	//
	// Returns the buffer with the currently available bytes. The returned
	// buffer must not be modified and will become invalid when reading from
	// the stream or filling the buffer.
	PeekBuffer() (uint, []byte)
	// ReadByte wraps g_buffered_input_stream_read_byte
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to read a single byte from the stream or the buffer. Will block
	// during this read.
	// 
	// On success, the byte read from the stream is returned. On end of stream
	// `-1` is returned but it's not an exceptional error and @error is not set.
	// 
	// If @cancellable is not `NULL`, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
	// If an operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error `-1` is returned and @error is set accordingly.
	ReadByte(Cancellable) (int32, error)
	// SetBufferSize wraps g_buffered_input_stream_set_buffer_size
	// 
	// The function takes the following parameters:
	// 
	// 	- size uint: a #gsize 
	//
	// Sets the size of the internal buffer of @stream to @size, or to the
	// size of the contents of the buffer. The buffer can never be resized
	// smaller than its current contents.
	SetBufferSize(uint)

	// chain up virtual methods:

	// ParentFill calls the default implementations of the `GBufferedInputStream.fill` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- count int: the number of bytes that will be read from the stream 
	// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to read @count bytes from the stream into the buffer.
	// Will block during this read.
	// 
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than `G_MAXSSIZE` will cause a
	// [error@Gio.IOErrorEnum.INVALID_ARGUMENT] error.
	// 
	// On success, the number of bytes read into the buffer is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file. Zero is returned on end of file
	// (or if @count is zero),  but never otherwise.
	// 
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	// 
	// If @cancellable is not `NULL`, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
	// If an operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error `-1` is returned and @error is set accordingly.
	// 
	// For the asynchronous, non-blocking, version of this function, see
	// [method@Gio.BufferedInputStream.fill_async].
	ParentFill(count int, cancellable Cancellable) (int, error)
	// ParentFillFinish calls the default implementations of the `GBufferedInputStream.fill_finish` virtual method.
	// This function's behavior is not defined when the parent does not implement the virtual method.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a [iface@Gio.AsyncResult] 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous read.
	ParentFillFinish(result AsyncResult) (int, error)
}

func unsafeWrapBufferedInputStream(base *gobject.ObjectInstance) *BufferedInputStreamInstance {
	return &BufferedInputStreamInstance{
		FilterInputStreamInstance: FilterInputStreamInstance{
			InputStreamInstance: InputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBufferedInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedInputStream(inst)
		},
	)
}

func marshalBufferedInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBufferedInputStreamFromGlibNone is used to convert raw GBufferedInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibNone(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(BufferedInputStream)
}

// UnsafeBufferedInputStreamFromGlibFull is used to convert raw GBufferedInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibFull(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(BufferedInputStream)
}

// UnsafeBufferedInputStreamFromGlibBorrow is used to convert raw GBufferedInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBufferedInputStreamFromGlibBorrow(c unsafe.Pointer) BufferedInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BufferedInputStream)
}

func (b *BufferedInputStreamInstance) upcastToGBufferedInputStream() *BufferedInputStreamInstance {
	return b
}

// UnsafeBufferedInputStreamToGlibNone is used to convert the instance to it's C value GBufferedInputStream. This is used by the bindings internally.
func UnsafeBufferedInputStreamToGlibNone(c BufferedInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBufferedInputStreamToGlibFull is used to convert the instance to it's C value GBufferedInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBufferedInputStreamToGlibFull(c BufferedInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBufferedInputStream wraps g_buffered_input_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream InputStream: a [class@Gio.InputStream] 
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Creates a new [class@Gio.InputStream] from the given @base_stream, with
// a buffer set to the default size (4 kilobytes).
func NewBufferedInputStream(baseStream InputStream) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))

	cret = C.g_buffered_input_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewBufferedInputStreamSized wraps g_buffered_input_stream_new_sized
// 
// The function takes the following parameters:
// 
// 	- baseStream InputStream: a [class@Gio.InputStream] 
// 	- size uint: a #gsize 
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Creates a new [class@Gio.BufferedInputStream] from the given @base_stream,
// with a buffer set to @size.
func NewBufferedInputStreamSized(baseStream InputStream, size uint) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 C.gsize         // in, none, casted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))
	carg2 = C.gsize(size)

	cret = C.g_buffered_input_stream_new_sized(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Fill wraps g_buffered_input_stream_fill
// 
// The function takes the following parameters:
// 
// 	- count int: the number of bytes that will be read from the stream 
// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to read @count bytes from the stream into the buffer.
// Will block during this read.
// 
// If @count is zero, returns zero and does nothing. A value of @count
// larger than `G_MAXSSIZE` will cause a
// [error@Gio.IOErrorEnum.INVALID_ARGUMENT] error.
// 
// On success, the number of bytes read into the buffer is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file. Zero is returned on end of file
// (or if @count is zero),  but never otherwise.
// 
// If @count is -1 then the attempted read size is equal to the number of
// bytes that are required to fill the buffer.
// 
// If @cancellable is not `NULL`, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
// If an operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error `-1` is returned and @error is set accordingly.
// 
// For the asynchronous, non-blocking, version of this function, see
// [method@Gio.BufferedInputStream.fill_async].
func (stream *BufferedInputStreamInstance) Fill(count int, cancellable Cancellable) (int, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gssize                // in, none, casted
	var carg2 *C.GCancellable         // in, none, converted, nullable
	var cret  C.gssize                // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_buffered_input_stream_fill(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FillAsync wraps g_buffered_input_stream_fill_async
// 
// The function takes the following parameters:
// 
// 	- count int: the number of bytes that will be read from the stream 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object 
// 	- callback AsyncReadyCallback (nullable): a [callback@Gio.AsyncReadyCallback] 
//
// Reads data into @stream's buffer asynchronously, up to @count size.
// @io_priority can be used to prioritize reads. For the synchronous
// version of this function, see [method@Gio.BufferedInputStream.fill].
// 
// If @count is `-1` then the attempted read size is equal to the number
// of bytes that are required to fill the buffer.
func (stream *BufferedInputStreamInstance) FillAsync(count int, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gssize                // in, none, casted
	var carg2 C.int                   // in, none, casted
	var carg3 *C.GCancellable         // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback   // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer              // implicit

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	carg2 = C.int(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_buffered_input_stream_fill_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// FillFinish wraps g_buffered_input_stream_fill_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a [iface@Gio.AsyncResult] 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous read.
func (stream *BufferedInputStreamInstance) FillFinish(result AsyncResult) (int, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 *C.GAsyncResult         // in, none, converted
	var cret  C.gssize                // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_buffered_input_stream_fill_finish(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetAvailable wraps g_buffered_input_stream_get_available
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the size of the available data within the stream.
func (stream *BufferedInputStreamInstance) GetAvailable() uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_get_available(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetBufferSize wraps g_buffered_input_stream_get_buffer_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the size of the input buffer.
func (stream *BufferedInputStreamInstance) GetBufferSize() uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_get_buffer_size(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// Peek wraps g_buffered_input_stream_peek
// 
// The function takes the following parameters:
// 
// 	- buffer []byte: a pointer to
//   an allocated chunk of memory 
// 	- offset uint: a #gsize 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Peeks in the buffer, copying data of size @count into @buffer,
// offset @offset bytes.
func (stream *BufferedInputStreamInstance) Peek(buffer []byte, offset uint) uint {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 unsafe.Pointer          // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg2 C.gsize                 // in, none, casted
	var carg3 C.gsize                 // implicit
	var cret  C.gsize                 // return, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	_ = buffer
	_ = carg1
	_ = carg3
	panic("unimplemented conversion of []byte (void*) because of unimplemented: non-fixed size array")
	carg2 = C.gsize(offset)

	cret = C.g_buffered_input_stream_peek(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)

	var goret uint

	goret = uint(cret)

	return goret
}

// PeekBuffer wraps g_buffered_input_stream_peek_buffer
// 
// The function returns the following values:
// 
// 	- count uint: a #gsize to get the number of bytes available in the buffer 
// 	- goret []byte 
//
// Returns the buffer with the currently available bytes. The returned
// buffer must not be modified and will become invalid when reading from
// the stream or filling the buffer.
func (stream *BufferedInputStreamInstance) PeekBuffer() (uint, []byte) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gsize                 // out, full, casted
	var cret  unsafe.Pointer          // return, transfer: none, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))

	cret = C.g_buffered_input_stream_peek_buffer(carg0, &carg1)
	runtime.KeepAlive(stream)

	var count uint
	var goret []byte

	count = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []byte (void*) because of unknown reason")

	return count, goret
}

// ReadByte wraps g_buffered_input_stream_read_byte
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Tries to read a single byte from the stream or the buffer. Will block
// during this read.
// 
// On success, the byte read from the stream is returned. On end of stream
// `-1` is returned but it's not an exceptional error and @error is not set.
// 
// If @cancellable is not `NULL`, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
// If an operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error `-1` is returned and @error is set accordingly.
func (stream *BufferedInputStreamInstance) ReadByte(cancellable Cancellable) (int32, error) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 *C.GCancellable         // in, none, converted, nullable
	var cret  C.int                   // return, none, casted
	var _cerr *C.GError               // out, full, converted, nullable

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_buffered_input_stream_read_byte(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBufferSize wraps g_buffered_input_stream_set_buffer_size
// 
// The function takes the following parameters:
// 
// 	- size uint: a #gsize 
//
// Sets the size of the internal buffer of @stream to @size, or to the
// size of the contents of the buffer. The buffer can never be resized
// smaller than its current contents.
func (stream *BufferedInputStreamInstance) SetBufferSize(size uint) {
	var carg0 *C.GBufferedInputStream // in, none, converted
	var carg1 C.gsize                 // in, none, casted

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gsize(size)

	C.g_buffered_input_stream_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// BufferedInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type BufferedInputStreamOverrides[Instance BufferedInputStream] struct {
	// FilterInputStreamOverrides allows you to override virtual methods from the parent class FilterInputStream
	FilterInputStreamOverrides[Instance]

	// // Fill allows you to override the implementation of the virtual method fill.
	// 
	// The function takes the following parameters:
	// 
	// 	- count int: the number of bytes that will be read from the stream 
	// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Tries to read @count bytes from the stream into the buffer.
	// Will block during this read.
	// 
	// If @count is zero, returns zero and does nothing. A value of @count
	// larger than `G_MAXSSIZE` will cause a
	// [error@Gio.IOErrorEnum.INVALID_ARGUMENT] error.
	// 
	// On success, the number of bytes read into the buffer is returned.
	// It is not an error if this is not the same as the requested size, as it
	// can happen e.g. near the end of a file. Zero is returned on end of file
	// (or if @count is zero),  but never otherwise.
	// 
	// If @count is -1 then the attempted read size is equal to the number of
	// bytes that are required to fill the buffer.
	// 
	// If @cancellable is not `NULL`, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
	// If an operation was partially finished when the operation was cancelled the
	// partial result will be returned, without an error.
	// 
	// On error `-1` is returned and @error is set accordingly.
	// 
	// For the asynchronous, non-blocking, version of this function, see
	// [method@Gio.BufferedInputStream.fill_async].
	Fill func(Instance, int, Cancellable) (int, error)
	// // FillFinish allows you to override the implementation of the virtual method fill_finish.
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: a [iface@Gio.AsyncResult] 
	// 
	// The function returns the following values:
	// 
	// 	- goret int 
	// 	- _goerr error (nullable): an error 
	//
	// Finishes an asynchronous read.
	FillFinish func(Instance, AsyncResult) (int, error)
}

// UnsafeApplyBufferedInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyBufferedInputStreamOverrides[Instance BufferedInputStream](gclass unsafe.Pointer, overrides BufferedInputStreamOverrides[Instance]) {
	UnsafeApplyFilterInputStreamOverrides(gclass, overrides.FilterInputStreamOverrides)

	pclass := (*C.GBufferedInputStreamClass)(gclass)

	if overrides.Fill != nil {
		pclass.fill = (*[0]byte)(C._goglib_gio2_BufferedInputStream_fill)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_BufferedInputStream_fill",
			func(carg0 *C.GBufferedInputStream, carg1 C.gssize, carg2 *C.GCancellable, _cerr **C.GError) (cret C.gssize) {
				var stream      Instance    // go GBufferedInputStream subclass
				var count       int         // in, none, casted
				var cancellable Cancellable // in, none, converted, nullable
				var goret       int         // return, none, casted
				var _goerr      error       // out, full, converted

				stream = UnsafeBufferedInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				count = int(carg1)
				if carg2 != nil {
					cancellable = UnsafeCancellableFromGlibNone(unsafe.Pointer(carg2))
				}

				goret, _goerr = overrides.Fill(stream, count, cancellable)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}

	if overrides.FillFinish != nil {
		pclass.fill_finish = (*[0]byte)(C._goglib_gio2_BufferedInputStream_fill_finish)
		classdata.StoreVirtualMethod(
			unsafe.Pointer(pclass),
			"_goglib_gio2_BufferedInputStream_fill_finish",
			func(carg0 *C.GBufferedInputStream, carg1 *C.GAsyncResult, _cerr **C.GError) (cret C.gssize) {
				var stream Instance    // go GBufferedInputStream subclass
				var result AsyncResult // in, none, converted
				var goret  int         // return, none, casted
				var _goerr error       // out, full, converted

				stream = UnsafeBufferedInputStreamFromGlibBorrow(unsafe.Pointer(carg0)).UnsafeLoadInstanceFromPrivateData().(Instance)
				result = UnsafeAsyncResultFromGlibNone(unsafe.Pointer(carg1))

				goret, _goerr = overrides.FillFinish(stream, result)

				cret = C.gssize(goret)
				*_cerr = (*C.GError)(glib.UnsafeErrorToGlibFull(_goerr))

				return cret
			},
		)
	}
}

// ParentFill calls the default implementations of the `GBufferedInputStream.fill` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- count int: the number of bytes that will be read from the stream 
// 	- cancellable Cancellable (nullable): optional [class@Gio.Cancellable] object, `NULL` to ignore 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Tries to read @count bytes from the stream into the buffer.
// Will block during this read.
// 
// If @count is zero, returns zero and does nothing. A value of @count
// larger than `G_MAXSSIZE` will cause a
// [error@Gio.IOErrorEnum.INVALID_ARGUMENT] error.
// 
// On success, the number of bytes read into the buffer is returned.
// It is not an error if this is not the same as the requested size, as it
// can happen e.g. near the end of a file. Zero is returned on end of file
// (or if @count is zero),  but never otherwise.
// 
// If @count is -1 then the attempted read size is equal to the number of
// bytes that are required to fill the buffer.
// 
// If @cancellable is not `NULL`, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error [error@Gio.IOErrorEnum.CANCELLED] will be returned.
// If an operation was partially finished when the operation was cancelled the
// partial result will be returned, without an error.
// 
// On error `-1` is returned and @error is set accordingly.
// 
// For the asynchronous, non-blocking, version of this function, see
// [method@Gio.BufferedInputStream.fill_async].
func (stream *BufferedInputStreamInstance) ParentFill(count int, cancellable Cancellable) (int, error) {
	var carg0 *C.GBufferedInputStream
	var carg1 C.gssize        // in, none, converted
	var carg2 *C.GCancellable // in, none, casted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GBufferedInputStreamClass)(classdata.PeekParentClass(UnsafeBufferedInputStreamToGlibNone(stream)))

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = C.gssize(count)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C._goglib_gio2_BufferedInputStream_virtual_fill(unsafe.Pointer(parentclass.fill), carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(count)
	runtime.KeepAlive(cancellable)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ParentFillFinish calls the default implementations of the `GBufferedInputStream.fill_finish` virtual method.
// This function's behavior is not defined when the parent does not implement the virtual method.
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: a [iface@Gio.AsyncResult] 
// 
// The function returns the following values:
// 
// 	- goret int 
// 	- _goerr error (nullable): an error 
//
// Finishes an asynchronous read.
func (stream *BufferedInputStreamInstance) ParentFillFinish(result AsyncResult) (int, error) {
	var carg0 *C.GBufferedInputStream
	var carg1 *C.GAsyncResult // in, none, converted
	var cret  C.gssize        // return, none, casted
	var _cerr *C.GError       // out, full, converted, nullable

	parentclass := (*C.GBufferedInputStreamClass)(classdata.PeekParentClass(UnsafeBufferedInputStreamToGlibNone(stream)))

	carg0 = (*C.GBufferedInputStream)(UnsafeBufferedInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C._goglib_gio2_BufferedInputStream_virtual_fill_finish(unsafe.Pointer(parentclass.fill_finish), carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var goret  int
	var _goerr error

	goret = int(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegisterBufferedInputStreamSubClass is used to register a go subclass of GBufferedInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterBufferedInputStreamSubClass[InstanceT BufferedInputStream](
		name string,
		classInit func(class *BufferedInputStreamClass),
		constructor func() InstanceT,
		overrides BufferedInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeBufferedInputStream,
		UnsafeBufferedInputStreamClassFromGlibBorrow,
		UnsafeApplyBufferedInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedInputStream(obj)
		},
		interfaceInits...,
	)
}

// BufferedOutputStreamInstance is the instance type used by all types extending GBufferedOutputStream. It is used internally by the bindings. Users should use the interface [BufferedOutputStream] instead.
type BufferedOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ BufferedOutputStream = (*BufferedOutputStreamInstance)(nil)

// BufferedOutputStream wraps GBufferedOutputStream
//
// Buffered output stream implements [class@Gio.FilterOutputStream] and provides
// for buffered writes.
// 
// By default, `GBufferedOutputStream`'s buffer size is set at 4 kilobytes.
// 
// To create a buffered output stream, use [ctor@Gio.BufferedOutputStream.new],
// or [ctor@Gio.BufferedOutputStream.new_sized] to specify the buffer's size
// at construction.
// 
// To get the size of a buffer within a buffered input stream, use
// [method@Gio.BufferedOutputStream.get_buffer_size]. To change the size of a
// buffered output stream's buffer, use [method@Gio.BufferedOutputStream.set_buffer_size].
// Note that the buffer's size cannot be reduced below the size of the data within the buffer.
type BufferedOutputStream interface {
	FilterOutputStream
	Seekable
	upcastToGBufferedOutputStream() *BufferedOutputStreamInstance

	// GetAutoGrow wraps g_buffered_output_stream_get_auto_grow
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	//
	// Checks if the buffer automatically grows as data is added.
	GetAutoGrow() bool
	// GetBufferSize wraps g_buffered_output_stream_get_buffer_size
	// 
	// The function returns the following values:
	// 
	// 	- goret uint 
	//
	// Gets the size of the buffer in the @stream.
	GetBufferSize() uint
	// SetAutoGrow wraps g_buffered_output_stream_set_auto_grow
	// 
	// The function takes the following parameters:
	// 
	// 	- autoGrow bool: a #gboolean. 
	//
	// Sets whether or not the @stream's buffer should automatically grow.
	// If @auto_grow is true, then each write will just make the buffer
	// larger, and you must manually flush the buffer to actually write out
	// the data to the underlying stream.
	SetAutoGrow(bool)
	// SetBufferSize wraps g_buffered_output_stream_set_buffer_size
	// 
	// The function takes the following parameters:
	// 
	// 	- size uint: a #gsize. 
	//
	// Sets the size of the internal buffer to @size.
	SetBufferSize(uint)

	// chain up virtual methods:
}

func unsafeWrapBufferedOutputStream(base *gobject.ObjectInstance) *BufferedOutputStreamInstance {
	return &BufferedOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeBufferedOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedOutputStream(inst)
		},
	)
}

func marshalBufferedOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeBufferedOutputStreamFromGlibNone is used to convert raw GBufferedOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibNone(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(BufferedOutputStream)
}

// UnsafeBufferedOutputStreamFromGlibFull is used to convert raw GBufferedOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibFull(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(BufferedOutputStream)
}

// UnsafeBufferedOutputStreamFromGlibBorrow is used to convert raw GBufferedOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBufferedOutputStreamFromGlibBorrow(c unsafe.Pointer) BufferedOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(BufferedOutputStream)
}

func (b *BufferedOutputStreamInstance) upcastToGBufferedOutputStream() *BufferedOutputStreamInstance {
	return b
}

// UnsafeBufferedOutputStreamToGlibNone is used to convert the instance to it's C value GBufferedOutputStream. This is used by the bindings internally.
func UnsafeBufferedOutputStreamToGlibNone(c BufferedOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeBufferedOutputStreamToGlibFull is used to convert the instance to it's C value GBufferedOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamToGlibFull(c BufferedOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewBufferedOutputStream wraps g_buffered_output_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream OutputStream: a [class@Gio.OutputStream]. 
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Creates a new buffered output stream for a base stream.
func NewBufferedOutputStream(baseStream OutputStream) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))

	cret = C.g_buffered_output_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewBufferedOutputStreamSized wraps g_buffered_output_stream_new_sized
// 
// The function takes the following parameters:
// 
// 	- baseStream OutputStream: a [class@Gio.OutputStream]. 
// 	- size uint: a #gsize. 
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Creates a new buffered output stream with a given buffer size.
func NewBufferedOutputStreamSized(baseStream OutputStream, size uint) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 C.gsize          // in, none, casted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))
	carg2 = C.gsize(size)

	cret = C.g_buffered_output_stream_new_sized(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(size)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetAutoGrow wraps g_buffered_output_stream_get_auto_grow
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the buffer automatically grows as data is added.
func (stream *BufferedOutputStreamInstance) GetAutoGrow() bool {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var cret  C.gboolean               // return

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))

	cret = C.g_buffered_output_stream_get_auto_grow(carg0)
	runtime.KeepAlive(stream)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetBufferSize wraps g_buffered_output_stream_get_buffer_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the size of the buffer in the @stream.
func (stream *BufferedOutputStreamInstance) GetBufferSize() uint {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var cret  C.gsize                  // return, none, casted

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))

	cret = C.g_buffered_output_stream_get_buffer_size(carg0)
	runtime.KeepAlive(stream)

	var goret uint

	goret = uint(cret)

	return goret
}

// SetAutoGrow wraps g_buffered_output_stream_set_auto_grow
// 
// The function takes the following parameters:
// 
// 	- autoGrow bool: a #gboolean. 
//
// Sets whether or not the @stream's buffer should automatically grow.
// If @auto_grow is true, then each write will just make the buffer
// larger, and you must manually flush the buffer to actually write out
// the data to the underlying stream.
func (stream *BufferedOutputStreamInstance) SetAutoGrow(autoGrow bool) {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var carg1 C.gboolean               // in

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))
	if autoGrow {
		carg1 = C.TRUE
	}

	C.g_buffered_output_stream_set_auto_grow(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(autoGrow)
}

// SetBufferSize wraps g_buffered_output_stream_set_buffer_size
// 
// The function takes the following parameters:
// 
// 	- size uint: a #gsize. 
//
// Sets the size of the internal buffer to @size.
func (stream *BufferedOutputStreamInstance) SetBufferSize(size uint) {
	var carg0 *C.GBufferedOutputStream // in, none, converted
	var carg1 C.gsize                  // in, none, casted

	carg0 = (*C.GBufferedOutputStream)(UnsafeBufferedOutputStreamToGlibNone(stream))
	carg1 = C.gsize(size)

	C.g_buffered_output_stream_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(size)
}

// BufferedOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type BufferedOutputStreamOverrides[Instance BufferedOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyBufferedOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyBufferedOutputStreamOverrides[Instance BufferedOutputStream](gclass unsafe.Pointer, overrides BufferedOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterBufferedOutputStreamSubClass is used to register a go subclass of GBufferedOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterBufferedOutputStreamSubClass[InstanceT BufferedOutputStream](
		name string,
		classInit func(class *BufferedOutputStreamClass),
		constructor func() InstanceT,
		overrides BufferedOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeBufferedOutputStream,
		UnsafeBufferedOutputStreamClassFromGlibBorrow,
		UnsafeApplyBufferedOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapBufferedOutputStream(obj)
		},
		interfaceInits...,
	)
}

// ConverterInputStreamInstance is the instance type used by all types extending GConverterInputStream. It is used internally by the bindings. Users should use the interface [ConverterInputStream] instead.
type ConverterInputStreamInstance struct {
	_ [0]func() // equal guard
	FilterInputStreamInstance
	// implemented interfaces:
	PollableInputStreamInstance
}

var _ ConverterInputStream = (*ConverterInputStreamInstance)(nil)

// ConverterInputStream wraps GConverterInputStream
//
// Converter input stream implements [class@Gio.InputStream] and allows
// conversion of data of various types during reading.
// 
// As of GLib 2.34, `GConverterInputStream` implements
// [iface@Gio.PollableInputStream].
type ConverterInputStream interface {
	FilterInputStream
	PollableInputStream
	upcastToGConverterInputStream() *ConverterInputStreamInstance

	// GetConverter wraps g_converter_input_stream_get_converter
	// 
	// The function returns the following values:
	// 
	// 	- goret Converter 
	//
	// Gets the #GConverter that is used by @converter_stream.
	GetConverter() Converter

	// chain up virtual methods:
}

func unsafeWrapConverterInputStream(base *gobject.ObjectInstance) *ConverterInputStreamInstance {
	return &ConverterInputStreamInstance{
		FilterInputStreamInstance: FilterInputStreamInstance{
			InputStreamInstance: InputStreamInstance{
				ObjectInstance: *base,
			},
		},
		PollableInputStreamInstance: PollableInputStreamInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeConverterInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterInputStream(inst)
		},
	)
}

func marshalConverterInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeConverterInputStreamFromGlibNone is used to convert raw GConverterInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibNone(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(ConverterInputStream)
}

// UnsafeConverterInputStreamFromGlibFull is used to convert raw GConverterInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibFull(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(ConverterInputStream)
}

// UnsafeConverterInputStreamFromGlibBorrow is used to convert raw GConverterInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterInputStreamFromGlibBorrow(c unsafe.Pointer) ConverterInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ConverterInputStream)
}

func (c *ConverterInputStreamInstance) upcastToGConverterInputStream() *ConverterInputStreamInstance {
	return c
}

// UnsafeConverterInputStreamToGlibNone is used to convert the instance to it's C value GConverterInputStream. This is used by the bindings internally.
func UnsafeConverterInputStreamToGlibNone(c ConverterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeConverterInputStreamToGlibFull is used to convert the instance to it's C value GConverterInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterInputStreamToGlibFull(c ConverterInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewConverterInputStream wraps g_converter_input_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream InputStream: a #GInputStream 
// 	- converter Converter: a #GConverter 
// 
// The function returns the following values:
// 
// 	- goret InputStream 
//
// Creates a new converter input stream for the @base_stream.
func NewConverterInputStream(baseStream InputStream, converter Converter) InputStream {
	var carg1 *C.GInputStream // in, none, converted
	var carg2 *C.GConverter   // in, none, converted
	var cret  *C.GInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))
	carg2 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	cret = C.g_converter_input_stream_new(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var goret InputStream

	goret = UnsafeInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConverter wraps g_converter_input_stream_get_converter
// 
// The function returns the following values:
// 
// 	- goret Converter 
//
// Gets the #GConverter that is used by @converter_stream.
func (converterStream *ConverterInputStreamInstance) GetConverter() Converter {
	var carg0 *C.GConverterInputStream // in, none, converted
	var cret  *C.GConverter            // return, none, converted

	carg0 = (*C.GConverterInputStream)(UnsafeConverterInputStreamToGlibNone(converterStream))

	cret = C.g_converter_input_stream_get_converter(carg0)
	runtime.KeepAlive(converterStream)

	var goret Converter

	goret = UnsafeConverterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ConverterInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ConverterInputStreamOverrides[Instance ConverterInputStream] struct {
	// FilterInputStreamOverrides allows you to override virtual methods from the parent class FilterInputStream
	FilterInputStreamOverrides[Instance]

}

// UnsafeApplyConverterInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyConverterInputStreamOverrides[Instance ConverterInputStream](gclass unsafe.Pointer, overrides ConverterInputStreamOverrides[Instance]) {
	UnsafeApplyFilterInputStreamOverrides(gclass, overrides.FilterInputStreamOverrides)
}

// RegisterConverterInputStreamSubClass is used to register a go subclass of GConverterInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterConverterInputStreamSubClass[InstanceT ConverterInputStream](
		name string,
		classInit func(class *ConverterInputStreamClass),
		constructor func() InstanceT,
		overrides ConverterInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeConverterInputStream,
		UnsafeConverterInputStreamClassFromGlibBorrow,
		UnsafeApplyConverterInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterInputStream(obj)
		},
		interfaceInits...,
	)
}

// ConverterOutputStreamInstance is the instance type used by all types extending GConverterOutputStream. It is used internally by the bindings. Users should use the interface [ConverterOutputStream] instead.
type ConverterOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	PollableOutputStreamInstance
}

var _ ConverterOutputStream = (*ConverterOutputStreamInstance)(nil)

// ConverterOutputStream wraps GConverterOutputStream
//
// Converter output stream implements [class@Gio.OutputStream] and allows
// conversion of data of various types during reading.
// 
// As of GLib 2.34, `GConverterOutputStream` implements
// [iface@Gio.PollableOutputStream].
type ConverterOutputStream interface {
	FilterOutputStream
	PollableOutputStream
	upcastToGConverterOutputStream() *ConverterOutputStreamInstance

	// GetConverter wraps g_converter_output_stream_get_converter
	// 
	// The function returns the following values:
	// 
	// 	- goret Converter 
	//
	// Gets the #GConverter that is used by @converter_stream.
	GetConverter() Converter

	// chain up virtual methods:
}

func unsafeWrapConverterOutputStream(base *gobject.ObjectInstance) *ConverterOutputStreamInstance {
	return &ConverterOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		PollableOutputStreamInstance: PollableOutputStreamInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeConverterOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterOutputStream(inst)
		},
	)
}

func marshalConverterOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeConverterOutputStreamFromGlibNone is used to convert raw GConverterOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibNone(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(ConverterOutputStream)
}

// UnsafeConverterOutputStreamFromGlibFull is used to convert raw GConverterOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibFull(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(ConverterOutputStream)
}

// UnsafeConverterOutputStreamFromGlibBorrow is used to convert raw GConverterOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeConverterOutputStreamFromGlibBorrow(c unsafe.Pointer) ConverterOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(ConverterOutputStream)
}

func (c *ConverterOutputStreamInstance) upcastToGConverterOutputStream() *ConverterOutputStreamInstance {
	return c
}

// UnsafeConverterOutputStreamToGlibNone is used to convert the instance to it's C value GConverterOutputStream. This is used by the bindings internally.
func UnsafeConverterOutputStreamToGlibNone(c ConverterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeConverterOutputStreamToGlibFull is used to convert the instance to it's C value GConverterOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeConverterOutputStreamToGlibFull(c ConverterOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewConverterOutputStream wraps g_converter_output_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream OutputStream: a #GOutputStream 
// 	- converter Converter: a #GConverter 
// 
// The function returns the following values:
// 
// 	- goret OutputStream 
//
// Creates a new converter output stream for the @base_stream.
func NewConverterOutputStream(baseStream OutputStream, converter Converter) OutputStream {
	var carg1 *C.GOutputStream // in, none, converted
	var carg2 *C.GConverter    // in, none, converted
	var cret  *C.GOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))
	carg2 = (*C.GConverter)(UnsafeConverterToGlibNone(converter))

	cret = C.g_converter_output_stream_new(carg1, carg2)
	runtime.KeepAlive(baseStream)
	runtime.KeepAlive(converter)

	var goret OutputStream

	goret = UnsafeOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetConverter wraps g_converter_output_stream_get_converter
// 
// The function returns the following values:
// 
// 	- goret Converter 
//
// Gets the #GConverter that is used by @converter_stream.
func (converterStream *ConverterOutputStreamInstance) GetConverter() Converter {
	var carg0 *C.GConverterOutputStream // in, none, converted
	var cret  *C.GConverter             // return, none, converted

	carg0 = (*C.GConverterOutputStream)(UnsafeConverterOutputStreamToGlibNone(converterStream))

	cret = C.g_converter_output_stream_get_converter(carg0)
	runtime.KeepAlive(converterStream)

	var goret Converter

	goret = UnsafeConverterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// ConverterOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type ConverterOutputStreamOverrides[Instance ConverterOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyConverterOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyConverterOutputStreamOverrides[Instance ConverterOutputStream](gclass unsafe.Pointer, overrides ConverterOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterConverterOutputStreamSubClass is used to register a go subclass of GConverterOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterConverterOutputStreamSubClass[InstanceT ConverterOutputStream](
		name string,
		classInit func(class *ConverterOutputStreamClass),
		constructor func() InstanceT,
		overrides ConverterOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeConverterOutputStream,
		UnsafeConverterOutputStreamClassFromGlibBorrow,
		UnsafeApplyConverterOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapConverterOutputStream(obj)
		},
		interfaceInits...,
	)
}

// DataInputStreamInstance is the instance type used by all types extending GDataInputStream. It is used internally by the bindings. Users should use the interface [DataInputStream] instead.
type DataInputStreamInstance struct {
	_ [0]func() // equal guard
	BufferedInputStreamInstance
}

var _ DataInputStream = (*DataInputStreamInstance)(nil)

// DataInputStream wraps GDataInputStream
//
// Data input stream implements [class@Gio.InputStream] and includes functions
// for reading structured data directly from a binary input stream.
type DataInputStream interface {
	BufferedInputStream
	upcastToGDataInputStream() *DataInputStreamInstance

	// GetByteOrder wraps g_data_input_stream_get_byte_order
	// 
	// The function returns the following values:
	// 
	// 	- goret DataStreamByteOrder 
	//
	// Gets the byte order for the data input stream.
	GetByteOrder() DataStreamByteOrder
	// GetNewlineType wraps g_data_input_stream_get_newline_type
	// 
	// The function returns the following values:
	// 
	// 	- goret DataStreamNewlineType 
	//
	// Gets the current newline type for the @stream.
	GetNewlineType() DataStreamNewlineType
	// ReadInt16 wraps g_data_input_stream_read_int16
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int16 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a 16-bit/2-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
	ReadInt16(Cancellable) (int16, error)
	// ReadInt32 wraps g_data_input_stream_read_int32
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int32 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a signed 32-bit/4-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadInt32(Cancellable) (int32, error)
	// ReadInt64 wraps g_data_input_stream_read_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret int64 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a 64-bit/8-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadInt64(Cancellable) (int64, error)
	// ReadLine wraps g_data_input_stream_read_line
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a line from the data input stream.  Note that no encoding
	// checks or conversion is performed; the input is not guaranteed to
	// be UTF-8, and may in fact have embedded NUL characters.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadLine(Cancellable) (uint, string, error)
	// ReadLineAsync wraps g_data_input_stream_read_line_async
	// 
	// The function takes the following parameters:
	// 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied. 
	//
	// The asynchronous version of g_data_input_stream_read_line().  It is
	// an error to have two outstanding calls to this function.
	// 
	// When the operation is finished, @callback will be called. You
	// can then call g_data_input_stream_read_line_finish() to get
	// the result of the operation.
	ReadLineAsync(int32, Cancellable, AsyncReadyCallback)
	// ReadLineFinish wraps g_data_input_stream_read_line_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous call started by
	// g_data_input_stream_read_line_async().  Note the warning about
	// string encoding in g_data_input_stream_read_line() applies here as
	// well.
	ReadLineFinish(AsyncResult) (uint, string, error)
	// ReadLineFinishUTF8 wraps g_data_input_stream_read_line_finish_utf8
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous call started by
	// g_data_input_stream_read_line_async().
	ReadLineFinishUTF8(AsyncResult) (uint, string, error)
	// ReadLineUTF8 wraps g_data_input_stream_read_line_utf8
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string (nullable) 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a UTF-8 encoded line from the data input stream.
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadLineUTF8(Cancellable) (uint, string, error)
	// ReadUint16 wraps g_data_input_stream_read_uint16
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint16 
	// 	- _goerr error (nullable): an error 
	//
	// Reads an unsigned 16-bit/2-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
	ReadUint16(Cancellable) (uint16, error)
	// ReadUint32 wraps g_data_input_stream_read_uint32
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint32 
	// 	- _goerr error (nullable): an error 
	//
	// Reads an unsigned 32-bit/4-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadUint32(Cancellable) (uint32, error)
	// ReadUint64 wraps g_data_input_stream_read_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret uint64 
	// 	- _goerr error (nullable): an error 
	//
	// Reads an unsigned 64-bit/8-byte value from @stream.
	// 
	// In order to get the correct byte order for this read operation,
	// see g_data_input_stream_get_byte_order().
	// 
	// If @cancellable is not %NULL, then the operation can be cancelled by
	// triggering the cancellable object from another thread. If the operation
	// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
	ReadUint64(Cancellable) (uint64, error)
	// ReadUntil wraps g_data_input_stream_read_until
	// 
	// The function takes the following parameters:
	// 
	// 	- stopChars string: characters to terminate the read. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	// 
	// Note that, in contrast to g_data_input_stream_read_until_async(),
	// this function consumes the stop character that it finds.
	// 
	// Don't use this function in new code.  Its functionality is
	// inconsistent with g_data_input_stream_read_until_async().  Both
	// functions will be marked as deprecated in a future release.  Use
	// g_data_input_stream_read_upto() instead, but note that that function
	// does not consume the stop character.
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto() instead, which has more
	//     consistent behaviour regarding the stop character.
	ReadUntil(string, Cancellable) (uint, string, error)
	// ReadUntilAsync wraps g_data_input_stream_read_until_async
	// 
	// The function takes the following parameters:
	// 
	// 	- stopChars string: characters to terminate the read. 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied. 
	//
	// The asynchronous version of g_data_input_stream_read_until().
	// It is an error to have two outstanding calls to this function.
	// 
	// Note that, in contrast to g_data_input_stream_read_until(),
	// this function does not consume the stop character that it finds.  You
	// must read it for yourself.
	// 
	// When the operation is finished, @callback will be called. You
	// can then call g_data_input_stream_read_until_finish() to get
	// the result of the operation.
	// 
	// Don't use this function in new code.  Its functionality is
	// inconsistent with g_data_input_stream_read_until().  Both functions
	// will be marked as deprecated in a future release.  Use
	// g_data_input_stream_read_upto_async() instead.
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_async() instead, which
	//     has more consistent behaviour regarding the stop character.
	ReadUntilAsync(string, int32, Cancellable, AsyncReadyCallback)
	// ReadUntilFinish wraps g_data_input_stream_read_until_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in. 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous call started by
	// g_data_input_stream_read_until_async().
	//
	// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_finish() instead, which
	//     has more consistent behaviour regarding the stop character.
	ReadUntilFinish(AsyncResult) (uint, string, error)
	// ReadUpto wraps g_data_input_stream_read_upto
	// 
	// The function takes the following parameters:
	// 
	// 	- stopChars string: characters to terminate the read 
	// 	- stopCharsLen int: length of @stop_chars. May be -1 if @stop_chars is
	//     nul-terminated 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Reads a string from the data input stream, up to the first
	// occurrence of any of the stop characters.
	// 
	// In contrast to g_data_input_stream_read_until(), this function
	// does not consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	// 
	// Note that @stop_chars may contain '\0' if @stop_chars_len is
	// specified.
	// 
	// The returned string will always be nul-terminated on success.
	ReadUpto(string, int, Cancellable) (uint, string, error)
	// ReadUptoAsync wraps g_data_input_stream_read_upto_async
	// 
	// The function takes the following parameters:
	// 
	// 	- stopChars string: characters to terminate the read 
	// 	- stopCharsLen int: length of @stop_chars. May be -1 if @stop_chars is
	//     nul-terminated 
	// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
	// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied 
	//
	// The asynchronous version of g_data_input_stream_read_upto().
	// It is an error to have two outstanding calls to this function.
	// 
	// In contrast to g_data_input_stream_read_until(), this function
	// does not consume the stop character. You have to use
	// g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto() again.
	// 
	// Note that @stop_chars may contain '\0' if @stop_chars_len is
	// specified.
	// 
	// When the operation is finished, @callback will be called. You
	// can then call g_data_input_stream_read_upto_finish() to get
	// the result of the operation.
	ReadUptoAsync(string, int, int32, Cancellable, AsyncReadyCallback)
	// ReadUptoFinish wraps g_data_input_stream_read_upto_finish
	// 
	// The function takes the following parameters:
	// 
	// 	- result AsyncResult: the #GAsyncResult that was provided to the callback 
	// 
	// The function returns the following values:
	// 
	// 	- length uint: a #gsize to get the length of the data read in 
	// 	- goret string 
	// 	- _goerr error (nullable): an error 
	//
	// Finish an asynchronous call started by
	// g_data_input_stream_read_upto_async().
	// 
	// Note that this function does not consume the stop character. You
	// have to use g_data_input_stream_read_byte() to get it before calling
	// g_data_input_stream_read_upto_async() again.
	// 
	// The returned string will always be nul-terminated on success.
	ReadUptoFinish(AsyncResult) (uint, string, error)
	// SetByteOrder wraps g_data_input_stream_set_byte_order
	// 
	// The function takes the following parameters:
	// 
	// 	- order DataStreamByteOrder: a #GDataStreamByteOrder to set. 
	//
	// This function sets the byte order for the given @stream. All subsequent
	// reads from the @stream will be read in the given @order.
	SetByteOrder(DataStreamByteOrder)
	// SetNewlineType wraps g_data_input_stream_set_newline_type
	// 
	// The function takes the following parameters:
	// 
	// 	- typ DataStreamNewlineType: the type of new line return as #GDataStreamNewlineType. 
	//
	// Sets the newline type for the @stream.
	// 
	// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
	// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
	// "CR LF", and this might block if there is no more data available.
	SetNewlineType(DataStreamNewlineType)

	// chain up virtual methods:
}

func unsafeWrapDataInputStream(base *gobject.ObjectInstance) *DataInputStreamInstance {
	return &DataInputStreamInstance{
		BufferedInputStreamInstance: BufferedInputStreamInstance{
			FilterInputStreamInstance: FilterInputStreamInstance{
				InputStreamInstance: InputStreamInstance{
					ObjectInstance: *base,
				},
			},
			SeekableInstance: SeekableInstance{
				Instance: *base,
			},
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeDataInputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataInputStream(inst)
		},
	)
}

func marshalDataInputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeDataInputStreamFromGlibNone is used to convert raw GDataInputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibNone(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(DataInputStream)
}

// UnsafeDataInputStreamFromGlibFull is used to convert raw GDataInputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibFull(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(DataInputStream)
}

// UnsafeDataInputStreamFromGlibBorrow is used to convert raw GDataInputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDataInputStreamFromGlibBorrow(c unsafe.Pointer) DataInputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DataInputStream)
}

func (d *DataInputStreamInstance) upcastToGDataInputStream() *DataInputStreamInstance {
	return d
}

// UnsafeDataInputStreamToGlibNone is used to convert the instance to it's C value GDataInputStream. This is used by the bindings internally.
func UnsafeDataInputStreamToGlibNone(c DataInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeDataInputStreamToGlibFull is used to convert the instance to it's C value GDataInputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDataInputStreamToGlibFull(c DataInputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewDataInputStream wraps g_data_input_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream InputStream: a #GInputStream. 
// 
// The function returns the following values:
// 
// 	- goret DataInputStream 
//
// Creates a new data input stream for the @base_stream.
func NewDataInputStream(baseStream InputStream) DataInputStream {
	var carg1 *C.GInputStream     // in, none, converted
	var cret  *C.GDataInputStream // return, full, converted

	carg1 = (*C.GInputStream)(UnsafeInputStreamToGlibNone(baseStream))

	cret = C.g_data_input_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret DataInputStream

	goret = UnsafeDataInputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetByteOrder wraps g_data_input_stream_get_byte_order
// 
// The function returns the following values:
// 
// 	- goret DataStreamByteOrder 
//
// Gets the byte order for the data input stream.
func (stream *DataInputStreamInstance) GetByteOrder() DataStreamByteOrder {
	var carg0 *C.GDataInputStream    // in, none, converted
	var cret  C.GDataStreamByteOrder // return, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))

	cret = C.g_data_input_stream_get_byte_order(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamByteOrder

	goret = DataStreamByteOrder(cret)

	return goret
}

// GetNewlineType wraps g_data_input_stream_get_newline_type
// 
// The function returns the following values:
// 
// 	- goret DataStreamNewlineType 
//
// Gets the current newline type for the @stream.
func (stream *DataInputStreamInstance) GetNewlineType() DataStreamNewlineType {
	var carg0 *C.GDataInputStream      // in, none, converted
	var cret  C.GDataStreamNewlineType // return, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))

	cret = C.g_data_input_stream_get_newline_type(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamNewlineType

	goret = DataStreamNewlineType(cret)

	return goret
}

// ReadInt16 wraps g_data_input_stream_read_int16
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int16 
// 	- _goerr error (nullable): an error 
//
// Reads a 16-bit/2-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
func (stream *DataInputStreamInstance) ReadInt16(cancellable Cancellable) (int16, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint16            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int16(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int16
	var _goerr error

	goret = int16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadInt32 wraps g_data_input_stream_read_int32
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Reads a signed 32-bit/4-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadInt32(cancellable Cancellable) (int32, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint32            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int32(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadInt64 wraps g_data_input_stream_read_int64
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret int64 
// 	- _goerr error (nullable): an error 
//
// Reads a 64-bit/8-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadInt64(cancellable Cancellable) (int64, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.gint64            // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_int64(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  int64
	var _goerr error

	goret = int64(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadLine wraps g_data_input_stream_read_line
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string (nullable) 
// 	- _goerr error (nullable): an error 
//
// Reads a line from the data input stream.  Note that no encoding
// checks or conversion is performed; the input is not guaranteed to
// be UTF-8, and may in fact have embedded NUL characters.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadLine(cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var carg1 C.gsize             // out, full, casted
	var cret  *C.char             // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , nullable, array (inner unknown, zero-terminated)
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_line(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineAsync wraps g_data_input_stream_read_line_async
// 
// The function takes the following parameters:
// 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied. 
//
// The asynchronous version of g_data_input_stream_read_line().  It is
// an error to have two outstanding calls to this function.
// 
// When the operation is finished, @callback will be called. You
// can then call g_data_input_stream_read_line_finish() to get
// the result of the operation.
func (stream *DataInputStreamInstance) ReadLineAsync(ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 C.gint                // in, none, casted
	var carg2 *C.GCancellable       // in, none, converted, nullable
	var carg3 C.GAsyncReadyCallback // callback, scope: async, closure: carg4, nullable
	var carg4 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.gint(ioPriority)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg3 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg4 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_line_async(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadLineFinish wraps g_data_input_stream_read_line_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string (nullable) 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous call started by
// g_data_input_stream_read_line_async().  Note the warning about
// string encoding in g_data_input_stream_read_line() applies here as
// well.
func (stream *DataInputStreamInstance) ReadLineFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , nullable, array (inner unknown, zero-terminated)
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_line_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (char*) because of unknown reason")
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineFinishUTF8 wraps g_data_input_stream_read_line_finish_utf8
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string (nullable) 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous call started by
// g_data_input_stream_read_line_async().
func (stream *DataInputStreamInstance) ReadLineFinishUTF8(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string, nullable-string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_line_finish_utf8(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadLineUTF8 wraps g_data_input_stream_read_line_utf8
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string (nullable) 
// 	- _goerr error (nullable): an error 
//
// Reads a UTF-8 encoded line from the data input stream.
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadLineUTF8(cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg2 *C.GCancellable     // in, none, converted, nullable
	var carg1 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string, nullable-string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_line_utf8(carg0, &carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUint16 wraps g_data_input_stream_read_uint16
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret uint16 
// 	- _goerr error (nullable): an error 
//
// Reads an unsigned 16-bit/2-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
func (stream *DataInputStreamInstance) ReadUint16(cancellable Cancellable) (uint16, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint16           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint16(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint16
	var _goerr error

	goret = uint16(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUint32 wraps g_data_input_stream_read_uint32
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret uint32 
// 	- _goerr error (nullable): an error 
//
// Reads an unsigned 32-bit/4-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadUint32(cancellable Cancellable) (uint32, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint32           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint32(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint32
	var _goerr error

	goret = uint32(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUint64 wraps g_data_input_stream_read_uint64
// 
// The function takes the following parameters:
// 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret uint64 
// 	- _goerr error (nullable): an error 
//
// Reads an unsigned 64-bit/8-byte value from @stream.
// 
// In order to get the correct byte order for this read operation,
// see g_data_input_stream_get_byte_order().
// 
// If @cancellable is not %NULL, then the operation can be cancelled by
// triggering the cancellable object from another thread. If the operation
// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
func (stream *DataInputStreamInstance) ReadUint64(cancellable Cancellable) (uint64, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GCancellable     // in, none, converted, nullable
	var cret  C.guint64           // return, none, casted
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	if cancellable != nil {
		carg1 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_uint64(carg0, carg1, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(cancellable)

	var goret  uint64
	var _goerr error

	goret = uint64(cret)
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReadUntil wraps g_data_input_stream_read_until
// 
// The function takes the following parameters:
// 
// 	- stopChars string: characters to terminate the read. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
// 
// Note that, in contrast to g_data_input_stream_read_until_async(),
// this function consumes the stop character that it finds.
// 
// Don't use this function in new code.  Its functionality is
// inconsistent with g_data_input_stream_read_until_async().  Both
// functions will be marked as deprecated in a future release.  Use
// g_data_input_stream_read_upto() instead, but note that that function
// does not consume the stop character.
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto() instead, which has more
//     consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntil(stopChars string, cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.gchar            // in, none, string
	var carg3 *C.GCancellable     // in, none, converted, nullable
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_until(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUntilAsync wraps g_data_input_stream_read_until_async
// 
// The function takes the following parameters:
// 
// 	- stopChars string: characters to terminate the read. 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied. 
//
// The asynchronous version of g_data_input_stream_read_until().
// It is an error to have two outstanding calls to this function.
// 
// Note that, in contrast to g_data_input_stream_read_until(),
// this function does not consume the stop character that it finds.  You
// must read it for yourself.
// 
// When the operation is finished, @callback will be called. You
// can then call g_data_input_stream_read_until_finish() to get
// the result of the operation.
// 
// Don't use this function in new code.  Its functionality is
// inconsistent with g_data_input_stream_read_until().  Both functions
// will be marked as deprecated in a future release.  Use
// g_data_input_stream_read_upto_async() instead.
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_async() instead, which
//     has more consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntilAsync(stopChars string, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.gint                // in, none, casted
	var carg3 *C.GCancellable       // in, none, converted, nullable
	var carg4 C.GAsyncReadyCallback // callback, scope: async, closure: carg5, nullable
	var carg5 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(ioPriority)
	if cancellable != nil {
		carg3 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg4 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg5 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_until_async(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadUntilFinish wraps g_data_input_stream_read_until_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult that was provided to the callback. 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in. 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous call started by
// g_data_input_stream_read_until_async().
//
// Deprecated: (since 2.56.0) Use g_data_input_stream_read_upto_finish() instead, which
//     has more consistent behaviour regarding the stop character.
func (stream *DataInputStreamInstance) ReadUntilFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_until_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUpto wraps g_data_input_stream_read_upto
// 
// The function takes the following parameters:
// 
// 	- stopChars string: characters to terminate the read 
// 	- stopCharsLen int: length of @stop_chars. May be -1 if @stop_chars is
//     nul-terminated 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Reads a string from the data input stream, up to the first
// occurrence of any of the stop characters.
// 
// In contrast to g_data_input_stream_read_until(), this function
// does not consume the stop character. You have to use
// g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto() again.
// 
// Note that @stop_chars may contain '\0' if @stop_chars_len is
// specified.
// 
// The returned string will always be nul-terminated on success.
func (stream *DataInputStreamInstance) ReadUpto(stopChars string, stopCharsLen int, cancellable Cancellable) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.gchar            // in, none, string
	var carg2 C.gssize            // in, none, casted
	var carg4 *C.GCancellable     // in, none, converted, nullable
	var carg3 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(stopCharsLen)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_input_stream_read_upto(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(stopCharsLen)
	runtime.KeepAlive(cancellable)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg3)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ReadUptoAsync wraps g_data_input_stream_read_upto_async
// 
// The function takes the following parameters:
// 
// 	- stopChars string: characters to terminate the read 
// 	- stopCharsLen int: length of @stop_chars. May be -1 if @stop_chars is
//     nul-terminated 
// 	- ioPriority int32: the [I/O priority](iface.AsyncResult.html#io-priority) of the request 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore 
// 	- callback AsyncReadyCallback (nullable): callback to call when the request is satisfied 
//
// The asynchronous version of g_data_input_stream_read_upto().
// It is an error to have two outstanding calls to this function.
// 
// In contrast to g_data_input_stream_read_until(), this function
// does not consume the stop character. You have to use
// g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto() again.
// 
// Note that @stop_chars may contain '\0' if @stop_chars_len is
// specified.
// 
// When the operation is finished, @callback will be called. You
// can then call g_data_input_stream_read_upto_finish() to get
// the result of the operation.
func (stream *DataInputStreamInstance) ReadUptoAsync(stopChars string, stopCharsLen int, ioPriority int32, cancellable Cancellable, callback AsyncReadyCallback) {
	var carg0 *C.GDataInputStream   // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var carg2 C.gssize              // in, none, casted
	var carg3 C.gint                // in, none, casted
	var carg4 *C.GCancellable       // in, none, converted, nullable
	var carg5 C.GAsyncReadyCallback // callback, scope: async, closure: carg6, nullable
	var carg6 C.gpointer            // implicit

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stopChars)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(stopCharsLen)
	carg3 = C.gint(ioPriority)
	if cancellable != nil {
		carg4 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}
	if callback != nil {
		carg5 = (*[0]byte)(C._goglib_gio2_AsyncReadyCallback)
		carg6 = C.gpointer(userdata.RegisterOnce(callback))
	}

	C.g_data_input_stream_read_upto_async(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(stopChars)
	runtime.KeepAlive(stopCharsLen)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(callback)
}

// ReadUptoFinish wraps g_data_input_stream_read_upto_finish
// 
// The function takes the following parameters:
// 
// 	- result AsyncResult: the #GAsyncResult that was provided to the callback 
// 
// The function returns the following values:
// 
// 	- length uint: a #gsize to get the length of the data read in 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Finish an asynchronous call started by
// g_data_input_stream_read_upto_async().
// 
// Note that this function does not consume the stop character. You
// have to use g_data_input_stream_read_byte() to get it before calling
// g_data_input_stream_read_upto_async() again.
// 
// The returned string will always be nul-terminated on success.
func (stream *DataInputStreamInstance) ReadUptoFinish(result AsyncResult) (uint, string, error) {
	var carg0 *C.GDataInputStream // in, none, converted
	var carg1 *C.GAsyncResult     // in, none, converted
	var carg2 C.gsize             // out, full, casted
	var cret  *C.char             // return, full, string
	var _cerr *C.GError           // out, full, converted, nullable

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = (*C.GAsyncResult)(UnsafeAsyncResultToGlibNone(result))

	cret = C.g_data_input_stream_read_upto_finish(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg2)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// SetByteOrder wraps g_data_input_stream_set_byte_order
// 
// The function takes the following parameters:
// 
// 	- order DataStreamByteOrder: a #GDataStreamByteOrder to set. 
//
// This function sets the byte order for the given @stream. All subsequent
// reads from the @stream will be read in the given @order.
func (stream *DataInputStreamInstance) SetByteOrder(order DataStreamByteOrder) {
	var carg0 *C.GDataInputStream    // in, none, converted
	var carg1 C.GDataStreamByteOrder // in, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.GDataStreamByteOrder(order)

	C.g_data_input_stream_set_byte_order(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// SetNewlineType wraps g_data_input_stream_set_newline_type
// 
// The function takes the following parameters:
// 
// 	- typ DataStreamNewlineType: the type of new line return as #GDataStreamNewlineType. 
//
// Sets the newline type for the @stream.
// 
// Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
// chunk ends in "CR" we must read an additional byte to know if this is "CR" or
// "CR LF", and this might block if there is no more data available.
func (stream *DataInputStreamInstance) SetNewlineType(typ DataStreamNewlineType) {
	var carg0 *C.GDataInputStream      // in, none, converted
	var carg1 C.GDataStreamNewlineType // in, none, casted

	carg0 = (*C.GDataInputStream)(UnsafeDataInputStreamToGlibNone(stream))
	carg1 = C.GDataStreamNewlineType(typ)

	C.g_data_input_stream_set_newline_type(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(typ)
}

// DataInputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type DataInputStreamOverrides[Instance DataInputStream] struct {
	// BufferedInputStreamOverrides allows you to override virtual methods from the parent class BufferedInputStream
	BufferedInputStreamOverrides[Instance]

}

// UnsafeApplyDataInputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyDataInputStreamOverrides[Instance DataInputStream](gclass unsafe.Pointer, overrides DataInputStreamOverrides[Instance]) {
	UnsafeApplyBufferedInputStreamOverrides(gclass, overrides.BufferedInputStreamOverrides)
}

// RegisterDataInputStreamSubClass is used to register a go subclass of GDataInputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterDataInputStreamSubClass[InstanceT DataInputStream](
		name string,
		classInit func(class *DataInputStreamClass),
		constructor func() InstanceT,
		overrides DataInputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeDataInputStream,
		UnsafeDataInputStreamClassFromGlibBorrow,
		UnsafeApplyDataInputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataInputStream(obj)
		},
		interfaceInits...,
	)
}

// DataOutputStreamInstance is the instance type used by all types extending GDataOutputStream. It is used internally by the bindings. Users should use the interface [DataOutputStream] instead.
type DataOutputStreamInstance struct {
	_ [0]func() // equal guard
	FilterOutputStreamInstance
	// implemented interfaces:
	SeekableInstance
}

var _ DataOutputStream = (*DataOutputStreamInstance)(nil)

// DataOutputStream wraps GDataOutputStream
//
// Data output stream implements [class@Gio.OutputStream] and includes functions
// for writing data directly to an output stream.
type DataOutputStream interface {
	FilterOutputStream
	Seekable
	upcastToGDataOutputStream() *DataOutputStreamInstance

	// GetByteOrder wraps g_data_output_stream_get_byte_order
	// 
	// The function returns the following values:
	// 
	// 	- goret DataStreamByteOrder 
	//
	// Gets the byte order for the stream.
	GetByteOrder() DataStreamByteOrder
	// PutByte wraps g_data_output_stream_put_byte
	// 
	// The function takes the following parameters:
	// 
	// 	- data byte: a #guchar. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts a byte into the output stream.
	PutByte(byte, Cancellable) (bool, error)
	// PutInt16 wraps g_data_output_stream_put_int16
	// 
	// The function takes the following parameters:
	// 
	// 	- data int16: a #gint16. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts a signed 16-bit integer into the output stream.
	PutInt16(int16, Cancellable) (bool, error)
	// PutInt32 wraps g_data_output_stream_put_int32
	// 
	// The function takes the following parameters:
	// 
	// 	- data int32: a #gint32. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts a signed 32-bit integer into the output stream.
	PutInt32(int32, Cancellable) (bool, error)
	// PutInt64 wraps g_data_output_stream_put_int64
	// 
	// The function takes the following parameters:
	// 
	// 	- data int64: a #gint64. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts a signed 64-bit integer into the stream.
	PutInt64(int64, Cancellable) (bool, error)
	// PutString wraps g_data_output_stream_put_string
	// 
	// The function takes the following parameters:
	// 
	// 	- str string: a string. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts a string into the output stream.
	PutString(string, Cancellable) (bool, error)
	// PutUint16 wraps g_data_output_stream_put_uint16
	// 
	// The function takes the following parameters:
	// 
	// 	- data uint16: a #guint16. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts an unsigned 16-bit integer into the output stream.
	PutUint16(uint16, Cancellable) (bool, error)
	// PutUint32 wraps g_data_output_stream_put_uint32
	// 
	// The function takes the following parameters:
	// 
	// 	- data uint32: a #guint32. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts an unsigned 32-bit integer into the stream.
	PutUint32(uint32, Cancellable) (bool, error)
	// PutUint64 wraps g_data_output_stream_put_uint64
	// 
	// The function takes the following parameters:
	// 
	// 	- data uint64: a #guint64. 
	// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
	// 
	// The function returns the following values:
	// 
	// 	- goret bool 
	// 	- _goerr error (nullable): an error 
	//
	// Puts an unsigned 64-bit integer into the stream.
	PutUint64(uint64, Cancellable) (bool, error)
	// SetByteOrder wraps g_data_output_stream_set_byte_order
	// 
	// The function takes the following parameters:
	// 
	// 	- order DataStreamByteOrder: a %GDataStreamByteOrder. 
	//
	// Sets the byte order of the data output stream to @order.
	SetByteOrder(DataStreamByteOrder)

	// chain up virtual methods:
}

func unsafeWrapDataOutputStream(base *gobject.ObjectInstance) *DataOutputStreamInstance {
	return &DataOutputStreamInstance{
		FilterOutputStreamInstance: FilterOutputStreamInstance{
			OutputStreamInstance: OutputStreamInstance{
				ObjectInstance: *base,
			},
		},
		SeekableInstance: SeekableInstance{
			Instance: *base,
		},
	}
}

func init() {
	gobject.RegisterObjectCasting(
		TypeDataOutputStream,
		func (inst *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataOutputStream(inst)
		},
	)
}

func marshalDataOutputStreamInstance(p unsafe.Pointer) (any, error) {
	return gobject.ValueFromNative(p).Object(), nil
}

// UnsafeDataOutputStreamFromGlibNone is used to convert raw GDataOutputStream pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibNone(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibNone(c).(DataOutputStream)
}

// UnsafeDataOutputStreamFromGlibFull is used to convert raw GDataOutputStream pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibFull(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibFull(c).(DataOutputStream)
}

// UnsafeDataOutputStreamFromGlibBorrow is used to convert raw GDataOutputStream pointers to go without touching any references. This is used by the bindings internally.
func UnsafeDataOutputStreamFromGlibBorrow(c unsafe.Pointer) DataOutputStream {
	return gobject.UnsafeObjectFromGlibBorrow(c).(DataOutputStream)
}

func (d *DataOutputStreamInstance) upcastToGDataOutputStream() *DataOutputStreamInstance {
	return d
}

// UnsafeDataOutputStreamToGlibNone is used to convert the instance to it's C value GDataOutputStream. This is used by the bindings internally.
func UnsafeDataOutputStreamToGlibNone(c DataOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibNone(c)
}

// UnsafeDataOutputStreamToGlibFull is used to convert the instance to it's C value GDataOutputStream, while removeing the finalizer. This is used by the bindings internally.
func UnsafeDataOutputStreamToGlibFull(c DataOutputStream) unsafe.Pointer {
	return gobject.UnsafeObjectToGlibFull(c)
}

// NewDataOutputStream wraps g_data_output_stream_new
// 
// The function takes the following parameters:
// 
// 	- baseStream OutputStream: a #GOutputStream. 
// 
// The function returns the following values:
// 
// 	- goret DataOutputStream 
//
// Creates a new data output stream for @base_stream.
func NewDataOutputStream(baseStream OutputStream) DataOutputStream {
	var carg1 *C.GOutputStream     // in, none, converted
	var cret  *C.GDataOutputStream // return, full, converted

	carg1 = (*C.GOutputStream)(UnsafeOutputStreamToGlibNone(baseStream))

	cret = C.g_data_output_stream_new(carg1)
	runtime.KeepAlive(baseStream)

	var goret DataOutputStream

	goret = UnsafeDataOutputStreamFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetByteOrder wraps g_data_output_stream_get_byte_order
// 
// The function returns the following values:
// 
// 	- goret DataStreamByteOrder 
//
// Gets the byte order for the stream.
func (stream *DataOutputStreamInstance) GetByteOrder() DataStreamByteOrder {
	var carg0 *C.GDataOutputStream   // in, none, converted
	var cret  C.GDataStreamByteOrder // return, none, casted

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))

	cret = C.g_data_output_stream_get_byte_order(carg0)
	runtime.KeepAlive(stream)

	var goret DataStreamByteOrder

	goret = DataStreamByteOrder(cret)

	return goret
}

// PutByte wraps g_data_output_stream_put_byte
// 
// The function takes the following parameters:
// 
// 	- data byte: a #guchar. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts a byte into the output stream.
func (stream *DataOutputStreamInstance) PutByte(data byte, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guchar             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guchar(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_byte(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt16 wraps g_data_output_stream_put_int16
// 
// The function takes the following parameters:
// 
// 	- data int16: a #gint16. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts a signed 16-bit integer into the output stream.
func (stream *DataOutputStreamInstance) PutInt16(data int16, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint16             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint16(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int16(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt32 wraps g_data_output_stream_put_int32
// 
// The function takes the following parameters:
// 
// 	- data int32: a #gint32. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts a signed 32-bit integer into the output stream.
func (stream *DataOutputStreamInstance) PutInt32(data int32, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint32             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint32(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int32(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutInt64 wraps g_data_output_stream_put_int64
// 
// The function takes the following parameters:
// 
// 	- data int64: a #gint64. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts a signed 64-bit integer into the stream.
func (stream *DataOutputStreamInstance) PutInt64(data int64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.gint64             // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.gint64(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_int64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutString wraps g_data_output_stream_put_string
// 
// The function takes the following parameters:
// 
// 	- str string: a string. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts a string into the output stream.
func (stream *DataOutputStreamInstance) PutString(str string, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 *C.char              // in, none, string
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_string(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint16 wraps g_data_output_stream_put_uint16
// 
// The function takes the following parameters:
// 
// 	- data uint16: a #guint16. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts an unsigned 16-bit integer into the output stream.
func (stream *DataOutputStreamInstance) PutUint16(data uint16, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint16            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint16(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint16(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint32 wraps g_data_output_stream_put_uint32
// 
// The function takes the following parameters:
// 
// 	- data uint32: a #guint32. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts an unsigned 32-bit integer into the stream.
func (stream *DataOutputStreamInstance) PutUint32(data uint32, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint32            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint32(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint32(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// PutUint64 wraps g_data_output_stream_put_uint64
// 
// The function takes the following parameters:
// 
// 	- data uint64: a #guint64. 
// 	- cancellable Cancellable (nullable): optional #GCancellable object, %NULL to ignore. 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Puts an unsigned 64-bit integer into the stream.
func (stream *DataOutputStreamInstance) PutUint64(data uint64, cancellable Cancellable) (bool, error) {
	var carg0 *C.GDataOutputStream // in, none, converted
	var carg1 C.guint64            // in, none, casted
	var carg2 *C.GCancellable      // in, none, converted, nullable
	var cret  C.gboolean           // return
	var _cerr *C.GError            // out, full, converted, nullable

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.guint64(data)
	if cancellable != nil {
		carg2 = (*C.GCancellable)(UnsafeCancellableToGlibNone(cancellable))
	}

	cret = C.g_data_output_stream_put_uint64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(data)
	runtime.KeepAlive(cancellable)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetByteOrder wraps g_data_output_stream_set_byte_order
// 
// The function takes the following parameters:
// 
// 	- order DataStreamByteOrder: a %GDataStreamByteOrder. 
//
// Sets the byte order of the data output stream to @order.
func (stream *DataOutputStreamInstance) SetByteOrder(order DataStreamByteOrder) {
	var carg0 *C.GDataOutputStream   // in, none, converted
	var carg1 C.GDataStreamByteOrder // in, none, casted

	carg0 = (*C.GDataOutputStream)(UnsafeDataOutputStreamToGlibNone(stream))
	carg1 = C.GDataStreamByteOrder(order)

	C.g_data_output_stream_set_byte_order(carg0, carg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(order)
}

// DataOutputStreamOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type DataOutputStreamOverrides[Instance DataOutputStream] struct {
	// FilterOutputStreamOverrides allows you to override virtual methods from the parent class FilterOutputStream
	FilterOutputStreamOverrides[Instance]

}

// UnsafeApplyDataOutputStreamOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyDataOutputStreamOverrides[Instance DataOutputStream](gclass unsafe.Pointer, overrides DataOutputStreamOverrides[Instance]) {
	UnsafeApplyFilterOutputStreamOverrides(gclass, overrides.FilterOutputStreamOverrides)
}

// RegisterDataOutputStreamSubClass is used to register a go subclass of GDataOutputStream. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterDataOutputStreamSubClass[InstanceT DataOutputStream](
		name string,
		classInit func(class *DataOutputStreamClass),
		constructor func() InstanceT,
		overrides DataOutputStreamOverrides[InstanceT],
		signals map[string]gobject.SignalDefinition,
		interfaceInits ...gobject.SubClassInterfaceInit[InstanceT],
) gobject.Type {
	return gobject.UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeDataOutputStream,
		UnsafeDataOutputStreamClassFromGlibBorrow,
		UnsafeApplyDataOutputStreamOverrides,
		func (obj *gobject.ObjectInstance) gobject.Object {
			return unsafeWrapDataOutputStream(obj)
		},
		interfaceInits...,
	)
}

// ActionEntry wraps GActionEntry
//
// This struct defines a single action.  It is for use with
// [method@Gio.ActionMap.add_action_entries].
// 
// The order of the items in the structure are intended to reflect
// frequency of use.  It is permissible to use an incomplete initialiser
// in order to leave some of the later values as `NULL`.  All values
// after @name are optional.  Additional optional fields may be added in
// the future.
// 
// See [method@Gio.ActionMap.add_action_entries] for an example.
type ActionEntry struct {
	*actionEntry
}

// actionEntry is the struct that's finalized
type actionEntry struct {
	native *C.GActionEntry
}

// UnsafeActionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionEntry) instance() *C.GActionEntry {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionEntryFromGlibBorrow is used to convert raw C.GActionEntry pointers to go. This is used by the bindings internally.
func UnsafeActionEntryFromGlibBorrow(p unsafe.Pointer) *ActionEntry {
	if p == nil {
		return nil
	}
	return &ActionEntry{&actionEntry{(*C.GActionEntry)(p)}}
}

// UnsafeActionEntryFromGlibNone is used to convert raw C.GActionEntry pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionEntryFromGlibNone(p unsafe.Pointer) *ActionEntry {
	wrapped := UnsafeActionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionEntry because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionEntryFromGlibFull is used to convert raw C.GActionEntry pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionEntryFromGlibFull(p unsafe.Pointer) *ActionEntry {
	wrapped := UnsafeActionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionEntry,
		func (intern *actionEntry) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionEntryFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionEntry] is expected to work anymore.
func UnsafeActionEntryFree(a *ActionEntry) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionEntryToGlibNone(a *ActionEntry) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionEntryToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionEntryToGlibFull(a *ActionEntry) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionEntry, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionEntry is invalid from here on
	return _p
}

// ActionGroupInterface wraps GActionGroupInterface
//
// The virtual function table for [type@Gio.ActionGroup].
type ActionGroupInterface struct {
	*actionGroupInterface
}

// actionGroupInterface is the struct that's finalized
type actionGroupInterface struct {
	native *C.GActionGroupInterface
}

// UnsafeActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionGroupInterface) instance() *C.GActionGroupInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionGroupInterfaceFromGlibBorrow is used to convert raw C.GActionGroupInterface pointers to go. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionGroupInterface {
	if p == nil {
		return nil
	}
	return &ActionGroupInterface{&actionGroupInterface{(*C.GActionGroupInterface)(p)}}
}

// UnsafeActionGroupInterfaceFromGlibNone is used to convert raw C.GActionGroupInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibNone(p unsafe.Pointer) *ActionGroupInterface {
	wrapped := UnsafeActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionGroupInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionGroupInterfaceFromGlibFull is used to convert raw C.GActionGroupInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionGroupInterfaceFromGlibFull(p unsafe.Pointer) *ActionGroupInterface {
	wrapped := UnsafeActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionGroupInterface,
		func (intern *actionGroupInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionGroupInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionGroupInterface] is expected to work anymore.
func UnsafeActionGroupInterfaceFree(a *ActionGroupInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionGroupInterfaceToGlibNone(a *ActionGroupInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionGroupInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionGroupInterfaceToGlibFull(a *ActionGroupInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionGroupInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionGroupInterface is invalid from here on
	return _p
}

// ActionInterface wraps GActionInterface
//
// The virtual function table for [type@Gio.Action].
type ActionInterface struct {
	*actionInterface
}

// actionInterface is the struct that's finalized
type actionInterface struct {
	native *C.GActionInterface
}

// UnsafeActionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionInterface) instance() *C.GActionInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionInterfaceFromGlibBorrow is used to convert raw C.GActionInterface pointers to go. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionInterface {
	if p == nil {
		return nil
	}
	return &ActionInterface{&actionInterface{(*C.GActionInterface)(p)}}
}

// UnsafeActionInterfaceFromGlibNone is used to convert raw C.GActionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibNone(p unsafe.Pointer) *ActionInterface {
	wrapped := UnsafeActionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionInterfaceFromGlibFull is used to convert raw C.GActionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionInterfaceFromGlibFull(p unsafe.Pointer) *ActionInterface {
	wrapped := UnsafeActionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionInterface,
		func (intern *actionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionInterface] is expected to work anymore.
func UnsafeActionInterfaceFree(a *ActionInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionInterfaceToGlibNone(a *ActionInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionInterfaceToGlibFull(a *ActionInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionInterface is invalid from here on
	return _p
}

// ActionMapInterface wraps GActionMapInterface
//
// The virtual function table for [iface@Gio.ActionMap].
type ActionMapInterface struct {
	*actionMapInterface
}

// actionMapInterface is the struct that's finalized
type actionMapInterface struct {
	native *C.GActionMapInterface
}

// UnsafeActionMapInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ActionMapInterface) instance() *C.GActionMapInterface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeActionMapInterfaceFromGlibBorrow is used to convert raw C.GActionMapInterface pointers to go. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibBorrow(p unsafe.Pointer) *ActionMapInterface {
	if p == nil {
		return nil
	}
	return &ActionMapInterface{&actionMapInterface{(*C.GActionMapInterface)(p)}}
}

// UnsafeActionMapInterfaceFromGlibNone is used to convert raw C.GActionMapInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibNone(p unsafe.Pointer) *ActionMapInterface {
	wrapped := UnsafeActionMapInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ActionMapInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeActionMapInterfaceFromGlibFull is used to convert raw C.GActionMapInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeActionMapInterfaceFromGlibFull(p unsafe.Pointer) *ActionMapInterface {
	wrapped := UnsafeActionMapInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.actionMapInterface,
		func (intern *actionMapInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeActionMapInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ActionMapInterface] is expected to work anymore.
func UnsafeActionMapInterfaceFree(a *ActionMapInterface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeActionMapInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeActionMapInterfaceToGlibNone(a *ActionMapInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeActionMapInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeActionMapInterfaceToGlibFull(a *ActionMapInterface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.actionMapInterface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // ActionMapInterface is invalid from here on
	return _p
}

// AppInfoIface wraps GAppInfoIface
//
// Application Information interface, for operating system portability.
type AppInfoIface struct {
	*appInfoIface
}

// appInfoIface is the struct that's finalized
type appInfoIface struct {
	native *C.GAppInfoIface
}

// UnsafeAppInfoIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AppInfoIface) instance() *C.GAppInfoIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAppInfoIfaceFromGlibBorrow is used to convert raw C.GAppInfoIface pointers to go. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibBorrow(p unsafe.Pointer) *AppInfoIface {
	if p == nil {
		return nil
	}
	return &AppInfoIface{&appInfoIface{(*C.GAppInfoIface)(p)}}
}

// UnsafeAppInfoIfaceFromGlibNone is used to convert raw C.GAppInfoIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibNone(p unsafe.Pointer) *AppInfoIface {
	wrapped := UnsafeAppInfoIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AppInfoIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAppInfoIfaceFromGlibFull is used to convert raw C.GAppInfoIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAppInfoIfaceFromGlibFull(p unsafe.Pointer) *AppInfoIface {
	wrapped := UnsafeAppInfoIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.appInfoIface,
		func (intern *appInfoIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAppInfoIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AppInfoIface] is expected to work anymore.
func UnsafeAppInfoIfaceFree(a *AppInfoIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAppInfoIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAppInfoIfaceToGlibNone(a *AppInfoIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAppInfoIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAppInfoIfaceToGlibFull(a *AppInfoIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.appInfoIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AppInfoIface is invalid from here on
	return _p
}

// AppLaunchContextClass wraps GAppLaunchContextClass
// 
// AppLaunchContextClass is the type struct for [AppLaunchContext]
type AppLaunchContextClass struct {
	*appLaunchContextClass
}

// appLaunchContextClass is the struct that's finalized
type appLaunchContextClass struct {
	native *C.GAppLaunchContextClass
}

// UnsafeAppLaunchContextClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AppLaunchContextClass) instance() *C.GAppLaunchContextClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAppLaunchContextClassFromGlibBorrow is used to convert raw C.GAppLaunchContextClass pointers to go. This is used by the bindings internally.
func UnsafeAppLaunchContextClassFromGlibBorrow(p unsafe.Pointer) *AppLaunchContextClass {
	if p == nil {
		return nil
	}
	return &AppLaunchContextClass{&appLaunchContextClass{(*C.GAppLaunchContextClass)(p)}}
}

// UnsafeAppLaunchContextClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AppLaunchContextClass] is expected to work anymore.
func UnsafeAppLaunchContextClassFree(a *AppLaunchContextClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAppLaunchContextClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAppLaunchContextClassToGlibNone(a *AppLaunchContextClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *AppLaunchContextClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeAppLaunchContextClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *AppLaunchContextClass) {}, a)
	return parent
}

// ApplicationClass wraps GApplicationClass
//
// Virtual function table for #GApplication.
// 
// ApplicationClass is the type struct for [Application]
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized
type applicationClass struct {
	native *C.GApplicationClass
}

// UnsafeApplicationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ApplicationClass) instance() *C.GApplicationClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeApplicationClassFromGlibBorrow is used to convert raw C.GApplicationClass pointers to go. This is used by the bindings internally.
func UnsafeApplicationClassFromGlibBorrow(p unsafe.Pointer) *ApplicationClass {
	if p == nil {
		return nil
	}
	return &ApplicationClass{&applicationClass{(*C.GApplicationClass)(p)}}
}

// UnsafeApplicationClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ApplicationClass] is expected to work anymore.
func UnsafeApplicationClassFree(a *ApplicationClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeApplicationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeApplicationClassToGlibNone(a *ApplicationClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *ApplicationClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeApplicationClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ApplicationClass) {}, a)
	return parent
}

// ApplicationCommandLineClass wraps GApplicationCommandLineClass
//
// The #GApplicationCommandLineClass-struct
// contains private data only.
// 
// ApplicationCommandLineClass is the type struct for [ApplicationCommandLine]
type ApplicationCommandLineClass struct {
	*applicationCommandLineClass
}

// applicationCommandLineClass is the struct that's finalized
type applicationCommandLineClass struct {
	native *C.GApplicationCommandLineClass
}

// UnsafeApplicationCommandLineClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *ApplicationCommandLineClass) instance() *C.GApplicationCommandLineClass {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeApplicationCommandLineClassFromGlibBorrow is used to convert raw C.GApplicationCommandLineClass pointers to go. This is used by the bindings internally.
func UnsafeApplicationCommandLineClassFromGlibBorrow(p unsafe.Pointer) *ApplicationCommandLineClass {
	if p == nil {
		return nil
	}
	return &ApplicationCommandLineClass{&applicationCommandLineClass{(*C.GApplicationCommandLineClass)(p)}}
}

// UnsafeApplicationCommandLineClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ApplicationCommandLineClass] is expected to work anymore.
func UnsafeApplicationCommandLineClassFree(a *ApplicationCommandLineClass) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeApplicationCommandLineClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeApplicationCommandLineClassToGlibNone(a *ApplicationCommandLineClass) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (a *ApplicationCommandLineClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeApplicationCommandLineClassToGlibNone(a))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ApplicationCommandLineClass) {}, a)
	return parent
}

// AsyncInitableIface wraps GAsyncInitableIface
//
// Provides an interface for asynchronous initializing object such that
// initialization may fail.
type AsyncInitableIface struct {
	*asyncInitableIface
}

// asyncInitableIface is the struct that's finalized
type asyncInitableIface struct {
	native *C.GAsyncInitableIface
}

// UnsafeAsyncInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncInitableIface) instance() *C.GAsyncInitableIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncInitableIfaceFromGlibBorrow is used to convert raw C.GAsyncInitableIface pointers to go. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibBorrow(p unsafe.Pointer) *AsyncInitableIface {
	if p == nil {
		return nil
	}
	return &AsyncInitableIface{&asyncInitableIface{(*C.GAsyncInitableIface)(p)}}
}

// UnsafeAsyncInitableIfaceFromGlibNone is used to convert raw C.GAsyncInitableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibNone(p unsafe.Pointer) *AsyncInitableIface {
	wrapped := UnsafeAsyncInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AsyncInitableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAsyncInitableIfaceFromGlibFull is used to convert raw C.GAsyncInitableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceFromGlibFull(p unsafe.Pointer) *AsyncInitableIface {
	wrapped := UnsafeAsyncInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncInitableIface,
		func (intern *asyncInitableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAsyncInitableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncInitableIface] is expected to work anymore.
func UnsafeAsyncInitableIfaceFree(a *AsyncInitableIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAsyncInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncInitableIfaceToGlibNone(a *AsyncInitableIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncInitableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncInitableIfaceToGlibFull(a *AsyncInitableIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncInitableIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncInitableIface is invalid from here on
	return _p
}

// AsyncResultIface wraps GAsyncResultIface
//
// Interface definition for [iface@Gio.AsyncResult].
type AsyncResultIface struct {
	*asyncResultIface
}

// asyncResultIface is the struct that's finalized
type asyncResultIface struct {
	native *C.GAsyncResultIface
}

// UnsafeAsyncResultIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncResultIface) instance() *C.GAsyncResultIface {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncResultIfaceFromGlibBorrow is used to convert raw C.GAsyncResultIface pointers to go. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibBorrow(p unsafe.Pointer) *AsyncResultIface {
	if p == nil {
		return nil
	}
	return &AsyncResultIface{&asyncResultIface{(*C.GAsyncResultIface)(p)}}
}

// UnsafeAsyncResultIfaceFromGlibNone is used to convert raw C.GAsyncResultIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibNone(p unsafe.Pointer) *AsyncResultIface {
	wrapped := UnsafeAsyncResultIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to AsyncResultIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeAsyncResultIfaceFromGlibFull is used to convert raw C.GAsyncResultIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncResultIfaceFromGlibFull(p unsafe.Pointer) *AsyncResultIface {
	wrapped := UnsafeAsyncResultIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncResultIface,
		func (intern *asyncResultIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeAsyncResultIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncResultIface] is expected to work anymore.
func UnsafeAsyncResultIfaceFree(a *AsyncResultIface) {
	C.free(unsafe.Pointer(a.native))
}

// UnsafeAsyncResultIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncResultIfaceToGlibNone(a *AsyncResultIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncResultIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncResultIfaceToGlibFull(a *AsyncResultIface) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncResultIface, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncResultIface is invalid from here on
	return _p
}

// BufferedInputStreamClass wraps GBufferedInputStreamClass
// 
// BufferedInputStreamClass is the type struct for [BufferedInputStream]
type BufferedInputStreamClass struct {
	*bufferedInputStreamClass
}

// bufferedInputStreamClass is the struct that's finalized
type bufferedInputStreamClass struct {
	native *C.GBufferedInputStreamClass
}

// UnsafeBufferedInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BufferedInputStreamClass) instance() *C.GBufferedInputStreamClass {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBufferedInputStreamClassFromGlibBorrow is used to convert raw C.GBufferedInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeBufferedInputStreamClassFromGlibBorrow(p unsafe.Pointer) *BufferedInputStreamClass {
	if p == nil {
		return nil
	}
	return &BufferedInputStreamClass{&bufferedInputStreamClass{(*C.GBufferedInputStreamClass)(p)}}
}

// UnsafeBufferedInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BufferedInputStreamClass] is expected to work anymore.
func UnsafeBufferedInputStreamClassFree(b *BufferedInputStreamClass) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeBufferedInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBufferedInputStreamClassToGlibNone(b *BufferedInputStreamClass) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (b *BufferedInputStreamClass) ParentClass() *FilterInputStreamClass {
	parent := UnsafeFilterInputStreamClassFromGlibBorrow(UnsafeBufferedInputStreamClassToGlibNone(b))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *BufferedInputStreamClass) {}, b)
	return parent
}

// BufferedOutputStreamClass wraps GBufferedOutputStreamClass
// 
// BufferedOutputStreamClass is the type struct for [BufferedOutputStream]
type BufferedOutputStreamClass struct {
	*bufferedOutputStreamClass
}

// bufferedOutputStreamClass is the struct that's finalized
type bufferedOutputStreamClass struct {
	native *C.GBufferedOutputStreamClass
}

// UnsafeBufferedOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BufferedOutputStreamClass) instance() *C.GBufferedOutputStreamClass {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBufferedOutputStreamClassFromGlibBorrow is used to convert raw C.GBufferedOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeBufferedOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *BufferedOutputStreamClass {
	if p == nil {
		return nil
	}
	return &BufferedOutputStreamClass{&bufferedOutputStreamClass{(*C.GBufferedOutputStreamClass)(p)}}
}

// UnsafeBufferedOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BufferedOutputStreamClass] is expected to work anymore.
func UnsafeBufferedOutputStreamClassFree(b *BufferedOutputStreamClass) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeBufferedOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBufferedOutputStreamClassToGlibNone(b *BufferedOutputStreamClass) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (b *BufferedOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeBufferedOutputStreamClassToGlibNone(b))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *BufferedOutputStreamClass) {}, b)
	return parent
}

// CancellableClass wraps GCancellableClass
// 
// CancellableClass is the type struct for [Cancellable]
type CancellableClass struct {
	*cancellableClass
}

// cancellableClass is the struct that's finalized
type cancellableClass struct {
	native *C.GCancellableClass
}

// UnsafeCancellableClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CancellableClass) instance() *C.GCancellableClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCancellableClassFromGlibBorrow is used to convert raw C.GCancellableClass pointers to go. This is used by the bindings internally.
func UnsafeCancellableClassFromGlibBorrow(p unsafe.Pointer) *CancellableClass {
	if p == nil {
		return nil
	}
	return &CancellableClass{&cancellableClass{(*C.GCancellableClass)(p)}}
}

// UnsafeCancellableClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CancellableClass] is expected to work anymore.
func UnsafeCancellableClassFree(c *CancellableClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCancellableClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCancellableClassToGlibNone(c *CancellableClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CancellableClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCancellableClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CancellableClass) {}, c)
	return parent
}

// CharsetConverterClass wraps GCharsetConverterClass
// 
// CharsetConverterClass is the type struct for [CharsetConverter]
type CharsetConverterClass struct {
	*charsetConverterClass
}

// charsetConverterClass is the struct that's finalized
type charsetConverterClass struct {
	native *C.GCharsetConverterClass
}

// UnsafeCharsetConverterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CharsetConverterClass) instance() *C.GCharsetConverterClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCharsetConverterClassFromGlibBorrow is used to convert raw C.GCharsetConverterClass pointers to go. This is used by the bindings internally.
func UnsafeCharsetConverterClassFromGlibBorrow(p unsafe.Pointer) *CharsetConverterClass {
	if p == nil {
		return nil
	}
	return &CharsetConverterClass{&charsetConverterClass{(*C.GCharsetConverterClass)(p)}}
}

// UnsafeCharsetConverterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CharsetConverterClass] is expected to work anymore.
func UnsafeCharsetConverterClassFree(c *CharsetConverterClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCharsetConverterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCharsetConverterClassToGlibNone(c *CharsetConverterClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CharsetConverterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCharsetConverterClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CharsetConverterClass) {}, c)
	return parent
}

// ConverterIface wraps GConverterIface
//
// Provides an interface for converting data from one type
// to another type. The conversion can be stateful
// and may fail at any place.
type ConverterIface struct {
	*converterIface
}

// converterIface is the struct that's finalized
type converterIface struct {
	native *C.GConverterIface
}

// UnsafeConverterIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterIface) instance() *C.GConverterIface {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterIfaceFromGlibBorrow is used to convert raw C.GConverterIface pointers to go. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibBorrow(p unsafe.Pointer) *ConverterIface {
	if p == nil {
		return nil
	}
	return &ConverterIface{&converterIface{(*C.GConverterIface)(p)}}
}

// UnsafeConverterIfaceFromGlibNone is used to convert raw C.GConverterIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibNone(p unsafe.Pointer) *ConverterIface {
	wrapped := UnsafeConverterIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ConverterIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeConverterIfaceFromGlibFull is used to convert raw C.GConverterIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeConverterIfaceFromGlibFull(p unsafe.Pointer) *ConverterIface {
	wrapped := UnsafeConverterIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.converterIface,
		func (intern *converterIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeConverterIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterIface] is expected to work anymore.
func UnsafeConverterIfaceFree(c *ConverterIface) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterIfaceToGlibNone(c *ConverterIface) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeConverterIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeConverterIfaceToGlibFull(c *ConverterIface) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.converterIface, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // ConverterIface is invalid from here on
	return _p
}

// ConverterInputStreamClass wraps GConverterInputStreamClass
// 
// ConverterInputStreamClass is the type struct for [ConverterInputStream]
type ConverterInputStreamClass struct {
	*converterInputStreamClass
}

// converterInputStreamClass is the struct that's finalized
type converterInputStreamClass struct {
	native *C.GConverterInputStreamClass
}

// UnsafeConverterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterInputStreamClass) instance() *C.GConverterInputStreamClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterInputStreamClassFromGlibBorrow is used to convert raw C.GConverterInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeConverterInputStreamClassFromGlibBorrow(p unsafe.Pointer) *ConverterInputStreamClass {
	if p == nil {
		return nil
	}
	return &ConverterInputStreamClass{&converterInputStreamClass{(*C.GConverterInputStreamClass)(p)}}
}

// UnsafeConverterInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterInputStreamClass] is expected to work anymore.
func UnsafeConverterInputStreamClassFree(c *ConverterInputStreamClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterInputStreamClassToGlibNone(c *ConverterInputStreamClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *ConverterInputStreamClass) ParentClass() *FilterInputStreamClass {
	parent := UnsafeFilterInputStreamClassFromGlibBorrow(UnsafeConverterInputStreamClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ConverterInputStreamClass) {}, c)
	return parent
}

// ConverterOutputStreamClass wraps GConverterOutputStreamClass
// 
// ConverterOutputStreamClass is the type struct for [ConverterOutputStream]
type ConverterOutputStreamClass struct {
	*converterOutputStreamClass
}

// converterOutputStreamClass is the struct that's finalized
type converterOutputStreamClass struct {
	native *C.GConverterOutputStreamClass
}

// UnsafeConverterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ConverterOutputStreamClass) instance() *C.GConverterOutputStreamClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeConverterOutputStreamClassFromGlibBorrow is used to convert raw C.GConverterOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeConverterOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *ConverterOutputStreamClass {
	if p == nil {
		return nil
	}
	return &ConverterOutputStreamClass{&converterOutputStreamClass{(*C.GConverterOutputStreamClass)(p)}}
}

// UnsafeConverterOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ConverterOutputStreamClass] is expected to work anymore.
func UnsafeConverterOutputStreamClassFree(c *ConverterOutputStreamClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeConverterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeConverterOutputStreamClassToGlibNone(c *ConverterOutputStreamClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *ConverterOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeConverterOutputStreamClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ConverterOutputStreamClass) {}, c)
	return parent
}

// CredentialsClass wraps GCredentialsClass
//
// Class structure for #GCredentials.
// 
// CredentialsClass is the type struct for [Credentials]
type CredentialsClass struct {
	*credentialsClass
}

// credentialsClass is the struct that's finalized
type credentialsClass struct {
	native *C.GCredentialsClass
}

// UnsafeCredentialsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CredentialsClass) instance() *C.GCredentialsClass {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCredentialsClassFromGlibBorrow is used to convert raw C.GCredentialsClass pointers to go. This is used by the bindings internally.
func UnsafeCredentialsClassFromGlibBorrow(p unsafe.Pointer) *CredentialsClass {
	if p == nil {
		return nil
	}
	return &CredentialsClass{&credentialsClass{(*C.GCredentialsClass)(p)}}
}

// UnsafeCredentialsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CredentialsClass] is expected to work anymore.
func UnsafeCredentialsClassFree(c *CredentialsClass) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCredentialsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCredentialsClassToGlibNone(c *CredentialsClass) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (c *CredentialsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeCredentialsClassToGlibNone(c))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *CredentialsClass) {}, c)
	return parent
}

// DataInputStreamClass wraps GDataInputStreamClass
// 
// DataInputStreamClass is the type struct for [DataInputStream]
type DataInputStreamClass struct {
	*dataInputStreamClass
}

// dataInputStreamClass is the struct that's finalized
type dataInputStreamClass struct {
	native *C.GDataInputStreamClass
}

// UnsafeDataInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DataInputStreamClass) instance() *C.GDataInputStreamClass {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataInputStreamClassFromGlibBorrow is used to convert raw C.GDataInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeDataInputStreamClassFromGlibBorrow(p unsafe.Pointer) *DataInputStreamClass {
	if p == nil {
		return nil
	}
	return &DataInputStreamClass{&dataInputStreamClass{(*C.GDataInputStreamClass)(p)}}
}

// UnsafeDataInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DataInputStreamClass] is expected to work anymore.
func UnsafeDataInputStreamClassFree(d *DataInputStreamClass) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataInputStreamClassToGlibNone(d *DataInputStreamClass) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (d *DataInputStreamClass) ParentClass() *BufferedInputStreamClass {
	parent := UnsafeBufferedInputStreamClassFromGlibBorrow(UnsafeDataInputStreamClassToGlibNone(d))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *DataInputStreamClass) {}, d)
	return parent
}

// DataOutputStreamClass wraps GDataOutputStreamClass
// 
// DataOutputStreamClass is the type struct for [DataOutputStream]
type DataOutputStreamClass struct {
	*dataOutputStreamClass
}

// dataOutputStreamClass is the struct that's finalized
type dataOutputStreamClass struct {
	native *C.GDataOutputStreamClass
}

// UnsafeDataOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DataOutputStreamClass) instance() *C.GDataOutputStreamClass {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataOutputStreamClassFromGlibBorrow is used to convert raw C.GDataOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeDataOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *DataOutputStreamClass {
	if p == nil {
		return nil
	}
	return &DataOutputStreamClass{&dataOutputStreamClass{(*C.GDataOutputStreamClass)(p)}}
}

// UnsafeDataOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DataOutputStreamClass] is expected to work anymore.
func UnsafeDataOutputStreamClassFree(d *DataOutputStreamClass) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataOutputStreamClassToGlibNone(d *DataOutputStreamClass) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (d *DataOutputStreamClass) ParentClass() *FilterOutputStreamClass {
	parent := UnsafeFilterOutputStreamClassFromGlibBorrow(UnsafeDataOutputStreamClassToGlibNone(d))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *DataOutputStreamClass) {}, d)
	return parent
}

// DatagramBasedInterface wraps GDatagramBasedInterface
//
// Provides an interface for socket-like objects which have datagram semantics,
// following the Berkeley sockets API. The interface methods are thin wrappers
// around the corresponding virtual methods, and no pre-processing of inputs is
// implemented &#x2014; so implementations of this API must handle all functionality
// documented in the interface methods.
type DatagramBasedInterface struct {
	*datagramBasedInterface
}

// datagramBasedInterface is the struct that's finalized
type datagramBasedInterface struct {
	native *C.GDatagramBasedInterface
}

// UnsafeDatagramBasedInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DatagramBasedInterface) instance() *C.GDatagramBasedInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDatagramBasedInterfaceFromGlibBorrow is used to convert raw C.GDatagramBasedInterface pointers to go. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibBorrow(p unsafe.Pointer) *DatagramBasedInterface {
	if p == nil {
		return nil
	}
	return &DatagramBasedInterface{&datagramBasedInterface{(*C.GDatagramBasedInterface)(p)}}
}

// UnsafeDatagramBasedInterfaceFromGlibNone is used to convert raw C.GDatagramBasedInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibNone(p unsafe.Pointer) *DatagramBasedInterface {
	wrapped := UnsafeDatagramBasedInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DatagramBasedInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDatagramBasedInterfaceFromGlibFull is used to convert raw C.GDatagramBasedInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceFromGlibFull(p unsafe.Pointer) *DatagramBasedInterface {
	wrapped := UnsafeDatagramBasedInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.datagramBasedInterface,
		func (intern *datagramBasedInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDatagramBasedInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DatagramBasedInterface] is expected to work anymore.
func UnsafeDatagramBasedInterfaceFree(d *DatagramBasedInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDatagramBasedInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceToGlibNone(d *DatagramBasedInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDatagramBasedInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDatagramBasedInterfaceToGlibFull(d *DatagramBasedInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.datagramBasedInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DatagramBasedInterface is invalid from here on
	return _p
}

// DebugControllerInterface wraps GDebugControllerInterface
//
// The virtual function table for #GDebugController.
type DebugControllerInterface struct {
	*debugControllerInterface
}

// debugControllerInterface is the struct that's finalized
type debugControllerInterface struct {
	native *C.GDebugControllerInterface
}

// UnsafeDebugControllerInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DebugControllerInterface) instance() *C.GDebugControllerInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDebugControllerInterfaceFromGlibBorrow is used to convert raw C.GDebugControllerInterface pointers to go. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibBorrow(p unsafe.Pointer) *DebugControllerInterface {
	if p == nil {
		return nil
	}
	return &DebugControllerInterface{&debugControllerInterface{(*C.GDebugControllerInterface)(p)}}
}

// UnsafeDebugControllerInterfaceFromGlibNone is used to convert raw C.GDebugControllerInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibNone(p unsafe.Pointer) *DebugControllerInterface {
	wrapped := UnsafeDebugControllerInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DebugControllerInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDebugControllerInterfaceFromGlibFull is used to convert raw C.GDebugControllerInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceFromGlibFull(p unsafe.Pointer) *DebugControllerInterface {
	wrapped := UnsafeDebugControllerInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.debugControllerInterface,
		func (intern *debugControllerInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDebugControllerInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DebugControllerInterface] is expected to work anymore.
func UnsafeDebugControllerInterfaceFree(d *DebugControllerInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDebugControllerInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDebugControllerInterfaceToGlibNone(d *DebugControllerInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDebugControllerInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDebugControllerInterfaceToGlibFull(d *DebugControllerInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.debugControllerInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DebugControllerInterface is invalid from here on
	return _p
}

// DriveIface wraps GDriveIface
//
// Interface for creating #GDrive implementations.
type DriveIface struct {
	*driveIface
}

// driveIface is the struct that's finalized
type driveIface struct {
	native *C.GDriveIface
}

// UnsafeDriveIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DriveIface) instance() *C.GDriveIface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDriveIfaceFromGlibBorrow is used to convert raw C.GDriveIface pointers to go. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibBorrow(p unsafe.Pointer) *DriveIface {
	if p == nil {
		return nil
	}
	return &DriveIface{&driveIface{(*C.GDriveIface)(p)}}
}

// UnsafeDriveIfaceFromGlibNone is used to convert raw C.GDriveIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibNone(p unsafe.Pointer) *DriveIface {
	wrapped := UnsafeDriveIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DriveIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDriveIfaceFromGlibFull is used to convert raw C.GDriveIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDriveIfaceFromGlibFull(p unsafe.Pointer) *DriveIface {
	wrapped := UnsafeDriveIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.driveIface,
		func (intern *driveIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDriveIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DriveIface] is expected to work anymore.
func UnsafeDriveIfaceFree(d *DriveIface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDriveIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDriveIfaceToGlibNone(d *DriveIface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDriveIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDriveIfaceToGlibFull(d *DriveIface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.driveIface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DriveIface is invalid from here on
	return _p
}

// DtlsClientConnectionInterface wraps GDtlsClientConnectionInterface
//
// vtable for a #GDtlsClientConnection implementation.
type DtlsClientConnectionInterface struct {
	*dtlsClientConnectionInterface
}

// dtlsClientConnectionInterface is the struct that's finalized
type dtlsClientConnectionInterface struct {
	native *C.GDtlsClientConnectionInterface
}

// UnsafeDtlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsClientConnectionInterface) instance() *C.GDtlsClientConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsClientConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsClientConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsClientConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsClientConnectionInterface{&dtlsClientConnectionInterface{(*C.GDtlsClientConnectionInterface)(p)}}
}

// UnsafeDtlsClientConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsClientConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsClientConnectionInterface {
	wrapped := UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsClientConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsClientConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsClientConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsClientConnectionInterface {
	wrapped := UnsafeDtlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsClientConnectionInterface,
		func (intern *dtlsClientConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsClientConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsClientConnectionInterface] is expected to work anymore.
func UnsafeDtlsClientConnectionInterfaceFree(d *DtlsClientConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceToGlibNone(d *DtlsClientConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsClientConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsClientConnectionInterfaceToGlibFull(d *DtlsClientConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsClientConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsClientConnectionInterface is invalid from here on
	return _p
}

// DtlsConnectionInterface wraps GDtlsConnectionInterface
//
// Virtual method table for a #GDtlsConnection implementation.
type DtlsConnectionInterface struct {
	*dtlsConnectionInterface
}

// dtlsConnectionInterface is the struct that's finalized
type dtlsConnectionInterface struct {
	native *C.GDtlsConnectionInterface
}

// UnsafeDtlsConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsConnectionInterface) instance() *C.GDtlsConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsConnectionInterface{&dtlsConnectionInterface{(*C.GDtlsConnectionInterface)(p)}}
}

// UnsafeDtlsConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsConnectionInterface {
	wrapped := UnsafeDtlsConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsConnectionInterface {
	wrapped := UnsafeDtlsConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsConnectionInterface,
		func (intern *dtlsConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsConnectionInterface] is expected to work anymore.
func UnsafeDtlsConnectionInterfaceFree(d *DtlsConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceToGlibNone(d *DtlsConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsConnectionInterfaceToGlibFull(d *DtlsConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsConnectionInterface is invalid from here on
	return _p
}

// DtlsServerConnectionInterface wraps GDtlsServerConnectionInterface
//
// vtable for a #GDtlsServerConnection implementation.
type DtlsServerConnectionInterface struct {
	*dtlsServerConnectionInterface
}

// dtlsServerConnectionInterface is the struct that's finalized
type dtlsServerConnectionInterface struct {
	native *C.GDtlsServerConnectionInterface
}

// UnsafeDtlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DtlsServerConnectionInterface) instance() *C.GDtlsServerConnectionInterface {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDtlsServerConnectionInterfaceFromGlibBorrow is used to convert raw C.GDtlsServerConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *DtlsServerConnectionInterface {
	if p == nil {
		return nil
	}
	return &DtlsServerConnectionInterface{&dtlsServerConnectionInterface{(*C.GDtlsServerConnectionInterface)(p)}}
}

// UnsafeDtlsServerConnectionInterfaceFromGlibNone is used to convert raw C.GDtlsServerConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibNone(p unsafe.Pointer) *DtlsServerConnectionInterface {
	wrapped := UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DtlsServerConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDtlsServerConnectionInterfaceFromGlibFull is used to convert raw C.GDtlsServerConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceFromGlibFull(p unsafe.Pointer) *DtlsServerConnectionInterface {
	wrapped := UnsafeDtlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dtlsServerConnectionInterface,
		func (intern *dtlsServerConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDtlsServerConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DtlsServerConnectionInterface] is expected to work anymore.
func UnsafeDtlsServerConnectionInterfaceFree(d *DtlsServerConnectionInterface) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDtlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceToGlibNone(d *DtlsServerConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDtlsServerConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDtlsServerConnectionInterfaceToGlibFull(d *DtlsServerConnectionInterface) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dtlsServerConnectionInterface, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DtlsServerConnectionInterface is invalid from here on
	return _p
}

// EmblemClass wraps GEmblemClass
// 
// EmblemClass is the type struct for [Emblem]
type EmblemClass struct {
	*emblemClass
}

// emblemClass is the struct that's finalized
type emblemClass struct {
	native *C.GEmblemClass
}

// UnsafeEmblemClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EmblemClass) instance() *C.GEmblemClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEmblemClassFromGlibBorrow is used to convert raw C.GEmblemClass pointers to go. This is used by the bindings internally.
func UnsafeEmblemClassFromGlibBorrow(p unsafe.Pointer) *EmblemClass {
	if p == nil {
		return nil
	}
	return &EmblemClass{&emblemClass{(*C.GEmblemClass)(p)}}
}

// UnsafeEmblemClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EmblemClass] is expected to work anymore.
func UnsafeEmblemClassFree(e *EmblemClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEmblemClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEmblemClassToGlibNone(e *EmblemClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (e *EmblemClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeEmblemClassToGlibNone(e))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *EmblemClass) {}, e)
	return parent
}

// EmblemedIconClass wraps GEmblemedIconClass
// 
// EmblemedIconClass is the type struct for [EmblemedIcon]
type EmblemedIconClass struct {
	*emblemedIconClass
}

// emblemedIconClass is the struct that's finalized
type emblemedIconClass struct {
	native *C.GEmblemedIconClass
}

// UnsafeEmblemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EmblemedIconClass) instance() *C.GEmblemedIconClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEmblemedIconClassFromGlibBorrow is used to convert raw C.GEmblemedIconClass pointers to go. This is used by the bindings internally.
func UnsafeEmblemedIconClassFromGlibBorrow(p unsafe.Pointer) *EmblemedIconClass {
	if p == nil {
		return nil
	}
	return &EmblemedIconClass{&emblemedIconClass{(*C.GEmblemedIconClass)(p)}}
}

// UnsafeEmblemedIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EmblemedIconClass] is expected to work anymore.
func UnsafeEmblemedIconClassFree(e *EmblemedIconClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEmblemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEmblemedIconClassToGlibNone(e *EmblemedIconClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (e *EmblemedIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeEmblemedIconClassToGlibNone(e))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *EmblemedIconClass) {}, e)
	return parent
}

// FileAttributeInfo wraps GFileAttributeInfo
//
// Information about a specific attribute.
type FileAttributeInfo struct {
	*fileAttributeInfo
}

// fileAttributeInfo is the struct that's finalized
type fileAttributeInfo struct {
	native *C.GFileAttributeInfo
}

// UnsafeFileAttributeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeInfo) instance() *C.GFileAttributeInfo {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileAttributeInfoFromGlibBorrow is used to convert raw C.GFileAttributeInfo pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibBorrow(p unsafe.Pointer) *FileAttributeInfo {
	if p == nil {
		return nil
	}
	return &FileAttributeInfo{&fileAttributeInfo{(*C.GFileAttributeInfo)(p)}}
}

// UnsafeFileAttributeInfoFromGlibNone is used to convert raw C.GFileAttributeInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibNone(p unsafe.Pointer) *FileAttributeInfo {
	wrapped := UnsafeFileAttributeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FileAttributeInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFileAttributeInfoFromGlibFull is used to convert raw C.GFileAttributeInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoFromGlibFull(p unsafe.Pointer) *FileAttributeInfo {
	wrapped := UnsafeFileAttributeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeInfo,
		func (intern *fileAttributeInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeInfo] is expected to work anymore.
func UnsafeFileAttributeInfoFree(f *FileAttributeInfo) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileAttributeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeInfoToGlibNone(f *FileAttributeInfo) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeInfoToGlibFull(f *FileAttributeInfo) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeInfo, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeInfo is invalid from here on
	return _p
}

// FileAttributeInfoList wraps GFileAttributeInfoList
//
// Acts as a lightweight registry for possible valid file attributes.
// The registry stores Key-Value pair formats as #GFileAttributeInfos.
type FileAttributeInfoList struct {
	*fileAttributeInfoList
}

// fileAttributeInfoList is the struct that's finalized
type fileAttributeInfoList struct {
	native *C.GFileAttributeInfoList
}

// UnsafeFileAttributeInfoListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeInfoList) instance() *C.GFileAttributeInfoList {
	if f == nil {
		return nil
	}
	return f.native
}

var _ gobject.GoValueInitializer = (*FileAttributeInfoList)(nil)

func marshalFileAttributeInfoList(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeFileAttributeInfoListFromGlibNone(b), nil
}

func (r *FileAttributeInfoList) GoValueType() gobject.Type {
	return TypeFileAttributeInfoList
}

func (r *FileAttributeInfoList) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeFileAttributeInfoListFromGlibBorrow is used to convert raw C.GFileAttributeInfoList pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibBorrow(p unsafe.Pointer) *FileAttributeInfoList {
	if p == nil {
		return nil
	}
	return &FileAttributeInfoList{&fileAttributeInfoList{(*C.GFileAttributeInfoList)(p)}}
}

// UnsafeFileAttributeInfoListFromGlibNone is used to convert raw C.GFileAttributeInfoList pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibNone(p unsafe.Pointer) *FileAttributeInfoList {
	C.g_file_attribute_info_list_ref((*C.GFileAttributeInfoList)(p))
	wrapped := UnsafeFileAttributeInfoListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.fileAttributeInfoList,
		func (intern *fileAttributeInfoList) {
			C.g_file_attribute_info_list_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoListFromGlibFull is used to convert raw C.GFileAttributeInfoList pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeInfoListFromGlibFull(p unsafe.Pointer) *FileAttributeInfoList {
	wrapped := UnsafeFileAttributeInfoListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeInfoList,
		func (intern *fileAttributeInfoList) {
			C.g_file_attribute_info_list_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeInfoListRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [FileAttributeInfoList.UnsafeFileAttributeInfoListUnref], then [FileAttributeInfoList] will leak memory.
func UnsafeFileAttributeInfoListRef(f *FileAttributeInfoList) {
	C.g_file_attribute_info_list_ref(f.native)
}

// UnsafeFileAttributeInfoListUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeInfoList] is expected to work anymore.
func UnsafeFileAttributeInfoListUnref(f *FileAttributeInfoList) {
	C.g_file_attribute_info_list_unref(f.native)
}

// UnsafeFileAttributeInfoListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeInfoListToGlibNone(f *FileAttributeInfoList) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeInfoListToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeInfoListToGlibFull(f *FileAttributeInfoList) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeInfoList, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeInfoList is invalid from here on
	return _p
}

// NewFileAttributeInfoList wraps g_file_attribute_info_list_new
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeInfoList 
//
// Creates a new file attribute info list.
func NewFileAttributeInfoList() *FileAttributeInfoList {
	var cret *C.GFileAttributeInfoList // return, full, converted

	cret = C.g_file_attribute_info_list_new()

	var goret *FileAttributeInfoList

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Add wraps g_file_attribute_info_list_add
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the attribute to add. 
// 	- typ FileAttributeType: the #GFileAttributeType for the attribute. 
// 	- flags FileAttributeInfoFlags: #GFileAttributeInfoFlags for the attribute. 
//
// Adds a new attribute with @name to the @list, setting
// its @type and @flags.
func (list *FileAttributeInfoList) Add(name string, typ FileAttributeType, flags FileAttributeInfoFlags) {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var carg1 *C.char                   // in, none, string
	var carg2 C.GFileAttributeType      // in, none, casted
	var carg3 C.GFileAttributeInfoFlags // in, none, casted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileAttributeType(typ)
	carg3 = C.GFileAttributeInfoFlags(flags)

	C.g_file_attribute_info_list_add(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)
}

// Dup wraps g_file_attribute_info_list_dup
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeInfoList 
//
// Makes a duplicate of a file attribute info list.
func (list *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var cret  *C.GFileAttributeInfoList // return, full, converted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))

	cret = C.g_file_attribute_info_list_dup(carg0)
	runtime.KeepAlive(list)

	var goret *FileAttributeInfoList

	goret = UnsafeFileAttributeInfoListFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Lookup wraps g_file_attribute_info_list_lookup
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the attribute to look up. 
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeInfo 
//
// Gets the file attribute with the name @name from @list.
func (list *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	var carg0 *C.GFileAttributeInfoList // in, none, converted
	var carg1 *C.char                   // in, none, string
	var cret  *C.GFileAttributeInfo     // return, none, converted

	carg0 = (*C.GFileAttributeInfoList)(UnsafeFileAttributeInfoListToGlibNone(list))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_info_list_lookup(carg0, carg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)

	var goret *FileAttributeInfo

	goret = UnsafeFileAttributeInfoFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// FileAttributeMatcher wraps GFileAttributeMatcher
//
// Determines if a string matches a file attribute.
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized
type fileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

// UnsafeFileAttributeMatcherToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileAttributeMatcher) instance() *C.GFileAttributeMatcher {
	if f == nil {
		return nil
	}
	return f.native
}

var _ gobject.GoValueInitializer = (*FileAttributeMatcher)(nil)

func marshalFileAttributeMatcher(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeFileAttributeMatcherFromGlibNone(b), nil
}

func (r *FileAttributeMatcher) GoValueType() gobject.Type {
	return TypeFileAttributeMatcher
}

func (r *FileAttributeMatcher) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeFileAttributeMatcherFromGlibBorrow is used to convert raw C.GFileAttributeMatcher pointers to go. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibBorrow(p unsafe.Pointer) *FileAttributeMatcher {
	if p == nil {
		return nil
	}
	return &FileAttributeMatcher{&fileAttributeMatcher{(*C.GFileAttributeMatcher)(p)}}
}

// UnsafeFileAttributeMatcherFromGlibNone is used to convert raw C.GFileAttributeMatcher pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibNone(p unsafe.Pointer) *FileAttributeMatcher {
	C.g_file_attribute_matcher_ref((*C.GFileAttributeMatcher)(p))
	wrapped := UnsafeFileAttributeMatcherFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.fileAttributeMatcher,
		func (intern *fileAttributeMatcher) {
			C.g_file_attribute_matcher_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeMatcherFromGlibFull is used to convert raw C.GFileAttributeMatcher pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileAttributeMatcherFromGlibFull(p unsafe.Pointer) *FileAttributeMatcher {
	wrapped := UnsafeFileAttributeMatcherFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileAttributeMatcher,
		func (intern *fileAttributeMatcher) {
			C.g_file_attribute_matcher_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeFileAttributeMatcherRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [FileAttributeMatcher.UnsafeFileAttributeMatcherUnref], then [FileAttributeMatcher] will leak memory.
func UnsafeFileAttributeMatcherRef(f *FileAttributeMatcher) {
	C.g_file_attribute_matcher_ref(f.native)
}

// UnsafeFileAttributeMatcherUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileAttributeMatcher] is expected to work anymore.
func UnsafeFileAttributeMatcherUnref(f *FileAttributeMatcher) {
	C.g_file_attribute_matcher_unref(f.native)
}

// UnsafeFileAttributeMatcherToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileAttributeMatcherToGlibNone(f *FileAttributeMatcher) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileAttributeMatcherToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileAttributeMatcherToGlibFull(f *FileAttributeMatcher) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileAttributeMatcher, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileAttributeMatcher is invalid from here on
	return _p
}

// NewFileAttributeMatcher wraps g_file_attribute_matcher_new
// 
// The function takes the following parameters:
// 
// 	- attributes string: an attribute string to match. 
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeMatcher 
//
// Creates a new file attribute matcher, which matches attributes
// against a given string. #GFileAttributeMatchers are reference
// counted structures, and are created with a reference count of 1. If
// the number of references falls to 0, the #GFileAttributeMatcher is
// automatically destroyed.
// 
// The @attributes string should be formatted with specific keys separated
// from namespaces with a double colon. Several "namespace::key" strings may be
// concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
// The wildcard "*" may be used to match all keys and namespaces, or
// "namespace::*" will match all keys in a given namespace.
// 
// ## Examples of file attribute matcher strings and results
// 
// - `"*"`: matches all attributes.
// - `"standard::is-hidden"`: matches only the key is-hidden in the
//   standard namespace.
// - `"standard::type,unix::*"`: matches the type key in the standard
//   namespace and all keys in the unix namespace.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var carg1 *C.char                  // in, none, string
	var cret  *C.GFileAttributeMatcher // return, full, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_new(carg1)
	runtime.KeepAlive(attributes)

	var goret *FileAttributeMatcher

	goret = UnsafeFileAttributeMatcherFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// EnumerateNamespace wraps g_file_attribute_matcher_enumerate_namespace
// 
// The function takes the following parameters:
// 
// 	- ns string: a string containing a file attribute namespace. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if the matcher will match all of the keys in a given namespace.
// This will always return %TRUE if a wildcard character is in use (e.g. if
// matcher was created with "standard::*" and @ns is "standard", or if matcher was created
// using "*" and namespace is anything.)
// 
// TODO: this is awkwardly worded.
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(ns)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_enumerate_namespace(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(ns)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// EnumerateNext wraps g_file_attribute_matcher_enumerate_next
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the next matched attribute from a #GFileAttributeMatcher.
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var cret  *C.char                  // return, none, string, nullable-string

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))

	cret = C.g_file_attribute_matcher_enumerate_next(carg0)
	runtime.KeepAlive(matcher)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Matches wraps g_file_attribute_matcher_matches
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function
// will always return %TRUE.
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_matches(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MatchesOnly wraps g_file_attribute_matcher_matches_only
// 
// The function takes the following parameters:
// 
// 	- attribute string: a file attribute key. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an attribute matcher only matches a given attribute. Always
// returns %FALSE if "*" was used when creating the matcher.
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.char                  // in, none, string
	var cret  C.gboolean               // return

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_attribute_matcher_matches_only(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Subtract wraps g_file_attribute_matcher_subtract
// 
// The function takes the following parameters:
// 
// 	- subtract *FileAttributeMatcher (nullable): The matcher to subtract 
// 
// The function returns the following values:
// 
// 	- goret *FileAttributeMatcher (nullable) 
//
// Subtracts all attributes of @subtract from @matcher and returns
// a matcher that supports those attributes.
// 
// Note that currently it is not possible to remove a single
// attribute when the @matcher matches the whole namespace - or remove
// a namespace or attribute when the matcher matches everything. This
// is a limitation of the current implementation, but may be fixed
// in the future.
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var carg1 *C.GFileAttributeMatcher // in, none, converted, nullable
	var cret  *C.GFileAttributeMatcher // return, full, converted, nullable

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))
	if subtract != nil {
		carg1 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(subtract))
	}

	cret = C.g_file_attribute_matcher_subtract(carg0, carg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(subtract)

	var goret *FileAttributeMatcher

	if cret != nil {
		goret = UnsafeFileAttributeMatcherFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// String wraps g_file_attribute_matcher_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Prints what the matcher is matching against. The format will be
// equal to the format passed to g_file_attribute_matcher_new().
// The output however, might not be identical, as the matcher may
// decide to use a different order or omit needless parts.
func (matcher *FileAttributeMatcher) String() string {
	var carg0 *C.GFileAttributeMatcher // in, none, converted
	var cret  *C.char                  // return, full, string

	carg0 = (*C.GFileAttributeMatcher)(UnsafeFileAttributeMatcherToGlibNone(matcher))

	cret = C.g_file_attribute_matcher_to_string(carg0)
	runtime.KeepAlive(matcher)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FileEnumeratorClass wraps GFileEnumeratorClass
// 
// FileEnumeratorClass is the type struct for [FileEnumerator]
type FileEnumeratorClass struct {
	*fileEnumeratorClass
}

// fileEnumeratorClass is the struct that's finalized
type fileEnumeratorClass struct {
	native *C.GFileEnumeratorClass
}

// UnsafeFileEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileEnumeratorClass) instance() *C.GFileEnumeratorClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileEnumeratorClassFromGlibBorrow is used to convert raw C.GFileEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeFileEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *FileEnumeratorClass {
	if p == nil {
		return nil
	}
	return &FileEnumeratorClass{&fileEnumeratorClass{(*C.GFileEnumeratorClass)(p)}}
}

// UnsafeFileEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileEnumeratorClass] is expected to work anymore.
func UnsafeFileEnumeratorClassFree(f *FileEnumeratorClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileEnumeratorClassToGlibNone(f *FileEnumeratorClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileEnumeratorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileEnumeratorClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileEnumeratorClass) {}, f)
	return parent
}

// FileIOStreamClass wraps GFileIOStreamClass
// 
// FileIOStreamClass is the type struct for [FileIOStream]
type FileIOStreamClass struct {
	*fileIOStreamClass
}

// fileIOStreamClass is the struct that's finalized
type fileIOStreamClass struct {
	native *C.GFileIOStreamClass
}

// UnsafeFileIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIOStreamClass) instance() *C.GFileIOStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIOStreamClassFromGlibBorrow is used to convert raw C.GFileIOStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileIOStreamClassFromGlibBorrow(p unsafe.Pointer) *FileIOStreamClass {
	if p == nil {
		return nil
	}
	return &FileIOStreamClass{&fileIOStreamClass{(*C.GFileIOStreamClass)(p)}}
}

// UnsafeFileIOStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIOStreamClass] is expected to work anymore.
func UnsafeFileIOStreamClassFree(f *FileIOStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIOStreamClassToGlibNone(f *FileIOStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileIOStreamClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeFileIOStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileIOStreamClass) {}, f)
	return parent
}

// FileIconClass wraps GFileIconClass
// 
// FileIconClass is the type struct for [FileIcon]
type FileIconClass struct {
	*fileIconClass
}

// fileIconClass is the struct that's finalized
type fileIconClass struct {
	native *C.GFileIconClass
}

// UnsafeFileIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIconClass) instance() *C.GFileIconClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIconClassFromGlibBorrow is used to convert raw C.GFileIconClass pointers to go. This is used by the bindings internally.
func UnsafeFileIconClassFromGlibBorrow(p unsafe.Pointer) *FileIconClass {
	if p == nil {
		return nil
	}
	return &FileIconClass{&fileIconClass{(*C.GFileIconClass)(p)}}
}

// UnsafeFileIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIconClass] is expected to work anymore.
func UnsafeFileIconClassFree(f *FileIconClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIconClassToGlibNone(f *FileIconClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileIconClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileIconClass) {}, f)
	return parent
}

// FileIface wraps GFileIface
//
// An interface for writing VFS file handles.
type FileIface struct {
	*fileIface
}

// fileIface is the struct that's finalized
type fileIface struct {
	native *C.GFileIface
}

// UnsafeFileIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileIface) instance() *C.GFileIface {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileIfaceFromGlibBorrow is used to convert raw C.GFileIface pointers to go. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibBorrow(p unsafe.Pointer) *FileIface {
	if p == nil {
		return nil
	}
	return &FileIface{&fileIface{(*C.GFileIface)(p)}}
}

// UnsafeFileIfaceFromGlibNone is used to convert raw C.GFileIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibNone(p unsafe.Pointer) *FileIface {
	wrapped := UnsafeFileIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FileIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFileIfaceFromGlibFull is used to convert raw C.GFileIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFileIfaceFromGlibFull(p unsafe.Pointer) *FileIface {
	wrapped := UnsafeFileIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.fileIface,
		func (intern *fileIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFileIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileIface] is expected to work anymore.
func UnsafeFileIfaceFree(f *FileIface) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileIfaceToGlibNone(f *FileIface) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFileIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFileIfaceToGlibFull(f *FileIface) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.fileIface, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FileIface is invalid from here on
	return _p
}

// FileInfoClass wraps GFileInfoClass
// 
// FileInfoClass is the type struct for [FileInfo]
type FileInfoClass struct {
	*fileInfoClass
}

// fileInfoClass is the struct that's finalized
type fileInfoClass struct {
	native *C.GFileInfoClass
}

// UnsafeFileInfoClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileInfoClass) instance() *C.GFileInfoClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileInfoClassFromGlibBorrow is used to convert raw C.GFileInfoClass pointers to go. This is used by the bindings internally.
func UnsafeFileInfoClassFromGlibBorrow(p unsafe.Pointer) *FileInfoClass {
	if p == nil {
		return nil
	}
	return &FileInfoClass{&fileInfoClass{(*C.GFileInfoClass)(p)}}
}

// UnsafeFileInfoClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileInfoClass] is expected to work anymore.
func UnsafeFileInfoClassFree(f *FileInfoClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileInfoClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileInfoClassToGlibNone(f *FileInfoClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileInfoClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileInfoClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileInfoClass) {}, f)
	return parent
}

// FileInputStreamClass wraps GFileInputStreamClass
// 
// FileInputStreamClass is the type struct for [FileInputStream]
type FileInputStreamClass struct {
	*fileInputStreamClass
}

// fileInputStreamClass is the struct that's finalized
type fileInputStreamClass struct {
	native *C.GFileInputStreamClass
}

// UnsafeFileInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileInputStreamClass) instance() *C.GFileInputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileInputStreamClassFromGlibBorrow is used to convert raw C.GFileInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileInputStreamClassFromGlibBorrow(p unsafe.Pointer) *FileInputStreamClass {
	if p == nil {
		return nil
	}
	return &FileInputStreamClass{&fileInputStreamClass{(*C.GFileInputStreamClass)(p)}}
}

// UnsafeFileInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileInputStreamClass] is expected to work anymore.
func UnsafeFileInputStreamClassFree(f *FileInputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileInputStreamClassToGlibNone(f *FileInputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeFileInputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileInputStreamClass) {}, f)
	return parent
}

// FileMonitorClass wraps GFileMonitorClass
// 
// FileMonitorClass is the type struct for [FileMonitor]
type FileMonitorClass struct {
	*fileMonitorClass
}

// fileMonitorClass is the struct that's finalized
type fileMonitorClass struct {
	native *C.GFileMonitorClass
}

// UnsafeFileMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileMonitorClass) instance() *C.GFileMonitorClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileMonitorClassFromGlibBorrow is used to convert raw C.GFileMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeFileMonitorClassFromGlibBorrow(p unsafe.Pointer) *FileMonitorClass {
	if p == nil {
		return nil
	}
	return &FileMonitorClass{&fileMonitorClass{(*C.GFileMonitorClass)(p)}}
}

// UnsafeFileMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileMonitorClass] is expected to work anymore.
func UnsafeFileMonitorClassFree(f *FileMonitorClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileMonitorClassToGlibNone(f *FileMonitorClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileMonitorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFileMonitorClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileMonitorClass) {}, f)
	return parent
}

// FileOutputStreamClass wraps GFileOutputStreamClass
// 
// FileOutputStreamClass is the type struct for [FileOutputStream]
type FileOutputStreamClass struct {
	*fileOutputStreamClass
}

// fileOutputStreamClass is the struct that's finalized
type fileOutputStreamClass struct {
	native *C.GFileOutputStreamClass
}

// UnsafeFileOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FileOutputStreamClass) instance() *C.GFileOutputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFileOutputStreamClassFromGlibBorrow is used to convert raw C.GFileOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFileOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *FileOutputStreamClass {
	if p == nil {
		return nil
	}
	return &FileOutputStreamClass{&fileOutputStreamClass{(*C.GFileOutputStreamClass)(p)}}
}

// UnsafeFileOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FileOutputStreamClass] is expected to work anymore.
func UnsafeFileOutputStreamClassFree(f *FileOutputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFileOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFileOutputStreamClassToGlibNone(f *FileOutputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FileOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeFileOutputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FileOutputStreamClass) {}, f)
	return parent
}

// FilenameCompleterClass wraps GFilenameCompleterClass
// 
// FilenameCompleterClass is the type struct for [FilenameCompleter]
type FilenameCompleterClass struct {
	*filenameCompleterClass
}

// filenameCompleterClass is the struct that's finalized
type filenameCompleterClass struct {
	native *C.GFilenameCompleterClass
}

// UnsafeFilenameCompleterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilenameCompleterClass) instance() *C.GFilenameCompleterClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilenameCompleterClassFromGlibBorrow is used to convert raw C.GFilenameCompleterClass pointers to go. This is used by the bindings internally.
func UnsafeFilenameCompleterClassFromGlibBorrow(p unsafe.Pointer) *FilenameCompleterClass {
	if p == nil {
		return nil
	}
	return &FilenameCompleterClass{&filenameCompleterClass{(*C.GFilenameCompleterClass)(p)}}
}

// UnsafeFilenameCompleterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilenameCompleterClass] is expected to work anymore.
func UnsafeFilenameCompleterClassFree(f *FilenameCompleterClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilenameCompleterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilenameCompleterClassToGlibNone(f *FilenameCompleterClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilenameCompleterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeFilenameCompleterClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilenameCompleterClass) {}, f)
	return parent
}

// FilterInputStreamClass wraps GFilterInputStreamClass
// 
// FilterInputStreamClass is the type struct for [FilterInputStream]
type FilterInputStreamClass struct {
	*filterInputStreamClass
}

// filterInputStreamClass is the struct that's finalized
type filterInputStreamClass struct {
	native *C.GFilterInputStreamClass
}

// UnsafeFilterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilterInputStreamClass) instance() *C.GFilterInputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilterInputStreamClassFromGlibBorrow is used to convert raw C.GFilterInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFilterInputStreamClassFromGlibBorrow(p unsafe.Pointer) *FilterInputStreamClass {
	if p == nil {
		return nil
	}
	return &FilterInputStreamClass{&filterInputStreamClass{(*C.GFilterInputStreamClass)(p)}}
}

// UnsafeFilterInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilterInputStreamClass] is expected to work anymore.
func UnsafeFilterInputStreamClassFree(f *FilterInputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilterInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilterInputStreamClassToGlibNone(f *FilterInputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilterInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeFilterInputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilterInputStreamClass) {}, f)
	return parent
}

// FilterOutputStreamClass wraps GFilterOutputStreamClass
// 
// FilterOutputStreamClass is the type struct for [FilterOutputStream]
type FilterOutputStreamClass struct {
	*filterOutputStreamClass
}

// filterOutputStreamClass is the struct that's finalized
type filterOutputStreamClass struct {
	native *C.GFilterOutputStreamClass
}

// UnsafeFilterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FilterOutputStreamClass) instance() *C.GFilterOutputStreamClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFilterOutputStreamClassFromGlibBorrow is used to convert raw C.GFilterOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeFilterOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *FilterOutputStreamClass {
	if p == nil {
		return nil
	}
	return &FilterOutputStreamClass{&filterOutputStreamClass{(*C.GFilterOutputStreamClass)(p)}}
}

// UnsafeFilterOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FilterOutputStreamClass] is expected to work anymore.
func UnsafeFilterOutputStreamClassFree(f *FilterOutputStreamClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFilterOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFilterOutputStreamClassToGlibNone(f *FilterOutputStreamClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (f *FilterOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeFilterOutputStreamClassToGlibNone(f))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *FilterOutputStreamClass) {}, f)
	return parent
}

// IOExtension wraps GIOExtension
//
// #GIOExtension is an opaque data structure and can only be accessed
// using the following functions.
type IOExtension struct {
	*iOExtension
}

// iOExtension is the struct that's finalized
type iOExtension struct {
	native *C.GIOExtension
}

// UnsafeIOExtensionToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOExtension) instance() *C.GIOExtension {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOExtensionFromGlibBorrow is used to convert raw C.GIOExtension pointers to go. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibBorrow(p unsafe.Pointer) *IOExtension {
	if p == nil {
		return nil
	}
	return &IOExtension{&iOExtension{(*C.GIOExtension)(p)}}
}

// UnsafeIOExtensionFromGlibNone is used to convert raw C.GIOExtension pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibNone(p unsafe.Pointer) *IOExtension {
	wrapped := UnsafeIOExtensionFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOExtension because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOExtensionFromGlibFull is used to convert raw C.GIOExtension pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOExtensionFromGlibFull(p unsafe.Pointer) *IOExtension {
	wrapped := UnsafeIOExtensionFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOExtension,
		func (intern *iOExtension) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOExtensionFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOExtension] is expected to work anymore.
func UnsafeIOExtensionFree(i *IOExtension) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOExtensionToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOExtensionToGlibNone(i *IOExtension) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOExtensionToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOExtensionToGlibFull(i *IOExtension) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOExtension, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOExtension is invalid from here on
	return _p
}

// GetName wraps g_io_extension_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name under which @extension was registered.
// 
// Note that the same type may be registered as extension
// for multiple extension points, under different names.
func (extension *IOExtension) GetName() string {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  *C.char         // return, none, string

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_name(carg0)
	runtime.KeepAlive(extension)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPriority wraps g_io_extension_get_priority
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the priority with which @extension was registered.
func (extension *IOExtension) GetPriority() int32 {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  C.gint          // return, none, casted

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_priority(carg0)
	runtime.KeepAlive(extension)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetType wraps g_io_extension_get_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the type associated with @extension.
func (extension *IOExtension) GetType() gobject.Type {
	var carg0 *C.GIOExtension // in, none, converted
	var cret  C.GType         // return, none, casted, alias

	carg0 = (*C.GIOExtension)(UnsafeIOExtensionToGlibNone(extension))

	cret = C.g_io_extension_get_type(carg0)
	runtime.KeepAlive(extension)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// IOExtensionPoint wraps GIOExtensionPoint
//
// `GIOExtensionPoint` provides a mechanism for modules to extend the
// functionality of the library or application that loaded it in an
// organized fashion.
// 
// An extension point is identified by a name, and it may optionally
// require that any implementation must be of a certain type (or derived
// thereof). Use [func@Gio.IOExtensionPoint.register] to register an
// extension point, and [method@Gio.IOExtensionPoint.set_required_type] to
// set a required type.
// 
// A module can implement an extension point by specifying the
// [type@GObject.Type] that implements the functionality. Additionally, each
// implementation of an extension point has a name, and a priority. Use
// [func@Gio.IOExtensionPoint.implement] to implement an extension point.
// 
// ```c
// GIOExtensionPoint *ep;
// 
// // Register an extension point
// ep = g_io_extension_point_register ("my-extension-point");
// g_io_extension_point_set_required_type (ep, MY_TYPE_EXAMPLE);
// ```
// 
// ```c
// // Implement an extension point
// G_DEFINE_TYPE (MyExampleImpl, my_example_impl, MY_TYPE_EXAMPLE)
// g_io_extension_point_implement ("my-extension-point",
//                                 my_example_impl_get_type (),
//                                 "my-example",
//                                 10);
// ```
// 
//  It is up to the code that registered the extension point how
//  it uses the implementations that have been associated with it.
//  Depending on the use case, it may use all implementations, or
//  only the one with the highest priority, or pick a specific
//  one by name.
// 
//  To avoid opening all modules just to find out what extension
//  points they implement, GIO makes use of a caching mechanism,
//  see [gio-querymodules](gio-querymodules.html).
//  You are expected to run this command after installing a
//  GIO module.
// 
//  The `GIO_EXTRA_MODULES` environment variable can be used to
//  specify additional directories to automatically load modules
//  from. This environment variable has the same syntax as the
//  `PATH`. If two modules have the same base name in different
//  directories, then the latter one will be ignored. If additional
//  directories are specified GIO will load modules from the built-in
//  directory last.
type IOExtensionPoint struct {
	*iOExtensionPoint
}

// iOExtensionPoint is the struct that's finalized
type iOExtensionPoint struct {
	native *C.GIOExtensionPoint
}

// UnsafeIOExtensionPointToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOExtensionPoint) instance() *C.GIOExtensionPoint {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOExtensionPointFromGlibBorrow is used to convert raw C.GIOExtensionPoint pointers to go. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibBorrow(p unsafe.Pointer) *IOExtensionPoint {
	if p == nil {
		return nil
	}
	return &IOExtensionPoint{&iOExtensionPoint{(*C.GIOExtensionPoint)(p)}}
}

// UnsafeIOExtensionPointFromGlibNone is used to convert raw C.GIOExtensionPoint pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibNone(p unsafe.Pointer) *IOExtensionPoint {
	wrapped := UnsafeIOExtensionPointFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOExtensionPoint because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOExtensionPointFromGlibFull is used to convert raw C.GIOExtensionPoint pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOExtensionPointFromGlibFull(p unsafe.Pointer) *IOExtensionPoint {
	wrapped := UnsafeIOExtensionPointFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOExtensionPoint,
		func (intern *iOExtensionPoint) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOExtensionPointFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOExtensionPoint] is expected to work anymore.
func UnsafeIOExtensionPointFree(i *IOExtensionPoint) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOExtensionPointToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOExtensionPointToGlibNone(i *IOExtensionPoint) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOExtensionPointToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOExtensionPointToGlibFull(i *IOExtensionPoint) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOExtensionPoint, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOExtensionPoint is invalid from here on
	return _p
}

// IOExtensionPointImplement wraps g_io_extension_point_implement
// 
// The function takes the following parameters:
// 
// 	- extensionPointName string: the name of the extension point 
// 	- typ gobject.Type: the #GType to register as extension 
// 	- extensionName string: the name for the extension 
// 	- priority int32: the priority for the extension 
// 
// The function returns the following values:
// 
// 	- goret *IOExtension 
//
// Registers @type as extension for the extension point with name
// @extension_point_name.
// 
// If @type has already been registered as an extension for this
// extension point, the existing #GIOExtension object is returned.
func IOExtensionPointImplement(extensionPointName string, typ gobject.Type, extensionName string, priority int32) *IOExtension {
	var carg1 *C.char         // in, none, string
	var carg2 C.GType         // in, none, casted, alias
	var carg3 *C.char         // in, none, string
	var carg4 C.gint          // in, none, casted
	var cret  *C.GIOExtension // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(extensionPointName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(typ)
	carg3 = (*C.char)(unsafe.Pointer(C.CString(extensionName)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gint(priority)

	cret = C.g_io_extension_point_implement(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(extensionPointName)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(extensionName)
	runtime.KeepAlive(priority)

	var goret *IOExtension

	goret = UnsafeIOExtensionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IOExtensionPointLookup wraps g_io_extension_point_lookup
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the extension point 
// 
// The function returns the following values:
// 
// 	- goret *IOExtensionPoint 
//
// Looks up an existing extension point.
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtensionPoint // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_lookup(carg1)
	runtime.KeepAlive(name)

	var goret *IOExtensionPoint

	goret = UnsafeIOExtensionPointFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IOExtensionPointRegister wraps g_io_extension_point_register
// 
// The function takes the following parameters:
// 
// 	- name string: The name of the extension point 
// 
// The function returns the following values:
// 
// 	- goret *IOExtensionPoint 
//
// Registers an extension point.
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtensionPoint // return, none, converted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_register(carg1)
	runtime.KeepAlive(name)

	var goret *IOExtensionPoint

	goret = UnsafeIOExtensionPointFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetExtensionByName wraps g_io_extension_point_get_extension_by_name
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the extension to get 
// 
// The function returns the following values:
// 
// 	- goret *IOExtension 
//
// Finds a #GIOExtension for an extension point by name.
func (extensionPoint *IOExtensionPoint) GetExtensionByName(name string) *IOExtension {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var carg1 *C.char              // in, none, string
	var cret  *C.GIOExtension      // return, none, converted

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_io_extension_point_get_extension_by_name(carg0, carg1)
	runtime.KeepAlive(extensionPoint)
	runtime.KeepAlive(name)

	var goret *IOExtension

	goret = UnsafeIOExtensionFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetExtensions wraps g_io_extension_point_get_extensions
// 
// The function returns the following values:
// 
// 	- goret []*IOExtension 
//
// Gets a list of all extensions that implement this extension point.
// The list is sorted by priority, beginning with the highest priority.
func (extensionPoint *IOExtensionPoint) GetExtensions() []*IOExtension {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var cret  *C.GList             // container, transfer: none

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))

	cret = C.g_io_extension_point_get_extensions(carg0)
	runtime.KeepAlive(extensionPoint)

	var goret []*IOExtension

	goret = glib.UnsafeListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) *IOExtension {
			var dst *IOExtension // converted
			dst = UnsafeIOExtensionFromGlibNone(v)
			return dst
		},
	)

	return goret
}

// GetRequiredType wraps g_io_extension_point_get_required_type
// 
// The function returns the following values:
// 
// 	- goret gobject.Type 
//
// Gets the required type for @extension_point.
func (extensionPoint *IOExtensionPoint) GetRequiredType() gobject.Type {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var cret  C.GType              // return, none, casted, alias

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))

	cret = C.g_io_extension_point_get_required_type(carg0)
	runtime.KeepAlive(extensionPoint)

	var goret gobject.Type

	goret = gobject.Type(cret)

	return goret
}

// SetRequiredType wraps g_io_extension_point_set_required_type
// 
// The function takes the following parameters:
// 
// 	- typ gobject.Type: the #GType to require 
//
// Sets the required type for @extension_point to @type.
// All implementations must henceforth have this type.
func (extensionPoint *IOExtensionPoint) SetRequiredType(typ gobject.Type) {
	var carg0 *C.GIOExtensionPoint // in, none, converted
	var carg1 C.GType              // in, none, casted, alias

	carg0 = (*C.GIOExtensionPoint)(UnsafeIOExtensionPointToGlibNone(extensionPoint))
	carg1 = C.GType(typ)

	C.g_io_extension_point_set_required_type(carg0, carg1)
	runtime.KeepAlive(extensionPoint)
	runtime.KeepAlive(typ)
}

// IOModuleClass wraps GIOModuleClass
// 
// IOModuleClass is the type struct for [IOModule]
type IOModuleClass struct {
	*iOModuleClass
}

// iOModuleClass is the struct that's finalized
type iOModuleClass struct {
	native *C.GIOModuleClass
}

// UnsafeIOModuleClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOModuleClass) instance() *C.GIOModuleClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOModuleClassFromGlibBorrow is used to convert raw C.GIOModuleClass pointers to go. This is used by the bindings internally.
func UnsafeIOModuleClassFromGlibBorrow(p unsafe.Pointer) *IOModuleClass {
	if p == nil {
		return nil
	}
	return &IOModuleClass{&iOModuleClass{(*C.GIOModuleClass)(p)}}
}

// UnsafeIOModuleClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOModuleClass] is expected to work anymore.
func UnsafeIOModuleClassFree(i *IOModuleClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOModuleClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOModuleClassToGlibNone(i *IOModuleClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// IOModuleScope wraps GIOModuleScope
//
// Represents a scope for loading IO modules. A scope can be used for blocking
// duplicate modules, or blocking a module you don't want to load.
// 
// The scope can be used with g_io_modules_load_all_in_directory_with_scope()
// or g_io_modules_scan_all_in_directory_with_scope().
type IOModuleScope struct {
	*iOModuleScope
}

// iOModuleScope is the struct that's finalized
type iOModuleScope struct {
	native *C.GIOModuleScope
}

// UnsafeIOModuleScopeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOModuleScope) instance() *C.GIOModuleScope {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOModuleScopeFromGlibBorrow is used to convert raw C.GIOModuleScope pointers to go. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibBorrow(p unsafe.Pointer) *IOModuleScope {
	if p == nil {
		return nil
	}
	return &IOModuleScope{&iOModuleScope{(*C.GIOModuleScope)(p)}}
}

// UnsafeIOModuleScopeFromGlibNone is used to convert raw C.GIOModuleScope pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibNone(p unsafe.Pointer) *IOModuleScope {
	wrapped := UnsafeIOModuleScopeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOModuleScope because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOModuleScopeFromGlibFull is used to convert raw C.GIOModuleScope pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOModuleScopeFromGlibFull(p unsafe.Pointer) *IOModuleScope {
	wrapped := UnsafeIOModuleScopeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOModuleScope,
		func (intern *iOModuleScope) {
			C.g_io_module_scope_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOModuleScopeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOModuleScope] is expected to work anymore.
func UnsafeIOModuleScopeFree(i *IOModuleScope) {
	C.g_io_module_scope_free(i.native)
}

// UnsafeIOModuleScopeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOModuleScopeToGlibNone(i *IOModuleScope) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOModuleScopeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOModuleScopeToGlibFull(i *IOModuleScope) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOModuleScope, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOModuleScope is invalid from here on
	return _p
}

// Block wraps g_io_module_scope_block
// 
// The function takes the following parameters:
// 
// 	- basename string: the basename to block 
//
// Block modules with the given @basename from being loaded when
// this scope is used with g_io_modules_scan_all_in_directory_with_scope()
// or g_io_modules_load_all_in_directory_with_scope().
func (scope *IOModuleScope) Block(basename string) {
	var carg0 *C.GIOModuleScope // in, none, converted
	var carg1 *C.gchar          // in, none, string

	carg0 = (*C.GIOModuleScope)(UnsafeIOModuleScopeToGlibNone(scope))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(basename)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_io_module_scope_block(carg0, carg1)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(basename)
}

// IOSchedulerJob wraps GIOSchedulerJob
//
// Opaque class for defining and scheduling IO jobs.
//
// Deprecated: (since 2.36.0) Use [struct@GLib.ThreadPool] or
//   [method@Gio.Task.run_in_thread]
type IOSchedulerJob struct {
	*iOSchedulerJob
}

// iOSchedulerJob is the struct that's finalized
type iOSchedulerJob struct {
	native *C.GIOSchedulerJob
}

// UnsafeIOSchedulerJobToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOSchedulerJob) instance() *C.GIOSchedulerJob {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOSchedulerJobFromGlibBorrow is used to convert raw C.GIOSchedulerJob pointers to go. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibBorrow(p unsafe.Pointer) *IOSchedulerJob {
	if p == nil {
		return nil
	}
	return &IOSchedulerJob{&iOSchedulerJob{(*C.GIOSchedulerJob)(p)}}
}

// UnsafeIOSchedulerJobFromGlibNone is used to convert raw C.GIOSchedulerJob pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibNone(p unsafe.Pointer) *IOSchedulerJob {
	wrapped := UnsafeIOSchedulerJobFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOSchedulerJob because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOSchedulerJobFromGlibFull is used to convert raw C.GIOSchedulerJob pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOSchedulerJobFromGlibFull(p unsafe.Pointer) *IOSchedulerJob {
	wrapped := UnsafeIOSchedulerJobFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOSchedulerJob,
		func (intern *iOSchedulerJob) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOSchedulerJobFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOSchedulerJob] is expected to work anymore.
func UnsafeIOSchedulerJobFree(i *IOSchedulerJob) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOSchedulerJobToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOSchedulerJobToGlibNone(i *IOSchedulerJob) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOSchedulerJobToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOSchedulerJobToGlibFull(i *IOSchedulerJob) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOSchedulerJob, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOSchedulerJob is invalid from here on
	return _p
}

// SendToMainloop wraps g_io_scheduler_job_send_to_mainloop
// 
// The function takes the following parameters:
// 
// 	- fn glib.SourceFunc: a #GSourceFunc callback that will be called in the original thread 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Used from an I/O job to send a callback to be run in the thread
// that the job was started from, waiting for the result (and thus
// blocking the I/O job).
//
// Deprecated: (since 2.36.0) Use g_main_context_invoke().
func (job *IOSchedulerJob) SendToMainloop(fn glib.SourceFunc) bool {
	var carg0 *C.GIOSchedulerJob // in, none, converted
	var carg1 C.GSourceFunc      // callback, scope: notified, closure: carg2, destroy: carg3
	var carg2 C.gpointer         // implicit
	var carg3 C.GDestroyNotify   // implicit
	var cret  C.gboolean         // return

	carg0 = (*C.GIOSchedulerJob)(UnsafeIOSchedulerJobToGlibNone(job))
	carg1 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg2 = C.gpointer(userdata.Register(fn))
	carg3 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_io_scheduler_job_send_to_mainloop(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(job)
	runtime.KeepAlive(fn)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SendToMainloopAsync wraps g_io_scheduler_job_send_to_mainloop_async
// 
// The function takes the following parameters:
// 
// 	- fn glib.SourceFunc: a #GSourceFunc callback that will be called in the original thread 
//
// Used from an I/O job to send a callback to be run asynchronously in
// the thread that the job was started from. The callback will be run
// when the main loop is available, but at that time the I/O job might
// have finished. The return value from the callback is ignored.
// 
// Note that if you are passing the @user_data from g_io_scheduler_push_job()
// on to this function you have to ensure that it is not freed before
// @func is called, either by passing %NULL as @notify to
// g_io_scheduler_push_job() or by using refcounting for @user_data.
//
// Deprecated: (since 2.36.0) Use g_main_context_invoke().
func (job *IOSchedulerJob) SendToMainloopAsync(fn glib.SourceFunc) {
	var carg0 *C.GIOSchedulerJob // in, none, converted
	var carg1 C.GSourceFunc      // callback, scope: notified, closure: carg2, destroy: carg3
	var carg2 C.gpointer         // implicit
	var carg3 C.GDestroyNotify   // implicit

	carg0 = (*C.GIOSchedulerJob)(UnsafeIOSchedulerJobToGlibNone(job))
	carg1 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg2 = C.gpointer(userdata.Register(fn))
	carg3 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	C.g_io_scheduler_job_send_to_mainloop_async(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(job)
	runtime.KeepAlive(fn)
}

// IOStreamAdapter wraps GIOStreamAdapter
type IOStreamAdapter struct {
	*iOStreamAdapter
}

// iOStreamAdapter is the struct that's finalized
type iOStreamAdapter struct {
	native *C.GIOStreamAdapter
}

// UnsafeIOStreamAdapterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOStreamAdapter) instance() *C.GIOStreamAdapter {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOStreamAdapterFromGlibBorrow is used to convert raw C.GIOStreamAdapter pointers to go. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibBorrow(p unsafe.Pointer) *IOStreamAdapter {
	if p == nil {
		return nil
	}
	return &IOStreamAdapter{&iOStreamAdapter{(*C.GIOStreamAdapter)(p)}}
}

// UnsafeIOStreamAdapterFromGlibNone is used to convert raw C.GIOStreamAdapter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibNone(p unsafe.Pointer) *IOStreamAdapter {
	wrapped := UnsafeIOStreamAdapterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOStreamAdapter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOStreamAdapterFromGlibFull is used to convert raw C.GIOStreamAdapter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOStreamAdapterFromGlibFull(p unsafe.Pointer) *IOStreamAdapter {
	wrapped := UnsafeIOStreamAdapterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOStreamAdapter,
		func (intern *iOStreamAdapter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOStreamAdapterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOStreamAdapter] is expected to work anymore.
func UnsafeIOStreamAdapterFree(i *IOStreamAdapter) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOStreamAdapterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOStreamAdapterToGlibNone(i *IOStreamAdapter) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOStreamAdapterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOStreamAdapterToGlibFull(i *IOStreamAdapter) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOStreamAdapter, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOStreamAdapter is invalid from here on
	return _p
}

// IOStreamClass wraps GIOStreamClass
// 
// IOStreamClass is the type struct for [IOStream]
type IOStreamClass struct {
	*iOStreamClass
}

// iOStreamClass is the struct that's finalized
type iOStreamClass struct {
	native *C.GIOStreamClass
}

// UnsafeIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOStreamClass) instance() *C.GIOStreamClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOStreamClassFromGlibBorrow is used to convert raw C.GIOStreamClass pointers to go. This is used by the bindings internally.
func UnsafeIOStreamClassFromGlibBorrow(p unsafe.Pointer) *IOStreamClass {
	if p == nil {
		return nil
	}
	return &IOStreamClass{&iOStreamClass{(*C.GIOStreamClass)(p)}}
}

// UnsafeIOStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOStreamClass] is expected to work anymore.
func UnsafeIOStreamClassFree(i *IOStreamClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOStreamClassToGlibNone(i *IOStreamClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *IOStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeIOStreamClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *IOStreamClass) {}, i)
	return parent
}

// IconIface wraps GIconIface
//
// GIconIface is used to implement GIcon types for various
// different systems. See #GThemedIcon and #GLoadableIcon for
// examples of how to implement this interface.
type IconIface struct {
	*iconIface
}

// iconIface is the struct that's finalized
type iconIface struct {
	native *C.GIconIface
}

// UnsafeIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IconIface) instance() *C.GIconIface {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIconIfaceFromGlibBorrow is used to convert raw C.GIconIface pointers to go. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibBorrow(p unsafe.Pointer) *IconIface {
	if p == nil {
		return nil
	}
	return &IconIface{&iconIface{(*C.GIconIface)(p)}}
}

// UnsafeIconIfaceFromGlibNone is used to convert raw C.GIconIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibNone(p unsafe.Pointer) *IconIface {
	wrapped := UnsafeIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IconIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIconIfaceFromGlibFull is used to convert raw C.GIconIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIconIfaceFromGlibFull(p unsafe.Pointer) *IconIface {
	wrapped := UnsafeIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iconIface,
		func (intern *iconIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIconIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IconIface] is expected to work anymore.
func UnsafeIconIfaceFree(i *IconIface) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIconIfaceToGlibNone(i *IconIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIconIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIconIfaceToGlibFull(i *IconIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iconIface, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IconIface is invalid from here on
	return _p
}

// InetAddressClass wraps GInetAddressClass
// 
// InetAddressClass is the type struct for [InetAddress]
type InetAddressClass struct {
	*inetAddressClass
}

// inetAddressClass is the struct that's finalized
type inetAddressClass struct {
	native *C.GInetAddressClass
}

// UnsafeInetAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetAddressClass) instance() *C.GInetAddressClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetAddressClassFromGlibBorrow is used to convert raw C.GInetAddressClass pointers to go. This is used by the bindings internally.
func UnsafeInetAddressClassFromGlibBorrow(p unsafe.Pointer) *InetAddressClass {
	if p == nil {
		return nil
	}
	return &InetAddressClass{&inetAddressClass{(*C.GInetAddressClass)(p)}}
}

// UnsafeInetAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetAddressClass] is expected to work anymore.
func UnsafeInetAddressClassFree(i *InetAddressClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetAddressClassToGlibNone(i *InetAddressClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInetAddressClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetAddressClass) {}, i)
	return parent
}

// InetAddressMaskClass wraps GInetAddressMaskClass
// 
// InetAddressMaskClass is the type struct for [InetAddressMask]
type InetAddressMaskClass struct {
	*inetAddressMaskClass
}

// inetAddressMaskClass is the struct that's finalized
type inetAddressMaskClass struct {
	native *C.GInetAddressMaskClass
}

// UnsafeInetAddressMaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetAddressMaskClass) instance() *C.GInetAddressMaskClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetAddressMaskClassFromGlibBorrow is used to convert raw C.GInetAddressMaskClass pointers to go. This is used by the bindings internally.
func UnsafeInetAddressMaskClassFromGlibBorrow(p unsafe.Pointer) *InetAddressMaskClass {
	if p == nil {
		return nil
	}
	return &InetAddressMaskClass{&inetAddressMaskClass{(*C.GInetAddressMaskClass)(p)}}
}

// UnsafeInetAddressMaskClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetAddressMaskClass] is expected to work anymore.
func UnsafeInetAddressMaskClassFree(i *InetAddressMaskClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetAddressMaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetAddressMaskClassToGlibNone(i *InetAddressMaskClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetAddressMaskClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInetAddressMaskClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetAddressMaskClass) {}, i)
	return parent
}

// InetSocketAddressClass wraps GInetSocketAddressClass
// 
// InetSocketAddressClass is the type struct for [InetSocketAddress]
type InetSocketAddressClass struct {
	*inetSocketAddressClass
}

// inetSocketAddressClass is the struct that's finalized
type inetSocketAddressClass struct {
	native *C.GInetSocketAddressClass
}

// UnsafeInetSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InetSocketAddressClass) instance() *C.GInetSocketAddressClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInetSocketAddressClassFromGlibBorrow is used to convert raw C.GInetSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeInetSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *InetSocketAddressClass {
	if p == nil {
		return nil
	}
	return &InetSocketAddressClass{&inetSocketAddressClass{(*C.GInetSocketAddressClass)(p)}}
}

// UnsafeInetSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InetSocketAddressClass] is expected to work anymore.
func UnsafeInetSocketAddressClassFree(i *InetSocketAddressClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInetSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInetSocketAddressClassToGlibNone(i *InetSocketAddressClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InetSocketAddressClass) ParentClass() *SocketAddressClass {
	parent := UnsafeSocketAddressClassFromGlibBorrow(UnsafeInetSocketAddressClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InetSocketAddressClass) {}, i)
	return parent
}

// InitableIface wraps GInitableIface
//
// Provides an interface for initializing object such that initialization
// may fail.
type InitableIface struct {
	*initableIface
}

// initableIface is the struct that's finalized
type initableIface struct {
	native *C.GInitableIface
}

// UnsafeInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InitableIface) instance() *C.GInitableIface {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInitableIfaceFromGlibBorrow is used to convert raw C.GInitableIface pointers to go. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibBorrow(p unsafe.Pointer) *InitableIface {
	if p == nil {
		return nil
	}
	return &InitableIface{&initableIface{(*C.GInitableIface)(p)}}
}

// UnsafeInitableIfaceFromGlibNone is used to convert raw C.GInitableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibNone(p unsafe.Pointer) *InitableIface {
	wrapped := UnsafeInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InitableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInitableIfaceFromGlibFull is used to convert raw C.GInitableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInitableIfaceFromGlibFull(p unsafe.Pointer) *InitableIface {
	wrapped := UnsafeInitableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.initableIface,
		func (intern *initableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInitableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InitableIface] is expected to work anymore.
func UnsafeInitableIfaceFree(i *InitableIface) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInitableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInitableIfaceToGlibNone(i *InitableIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInitableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInitableIfaceToGlibFull(i *InitableIface) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.initableIface, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InitableIface is invalid from here on
	return _p
}

// InputMessage wraps GInputMessage
//
// Structure used for scatter/gather data input when receiving multiple
// messages or packets in one go. You generally pass in an array of empty
// #GInputVectors and the operation will use all the buffers as if they
// were one buffer, and will set @bytes_received to the total number of bytes
// received across all #GInputVectors.
// 
// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
// the POSIX sockets API (see `man 2 recvmmsg`).
// 
// If @address is non-%NULL then it is set to the source address the message
// was received from, and the caller must free it afterwards.
// 
// If @control_messages is non-%NULL then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. @num_control_messages is set to the number of elements in
// this array, which may be zero.
// 
// Flags relevant to this message will be returned in @flags. For example,
// `MSG_EOR` or `MSG_TRUNC`.
type InputMessage struct {
	*inputMessage
}

// inputMessage is the struct that's finalized
type inputMessage struct {
	native *C.GInputMessage
}

// UnsafeInputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputMessage) instance() *C.GInputMessage {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputMessageFromGlibBorrow is used to convert raw C.GInputMessage pointers to go. This is used by the bindings internally.
func UnsafeInputMessageFromGlibBorrow(p unsafe.Pointer) *InputMessage {
	if p == nil {
		return nil
	}
	return &InputMessage{&inputMessage{(*C.GInputMessage)(p)}}
}

// UnsafeInputMessageFromGlibNone is used to convert raw C.GInputMessage pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInputMessageFromGlibNone(p unsafe.Pointer) *InputMessage {
	wrapped := UnsafeInputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InputMessage because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInputMessageFromGlibFull is used to convert raw C.GInputMessage pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInputMessageFromGlibFull(p unsafe.Pointer) *InputMessage {
	wrapped := UnsafeInputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.inputMessage,
		func (intern *inputMessage) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInputMessageFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputMessage] is expected to work anymore.
func UnsafeInputMessageFree(i *InputMessage) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputMessageToGlibNone(i *InputMessage) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInputMessageToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInputMessageToGlibFull(i *InputMessage) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.inputMessage, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InputMessage is invalid from here on
	return _p
}

// InputStreamClass wraps GInputStreamClass
// 
// InputStreamClass is the type struct for [InputStream]
type InputStreamClass struct {
	*inputStreamClass
}

// inputStreamClass is the struct that's finalized
type inputStreamClass struct {
	native *C.GInputStreamClass
}

// UnsafeInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputStreamClass) instance() *C.GInputStreamClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputStreamClassFromGlibBorrow is used to convert raw C.GInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeInputStreamClassFromGlibBorrow(p unsafe.Pointer) *InputStreamClass {
	if p == nil {
		return nil
	}
	return &InputStreamClass{&inputStreamClass{(*C.GInputStreamClass)(p)}}
}

// UnsafeInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputStreamClass] is expected to work anymore.
func UnsafeInputStreamClassFree(i *InputStreamClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputStreamClassToGlibNone(i *InputStreamClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InputStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeInputStreamClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InputStreamClass) {}, i)
	return parent
}

// InputVector wraps GInputVector
//
// Structure used for scatter/gather data input.
// You generally pass in an array of #GInputVectors
// and the operation will store the read data starting in the
// first buffer, switching to the next as needed.
type InputVector struct {
	*inputVector
}

// inputVector is the struct that's finalized
type inputVector struct {
	native *C.GInputVector
}

// UnsafeInputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InputVector) instance() *C.GInputVector {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInputVectorFromGlibBorrow is used to convert raw C.GInputVector pointers to go. This is used by the bindings internally.
func UnsafeInputVectorFromGlibBorrow(p unsafe.Pointer) *InputVector {
	if p == nil {
		return nil
	}
	return &InputVector{&inputVector{(*C.GInputVector)(p)}}
}

// UnsafeInputVectorFromGlibNone is used to convert raw C.GInputVector pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInputVectorFromGlibNone(p unsafe.Pointer) *InputVector {
	wrapped := UnsafeInputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InputVector because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInputVectorFromGlibFull is used to convert raw C.GInputVector pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInputVectorFromGlibFull(p unsafe.Pointer) *InputVector {
	wrapped := UnsafeInputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.inputVector,
		func (intern *inputVector) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInputVectorFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InputVector] is expected to work anymore.
func UnsafeInputVectorFree(i *InputVector) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInputVectorToGlibNone(i *InputVector) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInputVectorToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInputVectorToGlibFull(i *InputVector) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.inputVector, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InputVector is invalid from here on
	return _p
}

// ListModelInterface wraps GListModelInterface
//
// The virtual function table for #GListModel.
type ListModelInterface struct {
	*listModelInterface
}

// listModelInterface is the struct that's finalized
type listModelInterface struct {
	native *C.GListModelInterface
}

// UnsafeListModelInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *ListModelInterface) instance() *C.GListModelInterface {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeListModelInterfaceFromGlibBorrow is used to convert raw C.GListModelInterface pointers to go. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibBorrow(p unsafe.Pointer) *ListModelInterface {
	if p == nil {
		return nil
	}
	return &ListModelInterface{&listModelInterface{(*C.GListModelInterface)(p)}}
}

// UnsafeListModelInterfaceFromGlibNone is used to convert raw C.GListModelInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibNone(p unsafe.Pointer) *ListModelInterface {
	wrapped := UnsafeListModelInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ListModelInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeListModelInterfaceFromGlibFull is used to convert raw C.GListModelInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeListModelInterfaceFromGlibFull(p unsafe.Pointer) *ListModelInterface {
	wrapped := UnsafeListModelInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.listModelInterface,
		func (intern *listModelInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeListModelInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ListModelInterface] is expected to work anymore.
func UnsafeListModelInterfaceFree(l *ListModelInterface) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeListModelInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeListModelInterfaceToGlibNone(l *ListModelInterface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeListModelInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeListModelInterfaceToGlibFull(l *ListModelInterface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.listModelInterface, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // ListModelInterface is invalid from here on
	return _p
}

// ListStoreClass wraps GListStoreClass
// 
// ListStoreClass is the type struct for [ListStore]
type ListStoreClass struct {
	*listStoreClass
}

// listStoreClass is the struct that's finalized
type listStoreClass struct {
	native *C.GListStoreClass
}

// UnsafeListStoreClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *ListStoreClass) instance() *C.GListStoreClass {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeListStoreClassFromGlibBorrow is used to convert raw C.GListStoreClass pointers to go. This is used by the bindings internally.
func UnsafeListStoreClassFromGlibBorrow(p unsafe.Pointer) *ListStoreClass {
	if p == nil {
		return nil
	}
	return &ListStoreClass{&listStoreClass{(*C.GListStoreClass)(p)}}
}

// UnsafeListStoreClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ListStoreClass] is expected to work anymore.
func UnsafeListStoreClassFree(l *ListStoreClass) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeListStoreClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeListStoreClassToGlibNone(l *ListStoreClass) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (l *ListStoreClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeListStoreClassToGlibNone(l))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ListStoreClass) {}, l)
	return parent
}

// LoadableIconIface wraps GLoadableIconIface
//
// Interface for icons that can be loaded as a stream.
type LoadableIconIface struct {
	*loadableIconIface
}

// loadableIconIface is the struct that's finalized
type loadableIconIface struct {
	native *C.GLoadableIconIface
}

// UnsafeLoadableIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *LoadableIconIface) instance() *C.GLoadableIconIface {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeLoadableIconIfaceFromGlibBorrow is used to convert raw C.GLoadableIconIface pointers to go. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibBorrow(p unsafe.Pointer) *LoadableIconIface {
	if p == nil {
		return nil
	}
	return &LoadableIconIface{&loadableIconIface{(*C.GLoadableIconIface)(p)}}
}

// UnsafeLoadableIconIfaceFromGlibNone is used to convert raw C.GLoadableIconIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibNone(p unsafe.Pointer) *LoadableIconIface {
	wrapped := UnsafeLoadableIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to LoadableIconIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeLoadableIconIfaceFromGlibFull is used to convert raw C.GLoadableIconIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeLoadableIconIfaceFromGlibFull(p unsafe.Pointer) *LoadableIconIface {
	wrapped := UnsafeLoadableIconIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.loadableIconIface,
		func (intern *loadableIconIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeLoadableIconIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [LoadableIconIface] is expected to work anymore.
func UnsafeLoadableIconIfaceFree(l *LoadableIconIface) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeLoadableIconIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeLoadableIconIfaceToGlibNone(l *LoadableIconIface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeLoadableIconIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeLoadableIconIfaceToGlibFull(l *LoadableIconIface) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.loadableIconIface, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // LoadableIconIface is invalid from here on
	return _p
}

// MemoryInputStreamClass wraps GMemoryInputStreamClass
// 
// MemoryInputStreamClass is the type struct for [MemoryInputStream]
type MemoryInputStreamClass struct {
	*memoryInputStreamClass
}

// memoryInputStreamClass is the struct that's finalized
type memoryInputStreamClass struct {
	native *C.GMemoryInputStreamClass
}

// UnsafeMemoryInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryInputStreamClass) instance() *C.GMemoryInputStreamClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryInputStreamClassFromGlibBorrow is used to convert raw C.GMemoryInputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeMemoryInputStreamClassFromGlibBorrow(p unsafe.Pointer) *MemoryInputStreamClass {
	if p == nil {
		return nil
	}
	return &MemoryInputStreamClass{&memoryInputStreamClass{(*C.GMemoryInputStreamClass)(p)}}
}

// UnsafeMemoryInputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryInputStreamClass] is expected to work anymore.
func UnsafeMemoryInputStreamClassFree(m *MemoryInputStreamClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryInputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryInputStreamClassToGlibNone(m *MemoryInputStreamClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MemoryInputStreamClass) ParentClass() *InputStreamClass {
	parent := UnsafeInputStreamClassFromGlibBorrow(UnsafeMemoryInputStreamClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MemoryInputStreamClass) {}, m)
	return parent
}

// MemoryMonitorInterface wraps GMemoryMonitorInterface
//
// The virtual function table for #GMemoryMonitor.
type MemoryMonitorInterface struct {
	*memoryMonitorInterface
}

// memoryMonitorInterface is the struct that's finalized
type memoryMonitorInterface struct {
	native *C.GMemoryMonitorInterface
}

// UnsafeMemoryMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryMonitorInterface) instance() *C.GMemoryMonitorInterface {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryMonitorInterfaceFromGlibBorrow is used to convert raw C.GMemoryMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *MemoryMonitorInterface {
	if p == nil {
		return nil
	}
	return &MemoryMonitorInterface{&memoryMonitorInterface{(*C.GMemoryMonitorInterface)(p)}}
}

// UnsafeMemoryMonitorInterfaceFromGlibNone is used to convert raw C.GMemoryMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibNone(p unsafe.Pointer) *MemoryMonitorInterface {
	wrapped := UnsafeMemoryMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MemoryMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMemoryMonitorInterfaceFromGlibFull is used to convert raw C.GMemoryMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceFromGlibFull(p unsafe.Pointer) *MemoryMonitorInterface {
	wrapped := UnsafeMemoryMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.memoryMonitorInterface,
		func (intern *memoryMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMemoryMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryMonitorInterface] is expected to work anymore.
func UnsafeMemoryMonitorInterfaceFree(m *MemoryMonitorInterface) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceToGlibNone(m *MemoryMonitorInterface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMemoryMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMemoryMonitorInterfaceToGlibFull(m *MemoryMonitorInterface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.memoryMonitorInterface, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MemoryMonitorInterface is invalid from here on
	return _p
}

// MemoryOutputStreamClass wraps GMemoryOutputStreamClass
// 
// MemoryOutputStreamClass is the type struct for [MemoryOutputStream]
type MemoryOutputStreamClass struct {
	*memoryOutputStreamClass
}

// memoryOutputStreamClass is the struct that's finalized
type memoryOutputStreamClass struct {
	native *C.GMemoryOutputStreamClass
}

// UnsafeMemoryOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemoryOutputStreamClass) instance() *C.GMemoryOutputStreamClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemoryOutputStreamClassFromGlibBorrow is used to convert raw C.GMemoryOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeMemoryOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *MemoryOutputStreamClass {
	if p == nil {
		return nil
	}
	return &MemoryOutputStreamClass{&memoryOutputStreamClass{(*C.GMemoryOutputStreamClass)(p)}}
}

// UnsafeMemoryOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemoryOutputStreamClass] is expected to work anymore.
func UnsafeMemoryOutputStreamClassFree(m *MemoryOutputStreamClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemoryOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemoryOutputStreamClassToGlibNone(m *MemoryOutputStreamClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MemoryOutputStreamClass) ParentClass() *OutputStreamClass {
	parent := UnsafeOutputStreamClassFromGlibBorrow(UnsafeMemoryOutputStreamClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MemoryOutputStreamClass) {}, m)
	return parent
}

// MenuAttributeIterClass wraps GMenuAttributeIterClass
// 
// MenuAttributeIterClass is the type struct for [MenuAttributeIter]
type MenuAttributeIterClass struct {
	*menuAttributeIterClass
}

// menuAttributeIterClass is the struct that's finalized
type menuAttributeIterClass struct {
	native *C.GMenuAttributeIterClass
}

// UnsafeMenuAttributeIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuAttributeIterClass) instance() *C.GMenuAttributeIterClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuAttributeIterClassFromGlibBorrow is used to convert raw C.GMenuAttributeIterClass pointers to go. This is used by the bindings internally.
func UnsafeMenuAttributeIterClassFromGlibBorrow(p unsafe.Pointer) *MenuAttributeIterClass {
	if p == nil {
		return nil
	}
	return &MenuAttributeIterClass{&menuAttributeIterClass{(*C.GMenuAttributeIterClass)(p)}}
}

// UnsafeMenuAttributeIterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuAttributeIterClass] is expected to work anymore.
func UnsafeMenuAttributeIterClassFree(m *MenuAttributeIterClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuAttributeIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuAttributeIterClassToGlibNone(m *MenuAttributeIterClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuAttributeIterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuAttributeIterClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuAttributeIterClass) {}, m)
	return parent
}

// MenuLinkIterClass wraps GMenuLinkIterClass
// 
// MenuLinkIterClass is the type struct for [MenuLinkIter]
type MenuLinkIterClass struct {
	*menuLinkIterClass
}

// menuLinkIterClass is the struct that's finalized
type menuLinkIterClass struct {
	native *C.GMenuLinkIterClass
}

// UnsafeMenuLinkIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuLinkIterClass) instance() *C.GMenuLinkIterClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuLinkIterClassFromGlibBorrow is used to convert raw C.GMenuLinkIterClass pointers to go. This is used by the bindings internally.
func UnsafeMenuLinkIterClassFromGlibBorrow(p unsafe.Pointer) *MenuLinkIterClass {
	if p == nil {
		return nil
	}
	return &MenuLinkIterClass{&menuLinkIterClass{(*C.GMenuLinkIterClass)(p)}}
}

// UnsafeMenuLinkIterClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuLinkIterClass] is expected to work anymore.
func UnsafeMenuLinkIterClassFree(m *MenuLinkIterClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuLinkIterClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuLinkIterClassToGlibNone(m *MenuLinkIterClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuLinkIterClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuLinkIterClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuLinkIterClass) {}, m)
	return parent
}

// MenuModelClass wraps GMenuModelClass
// 
// MenuModelClass is the type struct for [MenuModel]
type MenuModelClass struct {
	*menuModelClass
}

// menuModelClass is the struct that's finalized
type menuModelClass struct {
	native *C.GMenuModelClass
}

// UnsafeMenuModelClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MenuModelClass) instance() *C.GMenuModelClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMenuModelClassFromGlibBorrow is used to convert raw C.GMenuModelClass pointers to go. This is used by the bindings internally.
func UnsafeMenuModelClassFromGlibBorrow(p unsafe.Pointer) *MenuModelClass {
	if p == nil {
		return nil
	}
	return &MenuModelClass{&menuModelClass{(*C.GMenuModelClass)(p)}}
}

// UnsafeMenuModelClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MenuModelClass] is expected to work anymore.
func UnsafeMenuModelClassFree(m *MenuModelClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMenuModelClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMenuModelClassToGlibNone(m *MenuModelClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MenuModelClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMenuModelClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MenuModelClass) {}, m)
	return parent
}

// MountIface wraps GMountIface
//
// Interface for implementing operations for mounts.
type MountIface struct {
	*mountIface
}

// mountIface is the struct that's finalized
type mountIface struct {
	native *C.GMountIface
}

// UnsafeMountIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MountIface) instance() *C.GMountIface {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMountIfaceFromGlibBorrow is used to convert raw C.GMountIface pointers to go. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibBorrow(p unsafe.Pointer) *MountIface {
	if p == nil {
		return nil
	}
	return &MountIface{&mountIface{(*C.GMountIface)(p)}}
}

// UnsafeMountIfaceFromGlibNone is used to convert raw C.GMountIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibNone(p unsafe.Pointer) *MountIface {
	wrapped := UnsafeMountIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MountIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMountIfaceFromGlibFull is used to convert raw C.GMountIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMountIfaceFromGlibFull(p unsafe.Pointer) *MountIface {
	wrapped := UnsafeMountIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mountIface,
		func (intern *mountIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMountIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MountIface] is expected to work anymore.
func UnsafeMountIfaceFree(m *MountIface) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMountIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMountIfaceToGlibNone(m *MountIface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMountIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMountIfaceToGlibFull(m *MountIface) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mountIface, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MountIface is invalid from here on
	return _p
}

// MountOperationClass wraps GMountOperationClass
// 
// MountOperationClass is the type struct for [MountOperation]
type MountOperationClass struct {
	*mountOperationClass
}

// mountOperationClass is the struct that's finalized
type mountOperationClass struct {
	native *C.GMountOperationClass
}

// UnsafeMountOperationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MountOperationClass) instance() *C.GMountOperationClass {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMountOperationClassFromGlibBorrow is used to convert raw C.GMountOperationClass pointers to go. This is used by the bindings internally.
func UnsafeMountOperationClassFromGlibBorrow(p unsafe.Pointer) *MountOperationClass {
	if p == nil {
		return nil
	}
	return &MountOperationClass{&mountOperationClass{(*C.GMountOperationClass)(p)}}
}

// UnsafeMountOperationClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MountOperationClass] is expected to work anymore.
func UnsafeMountOperationClassFree(m *MountOperationClass) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMountOperationClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMountOperationClassToGlibNone(m *MountOperationClass) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (m *MountOperationClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeMountOperationClassToGlibNone(m))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *MountOperationClass) {}, m)
	return parent
}

// NativeSocketAddressClass wraps GNativeSocketAddressClass
// 
// NativeSocketAddressClass is the type struct for [NativeSocketAddress]
type NativeSocketAddressClass struct {
	*nativeSocketAddressClass
}

// nativeSocketAddressClass is the struct that's finalized
type nativeSocketAddressClass struct {
	native *C.GNativeSocketAddressClass
}

// UnsafeNativeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NativeSocketAddressClass) instance() *C.GNativeSocketAddressClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNativeSocketAddressClassFromGlibBorrow is used to convert raw C.GNativeSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeNativeSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *NativeSocketAddressClass {
	if p == nil {
		return nil
	}
	return &NativeSocketAddressClass{&nativeSocketAddressClass{(*C.GNativeSocketAddressClass)(p)}}
}

// UnsafeNativeSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NativeSocketAddressClass] is expected to work anymore.
func UnsafeNativeSocketAddressClassFree(n *NativeSocketAddressClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNativeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNativeSocketAddressClassToGlibNone(n *NativeSocketAddressClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NativeSocketAddressClass) ParentClass() *SocketAddressClass {
	parent := UnsafeSocketAddressClassFromGlibBorrow(UnsafeNativeSocketAddressClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NativeSocketAddressClass) {}, n)
	return parent
}

// NativeVolumeMonitorClass wraps GNativeVolumeMonitorClass
// 
// NativeVolumeMonitorClass is the type struct for [NativeVolumeMonitor]
type NativeVolumeMonitorClass struct {
	*nativeVolumeMonitorClass
}

// nativeVolumeMonitorClass is the struct that's finalized
type nativeVolumeMonitorClass struct {
	native *C.GNativeVolumeMonitorClass
}

// UnsafeNativeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NativeVolumeMonitorClass) instance() *C.GNativeVolumeMonitorClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNativeVolumeMonitorClassFromGlibBorrow is used to convert raw C.GNativeVolumeMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorClassFromGlibBorrow(p unsafe.Pointer) *NativeVolumeMonitorClass {
	if p == nil {
		return nil
	}
	return &NativeVolumeMonitorClass{&nativeVolumeMonitorClass{(*C.GNativeVolumeMonitorClass)(p)}}
}

// UnsafeNativeVolumeMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NativeVolumeMonitorClass] is expected to work anymore.
func UnsafeNativeVolumeMonitorClassFree(n *NativeVolumeMonitorClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNativeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNativeVolumeMonitorClassToGlibNone(n *NativeVolumeMonitorClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NativeVolumeMonitorClass) ParentClass() *VolumeMonitorClass {
	parent := UnsafeVolumeMonitorClassFromGlibBorrow(UnsafeNativeVolumeMonitorClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NativeVolumeMonitorClass) {}, n)
	return parent
}

// NetworkAddressClass wraps GNetworkAddressClass
// 
// NetworkAddressClass is the type struct for [NetworkAddress]
type NetworkAddressClass struct {
	*networkAddressClass
}

// networkAddressClass is the struct that's finalized
type networkAddressClass struct {
	native *C.GNetworkAddressClass
}

// UnsafeNetworkAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkAddressClass) instance() *C.GNetworkAddressClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkAddressClassFromGlibBorrow is used to convert raw C.GNetworkAddressClass pointers to go. This is used by the bindings internally.
func UnsafeNetworkAddressClassFromGlibBorrow(p unsafe.Pointer) *NetworkAddressClass {
	if p == nil {
		return nil
	}
	return &NetworkAddressClass{&networkAddressClass{(*C.GNetworkAddressClass)(p)}}
}

// UnsafeNetworkAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkAddressClass] is expected to work anymore.
func UnsafeNetworkAddressClassFree(n *NetworkAddressClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkAddressClassToGlibNone(n *NetworkAddressClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NetworkAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeNetworkAddressClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NetworkAddressClass) {}, n)
	return parent
}

// NetworkMonitorInterface wraps GNetworkMonitorInterface
//
// The virtual function table for #GNetworkMonitor.
type NetworkMonitorInterface struct {
	*networkMonitorInterface
}

// networkMonitorInterface is the struct that's finalized
type networkMonitorInterface struct {
	native *C.GNetworkMonitorInterface
}

// UnsafeNetworkMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkMonitorInterface) instance() *C.GNetworkMonitorInterface {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkMonitorInterfaceFromGlibBorrow is used to convert raw C.GNetworkMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *NetworkMonitorInterface {
	if p == nil {
		return nil
	}
	return &NetworkMonitorInterface{&networkMonitorInterface{(*C.GNetworkMonitorInterface)(p)}}
}

// UnsafeNetworkMonitorInterfaceFromGlibNone is used to convert raw C.GNetworkMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibNone(p unsafe.Pointer) *NetworkMonitorInterface {
	wrapped := UnsafeNetworkMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to NetworkMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeNetworkMonitorInterfaceFromGlibFull is used to convert raw C.GNetworkMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceFromGlibFull(p unsafe.Pointer) *NetworkMonitorInterface {
	wrapped := UnsafeNetworkMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.networkMonitorInterface,
		func (intern *networkMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeNetworkMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkMonitorInterface] is expected to work anymore.
func UnsafeNetworkMonitorInterfaceFree(n *NetworkMonitorInterface) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceToGlibNone(n *NetworkMonitorInterface) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// UnsafeNetworkMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeNetworkMonitorInterfaceToGlibFull(n *NetworkMonitorInterface) unsafe.Pointer {
	if n == nil {
		return nil
	}
	runtime.SetFinalizer(n.networkMonitorInterface, nil)
	_p := unsafe.Pointer(n.native)
	n.native = nil // NetworkMonitorInterface is invalid from here on
	return _p
}

// NetworkServiceClass wraps GNetworkServiceClass
// 
// NetworkServiceClass is the type struct for [NetworkService]
type NetworkServiceClass struct {
	*networkServiceClass
}

// networkServiceClass is the struct that's finalized
type networkServiceClass struct {
	native *C.GNetworkServiceClass
}

// UnsafeNetworkServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *NetworkServiceClass) instance() *C.GNetworkServiceClass {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNetworkServiceClassFromGlibBorrow is used to convert raw C.GNetworkServiceClass pointers to go. This is used by the bindings internally.
func UnsafeNetworkServiceClassFromGlibBorrow(p unsafe.Pointer) *NetworkServiceClass {
	if p == nil {
		return nil
	}
	return &NetworkServiceClass{&networkServiceClass{(*C.GNetworkServiceClass)(p)}}
}

// UnsafeNetworkServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [NetworkServiceClass] is expected to work anymore.
func UnsafeNetworkServiceClassFree(n *NetworkServiceClass) {
	C.free(unsafe.Pointer(n.native))
}

// UnsafeNetworkServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNetworkServiceClassToGlibNone(n *NetworkServiceClass) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (n *NetworkServiceClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeNetworkServiceClassToGlibNone(n))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *NetworkServiceClass) {}, n)
	return parent
}

// OutputMessage wraps GOutputMessage
//
// Structure used for scatter/gather data output when sending multiple
// messages or packets in one go. You generally pass in an array of
// #GOutputVectors and the operation will use all the buffers as if they
// were one buffer.
// 
// If @address is %NULL then the message is sent to the default receiver
// (as previously set by g_socket_connect()).
type OutputMessage struct {
	*outputMessage
}

// outputMessage is the struct that's finalized
type outputMessage struct {
	native *C.GOutputMessage
}

// UnsafeOutputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputMessage) instance() *C.GOutputMessage {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputMessageFromGlibBorrow is used to convert raw C.GOutputMessage pointers to go. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibBorrow(p unsafe.Pointer) *OutputMessage {
	if p == nil {
		return nil
	}
	return &OutputMessage{&outputMessage{(*C.GOutputMessage)(p)}}
}

// UnsafeOutputMessageFromGlibNone is used to convert raw C.GOutputMessage pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibNone(p unsafe.Pointer) *OutputMessage {
	wrapped := UnsafeOutputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OutputMessage because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOutputMessageFromGlibFull is used to convert raw C.GOutputMessage pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOutputMessageFromGlibFull(p unsafe.Pointer) *OutputMessage {
	wrapped := UnsafeOutputMessageFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.outputMessage,
		func (intern *outputMessage) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOutputMessageFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputMessage] is expected to work anymore.
func UnsafeOutputMessageFree(o *OutputMessage) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputMessageToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputMessageToGlibNone(o *OutputMessage) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOutputMessageToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOutputMessageToGlibFull(o *OutputMessage) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.outputMessage, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OutputMessage is invalid from here on
	return _p
}

// OutputStreamClass wraps GOutputStreamClass
// 
// OutputStreamClass is the type struct for [OutputStream]
type OutputStreamClass struct {
	*outputStreamClass
}

// outputStreamClass is the struct that's finalized
type outputStreamClass struct {
	native *C.GOutputStreamClass
}

// UnsafeOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputStreamClass) instance() *C.GOutputStreamClass {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputStreamClassFromGlibBorrow is used to convert raw C.GOutputStreamClass pointers to go. This is used by the bindings internally.
func UnsafeOutputStreamClassFromGlibBorrow(p unsafe.Pointer) *OutputStreamClass {
	if p == nil {
		return nil
	}
	return &OutputStreamClass{&outputStreamClass{(*C.GOutputStreamClass)(p)}}
}

// UnsafeOutputStreamClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputStreamClass] is expected to work anymore.
func UnsafeOutputStreamClassFree(o *OutputStreamClass) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputStreamClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputStreamClassToGlibNone(o *OutputStreamClass) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (o *OutputStreamClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeOutputStreamClassToGlibNone(o))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *OutputStreamClass) {}, o)
	return parent
}

// OutputVector wraps GOutputVector
//
// Structure used for scatter/gather data output.
// You generally pass in an array of #GOutputVectors
// and the operation will use all the buffers as if they were
// one buffer.
type OutputVector struct {
	*outputVector
}

// outputVector is the struct that's finalized
type outputVector struct {
	native *C.GOutputVector
}

// UnsafeOutputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OutputVector) instance() *C.GOutputVector {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOutputVectorFromGlibBorrow is used to convert raw C.GOutputVector pointers to go. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibBorrow(p unsafe.Pointer) *OutputVector {
	if p == nil {
		return nil
	}
	return &OutputVector{&outputVector{(*C.GOutputVector)(p)}}
}

// UnsafeOutputVectorFromGlibNone is used to convert raw C.GOutputVector pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibNone(p unsafe.Pointer) *OutputVector {
	wrapped := UnsafeOutputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OutputVector because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOutputVectorFromGlibFull is used to convert raw C.GOutputVector pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOutputVectorFromGlibFull(p unsafe.Pointer) *OutputVector {
	wrapped := UnsafeOutputVectorFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.outputVector,
		func (intern *outputVector) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOutputVectorFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OutputVector] is expected to work anymore.
func UnsafeOutputVectorFree(o *OutputVector) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOutputVectorToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOutputVectorToGlibNone(o *OutputVector) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOutputVectorToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOutputVectorToGlibFull(o *OutputVector) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.outputVector, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OutputVector is invalid from here on
	return _p
}

// PermissionClass wraps GPermissionClass
// 
// PermissionClass is the type struct for [Permission]
type PermissionClass struct {
	*permissionClass
}

// permissionClass is the struct that's finalized
type permissionClass struct {
	native *C.GPermissionClass
}

// UnsafePermissionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PermissionClass) instance() *C.GPermissionClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePermissionClassFromGlibBorrow is used to convert raw C.GPermissionClass pointers to go. This is used by the bindings internally.
func UnsafePermissionClassFromGlibBorrow(p unsafe.Pointer) *PermissionClass {
	if p == nil {
		return nil
	}
	return &PermissionClass{&permissionClass{(*C.GPermissionClass)(p)}}
}

// UnsafePermissionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PermissionClass] is expected to work anymore.
func UnsafePermissionClassFree(p *PermissionClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePermissionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePermissionClassToGlibNone(p *PermissionClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *PermissionClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafePermissionClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *PermissionClass) {}, p)
	return parent
}

// PollableInputStreamInterface wraps GPollableInputStreamInterface
//
// The interface for pollable input streams.
// 
// The default implementation of @can_poll always returns %TRUE.
// 
// The default implementation of @read_nonblocking calls
// g_pollable_input_stream_is_readable(), and then calls
// g_input_stream_read() if it returns %TRUE. This means you only need
// to override it if it is possible that your @is_readable
// implementation may return %TRUE when the stream is not actually
// readable.
type PollableInputStreamInterface struct {
	*pollableInputStreamInterface
}

// pollableInputStreamInterface is the struct that's finalized
type pollableInputStreamInterface struct {
	native *C.GPollableInputStreamInterface
}

// UnsafePollableInputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollableInputStreamInterface) instance() *C.GPollableInputStreamInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollableInputStreamInterfaceFromGlibBorrow is used to convert raw C.GPollableInputStreamInterface pointers to go. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibBorrow(p unsafe.Pointer) *PollableInputStreamInterface {
	if p == nil {
		return nil
	}
	return &PollableInputStreamInterface{&pollableInputStreamInterface{(*C.GPollableInputStreamInterface)(p)}}
}

// UnsafePollableInputStreamInterfaceFromGlibNone is used to convert raw C.GPollableInputStreamInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibNone(p unsafe.Pointer) *PollableInputStreamInterface {
	wrapped := UnsafePollableInputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollableInputStreamInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollableInputStreamInterfaceFromGlibFull is used to convert raw C.GPollableInputStreamInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceFromGlibFull(p unsafe.Pointer) *PollableInputStreamInterface {
	wrapped := UnsafePollableInputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollableInputStreamInterface,
		func (intern *pollableInputStreamInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollableInputStreamInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollableInputStreamInterface] is expected to work anymore.
func UnsafePollableInputStreamInterfaceFree(p *PollableInputStreamInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollableInputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceToGlibNone(p *PollableInputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollableInputStreamInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollableInputStreamInterfaceToGlibFull(p *PollableInputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollableInputStreamInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollableInputStreamInterface is invalid from here on
	return _p
}

// PollableOutputStreamInterface wraps GPollableOutputStreamInterface
//
// The interface for pollable output streams.
// 
// The default implementation of @can_poll always returns %TRUE.
// 
// The default implementation of @write_nonblocking calls
// g_pollable_output_stream_is_writable(), and then calls
// g_output_stream_write() if it returns %TRUE. This means you only
// need to override it if it is possible that your @is_writable
// implementation may return %TRUE when the stream is not actually
// writable.
// 
// The default implementation of @writev_nonblocking calls
// g_pollable_output_stream_write_nonblocking() for each vector, and converts
// its return value and error (if set) to a #GPollableReturn. You should
// override this where possible to avoid having to allocate a #GError to return
// %G_IO_ERROR_WOULD_BLOCK.
type PollableOutputStreamInterface struct {
	*pollableOutputStreamInterface
}

// pollableOutputStreamInterface is the struct that's finalized
type pollableOutputStreamInterface struct {
	native *C.GPollableOutputStreamInterface
}

// UnsafePollableOutputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollableOutputStreamInterface) instance() *C.GPollableOutputStreamInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollableOutputStreamInterfaceFromGlibBorrow is used to convert raw C.GPollableOutputStreamInterface pointers to go. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibBorrow(p unsafe.Pointer) *PollableOutputStreamInterface {
	if p == nil {
		return nil
	}
	return &PollableOutputStreamInterface{&pollableOutputStreamInterface{(*C.GPollableOutputStreamInterface)(p)}}
}

// UnsafePollableOutputStreamInterfaceFromGlibNone is used to convert raw C.GPollableOutputStreamInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibNone(p unsafe.Pointer) *PollableOutputStreamInterface {
	wrapped := UnsafePollableOutputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollableOutputStreamInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollableOutputStreamInterfaceFromGlibFull is used to convert raw C.GPollableOutputStreamInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceFromGlibFull(p unsafe.Pointer) *PollableOutputStreamInterface {
	wrapped := UnsafePollableOutputStreamInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollableOutputStreamInterface,
		func (intern *pollableOutputStreamInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollableOutputStreamInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollableOutputStreamInterface] is expected to work anymore.
func UnsafePollableOutputStreamInterfaceFree(p *PollableOutputStreamInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollableOutputStreamInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceToGlibNone(p *PollableOutputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollableOutputStreamInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollableOutputStreamInterfaceToGlibFull(p *PollableOutputStreamInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollableOutputStreamInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollableOutputStreamInterface is invalid from here on
	return _p
}

// PowerProfileMonitorInterface wraps GPowerProfileMonitorInterface
//
// The virtual function table for #GPowerProfileMonitor.
type PowerProfileMonitorInterface struct {
	*powerProfileMonitorInterface
}

// powerProfileMonitorInterface is the struct that's finalized
type powerProfileMonitorInterface struct {
	native *C.GPowerProfileMonitorInterface
}

// UnsafePowerProfileMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PowerProfileMonitorInterface) instance() *C.GPowerProfileMonitorInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePowerProfileMonitorInterfaceFromGlibBorrow is used to convert raw C.GPowerProfileMonitorInterface pointers to go. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p unsafe.Pointer) *PowerProfileMonitorInterface {
	if p == nil {
		return nil
	}
	return &PowerProfileMonitorInterface{&powerProfileMonitorInterface{(*C.GPowerProfileMonitorInterface)(p)}}
}

// UnsafePowerProfileMonitorInterfaceFromGlibNone is used to convert raw C.GPowerProfileMonitorInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibNone(p unsafe.Pointer) *PowerProfileMonitorInterface {
	wrapped := UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PowerProfileMonitorInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePowerProfileMonitorInterfaceFromGlibFull is used to convert raw C.GPowerProfileMonitorInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceFromGlibFull(p unsafe.Pointer) *PowerProfileMonitorInterface {
	wrapped := UnsafePowerProfileMonitorInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.powerProfileMonitorInterface,
		func (intern *powerProfileMonitorInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePowerProfileMonitorInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PowerProfileMonitorInterface] is expected to work anymore.
func UnsafePowerProfileMonitorInterfaceFree(p *PowerProfileMonitorInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePowerProfileMonitorInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceToGlibNone(p *PowerProfileMonitorInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePowerProfileMonitorInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePowerProfileMonitorInterfaceToGlibFull(p *PowerProfileMonitorInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.powerProfileMonitorInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PowerProfileMonitorInterface is invalid from here on
	return _p
}

// ProxyAddressClass wraps GProxyAddressClass
//
// Class structure for #GProxyAddress.
// 
// ProxyAddressClass is the type struct for [ProxyAddress]
type ProxyAddressClass struct {
	*proxyAddressClass
}

// proxyAddressClass is the struct that's finalized
type proxyAddressClass struct {
	native *C.GProxyAddressClass
}

// UnsafeProxyAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyAddressClass) instance() *C.GProxyAddressClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyAddressClassFromGlibBorrow is used to convert raw C.GProxyAddressClass pointers to go. This is used by the bindings internally.
func UnsafeProxyAddressClassFromGlibBorrow(p unsafe.Pointer) *ProxyAddressClass {
	if p == nil {
		return nil
	}
	return &ProxyAddressClass{&proxyAddressClass{(*C.GProxyAddressClass)(p)}}
}

// UnsafeProxyAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyAddressClass] is expected to work anymore.
func UnsafeProxyAddressClassFree(p *ProxyAddressClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyAddressClassToGlibNone(p *ProxyAddressClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *ProxyAddressClass) ParentClass() *InetSocketAddressClass {
	parent := UnsafeInetSocketAddressClassFromGlibBorrow(UnsafeProxyAddressClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ProxyAddressClass) {}, p)
	return parent
}

// ProxyAddressEnumeratorClass wraps GProxyAddressEnumeratorClass
//
// Class structure for #GProxyAddressEnumerator.
// 
// ProxyAddressEnumeratorClass is the type struct for [ProxyAddressEnumerator]
type ProxyAddressEnumeratorClass struct {
	*proxyAddressEnumeratorClass
}

// proxyAddressEnumeratorClass is the struct that's finalized
type proxyAddressEnumeratorClass struct {
	native *C.GProxyAddressEnumeratorClass
}

// UnsafeProxyAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyAddressEnumeratorClass) instance() *C.GProxyAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyAddressEnumeratorClassFromGlibBorrow is used to convert raw C.GProxyAddressEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *ProxyAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return &ProxyAddressEnumeratorClass{&proxyAddressEnumeratorClass{(*C.GProxyAddressEnumeratorClass)(p)}}
}

// UnsafeProxyAddressEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyAddressEnumeratorClass] is expected to work anymore.
func UnsafeProxyAddressEnumeratorClassFree(p *ProxyAddressEnumeratorClass) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyAddressEnumeratorClassToGlibNone(p *ProxyAddressEnumeratorClass) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (p *ProxyAddressEnumeratorClass) ParentClass() *SocketAddressEnumeratorClass {
	parent := UnsafeSocketAddressEnumeratorClassFromGlibBorrow(UnsafeProxyAddressEnumeratorClassToGlibNone(p))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ProxyAddressEnumeratorClass) {}, p)
	return parent
}

// ProxyInterface wraps GProxyInterface
//
// Provides an interface for handling proxy connection and payload.
type ProxyInterface struct {
	*proxyInterface
}

// proxyInterface is the struct that's finalized
type proxyInterface struct {
	native *C.GProxyInterface
}

// UnsafeProxyInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyInterface) instance() *C.GProxyInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyInterfaceFromGlibBorrow is used to convert raw C.GProxyInterface pointers to go. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibBorrow(p unsafe.Pointer) *ProxyInterface {
	if p == nil {
		return nil
	}
	return &ProxyInterface{&proxyInterface{(*C.GProxyInterface)(p)}}
}

// UnsafeProxyInterfaceFromGlibNone is used to convert raw C.GProxyInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibNone(p unsafe.Pointer) *ProxyInterface {
	wrapped := UnsafeProxyInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ProxyInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeProxyInterfaceFromGlibFull is used to convert raw C.GProxyInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeProxyInterfaceFromGlibFull(p unsafe.Pointer) *ProxyInterface {
	wrapped := UnsafeProxyInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.proxyInterface,
		func (intern *proxyInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeProxyInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyInterface] is expected to work anymore.
func UnsafeProxyInterfaceFree(p *ProxyInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyInterfaceToGlibNone(p *ProxyInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafeProxyInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeProxyInterfaceToGlibFull(p *ProxyInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.proxyInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // ProxyInterface is invalid from here on
	return _p
}

// ProxyResolverInterface wraps GProxyResolverInterface
//
// The virtual function table for #GProxyResolver.
type ProxyResolverInterface struct {
	*proxyResolverInterface
}

// proxyResolverInterface is the struct that's finalized
type proxyResolverInterface struct {
	native *C.GProxyResolverInterface
}

// UnsafeProxyResolverInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *ProxyResolverInterface) instance() *C.GProxyResolverInterface {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafeProxyResolverInterfaceFromGlibBorrow is used to convert raw C.GProxyResolverInterface pointers to go. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibBorrow(p unsafe.Pointer) *ProxyResolverInterface {
	if p == nil {
		return nil
	}
	return &ProxyResolverInterface{&proxyResolverInterface{(*C.GProxyResolverInterface)(p)}}
}

// UnsafeProxyResolverInterfaceFromGlibNone is used to convert raw C.GProxyResolverInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibNone(p unsafe.Pointer) *ProxyResolverInterface {
	wrapped := UnsafeProxyResolverInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ProxyResolverInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeProxyResolverInterfaceFromGlibFull is used to convert raw C.GProxyResolverInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceFromGlibFull(p unsafe.Pointer) *ProxyResolverInterface {
	wrapped := UnsafeProxyResolverInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.proxyResolverInterface,
		func (intern *proxyResolverInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeProxyResolverInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ProxyResolverInterface] is expected to work anymore.
func UnsafeProxyResolverInterfaceFree(p *ProxyResolverInterface) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafeProxyResolverInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeProxyResolverInterfaceToGlibNone(p *ProxyResolverInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafeProxyResolverInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeProxyResolverInterfaceToGlibFull(p *ProxyResolverInterface) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.proxyResolverInterface, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // ProxyResolverInterface is invalid from here on
	return _p
}

// RemoteActionGroupInterface wraps GRemoteActionGroupInterface
//
// The virtual function table for #GRemoteActionGroup.
type RemoteActionGroupInterface struct {
	*remoteActionGroupInterface
}

// remoteActionGroupInterface is the struct that's finalized
type remoteActionGroupInterface struct {
	native *C.GRemoteActionGroupInterface
}

// UnsafeRemoteActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RemoteActionGroupInterface) instance() *C.GRemoteActionGroupInterface {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRemoteActionGroupInterfaceFromGlibBorrow is used to convert raw C.GRemoteActionGroupInterface pointers to go. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p unsafe.Pointer) *RemoteActionGroupInterface {
	if p == nil {
		return nil
	}
	return &RemoteActionGroupInterface{&remoteActionGroupInterface{(*C.GRemoteActionGroupInterface)(p)}}
}

// UnsafeRemoteActionGroupInterfaceFromGlibNone is used to convert raw C.GRemoteActionGroupInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibNone(p unsafe.Pointer) *RemoteActionGroupInterface {
	wrapped := UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RemoteActionGroupInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRemoteActionGroupInterfaceFromGlibFull is used to convert raw C.GRemoteActionGroupInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceFromGlibFull(p unsafe.Pointer) *RemoteActionGroupInterface {
	wrapped := UnsafeRemoteActionGroupInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.remoteActionGroupInterface,
		func (intern *remoteActionGroupInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRemoteActionGroupInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RemoteActionGroupInterface] is expected to work anymore.
func UnsafeRemoteActionGroupInterfaceFree(r *RemoteActionGroupInterface) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRemoteActionGroupInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceToGlibNone(r *RemoteActionGroupInterface) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRemoteActionGroupInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRemoteActionGroupInterfaceToGlibFull(r *RemoteActionGroupInterface) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.remoteActionGroupInterface, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RemoteActionGroupInterface is invalid from here on
	return _p
}

// ResolverClass wraps GResolverClass
// 
// ResolverClass is the type struct for [Resolver]
type ResolverClass struct {
	*resolverClass
}

// resolverClass is the struct that's finalized
type resolverClass struct {
	native *C.GResolverClass
}

// UnsafeResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *ResolverClass) instance() *C.GResolverClass {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeResolverClassFromGlibBorrow is used to convert raw C.GResolverClass pointers to go. This is used by the bindings internally.
func UnsafeResolverClassFromGlibBorrow(p unsafe.Pointer) *ResolverClass {
	if p == nil {
		return nil
	}
	return &ResolverClass{&resolverClass{(*C.GResolverClass)(p)}}
}

// UnsafeResolverClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ResolverClass] is expected to work anymore.
func UnsafeResolverClassFree(r *ResolverClass) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeResolverClassToGlibNone(r *ResolverClass) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (r *ResolverClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeResolverClassToGlibNone(r))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ResolverClass) {}, r)
	return parent
}

// SeekableIface wraps GSeekableIface
//
// Provides an interface for implementing seekable functionality on I/O Streams.
type SeekableIface struct {
	*seekableIface
}

// seekableIface is the struct that's finalized
type seekableIface struct {
	native *C.GSeekableIface
}

// UnsafeSeekableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SeekableIface) instance() *C.GSeekableIface {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSeekableIfaceFromGlibBorrow is used to convert raw C.GSeekableIface pointers to go. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibBorrow(p unsafe.Pointer) *SeekableIface {
	if p == nil {
		return nil
	}
	return &SeekableIface{&seekableIface{(*C.GSeekableIface)(p)}}
}

// UnsafeSeekableIfaceFromGlibNone is used to convert raw C.GSeekableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibNone(p unsafe.Pointer) *SeekableIface {
	wrapped := UnsafeSeekableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SeekableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSeekableIfaceFromGlibFull is used to convert raw C.GSeekableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSeekableIfaceFromGlibFull(p unsafe.Pointer) *SeekableIface {
	wrapped := UnsafeSeekableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.seekableIface,
		func (intern *seekableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSeekableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SeekableIface] is expected to work anymore.
func UnsafeSeekableIfaceFree(s *SeekableIface) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSeekableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSeekableIfaceToGlibNone(s *SeekableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSeekableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSeekableIfaceToGlibFull(s *SeekableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.seekableIface, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SeekableIface is invalid from here on
	return _p
}

// SettingsClass wraps GSettingsClass
// 
// SettingsClass is the type struct for [Settings]
type SettingsClass struct {
	*settingsClass
}

// settingsClass is the struct that's finalized
type settingsClass struct {
	native *C.GSettingsClass
}

// UnsafeSettingsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsClass) instance() *C.GSettingsClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSettingsClassFromGlibBorrow is used to convert raw C.GSettingsClass pointers to go. This is used by the bindings internally.
func UnsafeSettingsClassFromGlibBorrow(p unsafe.Pointer) *SettingsClass {
	if p == nil {
		return nil
	}
	return &SettingsClass{&settingsClass{(*C.GSettingsClass)(p)}}
}

// UnsafeSettingsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsClass] is expected to work anymore.
func UnsafeSettingsClassFree(s *SettingsClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSettingsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsClassToGlibNone(s *SettingsClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SettingsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSettingsClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SettingsClass) {}, s)
	return parent
}

// SettingsSchema wraps GSettingsSchema
//
// The [struct@Gio.SettingsSchemaSource] and `GSettingsSchema` APIs provide a
// mechanism for advanced control over the loading of schemas and a
// mechanism for introspecting their content.
// 
// Plugin loading systems that wish to provide plugins a way to access
// settings face the problem of how to make the schemas for these
// settings visible to GSettings.  Typically, a plugin will want to ship
// the schema along with itself and it won't be installed into the
// standard system directories for schemas.
// 
// [struct@Gio.SettingsSchemaSource] provides a mechanism for dealing with this
// by allowing the creation of a new &#x2018;schema source&#x2019; from which schemas can
// be acquired.  This schema source can then become part of the metadata
// associated with the plugin and queried whenever the plugin requires
// access to some settings.
// 
// Consider the following example:
// 
// ```c
// typedef struct
// {
//    &#x2026;
//    GSettingsSchemaSource *schema_source;
//    &#x2026;
// } Plugin;
// 
// Plugin *
// initialise_plugin (const gchar *dir)
// {
//   Plugin *plugin;
// 
//   &#x2026;
// 
//   plugin-&gt;schema_source =
//     g_settings_schema_source_new_from_directory (dir,
//       g_settings_schema_source_get_default (), FALSE, NULL);
// 
//   &#x2026;
// 
//   return plugin;
// }
// 
// &#x2026;
// 
// GSettings *
// plugin_get_settings (Plugin      *plugin,
//                      const gchar *schema_id)
// {
//   GSettingsSchema *schema;
// 
//   if (schema_id == NULL)
//     schema_id = plugin-&gt;identifier;
// 
//   schema = g_settings_schema_source_lookup (plugin-&gt;schema_source,
//                                             schema_id, FALSE);
// 
//   if (schema == NULL)
//     {
//       &#x2026; disable the plugin or abort, etc &#x2026;
//     }
// 
//   return g_settings_new_full (schema, NULL, NULL);
// }
// ```
// 
// The code above shows how hooks should be added to the code that
// initialises (or enables) the plugin to create the schema source and
// how an API can be added to the plugin system to provide a convenient
// way for the plugin to access its settings, using the schemas that it
// ships.
// 
// From the standpoint of the plugin, it would need to ensure that it
// ships a gschemas.compiled file as part of itself, and then simply do
// the following:
// 
// ```c
// {
//   GSettings *settings;
//   gint some_value;
// 
//   settings = plugin_get_settings (self, NULL);
//   some_value = g_settings_get_int (settings, "some-value");
//   &#x2026;
// }
// ```
// 
// It's also possible that the plugin system expects the schema source
// files (ie: `.gschema.xml` files) instead of a `gschemas.compiled` file.
// In that case, the plugin loading system must compile the schemas for
// itself before attempting to create the settings source.
type SettingsSchema struct {
	*settingsSchema
}

// settingsSchema is the struct that's finalized
type settingsSchema struct {
	native *C.GSettingsSchema
}

// UnsafeSettingsSchemaToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchema) instance() *C.GSettingsSchema {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchema)(nil)

func marshalSettingsSchema(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaFromGlibNone(b), nil
}

func (r *SettingsSchema) GoValueType() gobject.Type {
	return TypeSettingsSchema
}

func (r *SettingsSchema) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaFromGlibBorrow is used to convert raw C.GSettingsSchema pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibBorrow(p unsafe.Pointer) *SettingsSchema {
	if p == nil {
		return nil
	}
	return &SettingsSchema{&settingsSchema{(*C.GSettingsSchema)(p)}}
}

// UnsafeSettingsSchemaFromGlibNone is used to convert raw C.GSettingsSchema pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibNone(p unsafe.Pointer) *SettingsSchema {
	C.g_settings_schema_ref((*C.GSettingsSchema)(p))
	wrapped := UnsafeSettingsSchemaFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchema,
		func (intern *settingsSchema) {
			C.g_settings_schema_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaFromGlibFull is used to convert raw C.GSettingsSchema pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaFromGlibFull(p unsafe.Pointer) *SettingsSchema {
	wrapped := UnsafeSettingsSchemaFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchema,
		func (intern *settingsSchema) {
			C.g_settings_schema_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchema.UnsafeSettingsSchemaUnref], then [SettingsSchema] will leak memory.
func UnsafeSettingsSchemaRef(s *SettingsSchema) {
	C.g_settings_schema_ref(s.native)
}

// UnsafeSettingsSchemaUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchema] is expected to work anymore.
func UnsafeSettingsSchemaUnref(s *SettingsSchema) {
	C.g_settings_schema_unref(s.native)
}

// UnsafeSettingsSchemaToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaToGlibNone(s *SettingsSchema) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaToGlibFull(s *SettingsSchema) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchema, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchema is invalid from here on
	return _p
}

// GetID wraps g_settings_schema_get_id
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Get the ID of @schema.
func (schema *SettingsSchema) GetID() string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  *C.gchar           // return, none, string

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_get_id(carg0)
	runtime.KeepAlive(schema)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetKey wraps g_settings_schema_get_key
// 
// The function takes the following parameters:
// 
// 	- name string: the name of a key 
// 
// The function returns the following values:
// 
// 	- goret *SettingsSchemaKey 
//
// Gets the key named @name from @schema.
// 
// It is a programmer error to request a key that does not exist.  See
// g_settings_schema_list_keys().
func (schema *SettingsSchema) GetKey(name string) *SettingsSchemaKey {
	var carg0 *C.GSettingsSchema    // in, none, converted
	var carg1 *C.gchar              // in, none, string
	var cret  *C.GSettingsSchemaKey // return, full, converted

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_schema_get_key(carg0, carg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var goret *SettingsSchemaKey

	goret = UnsafeSettingsSchemaKeyFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetPath wraps g_settings_schema_get_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the path associated with @schema, or %NULL.
// 
// Schemas may be single-instance or relocatable.  Single-instance
// schemas correspond to exactly one set of keys in the backend
// database: those located at the path returned by this function.
// 
// Relocatable schemas can be referenced by other schemas and can
// therefore describe multiple sets of keys at different locations.  For
// relocatable schemas, this function will return %NULL.
func (schema *SettingsSchema) GetPath() string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  *C.gchar           // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_get_path(carg0)
	runtime.KeepAlive(schema)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HasKey wraps g_settings_schema_has_key
// 
// The function takes the following parameters:
// 
// 	- name string: the name of a key 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @schema has a key named @name.
func (schema *SettingsSchema) HasKey(name string) bool {
	var carg0 *C.GSettingsSchema // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var cret  C.gboolean         // return

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_settings_schema_has_key(carg0, carg1)
	runtime.KeepAlive(schema)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ListChildren wraps g_settings_schema_list_children
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the list of children in @schema.
// 
// You should free the return value with g_strfreev() when you are done
// with it.
func (schema *SettingsSchema) ListChildren() []string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_list_children(carg0)
	runtime.KeepAlive(schema)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// ListKeys wraps g_settings_schema_list_keys
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Introspects the list of keys on @schema.
// 
// You should probably not be calling this function from "normal" code
// (since you should already know what keys are in your schema).  This
// function is intended for introspection reasons.
func (schema *SettingsSchema) ListKeys() []string {
	var carg0 *C.GSettingsSchema // in, none, converted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GSettingsSchema)(UnsafeSettingsSchemaToGlibNone(schema))

	cret = C.g_settings_schema_list_keys(carg0)
	runtime.KeepAlive(schema)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// SettingsSchemaKey wraps GSettingsSchemaKey
//
// #GSettingsSchemaKey is an opaque data structure and can only be accessed
// using the following functions.
type SettingsSchemaKey struct {
	*settingsSchemaKey
}

// settingsSchemaKey is the struct that's finalized
type settingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

// UnsafeSettingsSchemaKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchemaKey) instance() *C.GSettingsSchemaKey {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchemaKey)(nil)

func marshalSettingsSchemaKey(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaKeyFromGlibNone(b), nil
}

func (r *SettingsSchemaKey) GoValueType() gobject.Type {
	return TypeSettingsSchemaKey
}

func (r *SettingsSchemaKey) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaKeyFromGlibBorrow is used to convert raw C.GSettingsSchemaKey pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibBorrow(p unsafe.Pointer) *SettingsSchemaKey {
	if p == nil {
		return nil
	}
	return &SettingsSchemaKey{&settingsSchemaKey{(*C.GSettingsSchemaKey)(p)}}
}

// UnsafeSettingsSchemaKeyFromGlibNone is used to convert raw C.GSettingsSchemaKey pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibNone(p unsafe.Pointer) *SettingsSchemaKey {
	C.g_settings_schema_key_ref((*C.GSettingsSchemaKey)(p))
	wrapped := UnsafeSettingsSchemaKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchemaKey,
		func (intern *settingsSchemaKey) {
			C.g_settings_schema_key_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaKeyFromGlibFull is used to convert raw C.GSettingsSchemaKey pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyFromGlibFull(p unsafe.Pointer) *SettingsSchemaKey {
	wrapped := UnsafeSettingsSchemaKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchemaKey,
		func (intern *settingsSchemaKey) {
			C.g_settings_schema_key_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaKeyRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchemaKey.UnsafeSettingsSchemaKeyUnref], then [SettingsSchemaKey] will leak memory.
func UnsafeSettingsSchemaKeyRef(s *SettingsSchemaKey) {
	C.g_settings_schema_key_ref(s.native)
}

// UnsafeSettingsSchemaKeyUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchemaKey] is expected to work anymore.
func UnsafeSettingsSchemaKeyUnref(s *SettingsSchemaKey) {
	C.g_settings_schema_key_unref(s.native)
}

// UnsafeSettingsSchemaKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaKeyToGlibNone(s *SettingsSchemaKey) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaKeyToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaKeyToGlibFull(s *SettingsSchemaKey) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchemaKey, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchemaKey is invalid from here on
	return _p
}

// GetDescription wraps g_settings_schema_key_get_description
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the description for @key.
// 
// If no description has been provided in the schema for @key, returns
// %NULL.
// 
// The description can be one sentence to several paragraphs in length.
// Paragraphs are delimited with a double newline.  Descriptions can be
// translated and the value returned from this function is is the
// current locale.
// 
// This function is slow.  The summary and description information for
// the schemas is not stored in the compiled schema database so this
// function has to parse all of the source XML files in the schema
// directory.
func (key *SettingsSchemaKey) GetDescription() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_description(carg0)
	runtime.KeepAlive(key)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetName wraps g_settings_schema_key_get_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the name of @key.
func (key *SettingsSchemaKey) GetName() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_name(carg0)
	runtime.KeepAlive(key)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetSummary wraps g_settings_schema_key_get_summary
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the summary for @key.
// 
// If no summary has been provided in the schema for @key, returns
// %NULL.
// 
// The summary is a short description of the purpose of the key; usually
// one short sentence.  Summaries can be translated and the value
// returned from this function is is the current locale.
// 
// This function is slow.  The summary and description information for
// the schemas is not stored in the compiled schema database so this
// function has to parse all of the source XML files in the schema
// directory.
func (key *SettingsSchemaKey) GetSummary() string {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.gchar              // return, none, string, nullable-string

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_summary(carg0)
	runtime.KeepAlive(key)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetValueType wraps g_settings_schema_key_get_value_type
// 
// The function returns the following values:
// 
// 	- goret *glib.VariantType 
//
// Gets the #GVariantType of @key.
func (key *SettingsSchemaKey) GetValueType() *glib.VariantType {
	var carg0 *C.GSettingsSchemaKey // in, none, converted
	var cret  *C.GVariantType       // return, none, converted

	carg0 = (*C.GSettingsSchemaKey)(UnsafeSettingsSchemaKeyToGlibNone(key))

	cret = C.g_settings_schema_key_get_value_type(carg0)
	runtime.KeepAlive(key)

	var goret *glib.VariantType

	goret = glib.UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SettingsSchemaSource wraps GSettingsSchemaSource
//
// This is an opaque structure type.  You may not access it directly.
type SettingsSchemaSource struct {
	*settingsSchemaSource
}

// settingsSchemaSource is the struct that's finalized
type settingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

// UnsafeSettingsSchemaSourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SettingsSchemaSource) instance() *C.GSettingsSchemaSource {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SettingsSchemaSource)(nil)

func marshalSettingsSchemaSource(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSettingsSchemaSourceFromGlibNone(b), nil
}

func (r *SettingsSchemaSource) GoValueType() gobject.Type {
	return TypeSettingsSchemaSource
}

func (r *SettingsSchemaSource) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSettingsSchemaSourceFromGlibBorrow is used to convert raw C.GSettingsSchemaSource pointers to go. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibBorrow(p unsafe.Pointer) *SettingsSchemaSource {
	if p == nil {
		return nil
	}
	return &SettingsSchemaSource{&settingsSchemaSource{(*C.GSettingsSchemaSource)(p)}}
}

// UnsafeSettingsSchemaSourceFromGlibNone is used to convert raw C.GSettingsSchemaSource pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibNone(p unsafe.Pointer) *SettingsSchemaSource {
	C.g_settings_schema_source_ref((*C.GSettingsSchemaSource)(p))
	wrapped := UnsafeSettingsSchemaSourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.settingsSchemaSource,
		func (intern *settingsSchemaSource) {
			C.g_settings_schema_source_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaSourceFromGlibFull is used to convert raw C.GSettingsSchemaSource pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceFromGlibFull(p unsafe.Pointer) *SettingsSchemaSource {
	wrapped := UnsafeSettingsSchemaSourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.settingsSchemaSource,
		func (intern *settingsSchemaSource) {
			C.g_settings_schema_source_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeSettingsSchemaSourceRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [SettingsSchemaSource.UnsafeSettingsSchemaSourceUnref], then [SettingsSchemaSource] will leak memory.
func UnsafeSettingsSchemaSourceRef(s *SettingsSchemaSource) {
	C.g_settings_schema_source_ref(s.native)
}

// UnsafeSettingsSchemaSourceUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SettingsSchemaSource] is expected to work anymore.
func UnsafeSettingsSchemaSourceUnref(s *SettingsSchemaSource) {
	C.g_settings_schema_source_unref(s.native)
}

// UnsafeSettingsSchemaSourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSettingsSchemaSourceToGlibNone(s *SettingsSchemaSource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSettingsSchemaSourceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSettingsSchemaSourceToGlibFull(s *SettingsSchemaSource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.settingsSchemaSource, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SettingsSchemaSource is invalid from here on
	return _p
}

// NewSettingsSchemaSourceFromDirectory wraps g_settings_schema_source_new_from_directory
// 
// The function takes the following parameters:
// 
// 	- directory string: the filename of a directory 
// 	- parent *SettingsSchemaSource (nullable): a #GSettingsSchemaSource, or %NULL 
// 	- trusted bool: %TRUE, if the directory is trusted 
// 
// The function returns the following values:
// 
// 	- goret *SettingsSchemaSource 
// 	- _goerr error (nullable): an error 
//
// Attempts to create a new schema source corresponding to the contents
// of the given directory.
// 
// This function is not required for normal uses of #GSettings but it
// may be useful to authors of plugin management systems.
// 
// The directory should contain a file called `gschemas.compiled` as
// produced by the [glib-compile-schemas][glib-compile-schemas] tool.
// 
// If @trusted is %TRUE then `gschemas.compiled` is trusted not to be
// corrupted. This assumption has a performance advantage, but can result
// in crashes or inconsistent behaviour in the case of a corrupted file.
// Generally, you should set @trusted to %TRUE for files installed by the
// system and to %FALSE for files in the home directory.
// 
// In either case, an empty file or some types of corruption in the file will
// result in %G_FILE_ERROR_INVAL being returned.
// 
// If @parent is non-%NULL then there are two effects.
// 
// First, if g_settings_schema_source_lookup() is called with the
// @recursive flag set to %TRUE and the schema can not be found in the
// source, the lookup will recurse to the parent.
// 
// Second, any references to other schemas specified within this
// source (ie: `child` or `extends`) references may be resolved
// from the @parent.
// 
// For this second reason, except in very unusual situations, the
// @parent should probably be given as the default schema source, as
// returned by g_settings_schema_source_get_default().
func NewSettingsSchemaSourceFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	var carg1 *C.gchar                 // in, none, string
	var carg2 *C.GSettingsSchemaSource // in, none, converted, nullable
	var carg3 C.gboolean               // in
	var cret  *C.GSettingsSchemaSource // return, full, converted
	var _cerr *C.GError                // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(directory)))
	defer C.free(unsafe.Pointer(carg1))
	if parent != nil {
		carg2 = (*C.GSettingsSchemaSource)(UnsafeSettingsSchemaSourceToGlibNone(parent))
	}
	if trusted {
		carg3 = C.TRUE
	}

	cret = C.g_settings_schema_source_new_from_directory(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(directory)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(trusted)

	var goret  *SettingsSchemaSource
	var _goerr error

	goret = UnsafeSettingsSchemaSourceFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = glib.UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SettingsSchemaSourceGetDefault wraps g_settings_schema_source_get_default
// 
// The function returns the following values:
// 
// 	- goret *SettingsSchemaSource (nullable) 
//
// Gets the default system schema source.
// 
// This function is not required for normal uses of #GSettings but it
// may be useful to authors of plugin management systems or to those who
// want to introspect the content of schemas.
// 
// If no schemas are installed, %NULL will be returned.
// 
// The returned source may actually consist of multiple schema sources
// from different directories, depending on which directories were given
// in `XDG_DATA_DIRS` and `GSETTINGS_SCHEMA_DIR`. For this reason, all
// lookups performed against the default source should probably be done
// recursively.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {
	var cret *C.GSettingsSchemaSource // return, none, converted, nullable

	cret = C.g_settings_schema_source_get_default()

	var goret *SettingsSchemaSource

	if cret != nil {
		goret = UnsafeSettingsSchemaSourceFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Lookup wraps g_settings_schema_source_lookup
// 
// The function takes the following parameters:
// 
// 	- schemaId string: a schema ID 
// 	- recursive bool: %TRUE if the lookup should be recursive 
// 
// The function returns the following values:
// 
// 	- goret *SettingsSchema (nullable) 
//
// Looks up a schema with the identifier @schema_id in @source.
// 
// This function is not required for normal uses of #GSettings but it
// may be useful to authors of plugin management systems or to those who
// want to introspect the content of schemas.
// 
// If the schema isn't found directly in @source and @recursive is %TRUE
// then the parent sources will also be checked.
// 
// If the schema isn't found, %NULL is returned.
func (source *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	var carg0 *C.GSettingsSchemaSource // in, none, converted
	var carg1 *C.gchar                 // in, none, string
	var carg2 C.gboolean               // in
	var cret  *C.GSettingsSchema       // return, full, converted, nullable

	carg0 = (*C.GSettingsSchemaSource)(UnsafeSettingsSchemaSourceToGlibNone(source))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(schemaId)))
	defer C.free(unsafe.Pointer(carg1))
	if recursive {
		carg2 = C.TRUE
	}

	cret = C.g_settings_schema_source_lookup(carg0, carg1, carg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(schemaId)
	runtime.KeepAlive(recursive)

	var goret *SettingsSchema

	if cret != nil {
		goret = UnsafeSettingsSchemaFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// SimpleActionGroupClass wraps GSimpleActionGroupClass
// 
// SimpleActionGroupClass is the type struct for [SimpleActionGroup]
type SimpleActionGroupClass struct {
	*simpleActionGroupClass
}

// simpleActionGroupClass is the struct that's finalized
type simpleActionGroupClass struct {
	native *C.GSimpleActionGroupClass
}

// UnsafeSimpleActionGroupClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleActionGroupClass) instance() *C.GSimpleActionGroupClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleActionGroupClassFromGlibBorrow is used to convert raw C.GSimpleActionGroupClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleActionGroupClassFromGlibBorrow(p unsafe.Pointer) *SimpleActionGroupClass {
	if p == nil {
		return nil
	}
	return &SimpleActionGroupClass{&simpleActionGroupClass{(*C.GSimpleActionGroupClass)(p)}}
}

// UnsafeSimpleActionGroupClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleActionGroupClass] is expected to work anymore.
func UnsafeSimpleActionGroupClassFree(s *SimpleActionGroupClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleActionGroupClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleActionGroupClassToGlibNone(s *SimpleActionGroupClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleActionGroupClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleActionGroupClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleActionGroupClass) {}, s)
	return parent
}

// SimpleAsyncResultClass wraps GSimpleAsyncResultClass
// 
// SimpleAsyncResultClass is the type struct for [SimpleAsyncResult]
type SimpleAsyncResultClass struct {
	*simpleAsyncResultClass
}

// simpleAsyncResultClass is the struct that's finalized
type simpleAsyncResultClass struct {
	native *C.GSimpleAsyncResultClass
}

// UnsafeSimpleAsyncResultClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleAsyncResultClass) instance() *C.GSimpleAsyncResultClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleAsyncResultClassFromGlibBorrow is used to convert raw C.GSimpleAsyncResultClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleAsyncResultClassFromGlibBorrow(p unsafe.Pointer) *SimpleAsyncResultClass {
	if p == nil {
		return nil
	}
	return &SimpleAsyncResultClass{&simpleAsyncResultClass{(*C.GSimpleAsyncResultClass)(p)}}
}

// UnsafeSimpleAsyncResultClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleAsyncResultClass] is expected to work anymore.
func UnsafeSimpleAsyncResultClassFree(s *SimpleAsyncResultClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleAsyncResultClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleAsyncResultClassToGlibNone(s *SimpleAsyncResultClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleAsyncResultClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleAsyncResultClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleAsyncResultClass) {}, s)
	return parent
}

// SimpleProxyResolverClass wraps GSimpleProxyResolverClass
// 
// SimpleProxyResolverClass is the type struct for [SimpleProxyResolver]
type SimpleProxyResolverClass struct {
	*simpleProxyResolverClass
}

// simpleProxyResolverClass is the struct that's finalized
type simpleProxyResolverClass struct {
	native *C.GSimpleProxyResolverClass
}

// UnsafeSimpleProxyResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SimpleProxyResolverClass) instance() *C.GSimpleProxyResolverClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSimpleProxyResolverClassFromGlibBorrow is used to convert raw C.GSimpleProxyResolverClass pointers to go. This is used by the bindings internally.
func UnsafeSimpleProxyResolverClassFromGlibBorrow(p unsafe.Pointer) *SimpleProxyResolverClass {
	if p == nil {
		return nil
	}
	return &SimpleProxyResolverClass{&simpleProxyResolverClass{(*C.GSimpleProxyResolverClass)(p)}}
}

// UnsafeSimpleProxyResolverClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SimpleProxyResolverClass] is expected to work anymore.
func UnsafeSimpleProxyResolverClassFree(s *SimpleProxyResolverClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSimpleProxyResolverClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSimpleProxyResolverClassToGlibNone(s *SimpleProxyResolverClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SimpleProxyResolverClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSimpleProxyResolverClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SimpleProxyResolverClass) {}, s)
	return parent
}

// SocketAddressClass wraps GSocketAddressClass
// 
// SocketAddressClass is the type struct for [SocketAddress]
type SocketAddressClass struct {
	*socketAddressClass
}

// socketAddressClass is the struct that's finalized
type socketAddressClass struct {
	native *C.GSocketAddressClass
}

// UnsafeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketAddressClass) instance() *C.GSocketAddressClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketAddressClassFromGlibBorrow is used to convert raw C.GSocketAddressClass pointers to go. This is used by the bindings internally.
func UnsafeSocketAddressClassFromGlibBorrow(p unsafe.Pointer) *SocketAddressClass {
	if p == nil {
		return nil
	}
	return &SocketAddressClass{&socketAddressClass{(*C.GSocketAddressClass)(p)}}
}

// UnsafeSocketAddressClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketAddressClass] is expected to work anymore.
func UnsafeSocketAddressClassFree(s *SocketAddressClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketAddressClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketAddressClassToGlibNone(s *SocketAddressClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketAddressClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketAddressClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketAddressClass) {}, s)
	return parent
}

// SocketAddressEnumeratorClass wraps GSocketAddressEnumeratorClass
//
// Class structure for #GSocketAddressEnumerator.
// 
// SocketAddressEnumeratorClass is the type struct for [SocketAddressEnumerator]
type SocketAddressEnumeratorClass struct {
	*socketAddressEnumeratorClass
}

// socketAddressEnumeratorClass is the struct that's finalized
type socketAddressEnumeratorClass struct {
	native *C.GSocketAddressEnumeratorClass
}

// UnsafeSocketAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketAddressEnumeratorClass) instance() *C.GSocketAddressEnumeratorClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketAddressEnumeratorClassFromGlibBorrow is used to convert raw C.GSocketAddressEnumeratorClass pointers to go. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorClassFromGlibBorrow(p unsafe.Pointer) *SocketAddressEnumeratorClass {
	if p == nil {
		return nil
	}
	return &SocketAddressEnumeratorClass{&socketAddressEnumeratorClass{(*C.GSocketAddressEnumeratorClass)(p)}}
}

// UnsafeSocketAddressEnumeratorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketAddressEnumeratorClass] is expected to work anymore.
func UnsafeSocketAddressEnumeratorClassFree(s *SocketAddressEnumeratorClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketAddressEnumeratorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketAddressEnumeratorClassToGlibNone(s *SocketAddressEnumeratorClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketAddressEnumeratorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketAddressEnumeratorClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketAddressEnumeratorClass) {}, s)
	return parent
}

// SocketClass wraps GSocketClass
// 
// SocketClass is the type struct for [Socket]
type SocketClass struct {
	*socketClass
}

// socketClass is the struct that's finalized
type socketClass struct {
	native *C.GSocketClass
}

// UnsafeSocketClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketClass) instance() *C.GSocketClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketClassFromGlibBorrow is used to convert raw C.GSocketClass pointers to go. This is used by the bindings internally.
func UnsafeSocketClassFromGlibBorrow(p unsafe.Pointer) *SocketClass {
	if p == nil {
		return nil
	}
	return &SocketClass{&socketClass{(*C.GSocketClass)(p)}}
}

// UnsafeSocketClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketClass] is expected to work anymore.
func UnsafeSocketClassFree(s *SocketClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketClassToGlibNone(s *SocketClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketClass) {}, s)
	return parent
}

// SocketClientClass wraps GSocketClientClass
// 
// SocketClientClass is the type struct for [SocketClient]
type SocketClientClass struct {
	*socketClientClass
}

// socketClientClass is the struct that's finalized
type socketClientClass struct {
	native *C.GSocketClientClass
}

// UnsafeSocketClientClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketClientClass) instance() *C.GSocketClientClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketClientClassFromGlibBorrow is used to convert raw C.GSocketClientClass pointers to go. This is used by the bindings internally.
func UnsafeSocketClientClassFromGlibBorrow(p unsafe.Pointer) *SocketClientClass {
	if p == nil {
		return nil
	}
	return &SocketClientClass{&socketClientClass{(*C.GSocketClientClass)(p)}}
}

// UnsafeSocketClientClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketClientClass] is expected to work anymore.
func UnsafeSocketClientClassFree(s *SocketClientClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketClientClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketClientClassToGlibNone(s *SocketClientClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketClientClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketClientClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketClientClass) {}, s)
	return parent
}

// SocketConnectableIface wraps GSocketConnectableIface
//
// Provides an interface for returning a #GSocketAddressEnumerator
// and #GProxyAddressEnumerator
type SocketConnectableIface struct {
	*socketConnectableIface
}

// socketConnectableIface is the struct that's finalized
type socketConnectableIface struct {
	native *C.GSocketConnectableIface
}

// UnsafeSocketConnectableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketConnectableIface) instance() *C.GSocketConnectableIface {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketConnectableIfaceFromGlibBorrow is used to convert raw C.GSocketConnectableIface pointers to go. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibBorrow(p unsafe.Pointer) *SocketConnectableIface {
	if p == nil {
		return nil
	}
	return &SocketConnectableIface{&socketConnectableIface{(*C.GSocketConnectableIface)(p)}}
}

// UnsafeSocketConnectableIfaceFromGlibNone is used to convert raw C.GSocketConnectableIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibNone(p unsafe.Pointer) *SocketConnectableIface {
	wrapped := UnsafeSocketConnectableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SocketConnectableIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSocketConnectableIfaceFromGlibFull is used to convert raw C.GSocketConnectableIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceFromGlibFull(p unsafe.Pointer) *SocketConnectableIface {
	wrapped := UnsafeSocketConnectableIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.socketConnectableIface,
		func (intern *socketConnectableIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSocketConnectableIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketConnectableIface] is expected to work anymore.
func UnsafeSocketConnectableIfaceFree(s *SocketConnectableIface) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketConnectableIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketConnectableIfaceToGlibNone(s *SocketConnectableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSocketConnectableIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSocketConnectableIfaceToGlibFull(s *SocketConnectableIface) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.socketConnectableIface, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SocketConnectableIface is invalid from here on
	return _p
}

// SocketConnectionClass wraps GSocketConnectionClass
// 
// SocketConnectionClass is the type struct for [SocketConnection]
type SocketConnectionClass struct {
	*socketConnectionClass
}

// socketConnectionClass is the struct that's finalized
type socketConnectionClass struct {
	native *C.GSocketConnectionClass
}

// UnsafeSocketConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketConnectionClass) instance() *C.GSocketConnectionClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketConnectionClassFromGlibBorrow is used to convert raw C.GSocketConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeSocketConnectionClassFromGlibBorrow(p unsafe.Pointer) *SocketConnectionClass {
	if p == nil {
		return nil
	}
	return &SocketConnectionClass{&socketConnectionClass{(*C.GSocketConnectionClass)(p)}}
}

// UnsafeSocketConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketConnectionClass] is expected to work anymore.
func UnsafeSocketConnectionClassFree(s *SocketConnectionClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketConnectionClassToGlibNone(s *SocketConnectionClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketConnectionClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeSocketConnectionClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketConnectionClass) {}, s)
	return parent
}

// SocketControlMessageClass wraps GSocketControlMessageClass
//
// Class structure for #GSocketControlMessage.
// 
// SocketControlMessageClass is the type struct for [SocketControlMessage]
type SocketControlMessageClass struct {
	*socketControlMessageClass
}

// socketControlMessageClass is the struct that's finalized
type socketControlMessageClass struct {
	native *C.GSocketControlMessageClass
}

// UnsafeSocketControlMessageClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketControlMessageClass) instance() *C.GSocketControlMessageClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketControlMessageClassFromGlibBorrow is used to convert raw C.GSocketControlMessageClass pointers to go. This is used by the bindings internally.
func UnsafeSocketControlMessageClassFromGlibBorrow(p unsafe.Pointer) *SocketControlMessageClass {
	if p == nil {
		return nil
	}
	return &SocketControlMessageClass{&socketControlMessageClass{(*C.GSocketControlMessageClass)(p)}}
}

// UnsafeSocketControlMessageClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketControlMessageClass] is expected to work anymore.
func UnsafeSocketControlMessageClassFree(s *SocketControlMessageClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketControlMessageClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketControlMessageClassToGlibNone(s *SocketControlMessageClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketControlMessageClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketControlMessageClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketControlMessageClass) {}, s)
	return parent
}

// SocketListenerClass wraps GSocketListenerClass
//
// Class structure for #GSocketListener.
// 
// SocketListenerClass is the type struct for [SocketListener]
type SocketListenerClass struct {
	*socketListenerClass
}

// socketListenerClass is the struct that's finalized
type socketListenerClass struct {
	native *C.GSocketListenerClass
}

// UnsafeSocketListenerClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketListenerClass) instance() *C.GSocketListenerClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketListenerClassFromGlibBorrow is used to convert raw C.GSocketListenerClass pointers to go. This is used by the bindings internally.
func UnsafeSocketListenerClassFromGlibBorrow(p unsafe.Pointer) *SocketListenerClass {
	if p == nil {
		return nil
	}
	return &SocketListenerClass{&socketListenerClass{(*C.GSocketListenerClass)(p)}}
}

// UnsafeSocketListenerClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketListenerClass] is expected to work anymore.
func UnsafeSocketListenerClassFree(s *SocketListenerClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketListenerClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketListenerClassToGlibNone(s *SocketListenerClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketListenerClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeSocketListenerClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketListenerClass) {}, s)
	return parent
}

// SocketServiceClass wraps GSocketServiceClass
//
// Class structure for #GSocketService.
// 
// SocketServiceClass is the type struct for [SocketService]
type SocketServiceClass struct {
	*socketServiceClass
}

// socketServiceClass is the struct that's finalized
type socketServiceClass struct {
	native *C.GSocketServiceClass
}

// UnsafeSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SocketServiceClass) instance() *C.GSocketServiceClass {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSocketServiceClassFromGlibBorrow is used to convert raw C.GSocketServiceClass pointers to go. This is used by the bindings internally.
func UnsafeSocketServiceClassFromGlibBorrow(p unsafe.Pointer) *SocketServiceClass {
	if p == nil {
		return nil
	}
	return &SocketServiceClass{&socketServiceClass{(*C.GSocketServiceClass)(p)}}
}

// UnsafeSocketServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SocketServiceClass] is expected to work anymore.
func UnsafeSocketServiceClassFree(s *SocketServiceClass) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSocketServiceClassToGlibNone(s *SocketServiceClass) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (s *SocketServiceClass) ParentClass() *SocketListenerClass {
	parent := UnsafeSocketListenerClassFromGlibBorrow(UnsafeSocketServiceClassToGlibNone(s))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *SocketServiceClass) {}, s)
	return parent
}

// SrvTarget wraps GSrvTarget
//
// A single target host/port that a network service is running on.
// 
// SRV (service) records are used by some network protocols to provide
// service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain;
// rather than connecting directly to &#x2018;example.com&#x2019; or assuming a
// specific server hostname like &#x2018;xmpp.example.com&#x2019;, an XMPP client
// would look up the `xmpp-client` SRV record for &#x2018;example.com&#x2019;, and
// then connect to whatever host was pointed to by that record.
// 
// You can use [method@Gio.Resolver.lookup_service] or
// [method@Gio.Resolver.lookup_service_async] to find the `GSrvTarget`s
// for a given service. However, if you are simply planning to connect
// to the remote service, you can use [class@Gio.NetworkService]&#x2019;s
// [iface@Gio.SocketConnectable] interface and not need to worry about
// `GSrvTarget` at all.
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized
type srvTarget struct {
	native *C.GSrvTarget
}

// UnsafeSrvTargetToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SrvTarget) instance() *C.GSrvTarget {
	if s == nil {
		return nil
	}
	return s.native
}

var _ gobject.GoValueInitializer = (*SrvTarget)(nil)

func marshalSrvTarget(p unsafe.Pointer) (interface{}, error) {
	b := gobject.ValueFromNative(p).Boxed()
	return UnsafeSrvTargetFromGlibNone(b), nil
}

func (r *SrvTarget) GoValueType() gobject.Type {
	return TypeSrvTarget
}

func (r *SrvTarget) SetGoValue(v *gobject.Value) {
	v.SetBoxed(unsafe.Pointer(r.instance()))
}

// UnsafeSrvTargetFromGlibBorrow is used to convert raw C.GSrvTarget pointers to go. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibBorrow(p unsafe.Pointer) *SrvTarget {
	if p == nil {
		return nil
	}
	return &SrvTarget{&srvTarget{(*C.GSrvTarget)(p)}}
}

// UnsafeSrvTargetFromGlibNone is used to convert raw C.GSrvTarget pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibNone(p unsafe.Pointer) *SrvTarget {
	wrapped := UnsafeSrvTargetFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeSrvTargetFromGlibFull is used to convert raw C.GSrvTarget pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSrvTargetFromGlibFull(p unsafe.Pointer) *SrvTarget {
	wrapped := UnsafeSrvTargetFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.srvTarget,
		func (intern *srvTarget) {
			C.g_srv_target_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeSrvTargetFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SrvTarget] is expected to work anymore.
func UnsafeSrvTargetFree(s *SrvTarget) {
	C.g_srv_target_free(s.native)
}

// UnsafeSrvTargetToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSrvTargetToGlibNone(s *SrvTarget) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSrvTargetToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSrvTargetToGlibFull(s *SrvTarget) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.srvTarget, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SrvTarget is invalid from here on
	return _p
}

// NewSrvTarget wraps g_srv_target_new
// 
// The function takes the following parameters:
// 
// 	- hostname string: the host that the service is running on 
// 	- port uint16: the port that the service is running on 
// 	- priority uint16: the target's priority 
// 	- weight uint16: the target's weight 
// 
// The function returns the following values:
// 
// 	- goret *SrvTarget 
//
// Creates a new #GSrvTarget with the given parameters.
// 
// You should not need to use this; normally #GSrvTargets are
// created by #GResolver.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var carg1 *C.gchar      // in, none, string
	var carg2 C.guint16     // in, none, casted
	var carg3 C.guint16     // in, none, casted
	var carg4 C.guint16     // in, none, casted
	var cret  *C.GSrvTarget // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint16(port)
	carg3 = C.guint16(priority)
	carg4 = C.guint16(weight)

	cret = C.g_srv_target_new(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(weight)

	var goret *SrvTarget

	goret = UnsafeSrvTargetFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_srv_target_copy
// 
// The function returns the following values:
// 
// 	- goret *SrvTarget 
//
// Copies @target
func (target *SrvTarget) Copy() *SrvTarget {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  *C.GSrvTarget // return, full, converted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_copy(carg0)
	runtime.KeepAlive(target)

	var goret *SrvTarget

	goret = UnsafeSrvTargetFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetHostname wraps g_srv_target_get_hostname
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to
// check if it contains encoded Unicode segments, and use
// g_hostname_to_unicode() to convert it if it does.)
func (target *SrvTarget) GetHostname() string {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_hostname(carg0)
	runtime.KeepAlive(target)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_srv_target_get_port
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @target's port
func (target *SrvTarget) GetPort() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_port(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetPriority wraps g_srv_target_get_priority
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in
// RFC 2782.
func (target *SrvTarget) GetPriority() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_priority(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// GetWeight wraps g_srv_target_get_weight
// 
// The function returns the following values:
// 
// 	- goret uint16 
//
// Gets @target's weight. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in
// RFC 2782.
func (target *SrvTarget) GetWeight() uint16 {
	var carg0 *C.GSrvTarget // in, none, converted
	var cret  C.guint16     // return, none, casted

	carg0 = (*C.GSrvTarget)(UnsafeSrvTargetToGlibNone(target))

	cret = C.g_srv_target_get_weight(carg0)
	runtime.KeepAlive(target)

	var goret uint16

	goret = uint16(cret)

	return goret
}

// StaticResource wraps GStaticResource
//
// `GStaticResource` is an opaque data structure and can only be accessed
// using the following functions.
type StaticResource struct {
	*staticResource
}

// staticResource is the struct that's finalized
type staticResource struct {
	native *C.GStaticResource
}

// UnsafeStaticResourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StaticResource) instance() *C.GStaticResource {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStaticResourceFromGlibBorrow is used to convert raw C.GStaticResource pointers to go. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibBorrow(p unsafe.Pointer) *StaticResource {
	if p == nil {
		return nil
	}
	return &StaticResource{&staticResource{(*C.GStaticResource)(p)}}
}

// UnsafeStaticResourceFromGlibNone is used to convert raw C.GStaticResource pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibNone(p unsafe.Pointer) *StaticResource {
	wrapped := UnsafeStaticResourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to StaticResource because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeStaticResourceFromGlibFull is used to convert raw C.GStaticResource pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStaticResourceFromGlibFull(p unsafe.Pointer) *StaticResource {
	wrapped := UnsafeStaticResourceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.staticResource,
		func (intern *staticResource) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeStaticResourceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StaticResource] is expected to work anymore.
func UnsafeStaticResourceFree(s *StaticResource) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeStaticResourceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStaticResourceToGlibNone(s *StaticResource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStaticResourceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStaticResourceToGlibFull(s *StaticResource) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.staticResource, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StaticResource is invalid from here on
	return _p
}

// Fini wraps g_static_resource_fini
//
// Finalizes a [struct@Gio.Resource] initialized by
// [method@Gio.StaticResource.init].
// 
// This is normally used by code generated by
// [`glib-compile-resources`](glib-compile-resources.html)
// and is not typically used by other code.
func (staticResource *StaticResource) Fini() {
	var carg0 *C.GStaticResource // in, none, converted

	carg0 = (*C.GStaticResource)(UnsafeStaticResourceToGlibNone(staticResource))

	C.g_static_resource_fini(carg0)
	runtime.KeepAlive(staticResource)
}

// Init wraps g_static_resource_init
//
// Initializes a [struct@Gio.Resource] from static data using a
// [struct@Gio.StaticResource].
// 
// This is normally used by code generated by
// [`glib-compile-resources`](glib-compile-resources.html)
// and is not typically used by other code.
func (staticResource *StaticResource) Init() {
	var carg0 *C.GStaticResource // in, none, converted

	carg0 = (*C.GStaticResource)(UnsafeStaticResourceToGlibNone(staticResource))

	C.g_static_resource_init(carg0)
	runtime.KeepAlive(staticResource)
}

// TaskClass wraps GTaskClass
// 
// TaskClass is the type struct for [Task]
type TaskClass struct {
	*taskClass
}

// taskClass is the struct that's finalized
type taskClass struct {
	native *C.GTaskClass
}

// UnsafeTaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TaskClass) instance() *C.GTaskClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTaskClassFromGlibBorrow is used to convert raw C.GTaskClass pointers to go. This is used by the bindings internally.
func UnsafeTaskClassFromGlibBorrow(p unsafe.Pointer) *TaskClass {
	if p == nil {
		return nil
	}
	return &TaskClass{&taskClass{(*C.GTaskClass)(p)}}
}

// UnsafeTaskClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TaskClass] is expected to work anymore.
func UnsafeTaskClassFree(t *TaskClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTaskClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTaskClassToGlibNone(t *TaskClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TaskClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTaskClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TaskClass) {}, t)
	return parent
}

// TcpConnectionClass wraps GTcpConnectionClass
// 
// TcpConnectionClass is the type struct for [TcpConnection]
type TcpConnectionClass struct {
	*tcpConnectionClass
}

// tcpConnectionClass is the struct that's finalized
type tcpConnectionClass struct {
	native *C.GTcpConnectionClass
}

// UnsafeTcpConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TcpConnectionClass) instance() *C.GTcpConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTcpConnectionClassFromGlibBorrow is used to convert raw C.GTcpConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTcpConnectionClassFromGlibBorrow(p unsafe.Pointer) *TcpConnectionClass {
	if p == nil {
		return nil
	}
	return &TcpConnectionClass{&tcpConnectionClass{(*C.GTcpConnectionClass)(p)}}
}

// UnsafeTcpConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TcpConnectionClass] is expected to work anymore.
func UnsafeTcpConnectionClassFree(t *TcpConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTcpConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTcpConnectionClassToGlibNone(t *TcpConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TcpConnectionClass) ParentClass() *SocketConnectionClass {
	parent := UnsafeSocketConnectionClassFromGlibBorrow(UnsafeTcpConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TcpConnectionClass) {}, t)
	return parent
}

// TcpWrapperConnectionClass wraps GTcpWrapperConnectionClass
// 
// TcpWrapperConnectionClass is the type struct for [TcpWrapperConnection]
type TcpWrapperConnectionClass struct {
	*tcpWrapperConnectionClass
}

// tcpWrapperConnectionClass is the struct that's finalized
type tcpWrapperConnectionClass struct {
	native *C.GTcpWrapperConnectionClass
}

// UnsafeTcpWrapperConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TcpWrapperConnectionClass) instance() *C.GTcpWrapperConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTcpWrapperConnectionClassFromGlibBorrow is used to convert raw C.GTcpWrapperConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionClassFromGlibBorrow(p unsafe.Pointer) *TcpWrapperConnectionClass {
	if p == nil {
		return nil
	}
	return &TcpWrapperConnectionClass{&tcpWrapperConnectionClass{(*C.GTcpWrapperConnectionClass)(p)}}
}

// UnsafeTcpWrapperConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TcpWrapperConnectionClass] is expected to work anymore.
func UnsafeTcpWrapperConnectionClassFree(t *TcpWrapperConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTcpWrapperConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTcpWrapperConnectionClassToGlibNone(t *TcpWrapperConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TcpWrapperConnectionClass) ParentClass() *TcpConnectionClass {
	parent := UnsafeTcpConnectionClassFromGlibBorrow(UnsafeTcpWrapperConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TcpWrapperConnectionClass) {}, t)
	return parent
}

// ThemedIconClass wraps GThemedIconClass
// 
// ThemedIconClass is the type struct for [ThemedIcon]
type ThemedIconClass struct {
	*themedIconClass
}

// themedIconClass is the struct that's finalized
type themedIconClass struct {
	native *C.GThemedIconClass
}

// UnsafeThemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *ThemedIconClass) instance() *C.GThemedIconClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeThemedIconClassFromGlibBorrow is used to convert raw C.GThemedIconClass pointers to go. This is used by the bindings internally.
func UnsafeThemedIconClassFromGlibBorrow(p unsafe.Pointer) *ThemedIconClass {
	if p == nil {
		return nil
	}
	return &ThemedIconClass{&themedIconClass{(*C.GThemedIconClass)(p)}}
}

// UnsafeThemedIconClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ThemedIconClass] is expected to work anymore.
func UnsafeThemedIconClassFree(t *ThemedIconClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeThemedIconClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeThemedIconClassToGlibNone(t *ThemedIconClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *ThemedIconClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeThemedIconClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ThemedIconClass) {}, t)
	return parent
}

// ThreadedSocketServiceClass wraps GThreadedSocketServiceClass
// 
// ThreadedSocketServiceClass is the type struct for [ThreadedSocketService]
type ThreadedSocketServiceClass struct {
	*threadedSocketServiceClass
}

// threadedSocketServiceClass is the struct that's finalized
type threadedSocketServiceClass struct {
	native *C.GThreadedSocketServiceClass
}

// UnsafeThreadedSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *ThreadedSocketServiceClass) instance() *C.GThreadedSocketServiceClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeThreadedSocketServiceClassFromGlibBorrow is used to convert raw C.GThreadedSocketServiceClass pointers to go. This is used by the bindings internally.
func UnsafeThreadedSocketServiceClassFromGlibBorrow(p unsafe.Pointer) *ThreadedSocketServiceClass {
	if p == nil {
		return nil
	}
	return &ThreadedSocketServiceClass{&threadedSocketServiceClass{(*C.GThreadedSocketServiceClass)(p)}}
}

// UnsafeThreadedSocketServiceClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ThreadedSocketServiceClass] is expected to work anymore.
func UnsafeThreadedSocketServiceClassFree(t *ThreadedSocketServiceClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeThreadedSocketServiceClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeThreadedSocketServiceClassToGlibNone(t *ThreadedSocketServiceClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *ThreadedSocketServiceClass) ParentClass() *SocketServiceClass {
	parent := UnsafeSocketServiceClassFromGlibBorrow(UnsafeThreadedSocketServiceClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ThreadedSocketServiceClass) {}, t)
	return parent
}

// TlsBackendInterface wraps GTlsBackendInterface
//
// Provides an interface for describing TLS-related types.
type TlsBackendInterface struct {
	*tlsBackendInterface
}

// tlsBackendInterface is the struct that's finalized
type tlsBackendInterface struct {
	native *C.GTlsBackendInterface
}

// UnsafeTlsBackendInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsBackendInterface) instance() *C.GTlsBackendInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsBackendInterfaceFromGlibBorrow is used to convert raw C.GTlsBackendInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsBackendInterface {
	if p == nil {
		return nil
	}
	return &TlsBackendInterface{&tlsBackendInterface{(*C.GTlsBackendInterface)(p)}}
}

// UnsafeTlsBackendInterfaceFromGlibNone is used to convert raw C.GTlsBackendInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibNone(p unsafe.Pointer) *TlsBackendInterface {
	wrapped := UnsafeTlsBackendInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsBackendInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsBackendInterfaceFromGlibFull is used to convert raw C.GTlsBackendInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceFromGlibFull(p unsafe.Pointer) *TlsBackendInterface {
	wrapped := UnsafeTlsBackendInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsBackendInterface,
		func (intern *tlsBackendInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsBackendInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsBackendInterface] is expected to work anymore.
func UnsafeTlsBackendInterfaceFree(t *TlsBackendInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsBackendInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsBackendInterfaceToGlibNone(t *TlsBackendInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsBackendInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsBackendInterfaceToGlibFull(t *TlsBackendInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsBackendInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsBackendInterface is invalid from here on
	return _p
}

// TlsCertificateClass wraps GTlsCertificateClass
// 
// TlsCertificateClass is the type struct for [TlsCertificate]
type TlsCertificateClass struct {
	*tlsCertificateClass
}

// tlsCertificateClass is the struct that's finalized
type tlsCertificateClass struct {
	native *C.GTlsCertificateClass
}

// UnsafeTlsCertificateClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsCertificateClass) instance() *C.GTlsCertificateClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsCertificateClassFromGlibBorrow is used to convert raw C.GTlsCertificateClass pointers to go. This is used by the bindings internally.
func UnsafeTlsCertificateClassFromGlibBorrow(p unsafe.Pointer) *TlsCertificateClass {
	if p == nil {
		return nil
	}
	return &TlsCertificateClass{&tlsCertificateClass{(*C.GTlsCertificateClass)(p)}}
}

// UnsafeTlsCertificateClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsCertificateClass] is expected to work anymore.
func UnsafeTlsCertificateClassFree(t *TlsCertificateClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsCertificateClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsCertificateClassToGlibNone(t *TlsCertificateClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsCertificateClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsCertificateClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsCertificateClass) {}, t)
	return parent
}

// TlsClientConnectionInterface wraps GTlsClientConnectionInterface
//
// vtable for a #GTlsClientConnection implementation.
type TlsClientConnectionInterface struct {
	*tlsClientConnectionInterface
}

// tlsClientConnectionInterface is the struct that's finalized
type tlsClientConnectionInterface struct {
	native *C.GTlsClientConnectionInterface
}

// UnsafeTlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsClientConnectionInterface) instance() *C.GTlsClientConnectionInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsClientConnectionInterfaceFromGlibBorrow is used to convert raw C.GTlsClientConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsClientConnectionInterface {
	if p == nil {
		return nil
	}
	return &TlsClientConnectionInterface{&tlsClientConnectionInterface{(*C.GTlsClientConnectionInterface)(p)}}
}

// UnsafeTlsClientConnectionInterfaceFromGlibNone is used to convert raw C.GTlsClientConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibNone(p unsafe.Pointer) *TlsClientConnectionInterface {
	wrapped := UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsClientConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsClientConnectionInterfaceFromGlibFull is used to convert raw C.GTlsClientConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceFromGlibFull(p unsafe.Pointer) *TlsClientConnectionInterface {
	wrapped := UnsafeTlsClientConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsClientConnectionInterface,
		func (intern *tlsClientConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsClientConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsClientConnectionInterface] is expected to work anymore.
func UnsafeTlsClientConnectionInterfaceFree(t *TlsClientConnectionInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsClientConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceToGlibNone(t *TlsClientConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsClientConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsClientConnectionInterfaceToGlibFull(t *TlsClientConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsClientConnectionInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsClientConnectionInterface is invalid from here on
	return _p
}

// TlsConnectionClass wraps GTlsConnectionClass
//
// The class structure for the #GTlsConnection type.
// 
// TlsConnectionClass is the type struct for [TlsConnection]
type TlsConnectionClass struct {
	*tlsConnectionClass
}

// tlsConnectionClass is the struct that's finalized
type tlsConnectionClass struct {
	native *C.GTlsConnectionClass
}

// UnsafeTlsConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsConnectionClass) instance() *C.GTlsConnectionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsConnectionClassFromGlibBorrow is used to convert raw C.GTlsConnectionClass pointers to go. This is used by the bindings internally.
func UnsafeTlsConnectionClassFromGlibBorrow(p unsafe.Pointer) *TlsConnectionClass {
	if p == nil {
		return nil
	}
	return &TlsConnectionClass{&tlsConnectionClass{(*C.GTlsConnectionClass)(p)}}
}

// UnsafeTlsConnectionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsConnectionClass] is expected to work anymore.
func UnsafeTlsConnectionClassFree(t *TlsConnectionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsConnectionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsConnectionClassToGlibNone(t *TlsConnectionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsConnectionClass) ParentClass() *IOStreamClass {
	parent := UnsafeIOStreamClassFromGlibBorrow(UnsafeTlsConnectionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsConnectionClass) {}, t)
	return parent
}

// TlsDatabaseClass wraps GTlsDatabaseClass
//
// The class for #GTlsDatabase. Derived classes should implement the various
// virtual methods. _async and _finish methods have a default
// implementation that runs the corresponding sync method in a thread.
// 
// TlsDatabaseClass is the type struct for [TlsDatabase]
type TlsDatabaseClass struct {
	*tlsDatabaseClass
}

// tlsDatabaseClass is the struct that's finalized
type tlsDatabaseClass struct {
	native *C.GTlsDatabaseClass
}

// UnsafeTlsDatabaseClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsDatabaseClass) instance() *C.GTlsDatabaseClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsDatabaseClassFromGlibBorrow is used to convert raw C.GTlsDatabaseClass pointers to go. This is used by the bindings internally.
func UnsafeTlsDatabaseClassFromGlibBorrow(p unsafe.Pointer) *TlsDatabaseClass {
	if p == nil {
		return nil
	}
	return &TlsDatabaseClass{&tlsDatabaseClass{(*C.GTlsDatabaseClass)(p)}}
}

// UnsafeTlsDatabaseClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsDatabaseClass] is expected to work anymore.
func UnsafeTlsDatabaseClassFree(t *TlsDatabaseClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsDatabaseClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsDatabaseClassToGlibNone(t *TlsDatabaseClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsDatabaseClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsDatabaseClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsDatabaseClass) {}, t)
	return parent
}

// TlsFileDatabaseInterface wraps GTlsFileDatabaseInterface
//
// Provides an interface for #GTlsFileDatabase implementations.
type TlsFileDatabaseInterface struct {
	*tlsFileDatabaseInterface
}

// tlsFileDatabaseInterface is the struct that's finalized
type tlsFileDatabaseInterface struct {
	native *C.GTlsFileDatabaseInterface
}

// UnsafeTlsFileDatabaseInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsFileDatabaseInterface) instance() *C.GTlsFileDatabaseInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsFileDatabaseInterfaceFromGlibBorrow is used to convert raw C.GTlsFileDatabaseInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsFileDatabaseInterface {
	if p == nil {
		return nil
	}
	return &TlsFileDatabaseInterface{&tlsFileDatabaseInterface{(*C.GTlsFileDatabaseInterface)(p)}}
}

// UnsafeTlsFileDatabaseInterfaceFromGlibNone is used to convert raw C.GTlsFileDatabaseInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibNone(p unsafe.Pointer) *TlsFileDatabaseInterface {
	wrapped := UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsFileDatabaseInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsFileDatabaseInterfaceFromGlibFull is used to convert raw C.GTlsFileDatabaseInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceFromGlibFull(p unsafe.Pointer) *TlsFileDatabaseInterface {
	wrapped := UnsafeTlsFileDatabaseInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsFileDatabaseInterface,
		func (intern *tlsFileDatabaseInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsFileDatabaseInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsFileDatabaseInterface] is expected to work anymore.
func UnsafeTlsFileDatabaseInterfaceFree(t *TlsFileDatabaseInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsFileDatabaseInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceToGlibNone(t *TlsFileDatabaseInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsFileDatabaseInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsFileDatabaseInterfaceToGlibFull(t *TlsFileDatabaseInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsFileDatabaseInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsFileDatabaseInterface is invalid from here on
	return _p
}

// TlsInteractionClass wraps GTlsInteractionClass
//
// The class for #GTlsInteraction. Derived classes implement the various
// virtual interaction methods to handle TLS interactions.
// 
// Derived classes can choose to implement whichever interactions methods they'd
// like to support by overriding those virtual methods in their class
// initialization function. If a derived class implements an async method,
// it must also implement the corresponding finish method.
// 
// The synchronous interaction methods should implement to display modal dialogs,
// and the asynchronous methods to display modeless dialogs.
// 
// If the user cancels an interaction, then the result should be
// %G_TLS_INTERACTION_FAILED and the error should be set with a domain of
// %G_IO_ERROR and code of %G_IO_ERROR_CANCELLED.
// 
// TlsInteractionClass is the type struct for [TlsInteraction]
type TlsInteractionClass struct {
	*tlsInteractionClass
}

// tlsInteractionClass is the struct that's finalized
type tlsInteractionClass struct {
	native *C.GTlsInteractionClass
}

// UnsafeTlsInteractionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsInteractionClass) instance() *C.GTlsInteractionClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsInteractionClassFromGlibBorrow is used to convert raw C.GTlsInteractionClass pointers to go. This is used by the bindings internally.
func UnsafeTlsInteractionClassFromGlibBorrow(p unsafe.Pointer) *TlsInteractionClass {
	if p == nil {
		return nil
	}
	return &TlsInteractionClass{&tlsInteractionClass{(*C.GTlsInteractionClass)(p)}}
}

// UnsafeTlsInteractionClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsInteractionClass] is expected to work anymore.
func UnsafeTlsInteractionClassFree(t *TlsInteractionClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsInteractionClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsInteractionClassToGlibNone(t *TlsInteractionClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsInteractionClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsInteractionClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsInteractionClass) {}, t)
	return parent
}

// TlsPasswordClass wraps GTlsPasswordClass
//
// Class structure for #GTlsPassword.
// 
// TlsPasswordClass is the type struct for [TlsPassword]
type TlsPasswordClass struct {
	*tlsPasswordClass
}

// tlsPasswordClass is the struct that's finalized
type tlsPasswordClass struct {
	native *C.GTlsPasswordClass
}

// UnsafeTlsPasswordClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsPasswordClass) instance() *C.GTlsPasswordClass {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsPasswordClassFromGlibBorrow is used to convert raw C.GTlsPasswordClass pointers to go. This is used by the bindings internally.
func UnsafeTlsPasswordClassFromGlibBorrow(p unsafe.Pointer) *TlsPasswordClass {
	if p == nil {
		return nil
	}
	return &TlsPasswordClass{&tlsPasswordClass{(*C.GTlsPasswordClass)(p)}}
}

// UnsafeTlsPasswordClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsPasswordClass] is expected to work anymore.
func UnsafeTlsPasswordClassFree(t *TlsPasswordClass) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsPasswordClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsPasswordClassToGlibNone(t *TlsPasswordClass) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (t *TlsPasswordClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeTlsPasswordClassToGlibNone(t))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *TlsPasswordClass) {}, t)
	return parent
}

// TlsServerConnectionInterface wraps GTlsServerConnectionInterface
//
// vtable for a #GTlsServerConnection implementation.
type TlsServerConnectionInterface struct {
	*tlsServerConnectionInterface
}

// tlsServerConnectionInterface is the struct that's finalized
type tlsServerConnectionInterface struct {
	native *C.GTlsServerConnectionInterface
}

// UnsafeTlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TlsServerConnectionInterface) instance() *C.GTlsServerConnectionInterface {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTlsServerConnectionInterfaceFromGlibBorrow is used to convert raw C.GTlsServerConnectionInterface pointers to go. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p unsafe.Pointer) *TlsServerConnectionInterface {
	if p == nil {
		return nil
	}
	return &TlsServerConnectionInterface{&tlsServerConnectionInterface{(*C.GTlsServerConnectionInterface)(p)}}
}

// UnsafeTlsServerConnectionInterfaceFromGlibNone is used to convert raw C.GTlsServerConnectionInterface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibNone(p unsafe.Pointer) *TlsServerConnectionInterface {
	wrapped := UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TlsServerConnectionInterface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTlsServerConnectionInterfaceFromGlibFull is used to convert raw C.GTlsServerConnectionInterface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceFromGlibFull(p unsafe.Pointer) *TlsServerConnectionInterface {
	wrapped := UnsafeTlsServerConnectionInterfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.tlsServerConnectionInterface,
		func (intern *tlsServerConnectionInterface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTlsServerConnectionInterfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TlsServerConnectionInterface] is expected to work anymore.
func UnsafeTlsServerConnectionInterfaceFree(t *TlsServerConnectionInterface) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTlsServerConnectionInterfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceToGlibNone(t *TlsServerConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTlsServerConnectionInterfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTlsServerConnectionInterfaceToGlibFull(t *TlsServerConnectionInterface) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.tlsServerConnectionInterface, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TlsServerConnectionInterface is invalid from here on
	return _p
}

// VfsClass wraps GVfsClass
// 
// VfsClass is the type struct for [Vfs]
type VfsClass struct {
	*vfsClass
}

// vfsClass is the struct that's finalized
type vfsClass struct {
	native *C.GVfsClass
}

// UnsafeVfsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VfsClass) instance() *C.GVfsClass {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVfsClassFromGlibBorrow is used to convert raw C.GVfsClass pointers to go. This is used by the bindings internally.
func UnsafeVfsClassFromGlibBorrow(p unsafe.Pointer) *VfsClass {
	if p == nil {
		return nil
	}
	return &VfsClass{&vfsClass{(*C.GVfsClass)(p)}}
}

// UnsafeVfsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VfsClass] is expected to work anymore.
func UnsafeVfsClassFree(v *VfsClass) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVfsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVfsClassToGlibNone(v *VfsClass) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (v *VfsClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeVfsClassToGlibNone(v))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *VfsClass) {}, v)
	return parent
}

// VolumeIface wraps GVolumeIface
//
// Interface for implementing operations for mountable volumes.
type VolumeIface struct {
	*volumeIface
}

// volumeIface is the struct that's finalized
type volumeIface struct {
	native *C.GVolumeIface
}

// UnsafeVolumeIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VolumeIface) instance() *C.GVolumeIface {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVolumeIfaceFromGlibBorrow is used to convert raw C.GVolumeIface pointers to go. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibBorrow(p unsafe.Pointer) *VolumeIface {
	if p == nil {
		return nil
	}
	return &VolumeIface{&volumeIface{(*C.GVolumeIface)(p)}}
}

// UnsafeVolumeIfaceFromGlibNone is used to convert raw C.GVolumeIface pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibNone(p unsafe.Pointer) *VolumeIface {
	wrapped := UnsafeVolumeIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to VolumeIface because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeVolumeIfaceFromGlibFull is used to convert raw C.GVolumeIface pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVolumeIfaceFromGlibFull(p unsafe.Pointer) *VolumeIface {
	wrapped := UnsafeVolumeIfaceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.volumeIface,
		func (intern *volumeIface) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeVolumeIfaceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VolumeIface] is expected to work anymore.
func UnsafeVolumeIfaceFree(v *VolumeIface) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVolumeIfaceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVolumeIfaceToGlibNone(v *VolumeIface) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVolumeIfaceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVolumeIfaceToGlibFull(v *VolumeIface) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.volumeIface, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VolumeIface is invalid from here on
	return _p
}

// VolumeMonitorClass wraps GVolumeMonitorClass
// 
// VolumeMonitorClass is the type struct for [VolumeMonitor]
type VolumeMonitorClass struct {
	*volumeMonitorClass
}

// volumeMonitorClass is the struct that's finalized
type volumeMonitorClass struct {
	native *C.GVolumeMonitorClass
}

// UnsafeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VolumeMonitorClass) instance() *C.GVolumeMonitorClass {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVolumeMonitorClassFromGlibBorrow is used to convert raw C.GVolumeMonitorClass pointers to go. This is used by the bindings internally.
func UnsafeVolumeMonitorClassFromGlibBorrow(p unsafe.Pointer) *VolumeMonitorClass {
	if p == nil {
		return nil
	}
	return &VolumeMonitorClass{&volumeMonitorClass{(*C.GVolumeMonitorClass)(p)}}
}

// UnsafeVolumeMonitorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VolumeMonitorClass] is expected to work anymore.
func UnsafeVolumeMonitorClassFree(v *VolumeMonitorClass) {
	C.free(unsafe.Pointer(v.native))
}

// UnsafeVolumeMonitorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVolumeMonitorClassToGlibNone(v *VolumeMonitorClass) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (v *VolumeMonitorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeVolumeMonitorClassToGlibNone(v))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *VolumeMonitorClass) {}, v)
	return parent
}

// ZlibCompressorClass wraps GZlibCompressorClass
type ZlibCompressorClass struct {
	*zlibCompressorClass
}

// zlibCompressorClass is the struct that's finalized
type zlibCompressorClass struct {
	native *C.GZlibCompressorClass
}

// UnsafeZlibCompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (z *ZlibCompressorClass) instance() *C.GZlibCompressorClass {
	if z == nil {
		return nil
	}
	return z.native
}

// UnsafeZlibCompressorClassFromGlibBorrow is used to convert raw C.GZlibCompressorClass pointers to go. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibBorrow(p unsafe.Pointer) *ZlibCompressorClass {
	if p == nil {
		return nil
	}
	return &ZlibCompressorClass{&zlibCompressorClass{(*C.GZlibCompressorClass)(p)}}
}

// UnsafeZlibCompressorClassFromGlibNone is used to convert raw C.GZlibCompressorClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibNone(p unsafe.Pointer) *ZlibCompressorClass {
	wrapped := UnsafeZlibCompressorClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ZlibCompressorClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeZlibCompressorClassFromGlibFull is used to convert raw C.GZlibCompressorClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeZlibCompressorClassFromGlibFull(p unsafe.Pointer) *ZlibCompressorClass {
	wrapped := UnsafeZlibCompressorClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.zlibCompressorClass,
		func (intern *zlibCompressorClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeZlibCompressorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ZlibCompressorClass] is expected to work anymore.
func UnsafeZlibCompressorClassFree(z *ZlibCompressorClass) {
	C.free(unsafe.Pointer(z.native))
}

// UnsafeZlibCompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeZlibCompressorClassToGlibNone(z *ZlibCompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	return unsafe.Pointer(z.native)
}

// UnsafeZlibCompressorClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeZlibCompressorClassToGlibFull(z *ZlibCompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	runtime.SetFinalizer(z.zlibCompressorClass, nil)
	_p := unsafe.Pointer(z.native)
	z.native = nil // ZlibCompressorClass is invalid from here on
	return _p
}

// ZlibDecompressorClass wraps GZlibDecompressorClass
// 
// ZlibDecompressorClass is the type struct for [ZlibDecompressor]
type ZlibDecompressorClass struct {
	*zlibDecompressorClass
}

// zlibDecompressorClass is the struct that's finalized
type zlibDecompressorClass struct {
	native *C.GZlibDecompressorClass
}

// UnsafeZlibDecompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (z *ZlibDecompressorClass) instance() *C.GZlibDecompressorClass {
	if z == nil {
		return nil
	}
	return z.native
}

// UnsafeZlibDecompressorClassFromGlibBorrow is used to convert raw C.GZlibDecompressorClass pointers to go. This is used by the bindings internally.
func UnsafeZlibDecompressorClassFromGlibBorrow(p unsafe.Pointer) *ZlibDecompressorClass {
	if p == nil {
		return nil
	}
	return &ZlibDecompressorClass{&zlibDecompressorClass{(*C.GZlibDecompressorClass)(p)}}
}

// UnsafeZlibDecompressorClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ZlibDecompressorClass] is expected to work anymore.
func UnsafeZlibDecompressorClassFree(z *ZlibDecompressorClass) {
	C.free(unsafe.Pointer(z.native))
}

// UnsafeZlibDecompressorClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeZlibDecompressorClassToGlibNone(z *ZlibDecompressorClass) unsafe.Pointer {
	if z == nil {
		return nil
	}
	return unsafe.Pointer(z.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (z *ZlibDecompressorClass) ParentClass() *gobject.ObjectClass {
	parent := gobject.UnsafeObjectClassFromGlibBorrow(UnsafeZlibDecompressorClassToGlibNone(z))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *ZlibDecompressorClass) {}, z)
	return parent
}

