// Code generated by girgen for GObject-2. DO NOT EDIT.

package gobject

import (
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
import "C"

// GType values.
var (
	TypeBindingFlags     = Type(C.g_binding_flags_get_type())
	TypeIOCondition      = Type(C.g_io_condition_get_type())
	TypeBindingGroup     = Type(C.g_binding_group_get_type())
	TypeInitiallyUnowned = Type(C.g_initially_unowned_get_type())
)

func init() {
	RegisterGValueMarshalers([]TypeMarshaler{
		TypeMarshaler{T: TypeBindingFlags, F: marshalBindingFlags},
		TypeMarshaler{T: TypeIOCondition, F: marshalIOCondition},
		TypeMarshaler{T: TypeBindingGroup, F: marshalBindingGroupInstance},
		TypeMarshaler{T: TypeInitiallyUnowned, F: marshalInitiallyUnownedInstance},
	})
}

// PARAM_MASK wraps G_PARAM_MASK
//
// Mask containing the bits of #GParamSpec.flags which are reserved for GLib.
const PARAM_MASK = 255
// PARAM_STATIC_STRINGS wraps G_PARAM_STATIC_STRINGS
//
// #GParamFlags value alias for %G_PARAM_STATIC_NAME | %G_PARAM_STATIC_NICK | %G_PARAM_STATIC_BLURB.
// 
// It is recommended to use this for all properties by default, as it allows for
// internal performance improvements in GObject.
// 
// It is very rare that a property would have a dynamically constructed name,
// nickname or blurb.
// 
// Since 2.13.0
const PARAM_STATIC_STRINGS = 224
// PARAM_USER_SHIFT wraps G_PARAM_USER_SHIFT
//
// Minimum shift count to be used for user defined flags, to be stored in
// #GParamSpec.flags. The maximum allowed is 10.
const PARAM_USER_SHIFT = 8
// SIGNAL_FLAGS_MASK wraps G_SIGNAL_FLAGS_MASK
//
// A mask for all #GSignalFlags bits.
const SIGNAL_FLAGS_MASK = 511
// SIGNAL_MATCH_MASK wraps G_SIGNAL_MATCH_MASK
//
// A mask for all #GSignalMatchType bits.
const SIGNAL_MATCH_MASK = 63
// TYPE_FUNDAMENTAL_MAX wraps G_TYPE_FUNDAMENTAL_MAX
//
// An integer constant that represents the number of identifiers reserved
// for types that are assigned at compile-time.
const TYPE_FUNDAMENTAL_MAX = 1020
// TYPE_FUNDAMENTAL_SHIFT wraps G_TYPE_FUNDAMENTAL_SHIFT
//
// Shift value used in converting numbers to type IDs.
const TYPE_FUNDAMENTAL_SHIFT = 2
// TYPE_RESERVED_BSE_FIRST wraps G_TYPE_RESERVED_BSE_FIRST
//
// First fundamental type number to create a new fundamental type id with
// G_TYPE_MAKE_FUNDAMENTAL() reserved for BSE.
const TYPE_RESERVED_BSE_FIRST = 32
// TYPE_RESERVED_BSE_LAST wraps G_TYPE_RESERVED_BSE_LAST
//
// Last fundamental type number reserved for BSE.
const TYPE_RESERVED_BSE_LAST = 48
// TYPE_RESERVED_GLIB_FIRST wraps G_TYPE_RESERVED_GLIB_FIRST
//
// First fundamental type number to create a new fundamental type id with
// G_TYPE_MAKE_FUNDAMENTAL() reserved for GLib.
const TYPE_RESERVED_GLIB_FIRST = 22
// TYPE_RESERVED_GLIB_LAST wraps G_TYPE_RESERVED_GLIB_LAST
//
// Last fundamental type number reserved for GLib.
const TYPE_RESERVED_GLIB_LAST = 31
// TYPE_RESERVED_USER_FIRST wraps G_TYPE_RESERVED_USER_FIRST
//
// First available fundamental type number to create new fundamental
// type id with G_TYPE_MAKE_FUNDAMENTAL().
const TYPE_RESERVED_USER_FIRST = 49
// VALUE_COLLECT_FORMAT_MAX_LENGTH wraps G_VALUE_COLLECT_FORMAT_MAX_LENGTH
//
// The maximal number of #GTypeCValues which can be collected for a
// single #GValue.
const VALUE_COLLECT_FORMAT_MAX_LENGTH = 8
// VALUE_INTERNED_STRING wraps G_VALUE_INTERNED_STRING
//
// For string values, indicates that the string contained is canonical and will
// exist for the duration of the process. See g_value_set_interned_string().
const VALUE_INTERNED_STRING = 268435456
// VALUE_NOCOPY_CONTENTS wraps G_VALUE_NOCOPY_CONTENTS
//
// If passed to G_VALUE_COLLECT(), allocated data won't be copied
// but used verbatim. This does not affect ref-counted types like
// objects. This does not affect usage of g_value_copy(), the data will
// be copied if it is not ref-counted.
const VALUE_NOCOPY_CONTENTS = 134217728
// BindingFlags wraps GBindingFlags
//
// Flags to be passed to g_object_bind_property() or
// g_object_bind_property_full().
// 
// This enumeration can be extended at later date.
type BindingFlags C.gint

const (
	// BindingDefault wraps G_BINDING_DEFAULT
	//
	// The default binding; if the source property
	//   changes, the target property is updated with its value.
	BindingDefault BindingFlags = 0
	// BindingBidirectional wraps G_BINDING_BIDIRECTIONAL
	//
	// Bidirectional binding; if either the
	//   property of the source or the property of the target changes,
	//   the other is updated.
	BindingBidirectional BindingFlags = 1
	// BindingSyncCreate wraps G_BINDING_SYNC_CREATE
	//
	// Synchronize the values of the source and
	//   target properties when creating the binding; the direction of
	//   the synchronization is always from the source to the target.
	BindingSyncCreate BindingFlags = 2
	// BindingInvertBoolean wraps G_BINDING_INVERT_BOOLEAN
	//
	// If the two properties being bound are
	//   booleans, setting one to %TRUE will result in the other being
	//   set to %FALSE and vice versa. This flag will only work for
	//   boolean properties, and cannot be used when passing custom
	//   transformation functions to g_object_bind_property_full().
	BindingInvertBoolean BindingFlags = 4
)

func marshalBindingFlags(p unsafe.Pointer) (any, error) {
	return BindingFlags(ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BindingFlags) Has(other BindingFlags) bool {
	return (b & other) == other
}

var _ GoValueInitializer = BindingFlags(0)

func (f BindingFlags) GoValueType() Type {
	return TypeBindingFlags
}

func (f BindingFlags) SetGoValue(v *Value) {
	v.SetFlags(int(f))
}

func (f BindingFlags) String() string {
	if f == 0 {
		return "BindingFlags(0)"
	}

	var parts []string
	if (f & BindingDefault) != 0 {
		parts = append(parts, "BindingDefault")
	}
	if (f & BindingBidirectional) != 0 {
		parts = append(parts, "BindingBidirectional")
	}
	if (f & BindingSyncCreate) != 0 {
		parts = append(parts, "BindingSyncCreate")
	}
	if (f & BindingInvertBoolean) != 0 {
		parts = append(parts, "BindingInvertBoolean")
	}
	return "BindingFlags(" + strings.Join(parts, "|") + ")"
}

// ConnectFlags wraps GConnectFlags
//
// The connection flags are used to specify the behaviour of a signal's
// connection.
type ConnectFlags C.gint

const (
	// ConnectDefault wraps G_CONNECT_DEFAULT
	//
	// Default behaviour (no special flags). Since: 2.74
	ConnectDefault ConnectFlags = 0
	// ConnectAfter wraps G_CONNECT_AFTER
	//
	// If set, the handler should be called after the
	//  default handler of the signal. Normally, the handler is called before
	//  the default handler.
	ConnectAfter ConnectFlags = 1
	// ConnectSwapped wraps G_CONNECT_SWAPPED
	//
	// If set, the instance and data should be swapped when
	//  calling the handler; see g_signal_connect_swapped() for an example.
	ConnectSwapped ConnectFlags = 2
)

// Has returns true if c contains other
func (c ConnectFlags) Has(other ConnectFlags) bool {
	return (c & other) == other
}

func (f ConnectFlags) String() string {
	if f == 0 {
		return "ConnectFlags(0)"
	}

	var parts []string
	if (f & ConnectDefault) != 0 {
		parts = append(parts, "ConnectDefault")
	}
	if (f & ConnectAfter) != 0 {
		parts = append(parts, "ConnectAfter")
	}
	if (f & ConnectSwapped) != 0 {
		parts = append(parts, "ConnectSwapped")
	}
	return "ConnectFlags(" + strings.Join(parts, "|") + ")"
}

// IOCondition wraps GIOCondition
type IOCondition C.gint

const (
	// IOIn wraps G_IO_IN
	IOIn IOCondition = 1
	// IOOut wraps G_IO_OUT
	IOOut IOCondition = 4
	// IOPri wraps G_IO_PRI
	IOPri IOCondition = 2
	// IOErr wraps G_IO_ERR
	IOErr IOCondition = 8
	// IOHup wraps G_IO_HUP
	IOHup IOCondition = 16
	// IONval wraps G_IO_NVAL
	IONval IOCondition = 32
)

func marshalIOCondition(p unsafe.Pointer) (any, error) {
	return IOCondition(ValueFromNative(p).Flags()), nil
}
// Has returns true if i contains other
func (i IOCondition) Has(other IOCondition) bool {
	return (i & other) == other
}

var _ GoValueInitializer = IOCondition(0)

func (f IOCondition) GoValueType() Type {
	return TypeIOCondition
}

func (f IOCondition) SetGoValue(v *Value) {
	v.SetFlags(int(f))
}

func (f IOCondition) String() string {
	if f == 0 {
		return "IOCondition(0)"
	}

	var parts []string
	if (f & IOIn) != 0 {
		parts = append(parts, "IOIn")
	}
	if (f & IOOut) != 0 {
		parts = append(parts, "IOOut")
	}
	if (f & IOPri) != 0 {
		parts = append(parts, "IOPri")
	}
	if (f & IOErr) != 0 {
		parts = append(parts, "IOErr")
	}
	if (f & IOHup) != 0 {
		parts = append(parts, "IOHup")
	}
	if (f & IONval) != 0 {
		parts = append(parts, "IONval")
	}
	return "IOCondition(" + strings.Join(parts, "|") + ")"
}

// ParamFlags wraps GParamFlags
//
// Through the #GParamFlags flag values, certain aspects of parameters
// can be configured.
// 
// See also: %G_PARAM_STATIC_STRINGS
type ParamFlags C.gint

const (
	// ParamReadable wraps G_PARAM_READABLE
	//
	// the parameter is readable
	ParamReadable ParamFlags = 1
	// ParamWritable wraps G_PARAM_WRITABLE
	//
	// the parameter is writable
	ParamWritable ParamFlags = 2
	// ParamReadwrite wraps G_PARAM_READWRITE
	//
	// alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
	ParamReadwrite ParamFlags = 3
	// ParamConstruct wraps G_PARAM_CONSTRUCT
	//
	// the parameter will be set upon object construction.
	//   See [vfunc@Object.constructed] for more details
	ParamConstruct ParamFlags = 4
	// ParamConstructOnly wraps G_PARAM_CONSTRUCT_ONLY
	//
	// the parameter can only be set upon object construction.
	//   See [vfunc@Object.constructed] for more details
	ParamConstructOnly ParamFlags = 8
	// ParamLaxValidation wraps G_PARAM_LAX_VALIDATION
	//
	// upon parameter conversion (see g_param_value_convert())
	//  strict validation is not required
	ParamLaxValidation ParamFlags = 16
	// ParamStaticName wraps G_PARAM_STATIC_NAME
	//
	// the string used as name when constructing the
	//  parameter is guaranteed to remain valid and
	//  unmodified for the lifetime of the parameter.
	//  Since 2.8
	ParamStaticName ParamFlags = 32
	// ParamPrivate wraps G_PARAM_PRIVATE
	//
	// internal
	ParamPrivate ParamFlags = 32
	// ParamStaticNick wraps G_PARAM_STATIC_NICK
	//
	// the string used as nick when constructing the
	//  parameter is guaranteed to remain valid and
	//  unmmodified for the lifetime of the parameter.
	//  Since 2.8
	ParamStaticNick ParamFlags = 64
	// ParamStaticBlurb wraps G_PARAM_STATIC_BLURB
	//
	// the string used as blurb when constructing the
	//  parameter is guaranteed to remain valid and
	//  unmodified for the lifetime of the parameter.
	//  Since 2.8
	ParamStaticBlurb ParamFlags = 128
	// ParamExplicitNotify wraps G_PARAM_EXPLICIT_NOTIFY
	//
	// calls to g_object_set_property() for this
	//   property will not automatically result in a "notify" signal being
	//   emitted: the implementation must call g_object_notify() themselves
	//   in case the property actually changes.  Since: 2.42.
	ParamExplicitNotify ParamFlags = 1073741824
	// ParamDeprecated wraps G_PARAM_DEPRECATED
	//
	// the parameter is deprecated and will be removed
	//  in a future version. A warning will be generated if it is used
	//  while running with G_ENABLE_DIAGNOSTIC=1.
	//  Since 2.26
	ParamDeprecated ParamFlags = -2147483648
)

// Has returns true if p contains other
func (p ParamFlags) Has(other ParamFlags) bool {
	return (p & other) == other
}

func (f ParamFlags) String() string {
	if f == 0 {
		return "ParamFlags(0)"
	}

	var parts []string
	if (f & ParamReadable) != 0 {
		parts = append(parts, "ParamReadable")
	}
	if (f & ParamWritable) != 0 {
		parts = append(parts, "ParamWritable")
	}
	if (f & ParamReadwrite) != 0 {
		parts = append(parts, "ParamReadwrite")
	}
	if (f & ParamConstruct) != 0 {
		parts = append(parts, "ParamConstruct")
	}
	if (f & ParamConstructOnly) != 0 {
		parts = append(parts, "ParamConstructOnly")
	}
	if (f & ParamLaxValidation) != 0 {
		parts = append(parts, "ParamLaxValidation")
	}
	if (f & ParamStaticName) != 0 {
		parts = append(parts, "ParamStaticName")
	}
	if (f & ParamPrivate) != 0 {
		parts = append(parts, "ParamPrivate")
	}
	if (f & ParamStaticNick) != 0 {
		parts = append(parts, "ParamStaticNick")
	}
	if (f & ParamStaticBlurb) != 0 {
		parts = append(parts, "ParamStaticBlurb")
	}
	if (f & ParamExplicitNotify) != 0 {
		parts = append(parts, "ParamExplicitNotify")
	}
	if (f & ParamDeprecated) != 0 {
		parts = append(parts, "ParamDeprecated")
	}
	return "ParamFlags(" + strings.Join(parts, "|") + ")"
}

// SignalFlags wraps GSignalFlags
//
// The signal flags are used to specify a signal's behaviour.
type SignalFlags C.gint

const (
	// SignalRunFirst wraps G_SIGNAL_RUN_FIRST
	//
	// Invoke the object method handler in the first emission stage.
	SignalRunFirst SignalFlags = 1
	// SignalRunLast wraps G_SIGNAL_RUN_LAST
	//
	// Invoke the object method handler in the third emission stage.
	SignalRunLast SignalFlags = 2
	// SignalRunCleanup wraps G_SIGNAL_RUN_CLEANUP
	//
	// Invoke the object method handler in the last emission stage.
	SignalRunCleanup SignalFlags = 4
	// SignalNoRecurse wraps G_SIGNAL_NO_RECURSE
	//
	// Signals being emitted for an object while currently being in
	//  emission for this very object will not be emitted recursively,
	//  but instead cause the first emission to be restarted.
	SignalNoRecurse SignalFlags = 8
	// SignalDetailed wraps G_SIGNAL_DETAILED
	//
	// This signal supports "::detail" appendices to the signal name
	//  upon handler connections and emissions.
	SignalDetailed SignalFlags = 16
	// SignalAction wraps G_SIGNAL_ACTION
	//
	// Action signals are signals that may freely be emitted on alive
	//  objects from user code via g_signal_emit() and friends, without
	//  the need of being embedded into extra code that performs pre or
	//  post emission adjustments on the object. They can also be thought
	//  of as object methods which can be called generically by
	//  third-party code.
	SignalAction SignalFlags = 32
	// SignalNoHooks wraps G_SIGNAL_NO_HOOKS
	//
	// No emissions hooks are supported for this signal.
	SignalNoHooks SignalFlags = 64
	// SignalMustCollect wraps G_SIGNAL_MUST_COLLECT
	//
	// Varargs signal emission will always collect the arguments, even if there
	// are no signal handlers connected.
	SignalMustCollect SignalFlags = 128
	// SignalDeprecated wraps G_SIGNAL_DEPRECATED
	//
	// The signal is deprecated and will be removed in a future version.
	// 
	// A warning will be generated if it is connected while running with
	// `G_ENABLE_DIAGNOSTIC=1`.
	SignalDeprecated SignalFlags = 256
	// SignalAccumulatorFirstRun wraps G_SIGNAL_ACCUMULATOR_FIRST_RUN
	//
	// The signal accumulator was invoked for the first time.
	// 
	// This flag is only used in [callback@GObject.SignalAccumulator][accumulator functions]
	// for the `run_type` field of the [struct@GObject.SignalInvocationHint], to
	// mark the first call to the accumulator function for a signal emission.
	SignalAccumulatorFirstRun SignalFlags = 131072
)

// Has returns true if s contains other
func (s SignalFlags) Has(other SignalFlags) bool {
	return (s & other) == other
}

func (f SignalFlags) String() string {
	if f == 0 {
		return "SignalFlags(0)"
	}

	var parts []string
	if (f & SignalRunFirst) != 0 {
		parts = append(parts, "SignalRunFirst")
	}
	if (f & SignalRunLast) != 0 {
		parts = append(parts, "SignalRunLast")
	}
	if (f & SignalRunCleanup) != 0 {
		parts = append(parts, "SignalRunCleanup")
	}
	if (f & SignalNoRecurse) != 0 {
		parts = append(parts, "SignalNoRecurse")
	}
	if (f & SignalDetailed) != 0 {
		parts = append(parts, "SignalDetailed")
	}
	if (f & SignalAction) != 0 {
		parts = append(parts, "SignalAction")
	}
	if (f & SignalNoHooks) != 0 {
		parts = append(parts, "SignalNoHooks")
	}
	if (f & SignalMustCollect) != 0 {
		parts = append(parts, "SignalMustCollect")
	}
	if (f & SignalDeprecated) != 0 {
		parts = append(parts, "SignalDeprecated")
	}
	if (f & SignalAccumulatorFirstRun) != 0 {
		parts = append(parts, "SignalAccumulatorFirstRun")
	}
	return "SignalFlags(" + strings.Join(parts, "|") + ")"
}

// SignalMatchType wraps GSignalMatchType
//
// The match types specify what g_signal_handlers_block_matched(),
// g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
// match signals by.
type SignalMatchType C.gint

const (
	// SignalMatchID wraps G_SIGNAL_MATCH_ID
	//
	// The signal id must be equal.
	SignalMatchID SignalMatchType = 1
	// SignalMatchDetail wraps G_SIGNAL_MATCH_DETAIL
	//
	// The signal detail must be equal.
	SignalMatchDetail SignalMatchType = 2
	// SignalMatchClosure wraps G_SIGNAL_MATCH_CLOSURE
	//
	// The closure must be the same.
	SignalMatchClosure SignalMatchType = 4
	// SignalMatchFunc wraps G_SIGNAL_MATCH_FUNC
	//
	// The C closure callback must be the same.
	SignalMatchFunc SignalMatchType = 8
	// SignalMatchData wraps G_SIGNAL_MATCH_DATA
	//
	// The closure data must be the same.
	SignalMatchData SignalMatchType = 16
	// SignalMatchUnblocked wraps G_SIGNAL_MATCH_UNBLOCKED
	//
	// Only unblocked signals may be matched.
	SignalMatchUnblocked SignalMatchType = 32
)

// Has returns true if s contains other
func (s SignalMatchType) Has(other SignalMatchType) bool {
	return (s & other) == other
}

func (f SignalMatchType) String() string {
	if f == 0 {
		return "SignalMatchType(0)"
	}

	var parts []string
	if (f & SignalMatchID) != 0 {
		parts = append(parts, "SignalMatchID")
	}
	if (f & SignalMatchDetail) != 0 {
		parts = append(parts, "SignalMatchDetail")
	}
	if (f & SignalMatchClosure) != 0 {
		parts = append(parts, "SignalMatchClosure")
	}
	if (f & SignalMatchFunc) != 0 {
		parts = append(parts, "SignalMatchFunc")
	}
	if (f & SignalMatchData) != 0 {
		parts = append(parts, "SignalMatchData")
	}
	if (f & SignalMatchUnblocked) != 0 {
		parts = append(parts, "SignalMatchUnblocked")
	}
	return "SignalMatchType(" + strings.Join(parts, "|") + ")"
}

// TypeFlags wraps GTypeFlags
//
// Bit masks used to check or determine characteristics of a type.
type TypeFlags C.gint

const (
	// TypeFlagNone wraps G_TYPE_FLAG_NONE
	//
	// No special flags. Since: 2.74
	TypeFlagNone TypeFlags = 0
	// TypeFlagAbstract wraps G_TYPE_FLAG_ABSTRACT
	//
	// Indicates an abstract type. No instances can be
	//  created for an abstract type
	TypeFlagAbstract TypeFlags = 16
	// TypeFlagValueAbstract wraps G_TYPE_FLAG_VALUE_ABSTRACT
	//
	// Indicates an abstract value type, i.e. a type
	//  that introduces a value table, but can't be used for
	//  g_value_init()
	TypeFlagValueAbstract TypeFlags = 32
	// TypeFlagFinal wraps G_TYPE_FLAG_FINAL
	//
	// Indicates a final type. A final type is a non-derivable
	//  leaf node in a deep derivable type hierarchy tree. Since: 2.70
	TypeFlagFinal TypeFlags = 64
	// TypeFlagDeprecated wraps G_TYPE_FLAG_DEPRECATED
	//
	// The type is deprecated and may be removed in a
	//  future version. A warning will be emitted if it is instantiated while
	//  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76
	TypeFlagDeprecated TypeFlags = 128
)

// Has returns true if t contains other
func (t TypeFlags) Has(other TypeFlags) bool {
	return (t & other) == other
}

func (f TypeFlags) String() string {
	if f == 0 {
		return "TypeFlags(0)"
	}

	var parts []string
	if (f & TypeFlagNone) != 0 {
		parts = append(parts, "TypeFlagNone")
	}
	if (f & TypeFlagAbstract) != 0 {
		parts = append(parts, "TypeFlagAbstract")
	}
	if (f & TypeFlagValueAbstract) != 0 {
		parts = append(parts, "TypeFlagValueAbstract")
	}
	if (f & TypeFlagFinal) != 0 {
		parts = append(parts, "TypeFlagFinal")
	}
	if (f & TypeFlagDeprecated) != 0 {
		parts = append(parts, "TypeFlagDeprecated")
	}
	return "TypeFlags(" + strings.Join(parts, "|") + ")"
}

// TypeFundamentalFlags wraps GTypeFundamentalFlags
//
// Bit masks used to check or determine specific characteristics of a
// fundamental type.
type TypeFundamentalFlags C.gint

const (
	// TypeFlagClassed wraps G_TYPE_FLAG_CLASSED
	//
	// Indicates a classed type
	TypeFlagClassed TypeFundamentalFlags = 1
	// TypeFlagInstantiatable wraps G_TYPE_FLAG_INSTANTIATABLE
	//
	// Indicates an instantiatable type (implies classed)
	TypeFlagInstantiatable TypeFundamentalFlags = 2
	// TypeFlagDerivable wraps G_TYPE_FLAG_DERIVABLE
	//
	// Indicates a flat derivable type
	TypeFlagDerivable TypeFundamentalFlags = 4
	// TypeFlagDeepDerivable wraps G_TYPE_FLAG_DEEP_DERIVABLE
	//
	// Indicates a deep derivable type (implies derivable)
	TypeFlagDeepDerivable TypeFundamentalFlags = 8
)

// Has returns true if t contains other
func (t TypeFundamentalFlags) Has(other TypeFundamentalFlags) bool {
	return (t & other) == other
}

func (f TypeFundamentalFlags) String() string {
	if f == 0 {
		return "TypeFundamentalFlags(0)"
	}

	var parts []string
	if (f & TypeFlagClassed) != 0 {
		parts = append(parts, "TypeFlagClassed")
	}
	if (f & TypeFlagInstantiatable) != 0 {
		parts = append(parts, "TypeFlagInstantiatable")
	}
	if (f & TypeFlagDerivable) != 0 {
		parts = append(parts, "TypeFlagDerivable")
	}
	if (f & TypeFlagDeepDerivable) != 0 {
		parts = append(parts, "TypeFlagDeepDerivable")
	}
	return "TypeFundamentalFlags(" + strings.Join(parts, "|") + ")"
}

// EnumCompleteTypeInfo wraps g_enum_complete_type_info
// 
// The function takes the following parameters:
// 
// 	- gEnumType Type: the type identifier of the type being completed 
// 	- constValues []EnumValue: An array of #GEnumValue
//  structs for the possible enumeration values. The array is terminated
//  by a struct with all members being 0. 
// 
// The function returns the following values:
// 
// 	- info TypeInfo: the #GTypeInfo struct to be filled in 
//
// This function is meant to be called from the `complete_type_info`
// function of a #GTypePlugin implementation, as in the following
// example:
// 
// |[&lt;!-- language="C" --&gt;
// static void
// my_enum_complete_type_info (GTypePlugin     *plugin,
//                             GType            g_type,
//                             GTypeInfo       *info,
//                             GTypeValueTable *value_table)
// {
//   static const GEnumValue values[] = {
//     { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
//     { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
//     { 0, NULL, NULL }
//   };
// 
//   g_enum_complete_type_info (type, info, values);
// }
// ]|
func EnumCompleteTypeInfo(gEnumType Type, constValues []EnumValue) TypeInfo {
	var carg1 C.GType       // in, none, casted, alias
	var carg3 *C.GEnumValue // in, transfer: none, C Pointers: 1, Name: array[EnumValue], array (inner GEnumValue (*typesystem.Record), zero-terminated)
	var carg2 C.GTypeInfo   // out, transfer: full, C Pointers: 0, Name: TypeInfo

	carg1 = C.GType(gEnumType)
	_ = constValues
	_ = carg3
	panic("unimplemented conversion of []EnumValue (const GEnumValue*) because of unimplemented: non-fixed size array")

	C.g_enum_complete_type_info(carg1, &carg2, carg3)
	runtime.KeepAlive(gEnumType)
	runtime.KeepAlive(constValues)

	var info TypeInfo

	_ = info
	_ = carg2
	panic("unimplemented conversion of TypeInfo (GTypeInfo) because of unknown reason")

	return info
}

// EnumGetValue wraps g_enum_get_value
// 
// The function takes the following parameters:
// 
// 	- enumClass *EnumClass: a #GEnumClass 
// 	- value int32: the value to look up 
// 
// The function returns the following values:
// 
// 	- goret *EnumValue (nullable) 
//
// Returns the #GEnumValue for a value.
func EnumGetValue(enumClass *EnumClass, value int32) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 C.gint        // in, none, casted
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = C.gint(value)

	cret = C.g_enum_get_value(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(value)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumGetValueByName wraps g_enum_get_value_by_name
// 
// The function takes the following parameters:
// 
// 	- enumClass *EnumClass: a #GEnumClass 
// 	- name string: the name to look up 
// 
// The function returns the following values:
// 
// 	- goret *EnumValue (nullable) 
//
// Looks up a #GEnumValue by name.
func EnumGetValueByName(enumClass *EnumClass, name string) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_enum_get_value_by_name(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(name)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumGetValueByNick wraps g_enum_get_value_by_nick
// 
// The function takes the following parameters:
// 
// 	- enumClass *EnumClass: a #GEnumClass 
// 	- nick string: the nickname to look up 
// 
// The function returns the following values:
// 
// 	- goret *EnumValue (nullable) 
//
// Looks up a #GEnumValue by nickname.
func EnumGetValueByNick(enumClass *EnumClass, nick string) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_enum_get_value_by_nick(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(nick)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumRegisterStatic wraps g_enum_register_static
// 
// The function takes the following parameters:
// 
// 	- name string: A nul-terminated string used as the name of the new type. 
// 	- constStaticValues []EnumValue: An array of
//  #GEnumValue structs for the possible enumeration values. The array is
//  terminated by a struct with all members being 0. GObject keeps a
//  reference to the data, so it cannot be stack-allocated. 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Registers a new static enumeration type with the name @name.
// 
// It is normally more convenient to let [glib-mkenums][glib-mkenums],
// generate a my_enum_get_type() function from a usual C enumeration
// definition  than to write one yourself using g_enum_register_static().
func EnumRegisterStatic(name string, constStaticValues []EnumValue) Type {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.GEnumValue // in, transfer: none, C Pointers: 1, Name: array[EnumValue], array (inner GEnumValue (*typesystem.Record), zero-terminated)
	var cret  C.GType       // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	_ = constStaticValues
	_ = carg2
	panic("unimplemented conversion of []EnumValue (const GEnumValue*) because of unimplemented: non-fixed size array")

	cret = C.g_enum_register_static(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(constStaticValues)

	var goret Type

	goret = Type(cret)

	return goret
}

// EnumToString wraps g_enum_to_string
// 
// The function takes the following parameters:
// 
// 	- gEnumType Type: the type identifier of a #GEnumClass type 
// 	- value int32: the value 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Pretty-prints @value in the form of the enum&#x2019;s name.
// 
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func EnumToString(gEnumType Type, value int32) string {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.GType(gEnumType)
	carg2 = C.gint(value)

	cret = C.g_enum_to_string(carg1, carg2)
	runtime.KeepAlive(gEnumType)
	runtime.KeepAlive(value)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FlagsCompleteTypeInfo wraps g_flags_complete_type_info
// 
// The function takes the following parameters:
// 
// 	- gFlagsType Type: the type identifier of the type being completed 
// 	- constValues []FlagsValue: An array of #GFlagsValue
//  structs for the possible enumeration values. The array is terminated
//  by a struct with all members being 0. 
// 
// The function returns the following values:
// 
// 	- info TypeInfo: the #GTypeInfo struct to be filled in 
//
// This function is meant to be called from the complete_type_info()
// function of a #GTypePlugin implementation, see the example for
// g_enum_complete_type_info() above.
func FlagsCompleteTypeInfo(gFlagsType Type, constValues []FlagsValue) TypeInfo {
	var carg1 C.GType        // in, none, casted, alias
	var carg3 *C.GFlagsValue // in, transfer: none, C Pointers: 1, Name: array[FlagsValue], array (inner GFlagsValue (*typesystem.Record), zero-terminated)
	var carg2 C.GTypeInfo    // out, transfer: full, C Pointers: 0, Name: TypeInfo

	carg1 = C.GType(gFlagsType)
	_ = constValues
	_ = carg3
	panic("unimplemented conversion of []FlagsValue (const GFlagsValue*) because of unimplemented: non-fixed size array")

	C.g_flags_complete_type_info(carg1, &carg2, carg3)
	runtime.KeepAlive(gFlagsType)
	runtime.KeepAlive(constValues)

	var info TypeInfo

	_ = info
	_ = carg2
	panic("unimplemented conversion of TypeInfo (GTypeInfo) because of unknown reason")

	return info
}

// FlagsGetFirstValue wraps g_flags_get_first_value
// 
// The function takes the following parameters:
// 
// 	- flagsClass *FlagsClass: a #GFlagsClass 
// 	- value uint: the value 
// 
// The function returns the following values:
// 
// 	- goret *FlagsValue (nullable) 
//
// Returns the first #GFlagsValue which is set in @value.
func FlagsGetFirstValue(flagsClass *FlagsClass, value uint) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 C.guint        // in, none, casted
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = C.guint(value)

	cret = C.g_flags_get_first_value(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(value)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsGetValueByName wraps g_flags_get_value_by_name
// 
// The function takes the following parameters:
// 
// 	- flagsClass *FlagsClass: a #GFlagsClass 
// 	- name string: the name to look up 
// 
// The function returns the following values:
// 
// 	- goret *FlagsValue (nullable) 
//
// Looks up a #GFlagsValue by name.
func FlagsGetValueByName(flagsClass *FlagsClass, name string) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 *C.gchar       // in, none, string
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_flags_get_value_by_name(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(name)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsGetValueByNick wraps g_flags_get_value_by_nick
// 
// The function takes the following parameters:
// 
// 	- flagsClass *FlagsClass: a #GFlagsClass 
// 	- nick string: the nickname to look up 
// 
// The function returns the following values:
// 
// 	- goret *FlagsValue (nullable) 
//
// Looks up a #GFlagsValue by nickname.
func FlagsGetValueByNick(flagsClass *FlagsClass, nick string) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 *C.gchar       // in, none, string
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_flags_get_value_by_nick(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(nick)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsRegisterStatic wraps g_flags_register_static
// 
// The function takes the following parameters:
// 
// 	- name string: A nul-terminated string used as the name of the new type. 
// 	- constStaticValues []FlagsValue: An array of
//  #GFlagsValue structs for the possible flags values. The array is
//  terminated by a struct with all members being 0. GObject keeps a
//  reference to the data, so it cannot be stack-allocated. 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Registers a new static flags type with the name @name.
// 
// It is normally more convenient to let [glib-mkenums][glib-mkenums]
// generate a my_flags_get_type() function from a usual C enumeration
// definition than to write one yourself using g_flags_register_static().
func FlagsRegisterStatic(name string, constStaticValues []FlagsValue) Type {
	var carg1 *C.gchar       // in, none, string
	var carg2 *C.GFlagsValue // in, transfer: none, C Pointers: 1, Name: array[FlagsValue], array (inner GFlagsValue (*typesystem.Record), zero-terminated)
	var cret  C.GType        // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	_ = constStaticValues
	_ = carg2
	panic("unimplemented conversion of []FlagsValue (const GFlagsValue*) because of unimplemented: non-fixed size array")

	cret = C.g_flags_register_static(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(constStaticValues)

	var goret Type

	goret = Type(cret)

	return goret
}

// FlagsToString wraps g_flags_to_string
// 
// The function takes the following parameters:
// 
// 	- flagsType Type: the type identifier of a #GFlagsClass type 
// 	- value uint: the value 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Pretty-prints @value in the form of the flag names separated by ` | ` and
// sorted. Any extra bits will be shown at the end as a hexadecimal number.
// 
// This is intended to be used for debugging purposes. The format of the output
// may change in the future.
func FlagsToString(flagsType Type, value uint) string {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.GType(flagsType)
	carg2 = C.guint(value)

	cret = C.g_flags_to_string(carg1, carg2)
	runtime.KeepAlive(flagsType)
	runtime.KeepAlive(value)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GTypeGetType wraps g_gtype_get_type
// 
// The function returns the following values:
// 
// 	- goret Type 
func GTypeGetType() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_gtype_get_type()

	var goret Type

	goret = Type(cret)

	return goret
}

// ParamSpecBoolean wraps g_param_spec_boolean
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- defaultValue bool: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
// property. In many cases, it may be more appropriate to use an enum with
// g_param_spec_enum(), both to improve code clarity by using explicitly named
// values, and to allow for more values to be added in future without breaking
// API.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecBoolean(name string, nick string, blurb string, defaultValue bool, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gboolean    // in
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if defaultValue {
		carg4 = C.TRUE
	}
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_boolean(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecBoxed wraps g_param_spec_boxed
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- boxedType Type: %G_TYPE_BOXED derived type of this property 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
// derived property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecBoxed(name string, nick string, blurb string, boxedType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(boxedType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_boxed(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(boxedType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecChar wraps g_param_spec_char
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum int8: minimum value for the property specified 
// 	- maximum int8: maximum value for the property specified 
// 	- defaultValue int8: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.
func ParamSpecChar(name string, nick string, blurb string, minimum int8, maximum int8, defaultValue int8, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint8       // in, none, casted
	var carg5 C.gint8       // in, none, casted
	var carg6 C.gint8       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint8(minimum)
	carg5 = C.gint8(maximum)
	carg6 = C.gint8(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_char(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecDouble wraps g_param_spec_double
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum float64: minimum value for the property specified 
// 	- maximum float64: maximum value for the property specified 
// 	- defaultValue float64: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecDouble(name string, nick string, blurb string, minimum float64, maximum float64, defaultValue float64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gdouble     // in, none, casted
	var carg5 C.gdouble     // in, none, casted
	var carg6 C.gdouble     // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gdouble(minimum)
	carg5 = C.gdouble(maximum)
	carg6 = C.gdouble(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_double(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecEnum wraps g_param_spec_enum
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- enumType Type: a #GType derived from %G_TYPE_ENUM 
// 	- defaultValue int32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecEnum(name string, nick string, blurb string, enumType Type, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.gint        // in, none, casted
	var carg6 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(enumType)
	carg5 = C.gint(defaultValue)
	carg6 = C.GParamFlags(flags)

	cret = C.g_param_spec_enum(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(enumType)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecFlags wraps g_param_spec_flags
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- flagsType Type: a #GType derived from %G_TYPE_FLAGS 
// 	- defaultValue uint: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecFlags(name string, nick string, blurb string, flagsType Type, defaultValue uint, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.guint       // in, none, casted
	var carg6 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(flagsType)
	carg5 = C.guint(defaultValue)
	carg6 = C.GParamFlags(flags)

	cret = C.g_param_spec_flags(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(flagsType)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecFloat wraps g_param_spec_float
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum float32: minimum value for the property specified 
// 	- maximum float32: maximum value for the property specified 
// 	- defaultValue float32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecFloat(name string, nick string, blurb string, minimum float32, maximum float32, defaultValue float32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gfloat      // in, none, casted
	var carg5 C.gfloat      // in, none, casted
	var carg6 C.gfloat      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gfloat(minimum)
	carg5 = C.gfloat(maximum)
	carg6 = C.gfloat(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_float(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecGType wraps g_param_spec_gtype
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- isAType Type: a #GType whose subtypes are allowed as values
//  of the property (use %G_TYPE_NONE for any type) 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecGType instance specifying a
// %G_TYPE_GTYPE property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecGType(name string, nick string, blurb string, isAType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(isAType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_gtype(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(isAType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecInt32 wraps g_param_spec_int
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum int32: minimum value for the property specified 
// 	- maximum int32: maximum value for the property specified 
// 	- defaultValue int32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecInt32(name string, nick string, blurb string, minimum int32, maximum int32, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint        // in, none, casted
	var carg5 C.gint        // in, none, casted
	var carg6 C.gint        // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint(minimum)
	carg5 = C.gint(maximum)
	carg6 = C.gint(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_int(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecInt64 wraps g_param_spec_int64
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum int64: minimum value for the property specified 
// 	- maximum int64: maximum value for the property specified 
// 	- defaultValue int64: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecInt64(name string, nick string, blurb string, minimum int64, maximum int64, defaultValue int64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint64      // in, none, casted
	var carg5 C.gint64      // in, none, casted
	var carg6 C.gint64      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint64(minimum)
	carg5 = C.gint64(maximum)
	carg6 = C.gint64(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_int64(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecLong wraps g_param_spec_long
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum int32: minimum value for the property specified 
// 	- maximum int32: maximum value for the property specified 
// 	- defaultValue int32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecLong(name string, nick string, blurb string, minimum int32, maximum int32, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.glong       // in, none, casted
	var carg5 C.glong       // in, none, casted
	var carg6 C.glong       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.glong(minimum)
	carg5 = C.glong(maximum)
	carg6 = C.glong(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_long(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecObject wraps g_param_spec_object
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- objectType Type: %G_TYPE_OBJECT derived type of this property 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
// derived property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecObject(name string, nick string, blurb string, objectType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(objectType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_object(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(objectType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecParam wraps g_param_spec_param
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- paramType Type: a #GType derived from %G_TYPE_PARAM 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecParam(name string, nick string, blurb string, paramType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(paramType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_param(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(paramType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecPointer wraps g_param_spec_pointer
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecPointer instance specifying a pointer property.
// Where possible, it is better to use g_param_spec_object() or
// g_param_spec_boxed() to expose memory management information.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecPointer(name string, nick string, blurb string, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GParamFlags(flags)

	cret = C.g_param_spec_pointer(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecString wraps g_param_spec_string
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- defaultValue string (nullable): default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecString instance.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecString(name string, nick string, blurb string, defaultValue string, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 *C.gchar      // in, none, string, nullable-string
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if defaultValue != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(defaultValue)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_string(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUchar wraps g_param_spec_uchar
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum uint8: minimum value for the property specified 
// 	- maximum uint8: maximum value for the property specified 
// 	- defaultValue uint8: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.
func ParamSpecUchar(name string, nick string, blurb string, minimum uint8, maximum uint8, defaultValue uint8, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint8      // in, none, casted
	var carg5 C.guint8      // in, none, casted
	var carg6 C.guint8      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint8(minimum)
	carg5 = C.guint8(maximum)
	carg6 = C.guint8(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uchar(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUint wraps g_param_spec_uint
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum uint: minimum value for the property specified 
// 	- maximum uint: maximum value for the property specified 
// 	- defaultValue uint: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecUint(name string, nick string, blurb string, minimum uint, maximum uint, defaultValue uint, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint       // in, none, casted
	var carg5 C.guint       // in, none, casted
	var carg6 C.guint       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint(minimum)
	carg5 = C.guint(maximum)
	carg6 = C.guint(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uint(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUint64 wraps g_param_spec_uint64
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum uint64: minimum value for the property specified 
// 	- maximum uint64: maximum value for the property specified 
// 	- defaultValue uint64: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecUint64(name string, nick string, blurb string, minimum uint64, maximum uint64, defaultValue uint64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint64     // in, none, casted
	var carg5 C.guint64     // in, none, casted
	var carg6 C.guint64     // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint64(minimum)
	carg5 = C.guint64(maximum)
	carg6 = C.guint64(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uint64(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUlong wraps g_param_spec_ulong
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- minimum uint32: minimum value for the property specified 
// 	- maximum uint32: maximum value for the property specified 
// 	- defaultValue uint32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
// property.
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecUlong(name string, nick string, blurb string, minimum uint32, maximum uint32, defaultValue uint32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gulong      // in, none, casted
	var carg5 C.gulong      // in, none, casted
	var carg6 C.gulong      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gulong(minimum)
	carg5 = C.gulong(maximum)
	carg6 = C.gulong(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_ulong(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUnichar wraps g_param_spec_unichar
// 
// The function takes the following parameters:
// 
// 	- name string: canonical name of the property specified 
// 	- nick string (nullable): nick name for the property specified 
// 	- blurb string (nullable): description of the property specified 
// 	- defaultValue uint32: default value for the property specified 
// 	- flags ParamFlags: flags for the property specified 
// 
// The function returns the following values:
// 
// 	- goret *ParamSpec 
//
// Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
// property. #GValue structures for this property can be accessed with
// g_value_set_uint() and g_value_get_uint().
// 
// See g_param_spec_internal() for details on property names.
func ParamSpecUnichar(name string, nick string, blurb string, defaultValue uint32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gunichar    // in, none, casted
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gunichar(defaultValue)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_unichar(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamValueConvert wraps g_param_value_convert
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- srcValue *Value: source #GValue 
// 	- destValue *Value: destination #GValue of correct type for @pspec 
// 	- strictValidation bool: %TRUE requires @dest_value to conform to @pspec
// without modifications 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Transforms @src_value into @dest_value if possible, and then
// validates @dest_value, in order for it to conform to @pspec.  If
// @strict_validation is %TRUE this function will only succeed if the
// transformed @dest_value complied to @pspec without modifications.
// 
// See also g_value_type_transformable(), g_value_transform() and
// g_param_value_validate().
func ParamValueConvert(pspec *ParamSpec, srcValue *Value, destValue *Value, strictValidation bool) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var carg3 *C.GValue     // in, none, converted
	var carg4 C.gboolean    // in
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(srcValue))
	carg3 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(destValue))
	if strictValidation {
		carg4 = C.TRUE
	}

	cret = C.g_param_value_convert(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destValue)
	runtime.KeepAlive(strictValidation)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueDefaults wraps g_param_value_defaults
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- value *Value: a #GValue of correct type for @pspec 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks whether @value contains the default value as specified in @pspec.
func ParamValueDefaults(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_defaults(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueIsValid wraps g_param_value_is_valid
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- value *Value: a #GValue of correct type for @pspec 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Return whether the contents of @value comply with the specifications
// set out by @pspec.
func ParamValueIsValid(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_is_valid(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueSetDefault wraps g_param_value_set_default
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- value *Value: a #GValue of correct type for @pspec; since 2.64, you
//   can also pass an empty #GValue, initialized with %G_VALUE_INIT 
//
// Sets @value to its default value as specified in @pspec.
func ParamValueSetDefault(pspec *ParamSpec, value *Value) {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	C.g_param_value_set_default(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)
}

// ParamValueValidate wraps g_param_value_validate
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- value *Value: a #GValue of correct type for @pspec 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Ensures that the contents of @value comply with the specifications
// set out by @pspec. For example, a #GParamSpecInt might require
// that integers stored in @value may not be smaller than -42 and not be
// greater than +42. If @value contains an integer outside of this range,
// it is modified accordingly, so the resulting value will fit into the
// range -42 .. +42.
func ParamValueValidate(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_validate(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValuesCmp wraps g_param_values_cmp
// 
// The function takes the following parameters:
// 
// 	- pspec *ParamSpec: a valid #GParamSpec 
// 	- value1 *Value: a #GValue of correct type for @pspec 
// 	- value2 *Value: a #GValue of correct type for @pspec 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
// if @value1 is found to be less than, equal to or greater than @value2,
// respectively.
func ParamValuesCmp(pspec *ParamSpec, value1 *Value, value2 *Value) int32 {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var carg3 *C.GValue     // in, none, converted
	var cret  C.gint        // return, none, casted

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value1))
	carg3 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value2))

	cret = C.g_param_values_cmp(carg1, carg2, carg3)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var goret int32

	goret = int32(cret)

	return goret
}

// PointerTypeRegisterStatic wraps g_pointer_type_register_static
// 
// The function takes the following parameters:
// 
// 	- name string: the name of the new pointer type. 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Creates a new %G_TYPE_POINTER derived type id for a new
// pointer type with name @name.
func PointerTypeRegisterStatic(name string) Type {
	var carg1 *C.gchar // in, none, string
	var cret  C.GType  // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pointer_type_register_static(carg1)
	runtime.KeepAlive(name)

	var goret Type

	goret = Type(cret)

	return goret
}

// SignalIsValidName wraps g_signal_is_valid_name
// 
// The function takes the following parameters:
// 
// 	- name string: the canonical name of the signal 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Validate a signal name. This can be useful for dynamically-generated signals
// which need to be validated at run-time before actually trying to create them.
// 
// See [func@GObject.signal_new] for details of the rules for valid names.
// The rules for signal names are the same as those for property names.
func SignalIsValidName(name string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_signal_is_valid_name(carg1)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SignalListIDs wraps g_signal_list_ids
// 
// The function takes the following parameters:
// 
// 	- itype Type: Instance or interface type. 
// 
// The function returns the following values:
// 
// 	- nIds uint: Location to store the number of signal ids for @itype. 
// 	- goret []uint 
//
// Lists the signals by id that a certain instance or interface type
// created. Further information about the signals can be acquired through
// g_signal_query().
func SignalListIDs(itype Type) (uint, []uint) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.guint // return, transfer: full, C Pointers: 1, Name: array[guint], scope: , array (inner guint (*typesystem.CastablePrimitive))

	carg1 = C.GType(itype)

	cret = C.g_signal_list_ids(carg1, &carg2)
	runtime.KeepAlive(itype)

	var nIds  uint
	var goret []uint

	nIds = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint (guint*) because of unknown reason")

	return nIds, goret
}

// SignalLookup wraps g_signal_lookup
// 
// The function takes the following parameters:
// 
// 	- name string: the signal's name. 
// 	- itype Type: the type that the signal operates on. 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Given the name of the signal and the type of object it connects to, gets
// the signal's identifying integer. Emitting the signal by number is
// somewhat faster than using the name each time.
// 
// Also tries the ancestors of the given type.
// 
// The type class passed as @itype must already have been instantiated (for
// example, using g_type_class_ref()) for this function to work, as signals are
// always installed during class initialization.
// 
// See g_signal_new() for details on allowed signal names.
func SignalLookup(name string, itype Type) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 C.GType  // in, none, casted, alias
	var cret  C.guint  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(itype)

	cret = C.g_signal_lookup(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(itype)

	var goret uint

	goret = uint(cret)

	return goret
}

// SignalName wraps g_signal_name
// 
// The function takes the following parameters:
// 
// 	- signalId uint: the signal's identifying number. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Given the signal's identifier, finds its name.
// 
// Two different signals may have the same name, if they have differing types.
func SignalName(signalId uint) string {
	var carg1 C.guint  // in, none, casted
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.guint(signalId)

	cret = C.g_signal_name(carg1)
	runtime.KeepAlive(signalId)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// SignalParseName wraps g_signal_parse_name
// 
// The function takes the following parameters:
// 
// 	- detailedSignal string: a string of the form "signal-name::detail". 
// 	- itype Type: The interface/instance type that introduced "signal-name". 
// 	- forceDetailQuark bool: %TRUE forces creation of a #GQuark for the detail. 
// 
// The function returns the following values:
// 
// 	- signalIdP uint: Location to store the signal id. 
// 	- detailP glib.Quark: Location to store the detail quark. 
// 	- goret bool 
//
// Internal function to parse a signal name into its @signal_id
// and @detail quark.
func SignalParseName(detailedSignal string, itype Type, forceDetailQuark bool) (uint, glib.Quark, bool) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.GType    // in, none, casted, alias
	var carg5 C.gboolean // in
	var carg3 C.guint    // out, full, casted
	var carg4 C.GQuark   // out, full, casted, alias
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedSignal)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(itype)
	if forceDetailQuark {
		carg5 = C.TRUE
	}

	cret = C.g_signal_parse_name(carg1, carg2, &carg3, &carg4, carg5)
	runtime.KeepAlive(detailedSignal)
	runtime.KeepAlive(itype)
	runtime.KeepAlive(forceDetailQuark)

	var signalIdP uint
	var detailP   glib.Quark
	var goret     bool

	signalIdP = uint(carg3)
	detailP = glib.Quark(carg4)
	if cret != 0 {
		goret = true
	}

	return signalIdP, detailP, goret
}

// SignalRemoveEmissionHook wraps g_signal_remove_emission_hook
// 
// The function takes the following parameters:
// 
// 	- signalId uint: the id of the signal 
// 	- hookId uint32: the id of the emission hook, as returned by
//  g_signal_add_emission_hook() 
//
// Deletes an emission hook.
func SignalRemoveEmissionHook(signalId uint, hookId uint32) {
	var carg1 C.guint  // in, none, casted
	var carg2 C.gulong // in, none, casted

	carg1 = C.guint(signalId)
	carg2 = C.gulong(hookId)

	C.g_signal_remove_emission_hook(carg1, carg2)
	runtime.KeepAlive(signalId)
	runtime.KeepAlive(hookId)
}

// TypeAddClassPrivate wraps g_type_add_class_private
// 
// The function takes the following parameters:
// 
// 	- classType Type: GType of a classed type 
// 	- privateSize uint: size of private structure 
//
// Registers a private class structure for a classed type;
// when the class is allocated, the private structures for
// the class and all of its parent types are allocated
// sequentially in the same memory block as the public
// structures, and are zero-filled.
// 
// This function should be called in the
// type's get_type() function after the type is registered.
// The private structure can be retrieved using the
// G_TYPE_CLASS_GET_PRIVATE() macro.
func TypeAddClassPrivate(classType Type, privateSize uint) {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.gsize // in, none, casted

	carg1 = C.GType(classType)
	carg2 = C.gsize(privateSize)

	C.g_type_add_class_private(carg1, carg2)
	runtime.KeepAlive(classType)
	runtime.KeepAlive(privateSize)
}

// TypeAddInstancePrivate wraps g_type_add_instance_private
// 
// The function takes the following parameters:
// 
// 	- classType Type 
// 	- privateSize uint 
// 
// The function returns the following values:
// 
// 	- goret int32 
func TypeAddInstancePrivate(classType Type, privateSize uint) int32 {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.gsize // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.GType(classType)
	carg2 = C.gsize(privateSize)

	cret = C.g_type_add_instance_private(carg1, carg2)
	runtime.KeepAlive(classType)
	runtime.KeepAlive(privateSize)

	var goret int32

	goret = int32(cret)

	return goret
}

// TypeAddInterfaceStatic wraps g_type_add_interface_static
// 
// The function takes the following parameters:
// 
// 	- instanceType Type: #GType value of an instantiatable type 
// 	- interfaceType Type: #GType value of an interface type 
// 	- info *InterfaceInfo: #GInterfaceInfo structure for this
//        (@instance_type, @interface_type) combination 
//
// Adds @interface_type to the static @instance_type.
// The information contained in the #GInterfaceInfo structure
// pointed to by @info is used to manage the relationship.
func TypeAddInterfaceStatic(instanceType Type, interfaceType Type, info *InterfaceInfo) {
	var carg1 C.GType           // in, none, casted, alias
	var carg2 C.GType           // in, none, casted, alias
	var carg3 *C.GInterfaceInfo // in, none, converted

	carg1 = C.GType(instanceType)
	carg2 = C.GType(interfaceType)
	carg3 = (*C.GInterfaceInfo)(UnsafeInterfaceInfoToGlibNone(info))

	C.g_type_add_interface_static(carg1, carg2, carg3)
	runtime.KeepAlive(instanceType)
	runtime.KeepAlive(interfaceType)
	runtime.KeepAlive(info)
}

// TypeCheckInstance wraps g_type_check_instance
// 
// The function takes the following parameters:
// 
// 	- instance *TypeInstance: a valid #GTypeInstance structure 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Private helper function to aid implementation of the
// G_TYPE_CHECK_INSTANCE() macro.
func TypeCheckInstance(instance *TypeInstance) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	cret = C.g_type_check_instance(carg1)
	runtime.KeepAlive(instance)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckInstanceIsA wraps g_type_check_instance_is_a
// 
// The function takes the following parameters:
// 
// 	- instance *TypeInstance 
// 	- ifaceType Type 
// 
// The function returns the following values:
// 
// 	- goret bool 
func TypeCheckInstanceIsA(instance *TypeInstance, ifaceType Type) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var carg2 C.GType          // in, none, casted, alias
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))
	carg2 = C.GType(ifaceType)

	cret = C.g_type_check_instance_is_a(carg1, carg2)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(ifaceType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckInstanceIsFundamentallyA wraps g_type_check_instance_is_fundamentally_a
// 
// The function takes the following parameters:
// 
// 	- instance *TypeInstance 
// 	- fundamentalType Type 
// 
// The function returns the following values:
// 
// 	- goret bool 
func TypeCheckInstanceIsFundamentallyA(instance *TypeInstance, fundamentalType Type) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var carg2 C.GType          // in, none, casted, alias
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))
	carg2 = C.GType(fundamentalType)

	cret = C.g_type_check_instance_is_fundamentally_a(carg1, carg2)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(fundamentalType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckIsValueType wraps g_type_check_is_value_type
// 
// The function takes the following parameters:
// 
// 	- typ Type 
// 
// The function returns the following values:
// 
// 	- goret bool 
func TypeCheckIsValueType(typ Type) bool {
	var carg1 C.GType    // in, none, casted, alias
	var cret  C.gboolean // return

	carg1 = C.GType(typ)

	cret = C.g_type_check_is_value_type(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeChildren wraps g_type_children
// 
// The function takes the following parameters:
// 
// 	- typ Type: the parent type 
// 
// The function returns the following values:
// 
// 	- nChildren uint: location to store the length of
//     the returned array, or %NULL 
// 	- goret []Type 
//
// Return a newly allocated and 0-terminated array of type IDs, listing
// the child types of @type.
func TypeChildren(typ Type) (uint, []Type) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.GType // return, transfer: full, C Pointers: 1, Name: array[Type], scope: , array (inner GType (*typesystem.Alias))

	carg1 = C.GType(typ)

	cret = C.g_type_children(carg1, &carg2)
	runtime.KeepAlive(typ)

	var nChildren uint
	var goret     []Type

	nChildren = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []Type (GType*) because of unknown reason")

	return nChildren, goret
}

// TypeDepth wraps g_type_depth
// 
// The function takes the following parameters:
// 
// 	- typ Type: a #GType 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the length of the ancestry of the passed in type. This
// includes the type itself, so that e.g. a fundamental type has depth 1.
func TypeDepth(typ Type) uint {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.guint // return, none, casted

	carg1 = C.GType(typ)

	cret = C.g_type_depth(carg1)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// TypeEnsure wraps g_type_ensure
// 
// The function takes the following parameters:
// 
// 	- typ Type: a #GType 
//
// Ensures that the indicated @type has been registered with the
// type system, and its _class_init() method has been run.
// 
// In theory, simply calling the type's _get_type() method (or using
// the corresponding macro) is supposed take care of this. However,
// _get_type() methods are often marked %G_GNUC_CONST for performance
// reasons, even though this is technically incorrect (since
// %G_GNUC_CONST requires that the function not have side effects,
// which _get_type() methods do on the first call). As a result, if
// you write a bare call to a _get_type() macro, it may get optimized
// out by the compiler. Using g_type_ensure() guarantees that the
// type's _get_type() method is called.
func TypeEnsure(typ Type) {
	var carg1 C.GType // in, none, casted, alias

	carg1 = C.GType(typ)

	C.g_type_ensure(carg1)
	runtime.KeepAlive(typ)
}

// TypeFreeInstance wraps g_type_free_instance
// 
// The function takes the following parameters:
// 
// 	- instance *TypeInstance: an instance of a type 
//
// Frees an instance of a type, returning it to the instance pool for
// the type, if there is one.
// 
// Like g_type_create_instance(), this function is reserved for
// implementors of fundamental types.
func TypeFreeInstance(instance *TypeInstance) {
	var carg1 *C.GTypeInstance // in, none, converted

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	C.g_type_free_instance(carg1)
	runtime.KeepAlive(instance)
}

// TypeFromName wraps g_type_from_name
// 
// The function takes the following parameters:
// 
// 	- name string: type name to look up 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Look up the type ID from a given type name, returning 0 if no type
// has been registered under this name (this is the preferred method
// to find out by name whether a specific type has been registered
// yet).
func TypeFromName(name string) Type {
	var carg1 *C.gchar // in, none, string
	var cret  C.GType  // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_type_from_name(carg1)
	runtime.KeepAlive(name)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeFundamental wraps g_type_fundamental
// 
// The function takes the following parameters:
// 
// 	- typeId Type: valid type ID 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Internal function, used to extract the fundamental type ID portion.
// Use G_TYPE_FUNDAMENTAL() instead.
func TypeFundamental(typeId Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(typeId)

	cret = C.g_type_fundamental(carg1)
	runtime.KeepAlive(typeId)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeFundamentalNext wraps g_type_fundamental_next
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Returns the next free fundamental type id which can be used to
// register a new fundamental type with g_type_register_fundamental().
// The returned type ID represents the highest currently registered
// fundamental type identifier.
func TypeFundamentalNext() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_type_fundamental_next()

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeGetInstanceCount wraps g_type_get_instance_count
// 
// The function takes the following parameters:
// 
// 	- typ Type: a #GType 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the number of instances allocated of the particular type;
// this is only available if GLib is built with debugging support and
// the `instance-count` debug flag is set (by setting the `GOBJECT_DEBUG`
// variable to include `instance-count`).
func TypeGetInstanceCount(typ Type) int32 {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.int   // return, none, casted

	carg1 = C.GType(typ)

	cret = C.g_type_get_instance_count(carg1)
	runtime.KeepAlive(typ)

	var goret int32

	goret = int32(cret)

	return goret
}

// TypeGetTypeRegistrationSerial wraps g_type_get_type_registration_serial
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns an opaque serial number that represents the state of the set
// of registered types. Any time a type is registered this serial changes,
// which means you can cache information based on type lookups (such as
// g_type_from_name()) and know if the cache is still valid at a later
// time by comparing the current serial with the one at the type lookup.
func TypeGetTypeRegistrationSerial() uint {
	var cret C.guint // return, none, casted

	cret = C.g_type_get_type_registration_serial()

	var goret uint

	goret = uint(cret)

	return goret
}

// TypeInterfaces wraps g_type_interfaces
// 
// The function takes the following parameters:
// 
// 	- typ Type: the type to list interface types for 
// 
// The function returns the following values:
// 
// 	- nInterfaces uint: location to store the length of
//     the returned array, or %NULL 
// 	- goret []Type 
//
// Return a newly allocated and 0-terminated array of type IDs, listing
// the interface types that @type conforms to.
func TypeInterfaces(typ Type) (uint, []Type) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.GType // return, transfer: full, C Pointers: 1, Name: array[Type], scope: , array (inner GType (*typesystem.Alias))

	carg1 = C.GType(typ)

	cret = C.g_type_interfaces(carg1, &carg2)
	runtime.KeepAlive(typ)

	var nInterfaces uint
	var goret       []Type

	nInterfaces = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []Type (GType*) because of unknown reason")

	return nInterfaces, goret
}

// TypeIsA wraps g_type_is_a
// 
// The function takes the following parameters:
// 
// 	- typ Type: type to check ancestry for 
// 	- isAType Type: possible ancestor of @type or interface that @type
//     could conform to 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// If @is_a_type is a derivable type, check whether @type is a
// descendant of @is_a_type. If @is_a_type is an interface, check
// whether @type conforms to it.
func TypeIsA(typ Type, isAType Type) bool {
	var carg1 C.GType    // in, none, casted, alias
	var carg2 C.GType    // in, none, casted, alias
	var cret  C.gboolean // return

	carg1 = C.GType(typ)
	carg2 = C.GType(isAType)

	cret = C.g_type_is_a(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(isAType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeName wraps g_type_name
// 
// The function takes the following parameters:
// 
// 	- typ Type: type to return name for 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Get the unique name that is assigned to a type ID.
// 
// Note that this function (like all other GType API) cannot cope with
// invalid type IDs. %G_TYPE_INVALID may be passed to this function, as
// may be any other validly registered type ID, but randomized type IDs
// should not be passed in and will most likely lead to a crash.
func TypeName(typ Type) string {
	var carg1 C.GType  // in, none, casted, alias
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.GType(typ)

	cret = C.g_type_name(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// TypeNameFromInstance wraps g_type_name_from_instance
// 
// The function takes the following parameters:
// 
// 	- instance *TypeInstance 
// 
// The function returns the following values:
// 
// 	- goret string 
func TypeNameFromInstance(instance *TypeInstance) string {
	var carg1 *C.GTypeInstance // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	cret = C.g_type_name_from_instance(carg1)
	runtime.KeepAlive(instance)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TypeNextBase wraps g_type_next_base
// 
// The function takes the following parameters:
// 
// 	- leafType Type: descendant of @root_type and the type to be returned 
// 	- rootType Type: immediate parent of the returned type 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Given a @leaf_type and a @root_type which is contained in its
// ancestry, return the type that @root_type is the immediate parent
// of. In other words, this function determines the type that is
// derived directly from @root_type which is also a base class of
// @leaf_type.  Given a root type and a leaf type, this function can
// be used to determine the types and order in which the leaf type is
// descended from the root type.
func TypeNextBase(leafType Type, rootType Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(leafType)
	carg2 = C.GType(rootType)

	cret = C.g_type_next_base(carg1, carg2)
	runtime.KeepAlive(leafType)
	runtime.KeepAlive(rootType)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeParent wraps g_type_parent
// 
// The function takes the following parameters:
// 
// 	- typ Type: the derived type 
// 
// The function returns the following values:
// 
// 	- goret Type 
//
// Return the direct parent type of the passed in type. If the passed
// in type has no parent, i.e. is a fundamental type, 0 is returned.
func TypeParent(typ Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(typ)

	cret = C.g_type_parent(carg1)
	runtime.KeepAlive(typ)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeQname wraps g_type_qname
// 
// The function takes the following parameters:
// 
// 	- typ Type: type to return quark of type name for 
// 
// The function returns the following values:
// 
// 	- goret glib.Quark 
//
// Get the corresponding quark of the type IDs name.
func TypeQname(typ Type) glib.Quark {
	var carg1 C.GType  // in, none, casted, alias
	var cret  C.GQuark // return, none, casted, alias

	carg1 = C.GType(typ)

	cret = C.g_type_qname(carg1)
	runtime.KeepAlive(typ)

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TypeTestFlags wraps g_type_test_flags
// 
// The function takes the following parameters:
// 
// 	- typ Type 
// 	- flags uint 
// 
// The function returns the following values:
// 
// 	- goret bool 
func TypeTestFlags(typ Type, flags uint) bool {
	var carg1 C.GType    // in, none, casted, alias
	var carg2 C.guint    // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.GType(typ)
	carg2 = C.guint(flags)

	cret = C.g_type_test_flags(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantGetGType wraps g_variant_get_gtype
// 
// The function returns the following values:
// 
// 	- goret Type 
func VariantGetGType() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_variant_get_gtype()

	var goret Type

	goret = Type(cret)

	return goret
}

// BindingGroupInstance is the instance type used by all types extending GBindingGroup. It is used internally by the bindings. Users should use the interface [BindingGroup] instead.
type BindingGroupInstance struct {
	_ [0]func() // equal guard
	ObjectInstance
}

var _ BindingGroup = (*BindingGroupInstance)(nil)

// BindingGroup wraps GBindingGroup
//
// `GBindingGroup` can be used to bind multiple properties
// from an object collectively.
// 
// Use the various methods to bind properties from a single source
// object to multiple destination objects. Properties can be bound
// bidirectionally and are connected when the source object is set
// with [method@GObject.BindingGroup.set_source].
type BindingGroup interface {
	Object
	upcastToGBindingGroup() *BindingGroupInstance
}

func unsafeWrapBindingGroup(base *ObjectInstance) *BindingGroupInstance {
	return &BindingGroupInstance{
		ObjectInstance: *base,
	}
}

func init() {
	RegisterObjectCasting(
		TypeBindingGroup,
		func (inst *ObjectInstance) Object {
			return unsafeWrapBindingGroup(inst)
		},
	)
}

func marshalBindingGroupInstance(p unsafe.Pointer) (any, error) {
	return ValueFromNative(p).Object(), nil
}

// UnsafeBindingGroupFromGlibNone is used to convert raw GBindingGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibNone(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibNone(c).(BindingGroup)
}

// UnsafeBindingGroupFromGlibFull is used to convert raw GBindingGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibFull(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibFull(c).(BindingGroup)
}

// UnsafeBindingGroupFromGlibBorrow is used to convert raw GBindingGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibBorrow(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibBorrow(c).(BindingGroup)
}

func (b *BindingGroupInstance) upcastToGBindingGroup() *BindingGroupInstance {
	return b
}

// UnsafeBindingGroupToGlibNone is used to convert the instance to it's C value GBindingGroup. This is used by the bindings internally.
func UnsafeBindingGroupToGlibNone(c BindingGroup) unsafe.Pointer {
	return UnsafeObjectToGlibNone(c)
}

// UnsafeBindingGroupToGlibFull is used to convert the instance to it's C value GBindingGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBindingGroupToGlibFull(c BindingGroup) unsafe.Pointer {
	return UnsafeObjectToGlibFull(c)
}

// NewBindingGroup wraps g_binding_group_new
// 
// The function returns the following values:
// 
// 	- goret BindingGroup 
//
// Creates a new #GBindingGroup.
func NewBindingGroup() BindingGroup {
	var cret *C.GBindingGroup // return, full, converted

	cret = C.g_binding_group_new()

	var goret BindingGroup

	goret = UnsafeBindingGroupFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// InitiallyUnownedInstance is the instance type used by all types extending GInitiallyUnowned. It is used internally by the bindings. Users should use the interface [InitiallyUnowned] instead.
type InitiallyUnownedInstance struct {
	_ [0]func() // equal guard
	ObjectInstance
}

var _ InitiallyUnowned = (*InitiallyUnownedInstance)(nil)

// InitiallyUnowned wraps GInitiallyUnowned
//
// A type for objects that have an initially floating reference.
// 
// All the fields in the `GInitiallyUnowned` structure are private to the
// implementation and should never be accessed directly.
type InitiallyUnowned interface {
	Object
	upcastToGInitiallyUnowned() *InitiallyUnownedInstance

	// chain up virtual methods:
}

func unsafeWrapInitiallyUnowned(base *ObjectInstance) *InitiallyUnownedInstance {
	return &InitiallyUnownedInstance{
		ObjectInstance: *base,
	}
}

func init() {
	RegisterObjectCasting(
		TypeInitiallyUnowned,
		func (inst *ObjectInstance) Object {
			return unsafeWrapInitiallyUnowned(inst)
		},
	)
}

func marshalInitiallyUnownedInstance(p unsafe.Pointer) (any, error) {
	return ValueFromNative(p).Object(), nil
}

// UnsafeInitiallyUnownedFromGlibNone is used to convert raw GInitiallyUnowned pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibNone(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibNone(c).(InitiallyUnowned)
}

// UnsafeInitiallyUnownedFromGlibFull is used to convert raw GInitiallyUnowned pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibFull(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibFull(c).(InitiallyUnowned)
}

// UnsafeInitiallyUnownedFromGlibBorrow is used to convert raw GInitiallyUnowned pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibBorrow(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibBorrow(c).(InitiallyUnowned)
}

func (i *InitiallyUnownedInstance) upcastToGInitiallyUnowned() *InitiallyUnownedInstance {
	return i
}

// UnsafeInitiallyUnownedToGlibNone is used to convert the instance to it's C value GInitiallyUnowned. This is used by the bindings internally.
func UnsafeInitiallyUnownedToGlibNone(c InitiallyUnowned) unsafe.Pointer {
	return UnsafeObjectToGlibNone(c)
}

// UnsafeInitiallyUnownedToGlibFull is used to convert the instance to it's C value GInitiallyUnowned, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedToGlibFull(c InitiallyUnowned) unsafe.Pointer {
	return UnsafeObjectToGlibFull(c)
}

// InitiallyUnownedOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InitiallyUnownedOverrides[Instance InitiallyUnowned] struct {
	// ObjectOverrides allows you to override virtual methods from the parent class Object
	ObjectOverrides[Instance]

}

// UnsafeApplyInitiallyUnownedOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInitiallyUnownedOverrides[Instance InitiallyUnowned](gclass unsafe.Pointer, overrides InitiallyUnownedOverrides[Instance]) {
	UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterInitiallyUnownedSubClass is used to register a go subclass of GInitiallyUnowned. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInitiallyUnownedSubClass[InstanceT InitiallyUnowned](
		name string,
		classInit func(class *InitiallyUnownedClass),
		constructor func() InstanceT,
		overrides InitiallyUnownedOverrides[InstanceT],
		signals map[string]SignalDefinition,
		interfaceInits ...SubClassInterfaceInit[InstanceT],
) Type {
	return UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInitiallyUnowned,
		UnsafeInitiallyUnownedClassFromGlibBorrow,
		UnsafeApplyInitiallyUnownedOverrides,
		func (obj *ObjectInstance) Object {
			return unsafeWrapInitiallyUnowned(obj)
		},
		interfaceInits...,
	)
}

// CClosure wraps GCClosure
//
// A #GCClosure is a specialization of #GClosure for C function callbacks.
type CClosure struct {
	*cClosure
}

// cClosure is the struct that's finalized
type cClosure struct {
	native *C.GCClosure
}

// UnsafeCClosureToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CClosure) instance() *C.GCClosure {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCClosureFromGlibBorrow is used to convert raw C.GCClosure pointers to go. This is used by the bindings internally.
func UnsafeCClosureFromGlibBorrow(p unsafe.Pointer) *CClosure {
	if p == nil {
		return nil
	}
	return &CClosure{&cClosure{(*C.GCClosure)(p)}}
}

// UnsafeCClosureFromGlibNone is used to convert raw C.GCClosure pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeCClosureFromGlibNone(p unsafe.Pointer) *CClosure {
	wrapped := UnsafeCClosureFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to CClosure because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeCClosureFromGlibFull is used to convert raw C.GCClosure pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeCClosureFromGlibFull(p unsafe.Pointer) *CClosure {
	wrapped := UnsafeCClosureFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.cClosure,
		func (intern *cClosure) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeCClosureFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CClosure] is expected to work anymore.
func UnsafeCClosureFree(c *CClosure) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCClosureToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCClosureToGlibNone(c *CClosure) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeCClosureToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeCClosureToGlibFull(c *CClosure) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.cClosure, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // CClosure is invalid from here on
	return _p
}

// ClosureNotifyData wraps GClosureNotifyData
type ClosureNotifyData struct {
	*closureNotifyData
}

// closureNotifyData is the struct that's finalized
type closureNotifyData struct {
	native *C.GClosureNotifyData
}

// UnsafeClosureNotifyDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ClosureNotifyData) instance() *C.GClosureNotifyData {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeClosureNotifyDataFromGlibBorrow is used to convert raw C.GClosureNotifyData pointers to go. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibBorrow(p unsafe.Pointer) *ClosureNotifyData {
	if p == nil {
		return nil
	}
	return &ClosureNotifyData{&closureNotifyData{(*C.GClosureNotifyData)(p)}}
}

// UnsafeClosureNotifyDataFromGlibNone is used to convert raw C.GClosureNotifyData pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibNone(p unsafe.Pointer) *ClosureNotifyData {
	wrapped := UnsafeClosureNotifyDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ClosureNotifyData because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeClosureNotifyDataFromGlibFull is used to convert raw C.GClosureNotifyData pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibFull(p unsafe.Pointer) *ClosureNotifyData {
	wrapped := UnsafeClosureNotifyDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.closureNotifyData,
		func (intern *closureNotifyData) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeClosureNotifyDataFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ClosureNotifyData] is expected to work anymore.
func UnsafeClosureNotifyDataFree(c *ClosureNotifyData) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeClosureNotifyDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeClosureNotifyDataToGlibNone(c *ClosureNotifyData) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeClosureNotifyDataToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeClosureNotifyDataToGlibFull(c *ClosureNotifyData) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.closureNotifyData, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // ClosureNotifyData is invalid from here on
	return _p
}

// EnumClass wraps GEnumClass
//
// The class of an enumeration type holds information about its
// possible values.
type EnumClass struct {
	*enumClass
}

// enumClass is the struct that's finalized
type enumClass struct {
	native *C.GEnumClass
}

// UnsafeEnumClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EnumClass) instance() *C.GEnumClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEnumClassFromGlibBorrow is used to convert raw C.GEnumClass pointers to go. This is used by the bindings internally.
func UnsafeEnumClassFromGlibBorrow(p unsafe.Pointer) *EnumClass {
	if p == nil {
		return nil
	}
	return &EnumClass{&enumClass{(*C.GEnumClass)(p)}}
}

// UnsafeEnumClassFromGlibNone is used to convert raw C.GEnumClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeEnumClassFromGlibNone(p unsafe.Pointer) *EnumClass {
	wrapped := UnsafeEnumClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to EnumClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeEnumClassFromGlibFull is used to convert raw C.GEnumClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeEnumClassFromGlibFull(p unsafe.Pointer) *EnumClass {
	wrapped := UnsafeEnumClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.enumClass,
		func (intern *enumClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeEnumClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EnumClass] is expected to work anymore.
func UnsafeEnumClassFree(e *EnumClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEnumClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEnumClassToGlibNone(e *EnumClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// UnsafeEnumClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeEnumClassToGlibFull(e *EnumClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	runtime.SetFinalizer(e.enumClass, nil)
	_p := unsafe.Pointer(e.native)
	e.native = nil // EnumClass is invalid from here on
	return _p
}

// EnumValue wraps GEnumValue
//
// A structure which contains a single enum value, its name, and its
// nickname.
type EnumValue struct {
	*enumValue
}

// enumValue is the struct that's finalized
type enumValue struct {
	native *C.GEnumValue
}

// UnsafeEnumValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EnumValue) instance() *C.GEnumValue {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEnumValueFromGlibBorrow is used to convert raw C.GEnumValue pointers to go. This is used by the bindings internally.
func UnsafeEnumValueFromGlibBorrow(p unsafe.Pointer) *EnumValue {
	if p == nil {
		return nil
	}
	return &EnumValue{&enumValue{(*C.GEnumValue)(p)}}
}

// UnsafeEnumValueFromGlibNone is used to convert raw C.GEnumValue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeEnumValueFromGlibNone(p unsafe.Pointer) *EnumValue {
	wrapped := UnsafeEnumValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to EnumValue because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeEnumValueFromGlibFull is used to convert raw C.GEnumValue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeEnumValueFromGlibFull(p unsafe.Pointer) *EnumValue {
	wrapped := UnsafeEnumValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.enumValue,
		func (intern *enumValue) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeEnumValueFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EnumValue] is expected to work anymore.
func UnsafeEnumValueFree(e *EnumValue) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEnumValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEnumValueToGlibNone(e *EnumValue) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// UnsafeEnumValueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeEnumValueToGlibFull(e *EnumValue) unsafe.Pointer {
	if e == nil {
		return nil
	}
	runtime.SetFinalizer(e.enumValue, nil)
	_p := unsafe.Pointer(e.native)
	e.native = nil // EnumValue is invalid from here on
	return _p
}

// FlagsClass wraps GFlagsClass
//
// The class of a flags type holds information about its
// possible values.
type FlagsClass struct {
	*flagsClass
}

// flagsClass is the struct that's finalized
type flagsClass struct {
	native *C.GFlagsClass
}

// UnsafeFlagsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FlagsClass) instance() *C.GFlagsClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFlagsClassFromGlibBorrow is used to convert raw C.GFlagsClass pointers to go. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibBorrow(p unsafe.Pointer) *FlagsClass {
	if p == nil {
		return nil
	}
	return &FlagsClass{&flagsClass{(*C.GFlagsClass)(p)}}
}

// UnsafeFlagsClassFromGlibNone is used to convert raw C.GFlagsClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibNone(p unsafe.Pointer) *FlagsClass {
	wrapped := UnsafeFlagsClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FlagsClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFlagsClassFromGlibFull is used to convert raw C.GFlagsClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibFull(p unsafe.Pointer) *FlagsClass {
	wrapped := UnsafeFlagsClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.flagsClass,
		func (intern *flagsClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFlagsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FlagsClass] is expected to work anymore.
func UnsafeFlagsClassFree(f *FlagsClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFlagsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFlagsClassToGlibNone(f *FlagsClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFlagsClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFlagsClassToGlibFull(f *FlagsClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.flagsClass, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FlagsClass is invalid from here on
	return _p
}

// FlagsValue wraps GFlagsValue
//
// A structure which contains a single flags value, its name, and its
// nickname.
type FlagsValue struct {
	*flagsValue
}

// flagsValue is the struct that's finalized
type flagsValue struct {
	native *C.GFlagsValue
}

// UnsafeFlagsValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FlagsValue) instance() *C.GFlagsValue {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFlagsValueFromGlibBorrow is used to convert raw C.GFlagsValue pointers to go. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibBorrow(p unsafe.Pointer) *FlagsValue {
	if p == nil {
		return nil
	}
	return &FlagsValue{&flagsValue{(*C.GFlagsValue)(p)}}
}

// UnsafeFlagsValueFromGlibNone is used to convert raw C.GFlagsValue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibNone(p unsafe.Pointer) *FlagsValue {
	wrapped := UnsafeFlagsValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FlagsValue because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFlagsValueFromGlibFull is used to convert raw C.GFlagsValue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibFull(p unsafe.Pointer) *FlagsValue {
	wrapped := UnsafeFlagsValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.flagsValue,
		func (intern *flagsValue) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFlagsValueFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FlagsValue] is expected to work anymore.
func UnsafeFlagsValueFree(f *FlagsValue) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFlagsValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFlagsValueToGlibNone(f *FlagsValue) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFlagsValueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFlagsValueToGlibFull(f *FlagsValue) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.flagsValue, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FlagsValue is invalid from here on
	return _p
}

// InitiallyUnownedClass wraps GInitiallyUnownedClass
//
// The class structure for the GInitiallyUnowned type.
// 
// InitiallyUnownedClass is the type struct for [InitiallyUnowned]
type InitiallyUnownedClass struct {
	*initiallyUnownedClass
}

// initiallyUnownedClass is the struct that's finalized
type initiallyUnownedClass struct {
	native *C.GInitiallyUnownedClass
}

// UnsafeInitiallyUnownedClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InitiallyUnownedClass) instance() *C.GInitiallyUnownedClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInitiallyUnownedClassFromGlibBorrow is used to convert raw C.GInitiallyUnownedClass pointers to go. This is used by the bindings internally.
func UnsafeInitiallyUnownedClassFromGlibBorrow(p unsafe.Pointer) *InitiallyUnownedClass {
	if p == nil {
		return nil
	}
	return &InitiallyUnownedClass{&initiallyUnownedClass{(*C.GInitiallyUnownedClass)(p)}}
}

// UnsafeInitiallyUnownedClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InitiallyUnownedClass] is expected to work anymore.
func UnsafeInitiallyUnownedClassFree(i *InitiallyUnownedClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInitiallyUnownedClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInitiallyUnownedClassToGlibNone(i *InitiallyUnownedClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InitiallyUnownedClass) ParentClass() *ObjectClass {
	parent := UnsafeObjectClassFromGlibBorrow(UnsafeInitiallyUnownedClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InitiallyUnownedClass) {}, i)
	return parent
}

// InterfaceInfo wraps GInterfaceInfo
//
// A structure that provides information to the type system which is
// used specifically for managing interface types.
type InterfaceInfo struct {
	*interfaceInfo
}

// interfaceInfo is the struct that's finalized
type interfaceInfo struct {
	native *C.GInterfaceInfo
}

// UnsafeInterfaceInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InterfaceInfo) instance() *C.GInterfaceInfo {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInterfaceInfoFromGlibBorrow is used to convert raw C.GInterfaceInfo pointers to go. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibBorrow(p unsafe.Pointer) *InterfaceInfo {
	if p == nil {
		return nil
	}
	return &InterfaceInfo{&interfaceInfo{(*C.GInterfaceInfo)(p)}}
}

// UnsafeInterfaceInfoFromGlibNone is used to convert raw C.GInterfaceInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibNone(p unsafe.Pointer) *InterfaceInfo {
	wrapped := UnsafeInterfaceInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InterfaceInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInterfaceInfoFromGlibFull is used to convert raw C.GInterfaceInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibFull(p unsafe.Pointer) *InterfaceInfo {
	wrapped := UnsafeInterfaceInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.interfaceInfo,
		func (intern *interfaceInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInterfaceInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InterfaceInfo] is expected to work anymore.
func UnsafeInterfaceInfoFree(i *InterfaceInfo) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInterfaceInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInterfaceInfoToGlibNone(i *InterfaceInfo) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInterfaceInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInterfaceInfoToGlibFull(i *InterfaceInfo) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.interfaceInfo, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InterfaceInfo is invalid from here on
	return _p
}

// ObjectConstructParam wraps GObjectConstructParam
//
// The GObjectConstructParam struct is an auxiliary structure used to hand
// #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.
type ObjectConstructParam struct {
	*objectConstructParam
}

// objectConstructParam is the struct that's finalized
type objectConstructParam struct {
	native *C.GObjectConstructParam
}

// UnsafeObjectConstructParamToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *ObjectConstructParam) instance() *C.GObjectConstructParam {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeObjectConstructParamFromGlibBorrow is used to convert raw C.GObjectConstructParam pointers to go. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibBorrow(p unsafe.Pointer) *ObjectConstructParam {
	if p == nil {
		return nil
	}
	return &ObjectConstructParam{&objectConstructParam{(*C.GObjectConstructParam)(p)}}
}

// UnsafeObjectConstructParamFromGlibNone is used to convert raw C.GObjectConstructParam pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibNone(p unsafe.Pointer) *ObjectConstructParam {
	wrapped := UnsafeObjectConstructParamFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ObjectConstructParam because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeObjectConstructParamFromGlibFull is used to convert raw C.GObjectConstructParam pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibFull(p unsafe.Pointer) *ObjectConstructParam {
	wrapped := UnsafeObjectConstructParamFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.objectConstructParam,
		func (intern *objectConstructParam) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeObjectConstructParamFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ObjectConstructParam] is expected to work anymore.
func UnsafeObjectConstructParamFree(o *ObjectConstructParam) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeObjectConstructParamToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeObjectConstructParamToGlibNone(o *ObjectConstructParam) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeObjectConstructParamToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeObjectConstructParamToGlibFull(o *ObjectConstructParam) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.objectConstructParam, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // ObjectConstructParam is invalid from here on
	return _p
}

// SignalInvocationHint wraps GSignalInvocationHint
//
// The #GSignalInvocationHint structure is used to pass on additional information
// to callbacks during a signal emission.
type SignalInvocationHint struct {
	*signalInvocationHint
}

// signalInvocationHint is the struct that's finalized
type signalInvocationHint struct {
	native *C.GSignalInvocationHint
}

// UnsafeSignalInvocationHintToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SignalInvocationHint) instance() *C.GSignalInvocationHint {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSignalInvocationHintFromGlibBorrow is used to convert raw C.GSignalInvocationHint pointers to go. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibBorrow(p unsafe.Pointer) *SignalInvocationHint {
	if p == nil {
		return nil
	}
	return &SignalInvocationHint{&signalInvocationHint{(*C.GSignalInvocationHint)(p)}}
}

// UnsafeSignalInvocationHintFromGlibNone is used to convert raw C.GSignalInvocationHint pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibNone(p unsafe.Pointer) *SignalInvocationHint {
	wrapped := UnsafeSignalInvocationHintFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SignalInvocationHint because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSignalInvocationHintFromGlibFull is used to convert raw C.GSignalInvocationHint pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibFull(p unsafe.Pointer) *SignalInvocationHint {
	wrapped := UnsafeSignalInvocationHintFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.signalInvocationHint,
		func (intern *signalInvocationHint) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSignalInvocationHintFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SignalInvocationHint] is expected to work anymore.
func UnsafeSignalInvocationHintFree(s *SignalInvocationHint) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSignalInvocationHintToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSignalInvocationHintToGlibNone(s *SignalInvocationHint) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSignalInvocationHintToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSignalInvocationHintToGlibFull(s *SignalInvocationHint) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.signalInvocationHint, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SignalInvocationHint is invalid from here on
	return _p
}

// TypeFundamentalInfo wraps GTypeFundamentalInfo
//
// A structure that provides information to the type system which is
// used specifically for managing fundamental types.
type TypeFundamentalInfo struct {
	*typeFundamentalInfo
}

// typeFundamentalInfo is the struct that's finalized
type typeFundamentalInfo struct {
	native *C.GTypeFundamentalInfo
}

// UnsafeTypeFundamentalInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeFundamentalInfo) instance() *C.GTypeFundamentalInfo {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeFundamentalInfoFromGlibBorrow is used to convert raw C.GTypeFundamentalInfo pointers to go. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibBorrow(p unsafe.Pointer) *TypeFundamentalInfo {
	if p == nil {
		return nil
	}
	return &TypeFundamentalInfo{&typeFundamentalInfo{(*C.GTypeFundamentalInfo)(p)}}
}

// UnsafeTypeFundamentalInfoFromGlibNone is used to convert raw C.GTypeFundamentalInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibNone(p unsafe.Pointer) *TypeFundamentalInfo {
	wrapped := UnsafeTypeFundamentalInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeFundamentalInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeFundamentalInfoFromGlibFull is used to convert raw C.GTypeFundamentalInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibFull(p unsafe.Pointer) *TypeFundamentalInfo {
	wrapped := UnsafeTypeFundamentalInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeFundamentalInfo,
		func (intern *typeFundamentalInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeFundamentalInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeFundamentalInfo] is expected to work anymore.
func UnsafeTypeFundamentalInfoFree(t *TypeFundamentalInfo) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeFundamentalInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoToGlibNone(t *TypeFundamentalInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeFundamentalInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeFundamentalInfoToGlibFull(t *TypeFundamentalInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeFundamentalInfo, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeFundamentalInfo is invalid from here on
	return _p
}

// TypeInfo wraps GTypeInfo
//
// This structure is used to provide the type system with the information
// required to initialize and destruct (finalize) a type's class and
// its instances.
// 
// The initialized structure is passed to the g_type_register_static() function
// (or is copied into the provided #GTypeInfo structure in the
// g_type_plugin_complete_type_info()). The type system will perform a deep
// copy of this structure, so its memory does not need to be persistent
// across invocation of g_type_register_static().
type TypeInfo struct {
	*typeInfo
}

// typeInfo is the struct that's finalized
type typeInfo struct {
	native *C.GTypeInfo
}

// UnsafeTypeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeInfo) instance() *C.GTypeInfo {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeInfoFromGlibBorrow is used to convert raw C.GTypeInfo pointers to go. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibBorrow(p unsafe.Pointer) *TypeInfo {
	if p == nil {
		return nil
	}
	return &TypeInfo{&typeInfo{(*C.GTypeInfo)(p)}}
}

// UnsafeTypeInfoFromGlibNone is used to convert raw C.GTypeInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibNone(p unsafe.Pointer) *TypeInfo {
	wrapped := UnsafeTypeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeInfoFromGlibFull is used to convert raw C.GTypeInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibFull(p unsafe.Pointer) *TypeInfo {
	wrapped := UnsafeTypeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeInfo,
		func (intern *typeInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeInfo] is expected to work anymore.
func UnsafeTypeInfoFree(t *TypeInfo) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeInfoToGlibNone(t *TypeInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeInfoToGlibFull(t *TypeInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeInfo, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeInfo is invalid from here on
	return _p
}

// TypeInstance wraps GTypeInstance
//
// An opaque structure used as the base of all type instances.
type TypeInstance struct {
	*typeInstance
}

// typeInstance is the struct that's finalized
type typeInstance struct {
	native *C.GTypeInstance
}

// UnsafeTypeInstanceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeInstance) instance() *C.GTypeInstance {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeInstanceFromGlibBorrow is used to convert raw C.GTypeInstance pointers to go. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibBorrow(p unsafe.Pointer) *TypeInstance {
	if p == nil {
		return nil
	}
	return &TypeInstance{&typeInstance{(*C.GTypeInstance)(p)}}
}

// UnsafeTypeInstanceFromGlibNone is used to convert raw C.GTypeInstance pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibNone(p unsafe.Pointer) *TypeInstance {
	wrapped := UnsafeTypeInstanceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeInstance because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeInstanceFromGlibFull is used to convert raw C.GTypeInstance pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibFull(p unsafe.Pointer) *TypeInstance {
	wrapped := UnsafeTypeInstanceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeInstance,
		func (intern *typeInstance) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeInstanceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeInstance] is expected to work anymore.
func UnsafeTypeInstanceFree(t *TypeInstance) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeInstanceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeInstanceToGlibNone(t *TypeInstance) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeInstanceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeInstanceToGlibFull(t *TypeInstance) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeInstance, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeInstance is invalid from here on
	return _p
}

// TypeValueTable wraps GTypeValueTable
//
// - `'i'`: Integers, passed as `collect_values[].v_int`
//   - `'l'`: Longs, passed as `collect_values[].v_long`
//   - `'d'`: Doubles, passed as `collect_values[].v_double`
//   - `'p'`: Pointers, passed as `collect_values[].v_pointer`
// 
//   It should be noted that for variable argument list construction,
//   ANSI C promotes every type smaller than an integer to an int, and
//   floats to doubles. So for collection of short int or char, `'i'`
//   needs to be used, and for collection of floats `'d'`.
// The #GTypeValueTable provides the functions required by the #GValue
// implementation, to serve as a container for values of a type.
type TypeValueTable struct {
	*typeValueTable
}

// typeValueTable is the struct that's finalized
type typeValueTable struct {
	native *C.GTypeValueTable
}

// UnsafeTypeValueTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeValueTable) instance() *C.GTypeValueTable {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeValueTableFromGlibBorrow is used to convert raw C.GTypeValueTable pointers to go. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibBorrow(p unsafe.Pointer) *TypeValueTable {
	if p == nil {
		return nil
	}
	return &TypeValueTable{&typeValueTable{(*C.GTypeValueTable)(p)}}
}

// UnsafeTypeValueTableFromGlibNone is used to convert raw C.GTypeValueTable pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibNone(p unsafe.Pointer) *TypeValueTable {
	wrapped := UnsafeTypeValueTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeValueTable because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeValueTableFromGlibFull is used to convert raw C.GTypeValueTable pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibFull(p unsafe.Pointer) *TypeValueTable {
	wrapped := UnsafeTypeValueTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeValueTable,
		func (intern *typeValueTable) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeValueTableFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeValueTable] is expected to work anymore.
func UnsafeTypeValueTableFree(t *TypeValueTable) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeValueTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeValueTableToGlibNone(t *TypeValueTable) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeValueTableToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeValueTableToGlibFull(t *TypeValueTable) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeValueTable, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeValueTable is invalid from here on
	return _p
}

// WeakRef wraps GWeakRef
//
// A structure containing a weak reference to a #GObject.
// 
// A `GWeakRef` can either be empty (i.e. point to %NULL), or point to an
// object for as long as at least one "strong" reference to that object
// exists. Before the object's #GObjectClass.dispose method is called,
// every #GWeakRef associated with becomes empty (i.e. points to %NULL).
// 
// Like #GValue, #GWeakRef can be statically allocated, stack- or
// heap-allocated, or embedded in larger structures.
// 
// Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
// reference is thread-safe: converting a weak pointer to a reference is
// atomic with respect to invalidation of weak pointers to destroyed
// objects.
// 
// If the object's #GObjectClass.dispose method results in additional
// references to the object being held (&#x2018;re-referencing&#x2019;), any #GWeakRefs taken
// before it was disposed will continue to point to %NULL.  Any #GWeakRefs taken
// during disposal and after re-referencing, or after disposal has returned due
// to the re-referencing, will continue to point to the object until its refcount
// goes back to zero, at which point they too will be invalidated.
// 
// It is invalid to take a #GWeakRef on an object during #GObjectClass.dispose
// without first having or creating a strong reference to the object.
type WeakRef struct {
	*weakRef
}

// weakRef is the struct that's finalized
type weakRef struct {
	native *C.GWeakRef
}

// UnsafeWeakRefToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (w *WeakRef) instance() *C.GWeakRef {
	if w == nil {
		return nil
	}
	return w.native
}

// UnsafeWeakRefFromGlibBorrow is used to convert raw C.GWeakRef pointers to go. This is used by the bindings internally.
func UnsafeWeakRefFromGlibBorrow(p unsafe.Pointer) *WeakRef {
	if p == nil {
		return nil
	}
	return &WeakRef{&weakRef{(*C.GWeakRef)(p)}}
}

// UnsafeWeakRefFromGlibNone is used to convert raw C.GWeakRef pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeWeakRefFromGlibNone(p unsafe.Pointer) *WeakRef {
	wrapped := UnsafeWeakRefFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to WeakRef because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeWeakRefFromGlibFull is used to convert raw C.GWeakRef pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeWeakRefFromGlibFull(p unsafe.Pointer) *WeakRef {
	wrapped := UnsafeWeakRefFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.weakRef,
		func (intern *weakRef) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeWeakRefFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [WeakRef] is expected to work anymore.
func UnsafeWeakRefFree(w *WeakRef) {
	C.free(unsafe.Pointer(w.native))
}

// UnsafeWeakRefToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeWeakRefToGlibNone(w *WeakRef) unsafe.Pointer {
	if w == nil {
		return nil
	}
	return unsafe.Pointer(w.native)
}

// UnsafeWeakRefToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeWeakRefToGlibFull(w *WeakRef) unsafe.Pointer {
	if w == nil {
		return nil
	}
	runtime.SetFinalizer(w.weakRef, nil)
	_p := unsafe.Pointer(w.native)
	w.native = nil // WeakRef is invalid from here on
	return _p
}

