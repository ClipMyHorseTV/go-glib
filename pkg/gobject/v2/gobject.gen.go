// Code generated by girgen for GObject-2. DO NOT EDIT.

package gobject

import (
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
import "C"

// GType values.
var (
	TypeBindingFlags     = Type(C.g_binding_flags_get_type())
	TypeIOCondition      = Type(C.g_io_condition_get_type())
	TypeBindingGroup     = Type(C.g_binding_group_get_type())
	TypeInitiallyUnowned = Type(C.g_initially_unowned_get_type())
)

func init() {
	RegisterGValueMarshalers([]TypeMarshaler{
		TypeMarshaler{T: TypeBindingFlags, F: marshalBindingFlags},
		TypeMarshaler{T: TypeIOCondition, F: marshalIOCondition},
		TypeMarshaler{T: TypeBindingGroup, F: marshalBindingGroupInstance},
		TypeMarshaler{T: TypeInitiallyUnowned, F: marshalInitiallyUnownedInstance},
	})
}

// PARAM_MASK wraps G_PARAM_MASK
// 
// see also https://docs.gtk.org/gobject/const.PARAM_MASK.html
//
const PARAM_MASK = 255
// PARAM_STATIC_STRINGS wraps G_PARAM_STATIC_STRINGS
// 
// see also https://docs.gtk.org/gobject/const.PARAM_STATIC_STRINGS.html
//
const PARAM_STATIC_STRINGS = 224
// PARAM_USER_SHIFT wraps G_PARAM_USER_SHIFT
// 
// see also https://docs.gtk.org/gobject/const.PARAM_USER_SHIFT.html
//
const PARAM_USER_SHIFT = 8
// SIGNAL_FLAGS_MASK wraps G_SIGNAL_FLAGS_MASK
// 
// see also https://docs.gtk.org/gobject/const.SIGNAL_FLAGS_MASK.html
//
const SIGNAL_FLAGS_MASK = 511
// SIGNAL_MATCH_MASK wraps G_SIGNAL_MATCH_MASK
// 
// see also https://docs.gtk.org/gobject/const.SIGNAL_MATCH_MASK.html
//
const SIGNAL_MATCH_MASK = 63
// TYPE_FUNDAMENTAL_MAX wraps G_TYPE_FUNDAMENTAL_MAX
// 
// see also https://docs.gtk.org/gobject/const.TYPE_FUNDAMENTAL_MAX.html
//
const TYPE_FUNDAMENTAL_MAX = 1020
// TYPE_FUNDAMENTAL_SHIFT wraps G_TYPE_FUNDAMENTAL_SHIFT
// 
// see also https://docs.gtk.org/gobject/const.TYPE_FUNDAMENTAL_SHIFT.html
//
const TYPE_FUNDAMENTAL_SHIFT = 2
// TYPE_RESERVED_BSE_FIRST wraps G_TYPE_RESERVED_BSE_FIRST
// 
// see also https://docs.gtk.org/gobject/const.TYPE_RESERVED_BSE_FIRST.html
//
const TYPE_RESERVED_BSE_FIRST = 32
// TYPE_RESERVED_BSE_LAST wraps G_TYPE_RESERVED_BSE_LAST
// 
// see also https://docs.gtk.org/gobject/const.TYPE_RESERVED_BSE_LAST.html
//
const TYPE_RESERVED_BSE_LAST = 48
// TYPE_RESERVED_GLIB_FIRST wraps G_TYPE_RESERVED_GLIB_FIRST
// 
// see also https://docs.gtk.org/gobject/const.TYPE_RESERVED_GLIB_FIRST.html
//
const TYPE_RESERVED_GLIB_FIRST = 22
// TYPE_RESERVED_GLIB_LAST wraps G_TYPE_RESERVED_GLIB_LAST
// 
// see also https://docs.gtk.org/gobject/const.TYPE_RESERVED_GLIB_LAST.html
//
const TYPE_RESERVED_GLIB_LAST = 31
// TYPE_RESERVED_USER_FIRST wraps G_TYPE_RESERVED_USER_FIRST
// 
// see also https://docs.gtk.org/gobject/const.TYPE_RESERVED_USER_FIRST.html
//
const TYPE_RESERVED_USER_FIRST = 49
// VALUE_COLLECT_FORMAT_MAX_LENGTH wraps G_VALUE_COLLECT_FORMAT_MAX_LENGTH
// 
// see also https://docs.gtk.org/gobject/const.VALUE_COLLECT_FORMAT_MAX_LENGTH.html
//
const VALUE_COLLECT_FORMAT_MAX_LENGTH = 8
// VALUE_INTERNED_STRING wraps G_VALUE_INTERNED_STRING
// 
// see also https://docs.gtk.org/gobject/const.VALUE_INTERNED_STRING.html
//
const VALUE_INTERNED_STRING = 268435456
// VALUE_NOCOPY_CONTENTS wraps G_VALUE_NOCOPY_CONTENTS
// 
// see also https://docs.gtk.org/gobject/const.VALUE_NOCOPY_CONTENTS.html
//
const VALUE_NOCOPY_CONTENTS = 134217728
// BindingFlags wraps GBindingFlags
// 
// see also https://docs.gtk.org/gobject/flags.BindingFlags.html
//
type BindingFlags C.gint

const (
	// BindingDefault wraps G_BINDING_DEFAULT
	// 
	// see also https://docs.gtk.org/gobject/flags.BindingFlags.html#default
	//
	BindingDefault BindingFlags = 0
	// BindingBidirectional wraps G_BINDING_BIDIRECTIONAL
	// 
	// see also https://docs.gtk.org/gobject/flags.BindingFlags.html#bidirectional
	//
	BindingBidirectional BindingFlags = 1
	// BindingSyncCreate wraps G_BINDING_SYNC_CREATE
	// 
	// see also https://docs.gtk.org/gobject/flags.BindingFlags.html#sync_create
	//
	BindingSyncCreate BindingFlags = 2
	// BindingInvertBoolean wraps G_BINDING_INVERT_BOOLEAN
	// 
	// see also https://docs.gtk.org/gobject/flags.BindingFlags.html#invert_boolean
	//
	BindingInvertBoolean BindingFlags = 4
)

func marshalBindingFlags(p unsafe.Pointer) (any, error) {
	return BindingFlags(ValueFromNative(p).Flags()), nil
}
// Has returns true if b contains other
func (b BindingFlags) Has(other BindingFlags) bool {
	return (b & other) == other
}

var _ GoValueInitializer = BindingFlags(0)

func (f BindingFlags) GoValueType() Type {
	return TypeBindingFlags
}

func (f BindingFlags) SetGoValue(v *Value) {
	v.SetFlags(int(f))
}

func (f BindingFlags) String() string {
	if f == 0 {
		return "BindingFlags(0)"
	}

	var parts []string
	if (f & BindingDefault) != 0 {
		parts = append(parts, "BindingDefault")
	}
	if (f & BindingBidirectional) != 0 {
		parts = append(parts, "BindingBidirectional")
	}
	if (f & BindingSyncCreate) != 0 {
		parts = append(parts, "BindingSyncCreate")
	}
	if (f & BindingInvertBoolean) != 0 {
		parts = append(parts, "BindingInvertBoolean")
	}
	return "BindingFlags(" + strings.Join(parts, "|") + ")"
}

// ConnectFlags wraps GConnectFlags
// 
// see also https://docs.gtk.org/gobject/flags.ConnectFlags.html
//
type ConnectFlags C.gint

const (
	// ConnectDefault wraps G_CONNECT_DEFAULT
	// 
	// see also https://docs.gtk.org/gobject/flags.ConnectFlags.html#default
	//
	ConnectDefault ConnectFlags = 0
	// ConnectAfter wraps G_CONNECT_AFTER
	// 
	// see also https://docs.gtk.org/gobject/flags.ConnectFlags.html#after
	//
	ConnectAfter ConnectFlags = 1
	// ConnectSwapped wraps G_CONNECT_SWAPPED
	// 
	// see also https://docs.gtk.org/gobject/flags.ConnectFlags.html#swapped
	//
	ConnectSwapped ConnectFlags = 2
)

// Has returns true if c contains other
func (c ConnectFlags) Has(other ConnectFlags) bool {
	return (c & other) == other
}

func (f ConnectFlags) String() string {
	if f == 0 {
		return "ConnectFlags(0)"
	}

	var parts []string
	if (f & ConnectDefault) != 0 {
		parts = append(parts, "ConnectDefault")
	}
	if (f & ConnectAfter) != 0 {
		parts = append(parts, "ConnectAfter")
	}
	if (f & ConnectSwapped) != 0 {
		parts = append(parts, "ConnectSwapped")
	}
	return "ConnectFlags(" + strings.Join(parts, "|") + ")"
}

// IOCondition wraps GIOCondition
// 
// see also https://docs.gtk.org/gobject/flags.IOCondition.html
type IOCondition C.gint

const (
	// IOIn wraps G_IO_IN
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#in
	IOIn IOCondition = 1
	// IOOut wraps G_IO_OUT
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#out
	IOOut IOCondition = 4
	// IOPri wraps G_IO_PRI
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#pri
	IOPri IOCondition = 2
	// IOErr wraps G_IO_ERR
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#err
	IOErr IOCondition = 8
	// IOHup wraps G_IO_HUP
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#hup
	IOHup IOCondition = 16
	// IONval wraps G_IO_NVAL
	// 
	// see also https://docs.gtk.org/gobject/flags.IOCondition.html#nval
	IONval IOCondition = 32
)

func marshalIOCondition(p unsafe.Pointer) (any, error) {
	return IOCondition(ValueFromNative(p).Flags()), nil
}
// Has returns true if i contains other
func (i IOCondition) Has(other IOCondition) bool {
	return (i & other) == other
}

var _ GoValueInitializer = IOCondition(0)

func (f IOCondition) GoValueType() Type {
	return TypeIOCondition
}

func (f IOCondition) SetGoValue(v *Value) {
	v.SetFlags(int(f))
}

func (f IOCondition) String() string {
	if f == 0 {
		return "IOCondition(0)"
	}

	var parts []string
	if (f & IOIn) != 0 {
		parts = append(parts, "IOIn")
	}
	if (f & IOOut) != 0 {
		parts = append(parts, "IOOut")
	}
	if (f & IOPri) != 0 {
		parts = append(parts, "IOPri")
	}
	if (f & IOErr) != 0 {
		parts = append(parts, "IOErr")
	}
	if (f & IOHup) != 0 {
		parts = append(parts, "IOHup")
	}
	if (f & IONval) != 0 {
		parts = append(parts, "IONval")
	}
	return "IOCondition(" + strings.Join(parts, "|") + ")"
}

// ParamFlags wraps GParamFlags
// 
// see also https://docs.gtk.org/gobject/flags.ParamFlags.html
//
type ParamFlags C.gint

const (
	// ParamReadable wraps G_PARAM_READABLE
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#readable
	//
	ParamReadable ParamFlags = 1
	// ParamWritable wraps G_PARAM_WRITABLE
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#writable
	//
	ParamWritable ParamFlags = 2
	// ParamReadwrite wraps G_PARAM_READWRITE
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#readwrite
	//
	ParamReadwrite ParamFlags = 3
	// ParamConstruct wraps G_PARAM_CONSTRUCT
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#construct
	//
	ParamConstruct ParamFlags = 4
	// ParamConstructOnly wraps G_PARAM_CONSTRUCT_ONLY
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#construct_only
	//
	ParamConstructOnly ParamFlags = 8
	// ParamLaxValidation wraps G_PARAM_LAX_VALIDATION
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#lax_validation
	//
	ParamLaxValidation ParamFlags = 16
	// ParamStaticName wraps G_PARAM_STATIC_NAME
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#static_name
	//
	ParamStaticName ParamFlags = 32
	// ParamPrivate wraps G_PARAM_PRIVATE
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#private
	//
	ParamPrivate ParamFlags = 32
	// ParamStaticNick wraps G_PARAM_STATIC_NICK
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#static_nick
	//
	ParamStaticNick ParamFlags = 64
	// ParamStaticBlurb wraps G_PARAM_STATIC_BLURB
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#static_blurb
	//
	ParamStaticBlurb ParamFlags = 128
	// ParamExplicitNotify wraps G_PARAM_EXPLICIT_NOTIFY
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#explicit_notify
	//
	ParamExplicitNotify ParamFlags = 1073741824
	// ParamDeprecated wraps G_PARAM_DEPRECATED
	// 
	// see also https://docs.gtk.org/gobject/flags.ParamFlags.html#deprecated
	//
	ParamDeprecated ParamFlags = -2147483648
)

// Has returns true if p contains other
func (p ParamFlags) Has(other ParamFlags) bool {
	return (p & other) == other
}

func (f ParamFlags) String() string {
	if f == 0 {
		return "ParamFlags(0)"
	}

	var parts []string
	if (f & ParamReadable) != 0 {
		parts = append(parts, "ParamReadable")
	}
	if (f & ParamWritable) != 0 {
		parts = append(parts, "ParamWritable")
	}
	if (f & ParamReadwrite) != 0 {
		parts = append(parts, "ParamReadwrite")
	}
	if (f & ParamConstruct) != 0 {
		parts = append(parts, "ParamConstruct")
	}
	if (f & ParamConstructOnly) != 0 {
		parts = append(parts, "ParamConstructOnly")
	}
	if (f & ParamLaxValidation) != 0 {
		parts = append(parts, "ParamLaxValidation")
	}
	if (f & ParamStaticName) != 0 {
		parts = append(parts, "ParamStaticName")
	}
	if (f & ParamPrivate) != 0 {
		parts = append(parts, "ParamPrivate")
	}
	if (f & ParamStaticNick) != 0 {
		parts = append(parts, "ParamStaticNick")
	}
	if (f & ParamStaticBlurb) != 0 {
		parts = append(parts, "ParamStaticBlurb")
	}
	if (f & ParamExplicitNotify) != 0 {
		parts = append(parts, "ParamExplicitNotify")
	}
	if (f & ParamDeprecated) != 0 {
		parts = append(parts, "ParamDeprecated")
	}
	return "ParamFlags(" + strings.Join(parts, "|") + ")"
}

// SignalFlags wraps GSignalFlags
// 
// see also https://docs.gtk.org/gobject/flags.SignalFlags.html
//
type SignalFlags C.gint

const (
	// SignalRunFirst wraps G_SIGNAL_RUN_FIRST
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#run_first
	//
	SignalRunFirst SignalFlags = 1
	// SignalRunLast wraps G_SIGNAL_RUN_LAST
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#run_last
	//
	SignalRunLast SignalFlags = 2
	// SignalRunCleanup wraps G_SIGNAL_RUN_CLEANUP
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#run_cleanup
	//
	SignalRunCleanup SignalFlags = 4
	// SignalNoRecurse wraps G_SIGNAL_NO_RECURSE
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#no_recurse
	//
	SignalNoRecurse SignalFlags = 8
	// SignalDetailed wraps G_SIGNAL_DETAILED
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#detailed
	//
	SignalDetailed SignalFlags = 16
	// SignalAction wraps G_SIGNAL_ACTION
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#action
	//
	SignalAction SignalFlags = 32
	// SignalNoHooks wraps G_SIGNAL_NO_HOOKS
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#no_hooks
	//
	SignalNoHooks SignalFlags = 64
	// SignalMustCollect wraps G_SIGNAL_MUST_COLLECT
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#must_collect
	//
	SignalMustCollect SignalFlags = 128
	// SignalDeprecated wraps G_SIGNAL_DEPRECATED
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#deprecated
	//
	SignalDeprecated SignalFlags = 256
	// SignalAccumulatorFirstRun wraps G_SIGNAL_ACCUMULATOR_FIRST_RUN
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalFlags.html#accumulator_first_run
	//
	SignalAccumulatorFirstRun SignalFlags = 131072
)

// Has returns true if s contains other
func (s SignalFlags) Has(other SignalFlags) bool {
	return (s & other) == other
}

func (f SignalFlags) String() string {
	if f == 0 {
		return "SignalFlags(0)"
	}

	var parts []string
	if (f & SignalRunFirst) != 0 {
		parts = append(parts, "SignalRunFirst")
	}
	if (f & SignalRunLast) != 0 {
		parts = append(parts, "SignalRunLast")
	}
	if (f & SignalRunCleanup) != 0 {
		parts = append(parts, "SignalRunCleanup")
	}
	if (f & SignalNoRecurse) != 0 {
		parts = append(parts, "SignalNoRecurse")
	}
	if (f & SignalDetailed) != 0 {
		parts = append(parts, "SignalDetailed")
	}
	if (f & SignalAction) != 0 {
		parts = append(parts, "SignalAction")
	}
	if (f & SignalNoHooks) != 0 {
		parts = append(parts, "SignalNoHooks")
	}
	if (f & SignalMustCollect) != 0 {
		parts = append(parts, "SignalMustCollect")
	}
	if (f & SignalDeprecated) != 0 {
		parts = append(parts, "SignalDeprecated")
	}
	if (f & SignalAccumulatorFirstRun) != 0 {
		parts = append(parts, "SignalAccumulatorFirstRun")
	}
	return "SignalFlags(" + strings.Join(parts, "|") + ")"
}

// SignalMatchType wraps GSignalMatchType
// 
// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html
//
type SignalMatchType C.gint

const (
	// SignalMatchID wraps G_SIGNAL_MATCH_ID
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#id
	//
	SignalMatchID SignalMatchType = 1
	// SignalMatchDetail wraps G_SIGNAL_MATCH_DETAIL
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#detail
	//
	SignalMatchDetail SignalMatchType = 2
	// SignalMatchClosure wraps G_SIGNAL_MATCH_CLOSURE
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#closure
	//
	SignalMatchClosure SignalMatchType = 4
	// SignalMatchFunc wraps G_SIGNAL_MATCH_FUNC
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#func
	//
	SignalMatchFunc SignalMatchType = 8
	// SignalMatchData wraps G_SIGNAL_MATCH_DATA
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#data
	//
	SignalMatchData SignalMatchType = 16
	// SignalMatchUnblocked wraps G_SIGNAL_MATCH_UNBLOCKED
	// 
	// see also https://docs.gtk.org/gobject/flags.SignalMatchType.html#unblocked
	//
	SignalMatchUnblocked SignalMatchType = 32
)

// Has returns true if s contains other
func (s SignalMatchType) Has(other SignalMatchType) bool {
	return (s & other) == other
}

func (f SignalMatchType) String() string {
	if f == 0 {
		return "SignalMatchType(0)"
	}

	var parts []string
	if (f & SignalMatchID) != 0 {
		parts = append(parts, "SignalMatchID")
	}
	if (f & SignalMatchDetail) != 0 {
		parts = append(parts, "SignalMatchDetail")
	}
	if (f & SignalMatchClosure) != 0 {
		parts = append(parts, "SignalMatchClosure")
	}
	if (f & SignalMatchFunc) != 0 {
		parts = append(parts, "SignalMatchFunc")
	}
	if (f & SignalMatchData) != 0 {
		parts = append(parts, "SignalMatchData")
	}
	if (f & SignalMatchUnblocked) != 0 {
		parts = append(parts, "SignalMatchUnblocked")
	}
	return "SignalMatchType(" + strings.Join(parts, "|") + ")"
}

// TypeFlags wraps GTypeFlags
// 
// see also https://docs.gtk.org/gobject/flags.TypeFlags.html
//
type TypeFlags C.gint

const (
	// TypeFlagNone wraps G_TYPE_FLAG_NONE
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFlags.html#none
	//
	TypeFlagNone TypeFlags = 0
	// TypeFlagAbstract wraps G_TYPE_FLAG_ABSTRACT
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFlags.html#abstract
	//
	TypeFlagAbstract TypeFlags = 16
	// TypeFlagValueAbstract wraps G_TYPE_FLAG_VALUE_ABSTRACT
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFlags.html#value_abstract
	//
	TypeFlagValueAbstract TypeFlags = 32
	// TypeFlagFinal wraps G_TYPE_FLAG_FINAL
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFlags.html#final
	//
	TypeFlagFinal TypeFlags = 64
	// TypeFlagDeprecated wraps G_TYPE_FLAG_DEPRECATED
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFlags.html#deprecated
	//
	TypeFlagDeprecated TypeFlags = 128
)

// Has returns true if t contains other
func (t TypeFlags) Has(other TypeFlags) bool {
	return (t & other) == other
}

func (f TypeFlags) String() string {
	if f == 0 {
		return "TypeFlags(0)"
	}

	var parts []string
	if (f & TypeFlagNone) != 0 {
		parts = append(parts, "TypeFlagNone")
	}
	if (f & TypeFlagAbstract) != 0 {
		parts = append(parts, "TypeFlagAbstract")
	}
	if (f & TypeFlagValueAbstract) != 0 {
		parts = append(parts, "TypeFlagValueAbstract")
	}
	if (f & TypeFlagFinal) != 0 {
		parts = append(parts, "TypeFlagFinal")
	}
	if (f & TypeFlagDeprecated) != 0 {
		parts = append(parts, "TypeFlagDeprecated")
	}
	return "TypeFlags(" + strings.Join(parts, "|") + ")"
}

// TypeFundamentalFlags wraps GTypeFundamentalFlags
// 
// see also https://docs.gtk.org/gobject/flags.TypeFundamentalFlags.html
//
type TypeFundamentalFlags C.gint

const (
	// TypeFlagClassed wraps G_TYPE_FLAG_CLASSED
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFundamentalFlags.html#classed
	//
	TypeFlagClassed TypeFundamentalFlags = 1
	// TypeFlagInstantiatable wraps G_TYPE_FLAG_INSTANTIATABLE
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFundamentalFlags.html#instantiatable
	//
	TypeFlagInstantiatable TypeFundamentalFlags = 2
	// TypeFlagDerivable wraps G_TYPE_FLAG_DERIVABLE
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFundamentalFlags.html#derivable
	//
	TypeFlagDerivable TypeFundamentalFlags = 4
	// TypeFlagDeepDerivable wraps G_TYPE_FLAG_DEEP_DERIVABLE
	// 
	// see also https://docs.gtk.org/gobject/flags.TypeFundamentalFlags.html#deep_derivable
	//
	TypeFlagDeepDerivable TypeFundamentalFlags = 8
)

// Has returns true if t contains other
func (t TypeFundamentalFlags) Has(other TypeFundamentalFlags) bool {
	return (t & other) == other
}

func (f TypeFundamentalFlags) String() string {
	if f == 0 {
		return "TypeFundamentalFlags(0)"
	}

	var parts []string
	if (f & TypeFlagClassed) != 0 {
		parts = append(parts, "TypeFlagClassed")
	}
	if (f & TypeFlagInstantiatable) != 0 {
		parts = append(parts, "TypeFlagInstantiatable")
	}
	if (f & TypeFlagDerivable) != 0 {
		parts = append(parts, "TypeFlagDerivable")
	}
	if (f & TypeFlagDeepDerivable) != 0 {
		parts = append(parts, "TypeFlagDeepDerivable")
	}
	return "TypeFundamentalFlags(" + strings.Join(parts, "|") + ")"
}

// EnumCompleteTypeInfo wraps g_enum_complete_type_info
// 
// see also https://docs.gtk.org/gobject/func.g_enum_complete_type_info.html
//
func EnumCompleteTypeInfo(gEnumType Type, constValues []EnumValue) TypeInfo {
	var carg1 C.GType       // in, none, casted, alias
	var carg3 *C.GEnumValue // in, transfer: none, C Pointers: 1, Name: array[EnumValue], array (inner GEnumValue (*typesystem.Record), zero-terminated)
	var carg2 C.GTypeInfo   // out, transfer: full, C Pointers: 0, Name: TypeInfo

	carg1 = C.GType(gEnumType)
	_ = constValues
	_ = carg3
	panic("unimplemented conversion of []EnumValue (const GEnumValue*) because of unimplemented: non-fixed size array")

	C.g_enum_complete_type_info(carg1, &carg2, carg3)
	runtime.KeepAlive(gEnumType)
	runtime.KeepAlive(constValues)

	var info TypeInfo

	_ = info
	_ = carg2
	panic("unimplemented conversion of TypeInfo (GTypeInfo) because of unknown reason")

	return info
}

// EnumGetValue wraps g_enum_get_value
// 
// see also https://docs.gtk.org/gobject/func.g_enum_get_value.html
//
func EnumGetValue(enumClass *EnumClass, value int32) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 C.gint        // in, none, casted
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = C.gint(value)

	cret = C.g_enum_get_value(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(value)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumGetValueByName wraps g_enum_get_value_by_name
// 
// see also https://docs.gtk.org/gobject/func.g_enum_get_value_by_name.html
//
func EnumGetValueByName(enumClass *EnumClass, name string) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_enum_get_value_by_name(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(name)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumGetValueByNick wraps g_enum_get_value_by_nick
// 
// see also https://docs.gtk.org/gobject/func.g_enum_get_value_by_nick.html
//
func EnumGetValueByNick(enumClass *EnumClass, nick string) *EnumValue {
	var carg1 *C.GEnumClass // in, none, converted
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GEnumValue // return, none, converted, nullable

	carg1 = (*C.GEnumClass)(UnsafeEnumClassToGlibNone(enumClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_enum_get_value_by_nick(carg1, carg2)
	runtime.KeepAlive(enumClass)
	runtime.KeepAlive(nick)

	var goret *EnumValue

	if cret != nil {
		goret = UnsafeEnumValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// EnumRegisterStatic wraps g_enum_register_static
// 
// see also https://docs.gtk.org/gobject/func.g_enum_register_static.html
//
func EnumRegisterStatic(name string, constStaticValues []EnumValue) Type {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.GEnumValue // in, transfer: none, C Pointers: 1, Name: array[EnumValue], array (inner GEnumValue (*typesystem.Record), zero-terminated)
	var cret  C.GType       // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	_ = constStaticValues
	_ = carg2
	panic("unimplemented conversion of []EnumValue (const GEnumValue*) because of unimplemented: non-fixed size array")

	cret = C.g_enum_register_static(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(constStaticValues)

	var goret Type

	goret = Type(cret)

	return goret
}

// EnumToString wraps g_enum_to_string
// 
// see also https://docs.gtk.org/gobject/func.g_enum_to_string.html
//
func EnumToString(gEnumType Type, value int32) string {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.GType(gEnumType)
	carg2 = C.gint(value)

	cret = C.g_enum_to_string(carg1, carg2)
	runtime.KeepAlive(gEnumType)
	runtime.KeepAlive(value)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FlagsCompleteTypeInfo wraps g_flags_complete_type_info
// 
// see also https://docs.gtk.org/gobject/func.g_flags_complete_type_info.html
//
func FlagsCompleteTypeInfo(gFlagsType Type, constValues []FlagsValue) TypeInfo {
	var carg1 C.GType        // in, none, casted, alias
	var carg3 *C.GFlagsValue // in, transfer: none, C Pointers: 1, Name: array[FlagsValue], array (inner GFlagsValue (*typesystem.Record), zero-terminated)
	var carg2 C.GTypeInfo    // out, transfer: full, C Pointers: 0, Name: TypeInfo

	carg1 = C.GType(gFlagsType)
	_ = constValues
	_ = carg3
	panic("unimplemented conversion of []FlagsValue (const GFlagsValue*) because of unimplemented: non-fixed size array")

	C.g_flags_complete_type_info(carg1, &carg2, carg3)
	runtime.KeepAlive(gFlagsType)
	runtime.KeepAlive(constValues)

	var info TypeInfo

	_ = info
	_ = carg2
	panic("unimplemented conversion of TypeInfo (GTypeInfo) because of unknown reason")

	return info
}

// FlagsGetFirstValue wraps g_flags_get_first_value
// 
// see also https://docs.gtk.org/gobject/func.g_flags_get_first_value.html
//
func FlagsGetFirstValue(flagsClass *FlagsClass, value uint) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 C.guint        // in, none, casted
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = C.guint(value)

	cret = C.g_flags_get_first_value(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(value)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsGetValueByName wraps g_flags_get_value_by_name
// 
// see also https://docs.gtk.org/gobject/func.g_flags_get_value_by_name.html
//
func FlagsGetValueByName(flagsClass *FlagsClass, name string) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 *C.gchar       // in, none, string
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_flags_get_value_by_name(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(name)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsGetValueByNick wraps g_flags_get_value_by_nick
// 
// see also https://docs.gtk.org/gobject/func.g_flags_get_value_by_nick.html
//
func FlagsGetValueByNick(flagsClass *FlagsClass, nick string) *FlagsValue {
	var carg1 *C.GFlagsClass // in, none, converted
	var carg2 *C.gchar       // in, none, string
	var cret  *C.GFlagsValue // return, none, converted, nullable

	carg1 = (*C.GFlagsClass)(UnsafeFlagsClassToGlibNone(flagsClass))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_flags_get_value_by_nick(carg1, carg2)
	runtime.KeepAlive(flagsClass)
	runtime.KeepAlive(nick)

	var goret *FlagsValue

	if cret != nil {
		goret = UnsafeFlagsValueFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// FlagsRegisterStatic wraps g_flags_register_static
// 
// see also https://docs.gtk.org/gobject/func.g_flags_register_static.html
//
func FlagsRegisterStatic(name string, constStaticValues []FlagsValue) Type {
	var carg1 *C.gchar       // in, none, string
	var carg2 *C.GFlagsValue // in, transfer: none, C Pointers: 1, Name: array[FlagsValue], array (inner GFlagsValue (*typesystem.Record), zero-terminated)
	var cret  C.GType        // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	_ = constStaticValues
	_ = carg2
	panic("unimplemented conversion of []FlagsValue (const GFlagsValue*) because of unimplemented: non-fixed size array")

	cret = C.g_flags_register_static(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(constStaticValues)

	var goret Type

	goret = Type(cret)

	return goret
}

// FlagsToString wraps g_flags_to_string
// 
// see also https://docs.gtk.org/gobject/func.g_flags_to_string.html
//
func FlagsToString(flagsType Type, value uint) string {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.GType(flagsType)
	carg2 = C.guint(value)

	cret = C.g_flags_to_string(carg1, carg2)
	runtime.KeepAlive(flagsType)
	runtime.KeepAlive(value)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GTypeGetType wraps g_gtype_get_type
// 
// see also https://docs.gtk.org/gobject/func.g_gtype_get_type.html
func GTypeGetType() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_gtype_get_type()

	var goret Type

	goret = Type(cret)

	return goret
}

// ParamSpecBoolean wraps g_param_spec_boolean
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_boolean.html
//
func ParamSpecBoolean(name string, nick string, blurb string, defaultValue bool, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gboolean    // in
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if defaultValue {
		carg4 = C.TRUE
	}
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_boolean(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecBoxed wraps g_param_spec_boxed
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_boxed.html
//
func ParamSpecBoxed(name string, nick string, blurb string, boxedType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(boxedType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_boxed(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(boxedType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecChar wraps g_param_spec_char
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_char.html
//
func ParamSpecChar(name string, nick string, blurb string, minimum int8, maximum int8, defaultValue int8, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint8       // in, none, casted
	var carg5 C.gint8       // in, none, casted
	var carg6 C.gint8       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint8(minimum)
	carg5 = C.gint8(maximum)
	carg6 = C.gint8(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_char(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecDouble wraps g_param_spec_double
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_double.html
//
func ParamSpecDouble(name string, nick string, blurb string, minimum float64, maximum float64, defaultValue float64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gdouble     // in, none, casted
	var carg5 C.gdouble     // in, none, casted
	var carg6 C.gdouble     // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gdouble(minimum)
	carg5 = C.gdouble(maximum)
	carg6 = C.gdouble(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_double(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecEnum wraps g_param_spec_enum
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_enum.html
//
func ParamSpecEnum(name string, nick string, blurb string, enumType Type, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.gint        // in, none, casted
	var carg6 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(enumType)
	carg5 = C.gint(defaultValue)
	carg6 = C.GParamFlags(flags)

	cret = C.g_param_spec_enum(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(enumType)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecFlags wraps g_param_spec_flags
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_flags.html
//
func ParamSpecFlags(name string, nick string, blurb string, flagsType Type, defaultValue uint, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.guint       // in, none, casted
	var carg6 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(flagsType)
	carg5 = C.guint(defaultValue)
	carg6 = C.GParamFlags(flags)

	cret = C.g_param_spec_flags(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(flagsType)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecFloat wraps g_param_spec_float
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_float.html
//
func ParamSpecFloat(name string, nick string, blurb string, minimum float32, maximum float32, defaultValue float32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gfloat      // in, none, casted
	var carg5 C.gfloat      // in, none, casted
	var carg6 C.gfloat      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gfloat(minimum)
	carg5 = C.gfloat(maximum)
	carg6 = C.gfloat(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_float(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecGType wraps g_param_spec_gtype
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_gtype.html
//
func ParamSpecGType(name string, nick string, blurb string, isAType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(isAType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_gtype(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(isAType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecInt32 wraps g_param_spec_int
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_int.html
//
func ParamSpecInt32(name string, nick string, blurb string, minimum int32, maximum int32, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint        // in, none, casted
	var carg5 C.gint        // in, none, casted
	var carg6 C.gint        // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint(minimum)
	carg5 = C.gint(maximum)
	carg6 = C.gint(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_int(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecInt64 wraps g_param_spec_int64
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_int64.html
//
func ParamSpecInt64(name string, nick string, blurb string, minimum int64, maximum int64, defaultValue int64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gint64      // in, none, casted
	var carg5 C.gint64      // in, none, casted
	var carg6 C.gint64      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gint64(minimum)
	carg5 = C.gint64(maximum)
	carg6 = C.gint64(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_int64(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecLong wraps g_param_spec_long
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_long.html
//
func ParamSpecLong(name string, nick string, blurb string, minimum int32, maximum int32, defaultValue int32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.glong       // in, none, casted
	var carg5 C.glong       // in, none, casted
	var carg6 C.glong       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.glong(minimum)
	carg5 = C.glong(maximum)
	carg6 = C.glong(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_long(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecObject wraps g_param_spec_object
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_object.html
//
func ParamSpecObject(name string, nick string, blurb string, objectType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(objectType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_object(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(objectType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecParam wraps g_param_spec_param
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_param.html
//
func ParamSpecParam(name string, nick string, blurb string, paramType Type, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GType       // in, none, casted, alias
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GType(paramType)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_param(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(paramType)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecPointer wraps g_param_spec_pointer
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_pointer.html
//
func ParamSpecPointer(name string, nick string, blurb string, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.GParamFlags(flags)

	cret = C.g_param_spec_pointer(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecString wraps g_param_spec_string
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_string.html
//
func ParamSpecString(name string, nick string, blurb string, defaultValue string, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 *C.gchar      // in, none, string, nullable-string
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if defaultValue != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(defaultValue)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_string(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUchar wraps g_param_spec_uchar
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_uchar.html
//
func ParamSpecUchar(name string, nick string, blurb string, minimum uint8, maximum uint8, defaultValue uint8, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint8      // in, none, casted
	var carg5 C.guint8      // in, none, casted
	var carg6 C.guint8      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint8(minimum)
	carg5 = C.guint8(maximum)
	carg6 = C.guint8(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uchar(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUint wraps g_param_spec_uint
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_uint.html
//
func ParamSpecUint(name string, nick string, blurb string, minimum uint, maximum uint, defaultValue uint, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint       // in, none, casted
	var carg5 C.guint       // in, none, casted
	var carg6 C.guint       // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint(minimum)
	carg5 = C.guint(maximum)
	carg6 = C.guint(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uint(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUint64 wraps g_param_spec_uint64
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_uint64.html
//
func ParamSpecUint64(name string, nick string, blurb string, minimum uint64, maximum uint64, defaultValue uint64, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.guint64     // in, none, casted
	var carg5 C.guint64     // in, none, casted
	var carg6 C.guint64     // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.guint64(minimum)
	carg5 = C.guint64(maximum)
	carg6 = C.guint64(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_uint64(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUlong wraps g_param_spec_ulong
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_ulong.html
//
func ParamSpecUlong(name string, nick string, blurb string, minimum uint32, maximum uint32, defaultValue uint32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gulong      // in, none, casted
	var carg5 C.gulong      // in, none, casted
	var carg6 C.gulong      // in, none, casted
	var carg7 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gulong(minimum)
	carg5 = C.gulong(maximum)
	carg6 = C.gulong(defaultValue)
	carg7 = C.GParamFlags(flags)

	cret = C.g_param_spec_ulong(carg1, carg2, carg3, carg4, carg5, carg6, carg7)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(minimum)
	runtime.KeepAlive(maximum)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamSpecUnichar wraps g_param_spec_unichar
// 
// see also https://docs.gtk.org/gobject/func.g_param_spec_unichar.html
//
func ParamSpecUnichar(name string, nick string, blurb string, defaultValue uint32, flags ParamFlags) *ParamSpec {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string, nullable-string
	var carg3 *C.gchar      // in, none, string, nullable-string
	var carg4 C.gunichar    // in, none, casted
	var carg5 C.GParamFlags // in, none, casted
	var cret  *C.GParamSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	if nick != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if blurb != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(blurb)))
		defer C.free(unsafe.Pointer(carg3))
	}
	carg4 = C.gunichar(defaultValue)
	carg5 = C.GParamFlags(flags)

	cret = C.g_param_spec_unichar(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(blurb)
	runtime.KeepAlive(defaultValue)
	runtime.KeepAlive(flags)

	var goret *ParamSpec

	goret = UnsafeParamSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// ParamValueConvert wraps g_param_value_convert
// 
// see also https://docs.gtk.org/gobject/func.g_param_value_convert.html
//
func ParamValueConvert(pspec *ParamSpec, srcValue *Value, destValue *Value, strictValidation bool) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var carg3 *C.GValue     // in, none, converted
	var carg4 C.gboolean    // in
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(srcValue))
	carg3 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(destValue))
	if strictValidation {
		carg4 = C.TRUE
	}

	cret = C.g_param_value_convert(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destValue)
	runtime.KeepAlive(strictValidation)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueDefaults wraps g_param_value_defaults
// 
// see also https://docs.gtk.org/gobject/func.g_param_value_defaults.html
//
func ParamValueDefaults(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_defaults(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueIsValid wraps g_param_value_is_valid
// 
// see also https://docs.gtk.org/gobject/func.g_param_value_is_valid.html
//
func ParamValueIsValid(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_is_valid(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValueSetDefault wraps g_param_value_set_default
// 
// see also https://docs.gtk.org/gobject/func.g_param_value_set_default.html
//
func ParamValueSetDefault(pspec *ParamSpec, value *Value) {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	C.g_param_value_set_default(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)
}

// ParamValueValidate wraps g_param_value_validate
// 
// see also https://docs.gtk.org/gobject/func.g_param_value_validate.html
//
func ParamValueValidate(pspec *ParamSpec, value *Value) bool {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var cret  C.gboolean    // return

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value))

	cret = C.g_param_value_validate(carg1, carg2)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ParamValuesCmp wraps g_param_values_cmp
// 
// see also https://docs.gtk.org/gobject/func.g_param_values_cmp.html
//
func ParamValuesCmp(pspec *ParamSpec, value1 *Value, value2 *Value) int32 {
	var carg1 *C.GParamSpec // in, none, converted
	var carg2 *C.GValue     // in, none, converted
	var carg3 *C.GValue     // in, none, converted
	var cret  C.gint        // return, none, casted

	carg1 = (*C.GParamSpec)(UnsafeParamSpecToGlibNone(pspec))
	carg2 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value1))
	carg3 = (*C.GValue)(UnsafeValueToGlibUseAnyInstead(value2))

	cret = C.g_param_values_cmp(carg1, carg2, carg3)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var goret int32

	goret = int32(cret)

	return goret
}

// PointerTypeRegisterStatic wraps g_pointer_type_register_static
// 
// see also https://docs.gtk.org/gobject/func.g_pointer_type_register_static.html
//
func PointerTypeRegisterStatic(name string) Type {
	var carg1 *C.gchar // in, none, string
	var cret  C.GType  // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pointer_type_register_static(carg1)
	runtime.KeepAlive(name)

	var goret Type

	goret = Type(cret)

	return goret
}

// SignalIsValidName wraps g_signal_is_valid_name
// 
// see also https://docs.gtk.org/gobject/func.g_signal_is_valid_name.html
//
func SignalIsValidName(name string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_signal_is_valid_name(carg1)
	runtime.KeepAlive(name)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SignalListIDs wraps g_signal_list_ids
// 
// see also https://docs.gtk.org/gobject/func.g_signal_list_ids.html
//
func SignalListIDs(itype Type) (uint, []uint) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.guint // return, transfer: full, C Pointers: 1, Name: array[guint], scope: , array (inner guint (*typesystem.CastablePrimitive))

	carg1 = C.GType(itype)

	cret = C.g_signal_list_ids(carg1, &carg2)
	runtime.KeepAlive(itype)

	var nIds  uint
	var goret []uint

	nIds = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint (guint*) because of unknown reason")

	return nIds, goret
}

// SignalLookup wraps g_signal_lookup
// 
// see also https://docs.gtk.org/gobject/func.g_signal_lookup.html
//
func SignalLookup(name string, itype Type) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 C.GType  // in, none, casted, alias
	var cret  C.guint  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(itype)

	cret = C.g_signal_lookup(carg1, carg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(itype)

	var goret uint

	goret = uint(cret)

	return goret
}

// SignalName wraps g_signal_name
// 
// see also https://docs.gtk.org/gobject/func.g_signal_name.html
//
func SignalName(signalId uint) string {
	var carg1 C.guint  // in, none, casted
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.guint(signalId)

	cret = C.g_signal_name(carg1)
	runtime.KeepAlive(signalId)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// SignalParseName wraps g_signal_parse_name
// 
// see also https://docs.gtk.org/gobject/func.g_signal_parse_name.html
//
func SignalParseName(detailedSignal string, itype Type, forceDetailQuark bool) (uint, glib.Quark, bool) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.GType    // in, none, casted, alias
	var carg5 C.gboolean // in
	var carg3 C.guint    // out, full, casted
	var carg4 C.GQuark   // out, full, casted, alias
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(detailedSignal)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GType(itype)
	if forceDetailQuark {
		carg5 = C.TRUE
	}

	cret = C.g_signal_parse_name(carg1, carg2, &carg3, &carg4, carg5)
	runtime.KeepAlive(detailedSignal)
	runtime.KeepAlive(itype)
	runtime.KeepAlive(forceDetailQuark)

	var signalIdP uint
	var detailP   glib.Quark
	var goret     bool

	signalIdP = uint(carg3)
	detailP = glib.Quark(carg4)
	if cret != 0 {
		goret = true
	}

	return signalIdP, detailP, goret
}

// SignalRemoveEmissionHook wraps g_signal_remove_emission_hook
// 
// see also https://docs.gtk.org/gobject/func.g_signal_remove_emission_hook.html
//
func SignalRemoveEmissionHook(signalId uint, hookId uint32) {
	var carg1 C.guint  // in, none, casted
	var carg2 C.gulong // in, none, casted

	carg1 = C.guint(signalId)
	carg2 = C.gulong(hookId)

	C.g_signal_remove_emission_hook(carg1, carg2)
	runtime.KeepAlive(signalId)
	runtime.KeepAlive(hookId)
}

// TypeAddClassPrivate wraps g_type_add_class_private
// 
// see also https://docs.gtk.org/gobject/func.g_type_add_class_private.html
//
func TypeAddClassPrivate(classType Type, privateSize uint) {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.gsize // in, none, casted

	carg1 = C.GType(classType)
	carg2 = C.gsize(privateSize)

	C.g_type_add_class_private(carg1, carg2)
	runtime.KeepAlive(classType)
	runtime.KeepAlive(privateSize)
}

// TypeAddInstancePrivate wraps g_type_add_instance_private
// 
// see also https://docs.gtk.org/gobject/func.g_type_add_instance_private.html
func TypeAddInstancePrivate(classType Type, privateSize uint) int32 {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.gsize // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.GType(classType)
	carg2 = C.gsize(privateSize)

	cret = C.g_type_add_instance_private(carg1, carg2)
	runtime.KeepAlive(classType)
	runtime.KeepAlive(privateSize)

	var goret int32

	goret = int32(cret)

	return goret
}

// TypeAddInterfaceStatic wraps g_type_add_interface_static
// 
// see also https://docs.gtk.org/gobject/func.g_type_add_interface_static.html
//
func TypeAddInterfaceStatic(instanceType Type, interfaceType Type, info *InterfaceInfo) {
	var carg1 C.GType           // in, none, casted, alias
	var carg2 C.GType           // in, none, casted, alias
	var carg3 *C.GInterfaceInfo // in, none, converted

	carg1 = C.GType(instanceType)
	carg2 = C.GType(interfaceType)
	carg3 = (*C.GInterfaceInfo)(UnsafeInterfaceInfoToGlibNone(info))

	C.g_type_add_interface_static(carg1, carg2, carg3)
	runtime.KeepAlive(instanceType)
	runtime.KeepAlive(interfaceType)
	runtime.KeepAlive(info)
}

// TypeCheckInstance wraps g_type_check_instance
// 
// see also https://docs.gtk.org/gobject/func.g_type_check_instance.html
//
func TypeCheckInstance(instance *TypeInstance) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	cret = C.g_type_check_instance(carg1)
	runtime.KeepAlive(instance)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckInstanceIsA wraps g_type_check_instance_is_a
// 
// see also https://docs.gtk.org/gobject/func.g_type_check_instance_is_a.html
func TypeCheckInstanceIsA(instance *TypeInstance, ifaceType Type) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var carg2 C.GType          // in, none, casted, alias
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))
	carg2 = C.GType(ifaceType)

	cret = C.g_type_check_instance_is_a(carg1, carg2)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(ifaceType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckInstanceIsFundamentallyA wraps g_type_check_instance_is_fundamentally_a
// 
// see also https://docs.gtk.org/gobject/func.g_type_check_instance_is_fundamentally_a.html
func TypeCheckInstanceIsFundamentallyA(instance *TypeInstance, fundamentalType Type) bool {
	var carg1 *C.GTypeInstance // in, none, converted
	var carg2 C.GType          // in, none, casted, alias
	var cret  C.gboolean       // return

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))
	carg2 = C.GType(fundamentalType)

	cret = C.g_type_check_instance_is_fundamentally_a(carg1, carg2)
	runtime.KeepAlive(instance)
	runtime.KeepAlive(fundamentalType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeCheckIsValueType wraps g_type_check_is_value_type
// 
// see also https://docs.gtk.org/gobject/func.g_type_check_is_value_type.html
func TypeCheckIsValueType(typ Type) bool {
	var carg1 C.GType    // in, none, casted, alias
	var cret  C.gboolean // return

	carg1 = C.GType(typ)

	cret = C.g_type_check_is_value_type(carg1)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeChildren wraps g_type_children
// 
// see also https://docs.gtk.org/gobject/func.g_type_children.html
//
func TypeChildren(typ Type) (uint, []Type) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.GType // return, transfer: full, C Pointers: 1, Name: array[Type], scope: , array (inner GType (*typesystem.Alias))

	carg1 = C.GType(typ)

	cret = C.g_type_children(carg1, &carg2)
	runtime.KeepAlive(typ)

	var nChildren uint
	var goret     []Type

	nChildren = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []Type (GType*) because of unknown reason")

	return nChildren, goret
}

// TypeDepth wraps g_type_depth
// 
// see also https://docs.gtk.org/gobject/func.g_type_depth.html
//
func TypeDepth(typ Type) uint {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.guint // return, none, casted

	carg1 = C.GType(typ)

	cret = C.g_type_depth(carg1)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// TypeEnsure wraps g_type_ensure
// 
// see also https://docs.gtk.org/gobject/func.g_type_ensure.html
//
func TypeEnsure(typ Type) {
	var carg1 C.GType // in, none, casted, alias

	carg1 = C.GType(typ)

	C.g_type_ensure(carg1)
	runtime.KeepAlive(typ)
}

// TypeFreeInstance wraps g_type_free_instance
// 
// see also https://docs.gtk.org/gobject/func.g_type_free_instance.html
//
func TypeFreeInstance(instance *TypeInstance) {
	var carg1 *C.GTypeInstance // in, none, converted

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	C.g_type_free_instance(carg1)
	runtime.KeepAlive(instance)
}

// TypeFromName wraps g_type_from_name
// 
// see also https://docs.gtk.org/gobject/func.g_type_from_name.html
//
func TypeFromName(name string) Type {
	var carg1 *C.gchar // in, none, string
	var cret  C.GType  // return, none, casted, alias

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_type_from_name(carg1)
	runtime.KeepAlive(name)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeFundamental wraps g_type_fundamental
// 
// see also https://docs.gtk.org/gobject/func.g_type_fundamental.html
//
func TypeFundamental(typeId Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(typeId)

	cret = C.g_type_fundamental(carg1)
	runtime.KeepAlive(typeId)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeFundamentalNext wraps g_type_fundamental_next
// 
// see also https://docs.gtk.org/gobject/func.g_type_fundamental_next.html
//
func TypeFundamentalNext() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_type_fundamental_next()

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeGetInstanceCount wraps g_type_get_instance_count
// 
// see also https://docs.gtk.org/gobject/func.g_type_get_instance_count.html
//
func TypeGetInstanceCount(typ Type) int32 {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.int   // return, none, casted

	carg1 = C.GType(typ)

	cret = C.g_type_get_instance_count(carg1)
	runtime.KeepAlive(typ)

	var goret int32

	goret = int32(cret)

	return goret
}

// TypeGetTypeRegistrationSerial wraps g_type_get_type_registration_serial
// 
// see also https://docs.gtk.org/gobject/func.g_type_get_type_registration_serial.html
//
func TypeGetTypeRegistrationSerial() uint {
	var cret C.guint // return, none, casted

	cret = C.g_type_get_type_registration_serial()

	var goret uint

	goret = uint(cret)

	return goret
}

// TypeInterfaces wraps g_type_interfaces
// 
// see also https://docs.gtk.org/gobject/func.g_type_interfaces.html
//
func TypeInterfaces(typ Type) (uint, []Type) {
	var carg1 C.GType  // in, none, casted, alias
	var carg2 C.guint  // out, full, casted
	var cret  *C.GType // return, transfer: full, C Pointers: 1, Name: array[Type], scope: , array (inner GType (*typesystem.Alias))

	carg1 = C.GType(typ)

	cret = C.g_type_interfaces(carg1, &carg2)
	runtime.KeepAlive(typ)

	var nInterfaces uint
	var goret       []Type

	nInterfaces = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []Type (GType*) because of unknown reason")

	return nInterfaces, goret
}

// TypeIsA wraps g_type_is_a
// 
// see also https://docs.gtk.org/gobject/func.g_type_is_a.html
//
func TypeIsA(typ Type, isAType Type) bool {
	var carg1 C.GType    // in, none, casted, alias
	var carg2 C.GType    // in, none, casted, alias
	var cret  C.gboolean // return

	carg1 = C.GType(typ)
	carg2 = C.GType(isAType)

	cret = C.g_type_is_a(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(isAType)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TypeName wraps g_type_name
// 
// see also https://docs.gtk.org/gobject/func.g_type_name.html
//
func TypeName(typ Type) string {
	var carg1 C.GType  // in, none, casted, alias
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.GType(typ)

	cret = C.g_type_name(carg1)
	runtime.KeepAlive(typ)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// TypeNameFromInstance wraps g_type_name_from_instance
// 
// see also https://docs.gtk.org/gobject/func.g_type_name_from_instance.html
func TypeNameFromInstance(instance *TypeInstance) string {
	var carg1 *C.GTypeInstance // in, none, converted
	var cret  *C.gchar         // return, none, string

	carg1 = (*C.GTypeInstance)(UnsafeTypeInstanceToGlibNone(instance))

	cret = C.g_type_name_from_instance(carg1)
	runtime.KeepAlive(instance)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TypeNextBase wraps g_type_next_base
// 
// see also https://docs.gtk.org/gobject/func.g_type_next_base.html
//
func TypeNextBase(leafType Type, rootType Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var carg2 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(leafType)
	carg2 = C.GType(rootType)

	cret = C.g_type_next_base(carg1, carg2)
	runtime.KeepAlive(leafType)
	runtime.KeepAlive(rootType)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeParent wraps g_type_parent
// 
// see also https://docs.gtk.org/gobject/func.g_type_parent.html
//
func TypeParent(typ Type) Type {
	var carg1 C.GType // in, none, casted, alias
	var cret  C.GType // return, none, casted, alias

	carg1 = C.GType(typ)

	cret = C.g_type_parent(carg1)
	runtime.KeepAlive(typ)

	var goret Type

	goret = Type(cret)

	return goret
}

// TypeQname wraps g_type_qname
// 
// see also https://docs.gtk.org/gobject/func.g_type_qname.html
//
func TypeQname(typ Type) glib.Quark {
	var carg1 C.GType  // in, none, casted, alias
	var cret  C.GQuark // return, none, casted, alias

	carg1 = C.GType(typ)

	cret = C.g_type_qname(carg1)
	runtime.KeepAlive(typ)

	var goret glib.Quark

	goret = glib.Quark(cret)

	return goret
}

// TypeTestFlags wraps g_type_test_flags
// 
// see also https://docs.gtk.org/gobject/func.g_type_test_flags.html
func TypeTestFlags(typ Type, flags uint) bool {
	var carg1 C.GType    // in, none, casted, alias
	var carg2 C.guint    // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.GType(typ)
	carg2 = C.guint(flags)

	cret = C.g_type_test_flags(carg1, carg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantGetGType wraps g_variant_get_gtype
// 
// see also https://docs.gtk.org/gobject/func.g_variant_get_gtype.html
func VariantGetGType() Type {
	var cret C.GType // return, none, casted, alias

	cret = C.g_variant_get_gtype()

	var goret Type

	goret = Type(cret)

	return goret
}

// BindingGroupInstance is the instance type used by all types extending GBindingGroup. It is used internally by the bindings. Users should use the interface [BindingGroup] instead.
type BindingGroupInstance struct {
	_ [0]func() // equal guard
	ObjectInstance
}

var _ BindingGroup = (*BindingGroupInstance)(nil)

// BindingGroup wraps GBindingGroup
// 
// see also https://docs.gtk.org/gobject/class.BindingGroup.html
//
type BindingGroup interface {
	Object
	upcastToGBindingGroup() *BindingGroupInstance
}

func unsafeWrapBindingGroup(base *ObjectInstance) *BindingGroupInstance {
	return &BindingGroupInstance{
		ObjectInstance: *base,
	}
}

func init() {
	RegisterObjectCasting(
		TypeBindingGroup,
		func (inst *ObjectInstance) Object {
			return unsafeWrapBindingGroup(inst)
		},
	)
}

func marshalBindingGroupInstance(p unsafe.Pointer) (any, error) {
	return ValueFromNative(p).Object(), nil
}

// UnsafeBindingGroupFromGlibNone is used to convert raw GBindingGroup pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibNone(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibNone(c).(BindingGroup)
}

// UnsafeBindingGroupFromGlibFull is used to convert raw GBindingGroup pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibFull(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibFull(c).(BindingGroup)
}

// UnsafeBindingGroupFromGlibBorrow is used to convert raw GBindingGroup pointers to go without touching any references. This is used by the bindings internally.
func UnsafeBindingGroupFromGlibBorrow(c unsafe.Pointer) BindingGroup {
	return UnsafeObjectFromGlibBorrow(c).(BindingGroup)
}

func (b *BindingGroupInstance) upcastToGBindingGroup() *BindingGroupInstance {
	return b
}

// UnsafeBindingGroupToGlibNone is used to convert the instance to it's C value GBindingGroup. This is used by the bindings internally.
func UnsafeBindingGroupToGlibNone(c BindingGroup) unsafe.Pointer {
	return UnsafeObjectToGlibNone(c)
}

// UnsafeBindingGroupToGlibFull is used to convert the instance to it's C value GBindingGroup, while removeing the finalizer. This is used by the bindings internally.
func UnsafeBindingGroupToGlibFull(c BindingGroup) unsafe.Pointer {
	return UnsafeObjectToGlibFull(c)
}

// NewBindingGroup wraps g_binding_group_new
// 
// see also https://docs.gtk.org/gobject/func.g_binding_group_new.html
//
func NewBindingGroup() BindingGroup {
	var cret *C.GBindingGroup // return, full, converted

	cret = C.g_binding_group_new()

	var goret BindingGroup

	goret = UnsafeBindingGroupFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// InitiallyUnownedInstance is the instance type used by all types extending GInitiallyUnowned. It is used internally by the bindings. Users should use the interface [InitiallyUnowned] instead.
type InitiallyUnownedInstance struct {
	_ [0]func() // equal guard
	ObjectInstance
}

var _ InitiallyUnowned = (*InitiallyUnownedInstance)(nil)

// InitiallyUnowned wraps GInitiallyUnowned
// 
// see also https://docs.gtk.org/gobject/class.InitiallyUnowned.html
//
type InitiallyUnowned interface {
	Object
	upcastToGInitiallyUnowned() *InitiallyUnownedInstance

	// chain up virtual methods:
}

func unsafeWrapInitiallyUnowned(base *ObjectInstance) *InitiallyUnownedInstance {
	return &InitiallyUnownedInstance{
		ObjectInstance: *base,
	}
}

func init() {
	RegisterObjectCasting(
		TypeInitiallyUnowned,
		func (inst *ObjectInstance) Object {
			return unsafeWrapInitiallyUnowned(inst)
		},
	)
}

func marshalInitiallyUnownedInstance(p unsafe.Pointer) (any, error) {
	return ValueFromNative(p).Object(), nil
}

// UnsafeInitiallyUnownedFromGlibNone is used to convert raw GInitiallyUnowned pointers to go while taking a reference and attaching a finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibNone(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibNone(c).(InitiallyUnowned)
}

// UnsafeInitiallyUnownedFromGlibFull is used to convert raw GInitiallyUnowned pointers to go while attaching a finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibFull(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibFull(c).(InitiallyUnowned)
}

// UnsafeInitiallyUnownedFromGlibBorrow is used to convert raw GInitiallyUnowned pointers to go without touching any references. This is used by the bindings internally.
func UnsafeInitiallyUnownedFromGlibBorrow(c unsafe.Pointer) InitiallyUnowned {
	return UnsafeObjectFromGlibBorrow(c).(InitiallyUnowned)
}

func (i *InitiallyUnownedInstance) upcastToGInitiallyUnowned() *InitiallyUnownedInstance {
	return i
}

// UnsafeInitiallyUnownedToGlibNone is used to convert the instance to it's C value GInitiallyUnowned. This is used by the bindings internally.
func UnsafeInitiallyUnownedToGlibNone(c InitiallyUnowned) unsafe.Pointer {
	return UnsafeObjectToGlibNone(c)
}

// UnsafeInitiallyUnownedToGlibFull is used to convert the instance to it's C value GInitiallyUnowned, while removeing the finalizer. This is used by the bindings internally.
func UnsafeInitiallyUnownedToGlibFull(c InitiallyUnowned) unsafe.Pointer {
	return UnsafeObjectToGlibFull(c)
}

// InitiallyUnownedOverrides is the struct used to override the default implementation of virtual methods.
// it is generic over the extending instance type.
type InitiallyUnownedOverrides[Instance InitiallyUnowned] struct {
	// ObjectOverrides allows you to override virtual methods from the parent class Object
	ObjectOverrides[Instance]

}

// UnsafeApplyInitiallyUnownedOverrides applies the overrides to init the gclass by setting the trampoline functions.
// This is used by the bindings internally and only exported for visibility to other bindings code.
func UnsafeApplyInitiallyUnownedOverrides[Instance InitiallyUnowned](gclass unsafe.Pointer, overrides InitiallyUnownedOverrides[Instance]) {
	UnsafeApplyObjectOverrides(gclass, overrides.ObjectOverrides)
}

// RegisterInitiallyUnownedSubClass is used to register a go subclass of GInitiallyUnowned. For this to work safely please implement the
// virtual methods required by the implementation.
func RegisterInitiallyUnownedSubClass[InstanceT InitiallyUnowned](
		name string,
		classInit func(class *InitiallyUnownedClass),
		constructor func() InstanceT,
		overrides InitiallyUnownedOverrides[InstanceT],
		signals map[string]SignalDefinition,
		interfaceInits ...SubClassInterfaceInit[InstanceT],
) Type {
	return UnsafeRegisterSubClass(
		name,
		classInit,
		constructor,
		overrides,
		signals,
		TypeInitiallyUnowned,
		UnsafeInitiallyUnownedClassFromGlibBorrow,
		UnsafeApplyInitiallyUnownedOverrides,
		func (obj *ObjectInstance) Object {
			return unsafeWrapInitiallyUnowned(obj)
		},
		interfaceInits...,
	)
}

// CClosure wraps GCClosure
// 
// see also https://docs.gtk.org/gobject/struct.CClosure.html
//
type CClosure struct {
	*cClosure
}

// cClosure is the struct that's finalized
type cClosure struct {
	native *C.GCClosure
}

// UnsafeCClosureToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *CClosure) instance() *C.GCClosure {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCClosureFromGlibBorrow is used to convert raw C.GCClosure pointers to go. This is used by the bindings internally.
func UnsafeCClosureFromGlibBorrow(p unsafe.Pointer) *CClosure {
	if p == nil {
		return nil
	}
	return &CClosure{&cClosure{(*C.GCClosure)(p)}}
}

// UnsafeCClosureFromGlibNone is used to convert raw C.GCClosure pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeCClosureFromGlibNone(p unsafe.Pointer) *CClosure {
	wrapped := UnsafeCClosureFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to CClosure because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeCClosureFromGlibFull is used to convert raw C.GCClosure pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeCClosureFromGlibFull(p unsafe.Pointer) *CClosure {
	wrapped := UnsafeCClosureFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.cClosure,
		func (intern *cClosure) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeCClosureFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [CClosure] is expected to work anymore.
func UnsafeCClosureFree(c *CClosure) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeCClosureToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCClosureToGlibNone(c *CClosure) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeCClosureToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeCClosureToGlibFull(c *CClosure) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.cClosure, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // CClosure is invalid from here on
	return _p
}

// ClosureNotifyData wraps GClosureNotifyData
// 
// see also https://docs.gtk.org/gobject/struct.ClosureNotifyData.html
type ClosureNotifyData struct {
	*closureNotifyData
}

// closureNotifyData is the struct that's finalized
type closureNotifyData struct {
	native *C.GClosureNotifyData
}

// UnsafeClosureNotifyDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *ClosureNotifyData) instance() *C.GClosureNotifyData {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeClosureNotifyDataFromGlibBorrow is used to convert raw C.GClosureNotifyData pointers to go. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibBorrow(p unsafe.Pointer) *ClosureNotifyData {
	if p == nil {
		return nil
	}
	return &ClosureNotifyData{&closureNotifyData{(*C.GClosureNotifyData)(p)}}
}

// UnsafeClosureNotifyDataFromGlibNone is used to convert raw C.GClosureNotifyData pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibNone(p unsafe.Pointer) *ClosureNotifyData {
	wrapped := UnsafeClosureNotifyDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ClosureNotifyData because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeClosureNotifyDataFromGlibFull is used to convert raw C.GClosureNotifyData pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeClosureNotifyDataFromGlibFull(p unsafe.Pointer) *ClosureNotifyData {
	wrapped := UnsafeClosureNotifyDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.closureNotifyData,
		func (intern *closureNotifyData) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeClosureNotifyDataFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ClosureNotifyData] is expected to work anymore.
func UnsafeClosureNotifyDataFree(c *ClosureNotifyData) {
	C.free(unsafe.Pointer(c.native))
}

// UnsafeClosureNotifyDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeClosureNotifyDataToGlibNone(c *ClosureNotifyData) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeClosureNotifyDataToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeClosureNotifyDataToGlibFull(c *ClosureNotifyData) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.closureNotifyData, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // ClosureNotifyData is invalid from here on
	return _p
}

// EnumClass wraps GEnumClass
// 
// see also https://docs.gtk.org/gobject/struct.EnumClass.html
//
type EnumClass struct {
	*enumClass
}

// enumClass is the struct that's finalized
type enumClass struct {
	native *C.GEnumClass
}

// UnsafeEnumClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EnumClass) instance() *C.GEnumClass {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEnumClassFromGlibBorrow is used to convert raw C.GEnumClass pointers to go. This is used by the bindings internally.
func UnsafeEnumClassFromGlibBorrow(p unsafe.Pointer) *EnumClass {
	if p == nil {
		return nil
	}
	return &EnumClass{&enumClass{(*C.GEnumClass)(p)}}
}

// UnsafeEnumClassFromGlibNone is used to convert raw C.GEnumClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeEnumClassFromGlibNone(p unsafe.Pointer) *EnumClass {
	wrapped := UnsafeEnumClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to EnumClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeEnumClassFromGlibFull is used to convert raw C.GEnumClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeEnumClassFromGlibFull(p unsafe.Pointer) *EnumClass {
	wrapped := UnsafeEnumClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.enumClass,
		func (intern *enumClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeEnumClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EnumClass] is expected to work anymore.
func UnsafeEnumClassFree(e *EnumClass) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEnumClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEnumClassToGlibNone(e *EnumClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// UnsafeEnumClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeEnumClassToGlibFull(e *EnumClass) unsafe.Pointer {
	if e == nil {
		return nil
	}
	runtime.SetFinalizer(e.enumClass, nil)
	_p := unsafe.Pointer(e.native)
	e.native = nil // EnumClass is invalid from here on
	return _p
}

// EnumValue wraps GEnumValue
// 
// see also https://docs.gtk.org/gobject/struct.EnumValue.html
//
type EnumValue struct {
	*enumValue
}

// enumValue is the struct that's finalized
type enumValue struct {
	native *C.GEnumValue
}

// UnsafeEnumValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (e *EnumValue) instance() *C.GEnumValue {
	if e == nil {
		return nil
	}
	return e.native
}

// UnsafeEnumValueFromGlibBorrow is used to convert raw C.GEnumValue pointers to go. This is used by the bindings internally.
func UnsafeEnumValueFromGlibBorrow(p unsafe.Pointer) *EnumValue {
	if p == nil {
		return nil
	}
	return &EnumValue{&enumValue{(*C.GEnumValue)(p)}}
}

// UnsafeEnumValueFromGlibNone is used to convert raw C.GEnumValue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeEnumValueFromGlibNone(p unsafe.Pointer) *EnumValue {
	wrapped := UnsafeEnumValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to EnumValue because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeEnumValueFromGlibFull is used to convert raw C.GEnumValue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeEnumValueFromGlibFull(p unsafe.Pointer) *EnumValue {
	wrapped := UnsafeEnumValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.enumValue,
		func (intern *enumValue) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeEnumValueFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [EnumValue] is expected to work anymore.
func UnsafeEnumValueFree(e *EnumValue) {
	C.free(unsafe.Pointer(e.native))
}

// UnsafeEnumValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeEnumValueToGlibNone(e *EnumValue) unsafe.Pointer {
	if e == nil {
		return nil
	}
	return unsafe.Pointer(e.native)
}

// UnsafeEnumValueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeEnumValueToGlibFull(e *EnumValue) unsafe.Pointer {
	if e == nil {
		return nil
	}
	runtime.SetFinalizer(e.enumValue, nil)
	_p := unsafe.Pointer(e.native)
	e.native = nil // EnumValue is invalid from here on
	return _p
}

// FlagsClass wraps GFlagsClass
// 
// see also https://docs.gtk.org/gobject/struct.FlagsClass.html
//
type FlagsClass struct {
	*flagsClass
}

// flagsClass is the struct that's finalized
type flagsClass struct {
	native *C.GFlagsClass
}

// UnsafeFlagsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FlagsClass) instance() *C.GFlagsClass {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFlagsClassFromGlibBorrow is used to convert raw C.GFlagsClass pointers to go. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibBorrow(p unsafe.Pointer) *FlagsClass {
	if p == nil {
		return nil
	}
	return &FlagsClass{&flagsClass{(*C.GFlagsClass)(p)}}
}

// UnsafeFlagsClassFromGlibNone is used to convert raw C.GFlagsClass pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibNone(p unsafe.Pointer) *FlagsClass {
	wrapped := UnsafeFlagsClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FlagsClass because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFlagsClassFromGlibFull is used to convert raw C.GFlagsClass pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFlagsClassFromGlibFull(p unsafe.Pointer) *FlagsClass {
	wrapped := UnsafeFlagsClassFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.flagsClass,
		func (intern *flagsClass) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFlagsClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FlagsClass] is expected to work anymore.
func UnsafeFlagsClassFree(f *FlagsClass) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFlagsClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFlagsClassToGlibNone(f *FlagsClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFlagsClassToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFlagsClassToGlibFull(f *FlagsClass) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.flagsClass, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FlagsClass is invalid from here on
	return _p
}

// FlagsValue wraps GFlagsValue
// 
// see also https://docs.gtk.org/gobject/struct.FlagsValue.html
//
type FlagsValue struct {
	*flagsValue
}

// flagsValue is the struct that's finalized
type flagsValue struct {
	native *C.GFlagsValue
}

// UnsafeFlagsValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (f *FlagsValue) instance() *C.GFlagsValue {
	if f == nil {
		return nil
	}
	return f.native
}

// UnsafeFlagsValueFromGlibBorrow is used to convert raw C.GFlagsValue pointers to go. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibBorrow(p unsafe.Pointer) *FlagsValue {
	if p == nil {
		return nil
	}
	return &FlagsValue{&flagsValue{(*C.GFlagsValue)(p)}}
}

// UnsafeFlagsValueFromGlibNone is used to convert raw C.GFlagsValue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibNone(p unsafe.Pointer) *FlagsValue {
	wrapped := UnsafeFlagsValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to FlagsValue because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeFlagsValueFromGlibFull is used to convert raw C.GFlagsValue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeFlagsValueFromGlibFull(p unsafe.Pointer) *FlagsValue {
	wrapped := UnsafeFlagsValueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.flagsValue,
		func (intern *flagsValue) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeFlagsValueFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [FlagsValue] is expected to work anymore.
func UnsafeFlagsValueFree(f *FlagsValue) {
	C.free(unsafe.Pointer(f.native))
}

// UnsafeFlagsValueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeFlagsValueToGlibNone(f *FlagsValue) unsafe.Pointer {
	if f == nil {
		return nil
	}
	return unsafe.Pointer(f.native)
}

// UnsafeFlagsValueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeFlagsValueToGlibFull(f *FlagsValue) unsafe.Pointer {
	if f == nil {
		return nil
	}
	runtime.SetFinalizer(f.flagsValue, nil)
	_p := unsafe.Pointer(f.native)
	f.native = nil // FlagsValue is invalid from here on
	return _p
}

// InitiallyUnownedClass wraps GInitiallyUnownedClass
// 
// see also https://docs.gtk.org/gobject/struct.InitiallyUnownedClass.html
//
// 
// InitiallyUnownedClass is the type struct for [InitiallyUnowned]
type InitiallyUnownedClass struct {
	*initiallyUnownedClass
}

// initiallyUnownedClass is the struct that's finalized
type initiallyUnownedClass struct {
	native *C.GInitiallyUnownedClass
}

// UnsafeInitiallyUnownedClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InitiallyUnownedClass) instance() *C.GInitiallyUnownedClass {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInitiallyUnownedClassFromGlibBorrow is used to convert raw C.GInitiallyUnownedClass pointers to go. This is used by the bindings internally.
func UnsafeInitiallyUnownedClassFromGlibBorrow(p unsafe.Pointer) *InitiallyUnownedClass {
	if p == nil {
		return nil
	}
	return &InitiallyUnownedClass{&initiallyUnownedClass{(*C.GInitiallyUnownedClass)(p)}}
}

// UnsafeInitiallyUnownedClassFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InitiallyUnownedClass] is expected to work anymore.
func UnsafeInitiallyUnownedClassFree(i *InitiallyUnownedClass) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInitiallyUnownedClassToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInitiallyUnownedClassToGlibNone(i *InitiallyUnownedClass) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// ParentClass returns the type struct of the parent class of this type struct.
// This essentially casts the underlying c pointer.
func (i *InitiallyUnownedClass) ParentClass() *ObjectClass {
	parent := UnsafeObjectClassFromGlibBorrow(UnsafeInitiallyUnownedClassToGlibNone(i))
	// attach a cleanup to keep the instance alive as long as the parent is referenced
	runtime.AddCleanup(parent, func(_ *InitiallyUnownedClass) {}, i)
	return parent
}

// InterfaceInfo wraps GInterfaceInfo
// 
// see also https://docs.gtk.org/gobject/struct.InterfaceInfo.html
//
type InterfaceInfo struct {
	*interfaceInfo
}

// interfaceInfo is the struct that's finalized
type interfaceInfo struct {
	native *C.GInterfaceInfo
}

// UnsafeInterfaceInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *InterfaceInfo) instance() *C.GInterfaceInfo {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeInterfaceInfoFromGlibBorrow is used to convert raw C.GInterfaceInfo pointers to go. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibBorrow(p unsafe.Pointer) *InterfaceInfo {
	if p == nil {
		return nil
	}
	return &InterfaceInfo{&interfaceInfo{(*C.GInterfaceInfo)(p)}}
}

// UnsafeInterfaceInfoFromGlibNone is used to convert raw C.GInterfaceInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibNone(p unsafe.Pointer) *InterfaceInfo {
	wrapped := UnsafeInterfaceInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to InterfaceInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeInterfaceInfoFromGlibFull is used to convert raw C.GInterfaceInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeInterfaceInfoFromGlibFull(p unsafe.Pointer) *InterfaceInfo {
	wrapped := UnsafeInterfaceInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.interfaceInfo,
		func (intern *interfaceInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeInterfaceInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [InterfaceInfo] is expected to work anymore.
func UnsafeInterfaceInfoFree(i *InterfaceInfo) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeInterfaceInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeInterfaceInfoToGlibNone(i *InterfaceInfo) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeInterfaceInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeInterfaceInfoToGlibFull(i *InterfaceInfo) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.interfaceInfo, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // InterfaceInfo is invalid from here on
	return _p
}

// ObjectConstructParam wraps GObjectConstructParam
// 
// see also https://docs.gtk.org/gobject/struct.ObjectConstructParam.html
//
type ObjectConstructParam struct {
	*objectConstructParam
}

// objectConstructParam is the struct that's finalized
type objectConstructParam struct {
	native *C.GObjectConstructParam
}

// UnsafeObjectConstructParamToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *ObjectConstructParam) instance() *C.GObjectConstructParam {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeObjectConstructParamFromGlibBorrow is used to convert raw C.GObjectConstructParam pointers to go. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibBorrow(p unsafe.Pointer) *ObjectConstructParam {
	if p == nil {
		return nil
	}
	return &ObjectConstructParam{&objectConstructParam{(*C.GObjectConstructParam)(p)}}
}

// UnsafeObjectConstructParamFromGlibNone is used to convert raw C.GObjectConstructParam pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibNone(p unsafe.Pointer) *ObjectConstructParam {
	wrapped := UnsafeObjectConstructParamFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ObjectConstructParam because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeObjectConstructParamFromGlibFull is used to convert raw C.GObjectConstructParam pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeObjectConstructParamFromGlibFull(p unsafe.Pointer) *ObjectConstructParam {
	wrapped := UnsafeObjectConstructParamFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.objectConstructParam,
		func (intern *objectConstructParam) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeObjectConstructParamFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ObjectConstructParam] is expected to work anymore.
func UnsafeObjectConstructParamFree(o *ObjectConstructParam) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeObjectConstructParamToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeObjectConstructParamToGlibNone(o *ObjectConstructParam) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeObjectConstructParamToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeObjectConstructParamToGlibFull(o *ObjectConstructParam) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.objectConstructParam, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // ObjectConstructParam is invalid from here on
	return _p
}

// SignalInvocationHint wraps GSignalInvocationHint
// 
// see also https://docs.gtk.org/gobject/struct.SignalInvocationHint.html
//
type SignalInvocationHint struct {
	*signalInvocationHint
}

// signalInvocationHint is the struct that's finalized
type signalInvocationHint struct {
	native *C.GSignalInvocationHint
}

// UnsafeSignalInvocationHintToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SignalInvocationHint) instance() *C.GSignalInvocationHint {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSignalInvocationHintFromGlibBorrow is used to convert raw C.GSignalInvocationHint pointers to go. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibBorrow(p unsafe.Pointer) *SignalInvocationHint {
	if p == nil {
		return nil
	}
	return &SignalInvocationHint{&signalInvocationHint{(*C.GSignalInvocationHint)(p)}}
}

// UnsafeSignalInvocationHintFromGlibNone is used to convert raw C.GSignalInvocationHint pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibNone(p unsafe.Pointer) *SignalInvocationHint {
	wrapped := UnsafeSignalInvocationHintFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SignalInvocationHint because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSignalInvocationHintFromGlibFull is used to convert raw C.GSignalInvocationHint pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSignalInvocationHintFromGlibFull(p unsafe.Pointer) *SignalInvocationHint {
	wrapped := UnsafeSignalInvocationHintFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.signalInvocationHint,
		func (intern *signalInvocationHint) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSignalInvocationHintFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SignalInvocationHint] is expected to work anymore.
func UnsafeSignalInvocationHintFree(s *SignalInvocationHint) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSignalInvocationHintToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSignalInvocationHintToGlibNone(s *SignalInvocationHint) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSignalInvocationHintToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSignalInvocationHintToGlibFull(s *SignalInvocationHint) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.signalInvocationHint, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SignalInvocationHint is invalid from here on
	return _p
}

// TypeFundamentalInfo wraps GTypeFundamentalInfo
// 
// see also https://docs.gtk.org/gobject/struct.TypeFundamentalInfo.html
//
type TypeFundamentalInfo struct {
	*typeFundamentalInfo
}

// typeFundamentalInfo is the struct that's finalized
type typeFundamentalInfo struct {
	native *C.GTypeFundamentalInfo
}

// UnsafeTypeFundamentalInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeFundamentalInfo) instance() *C.GTypeFundamentalInfo {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeFundamentalInfoFromGlibBorrow is used to convert raw C.GTypeFundamentalInfo pointers to go. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibBorrow(p unsafe.Pointer) *TypeFundamentalInfo {
	if p == nil {
		return nil
	}
	return &TypeFundamentalInfo{&typeFundamentalInfo{(*C.GTypeFundamentalInfo)(p)}}
}

// UnsafeTypeFundamentalInfoFromGlibNone is used to convert raw C.GTypeFundamentalInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibNone(p unsafe.Pointer) *TypeFundamentalInfo {
	wrapped := UnsafeTypeFundamentalInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeFundamentalInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeFundamentalInfoFromGlibFull is used to convert raw C.GTypeFundamentalInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoFromGlibFull(p unsafe.Pointer) *TypeFundamentalInfo {
	wrapped := UnsafeTypeFundamentalInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeFundamentalInfo,
		func (intern *typeFundamentalInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeFundamentalInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeFundamentalInfo] is expected to work anymore.
func UnsafeTypeFundamentalInfoFree(t *TypeFundamentalInfo) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeFundamentalInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeFundamentalInfoToGlibNone(t *TypeFundamentalInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeFundamentalInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeFundamentalInfoToGlibFull(t *TypeFundamentalInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeFundamentalInfo, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeFundamentalInfo is invalid from here on
	return _p
}

// TypeInfo wraps GTypeInfo
// 
// see also https://docs.gtk.org/gobject/struct.TypeInfo.html
//
type TypeInfo struct {
	*typeInfo
}

// typeInfo is the struct that's finalized
type typeInfo struct {
	native *C.GTypeInfo
}

// UnsafeTypeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeInfo) instance() *C.GTypeInfo {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeInfoFromGlibBorrow is used to convert raw C.GTypeInfo pointers to go. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibBorrow(p unsafe.Pointer) *TypeInfo {
	if p == nil {
		return nil
	}
	return &TypeInfo{&typeInfo{(*C.GTypeInfo)(p)}}
}

// UnsafeTypeInfoFromGlibNone is used to convert raw C.GTypeInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibNone(p unsafe.Pointer) *TypeInfo {
	wrapped := UnsafeTypeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeInfo because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeInfoFromGlibFull is used to convert raw C.GTypeInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeInfoFromGlibFull(p unsafe.Pointer) *TypeInfo {
	wrapped := UnsafeTypeInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeInfo,
		func (intern *typeInfo) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeInfoFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeInfo] is expected to work anymore.
func UnsafeTypeInfoFree(t *TypeInfo) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeInfoToGlibNone(t *TypeInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeInfoToGlibFull(t *TypeInfo) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeInfo, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeInfo is invalid from here on
	return _p
}

// TypeInstance wraps GTypeInstance
// 
// see also https://docs.gtk.org/gobject/struct.TypeInstance.html
//
type TypeInstance struct {
	*typeInstance
}

// typeInstance is the struct that's finalized
type typeInstance struct {
	native *C.GTypeInstance
}

// UnsafeTypeInstanceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeInstance) instance() *C.GTypeInstance {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeInstanceFromGlibBorrow is used to convert raw C.GTypeInstance pointers to go. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibBorrow(p unsafe.Pointer) *TypeInstance {
	if p == nil {
		return nil
	}
	return &TypeInstance{&typeInstance{(*C.GTypeInstance)(p)}}
}

// UnsafeTypeInstanceFromGlibNone is used to convert raw C.GTypeInstance pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibNone(p unsafe.Pointer) *TypeInstance {
	wrapped := UnsafeTypeInstanceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeInstance because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeInstanceFromGlibFull is used to convert raw C.GTypeInstance pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeInstanceFromGlibFull(p unsafe.Pointer) *TypeInstance {
	wrapped := UnsafeTypeInstanceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeInstance,
		func (intern *typeInstance) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeInstanceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeInstance] is expected to work anymore.
func UnsafeTypeInstanceFree(t *TypeInstance) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeInstanceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeInstanceToGlibNone(t *TypeInstance) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeInstanceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeInstanceToGlibFull(t *TypeInstance) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeInstance, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeInstance is invalid from here on
	return _p
}

// TypeValueTable wraps GTypeValueTable
// 
// see also https://docs.gtk.org/gobject/struct.TypeValueTable.html
//
type TypeValueTable struct {
	*typeValueTable
}

// typeValueTable is the struct that's finalized
type typeValueTable struct {
	native *C.GTypeValueTable
}

// UnsafeTypeValueTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TypeValueTable) instance() *C.GTypeValueTable {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTypeValueTableFromGlibBorrow is used to convert raw C.GTypeValueTable pointers to go. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibBorrow(p unsafe.Pointer) *TypeValueTable {
	if p == nil {
		return nil
	}
	return &TypeValueTable{&typeValueTable{(*C.GTypeValueTable)(p)}}
}

// UnsafeTypeValueTableFromGlibNone is used to convert raw C.GTypeValueTable pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibNone(p unsafe.Pointer) *TypeValueTable {
	wrapped := UnsafeTypeValueTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TypeValueTable because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTypeValueTableFromGlibFull is used to convert raw C.GTypeValueTable pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTypeValueTableFromGlibFull(p unsafe.Pointer) *TypeValueTable {
	wrapped := UnsafeTypeValueTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.typeValueTable,
		func (intern *typeValueTable) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTypeValueTableFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TypeValueTable] is expected to work anymore.
func UnsafeTypeValueTableFree(t *TypeValueTable) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTypeValueTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTypeValueTableToGlibNone(t *TypeValueTable) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTypeValueTableToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTypeValueTableToGlibFull(t *TypeValueTable) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.typeValueTable, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TypeValueTable is invalid from here on
	return _p
}

// WeakRef wraps GWeakRef
// 
// see also https://docs.gtk.org/gobject/struct.WeakRef.html
//
type WeakRef struct {
	*weakRef
}

// weakRef is the struct that's finalized
type weakRef struct {
	native *C.GWeakRef
}

// UnsafeWeakRefToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (w *WeakRef) instance() *C.GWeakRef {
	if w == nil {
		return nil
	}
	return w.native
}

// UnsafeWeakRefFromGlibBorrow is used to convert raw C.GWeakRef pointers to go. This is used by the bindings internally.
func UnsafeWeakRefFromGlibBorrow(p unsafe.Pointer) *WeakRef {
	if p == nil {
		return nil
	}
	return &WeakRef{&weakRef{(*C.GWeakRef)(p)}}
}

// UnsafeWeakRefFromGlibNone is used to convert raw C.GWeakRef pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeWeakRefFromGlibNone(p unsafe.Pointer) *WeakRef {
	wrapped := UnsafeWeakRefFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to WeakRef because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeWeakRefFromGlibFull is used to convert raw C.GWeakRef pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeWeakRefFromGlibFull(p unsafe.Pointer) *WeakRef {
	wrapped := UnsafeWeakRefFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.weakRef,
		func (intern *weakRef) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeWeakRefFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [WeakRef] is expected to work anymore.
func UnsafeWeakRefFree(w *WeakRef) {
	C.free(unsafe.Pointer(w.native))
}

// UnsafeWeakRefToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeWeakRefToGlibNone(w *WeakRef) unsafe.Pointer {
	if w == nil {
		return nil
	}
	return unsafe.Pointer(w.native)
}

// UnsafeWeakRefToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeWeakRefToGlibFull(w *WeakRef) unsafe.Pointer {
	if w == nil {
		return nil
	}
	runtime.SetFinalizer(w.weakRef, nil)
	_p := unsafe.Pointer(w.native)
	w.native = nil // WeakRef is invalid from here on
	return _p
}

