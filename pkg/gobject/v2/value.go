package gobject

import (
	"log"
	"reflect"
	"runtime"
	"unsafe"
)

// #cgo pkg-config: gobject-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
//
// static gboolean _g_is_value(GValue *val) { return (G_IS_VALUE(val)); }
// static GType _g_value_type(GValue *val) { return (G_VALUE_TYPE(val)); }
import "C"

var (
	TypeValue Type = Type(C.g_value_get_type())
)

func init() {
	RegisterGValueMarshaler(TypeValue, marshalValue)
}

func marshalValue(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	if c == nil {
		return nil, nil
	}

	v := wrapValueFinalized(unsafe.Pointer(c))

	return v, nil
}

type invalidValueType struct{}

var (
	// InvalidValue is returned from Value methods, such as GoValue, to indicate
	// that the value obtained is invalid.
	InvalidValue = invalidValueType{}
)

// Value is a representation of GLib's GValue.
type Value struct {
	*value
}

type value struct {
	gvalue *C.GValue
}

func (v *Value) native() *C.GValue {
	if v == nil || v.value == nil {
		return nil
	}
	return v.value.gvalue
}

func (v *value) unset() {
	if v.isValue() {
		C.g_value_unset(v.gvalue)
	}
	runtime.KeepAlive(v)
}

func (v *value) isValue() bool {
	b := C._g_is_value(v.gvalue) != 0
	runtime.KeepAlive(v)
	return b
}

var (
	mustHeap interface{}
	never    bool
)

func wrapValueFinalized(v unsafe.Pointer) *Value {
	gvalue := ValueFromNative(v)

	//An allocated GValue is not guaranteed to hold a value that can be unset
	//We need to double check before unsetting, to prevent:
	//`g_value_unset: assertion 'G_IS_VALUE (value)' failed`
	runtime.SetFinalizer(gvalue.value, func(value *value) {
		value.unset()
	})

	return gvalue
}

// AllocateValue allocates a Value but does not initialize it. It sets a
// runtime finalizer to call g_value_unset() on the underlying GValue after
// leaving scope.
func AllocateValue() *Value {
	gvalue := new(C.GValue)
	if never {
		// Force the value to be on the Go heap, because we don't want it on the
		// stack. The compiler will likely throw it on the heap without this
		// anyway, but we'd like to be careful.
		mustHeap = gvalue
	}

	return wrapValueFinalized(unsafe.Pointer(gvalue))
}

// InitValue is a wrapper around g_value_init() and allocates and initializes a
// new Value with the Type t. A runtime finalizer is set to call g_value_unset()
// on the underlying GValue after leaving scope.  ValueInit() returns a non-nil
// error if the allocation failed.
func InitValue(t Type) *Value {
	v := AllocateValue()
	v.Init(t)
	return v
}

// ValueFromNative returns a type-asserted pointer to the Value. It does not add
// a finalizer into the Value. This function should only be used for
// autogenerated bindings.
func ValueFromNative(l unsafe.Pointer) *Value {
	return &Value{&value{(*C.GValue)(l)}}
}

// UnsafeValueToGlibNone returns the C pointer to the value. This function should only be used for
// autogenerated bindings.
func UnsafeValueToGlibNone(v *Value) unsafe.Pointer {
	return unsafe.Pointer(v.native())
}

// UnsafeValueToGlibUseAnyInstead panics. It is used to be able to generate code that uses
// GValue that should be handwritten instead and use "any" instead.
func UnsafeValueToGlibUseAnyInstead(v *Value) unsafe.Pointer {
	panic("this function must be handwritten. Please open an issue about it if you need it.")
}

// UseAnyInstead panics. It is used to be able to generate code that uses
// GValue that should be handwritten instead and use "any" instead.
func UnsafeValueFromGlibUseAnyInstead(unsafe.Pointer) *Value {
	panic("this function must be handwritten. Please open an issue about it if you need it.")
}

// UnsafeValueToGlibFull returns the C pointer to the value and clears the finalizer. This function should only be used for
// manually written bindings, because "any" is often a better fit.
func UnsafeValueToGlibFull(v *Value) unsafe.Pointer {
	ptr := UnsafeValueToGlibNone(v)

	runtime.SetFinalizer(v.gvalue, nil)

	return ptr
}

// NewValue converts a Go type to a comparable GValue. It will panic if the
// given type is unknown. Most Go primitive types and all Object types are
// supported. Additionaly the value can implement the [GoValueInitializer] interface
// to override the
func NewValue(v interface{}) *Value {
	val := AllocateValue()
	val.InitGoValue(v)
	val.SetGoValue(v)
	return val
}

// GoValueInitializer is the interface that is implemented by
// all go types that need to initialize a GValue differently than reflect can know. See any enum/flag/object
type GoValueInitializer interface {
	// GoValueType returns the GType needed to initialize the a GValue
	GoValueType() Type
	// SetGoValue sets the Go value of the GValue. The value must have been initialised
	// already
	SetGoValue(v *Value)
}

// InitGoValue sets the Go value of the GValue. The GValue MUST NOT HAVE BEEN
// INITIALIZED ALREADY!
func (v *Value) InitGoValue(goValue any) {
	if goValue == InvalidValue {
		v.Init(TypeInvalid)
		return
	}

	if typ := valueType(goValue); typ != TypeInvalid {
		v.Init(typ)

		return
	}

	log.Panicf("type %T not implemented", goValue)
}

// SetGoValue sets the Go value of the GValue. The GValue MUST HAVE BEEN
// INITIALIZED ALREADY!
func (v *Value) SetGoValue(goValue any) {
	v.AssertCanHold(goValue)

	// check for overridden init first
	if initter, ok := goValue.(GoValueInitializer); ok {
		initter.SetGoValue(v)
		return
	}

	if goValue == nil {
		v.SetPointer(nil)
		return
	}

	if setValuePrimitive(v, goValue) {
		return
	}

	if goValue == InvalidValue {
		return
	}

	// Try this since above doesn't catch constants under other types.
	rval := reflect.Indirect(reflect.ValueOf(goValue))

	var ok bool
	switch rval.Kind() {
	case reflect.Bool:
		ok = setValuePrimitive(v, rval.Bool())
	case reflect.Int8:
		ok = setValuePrimitive(v, int8(rval.Int()))
	case reflect.Int32:
		ok = setValuePrimitive(v, int32(rval.Int()))
	case reflect.Int64:
		ok = setValuePrimitive(v, int64(rval.Int()))
	case reflect.Int:
		ok = setValuePrimitive(v, int(rval.Int()))
	case reflect.Uint8:
		ok = setValuePrimitive(v, uint8(rval.Uint()))
	case reflect.Uint32:
		ok = setValuePrimitive(v, uint32(rval.Uint()))
	case reflect.Uint64:
		ok = setValuePrimitive(v, uint64(rval.Uint()))
	case reflect.Uint:
		ok = setValuePrimitive(v, uint(rval.Uint()))
	case reflect.Float32:
		ok = setValuePrimitive(v, float32(rval.Float()))
	case reflect.Float64:
		ok = setValuePrimitive(v, float64(rval.Float()))
	case reflect.String:
		ok = setValuePrimitive(v, rval.String())
	}

	if ok {
		return
	}

	log.Panicf("type %T not implemented", goValue)
}

// valueType returns the GType needed to initialize a GValue for the given value.
func valueType(v any) Type {
	if v == InvalidValue {
		return TypeInvalid
	}

	// check for overridden init first
	if initter, ok := v.(GoValueInitializer); ok {
		return initter.GoValueType()
	}

	if v == nil {
		return TypePointer
	}

	if valueTyp := valueTypeForPrimitive(v); valueTyp != TypeInvalid {
		return valueTyp
	}

	return valueTypeForPrimitiveReflect(v)
}

func valueTypeForPrimitive(v interface{}) Type {
	switch v.(type) {
	case bool:
		return TypeBoolean
	case int8:
		return TypeChar
	case int32:
		return TypeInt // C int is 32-bit
	case int64:
		return TypeInt64
	case int:
		return TypeInt // C int is 32-bit
	case uint8:
		return TypeUchar
	case uint32:
		return TypeUint
	case uint64:
		return TypeUint64
	case uint:
		return TypeUint // C uint is 32-bit
	case float32:
		return TypeFloat
	case float64:
		return TypeDouble
	case string:
		return TypeString
	default:
		return TypeInvalid
	}
}

func valueTypeForPrimitiveReflect(goValue any) Type {
	// Try this since above doesn't catch constants under other types.
	rval := reflect.Indirect(reflect.ValueOf(goValue))

	switch rval.Kind() {
	case reflect.Bool:
		return valueTypeForPrimitive(rval.Bool())
	case reflect.Int8:
		return valueTypeForPrimitive(int8(rval.Int()))
	case reflect.Int32:
		return valueTypeForPrimitive(int32(rval.Int()))
	case reflect.Int64:
		return valueTypeForPrimitive(int64(rval.Int()))
	case reflect.Int:
		return valueTypeForPrimitive(int(rval.Int()))
	case reflect.Uint8:
		return valueTypeForPrimitive(uint8(rval.Uint()))
	case reflect.Uint32:
		return valueTypeForPrimitive(uint32(rval.Uint()))
	case reflect.Uint64:
		return valueTypeForPrimitive(uint64(rval.Uint()))
	case reflect.Uint:
		return valueTypeForPrimitive(uint(rval.Uint()))
	case reflect.Float32:
		return valueTypeForPrimitive(float32(rval.Float()))
	case reflect.Float64:
		return valueTypeForPrimitive(float64(rval.Float()))
	case reflect.String:
		return valueTypeForPrimitive(rval.String())
	}

	return TypeInvalid
}

func setValuePrimitive(val *Value, v interface{}) bool {
	switch e := v.(type) {
	case bool:
		val.SetBool(e)
	case int8:
		val.SetSchar(e)
	case int32:
		val.SetInt(int(e))
	case int64:
		val.SetInt64(e)
	case int:
		val.SetInt(int(e))
	case uint8:
		val.SetUchar(e)
	case uint32:
		val.SetUint(uint(e))
	case uint64:
		val.SetUint64(e)
	case uint:
		val.SetUint(uint(e))
	case float32:
		val.SetFloat(e)
	case float64:
		val.SetDouble(e)
	case string:
		val.SetString(e)
	default:
		return false
	}
	return true
}

// Init initializes the Value to the given GType. It does nothing if the Value
// is already initialized.
func (v *Value) Init(gtype Type) {
	if !v.isValue() {
		C.g_value_init(v.native(), C.GType(gtype))
	}
	runtime.KeepAlive(v)
}

// SetBool is a wrapper around g_value_set_boolean().
func (v *Value) SetBool(val bool) {
	C.g_value_set_boolean(v.native(), gbool(val))
	runtime.KeepAlive(v)
}

// SetSChar is a wrapper around g_value_set_schar().
func (v *Value) SetSchar(val int8) {
	C.g_value_set_schar(v.native(), C.gint8(val))
	runtime.KeepAlive(v)
}

// SetInt64 is a wrapper around g_value_set_int64().
func (v *Value) SetInt64(val int64) {
	C.g_value_set_int64(v.native(), C.gint64(val))
	runtime.KeepAlive(v)
}

// SetLong is a wrapper around g_value_set_long().
func (v *Value) SetLong(long int32) {
	C.g_value_set_long(v.native(), C.glong(long))
	runtime.KeepAlive(v)
}

// SetInt is a wrapper around g_value_set_int().
func (v *Value) SetInt(val int) {
	C.g_value_set_int(v.native(), C.gint(val))
	runtime.KeepAlive(v)
}

// SetUchar is a wrapper around g_value_set_uchar().
func (v *Value) SetUchar(val uint8) {
	C.g_value_set_uchar(v.native(), C.guchar(val))
	runtime.KeepAlive(v)
}

// SetUint64 is a wrapper around g_value_set_uint64().
func (v *Value) SetUint64(val uint64) {
	C.g_value_set_uint64(v.native(), C.guint64(val))
	runtime.KeepAlive(v)
}

// SetUlong is a wrapper around g_value_set_ulong().
func (v *Value) SetUlong(ulong uint32) {
	C.g_value_set_ulong(v.native(), C.gulong(ulong))
	runtime.KeepAlive(v)
}

// SetUint is a wrapper around g_value_set_uint().
func (v *Value) SetUint(val uint) {
	C.g_value_set_uint(v.native(), C.guint(val))
	runtime.KeepAlive(v)
}

// SetFloat is a wrapper around g_value_set_float().
func (v *Value) SetFloat(val float32) {
	C.g_value_set_float(v.native(), C.gfloat(val))
	runtime.KeepAlive(v)
}

// SetDouble is a wrapper around g_value_set_double().
func (v *Value) SetDouble(val float64) {
	C.g_value_set_double(v.native(), C.gdouble(val))
	runtime.KeepAlive(v)
}

// SetString is a wrapper around g_value_set_string().
func (v *Value) SetString(val string) {
	cstr := C.CString(val)
	defer C.free(unsafe.Pointer(cstr))

	C.g_value_set_string(v.native(), (*C.gchar)(cstr))
	runtime.KeepAlive(v)
}

// SetInstance is a wrapper around g_value_set_instance().
func (v *Value) SetInstance(instance unsafe.Pointer) {
	C.g_value_set_instance(v.native(), C.gpointer(instance))
	runtime.KeepAlive(v)
}

// SetObject is a wrapper around g_value_set_object().
func (v *Value) SetObject(obj Object) {
	baseObject := obj.baseObject()
	C.g_value_set_object(v.native(), C.gpointer(baseObject.unsafe()))
	runtime.KeepAlive(v)
	runtime.KeepAlive(obj)
}

// SetPointer is a wrapper around g_value_set_pointer().
func (v *Value) SetPointer(p unsafe.Pointer) {
	C.g_value_set_pointer(v.native(), C.gpointer(p))
	runtime.KeepAlive(v)
}

// SetFlags is a wrapper around g_value_set_flags().
func (v *Value) SetFlags(f int) {
	C.g_value_set_flags(v.native(), C.guint(f))
	runtime.KeepAlive(v)
}

// SetEnum is a wrapper around g_value_set_enum().
func (v *Value) SetEnum(e int) {
	C.g_value_set_enum(v.native(), C.gint(e))
	runtime.KeepAlive(v)
}

// Pointer is a wrapper around g_value_get_pointer().
func (v *Value) Pointer() unsafe.Pointer {
	p := unsafe.Pointer(C.g_value_get_pointer(v.native()))
	runtime.KeepAlive(v)
	return p
}

// Boxed is a wrapper around g_value_get_boxed().
func (v *Value) Boxed() unsafe.Pointer {
	p := unsafe.Pointer(C.g_value_get_boxed(v.native()))
	runtime.KeepAlive(v)
	return p
}

// SetBoxed is a wrapper around g_value_set_boxed().
func (v *Value) SetBoxed(p unsafe.Pointer) {
	C.g_value_set_boxed(v.native(), C.gconstpointer(p))
	runtime.KeepAlive(v)
}

// Object is a wrapper around g_value_get_object(). The returned Object is already wrapped
// in a appropriate extending type, if it was registered before with [RegisterObjectCasting]
func (v *Value) Object() Object {
	p := unsafe.Pointer(C.g_value_get_object(v.native()))
	return UnsafeObjectFromGlibNone(unsafe.Pointer(p))
}

// Enum is a wrapper around g_value_get_enum().
func (v *Value) Enum() int {
	i := int(C.g_value_get_enum(v.native()))
	runtime.KeepAlive(v)
	return i
}

// Param is a wrapper around g_value_get_param().
func (v *Value) Param() unsafe.Pointer {
	p := unsafe.Pointer(C.g_value_get_param(v.native()))
	runtime.KeepAlive(v)
	return p
}

// Flags is a wrapper around g_value_get_flags().
func (v *Value) Flags() uint {
	u := uint(C.g_value_get_flags(v.native()))
	runtime.KeepAlive(v)
	return u
}

// String is a wrapper around g_value_get_string().  String() returns an empty string
// if g_value_get_string returned a null pointer
func (v *Value) String() string {
	c := C.g_value_get_string(v.native())
	runtime.KeepAlive(v)

	if c == nil {
		return ""
	}

	return C.GoString((*C.char)(c))
}

// GoValue converts a Value to its Go type. GoValue() returns
// InvalidValue if the conversion was unsuccessful. The returned value must be
// type asserted to the actual Go type.
func (v *Value) GoValue() interface{} {
	if !v.isValue() {
		return InvalidValue
	}

	f := marshalers.lookup(v)
	runtime.KeepAlive(v)
	if f == nil {
		return InvalidValue
	}

	// No need to add finalizer because it is already done by AllocateValue and
	// InitValue. (?)
	g, err := f(unsafe.Pointer(v.native()))
	runtime.KeepAlive(v)
	if err != nil {
		log.Printf("goglib: marshaler error for %s: %v", v.Type(), err)
		return InvalidValue
	}

	return g
}

// Type returns the Value's actual type. is a wrapper around the G_VALUE_TYPE()
// macro. It returns TYPE_INVALID if v does not hold a Type, or otherwise
// returns the Type of v.
//
// To get the fundamental type, use FundamentalType.
func (v *Value) Type() (actual Type) {
	if v == nil || !v.isValue() {
		return TypeInvalid
	}
	actual = Type(C._g_value_type(v.native()))
	runtime.KeepAlive(v)
	return
}

// CanHold returns true if the Value can hold the given go value
func (v *Value) CanHold(goValue any) bool {
	goValueType := valueType(goValue)
	valueType := v.Type()

	if goValueType == valueType {
		return true
	}

	return goValueType.IsA(valueType)
}

func (v *Value) AssertCanHold(goValue any) {
	if v.CanHold(goValue) {
		return
	}

	log.Panicf("gobject.Value type assertion failed: value is initialized for %s and not %s", v.Type(), valueType(goValue))
}
