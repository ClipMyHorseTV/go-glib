// Code generated by girgen for GLib-2. DO NOT EDIT.

package glib

import (
	"fmt"
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/core/userdata"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
// extern GLogWriterOutput _goglib_glib2_LogWriterFunc(GLogLevelFlags, const GLogField*, gsize, gpointer);
// extern gboolean _goglib_glib2_SourceFunc(gpointer);
// extern void _goglib_glib2_ChildWatchFunc(GPid, gint, gpointer);
// extern void _goglib_glib2_LogFunc(const gchar*, GLogLevelFlags, const gchar*, gpointer);
// extern void destroyUserdata(gpointer);
import "C"


// ANALYZER_ANALYZING wraps G_ANALYZER_ANALYZING
const ANALYZER_ANALYZING = 1
// ASCII_DTOSTR_BUF_SIZE wraps G_ASCII_DTOSTR_BUF_SIZE
//
// A good size for a buffer to be passed into [func@GLib.ascii_dtostr].
// It is guaranteed to be enough for all output of that function
// on systems with 64bit IEEE-compatible doubles.
// 
// The typical usage would be something like:
// ```C
// char buf[G_ASCII_DTOSTR_BUF_SIZE];
// 
// fprintf (out, "value=%s\n", g_ascii_dtostr (buf, sizeof (buf), value));
// ```
const ASCII_DTOSTR_BUF_SIZE = 39
// BIG_ENDIAN wraps G_BIG_ENDIAN
//
// Specifies one of the possible types of byte order.
// See %G_BYTE_ORDER.
const BIG_ENDIAN = 4321
// C_STD_VERSION wraps G_C_STD_VERSION
//
// The C standard version the code is compiling against, it's normally
// defined with the same value of `__STDC_VERSION__` for C standard
// compatible compilers, while it uses the lowest standard version
// in pure MSVC, given that in such compiler the definition depends on
// a compilation flag.
// 
// This is granted to be undefined when compiling with a C++ compiler.
// 
// See also: %G_C_STD_CHECK_VERSION and %G_CXX_STD_VERSION
const C_STD_VERSION = 199000
// DATALIST_FLAGS_MASK wraps G_DATALIST_FLAGS_MASK
//
// A bitmask that restricts the possible flags passed to
// g_datalist_set_flags(). Passing a flags value where
// flags &amp; ~G_DATALIST_FLAGS_MASK != 0 is an error.
const DATALIST_FLAGS_MASK = 3
// DATE_BAD_DAY wraps G_DATE_BAD_DAY
//
// Represents an invalid #GDateDay.
const DATE_BAD_DAY = 0
// DATE_BAD_JULIAN wraps G_DATE_BAD_JULIAN
//
// Represents an invalid Julian day number.
const DATE_BAD_JULIAN = 0
// DATE_BAD_YEAR wraps G_DATE_BAD_YEAR
//
// Represents an invalid year.
const DATE_BAD_YEAR = 0
// DIR_SEPARATOR wraps G_DIR_SEPARATOR
//
// The directory separator character.
// 
// This is `'/'` on UNIX machines and `'\'` under Windows.
const DIR_SEPARATOR = 47
// E wraps G_E
//
// The base of natural logarithms.
const E = 2.718282
// HAVE_GINT64 wraps G_HAVE_GINT64
const HAVE_GINT64 = 1
// HAVE_GNUC_VARARGS wraps G_HAVE_GNUC_VARARGS
const HAVE_GNUC_VARARGS = 1
// HAVE_GNUC_VISIBILITY wraps G_HAVE_GNUC_VISIBILITY
//
// Defined to 1 if gcc-style visibility handling is supported.
const HAVE_GNUC_VISIBILITY = 1
// HAVE_GROWING_STACK wraps G_HAVE_GROWING_STACK
const HAVE_GROWING_STACK = 0
// HAVE_ISO_VARARGS wraps G_HAVE_ISO_VARARGS
const HAVE_ISO_VARARGS = 1
// HOOK_FLAG_USER_SHIFT wraps G_HOOK_FLAG_USER_SHIFT
//
// The position of the first bit which is not reserved for internal
// use be the #GHook implementation, i.e.
// `1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT` is the first
// bit which can be used for application-defined flags.
const HOOK_FLAG_USER_SHIFT = 4
// IEEE754_DOUBLE_BIAS wraps G_IEEE754_DOUBLE_BIAS
//
// The bias by which exponents in double-precision floats are offset.
const IEEE754_DOUBLE_BIAS = 1023
// IEEE754_FLOAT_BIAS wraps G_IEEE754_FLOAT_BIAS
//
// The bias by which exponents in single-precision floats are offset.
const IEEE754_FLOAT_BIAS = 127
// LITTLE_ENDIAN wraps G_LITTLE_ENDIAN
//
// Specifies one of the possible types of byte order.
// See %G_BYTE_ORDER.
const LITTLE_ENDIAN = 1234
// LN10 wraps G_LN10
//
// The natural logarithm of 10.
const LN10 = 2.302585
// LN2 wraps G_LN2
//
// The natural logarithm of 2.
const LN2 = 0.693147
// LOG_2_BASE_10 wraps G_LOG_2_BASE_10
//
// Multiplying the base 2 exponent by this number yields the base 10 exponent.
const LOG_2_BASE_10 = 0.301030
// LOG_DOMAIN wraps G_LOG_DOMAIN
//
// Defines the log domain. See [Log Domains](#log-domains).
// 
// Libraries should define this so that any messages
// which they log can be differentiated from messages from other
// libraries and application code. But be careful not to define
// it in any public header files.
// 
// Log domains must be unique, and it is recommended that they are the
// application or library name, optionally followed by a hyphen and a sub-domain
// name. For example, `bloatpad` or `bloatpad-io`.
// 
// If undefined, it defaults to the default %NULL (or `""`) log domain; this is
// not advisable, as it cannot be filtered against using the `G_MESSAGES_DEBUG`
// environment variable.
// 
// For example, GTK uses this in its `Makefile.am`:
// |[
// AM_CPPFLAGS = -DG_LOG_DOMAIN=\"Gtk\"
// ]|
// 
// Applications can choose to leave it as the default %NULL (or `""`)
// domain. However, defining the domain offers the same advantages as
// above.
const LOG_DOMAIN = 0
// LOG_FATAL_MASK wraps G_LOG_FATAL_MASK
//
// GLib log levels that are considered fatal by default.
// 
// This is not used if structured logging is enabled; see
// [Using Structured Logging](logging.html#using-structured-logging).
const LOG_FATAL_MASK = 5
// LOG_LEVEL_USER_SHIFT wraps G_LOG_LEVEL_USER_SHIFT
//
// Log levels below `1&lt;&lt;G_LOG_LEVEL_USER_SHIFT` are used by GLib.
// Higher bits can be used for user-defined log levels.
const LOG_LEVEL_USER_SHIFT = 8
// MAJOR_VERSION wraps GLIB_MAJOR_VERSION
//
// The major version number of the GLib library.
// 
// Like #glib_major_version, but from the headers used at
// application compile time, rather than from the library
// linked against at application run time.
const MAJOR_VERSION = 2
// MAXINT16 wraps G_MAXINT16
const MAXINT16 = 32767
// MAXINT32 wraps G_MAXINT32
const MAXINT32 = 2147483647
// MAXINT64 wraps G_MAXINT64
const MAXINT64 = 9223372036854775807
// MAXINT8 wraps G_MAXINT8
const MAXINT8 = 127
// MAXUINT16 wraps G_MAXUINT16
const MAXUINT16 = 65535
// MAXUINT32 wraps G_MAXUINT32
const MAXUINT32 = 4294967295
// MAXUINT64 wraps G_MAXUINT64
const MAXUINT64 = 18446744073709551615
// MAXUINT8 wraps G_MAXUINT8
const MAXUINT8 = 255
// MICRO_VERSION wraps GLIB_MICRO_VERSION
//
// The micro version number of the GLib library.
// 
// Like #gtk_micro_version, but from the headers used at
// application compile time, rather than from the library
// linked against at application run time.
const MICRO_VERSION = 1
// MININT16 wraps G_MININT16
//
// The minimum value which can be held in a #gint16.
const MININT16 = -32768
// MININT32 wraps G_MININT32
//
// The minimum value which can be held in a #gint32.
const MININT32 = -2147483648
// MININT64 wraps G_MININT64
//
// The minimum value which can be held in a #gint64.
const MININT64 = -9223372036854775808
// MININT8 wraps G_MININT8
//
// The minimum value which can be held in a #gint8.
const MININT8 = -128
// MINOR_VERSION wraps GLIB_MINOR_VERSION
//
// The minor version number of the GLib library.
// 
// Like #gtk_minor_version, but from the headers used at
// application compile time, rather than from the library
// linked against at application run time.
const MINOR_VERSION = 85
// PDP_ENDIAN wraps G_PDP_ENDIAN
//
// Specifies one of the possible types of byte order
// (currently unused). See %G_BYTE_ORDER.
const PDP_ENDIAN = 3412
// PI wraps G_PI
//
// The value of pi (ratio of circle's circumference to its diameter).
const PI = 3.141593
// PI_2 wraps G_PI_2
//
// Pi divided by 2.
const PI_2 = 1.570796
// PI_4 wraps G_PI_4
//
// Pi divided by 4.
const PI_4 = 0.785398
// PRIORITY_DEFAULT wraps G_PRIORITY_DEFAULT
//
// Use this for default priority event sources.
// 
// In GLib this priority is used when adding timeout functions
// with [func@GLib.timeout_add]. In GDK this priority is used for events
// from the X server.
const PRIORITY_DEFAULT = 0
// PRIORITY_DEFAULT_IDLE wraps G_PRIORITY_DEFAULT_IDLE
//
// Use this for default priority idle functions.
// 
// In GLib this priority is used when adding idle functions with
// [func@GLib.idle_add].
const PRIORITY_DEFAULT_IDLE = 200
// PRIORITY_HIGH wraps G_PRIORITY_HIGH
//
// Use this for high priority event sources.
// 
// It is not used within GLib or GTK.
const PRIORITY_HIGH = -100
// PRIORITY_HIGH_IDLE wraps G_PRIORITY_HIGH_IDLE
//
// Use this for high priority idle functions.
// 
// GTK uses %G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
// and %G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
// done to ensure that any pending resizes are processed before any
// pending redraws, so that widgets are not redrawn twice unnecessarily.)
const PRIORITY_HIGH_IDLE = 100
// PRIORITY_LOW wraps G_PRIORITY_LOW
//
// Use this for very low priority background tasks.
// 
// It is not used within GLib or GTK.
const PRIORITY_LOW = 300
// REF_COUNT_INIT wraps G_REF_COUNT_INIT
//
// Evaluates to the initial reference count for `grefcount`.
// 
// This macro is useful for initializing `grefcount` fields inside
// structures, for instance:
// 
// |[&lt;!-- language="C" --&gt;
// typedef struct {
//   grefcount ref_count;
//   char *name;
//   char *address;
// } Person;
// 
// static const Person default_person = {
//   .ref_count = G_REF_COUNT_INIT,
//   .name = "Default name",
//   .address = "Default address",
// };
// ]|
const REF_COUNT_INIT = -1
// SEARCHPATH_SEPARATOR wraps G_SEARCHPATH_SEPARATOR
//
// The search path separator character.
// This is ':' on UNIX machines and ';' under Windows.
const SEARCHPATH_SEPARATOR = 58
// SIZEOF_LONG wraps GLIB_SIZEOF_LONG
const SIZEOF_LONG = 8
// SIZEOF_SIZE_T wraps GLIB_SIZEOF_SIZE_T
const SIZEOF_SIZE_T = 8
// SIZEOF_SSIZE_T wraps GLIB_SIZEOF_SSIZE_T
const SIZEOF_SSIZE_T = 8
// SIZEOF_VOID_P wraps GLIB_SIZEOF_VOID_P
const SIZEOF_VOID_P = 8
// SQRT2 wraps G_SQRT2
//
// The square root of two.
const SQRT2 = 1.414214
// SYSDEF_AF_INET wraps GLIB_SYSDEF_AF_INET
const SYSDEF_AF_INET = 2
// SYSDEF_AF_INET6 wraps GLIB_SYSDEF_AF_INET6
const SYSDEF_AF_INET6 = 10
// SYSDEF_AF_UNIX wraps GLIB_SYSDEF_AF_UNIX
const SYSDEF_AF_UNIX = 1
// SYSDEF_MSG_DONTROUTE wraps GLIB_SYSDEF_MSG_DONTROUTE
const SYSDEF_MSG_DONTROUTE = 4
// SYSDEF_MSG_OOB wraps GLIB_SYSDEF_MSG_OOB
const SYSDEF_MSG_OOB = 1
// SYSDEF_MSG_PEEK wraps GLIB_SYSDEF_MSG_PEEK
const SYSDEF_MSG_PEEK = 2
// TIME_SPAN_DAY wraps G_TIME_SPAN_DAY
//
// Evaluates to a time span of one day.
const TIME_SPAN_DAY = 86400000000
// TIME_SPAN_HOUR wraps G_TIME_SPAN_HOUR
//
// Evaluates to a time span of one hour.
const TIME_SPAN_HOUR = 3600000000
// TIME_SPAN_MILLISECOND wraps G_TIME_SPAN_MILLISECOND
//
// Evaluates to a time span of one millisecond.
const TIME_SPAN_MILLISECOND = 1000
// TIME_SPAN_MINUTE wraps G_TIME_SPAN_MINUTE
//
// Evaluates to a time span of one minute.
const TIME_SPAN_MINUTE = 60000000
// TIME_SPAN_SECOND wraps G_TIME_SPAN_SECOND
//
// Evaluates to a time span of one second.
const TIME_SPAN_SECOND = 1000000
// UNICHAR_MAX_DECOMPOSITION_LENGTH wraps G_UNICHAR_MAX_DECOMPOSITION_LENGTH
//
// The maximum length (in codepoints) of a compatibility or canonical
// decomposition of a single Unicode character.
// 
// This is as defined by Unicode 6.1.
const UNICHAR_MAX_DECOMPOSITION_LENGTH = 18
// USEC_PER_SEC wraps G_USEC_PER_SEC
//
// Number of microseconds in one second (1 million).
// This macro is provided for code readability.
const USEC_PER_SEC = 1000000
// VA_COPY_AS_ARRAY wraps G_VA_COPY_AS_ARRAY
const VA_COPY_AS_ARRAY = 1
// VERSION_MIN_REQUIRED wraps GLIB_VERSION_MIN_REQUIRED
//
// A macro that should be defined by the user prior to including
// the glib.h header.
// The definition should be one of the predefined GLib version
// macros: %GLIB_VERSION_2_26, %GLIB_VERSION_2_28,...
// 
// This macro defines the earliest version of GLib that the package is
// required to be able to compile against.
// 
// If the compiler is configured to warn about the use of deprecated
// functions, then using functions that were deprecated in version
// %GLIB_VERSION_MIN_REQUIRED or earlier will cause warnings (but
// using functions deprecated in later releases will not).
const VERSION_MIN_REQUIRED = 2
// WIN32_MSG_HANDLE wraps G_WIN32_MSG_HANDLE
const WIN32_MSG_HANDLE = 19981206
// macro__has_attribute___noreturn__ wraps g_macro__has_attribute___noreturn__
const macro__has_attribute___noreturn__ = 0
// macro__has_attribute_ifunc wraps g_macro__has_attribute_ifunc
const macro__has_attribute_ifunc = 0
// macro__has_attribute_no_sanitize_address wraps g_macro__has_attribute_no_sanitize_address
const macro__has_attribute_no_sanitize_address = 0
// Pid wraps GPid
//
// A type which is used to hold a process identification.
// 
// On UNIX, processes are identified by a process id (an integer),
// while Windows uses process handles (which are pointers).
// 
// GPid is used in GLib only for descendant processes spawned with
// the g_spawn functions.
type Pid = int32
// Quark wraps GQuark
//
// A GQuark is a non-zero integer which uniquely identifies a
// particular string.
// 
// A GQuark value of zero is associated to `NULL`.
// 
// Given either the string or the `GQuark` identifier it is possible to
// retrieve the other.
// 
// Quarks are used for both
// [datasets and keyed data lists](datalist-and-dataset.html).
// 
// To create a new quark from a string, use [func@GLib.quark_from_string]
// or [func@GLib.quark_from_static_string].
// 
// To find the string corresponding to a given `GQuark`, use
// [func@GLib.quark_to_string].
// 
// To find the `GQuark` corresponding to a given string, use
// [func@GLib.quark_try_string].
// 
// Another use for the string pool maintained for the quark functions
// is string interning, using [func@GLib.intern_string] or
// [func@GLib.intern_static_string]. An interned string is a canonical
// representation for a string. One important advantage of interned
// strings is that they can be compared for equality by a simple
// pointer comparison, rather than using `strcmp()`.
type Quark = uint32
// RefString wraps GRefString
//
// A typedef for a reference-counted string. A pointer to a #GRefString can be
// treated like a standard `char*` array by all code, but can additionally have
// `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be
// called on `char*` arrays not allocated using g_ref_string_new().
// 
// If using #GRefString with autocleanups, g_autoptr() must be used rather than
// g_autofree(), so that the reference counting metadata is also freed.
type RefString = byte
// TimeSpan wraps GTimeSpan
//
// A value representing an interval of time, in microseconds.
type TimeSpan = int64
// BookmarkFileError wraps GBookmarkFileError
//
// Error codes returned by bookmark file parsing.
type BookmarkFileError C.int

const (
	// BookmarkFileErrorInvalidURI wraps G_BOOKMARK_FILE_ERROR_INVALID_URI
	//
	// URI was ill-formed
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue wraps G_BOOKMARK_FILE_ERROR_INVALID_VALUE
	//
	// a requested field was not found
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered wraps G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED
	//
	// a requested application did
	//     not register a bookmark
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound wraps G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND
	//
	// a requested URI was not found
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead wraps G_BOOKMARK_FILE_ERROR_READ
	//
	// document was ill formed
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding wraps G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING
	//
	// the text being parsed was
	//     in an unknown encoding
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite wraps G_BOOKMARK_FILE_ERROR_WRITE
	//
	// an error occurred while writing
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound wraps G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
	//
	// requested file was not found
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)


func (e BookmarkFileError) String() string {
	switch e {
		case BookmarkFileErrorAppNotRegistered: return "BookmarkFileErrorAppNotRegistered"
		case BookmarkFileErrorFileNotFound: return "BookmarkFileErrorFileNotFound"
		case BookmarkFileErrorInvalidURI: return "BookmarkFileErrorInvalidURI"
		case BookmarkFileErrorInvalidValue: return "BookmarkFileErrorInvalidValue"
		case BookmarkFileErrorRead: return "BookmarkFileErrorRead"
		case BookmarkFileErrorURINotFound: return "BookmarkFileErrorURINotFound"
		case BookmarkFileErrorUnknownEncoding: return "BookmarkFileErrorUnknownEncoding"
		case BookmarkFileErrorWrite: return "BookmarkFileErrorWrite"
		default: return fmt.Sprintf("BookmarkFileError(%d)", e)
	}
}

// ChecksumType wraps GChecksumType
//
// The hashing algorithm to be used by #GChecksum when performing the
// digest of some data.
// 
// Note that the #GChecksumType enumeration may be extended at a later
// date to include new hashing algorithm types.
type ChecksumType C.int

const (
	// ChecksumMD5 wraps G_CHECKSUM_MD5
	//
	// Use the MD5 hashing algorithm
	ChecksumMD5 ChecksumType = 0
	// ChecksumSHA1 wraps G_CHECKSUM_SHA1
	//
	// Use the SHA-1 hashing algorithm
	ChecksumSHA1 ChecksumType = 1
	// ChecksumSHA256 wraps G_CHECKSUM_SHA256
	//
	// Use the SHA-256 hashing algorithm
	ChecksumSHA256 ChecksumType = 2
	// ChecksumSHA512 wraps G_CHECKSUM_SHA512
	//
	// Use the SHA-512 hashing algorithm (Since: 2.36)
	ChecksumSHA512 ChecksumType = 3
	// ChecksumSHA384 wraps G_CHECKSUM_SHA384
	//
	// Use the SHA-384 hashing algorithm (Since: 2.51)
	ChecksumSHA384 ChecksumType = 4
)


func (e ChecksumType) String() string {
	switch e {
		case ChecksumMD5: return "ChecksumMD5"
		case ChecksumSHA1: return "ChecksumSHA1"
		case ChecksumSHA256: return "ChecksumSHA256"
		case ChecksumSHA384: return "ChecksumSHA384"
		case ChecksumSHA512: return "ChecksumSHA512"
		default: return fmt.Sprintf("ChecksumType(%d)", e)
	}
}

// ConvertError wraps GConvertError
//
// Error codes returned by character set conversion routines.
type ConvertError C.int

const (
	// ConvertErrorNoConversion wraps G_CONVERT_ERROR_NO_CONVERSION
	//
	// Conversion between the requested character
	//     sets is not supported.
	ConvertErrorNoConversion ConvertError = 0
	// ConvertErrorIllegalSequence wraps G_CONVERT_ERROR_ILLEGAL_SEQUENCE
	//
	// Invalid byte sequence in conversion input;
	//    or the character sequence could not be represented in the target
	//    character set.
	ConvertErrorIllegalSequence ConvertError = 1
	// ConvertErrorFailed wraps G_CONVERT_ERROR_FAILED
	//
	// Conversion failed for some reason.
	ConvertErrorFailed ConvertError = 2
	// ConvertErrorPartialInput wraps G_CONVERT_ERROR_PARTIAL_INPUT
	//
	// Partial character sequence at end of input.
	ConvertErrorPartialInput ConvertError = 3
	// ConvertErrorBadURI wraps G_CONVERT_ERROR_BAD_URI
	//
	// URI is invalid.
	ConvertErrorBadURI ConvertError = 4
	// ConvertErrorNotAbsolutePath wraps G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
	//
	// Pathname is not an absolute path.
	ConvertErrorNotAbsolutePath ConvertError = 5
	// ConvertErrorNoMemory wraps G_CONVERT_ERROR_NO_MEMORY
	//
	// No memory available. Since: 2.40
	ConvertErrorNoMemory ConvertError = 6
	// ConvertErrorEmbeddedNul wraps G_CONVERT_ERROR_EMBEDDED_NUL
	//
	// An embedded NUL character is present in
	//     conversion output where a NUL-terminated string is expected.
	//     Since: 2.56
	ConvertErrorEmbeddedNul ConvertError = 7
)


func (e ConvertError) String() string {
	switch e {
		case ConvertErrorBadURI: return "ConvertErrorBadURI"
		case ConvertErrorEmbeddedNul: return "ConvertErrorEmbeddedNul"
		case ConvertErrorFailed: return "ConvertErrorFailed"
		case ConvertErrorIllegalSequence: return "ConvertErrorIllegalSequence"
		case ConvertErrorNoConversion: return "ConvertErrorNoConversion"
		case ConvertErrorNoMemory: return "ConvertErrorNoMemory"
		case ConvertErrorNotAbsolutePath: return "ConvertErrorNotAbsolutePath"
		case ConvertErrorPartialInput: return "ConvertErrorPartialInput"
		default: return fmt.Sprintf("ConvertError(%d)", e)
	}
}

// ErrorType wraps GErrorType
//
// The possible errors, used in the @v_error field
// of #GTokenValue, when the token is a %G_TOKEN_ERROR.
type ErrorType C.int

const (
	// ErrUnknown wraps G_ERR_UNKNOWN
	//
	// unknown error
	ErrUnknown ErrorType = 0
	// ErrUnexpEOF wraps G_ERR_UNEXP_EOF
	//
	// unexpected end of file
	ErrUnexpEOF ErrorType = 1
	// ErrUnexpEOFInString wraps G_ERR_UNEXP_EOF_IN_STRING
	//
	// unterminated string constant
	ErrUnexpEOFInString ErrorType = 2
	// ErrUnexpEOFInComment wraps G_ERR_UNEXP_EOF_IN_COMMENT
	//
	// unterminated comment
	ErrUnexpEOFInComment ErrorType = 3
	// ErrNonDigitInConst wraps G_ERR_NON_DIGIT_IN_CONST
	//
	// non-digit character in a number
	ErrNonDigitInConst ErrorType = 4
	// ErrDigitRadix wraps G_ERR_DIGIT_RADIX
	//
	// digit beyond radix in a number
	ErrDigitRadix ErrorType = 5
	// ErrFloatRadix wraps G_ERR_FLOAT_RADIX
	//
	// non-decimal floating point number
	ErrFloatRadix ErrorType = 6
	// ErrFloatMalformed wraps G_ERR_FLOAT_MALFORMED
	//
	// malformed floating point number
	ErrFloatMalformed ErrorType = 7
)


func (e ErrorType) String() string {
	switch e {
		case ErrDigitRadix: return "ErrDigitRadix"
		case ErrFloatMalformed: return "ErrFloatMalformed"
		case ErrFloatRadix: return "ErrFloatRadix"
		case ErrNonDigitInConst: return "ErrNonDigitInConst"
		case ErrUnexpEOF: return "ErrUnexpEOF"
		case ErrUnexpEOFInComment: return "ErrUnexpEOFInComment"
		case ErrUnexpEOFInString: return "ErrUnexpEOFInString"
		case ErrUnknown: return "ErrUnknown"
		default: return fmt.Sprintf("ErrorType(%d)", e)
	}
}

// FileError wraps GFileError
//
// Values corresponding to @errno codes returned from file operations
// on UNIX. Unlike @errno codes, GFileError values are available on
// all systems, even Windows. The exact meaning of each code depends
// on what sort of file operation you were performing; the UNIX
// documentation gives more details. The following error code descriptions
// come from the GNU C Library manual, and are under the copyright
// of that manual.
// 
// It's not very portable to make detailed assumptions about exactly
// which errors will be returned from a given operation. Some errors
// don't occur on some systems, etc., sometimes there are subtle
// differences in when a system will report a given error, etc.
type FileError C.int

const (
	// FileErrorExist wraps G_FILE_ERROR_EXIST
	//
	// Operation not permitted; only the owner of
	//     the file (or other resource) or processes with special privileges
	//     can perform the operation.
	FileErrorExist FileError = 0
	// FileErrorIsdir wraps G_FILE_ERROR_ISDIR
	//
	// File is a directory; you cannot open a directory
	//     for writing, or create or remove hard links to it.
	FileErrorIsdir FileError = 1
	// FileErrorAcces wraps G_FILE_ERROR_ACCES
	//
	// Permission denied; the file permissions do not
	//     allow the attempted operation.
	FileErrorAcces FileError = 2
	// FileErrorNametoolong wraps G_FILE_ERROR_NAMETOOLONG
	//
	// Filename too long.
	FileErrorNametoolong FileError = 3
	// FileErrorNoent wraps G_FILE_ERROR_NOENT
	//
	// No such file or directory. This is a "file
	//     doesn't exist" error for ordinary files that are referenced in
	//     contexts where they are expected to already exist.
	FileErrorNoent FileError = 4
	// FileErrorNotdir wraps G_FILE_ERROR_NOTDIR
	//
	// A file that isn't a directory was specified when
	//     a directory is required.
	FileErrorNotdir FileError = 5
	// FileErrorNxio wraps G_FILE_ERROR_NXIO
	//
	// No such device or address. The system tried to
	//     use the device represented by a file you specified, and it
	//     couldn't find the device. This can mean that the device file was
	//     installed incorrectly, or that the physical device is missing or
	//     not correctly attached to the computer.
	FileErrorNxio FileError = 6
	// FileErrorNodev wraps G_FILE_ERROR_NODEV
	//
	// The underlying file system of the specified file
	//     does not support memory mapping.
	FileErrorNodev FileError = 7
	// FileErrorRofs wraps G_FILE_ERROR_ROFS
	//
	// The directory containing the new link can't be
	//     modified because it's on a read-only file system.
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy wraps G_FILE_ERROR_TXTBSY
	//
	// Text file busy.
	FileErrorTxtbsy FileError = 9
	// FileErrorFault wraps G_FILE_ERROR_FAULT
	//
	// You passed in a pointer to bad memory.
	//     (GLib won't reliably return this, don't pass in pointers to bad
	//     memory.)
	FileErrorFault FileError = 10
	// FileErrorLoop wraps G_FILE_ERROR_LOOP
	//
	// Too many levels of symbolic links were encountered
	//     in looking up a file name. This often indicates a cycle of symbolic
	//     links.
	FileErrorLoop FileError = 11
	// FileErrorNospc wraps G_FILE_ERROR_NOSPC
	//
	// No space left on device; write operation on a
	//     file failed because the disk is full.
	FileErrorNospc FileError = 12
	// FileErrorNomem wraps G_FILE_ERROR_NOMEM
	//
	// No memory available. The system cannot allocate
	//     more virtual memory because its capacity is full.
	FileErrorNomem FileError = 13
	// FileErrorMfile wraps G_FILE_ERROR_MFILE
	//
	// The current process has too many files open and
	//     can't open any more. Duplicate descriptors do count toward this
	//     limit.
	FileErrorMfile FileError = 14
	// FileErrorNfile wraps G_FILE_ERROR_NFILE
	//
	// There are too many distinct file openings in the
	//     entire system.
	FileErrorNfile FileError = 15
	// FileErrorBadf wraps G_FILE_ERROR_BADF
	//
	// Bad file descriptor; for example, I/O on a
	//     descriptor that has been closed or reading from a descriptor open
	//     only for writing (or vice versa).
	FileErrorBadf FileError = 16
	// FileErrorInval wraps G_FILE_ERROR_INVAL
	//
	// Invalid argument. This is used to indicate
	//     various kinds of problems with passing the wrong argument to a
	//     library function.
	FileErrorInval FileError = 17
	// FileErrorPipe wraps G_FILE_ERROR_PIPE
	//
	// Broken pipe; there is no process reading from the
	//     other end of a pipe. Every library function that returns this
	//     error code also generates a 'SIGPIPE' signal; this signal
	//     terminates the program if not handled or blocked. Thus, your
	//     program will never actually see this code unless it has handled
	//     or blocked 'SIGPIPE'.
	FileErrorPipe FileError = 18
	// FileErrorAgain wraps G_FILE_ERROR_AGAIN
	//
	// Resource temporarily unavailable; the call might
	//     work if you try again later.
	FileErrorAgain FileError = 19
	// FileErrorIntr wraps G_FILE_ERROR_INTR
	//
	// Interrupted function call; an asynchronous signal
	//     occurred and prevented completion of the call. When this
	//     happens, you should try the call again.
	FileErrorIntr FileError = 20
	// FileErrorIO wraps G_FILE_ERROR_IO
	//
	// Input/output error; usually used for physical read
	//    or write errors. i.e. the disk or other physical device hardware
	//    is returning errors.
	FileErrorIO FileError = 21
	// FileErrorPerm wraps G_FILE_ERROR_PERM
	//
	// Operation not permitted; only the owner of the
	//    file (or other resource) or processes with special privileges can
	//    perform the operation.
	FileErrorPerm FileError = 22
	// FileErrorNosys wraps G_FILE_ERROR_NOSYS
	//
	// Function not implemented; this indicates that
	//    the system is missing some functionality.
	FileErrorNosys FileError = 23
	// FileErrorFailed wraps G_FILE_ERROR_FAILED
	//
	// Does not correspond to a UNIX error code; this
	//    is the standard "failed for unspecified reason" error code present
	//    in all #GError error code enumerations. Returned if no specific
	//    code applies.
	FileErrorFailed FileError = 24
)


func (e FileError) String() string {
	switch e {
		case FileErrorAcces: return "FileErrorAcces"
		case FileErrorAgain: return "FileErrorAgain"
		case FileErrorBadf: return "FileErrorBadf"
		case FileErrorExist: return "FileErrorExist"
		case FileErrorFailed: return "FileErrorFailed"
		case FileErrorFault: return "FileErrorFault"
		case FileErrorIO: return "FileErrorIO"
		case FileErrorIntr: return "FileErrorIntr"
		case FileErrorInval: return "FileErrorInval"
		case FileErrorIsdir: return "FileErrorIsdir"
		case FileErrorLoop: return "FileErrorLoop"
		case FileErrorMfile: return "FileErrorMfile"
		case FileErrorNametoolong: return "FileErrorNametoolong"
		case FileErrorNfile: return "FileErrorNfile"
		case FileErrorNodev: return "FileErrorNodev"
		case FileErrorNoent: return "FileErrorNoent"
		case FileErrorNomem: return "FileErrorNomem"
		case FileErrorNospc: return "FileErrorNospc"
		case FileErrorNosys: return "FileErrorNosys"
		case FileErrorNotdir: return "FileErrorNotdir"
		case FileErrorNxio: return "FileErrorNxio"
		case FileErrorPerm: return "FileErrorPerm"
		case FileErrorPipe: return "FileErrorPipe"
		case FileErrorRofs: return "FileErrorRofs"
		case FileErrorTxtbsy: return "FileErrorTxtbsy"
		default: return fmt.Sprintf("FileError(%d)", e)
	}
}

// IOChannelError wraps GIOChannelError
//
// Error codes returned by #GIOChannel operations.
type IOChannelError C.int

const (
	// IOChannelErrorFbig wraps G_IO_CHANNEL_ERROR_FBIG
	//
	// File too large.
	IOChannelErrorFbig IOChannelError = 0
	// IOChannelErrorInval wraps G_IO_CHANNEL_ERROR_INVAL
	//
	// Invalid argument.
	IOChannelErrorInval IOChannelError = 1
	// IOChannelErrorIO wraps G_IO_CHANNEL_ERROR_IO
	//
	// IO error.
	IOChannelErrorIO IOChannelError = 2
	// IOChannelErrorIsdir wraps G_IO_CHANNEL_ERROR_ISDIR
	//
	// File is a directory.
	IOChannelErrorIsdir IOChannelError = 3
	// IOChannelErrorNospc wraps G_IO_CHANNEL_ERROR_NOSPC
	//
	// No space left on device.
	IOChannelErrorNospc IOChannelError = 4
	// IOChannelErrorNxio wraps G_IO_CHANNEL_ERROR_NXIO
	//
	// No such device or address.
	IOChannelErrorNxio IOChannelError = 5
	// IOChannelErrorOverflow wraps G_IO_CHANNEL_ERROR_OVERFLOW
	//
	// Value too large for defined datatype.
	IOChannelErrorOverflow IOChannelError = 6
	// IOChannelErrorPipe wraps G_IO_CHANNEL_ERROR_PIPE
	//
	// Broken pipe.
	IOChannelErrorPipe IOChannelError = 7
	// IOChannelErrorFailed wraps G_IO_CHANNEL_ERROR_FAILED
	//
	// Some other error.
	IOChannelErrorFailed IOChannelError = 8
)


func (e IOChannelError) String() string {
	switch e {
		case IOChannelErrorFailed: return "IOChannelErrorFailed"
		case IOChannelErrorFbig: return "IOChannelErrorFbig"
		case IOChannelErrorIO: return "IOChannelErrorIO"
		case IOChannelErrorInval: return "IOChannelErrorInval"
		case IOChannelErrorIsdir: return "IOChannelErrorIsdir"
		case IOChannelErrorNospc: return "IOChannelErrorNospc"
		case IOChannelErrorNxio: return "IOChannelErrorNxio"
		case IOChannelErrorOverflow: return "IOChannelErrorOverflow"
		case IOChannelErrorPipe: return "IOChannelErrorPipe"
		default: return fmt.Sprintf("IOChannelError(%d)", e)
	}
}

// IOError wraps GIOError
//
// #GIOError is only used by the deprecated functions
// g_io_channel_read(), g_io_channel_write(), and g_io_channel_seek().
type IOError C.int

const (
	// IOErrorNone wraps G_IO_ERROR_NONE
	//
	// no error
	IOErrorNone IOError = 0
	// IOErrorAgain wraps G_IO_ERROR_AGAIN
	//
	// an EAGAIN error occurred
	IOErrorAgain IOError = 1
	// IOErrorInval wraps G_IO_ERROR_INVAL
	//
	// an EINVAL error occurred
	IOErrorInval IOError = 2
	// IOErrorUnknown wraps G_IO_ERROR_UNKNOWN
	//
	// another error occurred
	IOErrorUnknown IOError = 3
)


func (e IOError) String() string {
	switch e {
		case IOErrorAgain: return "IOErrorAgain"
		case IOErrorInval: return "IOErrorInval"
		case IOErrorNone: return "IOErrorNone"
		case IOErrorUnknown: return "IOErrorUnknown"
		default: return fmt.Sprintf("IOError(%d)", e)
	}
}

// IOStatus wraps GIOStatus
//
// Statuses returned by most of the #GIOFuncs functions.
type IOStatus C.int

const (
	// IOStatusError wraps G_IO_STATUS_ERROR
	//
	// An error occurred.
	IOStatusError IOStatus = 0
	// IOStatusNormal wraps G_IO_STATUS_NORMAL
	//
	// Success.
	IOStatusNormal IOStatus = 1
	// IOStatusEOF wraps G_IO_STATUS_EOF
	//
	// End of file.
	IOStatusEOF IOStatus = 2
	// IOStatusAgain wraps G_IO_STATUS_AGAIN
	//
	// Resource temporarily unavailable.
	IOStatusAgain IOStatus = 3
)


func (e IOStatus) String() string {
	switch e {
		case IOStatusAgain: return "IOStatusAgain"
		case IOStatusEOF: return "IOStatusEOF"
		case IOStatusError: return "IOStatusError"
		case IOStatusNormal: return "IOStatusNormal"
		default: return fmt.Sprintf("IOStatus(%d)", e)
	}
}

// KeyFileError wraps GKeyFileError
//
// Error codes returned by key file parsing.
type KeyFileError C.int

const (
	// KeyFileErrorUnknownEncoding wraps G_KEY_FILE_ERROR_UNKNOWN_ENCODING
	//
	// the text being parsed was in
	//   an unknown encoding
	KeyFileErrorUnknownEncoding KeyFileError = 0
	// KeyFileErrorParse wraps G_KEY_FILE_ERROR_PARSE
	//
	// document was ill-formed
	KeyFileErrorParse KeyFileError = 1
	// KeyFileErrorNotFound wraps G_KEY_FILE_ERROR_NOT_FOUND
	//
	// the file was not found
	KeyFileErrorNotFound KeyFileError = 2
	// KeyFileErrorKeyNotFound wraps G_KEY_FILE_ERROR_KEY_NOT_FOUND
	//
	// a requested key was not found
	KeyFileErrorKeyNotFound KeyFileError = 3
	// KeyFileErrorGroupNotFound wraps G_KEY_FILE_ERROR_GROUP_NOT_FOUND
	//
	// a requested group was not found
	KeyFileErrorGroupNotFound KeyFileError = 4
	// KeyFileErrorInvalidValue wraps G_KEY_FILE_ERROR_INVALID_VALUE
	//
	// a value could not be parsed
	KeyFileErrorInvalidValue KeyFileError = 5
)


func (e KeyFileError) String() string {
	switch e {
		case KeyFileErrorGroupNotFound: return "KeyFileErrorGroupNotFound"
		case KeyFileErrorInvalidValue: return "KeyFileErrorInvalidValue"
		case KeyFileErrorKeyNotFound: return "KeyFileErrorKeyNotFound"
		case KeyFileErrorNotFound: return "KeyFileErrorNotFound"
		case KeyFileErrorParse: return "KeyFileErrorParse"
		case KeyFileErrorUnknownEncoding: return "KeyFileErrorUnknownEncoding"
		default: return fmt.Sprintf("KeyFileError(%d)", e)
	}
}

// LogWriterOutput wraps GLogWriterOutput
//
// Return values from #GLogWriterFuncs to indicate whether the given log entry
// was successfully handled by the writer, or whether there was an error in
// handling it (and hence a fallback writer should be used).
// 
// If a #GLogWriterFunc ignores a log entry, it should return
// %G_LOG_WRITER_HANDLED.
type LogWriterOutput C.int

const (
	// LogWriterHandled wraps G_LOG_WRITER_HANDLED
	//
	// Log writer has handled the log entry.
	LogWriterHandled LogWriterOutput = 1
	// LogWriterUnhandled wraps G_LOG_WRITER_UNHANDLED
	//
	// Log writer could not handle the log entry.
	LogWriterUnhandled LogWriterOutput = 0
)


func (e LogWriterOutput) String() string {
	switch e {
		case LogWriterHandled: return "LogWriterHandled"
		case LogWriterUnhandled: return "LogWriterUnhandled"
		default: return fmt.Sprintf("LogWriterOutput(%d)", e)
	}
}

// MarkupError wraps GMarkupError
//
// Error codes returned by markup parsing.
type MarkupError C.int

const (
	// MarkupErrorBadUTF8 wraps G_MARKUP_ERROR_BAD_UTF8
	//
	// text being parsed was not valid UTF-8
	MarkupErrorBadUTF8 MarkupError = 0
	// MarkupErrorEmpty wraps G_MARKUP_ERROR_EMPTY
	//
	// document contained nothing, or only whitespace
	MarkupErrorEmpty MarkupError = 1
	// MarkupErrorParse wraps G_MARKUP_ERROR_PARSE
	//
	// document was ill-formed
	MarkupErrorParse MarkupError = 2
	// MarkupErrorUnknownElement wraps G_MARKUP_ERROR_UNKNOWN_ELEMENT
	//
	// error should be set by #GMarkupParser
	//     functions; element wasn't known
	MarkupErrorUnknownElement MarkupError = 3
	// MarkupErrorUnknownAttribute wraps G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE
	//
	// error should be set by #GMarkupParser
	//     functions; attribute wasn't known
	MarkupErrorUnknownAttribute MarkupError = 4
	// MarkupErrorInvalidContent wraps G_MARKUP_ERROR_INVALID_CONTENT
	//
	// error should be set by #GMarkupParser
	//     functions; content was invalid
	MarkupErrorInvalidContent MarkupError = 5
	// MarkupErrorMissingAttribute wraps G_MARKUP_ERROR_MISSING_ATTRIBUTE
	//
	// error should be set by #GMarkupParser
	//     functions; a required attribute was missing
	MarkupErrorMissingAttribute MarkupError = 6
)


func (e MarkupError) String() string {
	switch e {
		case MarkupErrorBadUTF8: return "MarkupErrorBadUTF8"
		case MarkupErrorEmpty: return "MarkupErrorEmpty"
		case MarkupErrorInvalidContent: return "MarkupErrorInvalidContent"
		case MarkupErrorMissingAttribute: return "MarkupErrorMissingAttribute"
		case MarkupErrorParse: return "MarkupErrorParse"
		case MarkupErrorUnknownAttribute: return "MarkupErrorUnknownAttribute"
		case MarkupErrorUnknownElement: return "MarkupErrorUnknownElement"
		default: return fmt.Sprintf("MarkupError(%d)", e)
	}
}

// NormalizeMode wraps GNormalizeMode
//
// Defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with
// an accent is represented as a base character and combining
// accent or as a single precomposed character. Unicode strings
// should generally be normalized before comparing them.
type NormalizeMode C.int

const (
	// NormalizeDefault wraps G_NORMALIZE_DEFAULT
	//
	// standardize differences that do not affect the
	//     text content, such as the above-mentioned accent representation
	NormalizeDefault NormalizeMode = 0
	// NormalizeNFD wraps G_NORMALIZE_NFD
	//
	// another name for %G_NORMALIZE_DEFAULT
	NormalizeNFD NormalizeMode = 0
	// NormalizeDefaultCompose wraps G_NORMALIZE_DEFAULT_COMPOSE
	//
	// like %G_NORMALIZE_DEFAULT, but with
	//     composed forms rather than a maximally decomposed form
	NormalizeDefaultCompose NormalizeMode = 1
	// NormalizeNFC wraps G_NORMALIZE_NFC
	//
	// another name for %G_NORMALIZE_DEFAULT_COMPOSE
	NormalizeNFC NormalizeMode = 1
	// NormalizeAll wraps G_NORMALIZE_ALL
	//
	// beyond %G_NORMALIZE_DEFAULT also standardize the
	//     "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
	//     to the standard forms (in this case DIGIT THREE). Formatting
	//     information may be lost but for most text operations such
	//     characters should be considered the same
	NormalizeAll NormalizeMode = 2
	// NormalizeNFKD wraps G_NORMALIZE_NFKD
	//
	// another name for %G_NORMALIZE_ALL
	NormalizeNFKD NormalizeMode = 2
	// NormalizeAllCompose wraps G_NORMALIZE_ALL_COMPOSE
	//
	// like %G_NORMALIZE_ALL, but with composed
	//     forms rather than a maximally decomposed form
	NormalizeAllCompose NormalizeMode = 3
	// NormalizeNFKC wraps G_NORMALIZE_NFKC
	//
	// another name for %G_NORMALIZE_ALL_COMPOSE
	NormalizeNFKC NormalizeMode = 3
)


func (e NormalizeMode) String() string {
	switch e {
		case NormalizeAll: return "NormalizeAll"
		case NormalizeAllCompose: return "NormalizeAllCompose"
		case NormalizeDefault: return "NormalizeDefault"
		case NormalizeDefaultCompose: return "NormalizeDefaultCompose"
		default: return fmt.Sprintf("NormalizeMode(%d)", e)
	}
}

// NumberParserError wraps GNumberParserError
//
// Error codes returned by functions converting a string to a number.
type NumberParserError C.int

const (
	// NumberParserErrorInvalid wraps G_NUMBER_PARSER_ERROR_INVALID
	//
	// string was not a valid number
	NumberParserErrorInvalid NumberParserError = 0
	// NumberParserErrorOutOfBounds wraps G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS
	//
	// string was a number, but out of bounds
	NumberParserErrorOutOfBounds NumberParserError = 1
)


func (e NumberParserError) String() string {
	switch e {
		case NumberParserErrorInvalid: return "NumberParserErrorInvalid"
		case NumberParserErrorOutOfBounds: return "NumberParserErrorOutOfBounds"
		default: return fmt.Sprintf("NumberParserError(%d)", e)
	}
}

// OnceStatus wraps GOnceStatus
//
// The possible statuses of a one-time initialization function
// controlled by a #GOnce struct.
type OnceStatus C.int

const (
	// OnceStatusNotcalled wraps G_ONCE_STATUS_NOTCALLED
	//
	// the function has not been called yet.
	OnceStatusNotcalled OnceStatus = 0
	// OnceStatusProgress wraps G_ONCE_STATUS_PROGRESS
	//
	// the function call is currently in progress.
	OnceStatusProgress OnceStatus = 1
	// OnceStatusReady wraps G_ONCE_STATUS_READY
	//
	// the function has been called.
	OnceStatusReady OnceStatus = 2
)


func (e OnceStatus) String() string {
	switch e {
		case OnceStatusNotcalled: return "OnceStatusNotcalled"
		case OnceStatusProgress: return "OnceStatusProgress"
		case OnceStatusReady: return "OnceStatusReady"
		default: return fmt.Sprintf("OnceStatus(%d)", e)
	}
}

// OptionArg wraps GOptionArg
//
// The #GOptionArg enum values determine which type of extra argument the
// options expect to find. If an option expects an extra argument, it can
// be specified in several ways; with a short option: `-x arg`, with a long
// option: `--name arg` or combined in a single argument: `--name=arg`.
type OptionArg C.int

const (
	// OptionArgNone wraps G_OPTION_ARG_NONE
	//
	// No extra argument. This is useful for simple flags or booleans.
	OptionArgNone OptionArg = 0
	// OptionArgString wraps G_OPTION_ARG_STRING
	//
	// The option takes a UTF-8 string argument.
	OptionArgString OptionArg = 1
	// OptionArgInt wraps G_OPTION_ARG_INT
	//
	// The option takes an integer argument.
	OptionArgInt OptionArg = 2
	// OptionArgCallback wraps G_OPTION_ARG_CALLBACK
	//
	// The option provides a callback (of type #GOptionArgFunc)
	//   to parse the extra argument.
	OptionArgCallback OptionArg = 3
	// OptionArgFilename wraps G_OPTION_ARG_FILENAME
	//
	// The option takes a filename as argument, which will
	//      be in the GLib filename encoding rather than UTF-8.
	OptionArgFilename OptionArg = 4
	// OptionArgStringArray wraps G_OPTION_ARG_STRING_ARRAY
	//
	// The option takes a string argument, multiple
	//   uses of the option are collected into an array of strings.
	OptionArgStringArray OptionArg = 5
	// OptionArgFilenameArray wraps G_OPTION_ARG_FILENAME_ARRAY
	//
	// The option takes a filename as argument,
	//   multiple uses of the option are collected into an array of strings.
	OptionArgFilenameArray OptionArg = 6
	// OptionArgDouble wraps G_OPTION_ARG_DOUBLE
	//
	// The option takes a double argument. The argument
	//   can be formatted either for the user's locale or for the "C" locale.
	//   Since 2.12
	OptionArgDouble OptionArg = 7
	// OptionArgInt64 wraps G_OPTION_ARG_INT64
	//
	// The option takes a 64-bit integer. Like
	//   %G_OPTION_ARG_INT but for larger numbers. The number can be in
	//   decimal base, or in hexadecimal (when prefixed with `0x`, for
	//   example, `0xffffffff`). Since 2.12
	OptionArgInt64 OptionArg = 8
)


func (e OptionArg) String() string {
	switch e {
		case OptionArgCallback: return "OptionArgCallback"
		case OptionArgDouble: return "OptionArgDouble"
		case OptionArgFilename: return "OptionArgFilename"
		case OptionArgFilenameArray: return "OptionArgFilenameArray"
		case OptionArgInt: return "OptionArgInt"
		case OptionArgInt64: return "OptionArgInt64"
		case OptionArgNone: return "OptionArgNone"
		case OptionArgString: return "OptionArgString"
		case OptionArgStringArray: return "OptionArgStringArray"
		default: return fmt.Sprintf("OptionArg(%d)", e)
	}
}

// OptionError wraps GOptionError
//
// Error codes returned by option parsing.
type OptionError C.int

const (
	// OptionErrorUnknownOption wraps G_OPTION_ERROR_UNKNOWN_OPTION
	//
	// An option was not known to the parser.
	//  This error will only be reported, if the parser hasn't been instructed
	//  to ignore unknown options, see g_option_context_set_ignore_unknown_options().
	OptionErrorUnknownOption OptionError = 0
	// OptionErrorBadValue wraps G_OPTION_ERROR_BAD_VALUE
	//
	// A value couldn't be parsed.
	OptionErrorBadValue OptionError = 1
	// OptionErrorFailed wraps G_OPTION_ERROR_FAILED
	//
	// A #GOptionArgFunc callback failed.
	OptionErrorFailed OptionError = 2
)


func (e OptionError) String() string {
	switch e {
		case OptionErrorBadValue: return "OptionErrorBadValue"
		case OptionErrorFailed: return "OptionErrorFailed"
		case OptionErrorUnknownOption: return "OptionErrorUnknownOption"
		default: return fmt.Sprintf("OptionError(%d)", e)
	}
}

// RegexError wraps GRegexError
//
// Error codes returned by regular expressions functions.
type RegexError C.int

const (
	// RegexErrorCompile wraps G_REGEX_ERROR_COMPILE
	//
	// Compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize wraps G_REGEX_ERROR_OPTIMIZE
	//
	// Optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace wraps G_REGEX_ERROR_REPLACE
	//
	// Replacement failed due to an ill-formed replacement
	//     string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch wraps G_REGEX_ERROR_MATCH
	//
	// The match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal wraps G_REGEX_ERROR_INTERNAL
	//
	// Internal error of the regular expression engine.
	//     Since 2.16
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash wraps G_REGEX_ERROR_STRAY_BACKSLASH
	//
	// "\\" at end of pattern. Since 2.16
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar wraps G_REGEX_ERROR_MISSING_CONTROL_CHAR
	//
	// "\\c" at end of pattern. Since 2.16
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape wraps G_REGEX_ERROR_UNRECOGNIZED_ESCAPE
	//
	// Unrecognized character follows "\\".
	//     Since 2.16
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder wraps G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER
	//
	// Numbers out of order in "{}"
	//     quantifier. Since 2.16
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig wraps G_REGEX_ERROR_QUANTIFIER_TOO_BIG
	//
	// Number too big in "{}" quantifier.
	//     Since 2.16
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass wraps G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS
	//
	// Missing terminating "]" for
	//     character class. Since 2.16
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass wraps G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS
	//
	// Invalid escape sequence
	//     in character class. Since 2.16
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder wraps G_REGEX_ERROR_RANGE_OUT_OF_ORDER
	//
	// Range out of order in character class.
	//     Since 2.16
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat wraps G_REGEX_ERROR_NOTHING_TO_REPEAT
	//
	// Nothing to repeat. Since 2.16
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter wraps G_REGEX_ERROR_UNRECOGNIZED_CHARACTER
	//
	// Unrecognized character after "(?",
	//     "(?&lt;" or "(?P". Since 2.16
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass wraps G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS
	//
	// POSIX named classes are
	//     supported only within a class. Since 2.16
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis wraps G_REGEX_ERROR_UNMATCHED_PARENTHESIS
	//
	// Missing terminating ")" or ")"
	//     without opening "(". Since 2.16
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference wraps G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE
	//
	// Reference to non-existent
	//     subpattern. Since 2.16
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment wraps G_REGEX_ERROR_UNTERMINATED_COMMENT
	//
	// Missing terminating ")" after comment.
	//     Since 2.16
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge wraps G_REGEX_ERROR_EXPRESSION_TOO_LARGE
	//
	// Regular expression too large.
	//     Since 2.16
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError wraps G_REGEX_ERROR_MEMORY_ERROR
	//
	// Failed to get memory. Since 2.16
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind wraps G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND
	//
	// Lookbehind assertion is not
	//     fixed length. Since 2.16
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition wraps G_REGEX_ERROR_MALFORMED_CONDITION
	//
	// Malformed number or name after "(?(".
	//     Since 2.16
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches wraps G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES
	//
	// Conditional group contains
	//     more than two branches. Since 2.16
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected wraps G_REGEX_ERROR_ASSERTION_EXPECTED
	//
	// Assertion expected after "(?(".
	//     Since 2.16
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName wraps G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME
	//
	// Unknown POSIX class name.
	//     Since 2.16
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported wraps G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED
	//
	// POSIX collating
	//     elements are not supported. Since 2.16
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge wraps G_REGEX_ERROR_HEX_CODE_TOO_LARGE
	//
	// Character value in "\\x{...}" sequence
	//     is too large. Since 2.16
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition wraps G_REGEX_ERROR_INVALID_CONDITION
	//
	// Invalid condition "(?(0)". Since 2.16
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind wraps G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND
	//
	// \\C not allowed in
	//     lookbehind assertion. Since 2.16
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop wraps G_REGEX_ERROR_INFINITE_LOOP
	//
	// Recursive call could loop indefinitely.
	//     Since 2.16
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator wraps G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR
	//
	// Missing terminator
	//     in subpattern name. Since 2.16
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName wraps G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME
	//
	// Two named subpatterns have
	//     the same name. Since 2.16
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty wraps G_REGEX_ERROR_MALFORMED_PROPERTY
	//
	// Malformed "\\P" or "\\p" sequence.
	//     Since 2.16
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty wraps G_REGEX_ERROR_UNKNOWN_PROPERTY
	//
	// Unknown property name after "\\P" or
	//     "\\p". Since 2.16
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong wraps G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG
	//
	// Subpattern name is too long
	//     (maximum 32 characters). Since 2.16
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns wraps G_REGEX_ERROR_TOO_MANY_SUBPATTERNS
	//
	// Too many named subpatterns (maximum
	//     10,000). Since 2.16
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue wraps G_REGEX_ERROR_INVALID_OCTAL_VALUE
	//
	// Octal value is greater than "\\377".
	//     Since 2.16
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine wraps G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE
	//
	// "DEFINE" group contains more
	//     than one branch. Since 2.16
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion wraps G_REGEX_ERROR_DEFINE_REPETION
	//
	// Repeating a "DEFINE" group is not allowed.
	//     This error is never raised. Since: 2.16 Deprecated: 2.34
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions wraps G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS
	//
	// Inconsistent newline options.
	//     Since 2.16
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference wraps G_REGEX_ERROR_MISSING_BACK_REFERENCE
	//
	// "\\g" is not followed by a braced,
	//      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference wraps G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE
	//
	// relative reference must not be zero. Since: 2.34
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden wraps G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN
	//
	// the backtracing
	//     control verb used does not allow an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb wraps G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB
	//
	// unknown backtracing
	//     control verb. Since: 2.34
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig wraps G_REGEX_ERROR_NUMBER_TOO_BIG
	//
	// number is too big in escape sequence. Since: 2.34
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName wraps G_REGEX_ERROR_MISSING_SUBPATTERN_NAME
	//
	// Missing subpattern name. Since: 2.34
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit wraps G_REGEX_ERROR_MISSING_DIGIT
	//
	// Missing digit. Since 2.34
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter wraps G_REGEX_ERROR_INVALID_DATA_CHARACTER
	//
	// In JavaScript compatibility mode,
	//     "[" is an invalid data character. Since: 2.34
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName wraps G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME
	//
	// different names for subpatterns of the
	//     same number are not allowed. Since: 2.34
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired wraps G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED
	//
	// the backtracing control
	//     verb requires an argument. Since: 2.34
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar wraps G_REGEX_ERROR_INVALID_CONTROL_CHAR
	//
	// "\\c" must be followed by an ASCII
	//     character. Since: 2.34
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName wraps G_REGEX_ERROR_MISSING_NAME
	//
	// "\\k" is not followed by a braced, angle-bracketed, or
	//     quoted name. Since: 2.34
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass wraps G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS
	//
	// "\\N" is not supported in a class. Since: 2.34
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences wraps G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES
	//
	// too many forward references. Since: 2.34
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong wraps G_REGEX_ERROR_NAME_TOO_LONG
	//
	// the name is too long in "(*MARK)", "(*PRUNE)",
	//     "(*SKIP)", or "(*THEN)". Since: 2.34
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge wraps G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE
	//
	// the character value in the \\u sequence is
	//     too large. Since: 2.34
	RegexErrorCharacterValueTooLarge RegexError = 176
)


func (e RegexError) String() string {
	switch e {
		case RegexErrorAssertionExpected: return "RegexErrorAssertionExpected"
		case RegexErrorBacktrackingControlVerbArgumentForbidden: return "RegexErrorBacktrackingControlVerbArgumentForbidden"
		case RegexErrorBacktrackingControlVerbArgumentRequired: return "RegexErrorBacktrackingControlVerbArgumentRequired"
		case RegexErrorCharacterValueTooLarge: return "RegexErrorCharacterValueTooLarge"
		case RegexErrorCompile: return "RegexErrorCompile"
		case RegexErrorDefineRepetion: return "RegexErrorDefineRepetion"
		case RegexErrorDuplicateSubpatternName: return "RegexErrorDuplicateSubpatternName"
		case RegexErrorExpressionTooLarge: return "RegexErrorExpressionTooLarge"
		case RegexErrorExtraSubpatternName: return "RegexErrorExtraSubpatternName"
		case RegexErrorHexCodeTooLarge: return "RegexErrorHexCodeTooLarge"
		case RegexErrorInconsistentNewlineOptions: return "RegexErrorInconsistentNewlineOptions"
		case RegexErrorInexistentSubpatternReference: return "RegexErrorInexistentSubpatternReference"
		case RegexErrorInfiniteLoop: return "RegexErrorInfiniteLoop"
		case RegexErrorInternal: return "RegexErrorInternal"
		case RegexErrorInvalidCondition: return "RegexErrorInvalidCondition"
		case RegexErrorInvalidControlChar: return "RegexErrorInvalidControlChar"
		case RegexErrorInvalidDataCharacter: return "RegexErrorInvalidDataCharacter"
		case RegexErrorInvalidEscapeInCharacterClass: return "RegexErrorInvalidEscapeInCharacterClass"
		case RegexErrorInvalidOctalValue: return "RegexErrorInvalidOctalValue"
		case RegexErrorInvalidRelativeReference: return "RegexErrorInvalidRelativeReference"
		case RegexErrorMalformedCondition: return "RegexErrorMalformedCondition"
		case RegexErrorMalformedProperty: return "RegexErrorMalformedProperty"
		case RegexErrorMatch: return "RegexErrorMatch"
		case RegexErrorMemoryError: return "RegexErrorMemoryError"
		case RegexErrorMissingBackReference: return "RegexErrorMissingBackReference"
		case RegexErrorMissingControlChar: return "RegexErrorMissingControlChar"
		case RegexErrorMissingDigit: return "RegexErrorMissingDigit"
		case RegexErrorMissingName: return "RegexErrorMissingName"
		case RegexErrorMissingSubpatternName: return "RegexErrorMissingSubpatternName"
		case RegexErrorMissingSubpatternNameTerminator: return "RegexErrorMissingSubpatternNameTerminator"
		case RegexErrorNameTooLong: return "RegexErrorNameTooLong"
		case RegexErrorNotSupportedInClass: return "RegexErrorNotSupportedInClass"
		case RegexErrorNothingToRepeat: return "RegexErrorNothingToRepeat"
		case RegexErrorNumberTooBig: return "RegexErrorNumberTooBig"
		case RegexErrorOptimize: return "RegexErrorOptimize"
		case RegexErrorPosixCollatingElementsNotSupported: return "RegexErrorPosixCollatingElementsNotSupported"
		case RegexErrorPosixNamedClassOutsideClass: return "RegexErrorPosixNamedClassOutsideClass"
		case RegexErrorQuantifierTooBig: return "RegexErrorQuantifierTooBig"
		case RegexErrorQuantifiersOutOfOrder: return "RegexErrorQuantifiersOutOfOrder"
		case RegexErrorRangeOutOfOrder: return "RegexErrorRangeOutOfOrder"
		case RegexErrorReplace: return "RegexErrorReplace"
		case RegexErrorSingleByteMatchInLookbehind: return "RegexErrorSingleByteMatchInLookbehind"
		case RegexErrorStrayBackslash: return "RegexErrorStrayBackslash"
		case RegexErrorSubpatternNameTooLong: return "RegexErrorSubpatternNameTooLong"
		case RegexErrorTooManyBranchesInDefine: return "RegexErrorTooManyBranchesInDefine"
		case RegexErrorTooManyConditionalBranches: return "RegexErrorTooManyConditionalBranches"
		case RegexErrorTooManyForwardReferences: return "RegexErrorTooManyForwardReferences"
		case RegexErrorTooManySubpatterns: return "RegexErrorTooManySubpatterns"
		case RegexErrorUnknownBacktrackingControlVerb: return "RegexErrorUnknownBacktrackingControlVerb"
		case RegexErrorUnknownPosixClassName: return "RegexErrorUnknownPosixClassName"
		case RegexErrorUnknownProperty: return "RegexErrorUnknownProperty"
		case RegexErrorUnmatchedParenthesis: return "RegexErrorUnmatchedParenthesis"
		case RegexErrorUnrecognizedCharacter: return "RegexErrorUnrecognizedCharacter"
		case RegexErrorUnrecognizedEscape: return "RegexErrorUnrecognizedEscape"
		case RegexErrorUnterminatedCharacterClass: return "RegexErrorUnterminatedCharacterClass"
		case RegexErrorUnterminatedComment: return "RegexErrorUnterminatedComment"
		case RegexErrorVariableLengthLookbehind: return "RegexErrorVariableLengthLookbehind"
		default: return fmt.Sprintf("RegexError(%d)", e)
	}
}

// SeekType wraps GSeekType
//
// An enumeration specifying the base position for a
// g_io_channel_seek_position() operation.
type SeekType C.int

const (
	// SeekCur wraps G_SEEK_CUR
	//
	// the current position in the file.
	SeekCur SeekType = 0
	// SeekSet wraps G_SEEK_SET
	//
	// the start of the file.
	SeekSet SeekType = 1
	// SeekEnd wraps G_SEEK_END
	//
	// the end of the file.
	SeekEnd SeekType = 2
)


func (e SeekType) String() string {
	switch e {
		case SeekCur: return "SeekCur"
		case SeekEnd: return "SeekEnd"
		case SeekSet: return "SeekSet"
		default: return fmt.Sprintf("SeekType(%d)", e)
	}
}

// ShellError wraps GShellError
//
// Error codes returned by shell functions.
type ShellError C.int

const (
	// ShellErrorBadQuoting wraps G_SHELL_ERROR_BAD_QUOTING
	//
	// Mismatched or otherwise mangled quoting.
	ShellErrorBadQuoting ShellError = 0
	// ShellErrorEmptyString wraps G_SHELL_ERROR_EMPTY_STRING
	//
	// String to be parsed was empty.
	ShellErrorEmptyString ShellError = 1
	// ShellErrorFailed wraps G_SHELL_ERROR_FAILED
	//
	// Some other error.
	ShellErrorFailed ShellError = 2
)


func (e ShellError) String() string {
	switch e {
		case ShellErrorBadQuoting: return "ShellErrorBadQuoting"
		case ShellErrorEmptyString: return "ShellErrorEmptyString"
		case ShellErrorFailed: return "ShellErrorFailed"
		default: return fmt.Sprintf("ShellError(%d)", e)
	}
}

// SliceConfig wraps GSliceConfig
type SliceConfig C.int

const (
	// SliceConfigAlwaysMalloc wraps G_SLICE_CONFIG_ALWAYS_MALLOC
	SliceConfigAlwaysMalloc SliceConfig = 1
	// SliceConfigBypassMagazines wraps G_SLICE_CONFIG_BYPASS_MAGAZINES
	SliceConfigBypassMagazines SliceConfig = 2
	// SliceConfigWorkingSetMsecs wraps G_SLICE_CONFIG_WORKING_SET_MSECS
	SliceConfigWorkingSetMsecs SliceConfig = 3
	// SliceConfigColorIncrement wraps G_SLICE_CONFIG_COLOR_INCREMENT
	SliceConfigColorIncrement SliceConfig = 4
	// SliceConfigChunkSizes wraps G_SLICE_CONFIG_CHUNK_SIZES
	SliceConfigChunkSizes SliceConfig = 5
	// SliceConfigContentionCounter wraps G_SLICE_CONFIG_CONTENTION_COUNTER
	SliceConfigContentionCounter SliceConfig = 6
)


func (e SliceConfig) String() string {
	switch e {
		case SliceConfigAlwaysMalloc: return "SliceConfigAlwaysMalloc"
		case SliceConfigBypassMagazines: return "SliceConfigBypassMagazines"
		case SliceConfigChunkSizes: return "SliceConfigChunkSizes"
		case SliceConfigColorIncrement: return "SliceConfigColorIncrement"
		case SliceConfigContentionCounter: return "SliceConfigContentionCounter"
		case SliceConfigWorkingSetMsecs: return "SliceConfigWorkingSetMsecs"
		default: return fmt.Sprintf("SliceConfig(%d)", e)
	}
}

// SpawnError wraps GSpawnError
//
// Error codes returned by spawning processes.
type SpawnError C.int

const (
	// SpawnErrorFork wraps G_SPAWN_ERROR_FORK
	//
	// Fork failed due to lack of memory.
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead wraps G_SPAWN_ERROR_READ
	//
	// Read or select on pipes failed.
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir wraps G_SPAWN_ERROR_CHDIR
	//
	// Changing to working directory failed.
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces wraps G_SPAWN_ERROR_ACCES
	//
	// execv() returned `EACCES`
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm wraps G_SPAWN_ERROR_PERM
	//
	// execv() returned `EPERM`
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig wraps G_SPAWN_ERROR_TOO_BIG
	//
	// execv() returned `E2BIG`
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2big wraps G_SPAWN_ERROR_2BIG
	//
	// deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)
	SpawnError2big SpawnError = 5
	// SpawnErrorNoexec wraps G_SPAWN_ERROR_NOEXEC
	//
	// execv() returned `ENOEXEC`
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong wraps G_SPAWN_ERROR_NAMETOOLONG
	//
	// execv() returned `ENAMETOOLONG`
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent wraps G_SPAWN_ERROR_NOENT
	//
	// execv() returned `ENOENT`
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNomem wraps G_SPAWN_ERROR_NOMEM
	//
	// execv() returned `ENOMEM`
	SpawnErrorNomem SpawnError = 9
	// SpawnErrorNotdir wraps G_SPAWN_ERROR_NOTDIR
	//
	// execv() returned `ENOTDIR`
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop wraps G_SPAWN_ERROR_LOOP
	//
	// execv() returned `ELOOP`
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy wraps G_SPAWN_ERROR_TXTBUSY
	//
	// execv() returned `ETXTBUSY`
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO wraps G_SPAWN_ERROR_IO
	//
	// execv() returned `EIO`
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile wraps G_SPAWN_ERROR_NFILE
	//
	// execv() returned `ENFILE`
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile wraps G_SPAWN_ERROR_MFILE
	//
	// execv() returned `EMFILE`
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval wraps G_SPAWN_ERROR_INVAL
	//
	// execv() returned `EINVAL`
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir wraps G_SPAWN_ERROR_ISDIR
	//
	// execv() returned `EISDIR`
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad wraps G_SPAWN_ERROR_LIBBAD
	//
	// execv() returned `ELIBBAD`
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed wraps G_SPAWN_ERROR_FAILED
	//
	// Some other fatal failure,
	//   `error-&gt;message` should explain.
	SpawnErrorFailed SpawnError = 19
)


func (e SpawnError) String() string {
	switch e {
		case SpawnErrorAcces: return "SpawnErrorAcces"
		case SpawnErrorChdir: return "SpawnErrorChdir"
		case SpawnErrorFailed: return "SpawnErrorFailed"
		case SpawnErrorFork: return "SpawnErrorFork"
		case SpawnErrorIO: return "SpawnErrorIO"
		case SpawnErrorInval: return "SpawnErrorInval"
		case SpawnErrorIsdir: return "SpawnErrorIsdir"
		case SpawnErrorLibbad: return "SpawnErrorLibbad"
		case SpawnErrorLoop: return "SpawnErrorLoop"
		case SpawnErrorMfile: return "SpawnErrorMfile"
		case SpawnErrorNametoolong: return "SpawnErrorNametoolong"
		case SpawnErrorNfile: return "SpawnErrorNfile"
		case SpawnErrorNoent: return "SpawnErrorNoent"
		case SpawnErrorNoexec: return "SpawnErrorNoexec"
		case SpawnErrorNomem: return "SpawnErrorNomem"
		case SpawnErrorNotdir: return "SpawnErrorNotdir"
		case SpawnErrorPerm: return "SpawnErrorPerm"
		case SpawnErrorRead: return "SpawnErrorRead"
		case SpawnErrorTooBig: return "SpawnErrorTooBig"
		case SpawnErrorTxtbusy: return "SpawnErrorTxtbusy"
		default: return fmt.Sprintf("SpawnError(%d)", e)
	}
}

// TestFileType wraps GTestFileType
//
// The type of file to return the filename for, when used with
// [func@GLib.test_build_filename].
// 
// These two options correspond rather directly to the 'dist' and
// 'built' terminology that automake uses and are explicitly used to
// distinguish between the 'srcdir' and 'builddir' being separate. All
// files in your project should either be dist (in the `EXTRA_DIST` or
// `dist_schema_DATA` sense, in which case they will always be in the
// srcdir) or built (in the `BUILT_SOURCES` sense, in which case they
// will always be in the builddir).
// 
// Note: As a general rule of automake, files that are generated only as
// part of the build-from-git process (but then are distributed with the
// tarball) always go in srcdir (even if doing a srcdir != builddir
// build from git) and are considered as distributed files.
// 
// The same principles apply for other build systems, such as meson.
type TestFileType C.int

const (
	// TestDist wraps G_TEST_DIST
	//
	// a file that was included in the distribution tarball
	TestDist TestFileType = 0
	// TestBuilt wraps G_TEST_BUILT
	//
	// a file that was built on the compiling machine
	TestBuilt TestFileType = 1
)


func (e TestFileType) String() string {
	switch e {
		case TestBuilt: return "TestBuilt"
		case TestDist: return "TestDist"
		default: return fmt.Sprintf("TestFileType(%d)", e)
	}
}

// TestLogType wraps GTestLogType
type TestLogType C.int

const (
	// TestLogNone wraps G_TEST_LOG_NONE
	TestLogNone TestLogType = 0
	// TestLogError wraps G_TEST_LOG_ERROR
	TestLogError TestLogType = 1
	// TestLogStartBinary wraps G_TEST_LOG_START_BINARY
	TestLogStartBinary TestLogType = 2
	// TestLogListCase wraps G_TEST_LOG_LIST_CASE
	TestLogListCase TestLogType = 3
	// TestLogSkipCase wraps G_TEST_LOG_SKIP_CASE
	TestLogSkipCase TestLogType = 4
	// TestLogStartCase wraps G_TEST_LOG_START_CASE
	TestLogStartCase TestLogType = 5
	// TestLogStopCase wraps G_TEST_LOG_STOP_CASE
	TestLogStopCase TestLogType = 6
	// TestLogMinResult wraps G_TEST_LOG_MIN_RESULT
	TestLogMinResult TestLogType = 7
	// TestLogMaxResult wraps G_TEST_LOG_MAX_RESULT
	TestLogMaxResult TestLogType = 8
	// TestLogMessage wraps G_TEST_LOG_MESSAGE
	TestLogMessage TestLogType = 9
	// TestLogStartSuite wraps G_TEST_LOG_START_SUITE
	TestLogStartSuite TestLogType = 10
	// TestLogStopSuite wraps G_TEST_LOG_STOP_SUITE
	TestLogStopSuite TestLogType = 11
)


func (e TestLogType) String() string {
	switch e {
		case TestLogError: return "TestLogError"
		case TestLogListCase: return "TestLogListCase"
		case TestLogMaxResult: return "TestLogMaxResult"
		case TestLogMessage: return "TestLogMessage"
		case TestLogMinResult: return "TestLogMinResult"
		case TestLogNone: return "TestLogNone"
		case TestLogSkipCase: return "TestLogSkipCase"
		case TestLogStartBinary: return "TestLogStartBinary"
		case TestLogStartCase: return "TestLogStartCase"
		case TestLogStartSuite: return "TestLogStartSuite"
		case TestLogStopCase: return "TestLogStopCase"
		case TestLogStopSuite: return "TestLogStopSuite"
		default: return fmt.Sprintf("TestLogType(%d)", e)
	}
}

// TestResult wraps GTestResult
type TestResult C.int

const (
	// TestRunSuccess wraps G_TEST_RUN_SUCCESS
	TestRunSuccess TestResult = 0
	// TestRunSkipped wraps G_TEST_RUN_SKIPPED
	TestRunSkipped TestResult = 1
	// TestRunFailure wraps G_TEST_RUN_FAILURE
	TestRunFailure TestResult = 2
	// TestRunIncomplete wraps G_TEST_RUN_INCOMPLETE
	TestRunIncomplete TestResult = 3
)


func (e TestResult) String() string {
	switch e {
		case TestRunFailure: return "TestRunFailure"
		case TestRunIncomplete: return "TestRunIncomplete"
		case TestRunSkipped: return "TestRunSkipped"
		case TestRunSuccess: return "TestRunSuccess"
		default: return fmt.Sprintf("TestResult(%d)", e)
	}
}

// ThreadError wraps GThreadError
//
// Possible errors of thread related functions.
type ThreadError C.int

const (
	// ThreadErrorAgain wraps G_THREAD_ERROR_AGAIN
	//
	// a thread couldn't be created due to resource
	//                        shortage. Try again later.
	ThreadErrorAgain ThreadError = 0
)


func (e ThreadError) String() string {
	switch e {
		case ThreadErrorAgain: return "ThreadErrorAgain"
		default: return fmt.Sprintf("ThreadError(%d)", e)
	}
}

// TimeType wraps GTimeType
//
// Disambiguates a given time in two ways.
// 
// First, specifies if the given time is in universal or local time.
// 
// Second, if the time is in local time, specifies if it is local
// standard time or local daylight time.  This is important for the case
// where the same local time occurs twice (during daylight savings time
// transitions, for example).
type TimeType C.int

const (
	// TimeTypeStandard wraps G_TIME_TYPE_STANDARD
	//
	// the time is in local standard time
	TimeTypeStandard TimeType = 0
	// TimeTypeDaylight wraps G_TIME_TYPE_DAYLIGHT
	//
	// the time is in local daylight time
	TimeTypeDaylight TimeType = 1
	// TimeTypeUniversal wraps G_TIME_TYPE_UNIVERSAL
	//
	// the time is in UTC
	TimeTypeUniversal TimeType = 2
)


func (e TimeType) String() string {
	switch e {
		case TimeTypeDaylight: return "TimeTypeDaylight"
		case TimeTypeStandard: return "TimeTypeStandard"
		case TimeTypeUniversal: return "TimeTypeUniversal"
		default: return fmt.Sprintf("TimeType(%d)", e)
	}
}

// TokenType wraps GTokenType
//
// The possible types of token returned from each
// g_scanner_get_next_token() call.
type TokenType C.int

const (
	// TokenEOF wraps G_TOKEN_EOF
	//
	// the end of the file
	TokenEOF TokenType = 0
	// TokenLeftParen wraps G_TOKEN_LEFT_PAREN
	//
	// a '(' character
	TokenLeftParen TokenType = 40
	// TokenRightParen wraps G_TOKEN_RIGHT_PAREN
	//
	// a ')' character
	TokenRightParen TokenType = 41
	// TokenLeftCurly wraps G_TOKEN_LEFT_CURLY
	//
	// a '{' character
	TokenLeftCurly TokenType = 123
	// TokenRightCurly wraps G_TOKEN_RIGHT_CURLY
	//
	// a '}' character
	TokenRightCurly TokenType = 125
	// TokenLeftBrace wraps G_TOKEN_LEFT_BRACE
	//
	// a '[' character
	TokenLeftBrace TokenType = 91
	// TokenRightBrace wraps G_TOKEN_RIGHT_BRACE
	//
	// a ']' character
	TokenRightBrace TokenType = 93
	// TokenEqualSign wraps G_TOKEN_EQUAL_SIGN
	//
	// a '=' character
	TokenEqualSign TokenType = 61
	// TokenComma wraps G_TOKEN_COMMA
	//
	// a ',' character
	TokenComma TokenType = 44
	// TokenNone wraps G_TOKEN_NONE
	//
	// not a token
	TokenNone TokenType = 256
	// TokenError wraps G_TOKEN_ERROR
	//
	// an error occurred
	TokenError TokenType = 257
	// TokenChar wraps G_TOKEN_CHAR
	//
	// a character
	TokenChar TokenType = 258
	// TokenBinary wraps G_TOKEN_BINARY
	//
	// a binary integer
	TokenBinary TokenType = 259
	// TokenOctal wraps G_TOKEN_OCTAL
	//
	// an octal integer
	TokenOctal TokenType = 260
	// TokenInt wraps G_TOKEN_INT
	//
	// an integer
	TokenInt TokenType = 261
	// TokenHex wraps G_TOKEN_HEX
	//
	// a hex integer
	TokenHex TokenType = 262
	// TokenFloat wraps G_TOKEN_FLOAT
	//
	// a floating point number
	TokenFloat TokenType = 263
	// TokenString wraps G_TOKEN_STRING
	//
	// a string
	TokenString TokenType = 264
	// TokenSymbol wraps G_TOKEN_SYMBOL
	//
	// a symbol
	TokenSymbol TokenType = 265
	// TokenIdentifier wraps G_TOKEN_IDENTIFIER
	//
	// an identifier
	TokenIdentifier TokenType = 266
	// TokenIdentifierNull wraps G_TOKEN_IDENTIFIER_NULL
	//
	// a null identifier
	TokenIdentifierNull TokenType = 267
	// TokenCommentSingle wraps G_TOKEN_COMMENT_SINGLE
	//
	// one line comment
	TokenCommentSingle TokenType = 268
	// TokenCommentMulti wraps G_TOKEN_COMMENT_MULTI
	//
	// multi line comment
	TokenCommentMulti TokenType = 269
)


func (e TokenType) String() string {
	switch e {
		case TokenBinary: return "TokenBinary"
		case TokenChar: return "TokenChar"
		case TokenComma: return "TokenComma"
		case TokenCommentMulti: return "TokenCommentMulti"
		case TokenCommentSingle: return "TokenCommentSingle"
		case TokenEOF: return "TokenEOF"
		case TokenEqualSign: return "TokenEqualSign"
		case TokenError: return "TokenError"
		case TokenFloat: return "TokenFloat"
		case TokenHex: return "TokenHex"
		case TokenIdentifier: return "TokenIdentifier"
		case TokenIdentifierNull: return "TokenIdentifierNull"
		case TokenInt: return "TokenInt"
		case TokenLeftBrace: return "TokenLeftBrace"
		case TokenLeftCurly: return "TokenLeftCurly"
		case TokenLeftParen: return "TokenLeftParen"
		case TokenNone: return "TokenNone"
		case TokenOctal: return "TokenOctal"
		case TokenRightBrace: return "TokenRightBrace"
		case TokenRightCurly: return "TokenRightCurly"
		case TokenRightParen: return "TokenRightParen"
		case TokenString: return "TokenString"
		case TokenSymbol: return "TokenSymbol"
		default: return fmt.Sprintf("TokenType(%d)", e)
	}
}

// TraverseType wraps GTraverseType
//
// Specifies the type of traversal performed by g_tree_traverse(),
// g_node_traverse() and g_node_find().
// 
// The different orders are illustrated here:
// 
// - In order: A, B, C, D, E, F, G, H, I
//   &lt;picture&gt;
//     &lt;source srcset="Sorted_binary_tree_inorder-dark.svg"
//      media="(prefers-color-scheme: dark)"&gt;
//     &lt;img src="Sorted_binary_tree_inorder.svg"
//      alt="Sorted binary tree, in-order traversal"&gt;
//   &lt;/picture&gt;
// - Pre order: F, B, A, D, C, E, G, I, H
//   &lt;picture&gt;
//     &lt;source srcset="Sorted_binary_tree_preorder-dark.svg"
//      media="(prefers-color-scheme: dark)"&gt;
//     &lt;img src="Sorted_binary_tree_preorder.svg"
//      alt="Sorted binary tree, pre-order traversal"&gt;
//   &lt;/picture&gt;
// - Post order: A, C, E, D, B, H, I, G, F
//   &lt;picture&gt;
//     &lt;source srcset="Sorted_binary_tree_postorder-dark.svg"
//      media="(prefers-color-scheme: dark)"&gt;
//     &lt;img src="Sorted_binary_tree_postorder.svg"
//      alt="Sorted binary tree, post-order traversal"&gt;
//   &lt;/picture&gt;
// - Level order: F, B, G, A, D, I, C, E, H
//   &lt;picture&gt;
//     &lt;source srcset="Sorted_binary_tree_breadth-first_traversal-dark.svg"
//      media="(prefers-color-scheme: dark)"&gt;
//     &lt;img src="Sorted_binary_tree_breadth-first_traversal.svg"
//      alt="Sorted binary tree, breadth-first level order traversal"&gt;
//   &lt;/picture&gt;
type TraverseType C.int

const (
	// InOrder wraps G_IN_ORDER
	//
	// visits a node's left child first, then the node itself,
	//              then its right child. This is the one to use if you
	//              want the output sorted according to the compare
	//              function.
	InOrder TraverseType = 0
	// PreOrder wraps G_PRE_ORDER
	//
	// visits a node, then its children.
	PreOrder TraverseType = 1
	// PostOrder wraps G_POST_ORDER
	//
	// visits the node's children, then the node itself.
	PostOrder TraverseType = 2
	// LevelOrder wraps G_LEVEL_ORDER
	//
	// is not implemented for
	//              [balanced binary trees](data-structures.html#binary-trees).
	//              For [n-ary trees](data-structures.html#n-ary-trees), it
	//              visits the root node first, then its children, then
	//              its grandchildren, and so on. Note that this is less
	//              efficient than the other orders.
	LevelOrder TraverseType = 3
)


func (e TraverseType) String() string {
	switch e {
		case InOrder: return "InOrder"
		case LevelOrder: return "LevelOrder"
		case PostOrder: return "PostOrder"
		case PreOrder: return "PreOrder"
		default: return fmt.Sprintf("TraverseType(%d)", e)
	}
}

// UnicodeBreakType wraps GUnicodeBreakType
//
// These are the possible line break classifications.
// 
// Since new Unicode versions may add new types here, applications should be ready
// to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.
// 
// See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/).
type UnicodeBreakType C.int

const (
	// UnicodeBreakMandatory wraps G_UNICODE_BREAK_MANDATORY
	//
	// Mandatory Break (BK)
	UnicodeBreakMandatory UnicodeBreakType = 0
	// UnicodeBreakCarriageReturn wraps G_UNICODE_BREAK_CARRIAGE_RETURN
	//
	// Carriage Return (CR)
	UnicodeBreakCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakLineFeed wraps G_UNICODE_BREAK_LINE_FEED
	//
	// Line Feed (LF)
	UnicodeBreakLineFeed UnicodeBreakType = 2
	// UnicodeBreakCombiningMark wraps G_UNICODE_BREAK_COMBINING_MARK
	//
	// Attached Characters and Combining Marks (CM)
	UnicodeBreakCombiningMark UnicodeBreakType = 3
	// UnicodeBreakSurrogate wraps G_UNICODE_BREAK_SURROGATE
	//
	// Surrogates (SG)
	UnicodeBreakSurrogate UnicodeBreakType = 4
	// UnicodeBreakZeroWidthSpace wraps G_UNICODE_BREAK_ZERO_WIDTH_SPACE
	//
	// Zero Width Space (ZW)
	UnicodeBreakZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakInseparable wraps G_UNICODE_BREAK_INSEPARABLE
	//
	// Inseparable (IN)
	UnicodeBreakInseparable UnicodeBreakType = 6
	// UnicodeBreakNonBreakingGlue wraps G_UNICODE_BREAK_NON_BREAKING_GLUE
	//
	// Non-breaking ("Glue") (GL)
	UnicodeBreakNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakContingent wraps G_UNICODE_BREAK_CONTINGENT
	//
	// Contingent Break Opportunity (CB)
	UnicodeBreakContingent UnicodeBreakType = 8
	// UnicodeBreakSpace wraps G_UNICODE_BREAK_SPACE
	//
	// Space (SP)
	UnicodeBreakSpace UnicodeBreakType = 9
	// UnicodeBreakAfter wraps G_UNICODE_BREAK_AFTER
	//
	// Break Opportunity After (BA)
	UnicodeBreakAfter UnicodeBreakType = 10
	// UnicodeBreakBefore wraps G_UNICODE_BREAK_BEFORE
	//
	// Break Opportunity Before (BB)
	UnicodeBreakBefore UnicodeBreakType = 11
	// UnicodeBreakBeforeAndAfter wraps G_UNICODE_BREAK_BEFORE_AND_AFTER
	//
	// Break Opportunity Before and After (B2)
	UnicodeBreakBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakHyphen wraps G_UNICODE_BREAK_HYPHEN
	//
	// Hyphen (HY)
	UnicodeBreakHyphen UnicodeBreakType = 13
	// UnicodeBreakNonStarter wraps G_UNICODE_BREAK_NON_STARTER
	//
	// Nonstarter (NS)
	UnicodeBreakNonStarter UnicodeBreakType = 14
	// UnicodeBreakOpenPunctuation wraps G_UNICODE_BREAK_OPEN_PUNCTUATION
	//
	// Opening Punctuation (OP)
	UnicodeBreakOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakClosePunctuation wraps G_UNICODE_BREAK_CLOSE_PUNCTUATION
	//
	// Closing Punctuation (CL)
	UnicodeBreakClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakQuotation wraps G_UNICODE_BREAK_QUOTATION
	//
	// Ambiguous Quotation (QU)
	UnicodeBreakQuotation UnicodeBreakType = 17
	// UnicodeBreakExclamation wraps G_UNICODE_BREAK_EXCLAMATION
	//
	// Exclamation/Interrogation (EX)
	UnicodeBreakExclamation UnicodeBreakType = 18
	// UnicodeBreakIdeographic wraps G_UNICODE_BREAK_IDEOGRAPHIC
	//
	// Ideographic (ID)
	UnicodeBreakIdeographic UnicodeBreakType = 19
	// UnicodeBreakNumeric wraps G_UNICODE_BREAK_NUMERIC
	//
	// Numeric (NU)
	UnicodeBreakNumeric UnicodeBreakType = 20
	// UnicodeBreakInfixSeparator wraps G_UNICODE_BREAK_INFIX_SEPARATOR
	//
	// Infix Separator (Numeric) (IS)
	UnicodeBreakInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakSymbol wraps G_UNICODE_BREAK_SYMBOL
	//
	// Symbols Allowing Break After (SY)
	UnicodeBreakSymbol UnicodeBreakType = 22
	// UnicodeBreakAlphabetic wraps G_UNICODE_BREAK_ALPHABETIC
	//
	// Ordinary Alphabetic and Symbol Characters (AL)
	UnicodeBreakAlphabetic UnicodeBreakType = 23
	// UnicodeBreakPrefix wraps G_UNICODE_BREAK_PREFIX
	//
	// Prefix (Numeric) (PR)
	UnicodeBreakPrefix UnicodeBreakType = 24
	// UnicodeBreakPostfix wraps G_UNICODE_BREAK_POSTFIX
	//
	// Postfix (Numeric) (PO)
	UnicodeBreakPostfix UnicodeBreakType = 25
	// UnicodeBreakComplexContext wraps G_UNICODE_BREAK_COMPLEX_CONTEXT
	//
	// Complex Content Dependent (South East Asian) (SA)
	UnicodeBreakComplexContext UnicodeBreakType = 26
	// UnicodeBreakAmbiguous wraps G_UNICODE_BREAK_AMBIGUOUS
	//
	// Ambiguous (Alphabetic or Ideographic) (AI)
	UnicodeBreakAmbiguous UnicodeBreakType = 27
	// UnicodeBreakUnknown wraps G_UNICODE_BREAK_UNKNOWN
	//
	// Unknown (XX)
	UnicodeBreakUnknown UnicodeBreakType = 28
	// UnicodeBreakNextLine wraps G_UNICODE_BREAK_NEXT_LINE
	//
	// Next Line (NL)
	UnicodeBreakNextLine UnicodeBreakType = 29
	// UnicodeBreakWordJoiner wraps G_UNICODE_BREAK_WORD_JOINER
	//
	// Word Joiner (WJ)
	UnicodeBreakWordJoiner UnicodeBreakType = 30
	// UnicodeBreakHangulLJamo wraps G_UNICODE_BREAK_HANGUL_L_JAMO
	//
	// Hangul L Jamo (JL)
	UnicodeBreakHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakHangulVJamo wraps G_UNICODE_BREAK_HANGUL_V_JAMO
	//
	// Hangul V Jamo (JV)
	UnicodeBreakHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakHangulTJamo wraps G_UNICODE_BREAK_HANGUL_T_JAMO
	//
	// Hangul T Jamo (JT)
	UnicodeBreakHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakHangulLvSyllable wraps G_UNICODE_BREAK_HANGUL_LV_SYLLABLE
	//
	// Hangul LV Syllable (H2)
	UnicodeBreakHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakHangulLvtSyllable wraps G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE
	//
	// Hangul LVT Syllable (H3)
	UnicodeBreakHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakCloseParanthesis wraps G_UNICODE_BREAK_CLOSE_PARANTHESIS
	//
	// Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.
	UnicodeBreakCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakCloseParenthesis wraps G_UNICODE_BREAK_CLOSE_PARENTHESIS
	//
	// Closing Parenthesis (CP). Since 2.70
	UnicodeBreakCloseParenthesis UnicodeBreakType = 36
	// UnicodeBreakConditionalJapaneseStarter wraps G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER
	//
	// Conditional Japanese Starter (CJ). Since: 2.32
	UnicodeBreakConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakHebrewLetter wraps G_UNICODE_BREAK_HEBREW_LETTER
	//
	// Hebrew Letter (HL). Since: 2.32
	UnicodeBreakHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakRegionalIndicator wraps G_UNICODE_BREAK_REGIONAL_INDICATOR
	//
	// Regional Indicator (RI). Since: 2.36
	UnicodeBreakRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakEmojiBase wraps G_UNICODE_BREAK_EMOJI_BASE
	//
	// Emoji Base (EB). Since: 2.50
	UnicodeBreakEmojiBase UnicodeBreakType = 40
	// UnicodeBreakEmojiModifier wraps G_UNICODE_BREAK_EMOJI_MODIFIER
	//
	// Emoji Modifier (EM). Since: 2.50
	UnicodeBreakEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakZeroWidthJoiner wraps G_UNICODE_BREAK_ZERO_WIDTH_JOINER
	//
	// Zero Width Joiner (ZWJ). Since: 2.50
	UnicodeBreakZeroWidthJoiner UnicodeBreakType = 42
	// UnicodeBreakAksara wraps G_UNICODE_BREAK_AKSARA
	//
	// Aksara (AK). Since: 2.80
	UnicodeBreakAksara UnicodeBreakType = 43
	// UnicodeBreakAksaraPreBase wraps G_UNICODE_BREAK_AKSARA_PRE_BASE
	//
	// Aksara Pre-Base (AP). Since: 2.80
	UnicodeBreakAksaraPreBase UnicodeBreakType = 44
	// UnicodeBreakAksaraStart wraps G_UNICODE_BREAK_AKSARA_START
	//
	// Aksara Start (AS). Since: 2.80
	UnicodeBreakAksaraStart UnicodeBreakType = 45
	// UnicodeBreakViramaFinal wraps G_UNICODE_BREAK_VIRAMA_FINAL
	//
	// Virama Final (VF). Since: 2.80
	UnicodeBreakViramaFinal UnicodeBreakType = 46
	// UnicodeBreakVirama wraps G_UNICODE_BREAK_VIRAMA
	//
	// Virama (VI). Since: 2.80
	UnicodeBreakVirama UnicodeBreakType = 47
)


func (e UnicodeBreakType) String() string {
	switch e {
		case UnicodeBreakAfter: return "UnicodeBreakAfter"
		case UnicodeBreakAksara: return "UnicodeBreakAksara"
		case UnicodeBreakAksaraPreBase: return "UnicodeBreakAksaraPreBase"
		case UnicodeBreakAksaraStart: return "UnicodeBreakAksaraStart"
		case UnicodeBreakAlphabetic: return "UnicodeBreakAlphabetic"
		case UnicodeBreakAmbiguous: return "UnicodeBreakAmbiguous"
		case UnicodeBreakBefore: return "UnicodeBreakBefore"
		case UnicodeBreakBeforeAndAfter: return "UnicodeBreakBeforeAndAfter"
		case UnicodeBreakCarriageReturn: return "UnicodeBreakCarriageReturn"
		case UnicodeBreakCloseParanthesis: return "UnicodeBreakCloseParanthesis"
		case UnicodeBreakClosePunctuation: return "UnicodeBreakClosePunctuation"
		case UnicodeBreakCombiningMark: return "UnicodeBreakCombiningMark"
		case UnicodeBreakComplexContext: return "UnicodeBreakComplexContext"
		case UnicodeBreakConditionalJapaneseStarter: return "UnicodeBreakConditionalJapaneseStarter"
		case UnicodeBreakContingent: return "UnicodeBreakContingent"
		case UnicodeBreakEmojiBase: return "UnicodeBreakEmojiBase"
		case UnicodeBreakEmojiModifier: return "UnicodeBreakEmojiModifier"
		case UnicodeBreakExclamation: return "UnicodeBreakExclamation"
		case UnicodeBreakHangulLJamo: return "UnicodeBreakHangulLJamo"
		case UnicodeBreakHangulLvSyllable: return "UnicodeBreakHangulLvSyllable"
		case UnicodeBreakHangulLvtSyllable: return "UnicodeBreakHangulLvtSyllable"
		case UnicodeBreakHangulTJamo: return "UnicodeBreakHangulTJamo"
		case UnicodeBreakHangulVJamo: return "UnicodeBreakHangulVJamo"
		case UnicodeBreakHebrewLetter: return "UnicodeBreakHebrewLetter"
		case UnicodeBreakHyphen: return "UnicodeBreakHyphen"
		case UnicodeBreakIdeographic: return "UnicodeBreakIdeographic"
		case UnicodeBreakInfixSeparator: return "UnicodeBreakInfixSeparator"
		case UnicodeBreakInseparable: return "UnicodeBreakInseparable"
		case UnicodeBreakLineFeed: return "UnicodeBreakLineFeed"
		case UnicodeBreakMandatory: return "UnicodeBreakMandatory"
		case UnicodeBreakNextLine: return "UnicodeBreakNextLine"
		case UnicodeBreakNonBreakingGlue: return "UnicodeBreakNonBreakingGlue"
		case UnicodeBreakNonStarter: return "UnicodeBreakNonStarter"
		case UnicodeBreakNumeric: return "UnicodeBreakNumeric"
		case UnicodeBreakOpenPunctuation: return "UnicodeBreakOpenPunctuation"
		case UnicodeBreakPostfix: return "UnicodeBreakPostfix"
		case UnicodeBreakPrefix: return "UnicodeBreakPrefix"
		case UnicodeBreakQuotation: return "UnicodeBreakQuotation"
		case UnicodeBreakRegionalIndicator: return "UnicodeBreakRegionalIndicator"
		case UnicodeBreakSpace: return "UnicodeBreakSpace"
		case UnicodeBreakSurrogate: return "UnicodeBreakSurrogate"
		case UnicodeBreakSymbol: return "UnicodeBreakSymbol"
		case UnicodeBreakUnknown: return "UnicodeBreakUnknown"
		case UnicodeBreakVirama: return "UnicodeBreakVirama"
		case UnicodeBreakViramaFinal: return "UnicodeBreakViramaFinal"
		case UnicodeBreakWordJoiner: return "UnicodeBreakWordJoiner"
		case UnicodeBreakZeroWidthJoiner: return "UnicodeBreakZeroWidthJoiner"
		case UnicodeBreakZeroWidthSpace: return "UnicodeBreakZeroWidthSpace"
		default: return fmt.Sprintf("UnicodeBreakType(%d)", e)
	}
}

// UnicodeScript wraps GUnicodeScript
//
// The #GUnicodeScript enumeration identifies different writing
// systems. The values correspond to the names as defined in the
// Unicode standard. The enumeration has been added in GLib 2.14,
// and is interchangeable with #PangoScript.
// 
// Note that new types may be added in the future. Applications
// should be ready to handle unknown values.
// See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
type UnicodeScript C.int

const (
	// UnicodeScriptInvalidCode wraps G_UNICODE_SCRIPT_INVALID_CODE
	//
	// a value never returned from g_unichar_get_script()
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon wraps G_UNICODE_SCRIPT_COMMON
	//
	// a character used by multiple different scripts
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited wraps G_UNICODE_SCRIPT_INHERITED
	//
	// a mark glyph that takes its script from the
	//                               base glyph to which it is attached
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic wraps G_UNICODE_SCRIPT_ARABIC
	//
	// Arabic
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian wraps G_UNICODE_SCRIPT_ARMENIAN
	//
	// Armenian
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali wraps G_UNICODE_SCRIPT_BENGALI
	//
	// Bengali
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo wraps G_UNICODE_SCRIPT_BOPOMOFO
	//
	// Bopomofo
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee wraps G_UNICODE_SCRIPT_CHEROKEE
	//
	// Cherokee
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic wraps G_UNICODE_SCRIPT_COPTIC
	//
	// Coptic
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic wraps G_UNICODE_SCRIPT_CYRILLIC
	//
	// Cyrillic
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret wraps G_UNICODE_SCRIPT_DESERET
	//
	// Deseret
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari wraps G_UNICODE_SCRIPT_DEVANAGARI
	//
	// Devanagari
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic wraps G_UNICODE_SCRIPT_ETHIOPIC
	//
	// Ethiopic
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian wraps G_UNICODE_SCRIPT_GEORGIAN
	//
	// Georgian
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic wraps G_UNICODE_SCRIPT_GOTHIC
	//
	// Gothic
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek wraps G_UNICODE_SCRIPT_GREEK
	//
	// Greek
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati wraps G_UNICODE_SCRIPT_GUJARATI
	//
	// Gujarati
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi wraps G_UNICODE_SCRIPT_GURMUKHI
	//
	// Gurmukhi
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan wraps G_UNICODE_SCRIPT_HAN
	//
	// Han
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul wraps G_UNICODE_SCRIPT_HANGUL
	//
	// Hangul
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew wraps G_UNICODE_SCRIPT_HEBREW
	//
	// Hebrew
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana wraps G_UNICODE_SCRIPT_HIRAGANA
	//
	// Hiragana
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada wraps G_UNICODE_SCRIPT_KANNADA
	//
	// Kannada
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana wraps G_UNICODE_SCRIPT_KATAKANA
	//
	// Katakana
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer wraps G_UNICODE_SCRIPT_KHMER
	//
	// Khmer
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao wraps G_UNICODE_SCRIPT_LAO
	//
	// Lao
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin wraps G_UNICODE_SCRIPT_LATIN
	//
	// Latin
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam wraps G_UNICODE_SCRIPT_MALAYALAM
	//
	// Malayalam
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian wraps G_UNICODE_SCRIPT_MONGOLIAN
	//
	// Mongolian
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar wraps G_UNICODE_SCRIPT_MYANMAR
	//
	// Myanmar
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham wraps G_UNICODE_SCRIPT_OGHAM
	//
	// Ogham
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic wraps G_UNICODE_SCRIPT_OLD_ITALIC
	//
	// Old Italic
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya wraps G_UNICODE_SCRIPT_ORIYA
	//
	// Oriya
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic wraps G_UNICODE_SCRIPT_RUNIC
	//
	// Runic
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala wraps G_UNICODE_SCRIPT_SINHALA
	//
	// Sinhala
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac wraps G_UNICODE_SCRIPT_SYRIAC
	//
	// Syriac
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil wraps G_UNICODE_SCRIPT_TAMIL
	//
	// Tamil
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu wraps G_UNICODE_SCRIPT_TELUGU
	//
	// Telugu
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana wraps G_UNICODE_SCRIPT_THAANA
	//
	// Thaana
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai wraps G_UNICODE_SCRIPT_THAI
	//
	// Thai
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan wraps G_UNICODE_SCRIPT_TIBETAN
	//
	// Tibetan
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal wraps G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL
	//
	// Canadian Aboriginal
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi wraps G_UNICODE_SCRIPT_YI
	//
	// Yi
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog wraps G_UNICODE_SCRIPT_TAGALOG
	//
	// Tagalog
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo wraps G_UNICODE_SCRIPT_HANUNOO
	//
	// Hanunoo
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid wraps G_UNICODE_SCRIPT_BUHID
	//
	// Buhid
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa wraps G_UNICODE_SCRIPT_TAGBANWA
	//
	// Tagbanwa
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille wraps G_UNICODE_SCRIPT_BRAILLE
	//
	// Braille
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot wraps G_UNICODE_SCRIPT_CYPRIOT
	//
	// Cypriot
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu wraps G_UNICODE_SCRIPT_LIMBU
	//
	// Limbu
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya wraps G_UNICODE_SCRIPT_OSMANYA
	//
	// Osmanya
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian wraps G_UNICODE_SCRIPT_SHAVIAN
	//
	// Shavian
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB wraps G_UNICODE_SCRIPT_LINEAR_B
	//
	// Linear B
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe wraps G_UNICODE_SCRIPT_TAI_LE
	//
	// Tai Le
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic wraps G_UNICODE_SCRIPT_UGARITIC
	//
	// Ugaritic
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue wraps G_UNICODE_SCRIPT_NEW_TAI_LUE
	//
	// New Tai Lue
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese wraps G_UNICODE_SCRIPT_BUGINESE
	//
	// Buginese
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic wraps G_UNICODE_SCRIPT_GLAGOLITIC
	//
	// Glagolitic
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh wraps G_UNICODE_SCRIPT_TIFINAGH
	//
	// Tifinagh
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri wraps G_UNICODE_SCRIPT_SYLOTI_NAGRI
	//
	// Syloti Nagri
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian wraps G_UNICODE_SCRIPT_OLD_PERSIAN
	//
	// Old Persian
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi wraps G_UNICODE_SCRIPT_KHAROSHTHI
	//
	// Kharoshthi
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown wraps G_UNICODE_SCRIPT_UNKNOWN
	//
	// an unassigned code point
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese wraps G_UNICODE_SCRIPT_BALINESE
	//
	// Balinese
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform wraps G_UNICODE_SCRIPT_CUNEIFORM
	//
	// Cuneiform
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician wraps G_UNICODE_SCRIPT_PHOENICIAN
	//
	// Phoenician
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa wraps G_UNICODE_SCRIPT_PHAGS_PA
	//
	// Phags-pa
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko wraps G_UNICODE_SCRIPT_NKO
	//
	// N'Ko
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi wraps G_UNICODE_SCRIPT_KAYAH_LI
	//
	// Kayah Li. Since 2.16.3
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha wraps G_UNICODE_SCRIPT_LEPCHA
	//
	// Lepcha. Since 2.16.3
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang wraps G_UNICODE_SCRIPT_REJANG
	//
	// Rejang. Since 2.16.3
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese wraps G_UNICODE_SCRIPT_SUNDANESE
	//
	// Sundanese. Since 2.16.3
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra wraps G_UNICODE_SCRIPT_SAURASHTRA
	//
	// Saurashtra. Since 2.16.3
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham wraps G_UNICODE_SCRIPT_CHAM
	//
	// Cham. Since 2.16.3
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki wraps G_UNICODE_SCRIPT_OL_CHIKI
	//
	// Ol Chiki. Since 2.16.3
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai wraps G_UNICODE_SCRIPT_VAI
	//
	// Vai. Since 2.16.3
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian wraps G_UNICODE_SCRIPT_CARIAN
	//
	// Carian. Since 2.16.3
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian wraps G_UNICODE_SCRIPT_LYCIAN
	//
	// Lycian. Since 2.16.3
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian wraps G_UNICODE_SCRIPT_LYDIAN
	//
	// Lydian. Since 2.16.3
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan wraps G_UNICODE_SCRIPT_AVESTAN
	//
	// Avestan. Since 2.26
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum wraps G_UNICODE_SCRIPT_BAMUM
	//
	// Bamum. Since 2.26
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs wraps G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS
	//
	// Egyptian Hieroglpyhs. Since 2.26
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic wraps G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC
	//
	// Imperial Aramaic. Since 2.26
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi wraps G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI
	//
	// Inscriptional Pahlavi. Since 2.26
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian wraps G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN
	//
	// Inscriptional Parthian. Since 2.26
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese wraps G_UNICODE_SCRIPT_JAVANESE
	//
	// Javanese. Since 2.26
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi wraps G_UNICODE_SCRIPT_KAITHI
	//
	// Kaithi. Since 2.26
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu wraps G_UNICODE_SCRIPT_LISU
	//
	// Lisu. Since 2.26
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek wraps G_UNICODE_SCRIPT_MEETEI_MAYEK
	//
	// Meetei Mayek. Since 2.26
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian wraps G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN
	//
	// Old South Arabian. Since 2.26
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic wraps G_UNICODE_SCRIPT_OLD_TURKIC
	//
	// Old Turkic. Since 2.28
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan wraps G_UNICODE_SCRIPT_SAMARITAN
	//
	// Samaritan. Since 2.26
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham wraps G_UNICODE_SCRIPT_TAI_THAM
	//
	// Tai Tham. Since 2.26
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet wraps G_UNICODE_SCRIPT_TAI_VIET
	//
	// Tai Viet. Since 2.26
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak wraps G_UNICODE_SCRIPT_BATAK
	//
	// Batak. Since 2.28
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi wraps G_UNICODE_SCRIPT_BRAHMI
	//
	// Brahmi. Since 2.28
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic wraps G_UNICODE_SCRIPT_MANDAIC
	//
	// Mandaic. Since 2.28
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma wraps G_UNICODE_SCRIPT_CHAKMA
	//
	// Chakma. Since: 2.32
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive wraps G_UNICODE_SCRIPT_MEROITIC_CURSIVE
	//
	// Meroitic Cursive. Since: 2.32
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs wraps G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS
	//
	// Meroitic Hieroglyphs. Since: 2.32
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao wraps G_UNICODE_SCRIPT_MIAO
	//
	// Miao. Since: 2.32
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada wraps G_UNICODE_SCRIPT_SHARADA
	//
	// Sharada. Since: 2.32
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng wraps G_UNICODE_SCRIPT_SORA_SOMPENG
	//
	// Sora Sompeng. Since: 2.32
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri wraps G_UNICODE_SCRIPT_TAKRI
	//
	// Takri. Since: 2.32
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah wraps G_UNICODE_SCRIPT_BASSA_VAH
	//
	// Bassa. Since: 2.42
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian wraps G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN
	//
	// Caucasian Albanian. Since: 2.42
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan wraps G_UNICODE_SCRIPT_DUPLOYAN
	//
	// Duployan. Since: 2.42
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan wraps G_UNICODE_SCRIPT_ELBASAN
	//
	// Elbasan. Since: 2.42
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha wraps G_UNICODE_SCRIPT_GRANTHA
	//
	// Grantha. Since: 2.42
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki wraps G_UNICODE_SCRIPT_KHOJKI
	//
	// Kjohki. Since: 2.42
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi wraps G_UNICODE_SCRIPT_KHUDAWADI
	//
	// Khudawadi, Sindhi. Since: 2.42
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA wraps G_UNICODE_SCRIPT_LINEAR_A
	//
	// Linear A. Since: 2.42
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani wraps G_UNICODE_SCRIPT_MAHAJANI
	//
	// Mahajani. Since: 2.42
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean wraps G_UNICODE_SCRIPT_MANICHAEAN
	//
	// Manichaean. Since: 2.42
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui wraps G_UNICODE_SCRIPT_MENDE_KIKAKUI
	//
	// Mende Kikakui. Since: 2.42
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi wraps G_UNICODE_SCRIPT_MODI
	//
	// Modi. Since: 2.42
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro wraps G_UNICODE_SCRIPT_MRO
	//
	// Mro. Since: 2.42
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean wraps G_UNICODE_SCRIPT_NABATAEAN
	//
	// Nabataean. Since: 2.42
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian wraps G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN
	//
	// Old North Arabian. Since: 2.42
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic wraps G_UNICODE_SCRIPT_OLD_PERMIC
	//
	// Old Permic. Since: 2.42
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong wraps G_UNICODE_SCRIPT_PAHAWH_HMONG
	//
	// Pahawh Hmong. Since: 2.42
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene wraps G_UNICODE_SCRIPT_PALMYRENE
	//
	// Palmyrene. Since: 2.42
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau wraps G_UNICODE_SCRIPT_PAU_CIN_HAU
	//
	// Pau Cin Hau. Since: 2.42
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi wraps G_UNICODE_SCRIPT_PSALTER_PAHLAVI
	//
	// Psalter Pahlavi. Since: 2.42
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham wraps G_UNICODE_SCRIPT_SIDDHAM
	//
	// Siddham. Since: 2.42
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta wraps G_UNICODE_SCRIPT_TIRHUTA
	//
	// Tirhuta. Since: 2.42
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti wraps G_UNICODE_SCRIPT_WARANG_CITI
	//
	// Warang Citi. Since: 2.42
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom wraps G_UNICODE_SCRIPT_AHOM
	//
	// Ahom. Since: 2.48
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs wraps G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS
	//
	// Anatolian Hieroglyphs. Since: 2.48
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran wraps G_UNICODE_SCRIPT_HATRAN
	//
	// Hatran. Since: 2.48
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani wraps G_UNICODE_SCRIPT_MULTANI
	//
	// Multani. Since: 2.48
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian wraps G_UNICODE_SCRIPT_OLD_HUNGARIAN
	//
	// Old Hungarian. Since: 2.48
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting wraps G_UNICODE_SCRIPT_SIGNWRITING
	//
	// Signwriting. Since: 2.48
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam wraps G_UNICODE_SCRIPT_ADLAM
	//
	// Adlam. Since: 2.50
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki wraps G_UNICODE_SCRIPT_BHAIKSUKI
	//
	// Bhaiksuki. Since: 2.50
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen wraps G_UNICODE_SCRIPT_MARCHEN
	//
	// Marchen. Since: 2.50
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa wraps G_UNICODE_SCRIPT_NEWA
	//
	// Newa. Since: 2.50
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage wraps G_UNICODE_SCRIPT_OSAGE
	//
	// Osage. Since: 2.50
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut wraps G_UNICODE_SCRIPT_TANGUT
	//
	// Tangut. Since: 2.50
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi wraps G_UNICODE_SCRIPT_MASARAM_GONDI
	//
	// Masaram Gondi. Since: 2.54
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu wraps G_UNICODE_SCRIPT_NUSHU
	//
	// Nushu. Since: 2.54
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo wraps G_UNICODE_SCRIPT_SOYOMBO
	//
	// Soyombo. Since: 2.54
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare wraps G_UNICODE_SCRIPT_ZANABAZAR_SQUARE
	//
	// Zanabazar Square. Since: 2.54
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra wraps G_UNICODE_SCRIPT_DOGRA
	//
	// Dogra. Since: 2.58
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi wraps G_UNICODE_SCRIPT_GUNJALA_GONDI
	//
	// Gunjala Gondi. Since: 2.58
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya wraps G_UNICODE_SCRIPT_HANIFI_ROHINGYA
	//
	// Hanifi Rohingya. Since: 2.58
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar wraps G_UNICODE_SCRIPT_MAKASAR
	//
	// Makasar. Since: 2.58
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin wraps G_UNICODE_SCRIPT_MEDEFAIDRIN
	//
	// Medefaidrin. Since: 2.58
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian wraps G_UNICODE_SCRIPT_OLD_SOGDIAN
	//
	// Old Sogdian. Since: 2.58
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian wraps G_UNICODE_SCRIPT_SOGDIAN
	//
	// Sogdian. Since: 2.58
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic wraps G_UNICODE_SCRIPT_ELYMAIC
	//
	// Elym. Since: 2.62
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari wraps G_UNICODE_SCRIPT_NANDINAGARI
	//
	// Nand. Since: 2.62
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong wraps G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG
	//
	// Rohg. Since: 2.62
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho wraps G_UNICODE_SCRIPT_WANCHO
	//
	// Wcho. Since: 2.62
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian wraps G_UNICODE_SCRIPT_CHORASMIAN
	//
	// Chorasmian. Since: 2.66
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru wraps G_UNICODE_SCRIPT_DIVES_AKURU
	//
	// Dives Akuru. Since: 2.66
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript wraps G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT
	//
	// Khitan small script. Since: 2.66
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi wraps G_UNICODE_SCRIPT_YEZIDI
	//
	// Yezidi. Since: 2.66
	UnicodeScriptYezidi UnicodeScript = 156
	// UnicodeScriptCyproMinoan wraps G_UNICODE_SCRIPT_CYPRO_MINOAN
	//
	// Cypro-Minoan. Since: 2.72
	UnicodeScriptCyproMinoan UnicodeScript = 157
	// UnicodeScriptOldUyghur wraps G_UNICODE_SCRIPT_OLD_UYGHUR
	//
	// Old Uyghur. Since: 2.72
	UnicodeScriptOldUyghur UnicodeScript = 158
	// UnicodeScriptTangsa wraps G_UNICODE_SCRIPT_TANGSA
	//
	// Tangsa. Since: 2.72
	UnicodeScriptTangsa UnicodeScript = 159
	// UnicodeScriptToto wraps G_UNICODE_SCRIPT_TOTO
	//
	// Toto. Since: 2.72
	UnicodeScriptToto UnicodeScript = 160
	// UnicodeScriptVithkuqi wraps G_UNICODE_SCRIPT_VITHKUQI
	//
	// Vithkuqi. Since: 2.72
	UnicodeScriptVithkuqi UnicodeScript = 161
	// UnicodeScriptMath wraps G_UNICODE_SCRIPT_MATH
	//
	// Mathematical notation. Since: 2.72
	UnicodeScriptMath UnicodeScript = 162
	// UnicodeScriptKawi wraps G_UNICODE_SCRIPT_KAWI
	//
	// Kawi. Since 2.74
	UnicodeScriptKawi UnicodeScript = 163
	// UnicodeScriptNagMundari wraps G_UNICODE_SCRIPT_NAG_MUNDARI
	//
	// Nag Mundari. Since 2.74
	UnicodeScriptNagMundari UnicodeScript = 164
	// UnicodeScriptTodhri wraps G_UNICODE_SCRIPT_TODHRI
	//
	// Todhri. Since: 2.84
	UnicodeScriptTodhri UnicodeScript = 165
	// UnicodeScriptGaray wraps G_UNICODE_SCRIPT_GARAY
	//
	// Garay. Since: 2.84
	UnicodeScriptGaray UnicodeScript = 166
	// UnicodeScriptTuluTigalari wraps G_UNICODE_SCRIPT_TULU_TIGALARI
	//
	// Tulu-Tigalari. Since: 2.84
	UnicodeScriptTuluTigalari UnicodeScript = 167
	// UnicodeScriptSunuwar wraps G_UNICODE_SCRIPT_SUNUWAR
	//
	// Sunuwar. Since: 2.84
	UnicodeScriptSunuwar UnicodeScript = 168
	// UnicodeScriptGurungKhema wraps G_UNICODE_SCRIPT_GURUNG_KHEMA
	//
	// Gurung Khema. Since: 2.84
	UnicodeScriptGurungKhema UnicodeScript = 169
	// UnicodeScriptKiratRai wraps G_UNICODE_SCRIPT_KIRAT_RAI
	//
	// Kirat Rai. Since: 2.84
	UnicodeScriptKiratRai UnicodeScript = 170
	// UnicodeScriptOlOnal wraps G_UNICODE_SCRIPT_OL_ONAL
	//
	// Ol Onal. Since: 2.84
	UnicodeScriptOlOnal UnicodeScript = 171
)


func (e UnicodeScript) String() string {
	switch e {
		case UnicodeScriptAdlam: return "UnicodeScriptAdlam"
		case UnicodeScriptAhom: return "UnicodeScriptAhom"
		case UnicodeScriptAnatolianHieroglyphs: return "UnicodeScriptAnatolianHieroglyphs"
		case UnicodeScriptArabic: return "UnicodeScriptArabic"
		case UnicodeScriptArmenian: return "UnicodeScriptArmenian"
		case UnicodeScriptAvestan: return "UnicodeScriptAvestan"
		case UnicodeScriptBalinese: return "UnicodeScriptBalinese"
		case UnicodeScriptBamum: return "UnicodeScriptBamum"
		case UnicodeScriptBassaVah: return "UnicodeScriptBassaVah"
		case UnicodeScriptBatak: return "UnicodeScriptBatak"
		case UnicodeScriptBengali: return "UnicodeScriptBengali"
		case UnicodeScriptBhaiksuki: return "UnicodeScriptBhaiksuki"
		case UnicodeScriptBopomofo: return "UnicodeScriptBopomofo"
		case UnicodeScriptBrahmi: return "UnicodeScriptBrahmi"
		case UnicodeScriptBraille: return "UnicodeScriptBraille"
		case UnicodeScriptBuginese: return "UnicodeScriptBuginese"
		case UnicodeScriptBuhid: return "UnicodeScriptBuhid"
		case UnicodeScriptCanadianAboriginal: return "UnicodeScriptCanadianAboriginal"
		case UnicodeScriptCarian: return "UnicodeScriptCarian"
		case UnicodeScriptCaucasianAlbanian: return "UnicodeScriptCaucasianAlbanian"
		case UnicodeScriptChakma: return "UnicodeScriptChakma"
		case UnicodeScriptCham: return "UnicodeScriptCham"
		case UnicodeScriptCherokee: return "UnicodeScriptCherokee"
		case UnicodeScriptChorasmian: return "UnicodeScriptChorasmian"
		case UnicodeScriptCommon: return "UnicodeScriptCommon"
		case UnicodeScriptCoptic: return "UnicodeScriptCoptic"
		case UnicodeScriptCuneiform: return "UnicodeScriptCuneiform"
		case UnicodeScriptCypriot: return "UnicodeScriptCypriot"
		case UnicodeScriptCyproMinoan: return "UnicodeScriptCyproMinoan"
		case UnicodeScriptCyrillic: return "UnicodeScriptCyrillic"
		case UnicodeScriptDeseret: return "UnicodeScriptDeseret"
		case UnicodeScriptDevanagari: return "UnicodeScriptDevanagari"
		case UnicodeScriptDivesAkuru: return "UnicodeScriptDivesAkuru"
		case UnicodeScriptDogra: return "UnicodeScriptDogra"
		case UnicodeScriptDuployan: return "UnicodeScriptDuployan"
		case UnicodeScriptEgyptianHieroglyphs: return "UnicodeScriptEgyptianHieroglyphs"
		case UnicodeScriptElbasan: return "UnicodeScriptElbasan"
		case UnicodeScriptElymaic: return "UnicodeScriptElymaic"
		case UnicodeScriptEthiopic: return "UnicodeScriptEthiopic"
		case UnicodeScriptGaray: return "UnicodeScriptGaray"
		case UnicodeScriptGeorgian: return "UnicodeScriptGeorgian"
		case UnicodeScriptGlagolitic: return "UnicodeScriptGlagolitic"
		case UnicodeScriptGothic: return "UnicodeScriptGothic"
		case UnicodeScriptGrantha: return "UnicodeScriptGrantha"
		case UnicodeScriptGreek: return "UnicodeScriptGreek"
		case UnicodeScriptGujarati: return "UnicodeScriptGujarati"
		case UnicodeScriptGunjalaGondi: return "UnicodeScriptGunjalaGondi"
		case UnicodeScriptGurmukhi: return "UnicodeScriptGurmukhi"
		case UnicodeScriptGurungKhema: return "UnicodeScriptGurungKhema"
		case UnicodeScriptHan: return "UnicodeScriptHan"
		case UnicodeScriptHangul: return "UnicodeScriptHangul"
		case UnicodeScriptHanifiRohingya: return "UnicodeScriptHanifiRohingya"
		case UnicodeScriptHanunoo: return "UnicodeScriptHanunoo"
		case UnicodeScriptHatran: return "UnicodeScriptHatran"
		case UnicodeScriptHebrew: return "UnicodeScriptHebrew"
		case UnicodeScriptHiragana: return "UnicodeScriptHiragana"
		case UnicodeScriptImperialAramaic: return "UnicodeScriptImperialAramaic"
		case UnicodeScriptInherited: return "UnicodeScriptInherited"
		case UnicodeScriptInscriptionalPahlavi: return "UnicodeScriptInscriptionalPahlavi"
		case UnicodeScriptInscriptionalParthian: return "UnicodeScriptInscriptionalParthian"
		case UnicodeScriptInvalidCode: return "UnicodeScriptInvalidCode"
		case UnicodeScriptJavanese: return "UnicodeScriptJavanese"
		case UnicodeScriptKaithi: return "UnicodeScriptKaithi"
		case UnicodeScriptKannada: return "UnicodeScriptKannada"
		case UnicodeScriptKatakana: return "UnicodeScriptKatakana"
		case UnicodeScriptKawi: return "UnicodeScriptKawi"
		case UnicodeScriptKayahLi: return "UnicodeScriptKayahLi"
		case UnicodeScriptKharoshthi: return "UnicodeScriptKharoshthi"
		case UnicodeScriptKhitanSmallScript: return "UnicodeScriptKhitanSmallScript"
		case UnicodeScriptKhmer: return "UnicodeScriptKhmer"
		case UnicodeScriptKhojki: return "UnicodeScriptKhojki"
		case UnicodeScriptKhudawadi: return "UnicodeScriptKhudawadi"
		case UnicodeScriptKiratRai: return "UnicodeScriptKiratRai"
		case UnicodeScriptLao: return "UnicodeScriptLao"
		case UnicodeScriptLatin: return "UnicodeScriptLatin"
		case UnicodeScriptLepcha: return "UnicodeScriptLepcha"
		case UnicodeScriptLimbu: return "UnicodeScriptLimbu"
		case UnicodeScriptLinearA: return "UnicodeScriptLinearA"
		case UnicodeScriptLinearB: return "UnicodeScriptLinearB"
		case UnicodeScriptLisu: return "UnicodeScriptLisu"
		case UnicodeScriptLycian: return "UnicodeScriptLycian"
		case UnicodeScriptLydian: return "UnicodeScriptLydian"
		case UnicodeScriptMahajani: return "UnicodeScriptMahajani"
		case UnicodeScriptMakasar: return "UnicodeScriptMakasar"
		case UnicodeScriptMalayalam: return "UnicodeScriptMalayalam"
		case UnicodeScriptMandaic: return "UnicodeScriptMandaic"
		case UnicodeScriptManichaean: return "UnicodeScriptManichaean"
		case UnicodeScriptMarchen: return "UnicodeScriptMarchen"
		case UnicodeScriptMasaramGondi: return "UnicodeScriptMasaramGondi"
		case UnicodeScriptMath: return "UnicodeScriptMath"
		case UnicodeScriptMedefaidrin: return "UnicodeScriptMedefaidrin"
		case UnicodeScriptMeeteiMayek: return "UnicodeScriptMeeteiMayek"
		case UnicodeScriptMendeKikakui: return "UnicodeScriptMendeKikakui"
		case UnicodeScriptMeroiticCursive: return "UnicodeScriptMeroiticCursive"
		case UnicodeScriptMeroiticHieroglyphs: return "UnicodeScriptMeroiticHieroglyphs"
		case UnicodeScriptMiao: return "UnicodeScriptMiao"
		case UnicodeScriptModi: return "UnicodeScriptModi"
		case UnicodeScriptMongolian: return "UnicodeScriptMongolian"
		case UnicodeScriptMro: return "UnicodeScriptMro"
		case UnicodeScriptMultani: return "UnicodeScriptMultani"
		case UnicodeScriptMyanmar: return "UnicodeScriptMyanmar"
		case UnicodeScriptNabataean: return "UnicodeScriptNabataean"
		case UnicodeScriptNagMundari: return "UnicodeScriptNagMundari"
		case UnicodeScriptNandinagari: return "UnicodeScriptNandinagari"
		case UnicodeScriptNewTaiLue: return "UnicodeScriptNewTaiLue"
		case UnicodeScriptNewa: return "UnicodeScriptNewa"
		case UnicodeScriptNko: return "UnicodeScriptNko"
		case UnicodeScriptNushu: return "UnicodeScriptNushu"
		case UnicodeScriptNyiakengPuachueHmong: return "UnicodeScriptNyiakengPuachueHmong"
		case UnicodeScriptOgham: return "UnicodeScriptOgham"
		case UnicodeScriptOlChiki: return "UnicodeScriptOlChiki"
		case UnicodeScriptOlOnal: return "UnicodeScriptOlOnal"
		case UnicodeScriptOldHungarian: return "UnicodeScriptOldHungarian"
		case UnicodeScriptOldItalic: return "UnicodeScriptOldItalic"
		case UnicodeScriptOldNorthArabian: return "UnicodeScriptOldNorthArabian"
		case UnicodeScriptOldPermic: return "UnicodeScriptOldPermic"
		case UnicodeScriptOldPersian: return "UnicodeScriptOldPersian"
		case UnicodeScriptOldSogdian: return "UnicodeScriptOldSogdian"
		case UnicodeScriptOldSouthArabian: return "UnicodeScriptOldSouthArabian"
		case UnicodeScriptOldTurkic: return "UnicodeScriptOldTurkic"
		case UnicodeScriptOldUyghur: return "UnicodeScriptOldUyghur"
		case UnicodeScriptOriya: return "UnicodeScriptOriya"
		case UnicodeScriptOsage: return "UnicodeScriptOsage"
		case UnicodeScriptOsmanya: return "UnicodeScriptOsmanya"
		case UnicodeScriptPahawhHmong: return "UnicodeScriptPahawhHmong"
		case UnicodeScriptPalmyrene: return "UnicodeScriptPalmyrene"
		case UnicodeScriptPauCinHau: return "UnicodeScriptPauCinHau"
		case UnicodeScriptPhagsPa: return "UnicodeScriptPhagsPa"
		case UnicodeScriptPhoenician: return "UnicodeScriptPhoenician"
		case UnicodeScriptPsalterPahlavi: return "UnicodeScriptPsalterPahlavi"
		case UnicodeScriptRejang: return "UnicodeScriptRejang"
		case UnicodeScriptRunic: return "UnicodeScriptRunic"
		case UnicodeScriptSamaritan: return "UnicodeScriptSamaritan"
		case UnicodeScriptSaurashtra: return "UnicodeScriptSaurashtra"
		case UnicodeScriptSharada: return "UnicodeScriptSharada"
		case UnicodeScriptShavian: return "UnicodeScriptShavian"
		case UnicodeScriptSiddham: return "UnicodeScriptSiddham"
		case UnicodeScriptSignwriting: return "UnicodeScriptSignwriting"
		case UnicodeScriptSinhala: return "UnicodeScriptSinhala"
		case UnicodeScriptSogdian: return "UnicodeScriptSogdian"
		case UnicodeScriptSoraSompeng: return "UnicodeScriptSoraSompeng"
		case UnicodeScriptSoyombo: return "UnicodeScriptSoyombo"
		case UnicodeScriptSundanese: return "UnicodeScriptSundanese"
		case UnicodeScriptSunuwar: return "UnicodeScriptSunuwar"
		case UnicodeScriptSylotiNagri: return "UnicodeScriptSylotiNagri"
		case UnicodeScriptSyriac: return "UnicodeScriptSyriac"
		case UnicodeScriptTagalog: return "UnicodeScriptTagalog"
		case UnicodeScriptTagbanwa: return "UnicodeScriptTagbanwa"
		case UnicodeScriptTaiLe: return "UnicodeScriptTaiLe"
		case UnicodeScriptTaiTham: return "UnicodeScriptTaiTham"
		case UnicodeScriptTaiViet: return "UnicodeScriptTaiViet"
		case UnicodeScriptTakri: return "UnicodeScriptTakri"
		case UnicodeScriptTamil: return "UnicodeScriptTamil"
		case UnicodeScriptTangsa: return "UnicodeScriptTangsa"
		case UnicodeScriptTangut: return "UnicodeScriptTangut"
		case UnicodeScriptTelugu: return "UnicodeScriptTelugu"
		case UnicodeScriptThaana: return "UnicodeScriptThaana"
		case UnicodeScriptThai: return "UnicodeScriptThai"
		case UnicodeScriptTibetan: return "UnicodeScriptTibetan"
		case UnicodeScriptTifinagh: return "UnicodeScriptTifinagh"
		case UnicodeScriptTirhuta: return "UnicodeScriptTirhuta"
		case UnicodeScriptTodhri: return "UnicodeScriptTodhri"
		case UnicodeScriptToto: return "UnicodeScriptToto"
		case UnicodeScriptTuluTigalari: return "UnicodeScriptTuluTigalari"
		case UnicodeScriptUgaritic: return "UnicodeScriptUgaritic"
		case UnicodeScriptUnknown: return "UnicodeScriptUnknown"
		case UnicodeScriptVai: return "UnicodeScriptVai"
		case UnicodeScriptVithkuqi: return "UnicodeScriptVithkuqi"
		case UnicodeScriptWancho: return "UnicodeScriptWancho"
		case UnicodeScriptWarangCiti: return "UnicodeScriptWarangCiti"
		case UnicodeScriptYezidi: return "UnicodeScriptYezidi"
		case UnicodeScriptYi: return "UnicodeScriptYi"
		case UnicodeScriptZanabazarSquare: return "UnicodeScriptZanabazarSquare"
		default: return fmt.Sprintf("UnicodeScript(%d)", e)
	}
}

// UnicodeScriptFromIso15924 wraps g_unicode_script_from_iso15924
// 
// The function takes the following parameters:
// 
// 	- iso15924 uint32: a Unicode script 
// 
// The function returns the following values:
// 
// 	- goret UnicodeScript 
//
// Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
// codes to scripts.  For example, the code for Arabic is 'Arab'.
// This function accepts four letter codes encoded as a @guint32 in a
// big-endian fashion.  That is, the code expected for Arabic is
// 0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
// 
// See
// [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
// for details.
func UnicodeScriptFromIso15924(iso15924 uint32) UnicodeScript {
	var carg1 C.guint32        // in, none, casted
	var cret  C.GUnicodeScript // return, none, casted

	carg1 = C.guint32(iso15924)

	cret = C.g_unicode_script_from_iso15924(carg1)
	runtime.KeepAlive(iso15924)

	var goret UnicodeScript

	goret = UnicodeScript(cret)

	return goret
}

// UnicodeScriptToIso15924 wraps g_unicode_script_to_iso15924
// 
// The function takes the following parameters:
// 
// 	- script UnicodeScript: a Unicode script 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
// codes to scripts.  For example, the code for Arabic is 'Arab'.  The
// four letter codes are encoded as a @guint32 by this function in a
// big-endian fashion.  That is, the code returned for Arabic is
// 0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
// 
// See
// [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
// for details.
func UnicodeScriptToIso15924(script UnicodeScript) uint32 {
	var carg1 C.GUnicodeScript // in, none, casted
	var cret  C.guint32        // return, none, casted

	carg1 = C.GUnicodeScript(script)

	cret = C.g_unicode_script_to_iso15924(carg1)
	runtime.KeepAlive(script)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicodeType wraps GUnicodeType
//
// These are the possible character classifications from the
// Unicode specification.
// See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).
type UnicodeType C.int

const (
	// UnicodeControl wraps G_UNICODE_CONTROL
	//
	// General category "Other, Control" (Cc)
	UnicodeControl UnicodeType = 0
	// UnicodeFormat wraps G_UNICODE_FORMAT
	//
	// General category "Other, Format" (Cf)
	UnicodeFormat UnicodeType = 1
	// UnicodeUnassigned wraps G_UNICODE_UNASSIGNED
	//
	// General category "Other, Not Assigned" (Cn)
	UnicodeUnassigned UnicodeType = 2
	// UnicodePrivateUse wraps G_UNICODE_PRIVATE_USE
	//
	// General category "Other, Private Use" (Co)
	UnicodePrivateUse UnicodeType = 3
	// UnicodeSurrogate wraps G_UNICODE_SURROGATE
	//
	// General category "Other, Surrogate" (Cs)
	UnicodeSurrogate UnicodeType = 4
	// UnicodeLowercaseLetter wraps G_UNICODE_LOWERCASE_LETTER
	//
	// General category "Letter, Lowercase" (Ll)
	UnicodeLowercaseLetter UnicodeType = 5
	// UnicodeModifierLetter wraps G_UNICODE_MODIFIER_LETTER
	//
	// General category "Letter, Modifier" (Lm)
	UnicodeModifierLetter UnicodeType = 6
	// UnicodeOtherLetter wraps G_UNICODE_OTHER_LETTER
	//
	// General category "Letter, Other" (Lo)
	UnicodeOtherLetter UnicodeType = 7
	// UnicodeTitlecaseLetter wraps G_UNICODE_TITLECASE_LETTER
	//
	// General category "Letter, Titlecase" (Lt)
	UnicodeTitlecaseLetter UnicodeType = 8
	// UnicodeUppercaseLetter wraps G_UNICODE_UPPERCASE_LETTER
	//
	// General category "Letter, Uppercase" (Lu)
	UnicodeUppercaseLetter UnicodeType = 9
	// UnicodeSpacingMark wraps G_UNICODE_SPACING_MARK
	//
	// General category "Mark, Spacing" (Mc)
	UnicodeSpacingMark UnicodeType = 10
	// UnicodeEnclosingMark wraps G_UNICODE_ENCLOSING_MARK
	//
	// General category "Mark, Enclosing" (Me)
	UnicodeEnclosingMark UnicodeType = 11
	// UnicodeNonSpacingMark wraps G_UNICODE_NON_SPACING_MARK
	//
	// General category "Mark, Nonspacing" (Mn)
	UnicodeNonSpacingMark UnicodeType = 12
	// UnicodeDecimalNumber wraps G_UNICODE_DECIMAL_NUMBER
	//
	// General category "Number, Decimal Digit" (Nd)
	UnicodeDecimalNumber UnicodeType = 13
	// UnicodeLetterNumber wraps G_UNICODE_LETTER_NUMBER
	//
	// General category "Number, Letter" (Nl)
	UnicodeLetterNumber UnicodeType = 14
	// UnicodeOtherNumber wraps G_UNICODE_OTHER_NUMBER
	//
	// General category "Number, Other" (No)
	UnicodeOtherNumber UnicodeType = 15
	// UnicodeConnectPunctuation wraps G_UNICODE_CONNECT_PUNCTUATION
	//
	// General category "Punctuation, Connector" (Pc)
	UnicodeConnectPunctuation UnicodeType = 16
	// UnicodeDashPunctuation wraps G_UNICODE_DASH_PUNCTUATION
	//
	// General category "Punctuation, Dash" (Pd)
	UnicodeDashPunctuation UnicodeType = 17
	// UnicodeClosePunctuation wraps G_UNICODE_CLOSE_PUNCTUATION
	//
	// General category "Punctuation, Close" (Pe)
	UnicodeClosePunctuation UnicodeType = 18
	// UnicodeFinalPunctuation wraps G_UNICODE_FINAL_PUNCTUATION
	//
	// General category "Punctuation, Final quote" (Pf)
	UnicodeFinalPunctuation UnicodeType = 19
	// UnicodeInitialPunctuation wraps G_UNICODE_INITIAL_PUNCTUATION
	//
	// General category "Punctuation, Initial quote" (Pi)
	UnicodeInitialPunctuation UnicodeType = 20
	// UnicodeOtherPunctuation wraps G_UNICODE_OTHER_PUNCTUATION
	//
	// General category "Punctuation, Other" (Po)
	UnicodeOtherPunctuation UnicodeType = 21
	// UnicodeOpenPunctuation wraps G_UNICODE_OPEN_PUNCTUATION
	//
	// General category "Punctuation, Open" (Ps)
	UnicodeOpenPunctuation UnicodeType = 22
	// UnicodeCurrencySymbol wraps G_UNICODE_CURRENCY_SYMBOL
	//
	// General category "Symbol, Currency" (Sc)
	UnicodeCurrencySymbol UnicodeType = 23
	// UnicodeModifierSymbol wraps G_UNICODE_MODIFIER_SYMBOL
	//
	// General category "Symbol, Modifier" (Sk)
	UnicodeModifierSymbol UnicodeType = 24
	// UnicodeMathSymbol wraps G_UNICODE_MATH_SYMBOL
	//
	// General category "Symbol, Math" (Sm)
	UnicodeMathSymbol UnicodeType = 25
	// UnicodeOtherSymbol wraps G_UNICODE_OTHER_SYMBOL
	//
	// General category "Symbol, Other" (So)
	UnicodeOtherSymbol UnicodeType = 26
	// UnicodeLineSeparator wraps G_UNICODE_LINE_SEPARATOR
	//
	// General category "Separator, Line" (Zl)
	UnicodeLineSeparator UnicodeType = 27
	// UnicodeParagraphSeparator wraps G_UNICODE_PARAGRAPH_SEPARATOR
	//
	// General category "Separator, Paragraph" (Zp)
	UnicodeParagraphSeparator UnicodeType = 28
	// UnicodeSpaceSeparator wraps G_UNICODE_SPACE_SEPARATOR
	//
	// General category "Separator, Space" (Zs)
	UnicodeSpaceSeparator UnicodeType = 29
)


func (e UnicodeType) String() string {
	switch e {
		case UnicodeClosePunctuation: return "UnicodeClosePunctuation"
		case UnicodeConnectPunctuation: return "UnicodeConnectPunctuation"
		case UnicodeControl: return "UnicodeControl"
		case UnicodeCurrencySymbol: return "UnicodeCurrencySymbol"
		case UnicodeDashPunctuation: return "UnicodeDashPunctuation"
		case UnicodeDecimalNumber: return "UnicodeDecimalNumber"
		case UnicodeEnclosingMark: return "UnicodeEnclosingMark"
		case UnicodeFinalPunctuation: return "UnicodeFinalPunctuation"
		case UnicodeFormat: return "UnicodeFormat"
		case UnicodeInitialPunctuation: return "UnicodeInitialPunctuation"
		case UnicodeLetterNumber: return "UnicodeLetterNumber"
		case UnicodeLineSeparator: return "UnicodeLineSeparator"
		case UnicodeLowercaseLetter: return "UnicodeLowercaseLetter"
		case UnicodeMathSymbol: return "UnicodeMathSymbol"
		case UnicodeModifierLetter: return "UnicodeModifierLetter"
		case UnicodeModifierSymbol: return "UnicodeModifierSymbol"
		case UnicodeNonSpacingMark: return "UnicodeNonSpacingMark"
		case UnicodeOpenPunctuation: return "UnicodeOpenPunctuation"
		case UnicodeOtherLetter: return "UnicodeOtherLetter"
		case UnicodeOtherNumber: return "UnicodeOtherNumber"
		case UnicodeOtherPunctuation: return "UnicodeOtherPunctuation"
		case UnicodeOtherSymbol: return "UnicodeOtherSymbol"
		case UnicodeParagraphSeparator: return "UnicodeParagraphSeparator"
		case UnicodePrivateUse: return "UnicodePrivateUse"
		case UnicodeSpaceSeparator: return "UnicodeSpaceSeparator"
		case UnicodeSpacingMark: return "UnicodeSpacingMark"
		case UnicodeSurrogate: return "UnicodeSurrogate"
		case UnicodeTitlecaseLetter: return "UnicodeTitlecaseLetter"
		case UnicodeUnassigned: return "UnicodeUnassigned"
		case UnicodeUppercaseLetter: return "UnicodeUppercaseLetter"
		default: return fmt.Sprintf("UnicodeType(%d)", e)
	}
}

// UriError wraps GUriError
//
// Error codes returned by #GUri methods.
type UriError C.int

const (
	// URIErrorFailed wraps G_URI_ERROR_FAILED
	//
	// Generic error if no more specific error is available.
	//     See the error message for details.
	URIErrorFailed UriError = 0
	// URIErrorBadScheme wraps G_URI_ERROR_BAD_SCHEME
	//
	// The scheme of a URI could not be parsed.
	URIErrorBadScheme UriError = 1
	// URIErrorBadUser wraps G_URI_ERROR_BAD_USER
	//
	// The user/userinfo of a URI could not be parsed.
	URIErrorBadUser UriError = 2
	// URIErrorBadPassword wraps G_URI_ERROR_BAD_PASSWORD
	//
	// The password of a URI could not be parsed.
	URIErrorBadPassword UriError = 3
	// URIErrorBadAuthParams wraps G_URI_ERROR_BAD_AUTH_PARAMS
	//
	// The authentication parameters of a URI could not be parsed.
	URIErrorBadAuthParams UriError = 4
	// URIErrorBadHost wraps G_URI_ERROR_BAD_HOST
	//
	// The host of a URI could not be parsed.
	URIErrorBadHost UriError = 5
	// URIErrorBadPort wraps G_URI_ERROR_BAD_PORT
	//
	// The port of a URI could not be parsed.
	URIErrorBadPort UriError = 6
	// URIErrorBadPath wraps G_URI_ERROR_BAD_PATH
	//
	// The path of a URI could not be parsed.
	URIErrorBadPath UriError = 7
	// URIErrorBadQuery wraps G_URI_ERROR_BAD_QUERY
	//
	// The query of a URI could not be parsed.
	URIErrorBadQuery UriError = 8
	// URIErrorBadFragment wraps G_URI_ERROR_BAD_FRAGMENT
	//
	// The fragment of a URI could not be parsed.
	URIErrorBadFragment UriError = 9
)


func (e UriError) String() string {
	switch e {
		case URIErrorBadAuthParams: return "URIErrorBadAuthParams"
		case URIErrorBadFragment: return "URIErrorBadFragment"
		case URIErrorBadHost: return "URIErrorBadHost"
		case URIErrorBadPassword: return "URIErrorBadPassword"
		case URIErrorBadPath: return "URIErrorBadPath"
		case URIErrorBadPort: return "URIErrorBadPort"
		case URIErrorBadQuery: return "URIErrorBadQuery"
		case URIErrorBadScheme: return "URIErrorBadScheme"
		case URIErrorBadUser: return "URIErrorBadUser"
		case URIErrorFailed: return "URIErrorFailed"
		default: return fmt.Sprintf("UriError(%d)", e)
	}
}

// UserDirectory wraps GUserDirectory
//
// These are logical ids for special directories which are defined
// depending on the platform used. You should use g_get_user_special_dir()
// to retrieve the full path associated to the logical id.
// 
// The #GUserDirectory enumeration can be extended at later date. Not
// every platform has a directory for every logical id in this
// enumeration.
type UserDirectory C.int

const (
	// UserDirectoryDesktop wraps G_USER_DIRECTORY_DESKTOP
	//
	// the user's Desktop directory
	UserDirectoryDesktop UserDirectory = 0
	// UserDirectoryDocuments wraps G_USER_DIRECTORY_DOCUMENTS
	//
	// the user's Documents directory
	UserDirectoryDocuments UserDirectory = 1
	// UserDirectoryDownload wraps G_USER_DIRECTORY_DOWNLOAD
	//
	// the user's Downloads directory
	UserDirectoryDownload UserDirectory = 2
	// UserDirectoryMusic wraps G_USER_DIRECTORY_MUSIC
	//
	// the user's Music directory
	UserDirectoryMusic UserDirectory = 3
	// UserDirectoryPictures wraps G_USER_DIRECTORY_PICTURES
	//
	// the user's Pictures directory
	UserDirectoryPictures UserDirectory = 4
	// UserDirectoryPublicShare wraps G_USER_DIRECTORY_PUBLIC_SHARE
	//
	// the user's shared directory
	UserDirectoryPublicShare UserDirectory = 5
	// UserDirectoryTemplates wraps G_USER_DIRECTORY_TEMPLATES
	//
	// the user's Templates directory
	UserDirectoryTemplates UserDirectory = 6
	// UserDirectoryVideos wraps G_USER_DIRECTORY_VIDEOS
	//
	// the user's Movies directory
	UserDirectoryVideos UserDirectory = 7
	// UserNDirectories wraps G_USER_N_DIRECTORIES
	//
	// the number of enum values
	UserNDirectories UserDirectory = 8
)


func (e UserDirectory) String() string {
	switch e {
		case UserDirectoryDesktop: return "UserDirectoryDesktop"
		case UserDirectoryDocuments: return "UserDirectoryDocuments"
		case UserDirectoryDownload: return "UserDirectoryDownload"
		case UserDirectoryMusic: return "UserDirectoryMusic"
		case UserDirectoryPictures: return "UserDirectoryPictures"
		case UserDirectoryPublicShare: return "UserDirectoryPublicShare"
		case UserDirectoryTemplates: return "UserDirectoryTemplates"
		case UserDirectoryVideos: return "UserDirectoryVideos"
		case UserNDirectories: return "UserNDirectories"
		default: return fmt.Sprintf("UserDirectory(%d)", e)
	}
}

// VariantClass wraps GVariantClass
//
// The range of possible top-level types of #GVariant instances.
type VariantClass C.int

const (
	// VariantClassBoolean wraps G_VARIANT_CLASS_BOOLEAN
	//
	// The #GVariant is a boolean.
	VariantClassBoolean VariantClass = 98
	// VariantClassByte wraps G_VARIANT_CLASS_BYTE
	//
	// The #GVariant is a byte.
	VariantClassByte VariantClass = 121
	// VariantClassInt16 wraps G_VARIANT_CLASS_INT16
	//
	// The #GVariant is a signed 16 bit integer.
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16 wraps G_VARIANT_CLASS_UINT16
	//
	// The #GVariant is an unsigned 16 bit integer.
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32 wraps G_VARIANT_CLASS_INT32
	//
	// The #GVariant is a signed 32 bit integer.
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32 wraps G_VARIANT_CLASS_UINT32
	//
	// The #GVariant is an unsigned 32 bit integer.
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64 wraps G_VARIANT_CLASS_INT64
	//
	// The #GVariant is a signed 64 bit integer.
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64 wraps G_VARIANT_CLASS_UINT64
	//
	// The #GVariant is an unsigned 64 bit integer.
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle wraps G_VARIANT_CLASS_HANDLE
	//
	// The #GVariant is a file handle index.
	VariantClassHandle VariantClass = 104
	// VariantClassDouble wraps G_VARIANT_CLASS_DOUBLE
	//
	// The #GVariant is a double precision floating
	//                          point value.
	VariantClassDouble VariantClass = 100
	// VariantClassString wraps G_VARIANT_CLASS_STRING
	//
	// The #GVariant is a normal string.
	VariantClassString VariantClass = 115
	// VariantClassObjectPath wraps G_VARIANT_CLASS_OBJECT_PATH
	//
	// The #GVariant is a D-Bus object path
	//                               string.
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature wraps G_VARIANT_CLASS_SIGNATURE
	//
	// The #GVariant is a D-Bus signature string.
	VariantClassSignature VariantClass = 103
	// VariantClassVariant wraps G_VARIANT_CLASS_VARIANT
	//
	// The #GVariant is a variant.
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe wraps G_VARIANT_CLASS_MAYBE
	//
	// The #GVariant is a maybe-typed value.
	VariantClassMaybe VariantClass = 109
	// VariantClassArray wraps G_VARIANT_CLASS_ARRAY
	//
	// The #GVariant is an array.
	VariantClassArray VariantClass = 97
	// VariantClassTuple wraps G_VARIANT_CLASS_TUPLE
	//
	// The #GVariant is a tuple.
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry wraps G_VARIANT_CLASS_DICT_ENTRY
	//
	// The #GVariant is a dictionary entry.
	VariantClassDictEntry VariantClass = 123
)


func (e VariantClass) String() string {
	switch e {
		case VariantClassArray: return "VariantClassArray"
		case VariantClassBoolean: return "VariantClassBoolean"
		case VariantClassByte: return "VariantClassByte"
		case VariantClassDictEntry: return "VariantClassDictEntry"
		case VariantClassDouble: return "VariantClassDouble"
		case VariantClassHandle: return "VariantClassHandle"
		case VariantClassInt16: return "VariantClassInt16"
		case VariantClassInt32: return "VariantClassInt32"
		case VariantClassInt64: return "VariantClassInt64"
		case VariantClassMaybe: return "VariantClassMaybe"
		case VariantClassObjectPath: return "VariantClassObjectPath"
		case VariantClassSignature: return "VariantClassSignature"
		case VariantClassString: return "VariantClassString"
		case VariantClassTuple: return "VariantClassTuple"
		case VariantClassUint16: return "VariantClassUint16"
		case VariantClassUint32: return "VariantClassUint32"
		case VariantClassUint64: return "VariantClassUint64"
		case VariantClassVariant: return "VariantClassVariant"
		default: return fmt.Sprintf("VariantClass(%d)", e)
	}
}

// VariantParseError wraps GVariantParseError
//
// Error codes returned by parsing text-format GVariants.
type VariantParseError C.int

const (
	// VariantParseErrorFailed wraps G_VARIANT_PARSE_ERROR_FAILED
	//
	// generic error (unused)
	VariantParseErrorFailed VariantParseError = 0
	// VariantParseErrorBasicTypeExpected wraps G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED
	//
	// a non-basic #GVariantType was given where a basic type was expected
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// VariantParseErrorCannotInferType wraps G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE
	//
	// cannot infer the #GVariantType
	VariantParseErrorCannotInferType VariantParseError = 2
	// VariantParseErrorDefiniteTypeExpected wraps G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED
	//
	// an indefinite #GVariantType was given where a definite type was expected
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// VariantParseErrorInputNotAtEnd wraps G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END
	//
	// extra data after parsing finished
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// VariantParseErrorInvalidCharacter wraps G_VARIANT_PARSE_ERROR_INVALID_CHARACTER
	//
	// invalid character in number or unicode escape
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// VariantParseErrorInvalidFormatString wraps G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING
	//
	// not a valid #GVariant format string
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// VariantParseErrorInvalidObjectPath wraps G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH
	//
	// not a valid object path
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// VariantParseErrorInvalidSignature wraps G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE
	//
	// not a valid type signature
	VariantParseErrorInvalidSignature VariantParseError = 8
	// VariantParseErrorInvalidTypeString wraps G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING
	//
	// not a valid #GVariant type string
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// VariantParseErrorNoCommonType wraps G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE
	//
	// could not find a common type for array entries
	VariantParseErrorNoCommonType VariantParseError = 10
	// VariantParseErrorNumberOutOfRange wraps G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE
	//
	// the numerical value is out of range of the given type
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// VariantParseErrorNumberTooBig wraps G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG
	//
	// the numerical value is out of range for any type
	VariantParseErrorNumberTooBig VariantParseError = 12
	// VariantParseErrorTypeError wraps G_VARIANT_PARSE_ERROR_TYPE_ERROR
	//
	// cannot parse as variant of the specified type
	VariantParseErrorTypeError VariantParseError = 13
	// VariantParseErrorUnexpectedToken wraps G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN
	//
	// an unexpected token was encountered
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// VariantParseErrorUnknownKeyword wraps G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD
	//
	// an unknown keyword was encountered
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// VariantParseErrorUnterminatedStringConstant wraps G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT
	//
	// unterminated string constant
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// VariantParseErrorValueExpected wraps G_VARIANT_PARSE_ERROR_VALUE_EXPECTED
	//
	// no value given
	VariantParseErrorValueExpected VariantParseError = 17
	// VariantParseErrorRecursion wraps G_VARIANT_PARSE_ERROR_RECURSION
	//
	// variant was too deeply nested; #GVariant is only guaranteed to handle nesting up to 64 levels (Since: 2.64)
	VariantParseErrorRecursion VariantParseError = 18
)


func (e VariantParseError) String() string {
	switch e {
		case VariantParseErrorBasicTypeExpected: return "VariantParseErrorBasicTypeExpected"
		case VariantParseErrorCannotInferType: return "VariantParseErrorCannotInferType"
		case VariantParseErrorDefiniteTypeExpected: return "VariantParseErrorDefiniteTypeExpected"
		case VariantParseErrorFailed: return "VariantParseErrorFailed"
		case VariantParseErrorInputNotAtEnd: return "VariantParseErrorInputNotAtEnd"
		case VariantParseErrorInvalidCharacter: return "VariantParseErrorInvalidCharacter"
		case VariantParseErrorInvalidFormatString: return "VariantParseErrorInvalidFormatString"
		case VariantParseErrorInvalidObjectPath: return "VariantParseErrorInvalidObjectPath"
		case VariantParseErrorInvalidSignature: return "VariantParseErrorInvalidSignature"
		case VariantParseErrorInvalidTypeString: return "VariantParseErrorInvalidTypeString"
		case VariantParseErrorNoCommonType: return "VariantParseErrorNoCommonType"
		case VariantParseErrorNumberOutOfRange: return "VariantParseErrorNumberOutOfRange"
		case VariantParseErrorNumberTooBig: return "VariantParseErrorNumberTooBig"
		case VariantParseErrorRecursion: return "VariantParseErrorRecursion"
		case VariantParseErrorTypeError: return "VariantParseErrorTypeError"
		case VariantParseErrorUnexpectedToken: return "VariantParseErrorUnexpectedToken"
		case VariantParseErrorUnknownKeyword: return "VariantParseErrorUnknownKeyword"
		case VariantParseErrorUnterminatedStringConstant: return "VariantParseErrorUnterminatedStringConstant"
		case VariantParseErrorValueExpected: return "VariantParseErrorValueExpected"
		default: return fmt.Sprintf("VariantParseError(%d)", e)
	}
}

// AsciiType wraps GAsciiType
type AsciiType C.gint

const (
	// ASCIIAlnum wraps G_ASCII_ALNUM
	ASCIIAlnum AsciiType = 1
	// ASCIIAlpha wraps G_ASCII_ALPHA
	ASCIIAlpha AsciiType = 2
	// ASCIICntrl wraps G_ASCII_CNTRL
	ASCIICntrl AsciiType = 4
	// ASCIIDigit wraps G_ASCII_DIGIT
	ASCIIDigit AsciiType = 8
	// ASCIIGraph wraps G_ASCII_GRAPH
	ASCIIGraph AsciiType = 16
	// ASCIILower wraps G_ASCII_LOWER
	ASCIILower AsciiType = 32
	// ASCIIPrint wraps G_ASCII_PRINT
	ASCIIPrint AsciiType = 64
	// ASCIIPunct wraps G_ASCII_PUNCT
	ASCIIPunct AsciiType = 128
	// ASCIISpace wraps G_ASCII_SPACE
	ASCIISpace AsciiType = 256
	// ASCIIUpper wraps G_ASCII_UPPER
	ASCIIUpper AsciiType = 512
	// ASCIIXdigit wraps G_ASCII_XDIGIT
	ASCIIXdigit AsciiType = 1024
)

// Has returns true if a contains other
func (a AsciiType) Has(other AsciiType) bool {
	return (a & other) == other
}

func (f AsciiType) String() string {
	if f == 0 {
		return "AsciiType(0)"
	}

	var parts []string
	if (f & ASCIIAlnum) != 0 {
		parts = append(parts, "ASCIIAlnum")
	}
	if (f & ASCIIAlpha) != 0 {
		parts = append(parts, "ASCIIAlpha")
	}
	if (f & ASCIICntrl) != 0 {
		parts = append(parts, "ASCIICntrl")
	}
	if (f & ASCIIDigit) != 0 {
		parts = append(parts, "ASCIIDigit")
	}
	if (f & ASCIIGraph) != 0 {
		parts = append(parts, "ASCIIGraph")
	}
	if (f & ASCIILower) != 0 {
		parts = append(parts, "ASCIILower")
	}
	if (f & ASCIIPrint) != 0 {
		parts = append(parts, "ASCIIPrint")
	}
	if (f & ASCIIPunct) != 0 {
		parts = append(parts, "ASCIIPunct")
	}
	if (f & ASCIISpace) != 0 {
		parts = append(parts, "ASCIISpace")
	}
	if (f & ASCIIUpper) != 0 {
		parts = append(parts, "ASCIIUpper")
	}
	if (f & ASCIIXdigit) != 0 {
		parts = append(parts, "ASCIIXdigit")
	}
	return "AsciiType(" + strings.Join(parts, "|") + ")"
}

// FileSetContentsFlags wraps GFileSetContentsFlags
//
// Flags to pass to g_file_set_contents_full() to affect its safety and
// performance.
type FileSetContentsFlags C.gint

const (
	// FileSetContentsNone wraps G_FILE_SET_CONTENTS_NONE
	//
	// No guarantees about file consistency or durability.
	//   The most dangerous setting, which is slightly faster than other settings.
	FileSetContentsNone FileSetContentsFlags = 0
	// FileSetContentsConsistent wraps G_FILE_SET_CONTENTS_CONSISTENT
	//
	// Guarantee file consistency: after a crash,
	//   either the old version of the file or the new version of the file will be
	//   available, but not a mixture. On Unix systems this equates to an `fsync()`
	//   on the file and use of an atomic `rename()` of the new version of the file
	//   over the old.
	FileSetContentsConsistent FileSetContentsFlags = 1
	// FileSetContentsDurable wraps G_FILE_SET_CONTENTS_DURABLE
	//
	// Guarantee file durability: after a crash, the
	//   new version of the file will be available. On Unix systems this equates to
	//   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or
	//   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the
	//   directory containing the file after calling `rename()`.
	FileSetContentsDurable FileSetContentsFlags = 2
	// FileSetContentsOnlyExisting wraps G_FILE_SET_CONTENTS_ONLY_EXISTING
	//
	// Only apply consistency and durability
	//   guarantees if the file already exists. This may speed up file operations
	//   if the file doesn&#x2019;t currently exist, but may result in a corrupted version
	//   of the new file if the system crashes while writing it.
	FileSetContentsOnlyExisting FileSetContentsFlags = 4
)

// Has returns true if f contains other
func (f FileSetContentsFlags) Has(other FileSetContentsFlags) bool {
	return (f & other) == other
}

func (f FileSetContentsFlags) String() string {
	if f == 0 {
		return "FileSetContentsFlags(0)"
	}

	var parts []string
	if (f & FileSetContentsNone) != 0 {
		parts = append(parts, "FileSetContentsNone")
	}
	if (f & FileSetContentsConsistent) != 0 {
		parts = append(parts, "FileSetContentsConsistent")
	}
	if (f & FileSetContentsDurable) != 0 {
		parts = append(parts, "FileSetContentsDurable")
	}
	if (f & FileSetContentsOnlyExisting) != 0 {
		parts = append(parts, "FileSetContentsOnlyExisting")
	}
	return "FileSetContentsFlags(" + strings.Join(parts, "|") + ")"
}

// FileTest wraps GFileTest
//
// A test to perform on a file using g_file_test().
type FileTest C.gint

const (
	// FileTestIsRegular wraps G_FILE_TEST_IS_REGULAR
	//
	// %TRUE if the file is a regular file
	//     (not a directory). Note that this test will also return %TRUE
	//     if the tested file is a symlink to a regular file.
	FileTestIsRegular FileTest = 1
	// FileTestIsSymlink wraps G_FILE_TEST_IS_SYMLINK
	//
	// %TRUE if the file is a symlink.
	FileTestIsSymlink FileTest = 2
	// FileTestIsDir wraps G_FILE_TEST_IS_DIR
	//
	// %TRUE if the file is a directory.
	FileTestIsDir FileTest = 4
	// FileTestIsExecutable wraps G_FILE_TEST_IS_EXECUTABLE
	//
	// %TRUE if the file is executable.
	FileTestIsExecutable FileTest = 8
	// FileTestExists wraps G_FILE_TEST_EXISTS
	//
	// %TRUE if the file exists. It may or may not
	//     be a regular file.
	FileTestExists FileTest = 16
)

// Has returns true if f contains other
func (f FileTest) Has(other FileTest) bool {
	return (f & other) == other
}

func (f FileTest) String() string {
	if f == 0 {
		return "FileTest(0)"
	}

	var parts []string
	if (f & FileTestIsRegular) != 0 {
		parts = append(parts, "FileTestIsRegular")
	}
	if (f & FileTestIsSymlink) != 0 {
		parts = append(parts, "FileTestIsSymlink")
	}
	if (f & FileTestIsDir) != 0 {
		parts = append(parts, "FileTestIsDir")
	}
	if (f & FileTestIsExecutable) != 0 {
		parts = append(parts, "FileTestIsExecutable")
	}
	if (f & FileTestExists) != 0 {
		parts = append(parts, "FileTestExists")
	}
	return "FileTest(" + strings.Join(parts, "|") + ")"
}

// FormatSizeFlags wraps GFormatSizeFlags
//
// Flags to modify the format of the string returned by g_format_size_full().
type FormatSizeFlags C.gint

const (
	// FormatSizeDefault wraps G_FORMAT_SIZE_DEFAULT
	//
	// behave the same as g_format_size()
	FormatSizeDefault FormatSizeFlags = 0
	// FormatSizeLongFormat wraps G_FORMAT_SIZE_LONG_FORMAT
	//
	// include the exact number of bytes as part
	//     of the returned string.  For example, "45.6 kB (45,612 bytes)".
	FormatSizeLongFormat FormatSizeFlags = 1
	// FormatSizeIecUnits wraps G_FORMAT_SIZE_IEC_UNITS
	//
	// use IEC (base 1024) units with "KiB"-style
	//     suffixes. IEC units should only be used for reporting things with
	//     a strong "power of 2" basis, like RAM sizes or RAID stripe sizes.
	//     Network and storage sizes should be reported in the normal SI units.
	FormatSizeIecUnits FormatSizeFlags = 2
	// FormatSizeBits wraps G_FORMAT_SIZE_BITS
	//
	// set the size as a quantity in bits, rather than
	//     bytes, and return units in bits. For example, &#x2018;Mbit&#x2019; rather than &#x2018;MB&#x2019;.
	FormatSizeBits FormatSizeFlags = 4
	// FormatSizeOnlyValue wraps G_FORMAT_SIZE_ONLY_VALUE
	//
	// return only value, without unit; this should
	//     not be used together with @G_FORMAT_SIZE_LONG_FORMAT
	//     nor @G_FORMAT_SIZE_ONLY_UNIT. Since: 2.74
	FormatSizeOnlyValue FormatSizeFlags = 8
	// FormatSizeOnlyUnit wraps G_FORMAT_SIZE_ONLY_UNIT
	//
	// return only unit, without value; this should
	//     not be used together with @G_FORMAT_SIZE_LONG_FORMAT
	//     nor @G_FORMAT_SIZE_ONLY_VALUE. Since: 2.74
	FormatSizeOnlyUnit FormatSizeFlags = 16
)

// Has returns true if f contains other
func (f FormatSizeFlags) Has(other FormatSizeFlags) bool {
	return (f & other) == other
}

func (f FormatSizeFlags) String() string {
	if f == 0 {
		return "FormatSizeFlags(0)"
	}

	var parts []string
	if (f & FormatSizeDefault) != 0 {
		parts = append(parts, "FormatSizeDefault")
	}
	if (f & FormatSizeLongFormat) != 0 {
		parts = append(parts, "FormatSizeLongFormat")
	}
	if (f & FormatSizeIecUnits) != 0 {
		parts = append(parts, "FormatSizeIecUnits")
	}
	if (f & FormatSizeBits) != 0 {
		parts = append(parts, "FormatSizeBits")
	}
	if (f & FormatSizeOnlyValue) != 0 {
		parts = append(parts, "FormatSizeOnlyValue")
	}
	if (f & FormatSizeOnlyUnit) != 0 {
		parts = append(parts, "FormatSizeOnlyUnit")
	}
	return "FormatSizeFlags(" + strings.Join(parts, "|") + ")"
}

// IOCondition wraps GIOCondition
//
// A bitwise combination representing a condition to watch for on an
// event source.
type IOCondition C.gint

const (
	// IOIn wraps G_IO_IN
	//
	// There is data to read.
	IOIn IOCondition = 1
	// IOOut wraps G_IO_OUT
	//
	// Data can be written (without blocking).
	IOOut IOCondition = 4
	// IOPri wraps G_IO_PRI
	//
	// There is urgent data to read.
	IOPri IOCondition = 2
	// IOErr wraps G_IO_ERR
	//
	// Error condition.
	IOErr IOCondition = 8
	// IOHup wraps G_IO_HUP
	//
	// Hung up (the connection has been broken, usually for
	//            pipes and sockets).
	IOHup IOCondition = 16
	// IONval wraps G_IO_NVAL
	//
	// Invalid request. The file descriptor is not open.
	IONval IOCondition = 32
)

// Has returns true if i contains other
func (i IOCondition) Has(other IOCondition) bool {
	return (i & other) == other
}

func (f IOCondition) String() string {
	if f == 0 {
		return "IOCondition(0)"
	}

	var parts []string
	if (f & IOIn) != 0 {
		parts = append(parts, "IOIn")
	}
	if (f & IOOut) != 0 {
		parts = append(parts, "IOOut")
	}
	if (f & IOPri) != 0 {
		parts = append(parts, "IOPri")
	}
	if (f & IOErr) != 0 {
		parts = append(parts, "IOErr")
	}
	if (f & IOHup) != 0 {
		parts = append(parts, "IOHup")
	}
	if (f & IONval) != 0 {
		parts = append(parts, "IONval")
	}
	return "IOCondition(" + strings.Join(parts, "|") + ")"
}

// IOFlags wraps GIOFlags
//
// Specifies properties of a #GIOChannel. Some of the flags can only be
// read with g_io_channel_get_flags(), but not changed with
// g_io_channel_set_flags().
type IOFlags C.gint

const (
	// IOFlagNone wraps G_IO_FLAG_NONE
	//
	// no special flags set. Since: 2.74
	IOFlagNone IOFlags = 0
	// IOFlagAppend wraps G_IO_FLAG_APPEND
	//
	// turns on append mode, corresponds to %O_APPEND
	//     (see the documentation of the UNIX open() syscall)
	IOFlagAppend IOFlags = 1
	// IOFlagNonblock wraps G_IO_FLAG_NONBLOCK
	//
	// turns on nonblocking mode, corresponds to
	//     %O_NONBLOCK/%O_NDELAY (see the documentation of the UNIX open()
	//     syscall)
	IOFlagNonblock IOFlags = 2
	// IOFlagIsReadable wraps G_IO_FLAG_IS_READABLE
	//
	// indicates that the io channel is readable.
	//     This flag cannot be changed.
	IOFlagIsReadable IOFlags = 4
	// IOFlagIsWritable wraps G_IO_FLAG_IS_WRITABLE
	//
	// indicates that the io channel is writable.
	//     This flag cannot be changed.
	IOFlagIsWritable IOFlags = 8
	// IOFlagIsWriteable wraps G_IO_FLAG_IS_WRITEABLE
	//
	// a misspelled version of @G_IO_FLAG_IS_WRITABLE
	//     that existed before the spelling was fixed in GLib 2.30. It is kept
	//     here for compatibility reasons. Deprecated since 2.30
	IOFlagIsWriteable IOFlags = 8
	// IOFlagIsSeekable wraps G_IO_FLAG_IS_SEEKABLE
	//
	// indicates that the io channel is seekable,
	//     i.e. that g_io_channel_seek_position() can be used on it.
	//     This flag cannot be changed.
	IOFlagIsSeekable IOFlags = 16
	// IOFlagMask wraps G_IO_FLAG_MASK
	//
	// the mask that specifies all the valid flags.
	IOFlagMask IOFlags = 31
	// IOFlagGetMask wraps G_IO_FLAG_GET_MASK
	//
	// the mask of the flags that are returned from
	//     g_io_channel_get_flags()
	IOFlagGetMask IOFlags = 31
	// IOFlagSetMask wraps G_IO_FLAG_SET_MASK
	//
	// the mask of the flags that the user can modify
	//     with g_io_channel_set_flags()
	IOFlagSetMask IOFlags = 3
)

// Has returns true if i contains other
func (i IOFlags) Has(other IOFlags) bool {
	return (i & other) == other
}

func (f IOFlags) String() string {
	if f == 0 {
		return "IOFlags(0)"
	}

	var parts []string
	if (f & IOFlagNone) != 0 {
		parts = append(parts, "IOFlagNone")
	}
	if (f & IOFlagAppend) != 0 {
		parts = append(parts, "IOFlagAppend")
	}
	if (f & IOFlagNonblock) != 0 {
		parts = append(parts, "IOFlagNonblock")
	}
	if (f & IOFlagIsReadable) != 0 {
		parts = append(parts, "IOFlagIsReadable")
	}
	if (f & IOFlagIsWritable) != 0 {
		parts = append(parts, "IOFlagIsWritable")
	}
	if (f & IOFlagIsWriteable) != 0 {
		parts = append(parts, "IOFlagIsWriteable")
	}
	if (f & IOFlagIsSeekable) != 0 {
		parts = append(parts, "IOFlagIsSeekable")
	}
	if (f & IOFlagMask) != 0 {
		parts = append(parts, "IOFlagMask")
	}
	if (f & IOFlagGetMask) != 0 {
		parts = append(parts, "IOFlagGetMask")
	}
	if (f & IOFlagSetMask) != 0 {
		parts = append(parts, "IOFlagSetMask")
	}
	return "IOFlags(" + strings.Join(parts, "|") + ")"
}

// KeyFileFlags wraps GKeyFileFlags
//
// Flags which influence the parsing.
type KeyFileFlags C.gint

const (
	// KeyFileNone wraps G_KEY_FILE_NONE
	//
	// No flags, default behaviour
	KeyFileNone KeyFileFlags = 0
	// KeyFileKeepComments wraps G_KEY_FILE_KEEP_COMMENTS
	//
	// Use this flag if you plan to write the
	//   (possibly modified) contents of the key file back to a file;
	//   otherwise all comments will be lost when the key file is
	//   written back.
	KeyFileKeepComments KeyFileFlags = 1
	// KeyFileKeepTranslations wraps G_KEY_FILE_KEEP_TRANSLATIONS
	//
	// Use this flag if you plan to write the
	//   (possibly modified) contents of the key file back to a file;
	//   otherwise only the translations for the current language will be
	//   written back.
	KeyFileKeepTranslations KeyFileFlags = 2
)

// Has returns true if k contains other
func (k KeyFileFlags) Has(other KeyFileFlags) bool {
	return (k & other) == other
}

func (f KeyFileFlags) String() string {
	if f == 0 {
		return "KeyFileFlags(0)"
	}

	var parts []string
	if (f & KeyFileNone) != 0 {
		parts = append(parts, "KeyFileNone")
	}
	if (f & KeyFileKeepComments) != 0 {
		parts = append(parts, "KeyFileKeepComments")
	}
	if (f & KeyFileKeepTranslations) != 0 {
		parts = append(parts, "KeyFileKeepTranslations")
	}
	return "KeyFileFlags(" + strings.Join(parts, "|") + ")"
}

// LogLevelFlags wraps GLogLevelFlags
//
// Flags specifying the level of log messages.
// 
// It is possible to change how GLib treats messages of the various
// levels using [func@GLib.log_set_handler] and [func@GLib.log_set_fatal_mask].
type LogLevelFlags C.gint

const (
	// LogFlagRecursion wraps G_LOG_FLAG_RECURSION
	//
	// internal flag
	LogFlagRecursion LogLevelFlags = 1
	// LogFlagFatal wraps G_LOG_FLAG_FATAL
	//
	// internal flag
	LogFlagFatal LogLevelFlags = 2
	// LogLevelError wraps G_LOG_LEVEL_ERROR
	//
	// log level for errors, see [func@GLib.error].
	//   This level is also used for messages produced by [func@GLib.assert].
	LogLevelError LogLevelFlags = 4
	// LogLevelCritical wraps G_LOG_LEVEL_CRITICAL
	//
	// log level for critical warning messages, see
	//   [func@GLib.critical]. This level is also used for messages produced by
	//   [func@GLib.return_if_fail] and [func@GLib.return_val_if_fail].
	LogLevelCritical LogLevelFlags = 8
	// LogLevelWarning wraps G_LOG_LEVEL_WARNING
	//
	// log level for warnings, see [func@GLib.warning]
	LogLevelWarning LogLevelFlags = 16
	// LogLevelMessage wraps G_LOG_LEVEL_MESSAGE
	//
	// log level for messages, see [func@GLib.message]
	LogLevelMessage LogLevelFlags = 32
	// LogLevelInfo wraps G_LOG_LEVEL_INFO
	//
	// log level for informational messages, see [func@GLib.info]
	LogLevelInfo LogLevelFlags = 64
	// LogLevelDebug wraps G_LOG_LEVEL_DEBUG
	//
	// log level for debug messages, see [func@GLib.debug]
	LogLevelDebug LogLevelFlags = 128
	// LogLevelMask wraps G_LOG_LEVEL_MASK
	//
	// a mask including all log levels
	LogLevelMask LogLevelFlags = -4
)

// Has returns true if l contains other
func (l LogLevelFlags) Has(other LogLevelFlags) bool {
	return (l & other) == other
}

func (f LogLevelFlags) String() string {
	if f == 0 {
		return "LogLevelFlags(0)"
	}

	var parts []string
	if (f & LogFlagRecursion) != 0 {
		parts = append(parts, "LogFlagRecursion")
	}
	if (f & LogFlagFatal) != 0 {
		parts = append(parts, "LogFlagFatal")
	}
	if (f & LogLevelError) != 0 {
		parts = append(parts, "LogLevelError")
	}
	if (f & LogLevelCritical) != 0 {
		parts = append(parts, "LogLevelCritical")
	}
	if (f & LogLevelWarning) != 0 {
		parts = append(parts, "LogLevelWarning")
	}
	if (f & LogLevelMessage) != 0 {
		parts = append(parts, "LogLevelMessage")
	}
	if (f & LogLevelInfo) != 0 {
		parts = append(parts, "LogLevelInfo")
	}
	if (f & LogLevelDebug) != 0 {
		parts = append(parts, "LogLevelDebug")
	}
	if (f & LogLevelMask) != 0 {
		parts = append(parts, "LogLevelMask")
	}
	return "LogLevelFlags(" + strings.Join(parts, "|") + ")"
}

// MainContextFlags wraps GMainContextFlags
//
// Flags to pass to [ctor@GLib.MainContext.new_with_flags] which affect the
// behaviour of a [struct@GLib.MainContext].
type MainContextFlags C.gint

const (
	// MainContextFlagsNone wraps G_MAIN_CONTEXT_FLAGS_NONE
	//
	// Default behaviour.
	MainContextFlagsNone MainContextFlags = 0
	// MainContextFlagsOwnerlessPolling wraps G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING
	//
	// Assume that polling for events will
	// free the thread to process other jobs. That's useful if you're using
	// `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
	// other event loops.
	MainContextFlagsOwnerlessPolling MainContextFlags = 1
)

// Has returns true if m contains other
func (m MainContextFlags) Has(other MainContextFlags) bool {
	return (m & other) == other
}

func (f MainContextFlags) String() string {
	if f == 0 {
		return "MainContextFlags(0)"
	}

	var parts []string
	if (f & MainContextFlagsNone) != 0 {
		parts = append(parts, "MainContextFlagsNone")
	}
	if (f & MainContextFlagsOwnerlessPolling) != 0 {
		parts = append(parts, "MainContextFlagsOwnerlessPolling")
	}
	return "MainContextFlags(" + strings.Join(parts, "|") + ")"
}

// MarkupCollectType wraps GMarkupCollectType
//
// A mixed enumerated type and flags field. You must specify one type
// (string, strdup, boolean, tristate).  Additionally, you may  optionally
// bitwise OR the type with the flag %G_MARKUP_COLLECT_OPTIONAL.
// 
// It is likely that this enum will be extended in the future to
// support other types.
type MarkupCollectType C.gint

const (
	// MarkupCollectInvalid wraps G_MARKUP_COLLECT_INVALID
	//
	// used to terminate the list of attributes
	//     to collect
	MarkupCollectInvalid MarkupCollectType = 0
	// MarkupCollectString wraps G_MARKUP_COLLECT_STRING
	//
	// collect the string pointer directly from
	//     the attribute_values[] array. Expects a parameter of type (const
	//     char **). If %G_MARKUP_COLLECT_OPTIONAL is specified and the
	//     attribute isn't present then the pointer will be set to %NULL
	MarkupCollectString MarkupCollectType = 1
	// MarkupCollectStrdup wraps G_MARKUP_COLLECT_STRDUP
	//
	// as with %G_MARKUP_COLLECT_STRING, but
	//     expects a parameter of type (char **) and g_strdup()s the
	//     returned pointer. The pointer must be freed with g_free()
	MarkupCollectStrdup MarkupCollectType = 2
	// MarkupCollectBoolean wraps G_MARKUP_COLLECT_BOOLEAN
	//
	// expects a parameter of type (`gboolean *`)
	//     and parses the attribute value as a boolean. Sets %FALSE if the
	//     attribute isn't present. Valid boolean values consist of
	//     (case-insensitive) "false", "f", "no", "n", "0" and "true", "t",
	//     "yes", "y", "1"
	MarkupCollectBoolean MarkupCollectType = 3
	// MarkupCollectTristate wraps G_MARKUP_COLLECT_TRISTATE
	//
	// as with %G_MARKUP_COLLECT_BOOLEAN, but
	//     in the case of a missing attribute a value is set that compares
	//     equal to neither %FALSE nor %TRUE %G_MARKUP_COLLECT_OPTIONAL is
	//     implied
	MarkupCollectTristate MarkupCollectType = 4
	// MarkupCollectOptional wraps G_MARKUP_COLLECT_OPTIONAL
	//
	// can be bitwise ORed with the other fields.
	//     If present, allows the attribute not to appear. A default value
	//     is set depending on what value type is used
	MarkupCollectOptional MarkupCollectType = 65536
)

// Has returns true if m contains other
func (m MarkupCollectType) Has(other MarkupCollectType) bool {
	return (m & other) == other
}

func (f MarkupCollectType) String() string {
	if f == 0 {
		return "MarkupCollectType(0)"
	}

	var parts []string
	if (f & MarkupCollectInvalid) != 0 {
		parts = append(parts, "MarkupCollectInvalid")
	}
	if (f & MarkupCollectString) != 0 {
		parts = append(parts, "MarkupCollectString")
	}
	if (f & MarkupCollectStrdup) != 0 {
		parts = append(parts, "MarkupCollectStrdup")
	}
	if (f & MarkupCollectBoolean) != 0 {
		parts = append(parts, "MarkupCollectBoolean")
	}
	if (f & MarkupCollectTristate) != 0 {
		parts = append(parts, "MarkupCollectTristate")
	}
	if (f & MarkupCollectOptional) != 0 {
		parts = append(parts, "MarkupCollectOptional")
	}
	return "MarkupCollectType(" + strings.Join(parts, "|") + ")"
}

// MarkupParseFlags wraps GMarkupParseFlags
//
// Flags that affect the behaviour of the parser.
type MarkupParseFlags C.gint

const (
	// MarkupDefaultFlags wraps G_MARKUP_DEFAULT_FLAGS
	//
	// No special behaviour. Since: 2.74
	MarkupDefaultFlags MarkupParseFlags = 0
	// MarkupDoNotUseThisUnsupportedFlag wraps G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG
	//
	// flag you should not use
	MarkupDoNotUseThisUnsupportedFlag MarkupParseFlags = 1
	// MarkupTreatCdataAsText wraps G_MARKUP_TREAT_CDATA_AS_TEXT
	//
	// When this flag is set, CDATA marked
	//     sections are not passed literally to the @passthrough function of
	//     the parser. Instead, the content of the section (without the
	//     `&lt;![CDATA[` and `]]&gt;`) is
	//     passed to the @text function. This flag was added in GLib 2.12
	MarkupTreatCdataAsText MarkupParseFlags = 2
	// MarkupPrefixErrorPosition wraps G_MARKUP_PREFIX_ERROR_POSITION
	//
	// Normally errors caught by GMarkup
	//     itself have line/column information prefixed to them to let the
	//     caller know the location of the error. When this flag is set the
	//     location information is also prefixed to errors generated by the
	//     #GMarkupParser implementation functions
	MarkupPrefixErrorPosition MarkupParseFlags = 4
	// MarkupIgnoreQualified wraps G_MARKUP_IGNORE_QUALIFIED
	//
	// Ignore (don't report) qualified
	//     attributes and tags, along with their contents.  A qualified
	//     attribute or tag is one that contains ':' in its name (ie: is in
	//     another namespace).  Since: 2.40.
	MarkupIgnoreQualified MarkupParseFlags = 8
)

// Has returns true if m contains other
func (m MarkupParseFlags) Has(other MarkupParseFlags) bool {
	return (m & other) == other
}

func (f MarkupParseFlags) String() string {
	if f == 0 {
		return "MarkupParseFlags(0)"
	}

	var parts []string
	if (f & MarkupDefaultFlags) != 0 {
		parts = append(parts, "MarkupDefaultFlags")
	}
	if (f & MarkupDoNotUseThisUnsupportedFlag) != 0 {
		parts = append(parts, "MarkupDoNotUseThisUnsupportedFlag")
	}
	if (f & MarkupTreatCdataAsText) != 0 {
		parts = append(parts, "MarkupTreatCdataAsText")
	}
	if (f & MarkupPrefixErrorPosition) != 0 {
		parts = append(parts, "MarkupPrefixErrorPosition")
	}
	if (f & MarkupIgnoreQualified) != 0 {
		parts = append(parts, "MarkupIgnoreQualified")
	}
	return "MarkupParseFlags(" + strings.Join(parts, "|") + ")"
}

// OptionFlags wraps GOptionFlags
//
// Flags which modify individual options.
type OptionFlags C.gint

const (
	// OptionFlagNone wraps G_OPTION_FLAG_NONE
	//
	// No flags.
	OptionFlagNone OptionFlags = 0
	// OptionFlagHidden wraps G_OPTION_FLAG_HIDDEN
	//
	// The option doesn't appear in `--help` output.
	OptionFlagHidden OptionFlags = 1
	// OptionFlagInMain wraps G_OPTION_FLAG_IN_MAIN
	//
	// The option appears in the main section of the
	//   `--help` output, even if it is defined in a group.
	OptionFlagInMain OptionFlags = 2
	// OptionFlagReverse wraps G_OPTION_FLAG_REVERSE
	//
	// For options of the %G_OPTION_ARG_NONE kind, this
	//   flag indicates that the sense of the option is reversed. i.e. %FALSE will
	//   be stored into the argument rather than %TRUE.
	OptionFlagReverse OptionFlags = 4
	// OptionFlagNoArg wraps G_OPTION_FLAG_NO_ARG
	//
	// For options of the %G_OPTION_ARG_CALLBACK kind,
	//   this flag indicates that the callback does not take any argument
	//   (like a %G_OPTION_ARG_NONE option). Since 2.8
	OptionFlagNoArg OptionFlags = 8
	// OptionFlagFilename wraps G_OPTION_FLAG_FILENAME
	//
	// For options of the %G_OPTION_ARG_CALLBACK
	//   kind, this flag indicates that the argument should be passed to the
	//   callback in the GLib filename encoding rather than UTF-8. Since 2.8
	OptionFlagFilename OptionFlags = 16
	// OptionFlagOptionalArg wraps G_OPTION_FLAG_OPTIONAL_ARG
	//
	// For options of the %G_OPTION_ARG_CALLBACK
	//   kind, this flag indicates that the argument supply is optional.
	//   If no argument is given then data of %GOptionParseFunc will be
	//   set to NULL. Since 2.8
	OptionFlagOptionalArg OptionFlags = 32
	// OptionFlagNoalias wraps G_OPTION_FLAG_NOALIAS
	//
	// This flag turns off the automatic conflict
	//   resolution which prefixes long option names with `groupname-` if
	//   there is a conflict. This option should only be used in situations
	//   where aliasing is necessary to model some legacy commandline interface.
	//   It is not safe to use this option, unless all option groups are under
	//   your direct control. Since 2.8.
	OptionFlagNoalias OptionFlags = 64
	// OptionFlagDeprecated wraps G_OPTION_FLAG_DEPRECATED
	//
	// This flag marks the option as deprecated in the `--help`.
	// 
	// You should update the description of the option to describe what
	// the user should do in response to the deprecation, for instance:
	// remove the option, or replace it with another one.
	OptionFlagDeprecated OptionFlags = 128
)

// Has returns true if o contains other
func (o OptionFlags) Has(other OptionFlags) bool {
	return (o & other) == other
}

func (f OptionFlags) String() string {
	if f == 0 {
		return "OptionFlags(0)"
	}

	var parts []string
	if (f & OptionFlagNone) != 0 {
		parts = append(parts, "OptionFlagNone")
	}
	if (f & OptionFlagHidden) != 0 {
		parts = append(parts, "OptionFlagHidden")
	}
	if (f & OptionFlagInMain) != 0 {
		parts = append(parts, "OptionFlagInMain")
	}
	if (f & OptionFlagReverse) != 0 {
		parts = append(parts, "OptionFlagReverse")
	}
	if (f & OptionFlagNoArg) != 0 {
		parts = append(parts, "OptionFlagNoArg")
	}
	if (f & OptionFlagFilename) != 0 {
		parts = append(parts, "OptionFlagFilename")
	}
	if (f & OptionFlagOptionalArg) != 0 {
		parts = append(parts, "OptionFlagOptionalArg")
	}
	if (f & OptionFlagNoalias) != 0 {
		parts = append(parts, "OptionFlagNoalias")
	}
	if (f & OptionFlagDeprecated) != 0 {
		parts = append(parts, "OptionFlagDeprecated")
	}
	return "OptionFlags(" + strings.Join(parts, "|") + ")"
}

// RegexCompileFlags wraps GRegexCompileFlags
//
// Flags specifying compile-time options.
type RegexCompileFlags C.gint

const (
	// RegexDefault wraps G_REGEX_DEFAULT
	//
	// No special options set. Since: 2.74
	RegexDefault RegexCompileFlags = 0
	// RegexCaseless wraps G_REGEX_CASELESS
	//
	// Letters in the pattern match both upper- and
	//     lowercase letters. This option can be changed within a pattern
	//     by a "(?i)" option setting.
	RegexCaseless RegexCompileFlags = 1
	// RegexMultiline wraps G_REGEX_MULTILINE
	//
	// By default, GRegex treats the strings as consisting
	//     of a single line of characters (even if it actually contains
	//     newlines). The "start of line" metacharacter ("^") matches only
	//     at the start of the string, while the "end of line" metacharacter
	//     ("$") matches only at the end of the string, or before a terminating
	//     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When
	//     %G_REGEX_MULTILINE is set, the "start of line" and "end of line"
	//     constructs match immediately following or immediately before any
	//     newline in the string, respectively, as well as at the very start
	//     and end. This can be changed within a pattern by a "(?m)" option
	//     setting.
	RegexMultiline RegexCompileFlags = 2
	// RegexDotall wraps G_REGEX_DOTALL
	//
	// A dot metacharacter (".") in the pattern matches all
	//     characters, including newlines. Without it, newlines are excluded.
	//     This option can be changed within a pattern by a ("?s") option setting.
	RegexDotall RegexCompileFlags = 4
	// RegexExtended wraps G_REGEX_EXTENDED
	//
	// Whitespace data characters in the pattern are
	//     totally ignored except when escaped or inside a character class.
	//     Whitespace does not include the VT character (code 11). In addition,
	//     characters between an unescaped "#" outside a character class and
	//     the next newline character, inclusive, are also ignored. This can
	//     be changed within a pattern by a "(?x)" option setting.
	RegexExtended RegexCompileFlags = 8
	// RegexAnchored wraps G_REGEX_ANCHORED
	//
	// The pattern is forced to be "anchored", that is,
	//     it is constrained to match only at the first matching point in the
	//     string that is being searched. This effect can also be achieved by
	//     appropriate constructs in the pattern itself such as the "^"
	//     metacharacter.
	RegexAnchored RegexCompileFlags = 16
	// RegexDollarEndonly wraps G_REGEX_DOLLAR_ENDONLY
	//
	// A dollar metacharacter ("$") in the pattern
	//     matches only at the end of the string. Without this option, a
	//     dollar also matches immediately before the final character if
	//     it is a newline (but not before any other newlines). This option
	//     is ignored if %G_REGEX_MULTILINE is set.
	RegexDollarEndonly RegexCompileFlags = 32
	// RegexUngreedy wraps G_REGEX_UNGREEDY
	//
	// Inverts the "greediness" of the quantifiers so that
	//     they are not greedy by default, but become greedy if followed by "?".
	//     It can also be set by a "(?U)" option setting within the pattern.
	RegexUngreedy RegexCompileFlags = 512
	// RegexRaw wraps G_REGEX_RAW
	//
	// Usually strings must be valid UTF-8 strings, using this
	//     flag they are considered as a raw sequence of bytes.
	RegexRaw RegexCompileFlags = 2048
	// RegexNoAutoCapture wraps G_REGEX_NO_AUTO_CAPTURE
	//
	// Disables the use of numbered capturing
	//     parentheses in the pattern. Any opening parenthesis that is not
	//     followed by "?" behaves as if it were followed by "?:" but named
	//     parentheses can still be used for capturing (and they acquire numbers
	//     in the usual way).
	RegexNoAutoCapture RegexCompileFlags = 4096
	// RegexOptimize wraps G_REGEX_OPTIMIZE
	//
	// Since 2.74 and the port to pcre2, requests JIT
	//     compilation, which, if the just-in-time compiler is available, further
	//     processes a compiled pattern into machine code that executes much
	//     faster. However, it comes at the cost of extra processing before the
	//     match is performed, so it is most beneficial to use this when the same
	//     compiled pattern is used for matching many times. Before 2.74 this
	//     option used the built-in non-JIT optimizations in pcre1.
	RegexOptimize RegexCompileFlags = 8192
	// RegexFirstline wraps G_REGEX_FIRSTLINE
	//
	// Limits an unanchored pattern to match before (or at) the
	//     first newline. Since: 2.34
	RegexFirstline RegexCompileFlags = 262144
	// RegexDupnames wraps G_REGEX_DUPNAMES
	//
	// Names used to identify capturing subpatterns need not
	//     be unique. This can be helpful for certain types of pattern when it
	//     is known that only one instance of the named subpattern can ever be
	//     matched.
	RegexDupnames RegexCompileFlags = 524288
	// RegexNewlineCr wraps G_REGEX_NEWLINE_CR
	//
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     is '\r'.
	RegexNewlineCr RegexCompileFlags = 1048576
	// RegexNewlineLf wraps G_REGEX_NEWLINE_LF
	//
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     is '\n'.
	RegexNewlineLf RegexCompileFlags = 2097152
	// RegexNewlineCrlf wraps G_REGEX_NEWLINE_CRLF
	//
	// Usually any newline character or character sequence is
	//     recognized. If this option is set, the only recognized newline character
	//     sequence is '\r\n'.
	RegexNewlineCrlf RegexCompileFlags = 3145728
	// RegexNewlineAnycrlf wraps G_REGEX_NEWLINE_ANYCRLF
	//
	// Usually any newline character or character sequence
	//     is recognized. If this option is set, the only recognized newline character
	//     sequences are '\r', '\n', and '\r\n'. Since: 2.34
	RegexNewlineAnycrlf RegexCompileFlags = 5242880
	// RegexBsrAnycrlf wraps G_REGEX_BSR_ANYCRLF
	//
	// Usually any newline character or character sequence
	//     is recognised. If this option is set, then "\R" only recognizes the newline
	//    characters '\r', '\n' and '\r\n'. Since: 2.34
	RegexBsrAnycrlf RegexCompileFlags = 8388608
	// RegexJavascriptCompat wraps G_REGEX_JAVASCRIPT_COMPAT
	//
	// Changes behaviour so that it is compatible with
	//     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,
	//     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74
	RegexJavascriptCompat RegexCompileFlags = 33554432
)

// Has returns true if r contains other
func (r RegexCompileFlags) Has(other RegexCompileFlags) bool {
	return (r & other) == other
}

func (f RegexCompileFlags) String() string {
	if f == 0 {
		return "RegexCompileFlags(0)"
	}

	var parts []string
	if (f & RegexDefault) != 0 {
		parts = append(parts, "RegexDefault")
	}
	if (f & RegexCaseless) != 0 {
		parts = append(parts, "RegexCaseless")
	}
	if (f & RegexMultiline) != 0 {
		parts = append(parts, "RegexMultiline")
	}
	if (f & RegexDotall) != 0 {
		parts = append(parts, "RegexDotall")
	}
	if (f & RegexExtended) != 0 {
		parts = append(parts, "RegexExtended")
	}
	if (f & RegexAnchored) != 0 {
		parts = append(parts, "RegexAnchored")
	}
	if (f & RegexDollarEndonly) != 0 {
		parts = append(parts, "RegexDollarEndonly")
	}
	if (f & RegexUngreedy) != 0 {
		parts = append(parts, "RegexUngreedy")
	}
	if (f & RegexRaw) != 0 {
		parts = append(parts, "RegexRaw")
	}
	if (f & RegexNoAutoCapture) != 0 {
		parts = append(parts, "RegexNoAutoCapture")
	}
	if (f & RegexOptimize) != 0 {
		parts = append(parts, "RegexOptimize")
	}
	if (f & RegexFirstline) != 0 {
		parts = append(parts, "RegexFirstline")
	}
	if (f & RegexDupnames) != 0 {
		parts = append(parts, "RegexDupnames")
	}
	if (f & RegexNewlineCr) != 0 {
		parts = append(parts, "RegexNewlineCr")
	}
	if (f & RegexNewlineLf) != 0 {
		parts = append(parts, "RegexNewlineLf")
	}
	if (f & RegexNewlineCrlf) != 0 {
		parts = append(parts, "RegexNewlineCrlf")
	}
	if (f & RegexNewlineAnycrlf) != 0 {
		parts = append(parts, "RegexNewlineAnycrlf")
	}
	if (f & RegexBsrAnycrlf) != 0 {
		parts = append(parts, "RegexBsrAnycrlf")
	}
	if (f & RegexJavascriptCompat) != 0 {
		parts = append(parts, "RegexJavascriptCompat")
	}
	return "RegexCompileFlags(" + strings.Join(parts, "|") + ")"
}

// RegexMatchFlags wraps GRegexMatchFlags
//
// Flags specifying match-time options.
type RegexMatchFlags C.gint

const (
	// RegexMatchDefault wraps G_REGEX_MATCH_DEFAULT
	//
	// No special options set. Since: 2.74
	RegexMatchDefault RegexMatchFlags = 0
	// RegexMatchAnchored wraps G_REGEX_MATCH_ANCHORED
	//
	// The pattern is forced to be "anchored", that is,
	//     it is constrained to match only at the first matching point in the
	//     string that is being searched. This effect can also be achieved by
	//     appropriate constructs in the pattern itself such as the "^"
	//     metacharacter.
	RegexMatchAnchored RegexMatchFlags = 16
	// RegexMatchNotbol wraps G_REGEX_MATCH_NOTBOL
	//
	// Specifies that first character of the string is
	//     not the beginning of a line, so the circumflex metacharacter should
	//     not match before it. Setting this without %G_REGEX_MULTILINE (at
	//     compile time) causes circumflex never to match. This option affects
	//     only the behaviour of the circumflex metacharacter, it does not
	//     affect "\A".
	RegexMatchNotbol RegexMatchFlags = 128
	// RegexMatchNoteol wraps G_REGEX_MATCH_NOTEOL
	//
	// Specifies that the end of the subject string is
	//     not the end of a line, so the dollar metacharacter should not match
	//     it nor (except in multiline mode) a newline immediately before it.
	//     Setting this without %G_REGEX_MULTILINE (at compile time) causes
	//     dollar never to match. This option affects only the behaviour of
	//     the dollar metacharacter, it does not affect "\Z" or "\z".
	RegexMatchNoteol RegexMatchFlags = 256
	// RegexMatchNotempty wraps G_REGEX_MATCH_NOTEMPTY
	//
	// An empty string is not considered to be a valid
	//     match if this option is set. If there are alternatives in the pattern,
	//     they are tried. If all the alternatives match the empty string, the
	//     entire match fails. For example, if the pattern "a?b?" is applied to
	//     a string not beginning with "a" or "b", it matches the empty string
	//     at the start of the string. With this flag set, this match is not
	//     valid, so GRegex searches further into the string for occurrences
	//     of "a" or "b".
	RegexMatchNotempty RegexMatchFlags = 1024
	// RegexMatchPartial wraps G_REGEX_MATCH_PARTIAL
	//
	// Turns on the partial matching feature, for more
	//     documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchPartial RegexMatchFlags = 32768
	// RegexMatchNewlineCr wraps G_REGEX_MATCH_NEWLINE_CR
	//
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\r' character as line terminator.
	RegexMatchNewlineCr RegexMatchFlags = 1048576
	// RegexMatchNewlineLf wraps G_REGEX_MATCH_NEWLINE_LF
	//
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\n' character as line terminator.
	RegexMatchNewlineLf RegexMatchFlags = 2097152
	// RegexMatchNewlineCrlf wraps G_REGEX_MATCH_NEWLINE_CRLF
	//
	// Overrides the newline definition set when
	//     creating a new #GRegex, setting the '\r\n' characters sequence as line terminator.
	RegexMatchNewlineCrlf RegexMatchFlags = 3145728
	// RegexMatchNewlineAny wraps G_REGEX_MATCH_NEWLINE_ANY
	//
	// Overrides the newline definition set when
	//     creating a new #GRegex, any Unicode newline sequence
	//     is recognised as a newline. These are '\r', '\n' and '\rn', and the
	//     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
	//     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
	//     U+2029 PARAGRAPH SEPARATOR.
	RegexMatchNewlineAny RegexMatchFlags = 4194304
	// RegexMatchNewlineAnycrlf wraps G_REGEX_MATCH_NEWLINE_ANYCRLF
	//
	// Overrides the newline definition set when
	//     creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence
	//     is recognized as a newline. Since: 2.34
	RegexMatchNewlineAnycrlf RegexMatchFlags = 5242880
	// RegexMatchBsrAnycrlf wraps G_REGEX_MATCH_BSR_ANYCRLF
	//
	// Overrides the newline definition for "\R" set when
	//     creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
	//     are recognized as a newline by "\R". Since: 2.34
	RegexMatchBsrAnycrlf RegexMatchFlags = 8388608
	// RegexMatchBsrAny wraps G_REGEX_MATCH_BSR_ANY
	//
	// Overrides the newline definition for "\R" set when
	//     creating a new #GRegex; any Unicode newline character or character sequence
	//     are recognized as a newline by "\R". These are '\r', '\n' and '\rn', and the
	//     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
	//     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
	//     U+2029 PARAGRAPH SEPARATOR. Since: 2.34
	RegexMatchBsrAny RegexMatchFlags = 16777216
	// RegexMatchPartialSoft wraps G_REGEX_MATCH_PARTIAL_SOFT
	//
	// An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34
	RegexMatchPartialSoft RegexMatchFlags = 32768
	// RegexMatchPartialHard wraps G_REGEX_MATCH_PARTIAL_HARD
	//
	// Turns on the partial matching feature. In contrast to
	//     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
	//     is found, without continuing to search for a possible complete match. See
	//     g_match_info_is_partial_match() for more information. Since: 2.34
	RegexMatchPartialHard RegexMatchFlags = 134217728
	// RegexMatchNotemptyAtstart wraps G_REGEX_MATCH_NOTEMPTY_ATSTART
	//
	// Like %G_REGEX_MATCH_NOTEMPTY, but only applied to
	//     the start of the matched string. For anchored
	//     patterns this can only happen for pattern containing "\K". Since: 2.34
	RegexMatchNotemptyAtstart RegexMatchFlags = 268435456
)

// Has returns true if r contains other
func (r RegexMatchFlags) Has(other RegexMatchFlags) bool {
	return (r & other) == other
}

func (f RegexMatchFlags) String() string {
	if f == 0 {
		return "RegexMatchFlags(0)"
	}

	var parts []string
	if (f & RegexMatchDefault) != 0 {
		parts = append(parts, "RegexMatchDefault")
	}
	if (f & RegexMatchAnchored) != 0 {
		parts = append(parts, "RegexMatchAnchored")
	}
	if (f & RegexMatchNotbol) != 0 {
		parts = append(parts, "RegexMatchNotbol")
	}
	if (f & RegexMatchNoteol) != 0 {
		parts = append(parts, "RegexMatchNoteol")
	}
	if (f & RegexMatchNotempty) != 0 {
		parts = append(parts, "RegexMatchNotempty")
	}
	if (f & RegexMatchPartial) != 0 {
		parts = append(parts, "RegexMatchPartial")
	}
	if (f & RegexMatchNewlineCr) != 0 {
		parts = append(parts, "RegexMatchNewlineCr")
	}
	if (f & RegexMatchNewlineLf) != 0 {
		parts = append(parts, "RegexMatchNewlineLf")
	}
	if (f & RegexMatchNewlineCrlf) != 0 {
		parts = append(parts, "RegexMatchNewlineCrlf")
	}
	if (f & RegexMatchNewlineAny) != 0 {
		parts = append(parts, "RegexMatchNewlineAny")
	}
	if (f & RegexMatchNewlineAnycrlf) != 0 {
		parts = append(parts, "RegexMatchNewlineAnycrlf")
	}
	if (f & RegexMatchBsrAnycrlf) != 0 {
		parts = append(parts, "RegexMatchBsrAnycrlf")
	}
	if (f & RegexMatchBsrAny) != 0 {
		parts = append(parts, "RegexMatchBsrAny")
	}
	if (f & RegexMatchPartialSoft) != 0 {
		parts = append(parts, "RegexMatchPartialSoft")
	}
	if (f & RegexMatchPartialHard) != 0 {
		parts = append(parts, "RegexMatchPartialHard")
	}
	if (f & RegexMatchNotemptyAtstart) != 0 {
		parts = append(parts, "RegexMatchNotemptyAtstart")
	}
	return "RegexMatchFlags(" + strings.Join(parts, "|") + ")"
}

// SpawnFlags wraps GSpawnFlags
//
// Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
type SpawnFlags C.gint

const (
	// SpawnDefault wraps G_SPAWN_DEFAULT
	//
	// no flags, default behaviour
	SpawnDefault SpawnFlags = 0
	// SpawnLeaveDescriptorsOpen wraps G_SPAWN_LEAVE_DESCRIPTORS_OPEN
	//
	// the parent's open file descriptors will
	//     be inherited by the child; otherwise all descriptors except stdin,
	//     stdout and stderr will be closed before calling exec() in the child.
	SpawnLeaveDescriptorsOpen SpawnFlags = 1
	// SpawnDoNotReapChild wraps G_SPAWN_DO_NOT_REAP_CHILD
	//
	// the child will not be automatically reaped;
	//     you must use g_child_watch_add() yourself (or call waitpid() or handle
	//     `SIGCHLD` yourself), or the child will become a zombie.
	SpawnDoNotReapChild SpawnFlags = 2
	// SpawnSearchPath wraps G_SPAWN_SEARCH_PATH
	//
	// `argv[0]` need not be an absolute path, it will be
	//     looked for in the user's `PATH`.
	SpawnSearchPath SpawnFlags = 4
	// SpawnStdoutToDevNull wraps G_SPAWN_STDOUT_TO_DEV_NULL
	//
	// the child's standard output will be discarded,
	//     instead of going to the same location as the parent's standard output.
	SpawnStdoutToDevNull SpawnFlags = 8
	// SpawnStderrToDevNull wraps G_SPAWN_STDERR_TO_DEV_NULL
	//
	// the child's standard error will be discarded.
	SpawnStderrToDevNull SpawnFlags = 16
	// SpawnChildInheritsStdin wraps G_SPAWN_CHILD_INHERITS_STDIN
	//
	// the child will inherit the parent's standard
	//     input (by default, the child's standard input is attached to `/dev/null`).
	SpawnChildInheritsStdin SpawnFlags = 32
	// SpawnFileAndArgvZero wraps G_SPAWN_FILE_AND_ARGV_ZERO
	//
	// the first element of `argv` is the file to
	//     execute, while the remaining elements are the actual argument vector
	//     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
	//     as the file to execute, and passes all of `argv` to the child.
	SpawnFileAndArgvZero SpawnFlags = 64
	// SpawnSearchPathFromEnvp wraps G_SPAWN_SEARCH_PATH_FROM_ENVP
	//
	// if `argv[0]` is not an absolute path,
	//     it will be looked for in the `PATH` from the passed child environment.
	//     Since: 2.34
	SpawnSearchPathFromEnvp SpawnFlags = 128
	// SpawnCloexecPipes wraps G_SPAWN_CLOEXEC_PIPES
	//
	// create all pipes with the `O_CLOEXEC` flag set.
	//     Since: 2.40
	SpawnCloexecPipes SpawnFlags = 256
	// SpawnChildInheritsStdout wraps G_SPAWN_CHILD_INHERITS_STDOUT
	//
	// The child will inherit the parent's standard output.
	SpawnChildInheritsStdout SpawnFlags = 512
	// SpawnChildInheritsStderr wraps G_SPAWN_CHILD_INHERITS_STDERR
	//
	// The child will inherit the parent's standard error.
	SpawnChildInheritsStderr SpawnFlags = 1024
	// SpawnStdinFromDevNull wraps G_SPAWN_STDIN_FROM_DEV_NULL
	//
	// The child's standard input is attached to `/dev/null`.
	SpawnStdinFromDevNull SpawnFlags = 2048
)

// Has returns true if s contains other
func (s SpawnFlags) Has(other SpawnFlags) bool {
	return (s & other) == other
}

func (f SpawnFlags) String() string {
	if f == 0 {
		return "SpawnFlags(0)"
	}

	var parts []string
	if (f & SpawnDefault) != 0 {
		parts = append(parts, "SpawnDefault")
	}
	if (f & SpawnLeaveDescriptorsOpen) != 0 {
		parts = append(parts, "SpawnLeaveDescriptorsOpen")
	}
	if (f & SpawnDoNotReapChild) != 0 {
		parts = append(parts, "SpawnDoNotReapChild")
	}
	if (f & SpawnSearchPath) != 0 {
		parts = append(parts, "SpawnSearchPath")
	}
	if (f & SpawnStdoutToDevNull) != 0 {
		parts = append(parts, "SpawnStdoutToDevNull")
	}
	if (f & SpawnStderrToDevNull) != 0 {
		parts = append(parts, "SpawnStderrToDevNull")
	}
	if (f & SpawnChildInheritsStdin) != 0 {
		parts = append(parts, "SpawnChildInheritsStdin")
	}
	if (f & SpawnFileAndArgvZero) != 0 {
		parts = append(parts, "SpawnFileAndArgvZero")
	}
	if (f & SpawnSearchPathFromEnvp) != 0 {
		parts = append(parts, "SpawnSearchPathFromEnvp")
	}
	if (f & SpawnCloexecPipes) != 0 {
		parts = append(parts, "SpawnCloexecPipes")
	}
	if (f & SpawnChildInheritsStdout) != 0 {
		parts = append(parts, "SpawnChildInheritsStdout")
	}
	if (f & SpawnChildInheritsStderr) != 0 {
		parts = append(parts, "SpawnChildInheritsStderr")
	}
	if (f & SpawnStdinFromDevNull) != 0 {
		parts = append(parts, "SpawnStdinFromDevNull")
	}
	return "SpawnFlags(" + strings.Join(parts, "|") + ")"
}

// TestSubprocessFlags wraps GTestSubprocessFlags
//
// Flags to pass to [func@GLib.test_trap_subprocess] to control input and output.
// 
// Note that in contrast with [func@GLib.test_trap_fork], the default
// behavior of [func@GLib.test_trap_subprocess] is to not show stdout
// and stderr.
type TestSubprocessFlags C.gint

const (
	// TestSubprocessDefault wraps G_TEST_SUBPROCESS_DEFAULT
	//
	// Default behaviour. Since: 2.74
	TestSubprocessDefault TestSubprocessFlags = 0
	// TestSubprocessInheritStdin wraps G_TEST_SUBPROCESS_INHERIT_STDIN
	//
	// If this flag is given, the child
	//   process will inherit the parent's stdin. Otherwise, the child's
	//   stdin is redirected to `/dev/null`.
	TestSubprocessInheritStdin TestSubprocessFlags = 1
	// TestSubprocessInheritStdout wraps G_TEST_SUBPROCESS_INHERIT_STDOUT
	//
	// If this flag is given, the child
	//   process will inherit the parent's stdout. Otherwise, the child's
	//   stdout will not be visible, but it will be captured to allow
	//   later tests with [func@GLib.test_trap_assert_stdout].
	TestSubprocessInheritStdout TestSubprocessFlags = 2
	// TestSubprocessInheritStderr wraps G_TEST_SUBPROCESS_INHERIT_STDERR
	//
	// If this flag is given, the child
	//   process will inherit the parent's stderr. Otherwise, the child's
	//   stderr will not be visible, but it will be captured to allow
	//   later tests with [func@GLib.test_trap_assert_stderr].
	TestSubprocessInheritStderr TestSubprocessFlags = 4
)

// Has returns true if t contains other
func (t TestSubprocessFlags) Has(other TestSubprocessFlags) bool {
	return (t & other) == other
}

func (f TestSubprocessFlags) String() string {
	if f == 0 {
		return "TestSubprocessFlags(0)"
	}

	var parts []string
	if (f & TestSubprocessDefault) != 0 {
		parts = append(parts, "TestSubprocessDefault")
	}
	if (f & TestSubprocessInheritStdin) != 0 {
		parts = append(parts, "TestSubprocessInheritStdin")
	}
	if (f & TestSubprocessInheritStdout) != 0 {
		parts = append(parts, "TestSubprocessInheritStdout")
	}
	if (f & TestSubprocessInheritStderr) != 0 {
		parts = append(parts, "TestSubprocessInheritStderr")
	}
	return "TestSubprocessFlags(" + strings.Join(parts, "|") + ")"
}

// TraverseFlags wraps GTraverseFlags
//
// Specifies which nodes are visited during several of the tree
// functions, including g_node_traverse() and g_node_find().
type TraverseFlags C.gint

const (
	// TraverseLeaves wraps G_TRAVERSE_LEAVES
	//
	// only leaf nodes should be visited. This name has
	//                     been introduced in 2.6, for older version use
	//                     %G_TRAVERSE_LEAFS.
	TraverseLeaves TraverseFlags = 1
	// TraverseNonLeaves wraps G_TRAVERSE_NON_LEAVES
	//
	// only non-leaf nodes should be visited. This
	//                         name has been introduced in 2.6, for older
	//                         version use %G_TRAVERSE_NON_LEAFS.
	TraverseNonLeaves TraverseFlags = 2
	// TraverseAll wraps G_TRAVERSE_ALL
	//
	// all nodes should be visited.
	TraverseAll TraverseFlags = 3
	// TraverseMask wraps G_TRAVERSE_MASK
	//
	// a mask of all traverse flags.
	TraverseMask TraverseFlags = 3
	// TraverseLeafs wraps G_TRAVERSE_LEAFS
	//
	// identical to %G_TRAVERSE_LEAVES.
	TraverseLeafs TraverseFlags = 1
	// TraverseNonLeafs wraps G_TRAVERSE_NON_LEAFS
	//
	// identical to %G_TRAVERSE_NON_LEAVES.
	TraverseNonLeafs TraverseFlags = 2
)

// Has returns true if t contains other
func (t TraverseFlags) Has(other TraverseFlags) bool {
	return (t & other) == other
}

func (f TraverseFlags) String() string {
	if f == 0 {
		return "TraverseFlags(0)"
	}

	var parts []string
	if (f & TraverseLeaves) != 0 {
		parts = append(parts, "TraverseLeaves")
	}
	if (f & TraverseNonLeaves) != 0 {
		parts = append(parts, "TraverseNonLeaves")
	}
	if (f & TraverseAll) != 0 {
		parts = append(parts, "TraverseAll")
	}
	if (f & TraverseMask) != 0 {
		parts = append(parts, "TraverseMask")
	}
	if (f & TraverseLeafs) != 0 {
		parts = append(parts, "TraverseLeafs")
	}
	if (f & TraverseNonLeafs) != 0 {
		parts = append(parts, "TraverseNonLeafs")
	}
	return "TraverseFlags(" + strings.Join(parts, "|") + ")"
}

// UriFlags wraps GUriFlags
//
// Flags that describe a URI.
// 
// When parsing a URI, if you need to choose different flags based on
// the type of URI, you can use g_uri_peek_scheme() on the URI string
// to check the scheme first, and use that to decide what flags to
// parse it with.
type UriFlags C.gint

const (
	// URIFlagsNone wraps G_URI_FLAGS_NONE
	//
	// No flags set.
	URIFlagsNone UriFlags = 0
	// URIFlagsParseRelaxed wraps G_URI_FLAGS_PARSE_RELAXED
	//
	// Parse the URI more relaxedly than the
	//     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
	//     fixing up or ignoring common mistakes in URIs coming from external
	//     sources. This is also needed for some obscure URI schemes where `;`
	//     separates the host from the path. Don&#x2019;t use this flag unless you need to.
	URIFlagsParseRelaxed UriFlags = 1
	// URIFlagsHasPassword wraps G_URI_FLAGS_HAS_PASSWORD
	//
	// The userinfo field may contain a password,
	//     which will be separated from the username by `:`.
	URIFlagsHasPassword UriFlags = 2
	// URIFlagsHasAuthParams wraps G_URI_FLAGS_HAS_AUTH_PARAMS
	//
	// The userinfo may contain additional
	//     authentication-related parameters, which will be separated from
	//     the username and/or password by `;`.
	URIFlagsHasAuthParams UriFlags = 4
	// URIFlagsEncoded wraps G_URI_FLAGS_ENCODED
	//
	// When parsing a URI, this indicates that `%`-encoded
	//     characters in the userinfo, path, query, and fragment fields
	//     should not be decoded. (And likewise the host field if
	//     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
	//     that you have already `%`-encoded the components, and so #GUri
	//     should not do any encoding itself.
	URIFlagsEncoded UriFlags = 8
	// URIFlagsNonDns wraps G_URI_FLAGS_NON_DNS
	//
	// The host component should not be assumed to be a
	//     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
	//     hostnames).
	URIFlagsNonDns UriFlags = 16
	// URIFlagsEncodedQuery wraps G_URI_FLAGS_ENCODED_QUERY
	//
	// Same as %G_URI_FLAGS_ENCODED, for the query
	//     field only.
	URIFlagsEncodedQuery UriFlags = 32
	// URIFlagsEncodedPath wraps G_URI_FLAGS_ENCODED_PATH
	//
	// Same as %G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath UriFlags = 64
	// URIFlagsEncodedFragment wraps G_URI_FLAGS_ENCODED_FRAGMENT
	//
	// Same as %G_URI_FLAGS_ENCODED, for the
	//     fragment only.
	URIFlagsEncodedFragment UriFlags = 128
	// URIFlagsSchemeNormalize wraps G_URI_FLAGS_SCHEME_NORMALIZE
	//
	// A scheme-based normalization will be applied.
	//     For example, when parsing an HTTP URI changing omitted path to `/` and
	//     omitted port to `80`; and when building a URI, changing empty path to `/`
	//     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)
	URIFlagsSchemeNormalize UriFlags = 256
)

// Has returns true if u contains other
func (u UriFlags) Has(other UriFlags) bool {
	return (u & other) == other
}

func (f UriFlags) String() string {
	if f == 0 {
		return "UriFlags(0)"
	}

	var parts []string
	if (f & URIFlagsNone) != 0 {
		parts = append(parts, "URIFlagsNone")
	}
	if (f & URIFlagsParseRelaxed) != 0 {
		parts = append(parts, "URIFlagsParseRelaxed")
	}
	if (f & URIFlagsHasPassword) != 0 {
		parts = append(parts, "URIFlagsHasPassword")
	}
	if (f & URIFlagsHasAuthParams) != 0 {
		parts = append(parts, "URIFlagsHasAuthParams")
	}
	if (f & URIFlagsEncoded) != 0 {
		parts = append(parts, "URIFlagsEncoded")
	}
	if (f & URIFlagsNonDns) != 0 {
		parts = append(parts, "URIFlagsNonDns")
	}
	if (f & URIFlagsEncodedQuery) != 0 {
		parts = append(parts, "URIFlagsEncodedQuery")
	}
	if (f & URIFlagsEncodedPath) != 0 {
		parts = append(parts, "URIFlagsEncodedPath")
	}
	if (f & URIFlagsEncodedFragment) != 0 {
		parts = append(parts, "URIFlagsEncodedFragment")
	}
	if (f & URIFlagsSchemeNormalize) != 0 {
		parts = append(parts, "URIFlagsSchemeNormalize")
	}
	return "UriFlags(" + strings.Join(parts, "|") + ")"
}

// UriHideFlags wraps GUriHideFlags
//
// Flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
// %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
// the corresponding flags.
type UriHideFlags C.gint

const (
	// URIHideNone wraps G_URI_HIDE_NONE
	//
	// No flags set.
	URIHideNone UriHideFlags = 0
	// URIHideUserinfo wraps G_URI_HIDE_USERINFO
	//
	// Hide the userinfo.
	URIHideUserinfo UriHideFlags = 1
	// URIHidePassword wraps G_URI_HIDE_PASSWORD
	//
	// Hide the password.
	URIHidePassword UriHideFlags = 2
	// URIHideAuthParams wraps G_URI_HIDE_AUTH_PARAMS
	//
	// Hide the auth_params.
	URIHideAuthParams UriHideFlags = 4
	// URIHideQuery wraps G_URI_HIDE_QUERY
	//
	// Hide the query.
	URIHideQuery UriHideFlags = 8
	// URIHideFragment wraps G_URI_HIDE_FRAGMENT
	//
	// Hide the fragment.
	URIHideFragment UriHideFlags = 16
)

// Has returns true if u contains other
func (u UriHideFlags) Has(other UriHideFlags) bool {
	return (u & other) == other
}

func (f UriHideFlags) String() string {
	if f == 0 {
		return "UriHideFlags(0)"
	}

	var parts []string
	if (f & URIHideNone) != 0 {
		parts = append(parts, "URIHideNone")
	}
	if (f & URIHideUserinfo) != 0 {
		parts = append(parts, "URIHideUserinfo")
	}
	if (f & URIHidePassword) != 0 {
		parts = append(parts, "URIHidePassword")
	}
	if (f & URIHideAuthParams) != 0 {
		parts = append(parts, "URIHideAuthParams")
	}
	if (f & URIHideQuery) != 0 {
		parts = append(parts, "URIHideQuery")
	}
	if (f & URIHideFragment) != 0 {
		parts = append(parts, "URIHideFragment")
	}
	return "UriHideFlags(" + strings.Join(parts, "|") + ")"
}

// UriParamsFlags wraps GUriParamsFlags
//
// Flags modifying the way parameters are handled by g_uri_parse_params() and
// #GUriParamsIter.
type UriParamsFlags C.gint

const (
	// URIParamsNone wraps G_URI_PARAMS_NONE
	//
	// No flags set.
	URIParamsNone UriParamsFlags = 0
	// URIParamsCaseInsensitive wraps G_URI_PARAMS_CASE_INSENSITIVE
	//
	// Parameter names are case insensitive.
	URIParamsCaseInsensitive UriParamsFlags = 1
	// URIParamsWwwForm wraps G_URI_PARAMS_WWW_FORM
	//
	// Replace `+` with space character. Only useful for
	//     URLs on the web, using the `https` or `http` schemas.
	URIParamsWwwForm UriParamsFlags = 2
	// URIParamsParseRelaxed wraps G_URI_PARAMS_PARSE_RELAXED
	//
	// See %G_URI_FLAGS_PARSE_RELAXED.
	URIParamsParseRelaxed UriParamsFlags = 4
)

// Has returns true if u contains other
func (u UriParamsFlags) Has(other UriParamsFlags) bool {
	return (u & other) == other
}

func (f UriParamsFlags) String() string {
	if f == 0 {
		return "UriParamsFlags(0)"
	}

	var parts []string
	if (f & URIParamsNone) != 0 {
		parts = append(parts, "URIParamsNone")
	}
	if (f & URIParamsCaseInsensitive) != 0 {
		parts = append(parts, "URIParamsCaseInsensitive")
	}
	if (f & URIParamsWwwForm) != 0 {
		parts = append(parts, "URIParamsWwwForm")
	}
	if (f & URIParamsParseRelaxed) != 0 {
		parts = append(parts, "URIParamsParseRelaxed")
	}
	return "UriParamsFlags(" + strings.Join(parts, "|") + ")"
}

// LogFunc wraps GLogFunc
// 
// The function takes the following parameters:
// 
// 	- logDomain string (nullable): the log domain of the message 
// 	- logLevel LogLevelFlags: the log level of the message (including the
//   fatal and recursion flags) 
// 	- message string: the message to process 
//
// Specifies the prototype of log handler functions.
// 
// The default log handler, [func@GLib.log_default_handler], automatically appends a
// new-line character to @message when printing it. It is advised that any
// custom log handler functions behave similarly, so that logging calls in user
// code do not need modifying to add a new-line character to the message if the
// log handler is changed.
// 
// The `log_domain` parameter can be set to `NULL` or an empty string to use the default
// application domain.
// 
// This is not used if structured logging is enabled; see
// [Using Structured Logging](logging.html#using-structured-logging).
type LogFunc func(logDomain string, logLevel LogLevelFlags, message string)

// LogWriterFunc wraps GLogWriterFunc
// 
// The function takes the following parameters:
// 
// 	- logLevel LogLevelFlags: log level of the message 
// 	- fields []LogField: fields forming the message 
// 
// The function returns the following values:
// 
// 	- goret LogWriterOutput 
//
// Writer function for log entries. A log entry is a collection of one or more
// #GLogFields, using the standard [field names from journal
// specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
// See g_log_structured() for more information.
// 
// Writer functions must ignore fields which they do not recognise, unless they
// can write arbitrary binary output, as field values may be arbitrary binary.
// 
// @log_level is guaranteed to be included in @fields as the `PRIORITY` field,
// but is provided separately for convenience of deciding whether or where to
// output the log entry.
// 
// Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log
// message successfully or if they deliberately ignored it. If there was an
// error handling the message (for example, if the writer function is meant to
// send messages to a remote logging server and there is a network error), it
// should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be
// chained and fall back to simpler handlers in case of failure.
type LogWriterFunc func(logLevel LogLevelFlags, fields []LogField) (goret LogWriterOutput)

// SourceFunc wraps GSourceFunc
// 
// The function takes the following parameters:
// 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Specifies the type of function passed to [func@GLib.timeout_add],
// [func@GLib.timeout_add_full], [func@GLib.idle_add], and
// [func@GLib.idle_add_full].
// 
// When calling [method@GLib.Source.set_callback], you may need to cast a
// function of a different type to this type. Use [func@GLib.SOURCE_FUNC] to
// avoid warnings about incompatible function types.
type SourceFunc func() (goret bool)

// SourceOnceFunc wraps GSourceOnceFunc
// 
// The function takes the following parameters:
// 
//
// A source function that is only called once before being removed from the main
// context automatically.
// 
// See: [func@GLib.idle_add_once], [func@GLib.timeout_add_once]
type SourceOnceFunc func()

// TestDataFunc wraps GTestDataFunc
// 
// The function takes the following parameters:
// 
//
// The type used for test case functions that take an extra pointer
// argument.
type TestDataFunc func()

// TestLogFatalFunc wraps GTestLogFatalFunc
// 
// The function takes the following parameters:
// 
// 	- logDomain string: the log domain of the message 
// 	- logLevel LogLevelFlags: the log level of the message (including the fatal and recursion flags) 
// 	- message string: the message to process 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Specifies the prototype of fatal log handler functions.
type TestLogFatalFunc func(logDomain string, logLevel LogLevelFlags, message string) (goret bool)

// ChildWatchFunc wraps GChildWatchFunc
// 
// The function takes the following parameters:
// 
// 	- pid Pid: the process id of the child process 
// 	- waitStatus int32: Status information about the child process, encoded
//               in a platform-specific manner 
//
// Prototype of a #GChildWatchSource callback, called when a child
// process has exited.
// 
// To interpret @wait_status, see the documentation for
// [func@GLib.spawn_check_wait_status]. In particular,
// on Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
type ChildWatchFunc func(pid Pid, waitStatus int32)

// ASCIIDigitValue wraps g_ascii_digit_value
// 
// The function takes the following parameters:
// 
// 	- c byte: an ASCII character 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the numeric value of a character as a decimal digit. If the
// character is not a decimal digit according to [func@GLib.ascii_isdigit],
// `-1` is returned.
// 
// Differs from [func@GLib.unichar_digit_value] because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIDigitValue(c byte) int32 {
	var carg1 C.gchar // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_digit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIDtostr wraps g_ascii_dtostr
// 
// The function takes the following parameters:
// 
// 	- buffer string: a buffer to place the resulting string in 
// 	- bufLen int32: the length of the buffer 
// 	- d float64: the value to convert 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a `gdouble` to a string, using the '.' as
// decimal point.
// 
// This function generates enough precision that converting
// the string back using [func@GLib.ascii_strtod] gives the same machine-number
// (on machines with IEEE compatible 64bit doubles). It is
// guaranteed that the size of the resulting string will never
// be larger than [const@GLib.ASCII_DTOSTR_BUF_SIZE] bytes, including the terminating
// nul character, which is always added.
func ASCIIDtostr(buffer string, bufLen int32, d float64) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gint    // in, none, casted
	var carg3 C.gdouble // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(bufLen)
	carg3 = C.gdouble(d)

	cret = C.g_ascii_dtostr(carg1, carg2, carg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(bufLen)
	runtime.KeepAlive(d)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIFormatd wraps g_ascii_formatd
// 
// The function takes the following parameters:
// 
// 	- buffer string: a buffer to place the resulting string in 
// 	- bufLen int32: the length of the buffer 
// 	- format string: the `printf()`-style format to use for the
//   code to use for converting 
// 	- d float64: the value to convert 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a `gdouble` to a string, using the '.' as
// decimal point. To format the number you pass in
// a `printf()`-style format string. Allowed conversion
// specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.
// 
// The @format must just be a single format specifier
// starting with `%`, expecting a `gdouble` argument.
// 
// The returned buffer is guaranteed to be nul-terminated.
// 
// If you just want to want to serialize the value into a
// string, use [func@GLib.ascii_dtostr].
func ASCIIFormatd(buffer string, bufLen int32, format string, d float64) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gint    // in, none, casted
	var carg3 *C.gchar  // in, none, string
	var carg4 C.gdouble // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(bufLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(format)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gdouble(d)

	cret = C.g_ascii_formatd(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(bufLen)
	runtime.KeepAlive(format)
	runtime.KeepAlive(d)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIStrcasecmp wraps g_ascii_strcasecmp
// 
// The function takes the following parameters:
// 
// 	- s1 string: string to compare with @s2 
// 	- s2 string: string to compare with @s1 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compare two strings, ignoring the case of ASCII characters.
// 
// Unlike the BSD `strcasecmp()` function, this only recognizes standard
// ASCII letters and ignores the locale, treating all non-ASCII
// bytes as if they are not letters.
// 
// This function should be used only on strings that are known to be
// in encodings where the bytes corresponding to ASCII letters always
// represent themselves. This includes UTF-8 and the ISO-8859-*
// charsets, but not for instance double-byte encodings like the
// Windows Codepage 932, where the trailing bytes of double-byte
// characters include all ASCII letters. If you compare two CP932
// strings using this function, you will get false matches.
// 
// Both @s1 and @s2 must be non-`NULL`.
func ASCIIStrcasecmp(s1 string, s2 string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(s2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_ascii_strcasecmp(carg1, carg2)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIStrdown wraps g_ascii_strdown
// 
// The function takes the following parameters:
// 
// 	- str string: a string 
// 	- len int: length of @str in bytes, or `-1` if @str is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts all upper case ASCII letters to lower case ASCII letters, with
// semantics that exactly match [func@GLib.ascii_tolower].
func ASCIIStrdown(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ascii_strdown(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIStringToSigned wraps g_ascii_string_to_signed
// 
// The function takes the following parameters:
// 
// 	- str string: a string to convert 
// 	- base uint: base of a parsed number 
// 	- min int64: a lower bound (inclusive) 
// 	- max int64: an upper bound (inclusive) 
// 
// The function returns the following values:
// 
// 	- outNum int64: a return location for a number 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// A convenience function for converting a string to a signed number.
// 
// This function assumes that @str contains only a number of the given
// @base that is within inclusive bounds limited by @min and @max. If
// this is true, then the converted number is stored in @out_num. An
// empty string is not a valid input. A string with leading or
// trailing whitespace is also an invalid input.
// 
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must
// not be prefixed with "0x" or "0X". Such a problem does not exist
// for octal numbers, since they were usually prefixed with a zero
// which does not change the value of the parsed number.
// 
// Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`
// domain. If the input is invalid, the error code will be
// [error@GLib.NumberParserError.INVALID]. If the parsed number is out of
// bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].
// 
// See [func@GLib.ascii_strtoll] if you have more complex needs such as
// parsing a string which starts with a number, but then has other
// characters.
func ASCIIStringToSigned(str string, base uint, min int64, max int64) (int64, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.guint    // in, none, casted
	var carg3 C.gint64   // in, none, casted
	var carg4 C.gint64   // in, none, casted
	var carg5 C.gint64   // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(base)
	carg3 = C.gint64(min)
	carg4 = C.gint64(max)

	cret = C.g_ascii_string_to_signed(carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(base)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)

	var outNum int64
	var goret  bool
	var _goerr error

	outNum = int64(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outNum, goret, _goerr
}

// ASCIIStringToUnsigned wraps g_ascii_string_to_unsigned
// 
// The function takes the following parameters:
// 
// 	- str string: a string 
// 	- base uint: base of a parsed number 
// 	- min uint64: a lower bound (inclusive) 
// 	- max uint64: an upper bound (inclusive) 
// 
// The function returns the following values:
// 
// 	- outNum uint64: a return location for a number 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// A convenience function for converting a string to an unsigned number.
// 
// This function assumes that @str contains only a number of the given
// @base that is within inclusive bounds limited by @min and @max. If
// this is true, then the converted number is stored in @out_num. An
// empty string is not a valid input. A string with leading or
// trailing whitespace is also an invalid input. A string with a leading sign
// (`-` or `+`) is not a valid input for the unsigned parser.
// 
// @base can be between 2 and 36 inclusive. Hexadecimal numbers must
// not be prefixed with "0x" or "0X". Such a problem does not exist
// for octal numbers, since they were usually prefixed with a zero
// which does not change the value of the parsed number.
// 
// Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`
// domain. If the input is invalid, the error code will be
// [error@GLib.NumberParserError.INVALID]. If the parsed number is out of
// bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].
// 
// See [func@GLib.ascii_strtoull] if you have more complex needs such as
// parsing a string which starts with a number, but then has other
// characters.
func ASCIIStringToUnsigned(str string, base uint, min uint64, max uint64) (uint64, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.guint    // in, none, casted
	var carg3 C.guint64  // in, none, casted
	var carg4 C.guint64  // in, none, casted
	var carg5 C.guint64  // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(base)
	carg3 = C.guint64(min)
	carg4 = C.guint64(max)

	cret = C.g_ascii_string_to_unsigned(carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(base)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)

	var outNum uint64
	var goret  bool
	var _goerr error

	outNum = uint64(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outNum, goret, _goerr
}

// ASCIIStrncasecmp wraps g_ascii_strncasecmp
// 
// The function takes the following parameters:
// 
// 	- s1 string: string to compare with @s2 
// 	- s2 string: string to compare with @s1 
// 	- n uint: number of characters to compare 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compare @s1 and @s2, ignoring the case of ASCII characters and any
// characters after the first @n in each string. If either string is
// less than @n bytes long, comparison will stop at the first nul byte
// encountered.
// 
// Unlike the BSD `strncasecmp()` function, this only recognizes standard
// ASCII letters and ignores the locale, treating all non-ASCII
// characters as if they are not letters.
// 
// The same warning as in [func@GLib.ascii_strcasecmp] applies: Use this
// function only on strings known to be in encodings where bytes
// corresponding to ASCII letters always represent themselves.
func ASCIIStrncasecmp(s1 string, s2 string, n uint) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(s2)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(n)

	cret = C.g_ascii_strncasecmp(carg1, carg2, carg3)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)
	runtime.KeepAlive(n)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIStrtod wraps g_ascii_strtod
// 
// The function takes the following parameters:
// 
// 	- nptr string: the string to convert to a numeric value 
// 
// The function returns the following values:
// 
// 	- endptr string: if non-`NULL`, it returns the
//   character after the last character used in the conversion 
// 	- goret float64 
//
// Converts a string to a floating point value.
// 
// This function behaves like the standard `strtod()` function
// does in the C locale. It does this without actually changing
// the current locale, since that would not be thread-safe.
// A limitation of the implementation is that this function
// will still accept localized versions of infinities and NANs.
// 
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system `strtod()` function.
// 
// To convert from a gdouble to a string in a locale-insensitive
// way, use [func@GLib.ascii_dtostr].
// 
// If the correct value would cause overflow, plus or minus `HUGE_VAL`
// is returned (according to the sign of the value), and `ERANGE` is
// stored in `errno`. If the correct value would cause underflow,
// zero is returned and `ERANGE` is stored in `errno`.
// 
// This function resets `errno` before calling `strtod()` so that
// you can reliably detect overflow and underflow.
func ASCIIStrtod(nptr string) (string, float64) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, none, string
	var cret  C.gdouble // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ascii_strtod(carg1, &carg2)
	runtime.KeepAlive(nptr)

	var endptr string
	var goret  float64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = float64(cret)

	return endptr, goret
}

// ASCIIStrtoll wraps g_ascii_strtoll
// 
// The function takes the following parameters:
// 
// 	- nptr string: the string to convert to a numeric value 
// 	- base uint: to be used for the conversion, 2..36 or 0 
// 
// The function returns the following values:
// 
// 	- endptr string: if non-`NULL`, it returns the
//   character after the last character used in the conversion 
// 	- goret int64 
//
// Converts a string to a `gint64` value.
// 
// This function behaves like the standard `strtoll()` function
// does in the C locale. It does this without actually
// changing the current locale, since that would not be
// thread-safe.
// 
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system `strtoll()` function.
// 
// If the correct value would cause overflow, [const@GLib.MAXINT64] or
// [const@GLib.MININT64] is returned, and `ERANGE` is stored in `errno`.
// If the base is outside the valid range, zero is returned, and
// `EINVAL` is stored in `errno`. If the
// string conversion fails, zero is returned, and @endptr returns @nptr
// (if @endptr is non-`NULL`).
func ASCIIStrtoll(nptr string, base uint) (string, int64) {
	var carg1 *C.gchar // in, none, string
	var carg3 C.guint  // in, none, casted
	var carg2 *C.gchar // out, none, string
	var cret  C.gint64 // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.guint(base)

	cret = C.g_ascii_strtoll(carg1, &carg2, carg3)
	runtime.KeepAlive(nptr)
	runtime.KeepAlive(base)

	var endptr string
	var goret  int64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = int64(cret)

	return endptr, goret
}

// ASCIIStrtoull wraps g_ascii_strtoull
// 
// The function takes the following parameters:
// 
// 	- nptr string: the string to convert to a numeric value 
// 	- base uint: to be used for the conversion, 2..36 or 0 
// 
// The function returns the following values:
// 
// 	- endptr string: if non-`NULL`, it returns the
//   character after the last character used in the conversion 
// 	- goret uint64 
//
// Converts a string to a `guint64` value.
// 
// This function behaves like the standard `strtoull()` function
// does in the C locale. It does this without actually
// changing the current locale, since that would not be
// thread-safe.
// 
// Note that input with a leading minus sign (`-`) is accepted, and will return
// the negation of the parsed number, unless that would overflow a `guint64`.
// Critically, this means you cannot assume that a short fixed length input will
// result in a low return value, as the input could have a leading `-`.
// 
// This function is typically used when reading configuration
// files or other non-user input that should be locale independent.
// To handle input from the user you should normally use the
// locale-sensitive system `strtoull()` function.
// 
// If the correct value would cause overflow, [const@GLib.MAXUINT64]
// is returned, and `ERANGE` is stored in `errno`.
// If the base is outside the valid range, zero is returned, and
// `EINVAL` is stored in `errno`.
// If the string conversion fails, zero is returned, and @endptr returns
// @nptr (if @endptr is non-`NULL`).
func ASCIIStrtoull(nptr string, base uint) (string, uint64) {
	var carg1 *C.gchar  // in, none, string
	var carg3 C.guint   // in, none, casted
	var carg2 *C.gchar  // out, none, string
	var cret  C.guint64 // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.guint(base)

	cret = C.g_ascii_strtoull(carg1, &carg2, carg3)
	runtime.KeepAlive(nptr)
	runtime.KeepAlive(base)

	var endptr string
	var goret  uint64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = uint64(cret)

	return endptr, goret
}

// ASCIIStrup wraps g_ascii_strup
// 
// The function takes the following parameters:
// 
// 	- str string: a string 
// 	- len int: length of @str in bytes, or `-1` if @str is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts all lower case ASCII letters to upper case ASCII letters, with
// semantics that exactly match [func@GLib.ascii_toupper].
func ASCIIStrup(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ascii_strup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIITolower wraps g_ascii_tolower
// 
// The function takes the following parameters:
// 
// 	- c byte: any character 
// 
// The function returns the following values:
// 
// 	- goret byte 
//
// Convert a character to ASCII lower case. If the character is not an
// ASCII upper case letter, it is returned unchanged.
// 
// Unlike the standard C library `tolower()` function, this only
// recognizes standard ASCII letters and ignores the locale, returning
// all non-ASCII characters unchanged, even if they are lower case
// letters in a particular character set. Also unlike the standard
// library function, this takes and returns a char, not an int, so
// don't call it on `EOF` but no need to worry about casting to `guchar`
// before passing a possibly non-ASCII character in.
func ASCIITolower(c byte) byte {
	var carg1 C.gchar // in, none, casted
	var cret  C.gchar // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_tolower(carg1)
	runtime.KeepAlive(c)

	var goret byte

	goret = byte(cret)

	return goret
}

// ASCIIToupper wraps g_ascii_toupper
// 
// The function takes the following parameters:
// 
// 	- c byte: any character 
// 
// The function returns the following values:
// 
// 	- goret byte 
//
// Convert a character to ASCII upper case. If the character is not an
// ASCII lower case letter, it is returned unchanged.
// 
// Unlike the standard C library `toupper()` function, this only
// recognizes standard ASCII letters and ignores the locale, returning
// all non-ASCII characters unchanged, even if they are upper case
// letters in a particular character set. Also unlike the standard
// library function, this takes and returns a char, not an int, so
// don't call it on `EOF` but no need to worry about casting to `guchar`
// before passing a possibly non-ASCII character in.
func ASCIIToupper(c byte) byte {
	var carg1 C.gchar // in, none, casted
	var cret  C.gchar // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_toupper(carg1)
	runtime.KeepAlive(c)

	var goret byte

	goret = byte(cret)

	return goret
}

// ASCIIXdigitValue wraps g_ascii_xdigit_value
// 
// The function takes the following parameters:
// 
// 	- c byte: an ASCII character 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the numeric value of a character as a hexadecimal digit. If the
// character is not a hex digit according to [func@GLib.ascii_isxdigit],
// `-1` is returned.
// 
// Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so
// there's no worry about sign extension if characters are signed.
// 
// Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so
// there's no worry about sign extension if characters are signed.
func ASCIIXdigitValue(c byte) int32 {
	var carg1 C.gchar // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_xdigit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// AssertWarning wraps g_assert_warning
// 
// The function takes the following parameters:
// 
// 	- logDomain string 
// 	- file string 
// 	- line int32 
// 	- prettyFunction string 
// 	- expression string 
func AssertWarning(logDomain string, file string, line int32, prettyFunction string, expression string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(prettyFunction)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expression)))
	defer C.free(unsafe.Pointer(carg5))

	C.g_assert_warning(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(prettyFunction)
	runtime.KeepAlive(expression)
}

// AssertionMessage wraps g_assertion_message
// 
// The function takes the following parameters:
// 
// 	- domain string 
// 	- file string 
// 	- line int32 
// 	- fn string 
// 	- message string 
func AssertionMessage(domain string, file string, line int32, fn string, message string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg5))

	C.g_assertion_message(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(message)
}

// AssertionMessageCmpint wraps g_assertion_message_cmpint
// 
// The function takes the following parameters:
// 
// 	- domain string 
// 	- file string 
// 	- line int32 
// 	- fn string 
// 	- expr string 
// 	- arg1 uint64 
// 	- cmp string 
// 	- arg2 uint64 
// 	- numtype byte 
func AssertionMessageCmpint(domain string, file string, line int32, fn string, expr string, arg1 uint64, cmp string, arg2 uint64, numtype byte) {
	var carg1 *C.char   // in, none, string
	var carg2 *C.char   // in, none, string
	var carg3 C.int     // in, none, casted
	var carg4 *C.char   // in, none, string
	var carg5 *C.char   // in, none, string
	var carg6 C.guint64 // in, none, casted
	var carg7 *C.char   // in, none, string
	var carg8 C.guint64 // in, none, casted
	var carg9 C.char    // in, none, casted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expr)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = C.guint64(arg1)
	carg7 = (*C.char)(unsafe.Pointer(C.CString(cmp)))
	defer C.free(unsafe.Pointer(carg7))
	carg8 = C.guint64(arg2)
	carg9 = C.char(numtype)

	C.g_assertion_message_cmpint(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(arg1)
	runtime.KeepAlive(cmp)
	runtime.KeepAlive(arg2)
	runtime.KeepAlive(numtype)
}

// AssertionMessageCmpstr wraps g_assertion_message_cmpstr
// 
// The function takes the following parameters:
// 
// 	- domain string 
// 	- file string 
// 	- line int32 
// 	- fn string 
// 	- expr string 
// 	- arg1 string 
// 	- cmp string 
// 	- arg2 string 
func AssertionMessageCmpstr(domain string, file string, line int32, fn string, expr string, arg1 string, cmp string, arg2 string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string
	var carg6 *C.char // in, none, string
	var carg7 *C.char // in, none, string
	var carg8 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expr)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = (*C.char)(unsafe.Pointer(C.CString(arg1)))
	defer C.free(unsafe.Pointer(carg6))
	carg7 = (*C.char)(unsafe.Pointer(C.CString(cmp)))
	defer C.free(unsafe.Pointer(carg7))
	carg8 = (*C.char)(unsafe.Pointer(C.CString(arg2)))
	defer C.free(unsafe.Pointer(carg8))

	C.g_assertion_message_cmpstr(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(arg1)
	runtime.KeepAlive(cmp)
	runtime.KeepAlive(arg2)
}

// Base64Decode wraps g_base64_decode
// 
// The function takes the following parameters:
// 
// 	- text string: zero-terminated string with base64 text to decode 
// 
// The function returns the following values:
// 
// 	- outLen uint: The length of the decoded data is written here 
// 	- goret []uint8 
//
// Decode a sequence of Base-64 encoded text into binary data.  Note
// that the returned binary data is not necessarily zero-terminated,
// so it should not be used as a character string.
func Base64Decode(text string) (uint, []uint8) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gsize   // out, full, casted
	var cret  *C.guchar // return, transfer: full, C Pointers: 1, Name: array[guint8], scope: , array (inner guint8 (*typesystem.CastablePrimitive))

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_base64_decode(carg1, &carg2)
	runtime.KeepAlive(text)

	var outLen uint
	var goret  []uint8

	outLen = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint8 (guchar*) because of unknown reason")

	return outLen, goret
}

// Base64Encode wraps g_base64_encode
// 
// The function takes the following parameters:
// 
// 	- data []uint8 (nullable): the binary data to encode 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Encode a sequence of binary data into its Base-64 stringified
// representation.
func Base64Encode(data []uint8) string {
	var carg1 *C.guchar // in, transfer: none, C Pointers: 1, Name: array[guint8], nullable, array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize   // implicit
	var cret  *C.gchar  // return, full, string

	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_base64_encode(carg1, carg2)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// BitNthLsf wraps g_bit_nth_lsf
// 
// The function takes the following parameters:
// 
// 	- mask uint32: a #gulong containing flags 
// 	- nthBit int32: the index of the bit to start the search from 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Find the position of the first bit set in @mask, searching
// from (but not including) @nth_bit upwards. Bits are numbered
// from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
// usually). To start searching from the 0th bit, set @nth_bit to -1.
func BitNthLsf(mask uint32, nthBit int32) int32 {
	var carg1 C.gulong // in, none, casted
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = C.gulong(mask)
	carg2 = C.gint(nthBit)

	cret = C.g_bit_nth_lsf(carg1, carg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var goret int32

	goret = int32(cret)

	return goret
}

// BitNthMsf wraps g_bit_nth_msf
// 
// The function takes the following parameters:
// 
// 	- mask uint32: a #gulong containing flags 
// 	- nthBit int32: the index of the bit to start the search from 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Find the position of the first bit set in @mask, searching
// from (but not including) @nth_bit downwards. Bits are numbered
// from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
// usually). To start searching from the last bit, set @nth_bit to
// -1 or GLIB_SIZEOF_LONG * 8.
func BitNthMsf(mask uint32, nthBit int32) int32 {
	var carg1 C.gulong // in, none, casted
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = C.gulong(mask)
	carg2 = C.gint(nthBit)

	cret = C.g_bit_nth_msf(carg1, carg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var goret int32

	goret = int32(cret)

	return goret
}

// BitStorage wraps g_bit_storage
// 
// The function takes the following parameters:
// 
// 	- number uint32: a #guint 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the number of bits used to hold @number,
// e.g. if @number is 4, 3 bits are needed.
func BitStorage(number uint32) uint {
	var carg1 C.gulong // in, none, casted
	var cret  C.guint  // return, none, casted

	carg1 = C.gulong(number)

	cret = C.g_bit_storage(carg1)
	runtime.KeepAlive(number)

	var goret uint

	goret = uint(cret)

	return goret
}

// BuildFilenamev wraps g_build_filenamev
// 
// The function takes the following parameters:
// 
// 	- args []string: %NULL-terminated
//   array of strings containing the path elements. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a filename from a vector of elements using the correct
// separator for the current platform.
// 
// This function behaves exactly like g_build_filename(), but takes the path
// elements as a string array, instead of varargs. This function is mainly
// meant for language bindings.
// 
// If you are building a path programmatically you may want to use
// #GPathBuf instead.
func BuildFilenamev(args []string) string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	_ = args
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_build_filenamev(carg1)
	runtime.KeepAlive(args)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// BuildPathv wraps g_build_pathv
// 
// The function takes the following parameters:
// 
// 	- separator string: a string used to separator the elements of the path. 
// 	- args []string: %NULL-terminated
//   array of strings containing the path elements. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Behaves exactly like g_build_path(), but takes the path elements
// as a string array, instead of variadic arguments.
// 
// This function is mainly meant for language bindings.
func BuildPathv(separator string, args []string) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(separator)))
	defer C.free(unsafe.Pointer(carg1))
	_ = args
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_build_pathv(carg1, carg2)
	runtime.KeepAlive(separator)
	runtime.KeepAlive(args)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// CanonicalizeFilename wraps g_canonicalize_filename
// 
// The function takes the following parameters:
// 
// 	- filename string: the name of the file 
// 	- relativeTo string (nullable): the relative directory, or %NULL
// to use the current working directory 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the canonical file name from @filename. All triple slashes are turned into
// single slashes, and all `..` and `.`s resolved against @relative_to.
// 
// Symlinks are not followed, and the returned path is guaranteed to be absolute.
// 
// If @filename is an absolute path, @relative_to is ignored. Otherwise,
// @relative_to will be prepended to @filename to make it absolute. @relative_to
// must be an absolute path, or %NULL. If @relative_to is %NULL, it'll fallback
// to g_get_current_dir().
// 
// This function never fails, and will canonicalize file paths even if they don't
// exist.
// 
// No file system I/O is done.
func CanonicalizeFilename(filename string, relativeTo string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if relativeTo != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(relativeTo)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_canonicalize_filename(carg1, carg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(relativeTo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// CheckVersion wraps glib_check_version
// 
// The function takes the following parameters:
// 
// 	- requiredMajor uint: the required major version 
// 	- requiredMinor uint: the required minor version 
// 	- requiredMicro uint: the required micro version 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Checks that the GLib library in use is compatible with the
// given version.
// 
// Generally you would pass in the constants %GLIB_MAJOR_VERSION,
// %GLIB_MINOR_VERSION, %GLIB_MICRO_VERSION as the three arguments
// to this function; that produces a check that the library in use
// is compatible with the version of GLib the application or module
// was compiled against.
// 
// Compatibility is defined by two things: first the version
// of the running library is newer than the version
// `@required_major.required_minor.@required_micro`. Second
// the running library must be binary compatible with the
// version `@required_major.@required_minor.@required_micro`
// (same major version.)
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var carg1 C.guint  // in, none, casted
	var carg2 C.guint  // in, none, casted
	var carg3 C.guint  // in, none, casted
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.guint(requiredMajor)
	carg2 = C.guint(requiredMinor)
	carg3 = C.guint(requiredMicro)

	cret = C.glib_check_version(carg1, carg2, carg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ChildWatchAddFull wraps g_child_watch_add_full
// 
// The function takes the following parameters:
// 
// 	- priority int32: the priority of the idle source. Typically this will be in the
//   range between [const@GLib.PRIORITY_DEFAULT_IDLE] and
//   [const@GLib.PRIORITY_HIGH_IDLE]. 
// 	- pid Pid: process to watch. On POSIX the positive pid of a child process. On
// Windows a handle for a process (which doesn't have to be a child). 
// 	- function ChildWatchFunc: function to call 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Sets a function to be called when the child indicated by @pid
// exits, at the priority @priority.
// 
// If you obtain @pid from [func@GLib.spawn_async] or
// [func@GLib.spawn_async_with_pipes] you will need to pass
// %G_SPAWN_DO_NOT_REAP_CHILD as flag to the spawn function for the child
// watching to work.
// 
// In many programs, you will want to call [func@GLib.spawn_check_wait_status]
// in the callback to determine whether or not the child exited
// successfully.
// 
// Also, note that on platforms where #GPid must be explicitly closed
// (see [func@GLib.spawn_close_pid]) @pid must not be closed while the source
// is still active.  Typically, you should invoke [func@GLib.spawn_close_pid]
// in the callback function for the source.
// 
// GLib supports only a single callback per process id.
// On POSIX platforms, the same restrictions mentioned for
// [func@GLib.child_watch_source_new] apply to this function.
// 
// This internally creates a main loop source using
// [func@GLib.child_watch_source_new] and attaches it to the main loop context
// using [method@GLib.Source.attach]. You can do these steps manually if you
// need greater control.
func ChildWatchAddFull(priority int32, pid Pid, function ChildWatchFunc) uint {
	var carg1 C.gint            // in, none, casted
	var carg2 C.GPid            // in, none, casted, alias
	var carg3 C.GChildWatchFunc // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer        // implicit
	var carg5 C.GDestroyNotify  // implicit
	var cret  C.guint           // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.GPid(pid)
	carg3 = (*[0]byte)(C._goglib_glib2_ChildWatchFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_child_watch_add_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(pid)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// ClearError wraps g_clear_error
// 
// The function returns the following values:
// 
// 	- _goerr error (nullable): an error 
//
// If @err or `*err` is %NULL, does nothing. Otherwise,
// calls g_error_free() on `*err` and sets `*err` to %NULL.
func ClearError() error {
	var _cerr *C.GError // out, full, converted, nullable

	C.g_clear_error(&_cerr)

	var _goerr error

	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ComputeChecksumForBytes wraps g_compute_checksum_for_bytes
// 
// The function takes the following parameters:
// 
// 	- checksumType ChecksumType: a #GChecksumType 
// 	- data *Bytes: binary blob to compute the digest of 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Computes the checksum for a binary @data. This is a
// convenience wrapper for g_checksum_new(), g_checksum_get_string()
// and g_checksum_free().
// 
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForBytes(checksumType ChecksumType, data *Bytes) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.GBytes       // in, none, converted
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	carg2 = (*C.GBytes)(UnsafeBytesToGlibNone(data))

	cret = C.g_compute_checksum_for_bytes(carg1, carg2)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeChecksumForData wraps g_compute_checksum_for_data
// 
// The function takes the following parameters:
// 
// 	- checksumType ChecksumType: a #GChecksumType 
// 	- data []uint8: binary blob to compute the digest of 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Computes the checksum for a binary @data of @length. This is a
// convenience wrapper for g_checksum_new(), g_checksum_get_string()
// and g_checksum_free().
// 
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForData(checksumType ChecksumType, data []uint8) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	_ = data
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_compute_checksum_for_data(carg1, carg2, carg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeChecksumForString wraps g_compute_checksum_for_string
// 
// The function takes the following parameters:
// 
// 	- checksumType ChecksumType: a #GChecksumType 
// 	- str string: the string to compute the checksum of 
// 	- length int: the length of the string, or -1 if the string is null-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Computes the checksum of a string.
// 
// The hexadecimal string returned will be in lower case.
func ComputeChecksumForString(checksumType ChecksumType, str string, length int) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.gchar        // in, none, string
	var carg3 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gssize(length)

	cret = C.g_compute_checksum_for_string(carg1, carg2, carg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeHmacForBytes wraps g_compute_hmac_for_bytes
// 
// The function takes the following parameters:
// 
// 	- digestType ChecksumType: a #GChecksumType to use for the HMAC 
// 	- key *Bytes: the key to use in the HMAC 
// 	- data *Bytes: binary blob to compute the HMAC of 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Computes the HMAC for a binary @data. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string()
// and g_hmac_unref().
// 
// The hexadecimal string returned will be in lower case.
func ComputeHmacForBytes(digestType ChecksumType, key *Bytes, data *Bytes) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.GBytes       // in, none, converted
	var carg3 *C.GBytes       // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	carg2 = (*C.GBytes)(UnsafeBytesToGlibNone(key))
	carg3 = (*C.GBytes)(UnsafeBytesToGlibNone(data))

	cret = C.g_compute_hmac_for_bytes(carg1, carg2, carg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ComputeHmacForData wraps g_compute_hmac_for_data
// 
// The function takes the following parameters:
// 
// 	- digestType ChecksumType: a #GChecksumType to use for the HMAC 
// 	- key []byte: the key to use in the HMAC 
// 	- data []byte: binary blob to compute the HMAC of 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Computes the HMAC for a binary @data of @length. This is a
// convenience wrapper for g_hmac_new(), g_hmac_get_string()
// and g_hmac_unref().
// 
// The hexadecimal string returned will be in lower case.
func ComputeHmacForData(digestType ChecksumType, key []byte, data []byte) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg5)
	var carg5 C.gsize         // implicit
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")
	_ = data
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_compute_hmac_for_data(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ComputeHmacForString wraps g_compute_hmac_for_string
// 
// The function takes the following parameters:
// 
// 	- digestType ChecksumType: a #GChecksumType to use for the HMAC 
// 	- key []byte: the key to use in the HMAC 
// 	- str string: the string to compute the HMAC for 
// 	- length int: the length of the string, or -1 if the string is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Computes the HMAC for a string.
// 
// The hexadecimal string returned will be in lower case.
func ComputeHmacForString(digestType ChecksumType, key []byte, str string, length int) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.gchar        // in, none, string
	var carg5 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.gssize(length)

	cret = C.g_compute_hmac_for_string(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Convert wraps g_convert
// 
// The function takes the following parameters:
// 
// 	- str string: 
//                 the string to convert. 
// 	- toCodeset string: name of character set into which to convert @str 
// 	- fromCodeset string: character set of @str. 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in
//                 the input string that were successfully converted, or %NULL.
//                 Even if the conversion was successful, this may be
//                 less than @len if there were partial characters
//                 at the end of the input. If the error
//                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
//                 stored will be the byte offset after the last valid
//                 input sequence. 
// 	- bytesWritten uint: the number of bytes stored in
//                 the output buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string from one character set to another.
// 
// Note that you should use g_iconv() for streaming conversions.
// Despite the fact that @bytes_read can return information about partial
// characters, the g_convert_... functions are not generally suitable
// for streaming. If the underlying converter maintains internal state,
// then this won't be preserved across successive calls to g_convert(),
// g_convert_with_iconv() or g_convert_with_fallback(). (An example of
// this is the GNU C converter for CP1255 which does not emit a base
// character until it knows that the next character is not a mark that
// could combine with the base character.)
// 
// Using extensions such as "//TRANSLIT" may not work (or may not work
// well) on many platforms.  Consider using g_str_to_ascii() instead.
func Convert(str string, toCodeset string, fromCodeset string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 *C.gchar  // in, none, string
	var carg4 *C.gchar  // in, none, string
	var carg5 C.gsize   // out, full, casted
	var carg6 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(carg4))

	cret = C.g_convert(carg1, carg2, carg3, carg4, &carg5, &carg6, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg5)
	bytesWritten = uint(carg6)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// ConvertErrorQuark wraps g_convert_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func ConvertErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_convert_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ConvertWithFallback wraps g_convert_with_fallback
// 
// The function takes the following parameters:
// 
// 	- str string: 
//                the string to convert. 
// 	- toCodeset string: name of character set into which to convert @str 
// 	- fromCodeset string: character set of @str. 
// 	- fallback string: UTF-8 string to use in place of characters not
//                present in the target encoding. (The string must be
//                representable in the target encoding).
//                If %NULL, characters not in the target encoding will
//                be represented as Unicode escapes \uxxxx or \Uxxxxyyyy. 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in
//                the input string that were successfully converted, or %NULL.
//                Even if the conversion was successful, this may be
//                less than @len if there were partial characters
//                at the end of the input. 
// 	- bytesWritten uint: the number of bytes stored in
//                 the output buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string from one character set to another, possibly
// including fallback sequences for characters not representable
// in the output. Note that it is not guaranteed that the specification
// for the fallback sequences in @fallback will be honored. Some
// systems may do an approximate conversion from @from_codeset
// to @to_codeset in their iconv() functions,
// in which case GLib will simply return that approximate conversion.
// 
// Note that you should use g_iconv() for streaming conversions.
// Despite the fact that @bytes_read can return information about partial
// characters, the g_convert_... functions are not generally suitable
// for streaming. If the underlying converter maintains internal state,
// then this won't be preserved across successive calls to g_convert(),
// g_convert_with_iconv() or g_convert_with_fallback(). (An example of
// this is the GNU C converter for CP1255 which does not emit a base
// character until it knows that the next character is not a mark that
// could combine with the base character.)
func ConvertWithFallback(str string, toCodeset string, fromCodeset string, fallback string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 *C.gchar  // in, none, string
	var carg4 *C.gchar  // in, none, string
	var carg5 *C.gchar  // in, none, string
	var carg6 C.gsize   // out, full, casted
	var carg7 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.gchar)(unsafe.Pointer(C.CString(fallback)))
	defer C.free(unsafe.Pointer(carg5))

	cret = C.g_convert_with_fallback(carg1, carg2, carg3, carg4, carg5, &carg6, &carg7, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)
	runtime.KeepAlive(fallback)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg6)
	bytesWritten = uint(carg7)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// Dcgettext wraps g_dcgettext
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the translation domain to use, or %NULL to use
//   the domain set with textdomain() 
// 	- msgid string: message to translate 
// 	- category int32: a locale category 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This is a variant of g_dgettext() that allows specifying a locale
// category instead of always using `LC_MESSAGES`. See g_dgettext() for
// more information about how this functions differs from calling
// dcgettext() directly.
func Dcgettext(domain string, msgid string, category int32) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(category)

	cret = C.g_dcgettext(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(category)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dgettext wraps g_dgettext
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the translation domain to use, or %NULL to use
//   the domain set with textdomain() 
// 	- msgid string: message to translate 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This function is a wrapper of dgettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
// 
// The advantage of using this function over dgettext() proper is that
// libraries using this function (like GTK) will not use translations
// if the application using the library does not have translations for
// the current locale.  This results in a consistent English-only
// interface instead of one having partial translations.  For this
// feature to work, the call to textdomain() and setlocale() should
// precede any g_dgettext() invocations.  For GTK, it means calling
// textdomain() before gtk_init or its variants.
// 
// This function disables translations if and only if upon its first
// call all the following conditions hold:
// 
// - @domain is not %NULL
// 
// - textdomain() has been called to set a default text domain
// 
// - there is no translations available for the default text domain
//   and the current locale
// 
// - current locale is not "C" or any English locales (those
//   starting with "en_")
// 
// Note that this behavior may not be desired for example if an application
// has its untranslated messages in a language other than English. In those
// cases the application should call textdomain() after initializing GTK.
// 
// Applications should normally not use this function directly,
// but use the _() macro for translations.
func Dgettext(domain string, msgid string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_dgettext(carg1, carg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dngettext wraps g_dngettext
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the translation domain to use, or %NULL to use
//   the domain set with textdomain() 
// 	- msgid string: message to translate 
// 	- msgidPlural string: plural form of the message 
// 	- n uint32: the quantity for which translation is needed 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This function is a wrapper of dngettext() which does not translate
// the message if the default domain as set with textdomain() has no
// translations for the current locale.
// 
// See g_dgettext() for details of how this differs from dngettext()
// proper.
func Dngettext(domain string, msgid string, msgidPlural string, n uint32) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 *C.gchar // in, none, string
	var carg4 C.gulong // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgidPlural)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gulong(n)

	cret = C.g_dngettext(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgidPlural)
	runtime.KeepAlive(n)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dpgettext wraps g_dpgettext
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the translation domain to use, or %NULL to use
//   the domain set with textdomain() 
// 	- msgctxtid string: a combined message context and message id, separated
//   by a \004 character 
// 	- msgidoffset uint: the offset of the message id in @msgctxid 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This function is a variant of g_dgettext() which supports
// a disambiguating message context. GNU gettext uses the
// '\004' character to separate the message context and
// message id in @msgctxtid.
// If 0 is passed as @msgidoffset, this function will fall back to
// trying to use the deprecated convention of using "|" as a separation
// character.
// 
// This uses g_dgettext() internally. See that functions for differences
// with dgettext() proper.
// 
// Applications should normally not use this function directly,
// but use the C_() macro for translations with context.
func Dpgettext(domain string, msgctxtid string, msgidoffset uint) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgctxtid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(msgidoffset)

	cret = C.g_dpgettext(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgctxtid)
	runtime.KeepAlive(msgidoffset)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dpgettext2 wraps g_dpgettext2
// 
// The function takes the following parameters:
// 
// 	- domain string (nullable): the translation domain to use, or %NULL to use
//   the domain set with textdomain() 
// 	- _context string: the message context 
// 	- msgid string: the message 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// This function is a variant of g_dgettext() which supports
// a disambiguating message context. GNU gettext uses the
// '\004' character to separate the message context and
// message id in @msgctxtid.
// 
// This uses g_dgettext() internally. See that functions for differences
// with dgettext() proper.
// 
// This function differs from C_() in that it is not a macro and
// thus you may use non-string-literals as context and msgid arguments.
func Dpgettext2(domain string, _context string, msgid string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(_context)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_dpgettext2(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(msgid)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// EnvironGetenv wraps g_environ_getenv
// 
// The function takes the following parameters:
// 
// 	- envp []string (nullable): 
//     an environment list (eg, as returned from g_get_environ()), or %NULL
//     for an empty environment list 
// 	- variable string: the environment variable to get 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the value of the environment variable @variable in the
// provided list @envp.
func EnvironGetenv(envp []string, variable string) string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, none, string, nullable

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_environ_getenv(carg1, carg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// EnvironSetenv wraps g_environ_setenv
// 
// The function takes the following parameters:
// 
// 	- envp []string (nullable): 
//     an environment list that can be freed using g_strfreev() (e.g., as
//     returned from g_get_environ()), or %NULL for an empty
//     environment list 
// 	- variable string: the environment variable to set, must not
//     contain '=' 
// 	- value string: the value for to set the variable to 
// 	- overwrite bool: whether to change the variable if it already exists 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Sets the environment variable @variable in the provided list
// @envp to @value.
func EnvironSetenv(envp []string, variable string, value string, overwrite bool) []string {
	var carg1 **C.gchar  // in, transfer: full, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar   // in, none, string
	var carg3 *C.gchar   // in, none, string
	var carg4 C.gboolean // in
	var cret  **C.gchar  // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg3))
	if overwrite {
		carg4 = C.TRUE
	}

	cret = C.g_environ_setenv(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// EnvironUnsetenv wraps g_environ_unsetenv
// 
// The function takes the following parameters:
// 
// 	- envp []string (nullable): 
//     an environment list that can be freed using g_strfreev() (e.g., as
//     returned from g_get_environ()), or %NULL for an empty environment list 
// 	- variable string: the environment variable to remove, must not
//     contain '=' 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Removes the environment variable @variable from the provided
// environment @envp.
func EnvironUnsetenv(envp []string, variable string) []string {
	var carg1 **C.gchar // in, transfer: full, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_environ_unsetenv(carg1, carg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// FileErrorFromErrno wraps g_file_error_from_errno
// 
// The function takes the following parameters:
// 
// 	- errNo int32: an "errno" value 
// 
// The function returns the following values:
// 
// 	- goret FileError 
//
// Gets a #GFileError constant based on the passed-in @err_no.
// 
// For example, if you pass in `EEXIST` this function returns
// %G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
// assume that all #GFileError values will exist.
// 
// Normally a #GFileError value goes into a #GError returned
// from a function that manipulates files. So you would use
// g_file_error_from_errno() when constructing a #GError.
func FileErrorFromErrno(errNo int32) FileError {
	var carg1 C.gint       // in, none, casted
	var cret  C.GFileError // return, none, casted

	carg1 = C.gint(errNo)

	cret = C.g_file_error_from_errno(carg1)
	runtime.KeepAlive(errNo)

	var goret FileError

	goret = FileError(cret)

	return goret
}

// FileErrorQuark wraps g_file_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func FileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// FileGetContents wraps g_file_get_contents
// 
// The function takes the following parameters:
// 
// 	- filename string: name of a file to read contents from, in the GLib file name encoding 
// 
// The function returns the following values:
// 
// 	- contents string: location to store an allocated string, use g_free() to free
//     the returned string 
// 	- length uint: location to store length in bytes of the contents, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Reads an entire file into allocated memory, with good error
// checking.
// 
// If the call was successful, it returns %TRUE and sets @contents to the file
// contents and @length to the length of the file contents in bytes. The string
// stored in @contents will be nul-terminated, so for text files you can pass
// %NULL for the @length argument. If the call was not successful, it returns
// %FALSE and sets @error. The error domain is %G_FILE_ERROR. Possible error
// codes are those in the #GFileError enumeration. In the error case,
// @contents is set to %NULL and @length is set to zero.
func FileGetContents(filename string) (string, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize    // implicit
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_contents(carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(filename)

	var contents string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, goret, _goerr
}

// FileOpenTmp wraps g_file_open_tmp
// 
// The function takes the following parameters:
// 
// 	- tmpl string (nullable): Template for file name, as in
//   g_mkstemp(), basename only, or %NULL for a default template 
// 
// The function returns the following values:
// 
// 	- nameUsed string: location to store actual name used,
//   or %NULL 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Opens a file for writing in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
// 
// @tmpl should be a string in the GLib file name encoding containing
// a sequence of six 'X' characters, as the parameter to g_mkstemp().
// However, unlike these functions, the template should only be a
// basename, no directory components are allowed. If template is
// %NULL, a default template is used.
// 
// Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not
// modified, and might thus be a read-only literal string.
// 
// Upon success, and if @name_used is non-%NULL, the actual name used
// is returned in @name_used. This string should be freed with g_free()
// when not needed any longer. The returned name is in the GLib file
// name encoding.
func FileOpenTmp(tmpl string) (string, int32, error) {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var carg2 *C.gchar  // out, full, string
	var cret  C.gint    // return, none, casted
	var _cerr *C.GError // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_open_tmp(carg1, &carg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var nameUsed string
	var goret    int32
	var _goerr   error

	nameUsed = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = int32(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return nameUsed, goret, _goerr
}

// FileReadLink wraps g_file_read_link
// 
// The function takes the following parameters:
// 
// 	- filename string: the symbolic link 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Reads the contents of the symbolic link @filename like the POSIX
// `readlink()` function.
// 
// The returned string is in the encoding used for filenames. Use
// g_filename_to_utf8() to convert it to UTF-8.
// 
// The returned string may also be a relative path. Use g_build_filename()
// to convert it to an absolute path:
// 
// |[&lt;!-- language="C" --&gt;
// g_autoptr(GError) local_error = NULL;
// g_autofree gchar *link_target = g_file_read_link ("/etc/localtime", &amp;local_error);
// 
// if (local_error != NULL)
//   g_error ("Error reading link: %s", local_error-&gt;message);
// 
// if (!g_path_is_absolute (link_target))
//   {
//     g_autofree gchar *absolute_link_target = g_build_filename ("/etc", link_target, NULL);
//     g_free (link_target);
//     link_target = g_steal_pointer (&amp;absolute_link_target);
//   }
// ]|
func FileReadLink(filename string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_read_link(carg1, &_cerr)
	runtime.KeepAlive(filename)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileSetContents wraps g_file_set_contents
// 
// The function takes the following parameters:
// 
// 	- filename string: name of a file to write @contents to, in the GLib file name
//   encoding 
// 	- contents string: string to write to the file 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Writes all of @contents to a file named @filename. This is a convenience
// wrapper around calling g_file_set_contents_full() with `flags` set to
// `G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING` and
// `mode` set to `0666`.
func FileSetContents(filename string, contents string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gssize   // implicit
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_file_set_contents(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileSetContentsFull wraps g_file_set_contents_full
// 
// The function takes the following parameters:
// 
// 	- filename string: name of a file to write @contents to, in the GLib file name
//   encoding 
// 	- contents string: string to write to the file 
// 	- flags FileSetContentsFlags: flags controlling the safety vs speed of the operation 
// 	- mode int32: file mode, as passed to `open()`; typically this will be `0666` 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Writes all of @contents to a file named @filename, with good error checking.
// If a file called @filename already exists it will be overwritten.
// 
// @flags control the properties of the write operation: whether it&#x2019;s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
// 
// As this function performs file I/O, it is recommended to not call it anywhere
// where blocking would cause problems, such as in the main loop of a graphical
// application. In particular, if @flags has any value other than
// %G_FILE_SET_CONTENTS_NONE then this function may call `fsync()`.
// 
// If %G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the operation is atomic
// in the sense that it is first written to a temporary file which is then
// renamed to the final name.
// 
// Notes:
// 
// - On UNIX, if @filename already exists hard links to @filename will break.
//   Also since the file is recreated, existing permissions, access control
//   lists, metadata etc. may be lost. If @filename is a symbolic link,
//   the link itself will be replaced, not the linked file.
// 
// - On UNIX, if @filename already exists and is non-empty, and if the system
//   supports it (via a journalling filesystem or equivalent), and if
//   %G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the `fsync()` call (or
//   equivalent) will be used to ensure atomic replacement: @filename
//   will contain either its old contents or @contents, even in the face of
//   system power loss, the disk being unsafely removed, etc.
// 
// - On UNIX, if @filename does not already exist or is empty, there is a
//   possibility that system power loss etc. after calling this function will
//   leave @filename empty or full of NUL bytes, depending on the underlying
//   filesystem, unless %G_FILE_SET_CONTENTS_DURABLE and
//   %G_FILE_SET_CONTENTS_CONSISTENT are set in @flags.
// 
// - On Windows renaming a file will not remove an existing file with the
//   new name, so on Windows there is a race condition between the existing
//   file being removed and the temporary file being renamed.
// 
// - On Windows there is no way to remove a file that is open to some
//   process, or mapped into memory. Thus, this function will fail if
//   @filename already exists and is open.
// 
// If the call was successful, it returns %TRUE. If the call was not successful,
// it returns %FALSE and sets @error. The error domain is %G_FILE_ERROR.
// Possible error codes are those in the #GFileError enumeration.
// 
// Note that the name for the temporary file is constructed by appending up
// to 7 characters to @filename.
// 
// If the file didn&#x2019;t exist before and is created, it will be given the
// permissions from @mode. Otherwise, the permissions of the existing file will
// remain unchanged.
func FileSetContentsFull(filename string, contents string, flags FileSetContentsFlags, mode int32) (bool, error) {
	var carg1 *C.gchar                // in, none, string
	var carg2 *C.gchar                // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gssize                // implicit
	var carg4 C.GFileSetContentsFlags // in, none, casted
	var carg5 C.int                   // in, none, casted
	var cret  C.gboolean              // return
	var _cerr *C.GError               // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg4 = C.GFileSetContentsFlags(flags)
	carg5 = C.int(mode)

	cret = C.g_file_set_contents_full(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mode)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TestFile wraps g_file_test
// 
// The function takes the following parameters:
// 
// 	- filename string: a filename to test in the
//     GLib file name encoding 
// 	- test FileTest: bitfield of #GFileTest flags 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns %TRUE if any of the tests in the bitfield @test are
// %TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
// will return %TRUE if the file exists; the check whether it's a
// directory doesn't matter since the existence test is %TRUE. With
// the current set of available tests, there's no point passing in
// more than one test at a time.
// 
// Apart from %G_FILE_TEST_IS_SYMLINK all tests follow symbolic links,
// so for a symbolic link to a regular file g_file_test() will return
// %TRUE for both %G_FILE_TEST_IS_SYMLINK and %G_FILE_TEST_IS_REGULAR.
// 
// Note, that for a dangling symbolic link g_file_test() will return
// %TRUE for %G_FILE_TEST_IS_SYMLINK and %FALSE for all other flags.
// 
// You should never use g_file_test() to test whether it is safe
// to perform an operation, because there is always the possibility
// of the condition changing before you actually perform the operation,
// see [TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).
// 
// For example, you might think you could use %G_FILE_TEST_IS_SYMLINK
// to know whether it is safe to write to a file without being
// tricked into writing into a different location. It doesn't work!
// 
// |[&lt;!-- language="C" --&gt;
//  // DON'T DO THIS
//  if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
//    {
//      fd = g_open (filename, O_WRONLY);
//      // write to fd
//    }
// 
//  // DO THIS INSTEAD
//  fd = g_open (filename, O_WRONLY | O_NOFOLLOW | O_CLOEXEC);
//  if (fd == -1)
//    {
//      // check error
//      if (errno == ELOOP)
//        // file is a symlink and can be ignored
//      else
//        // handle errors as before
//    }
//  else
//    {
//      // write to fd
//    }
// ]|
// 
// Another thing to note is that %G_FILE_TEST_EXISTS and
// %G_FILE_TEST_IS_EXECUTABLE are implemented using the access()
// system call. This usually doesn't matter, but if your program
// is setuid or setgid it means that these tests will give you
// the answer for the real user ID and group ID, rather than the
// effective user ID and group ID.
// 
// On Windows, there are no symlinks, so testing for
// %G_FILE_TEST_IS_SYMLINK will always return %FALSE. Testing for
// %G_FILE_TEST_IS_EXECUTABLE will just check that the file exists and
// its name indicates that it is executable, checking for well-known
// extensions and those listed in the `PATHEXT` environment variable.
func TestFile(filename string, test FileTest) bool {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GFileTest // in, none, casted
	var cret  C.gboolean  // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileTest(test)

	cret = C.g_file_test(carg1, carg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(test)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// FilenameDisplayBasename wraps g_filename_display_basename
// 
// The function takes the following parameters:
// 
// 	- filename string: an absolute pathname in the
//     GLib file name encoding 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns the display basename for the particular filename, guaranteed
// to be valid UTF-8. The display name might not be identical to the filename,
// for instance there might be problems converting it to UTF-8, and some files
// can be translated in the display.
// 
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
// 
// You must pass the whole absolute pathname to this functions so that
// translation of well known locations can be done.
// 
// This function is preferred over g_filename_display_name() if you know the
// whole path, as it allows translation.
func FilenameDisplayBasename(filename string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_display_basename(carg1)
	runtime.KeepAlive(filename)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FilenameDisplayName wraps g_filename_display_name
// 
// The function takes the following parameters:
// 
// 	- filename string: a pathname hopefully in the
//     GLib file name encoding 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a filename into a valid UTF-8 string. The conversion is
// not necessarily reversible, so you should keep the original around
// and use the return value of this function only for display purposes.
// Unlike g_filename_to_utf8(), the result is guaranteed to be non-%NULL
// even if the filename actually isn't in the GLib file name encoding.
// 
// If GLib cannot make sense of the encoding of @filename, as a last resort it
// replaces unknown characters with U+FFFD, the Unicode replacement character.
// You can search the result for the UTF-8 encoding of this character (which is
// "\357\277\275" in octal notation) to find out if @filename was in an invalid
// encoding.
// 
// If you know the whole pathname of the file you should use
// g_filename_display_basename(), since that allows location-based
// translation of filenames.
func FilenameDisplayName(filename string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_display_name(carg1)
	runtime.KeepAlive(filename)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FilenameFromURI wraps g_filename_from_uri
// 
// The function takes the following parameters:
// 
// 	- uri string: a uri describing a filename (escaped, encoded in ASCII). 
// 
// The function returns the following values:
// 
// 	- hostname string (nullable): Location to store hostname for the URI.
//            If there is no hostname in the URI, %NULL will be
//            stored in this location. 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts an escaped ASCII-encoded URI to a local filename in the
// encoding used for filenames.
// 
// Since GLib 2.78, the query string and fragment can be present in the URI,
// but are not part of the resulting filename.
// We take inspiration from https://url.spec.whatwg.org/#file-state,
// but we don't support the entire standard.
func FilenameFromURI(uri string) (string, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, full, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_from_uri(carg1, &carg2, &_cerr)
	runtime.KeepAlive(uri)

	var hostname string
	var goret    string
	var _goerr   error

	if carg2 != nil {
		hostname = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return hostname, goret, _goerr
}

// FilenameFromUTF8 wraps g_filename_from_utf8
// 
// The function takes the following parameters:
// 
// 	- utf8string string: a UTF-8 encoded string. 
// 	- len int: the length of the string, or -1 if the string is
//                 nul-terminated. 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in
//                 the input string that were successfully converted, or %NULL.
//                 Even if the conversion was successful, this may be
//                 less than @len if there were partial characters
//                 at the end of the input. If the error
//                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
//                 stored will be the byte offset after the last valid
//                 input sequence. 
// 	- bytesWritten uint: the number of bytes stored in
//                 the output buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames;
// on other platforms, this function indirectly depends on the
// [current locale](running.html#locale).
// 
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
// not UTF-8 and the conversion output contains a nul character, the error
// %G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.
func FilenameFromUTF8(utf8string string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8string)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_filename_from_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(utf8string)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// FilenameToURI wraps g_filename_to_uri
// 
// The function takes the following parameters:
// 
// 	- filename string: an absolute filename specified in the GLib file
//     name encoding, which is the on-disk file name bytes on Unix, and UTF-8
//     on Windows 
// 	- hostname string (nullable): A UTF-8 encoded hostname, or %NULL for none. 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts an absolute filename to an escaped ASCII-encoded URI, with the path
// component following Section 3.3. of RFC 2396.
func FilenameToURI(filename string, hostname string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if hostname != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_filename_to_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(hostname)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FilenameToUTF8 wraps g_filename_to_utf8
// 
// The function takes the following parameters:
// 
// 	- opsysstring string: a string in the encoding for filenames 
// 	- len int: the length of the string, or -1 if the string is
//                 nul-terminated (Note that some encodings may allow nul
//                 bytes to occur inside strings. In that case, using -1
//                 for the @len parameter is unsafe) 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in the
//                 input string that were successfully converted, or %NULL.
//                 Even if the conversion was successful, this may be
//                 less than @len if there were partial characters
//                 at the end of the input. If the error
//                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
//                 stored will be the byte offset after the last valid
//                 input sequence. 
// 	- bytesWritten uint: the number of bytes stored in the output
//                 buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
// for filenames; on other platforms, this function indirectly depends on
// the [current locale](running.html#locale).
// 
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
// If the source encoding is not UTF-8 and the conversion output contains a
// nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
// function returns %NULL. Use g_convert() to produce output that
// may contain embedded nul characters.
func FilenameToUTF8(opsysstring string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(opsysstring)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_filename_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(opsysstring)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// FindProgramInPath wraps g_find_program_in_path
// 
// The function takes the following parameters:
// 
// 	- program string: a program name in the GLib file name encoding 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Locates the first executable named @program in the user's path, in the
// same way that execvp() would locate it. Returns an allocated string
// with the absolute path name, or %NULL if the program is not found in
// the path. If @program is already an absolute path, returns a copy of
// @program if @program exists and is executable, and %NULL otherwise.
//  
// On Windows, if @program does not have a file type suffix, tries
// with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
// the `PATHEXT` environment variable.
// 
// On Windows, it looks for the file in the same way as CreateProcess()
// would. This means first in the directory where the executing
// program was loaded from, then in the current directory, then in the
// Windows 32-bit system directory, then in the Windows directory, and
// finally in the directories in the `PATH` environment variable. If
// the program is found, the return value contains the full name
// including the type suffix.
func FindProgramInPath(program string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(program)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_find_program_in_path(carg1)
	runtime.KeepAlive(program)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FormatSize wraps g_format_size
// 
// The function takes the following parameters:
// 
// 	- size uint64: a size in bytes 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Formats a size (for example the size of a file) into a human readable
// string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
// and are displayed rounded to the nearest tenth. E.g. the file size
// 3292528 bytes will be converted into the string "3.2 MB". The returned string
// is UTF-8, and may use a non-breaking space to separate the number and units,
// to ensure they aren&#x2019;t separated when line wrapped.
// 
// The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
// 
// This string should be freed with g_free() when not needed any longer.
// 
// See g_format_size_full() for more options about how the size might be
// formatted.
func FormatSize(size uint64) string {
	var carg1 C.guint64 // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = C.guint64(size)

	cret = C.g_format_size(carg1)
	runtime.KeepAlive(size)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FormatSizeFull wraps g_format_size_full
// 
// The function takes the following parameters:
// 
// 	- size uint64: a size in bytes 
// 	- flags FormatSizeFlags: #GFormatSizeFlags to modify the output 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Formats a size.
// 
// This function is similar to g_format_size() but allows for flags
// that modify the output. See #GFormatSizeFlags.
func FormatSizeFull(size uint64, flags FormatSizeFlags) string {
	var carg1 C.guint64          // in, none, casted
	var carg2 C.GFormatSizeFlags // in, none, casted
	var cret  *C.gchar           // return, full, string

	carg1 = C.guint64(size)
	carg2 = C.GFormatSizeFlags(flags)

	cret = C.g_format_size_full(carg1, carg2)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetApplicationName wraps g_get_application_name
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets a human-readable name for the application, as set by
// g_set_application_name(). This name should be localized if
// possible, and is intended for display to the user.  Contrast with
// g_get_prgname(), which gets a non-localized name. If
// g_set_application_name() has not been called, returns the result of
// g_get_prgname() (which may be %NULL if g_set_prgname() has also not
// been called).
func GetApplicationName() string {
	var cret *C.gchar // return, none, string, nullable-string

	cret = C.g_get_application_name()

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetCharset wraps g_get_charset
// 
// The function returns the following values:
// 
// 	- charset string: return location for character set
//   name, or %NULL. 
// 	- goret bool 
//
// Obtains the character set for the [current locale](running.html#locale);
// you might use this character set as an argument to g_convert(), to convert
// from the current locale's encoding to some other encoding. (Frequently
// g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts, though.)
// 
// On Windows the character set returned by this function is the
// so-called system default ANSI code-page. That is the character set
// used by the "narrow" versions of C library and Win32 functions that
// handle file names. It might be different from the character set
// used by the C library's current locale.
// 
// On Linux, the character set is found by consulting nl_langinfo() if
// available. If not, the environment variables `LC_ALL`, `LC_CTYPE`, `LANG`
// and `CHARSET` are queried in order. nl_langinfo() returns the C locale if
// no locale has been loaded by setlocale().
// 
// The return value is %TRUE if the locale's encoding is UTF-8, in that
// case you can perhaps avoid calling g_convert().
// 
// The string returned in @charset is not allocated, and should not be
// freed.
func GetCharset() (string, bool) {
	var carg1 *C.char    // out, none, string
	var cret  C.gboolean // return

	cret = C.g_get_charset(&carg1)

	var charset string
	var goret   bool

	charset = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	if cret != 0 {
		goret = true
	}

	return charset, goret
}

// GetCodeset wraps g_get_codeset
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the character set for the current locale.
func GetCodeset() string {
	var cret *C.gchar // return, full, string

	cret = C.g_get_codeset()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetConsoleCharset wraps g_get_console_charset
// 
// The function returns the following values:
// 
// 	- charset string: return location for character set
//   name, or %NULL. 
// 	- goret bool 
//
// Obtains the character set used by the console attached to the process,
// which is suitable for printing output to the terminal.
// 
// Usually this matches the result returned by g_get_charset(), but in
// environments where the locale's character set does not match the encoding
// of the console this function tries to guess a more suitable value instead.
// 
// On Windows the character set returned by this function is the
// output code page used by the console associated with the calling process.
// If the codepage can't be determined (for example because there is no
// console attached) UTF-8 is assumed.
// 
// The return value is %TRUE if the locale's encoding is UTF-8, in that
// case you can perhaps avoid calling g_convert().
// 
// The string returned in @charset is not allocated, and should not be
// freed.
func GetConsoleCharset() (string, bool) {
	var carg1 *C.char    // out, none, string
	var cret  C.gboolean // return

	cret = C.g_get_console_charset(&carg1)

	var charset string
	var goret   bool

	charset = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	if cret != 0 {
		goret = true
	}

	return charset, goret
}

// GetCurrentDir wraps g_get_current_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the current directory.
// 
// The returned string should be freed when no longer needed.
// The encoding of the returned string is system defined.
// On Windows, it is always UTF-8.
// 
// Since GLib 2.40, this function will return the value of the "PWD"
// environment variable if it is set and it happens to be the same as
// the current directory.  This can make a difference in the case that
// the current directory is the target of a symbolic link.
func GetCurrentDir() string {
	var cret *C.gchar // return, full, string

	cret = C.g_get_current_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetEnviron wraps g_get_environ
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the list of environment variables for the current process.
// 
// The list is %NULL terminated and each item in the list is of the
// form 'NAME=VALUE'.
// 
// This is equivalent to direct access to the 'environ' global variable,
// except portable.
// 
// The return value is freshly allocated and it should be freed with
// g_strfreev() when it is no longer needed.
func GetEnviron() []string {
	var cret **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_environ()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetHomeDir wraps g_get_home_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the current user's home directory.
// 
// As with most UNIX tools, this function will return the value of the
// `HOME` environment variable if it is set to an existing absolute path
// name, falling back to the `passwd` file in the case that it is unset.
// 
// If the path given in `HOME` is non-absolute, does not exist, or is
// not a directory, the result is undefined.
// 
// Before version 2.36 this function would ignore the `HOME` environment
// variable, taking the value from the `passwd` database instead. This was
// changed to increase the compatibility of GLib with other programs (and
// the XDG basedir specification) and to increase testability of programs
// based on GLib (by making it easier to run them from test frameworks).
// 
// If your program has a strong requirement for either the new or the
// old behaviour (and if you don't wish to increase your GLib
// dependency to ensure that the new behaviour is in effect) then you
// should either directly check the `HOME` environment variable yourself
// or unset it before calling any functions in GLib.
func GetHomeDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_home_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetHostName wraps g_get_host_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Return a name for the machine.
// 
// The returned name is not necessarily a fully-qualified domain name,
// or even present in DNS or some other name service at all. It need
// not even be unique on your local network or site, but usually it
// is. Callers should not rely on the return value having any specific
// properties like uniqueness for security purposes. Even if the name
// of the machine is changed while an application is running, the
// return value from this function does not change. The returned
// string is owned by GLib and should not be modified or freed. If no
// name can be determined, a default fixed string "localhost" is
// returned.
// 
// The encoding of the returned string is UTF-8.
func GetHostName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_host_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetLanguageNames wraps g_get_language_names
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Computes a list of applicable locale names, which can be used to
// e.g. construct locale-dependent filenames or search paths. The returned
// list is sorted from most desirable to least desirable and always contains
// the default locale "C".
// 
// For example, if LANGUAGE=de:en_US, then the returned list is
// "de", "en_US", "en", "C".
// 
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// `LC_MESSAGES` and `LANG` to find the list of locales specified by the
// user.
func GetLanguageNames() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_language_names()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetLanguageNamesWithCategory wraps g_get_language_names_with_category
// 
// The function takes the following parameters:
// 
// 	- categoryName string: a locale category name 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Computes a list of applicable locale names with a locale category name,
// which can be used to construct the fallback locale-dependent filenames
// or search paths. The returned list is sorted from most desirable to
// least desirable and always contains the default locale "C".
// 
// This function consults the environment variables `LANGUAGE`, `LC_ALL`,
// @category_name, and `LANG` to find the list of locales specified by the
// user.
// 
// g_get_language_names() returns g_get_language_names_with_category("LC_MESSAGES").
func GetLanguageNamesWithCategory(categoryName string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(categoryName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_language_names_with_category(carg1)
	runtime.KeepAlive(categoryName)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetLocaleVariants wraps g_get_locale_variants
// 
// The function takes the following parameters:
// 
// 	- locale string: a locale identifier 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Returns a list of derived variants of @locale, which can be used to
// e.g. construct locale-dependent filenames or search paths. The returned
// list is sorted from most desirable to least desirable.
// This function handles territory, charset and extra locale modifiers. See
// [`setlocale(3)`](man:setlocale) for information about locales and their format.
// 
// @locale itself is guaranteed to be returned in the output.
// 
// For example, if @locale is `fr_BE`, then the returned list
// is `fr_BE`, `fr`. If @locale is `en_GB.UTF-8@euro`, then the returned list
// is `en_GB.UTF-8@euro`, `en_GB.UTF-8`, `en_GB@euro`, `en_GB`, `en.UTF-8@euro`,
// `en.UTF-8`, `en@euro`, `en`.
// 
// If you need the list of variants for the current locale,
// use g_get_language_names().
func GetLocaleVariants(locale string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_locale_variants(carg1)
	runtime.KeepAlive(locale)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetMonotonicTime wraps g_get_monotonic_time
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Queries the system monotonic time.
// 
// The monotonic clock will always increase and doesn't suffer
// discontinuities when the user (or NTP) changes the system time.  It
// may or may not continue to tick during times where the machine is
// suspended.
// 
// We try to use the clock that corresponds as closely as possible to
// the passage of time as measured by system calls such as poll() but it
// may not always be possible to do this.
func GetMonotonicTime() int64 {
	var cret C.gint64 // return, none, casted

	cret = C.g_get_monotonic_time()

	var goret int64

	goret = int64(cret)

	return goret
}

// GetNumProcessors wraps g_get_num_processors
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Determine the approximate number of threads that the system will
// schedule simultaneously for this process.  This is intended to be
// used as a parameter to g_thread_pool_new() for CPU bound tasks and
// similar cases.
func GetNumProcessors() uint {
	var cret C.guint // return, none, casted

	cret = C.g_get_num_processors()

	var goret uint

	goret = uint(cret)

	return goret
}

// GetOsInfo wraps g_get_os_info
// 
// The function takes the following parameters:
// 
// 	- keyName string: a key for the OS info being requested, for example %G_OS_INFO_KEY_NAME. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Get information about the operating system.
// 
// On Linux this comes from the `/etc/os-release` file. On other systems, it may
// come from a variety of sources. You can either use the standard key names
// like %G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
// `/etc/os-release` provides a number of other less commonly used values that may
// be useful. No key is guaranteed to be provided, so the caller should always
// check if the result is %NULL.
func GetOsInfo(keyName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(keyName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_os_info(carg1)
	runtime.KeepAlive(keyName)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetPrgname wraps g_get_prgname
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
// 
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK it is set in
// gdk_init(), which is called by gtk_init() and the
// #GtkApplication::startup handler. The program name is found by
// taking the last component of @argv[0].
func GetPrgname() string {
	var cret *C.gchar // return, none, string, nullable-string

	cret = C.g_get_prgname()

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetRealName wraps g_get_real_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the real name of the user. This usually comes from the user's
// entry in the `passwd` file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the
// real user name cannot be determined, the string "Unknown" is
// returned.
func GetRealName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_real_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetRealTime wraps g_get_real_time
// 
// The function returns the following values:
// 
// 	- goret int64 
//
// Queries the system wall-clock time.
// 
// This call is functionally equivalent to [func@GLib.get_current_time] except
// that the return value is often more convenient than dealing with a
// #GTimeVal.
// 
// You should only use this call if you are actually interested in the real
// wall-clock time. [func@GLib.get_monotonic_time] is probably more useful for
// measuring intervals.
func GetRealTime() int64 {
	var cret C.gint64 // return, none, casted

	cret = C.g_get_real_time()

	var goret int64

	goret = int64(cret)

	return goret
}

// GetSystemConfigDirs wraps g_get_system_config_dirs
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Returns an ordered list of base directories in which to access
// system-wide configuration information.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
// If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
// data for all users is used instead. A typical path is
// `C:\Documents and Settings\All Users\Application Data`.
// This folder is used for application data
// that is not user specific. For example, an application can store
// a spell-check dictionary, a database of clip art, or a log file in the
// FOLDERID_ProgramData folder. This information will not roam and is available
// to anyone using the computer.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetSystemConfigDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_system_config_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetSystemDataDirs wraps g_get_system_data_dirs
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Returns an ordered list of base directories in which to access
// system-wide application data.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
// In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
// If `XDG_DATA_DIRS` is undefined,
// the first elements in the list are the Application Data
// and Documents folders for All Users. (These can be determined only
// on Windows 2000 or later and are not present in the list on other
// Windows versions.) See documentation for FOLDERID_ProgramData and
// FOLDERID_PublicDocuments.
// 
// Then follows the "share" subfolder in the installation folder for
// the package containing the DLL that calls this function, if it can
// be determined.
// 
// Finally the list contains the "share" subfolder in the installation
// folder for GLib, and in the installation folder for the package the
// application's .exe file belongs to.
// 
// The installation folders above are determined by looking up the
// folder where the module (DLL or EXE) in question is located. If the
// folder's name is "bin", its parent is used, otherwise the folder
// itself.
// 
// Note that on Windows the returned list can vary depending on where
// this function is called.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetSystemDataDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_system_data_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetTmpDir wraps g_get_tmp_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the directory to use for temporary files.
// 
// On UNIX, this is taken from the `TMPDIR` environment variable.
// If the variable is not set, `P_tmpdir` is
// used, as defined by the system C library. Failing that, a
// hard-coded default of "/tmp" is returned.
// 
// On Windows, the `TEMP` environment variable is used, with the
// root directory of the Windows installation (eg: "C:\") used
// as a default.
// 
// The encoding of the returned string is system-defined. On Windows,
// it is always UTF-8. The return value is never %NULL or the empty
// string.
func GetTmpDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_tmp_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserCacheDir wraps g_get_user_cache_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a base directory in which to store non-essential, cached
// data specific to particular user.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_CACHE_HOME`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
// If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
// repository for temporary Internet files is used instead. A typical path is
// `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
// See the [documentation for `FOLDERID_InternetCache`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetUserCacheDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_cache_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserConfigDir wraps g_get_user_config_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a base directory in which to store user-specific application
// configuration information such as user preferences and settings.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_CONFIG_HOME`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
// If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
// to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be  the same
// as what g_get_user_data_dir() returns.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetUserConfigDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_config_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserDataDir wraps g_get_user_data_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a base directory in which to access application data such
// as icons that is customized for a particular user.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_DATA_HOME`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
// is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
// opposed to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same
// as what g_get_user_config_dir() returns.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetUserDataDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_data_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserName wraps g_get_user_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the user name of the current user. The encoding of the returned
// string is system-defined. On UNIX, it might be the preferred file name
// encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
func GetUserName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserRuntimeDir wraps g_get_user_runtime_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a directory that is unique to the current user on the local
// system.
// 
// This is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// This is the directory
// specified in the `XDG_RUNTIME_DIR` environment variable.
// In the case that this variable is not set, we return the value of
// g_get_user_cache_dir(), after verifying that it exists.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetUserRuntimeDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_runtime_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserSpecialDir wraps g_get_user_special_dir
// 
// The function takes the following parameters:
// 
// 	- directory UserDirectory: the logical id of special directory 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the full path of a special directory using its logical id.
// 
// On UNIX this is done using the XDG special user directories.
// For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
// falls back to `$HOME/Desktop` when XDG special user directories have
// not been set up.
// 
// Depending on the platform, the user might be able to change the path
// of the special directory without requiring the session to restart; GLib
// will not reflect any change once the special directories are loaded.
func GetUserSpecialDir(directory UserDirectory) string {
	var carg1 C.GUserDirectory // in, none, casted
	var cret  *C.gchar         // return, none, string, nullable

	carg1 = C.GUserDirectory(directory)

	cret = C.g_get_user_special_dir(carg1)
	runtime.KeepAlive(directory)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUserStateDir wraps g_get_user_state_dir
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a base directory in which to store state files specific to
// particular user.
// 
// On UNIX platforms this is determined using the mechanisms described
// in the
// [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
// In this case the directory retrieved will be `XDG_STATE_HOME`.
// 
// On Windows it follows XDG Base Directory Specification if `XDG_STATE_HOME` is defined.
// If `XDG_STATE_HOME` is undefined, the folder to use for local (as opposed
// to roaming) application data is used instead. See the
// [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
// Note that in this case on Windows it will be the same
// as what g_get_user_data_dir() returns.
// 
// The return value is cached and modifying it at runtime is not supported, as
// it&#x2019;s not thread-safe to modify environment variables at runtime.
func GetUserStateDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_state_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Getenv wraps g_getenv
// 
// The function takes the following parameters:
// 
// 	- variable string: the environment variable to get 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the value of an environment variable.
// 
// On UNIX, the name and value are byte strings which might or might not
// be in some consistent character set and encoding. On Windows, they are
// in UTF-8.
// On Windows, in case the environment variable's value contains
// references to other environment variables, they are expanded.
func Getenv(variable string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_getenv(carg1)
	runtime.KeepAlive(variable)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HostnameIsASCIIEncoded wraps g_hostname_is_ascii_encoded
// 
// The function takes the following parameters:
// 
// 	- hostname string: a hostname 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @hostname contains segments with an ASCII-compatible
// encoding of an Internationalized Domain Name. If this returns
// %TRUE, you should decode the hostname with g_hostname_to_unicode()
// before displaying it to the user.
// 
// Note that a hostname might contain a mix of encoded and unencoded
// segments, and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return %TRUE for a name.
func HostnameIsASCIIEncoded(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_ascii_encoded(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameIsIpAddress wraps g_hostname_is_ip_address
// 
// The function takes the following parameters:
// 
// 	- hostname string: a hostname (or IP address in string form) 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @hostname is the string form of an IPv4 or IPv6 address.
// (Eg, "192.168.0.1".)
// 
// Since 2.66, IPv6 addresses with a zone-id are accepted (RFC6874).
func HostnameIsIpAddress(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_ip_address(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameIsNonASCII wraps g_hostname_is_non_ascii
// 
// The function takes the following parameters:
// 
// 	- hostname string: a hostname 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tests if @hostname contains Unicode characters. If this returns
// %TRUE, you need to encode the hostname with g_hostname_to_ascii()
// before using it in non-IDN-aware contexts.
// 
// Note that a hostname might contain a mix of encoded and unencoded
// segments, and so it is possible for g_hostname_is_non_ascii() and
// g_hostname_is_ascii_encoded() to both return %TRUE for a name.
func HostnameIsNonASCII(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_non_ascii(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameToASCII wraps g_hostname_to_ascii
// 
// The function takes the following parameters:
// 
// 	- hostname string: a valid UTF-8 or ASCII hostname 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Converts @hostname to its canonical ASCII form; an ASCII-only
// string containing no uppercase letters and not ending with a
// trailing dot.
func HostnameToASCII(hostname string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_to_ascii(carg1)
	runtime.KeepAlive(hostname)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// HostnameToUnicode wraps g_hostname_to_unicode
// 
// The function takes the following parameters:
// 
// 	- hostname string: a valid UTF-8 or ASCII hostname 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Converts @hostname to its canonical presentation form; a UTF-8
// string in Unicode normalization form C, containing no uppercase
// letters, no forbidden characters, and no ASCII-encoded segments,
// and not ending with a trailing dot.
// 
// Of course if @hostname is not an internationalized hostname, then
// the canonical presentation form will be entirely ASCII.
func HostnameToUnicode(hostname string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_to_unicode(carg1)
	runtime.KeepAlive(hostname)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// IdleAddFull wraps g_idle_add_full
// 
// The function takes the following parameters:
// 
// 	- priority int32: the priority of the idle source. Typically this will be in the
//   range between [const@GLib.PRIORITY_DEFAULT_IDLE] and
//   [const@GLib.PRIORITY_HIGH_IDLE]. 
// 	- function SourceFunc: function to call 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Adds a function to be called whenever there are no higher priority
// events pending.
// 
// If the function returns [const@GLib.SOURCE_REMOVE] or %FALSE it is automatically
// removed from the list of event sources and will not be called again.
// 
// See [mainloop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
// 
// This internally creates a main loop source using [func@GLib.idle_source_new]
// and attaches it to the global [struct@GLib.MainContext] using
// [method@GLib.Source.attach], so the callback will be invoked in whichever
// thread is running that main context. You can do these steps manually if you
// need greater control or to use a custom main context.
func IdleAddFull(priority int32, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.GSourceFunc    // callback, scope: notified, closure: carg3, destroy: carg4
	var carg3 C.gpointer       // implicit
	var carg4 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg3 = C.gpointer(userdata.Register(function))
	carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_idle_add_full(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// InternStaticString wraps g_intern_static_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a static string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a canonical representation for @string. Interned strings
// can be compared for equality by comparing the pointers, instead of
// using strcmp(). g_intern_static_string() does not copy the string,
// therefore @string must not be freed or modified.
// 
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternStaticString(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_intern_static_string(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// InternString wraps g_intern_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a canonical representation for @string. Interned strings
// can be compared for equality by comparing the pointers, instead of
// using strcmp().
// 
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func InternString(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_intern_string(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Listenv wraps g_listenv
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Gets the names of all variables set in the environment.
// 
// Programs that want to be portable to Windows should typically use
// this function and g_getenv() instead of using the environ array
// from the C library directly. On Windows, the strings in the environ
// array are in system codepage encoding, while in most of the typical
// use cases for environment variables in GLib-using programs you want
// the UTF-8 encoding that this function and g_getenv() provide.
func Listenv() []string {
	var cret **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_listenv()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// LocaleFromUTF8 wraps g_locale_from_utf8
// 
// The function takes the following parameters:
// 
// 	- utf8string string: a UTF-8 encoded string 
// 	- len int: the length of the string, or -1 if the string is
//                 nul-terminated. 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in the
//                 input string that were successfully converted, or %NULL.
//                 Even if the conversion was successful, this may be
//                 less than @len if there were partial characters
//                 at the end of the input. If the error
//                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
//                 stored will be the byte offset after the last valid
//                 input sequence. 
// 	- bytesWritten uint: the number of bytes stored in the output
//                 buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string from UTF-8 to the encoding used for strings by
// the C runtime (usually the same as that used by the operating
// system) in the [current locale](running.html#locale).
// On Windows this means the system codepage.
// 
// The input string shall not contain nul characters even if the @len
// argument is positive. A nul character found inside the string will result
// in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
// input that may contain embedded nul characters.
func LocaleFromUTF8(utf8string string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8string)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_locale_from_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(utf8string)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// LocaleToUTF8 wraps g_locale_to_utf8
// 
// The function takes the following parameters:
// 
// 	- opsysstring string: a string in the
//                 encoding of the current locale. On Windows
//                 this means the system codepage. 
// 
// The function returns the following values:
// 
// 	- bytesRead uint: location to store the number of bytes in the
//                 input string that were successfully converted, or %NULL.
//                 Even if the conversion was successful, this may be
//                 less than @len if there were partial characters
//                 at the end of the input. If the error
//                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
//                 stored will be the byte offset after the last valid
//                 input sequence. 
// 	- bytesWritten uint: the number of bytes stored in the output
//                 buffer (not including the terminating nul). 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating
// system) in the [current locale](running.html#locale) into a UTF-8 string.
// 
// If the source encoding is not UTF-8 and the conversion output contains a
// nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
// function returns %NULL.
// If the source encoding is UTF-8, an embedded nul character is treated with
// the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
// earlier versions of this library. Use g_convert() to produce output that
// may contain embedded nul characters.
func LocaleToUTF8(opsysstring string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	_ = opsysstring
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_locale_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(opsysstring)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// LogGetDebugEnabled wraps g_log_get_debug_enabled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Return whether debug output from the GLib logging system is enabled.
// 
// Note that this should not be used to conditionalise calls to [func@GLib.debug] or
// other logging functions; it should only be used from [type@GLib.LogWriterFunc]
// implementations.
// 
// Note also that the value of this does not depend on `G_MESSAGES_DEBUG`, nor
// `DEBUG_INVOCATION`, nor [func@GLib.log_writer_default_set_debug_domains]; see
// the docs for [func@GLib.log_set_debug_enabled].
func LogGetDebugEnabled() bool {
	var cret C.gboolean // return

	cret = C.g_log_get_debug_enabled()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogRemoveHandler wraps g_log_remove_handler
// 
// The function takes the following parameters:
// 
// 	- logDomain string: the log domain 
// 	- handlerId uint: the ID of the handler, which was returned
//   in [func@GLib.log_set_handler] 
//
// Removes the log handler.
// 
// This has no effect if structured logging is enabled; see
// [Using Structured Logging](logging.html#using-structured-logging).
func LogRemoveHandler(logDomain string, handlerId uint) {
	var carg1 *C.gchar // in, none, string
	var carg2 C.guint  // in, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(handlerId)

	C.g_log_remove_handler(carg1, carg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(handlerId)
}

// LogSetAlwaysFatal wraps g_log_set_always_fatal
// 
// The function takes the following parameters:
// 
// 	- fatalMask LogLevelFlags: the mask containing bits set for each level of error which is
//   to be fatal 
// 
// The function returns the following values:
// 
// 	- goret LogLevelFlags 
//
// Sets the message levels which are always fatal, in any log domain.
// 
// When a message with any of these levels is logged the program terminates.
// You can only set the levels defined by GLib to be fatal.
// [flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.
// 
// You can also make some message levels fatal at runtime by setting
// the `G_DEBUG` environment variable (see
// [Running GLib Applications](running.html)).
// 
// Libraries should not call this function, as it affects all messages logged
// by a process, including those from other libraries.
// 
// Structured log messages (using [func@GLib.log_structured] and
// [func@GLib.log_structured_array]) are fatal only if the default log writer is used;
// otherwise it is up to the writer function to determine which log messages
// are fatal. See [Using Structured Logging](logging.html#using-structured-logging).
func LogSetAlwaysFatal(fatalMask LogLevelFlags) LogLevelFlags {
	var carg1 C.GLogLevelFlags // in, none, casted
	var cret  C.GLogLevelFlags // return, none, casted

	carg1 = C.GLogLevelFlags(fatalMask)

	cret = C.g_log_set_always_fatal(carg1)
	runtime.KeepAlive(fatalMask)

	var goret LogLevelFlags

	goret = LogLevelFlags(cret)

	return goret
}

// LogSetDebugEnabled wraps g_log_set_debug_enabled
// 
// The function takes the following parameters:
// 
// 	- enabled bool: `TRUE` to enable debug output, `FALSE` otherwise 
//
// Enable or disable debug output from the GLib logging system for all domains.
// 
// This value interacts disjunctively with `G_MESSAGES_DEBUG`, `DEBUG_INVOCATION` and
// [func@GLib.log_writer_default_set_debug_domains] &#x2014; if any of them would allow
// a debug message to be outputted, it will be.
// 
// Note that this should not be used from within library code to enable debug
// output &#x2014; it is intended for external use.
func LogSetDebugEnabled(enabled bool) {
	var carg1 C.gboolean // in

	if enabled {
		carg1 = C.TRUE
	}

	C.g_log_set_debug_enabled(carg1)
	runtime.KeepAlive(enabled)
}

// LogSetFatalMask wraps g_log_set_fatal_mask
// 
// The function takes the following parameters:
// 
// 	- logDomain string: the log domain 
// 	- fatalMask LogLevelFlags: the new fatal mask 
// 
// The function returns the following values:
// 
// 	- goret LogLevelFlags 
//
// Sets the log levels which are fatal in the given domain.
// 
// [flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.
// 
// This has no effect on structured log messages (using [func@GLib.log_structured] or
// [func@GLib.log_structured_array]). To change the fatal behaviour for specific log
// messages, programs must install a custom log writer function using
// [func@GLib.log_set_writer_func]. See
// [Using Structured Logging](logging.html#using-structured-logging).
// 
// This function is mostly intended to be used with
// [flags@GLib.LogLevelFlags.LEVEL_CRITICAL].  You should typically not set
// [flags@GLib.LogLevelFlags.LEVEL_WARNING], [flags@GLib.LogLevelFlags.LEVEL_MESSAGE], [flags@GLib.LogLevelFlags.LEVEL_INFO] or
// [flags@GLib.LogLevelFlags.LEVEL_DEBUG] as fatal except inside of test programs.
func LogSetFatalMask(logDomain string, fatalMask LogLevelFlags) LogLevelFlags {
	var carg1 *C.gchar         // in, none, string
	var carg2 C.GLogLevelFlags // in, none, casted
	var cret  C.GLogLevelFlags // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GLogLevelFlags(fatalMask)

	cret = C.g_log_set_fatal_mask(carg1, carg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(fatalMask)

	var goret LogLevelFlags

	goret = LogLevelFlags(cret)

	return goret
}

// LogSetHandlerFull wraps g_log_set_handler_full
// 
// The function takes the following parameters:
// 
// 	- logDomain string (nullable): the log domain
//   application domain 
// 	- logLevels LogLevelFlags: the log levels to apply the log handler for.
//   To handle fatal and recursive messages as well, combine
//   the log levels with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and
//   [flags@GLib.LogLevelFlags.FLAG_RECURSION] bit flags. 
// 	- logFunc LogFunc: the log handler function 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Like [func@GLib.log_set_handler], but takes a destroy notify for the @user_data.
// 
// This has no effect if structured logging is enabled; see
// [Using Structured Logging](logging.html#using-structured-logging).
// 
// The `log_domain` parameter can be set to `NULL` or an empty string to use the default
// application domain.
func LogSetHandlerFull(logDomain string, logLevels LogLevelFlags, logFunc LogFunc) uint {
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 C.GLogLevelFlags // in, none, casted
	var carg3 C.GLogFunc       // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	if logDomain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GLogLevelFlags(logLevels)
	carg3 = (*[0]byte)(C._goglib_glib2_LogFunc)
	carg4 = C.gpointer(userdata.Register(logFunc))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_log_set_handler_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevels)
	runtime.KeepAlive(logFunc)

	var goret uint

	goret = uint(cret)

	return goret
}

// LogSetWriterFunc wraps g_log_set_writer_func
// 
// The function takes the following parameters:
// 
//
// Set a writer function which will be called to format and write out each log
// message.
// 
// Each program should set a writer function, or the default writer
// ([func@GLib.log_writer_default]) will be used.
// 
// Libraries **must not** call this function &#x2014; only programs are allowed to
// install a writer function, as there must be a single, central point where
// log messages are formatted and outputted.
// 
// There can only be one writer function. It is an error to set more than one.
func LogSetWriterFunc() {
	var carg1 C.GLogWriterFunc // implicit
	var carg2 C.gpointer       // implicit
	var carg3 C.GDestroyNotify // implicit

	C.g_log_set_writer_func(carg1, carg2, carg3)
}

// LogStructuredArray wraps g_log_structured_array
// 
// The function takes the following parameters:
// 
// 	- logLevel LogLevelFlags: log level, either from [type@GLib.LogLevelFlags], or a user-defined
//    level 
// 	- fields []LogField: key&#x2013;value pairs of structured data to add
//    to the log message 
//
// Log a message with structured data.
// 
// The message will be passed through to the log writer set by the application
// using [func@GLib.log_set_writer_func]. If the
// message is fatal (i.e. its log level is [flags@GLib.LogLevelFlags.LEVEL_ERROR]), the program will
// be aborted at the end of this function.
// 
// See [func@GLib.log_structured] for more documentation.
// 
// This assumes that @log_level is already present in @fields (typically as the
// `PRIORITY` field).
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.GLogField     // in, transfer: none, C Pointers: 1, Name: array[LogField], array (inner GLogField (*typesystem.Record), length-by: carg3)
	var carg3 C.gsize          // implicit

	carg1 = C.GLogLevelFlags(logLevel)
	_ = fields
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []LogField (const GLogField*) because of unimplemented: non-fixed size array")

	C.g_log_structured_array(carg1, carg2, carg3)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogWriterDefaultSetUseStderr wraps g_log_writer_default_set_use_stderr
// 
// The function takes the following parameters:
// 
// 	- useStderr bool: If `TRUE`, use `stderr` for log messages that would
//  normally have appeared on `stdout` 
//
// Configure whether the built-in log functions will output all log messages to
// `stderr`.
// 
// The built-in log functions are [func@GLib.log_default_handler] for the
// old-style API, and both [func@GLib.log_writer_default] and
// [func@GLib.log_writer_standard_streams] for the structured API.
// 
// By default, log messages of levels [flags@GLib.LogLevelFlags.LEVEL_INFO] and
// [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are sent to `stdout`, and other log messages are
// sent to `stderr`. This is problematic for applications that intend
// to reserve `stdout` for structured output such as JSON or XML.
// 
// This function sets global state. It is not thread-aware, and should be
// called at the very start of a program, before creating any other threads
// or creating objects that could create worker threads of their own.
func LogWriterDefaultSetUseStderr(useStderr bool) {
	var carg1 C.gboolean // in

	if useStderr {
		carg1 = C.TRUE
	}

	C.g_log_writer_default_set_use_stderr(carg1)
	runtime.KeepAlive(useStderr)
}

// LogWriterDefaultWouldDrop wraps g_log_writer_default_would_drop
// 
// The function takes the following parameters:
// 
// 	- logLevel LogLevelFlags: log level, either from [type@GLib.LogLevelFlags], or a user-defined
//    level 
// 	- logDomain string (nullable): log domain 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether [func@GLib.log_writer_default] and [func@GLib.log_default_handler] would
// ignore a message with the given domain and level.
// 
// As with [func@GLib.log_default_handler], this function drops debug and informational
// messages unless their log domain (or `all`) is listed in the space-separated
// `G_MESSAGES_DEBUG` environment variable, or `DEBUG_INVOCATION=1` is set in
// the environment, or by [func@GLib.log_writer_default_set_debug_domains].
// 
// This can be used when implementing log writers with the same filtering
// behaviour as the default, but a different destination or output format:
// 
// ```c
// if (g_log_writer_default_would_drop (log_level, log_domain))
//   return G_LOG_WRITER_HANDLED;
// ]|
// 
// or to skip an expensive computation if it is only needed for a debugging
// message, and `G_MESSAGES_DEBUG` and `DEBUG_INVOCATION` are not set:
// 
// ```c
// if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN))
//   {
//     g_autofree gchar *result = expensive_computation (my_object);
// 
//     g_debug ("my_object result: %s", result);
//   }
// ```
func LogWriterDefaultWouldDrop(logLevel LogLevelFlags, logDomain string) bool {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.char          // in, none, string, nullable-string
	var cret  C.gboolean       // return

	carg1 = C.GLogLevelFlags(logLevel)
	if logDomain != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_log_writer_default_would_drop(carg1, carg2)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(logDomain)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogWriterFormatFields wraps g_log_writer_format_fields
// 
// The function takes the following parameters:
// 
// 	- logLevel LogLevelFlags: log level, either from [type@GLib.LogLevelFlags], or a user-defined
//    level 
// 	- fields []LogField: key&#x2013;value pairs of structured data forming
//    the log message 
// 	- useColor bool: `TRUE` to use
//   [ANSI color escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
//   when formatting the message, `FALSE` to not 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Format a structured log message as a string suitable for outputting to the
// terminal (or elsewhere).
// 
// This will include the values of all fields it knows
// how to interpret, which includes `MESSAGE` and `GLIB_DOMAIN` (see the
// documentation for [func@GLib.log_structured]). It does not include values from
// unknown fields.
// 
// The returned string does **not** have a trailing new-line character. It is
// encoded in the character set of the current locale, which is not necessarily
// UTF-8.
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.GLogField     // in, transfer: none, C Pointers: 1, Name: array[LogField], array (inner GLogField (*typesystem.Record), length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var cret  *C.gchar         // return, full, string

	carg1 = C.GLogLevelFlags(logLevel)
	_ = fields
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []LogField (const GLogField*) because of unimplemented: non-fixed size array")
	if useColor {
		carg4 = C.TRUE
	}

	cret = C.g_log_writer_format_fields(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(useColor)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// LogWriterIsJournald wraps g_log_writer_is_journald
// 
// The function takes the following parameters:
// 
// 	- outputFd int32: output file descriptor to check 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether the given @output_fd file descriptor is a connection to the
// systemd journal, or something else (like a log file or `stdout` or
// `stderr`).
// 
// Invalid file descriptors are accepted and return `FALSE`, which allows for
// the following construct without needing any additional error handling:
// ```c
// is_journald = g_log_writer_is_journald (fileno (stderr));
// ```
func LogWriterIsJournald(outputFd int32) bool {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gint(outputFd)

	cret = C.g_log_writer_is_journald(carg1)
	runtime.KeepAlive(outputFd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogWriterSupportsColor wraps g_log_writer_supports_color
// 
// The function takes the following parameters:
// 
// 	- outputFd int32: output file descriptor to check 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Check whether the given @output_fd file descriptor supports
// [ANSI color escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code).
// 
// If so, they can safely be used when formatting log messages.
func LogWriterSupportsColor(outputFd int32) bool {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gint(outputFd)

	cret = C.g_log_writer_supports_color(carg1)
	runtime.KeepAlive(outputFd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MainDepth wraps g_main_depth
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the depth of the stack of calls to
// [method@GLib.MainContext.dispatch] on any #GMainContext in the current thread.
// That is, when called from the toplevel, it gives 0. When
// called from within a callback from [method@GLib.MainContext.iteration]
// (or [method@GLib.MainLoop.run], etc.) it returns 1. When called from within
// a callback to a recursive call to [method@GLib.MainContext.iteration],
// it returns 2. And so forth.
// 
// This function is useful in a situation like the following:
// Imagine an extremely simple "garbage collected" system.
// 
// |[&lt;!-- language="C" --&gt;
// static GList *free_list;
// 
// gpointer
// allocate_memory (gsize size)
// {
//   gpointer result = g_malloc (size);
//   free_list = g_list_prepend (free_list, result);
//   return result;
// }
// 
// void
// free_allocated_memory (void)
// {
//   GList *l;
//   for (l = free_list; l; l = l-&gt;next);
//     g_free (l-&gt;data);
//   g_list_free (free_list);
//   free_list = NULL;
//  }
// 
// [...]
// 
// while (TRUE);
//  {
//    g_main_context_iteration (NULL, TRUE);
//    free_allocated_memory();
//   }
// ]|
// 
// This works from an application, however, if you want to do the same
// thing from a library, it gets more difficult, since you no longer
// control the main loop. You might think you can simply use an idle
// function to make the call to free_allocated_memory(), but that
// doesn't work, since the idle function could be called from a
// recursive callback. This can be fixed by using [func@GLib.main_depth]
// 
// |[&lt;!-- language="C" --&gt;
// gpointer
// allocate_memory (gsize size)
// {
//   FreeListBlock *block = g_new (FreeListBlock, 1);
//   block-&gt;mem = g_malloc (size);
//   block-&gt;depth = g_main_depth ();
//   free_list = g_list_prepend (free_list, block);
//   return block-&gt;mem;
// }
// 
// void
// free_allocated_memory (void)
// {
//   GList *l;
//   
//   int depth = g_main_depth ();
//   for (l = free_list; l; );
//     {
//       GList *next = l-&gt;next;
//       FreeListBlock *block = l-&gt;data;
//       if (block-&gt;depth &gt; depth)
//         {
//           g_free (block-&gt;mem);
//           g_free (block);
//           free_list = g_list_delete_link (free_list, l);
//         }
//               
//       l = next;
//     }
//   }
// ]|
// 
// There is a temptation to use [func@GLib.main_depth] to solve
// problems with reentrancy. For instance, while waiting for data
// to be received from the network in response to a menu item,
// the menu item might be selected again. It might seem that
// one could make the menu item's callback return immediately
// and do nothing if [func@GLib.main_depth] returns a value greater than 1.
// However, this should be avoided since the user then sees selecting
// the menu item do nothing. Furthermore, you'll find yourself adding
// these checks all over your code, since there are doubtless many,
// many things that the user could do. Instead, you can use the
// following techniques:
// 
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
//    the user from interacting with elements while the main
//    loop is recursing.
// 
// 2. Avoid main loop recursion in situations where you can't handle
//    arbitrary  callbacks. Instead, structure your code so that you
//    simply return to the main loop and then get called again when
//    there is more work to do.
func MainDepth() int32 {
	var cret C.gint // return, none, casted

	cret = C.g_main_depth()

	var goret int32

	goret = int32(cret)

	return goret
}

// MarkupErrorQuark wraps g_markup_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func MarkupErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_markup_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// MarkupEscapeText wraps g_markup_escape_text
// 
// The function takes the following parameters:
// 
// 	- text string: some valid UTF-8 text 
// 	- length int: length of @text in bytes, or -1 if the text is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes text so that the markup parser will parse it verbatim.
// Less than, greater than, ampersand, etc. are replaced with the
// corresponding entities. This function would typically be used
// when writing out a file to be parsed with the markup parser.
// 
// Note that this function doesn't protect whitespace and line endings
// from being processed according to the XML rules for normalization
// of line endings and attribute values.
// 
// Note also that this function will produce character references in
// the range of &amp;#x1; ... &amp;#x1f; for all control sequences
// except for tabstop, newline and carriage return.  The character
// references in this range are not valid XML 1.0, but they are
// valid XML 1.1 and will be accepted by the GMarkup parser.
func MarkupEscapeText(text string, length int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)

	cret = C.g_markup_escape_text(carg1, carg2)
	runtime.KeepAlive(text)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// MkdirWithParents wraps g_mkdir_with_parents
// 
// The function takes the following parameters:
// 
// 	- pathname string: a pathname in the GLib file name encoding 
// 	- mode int32: permissions to use for newly created directories 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Create a directory if it doesn't already exist. Create intermediate
// parent directories as needed, too.
func MkdirWithParents(pathname string, mode int32) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pathname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(mode)

	cret = C.g_mkdir_with_parents(carg1, carg2)
	runtime.KeepAlive(pathname)
	runtime.KeepAlive(mode)

	var goret int32

	goret = int32(cret)

	return goret
}

// NumberParserErrorQuark wraps g_number_parser_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func NumberParserErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_number_parser_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// OnErrorQuery wraps g_on_error_query
// 
// The function takes the following parameters:
// 
// 	- prgName string: the program name, needed by gdb for the "[S]tack trace"
//     option. If @prg_name is %NULL, g_get_prgname() is called to get
//     the program name (which will work correctly if gdk_init() or
//     gtk_init() has been called) 
//
// Prompts the user with
// `[E]xit, [H]alt, show [S]tack trace or [P]roceed`.
// This function is intended to be used for debugging use only.
// The following example shows how it can be used together with
// the g_log() functions.
// 
// |[&lt;!-- language="C" --&gt;
// #include &lt;glib.h&gt;
// 
// static void
// log_handler (const gchar   *log_domain,
//              GLogLevelFlags log_level,
//              const gchar   *message,
//              gpointer       user_data)
// {
//   g_log_default_handler (log_domain, log_level, message, user_data);
// 
//   g_on_error_query (MY_PROGRAM_NAME);
// }
// 
// int
// main (int argc, char *argv[])
// {
//   g_log_set_handler (MY_LOG_DOMAIN,
//                      G_LOG_LEVEL_WARNING |
//                      G_LOG_LEVEL_ERROR |
//                      G_LOG_LEVEL_CRITICAL,
//                      log_handler,
//                      NULL);
//   ...
// ]|
// 
// If "[E]xit" is selected, the application terminates with a call
// to _exit(0).
// 
// If "[S]tack" trace is selected, g_on_error_stack_trace() is called.
// This invokes gdb, which attaches to the current process and shows
// a stack trace. The prompt is then shown again.
// 
// If "[P]roceed" is selected, the function returns.
// 
// This function may cause different actions on non-UNIX platforms.
// 
// On Windows consider using the `G_DEBUGGER` environment
// variable (see [Running GLib Applications](running.html)) and
// calling g_on_error_stack_trace() instead.
func OnErrorQuery(prgName string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_on_error_query(carg1)
	runtime.KeepAlive(prgName)
}

// OnErrorStackTrace wraps g_on_error_stack_trace
// 
// The function takes the following parameters:
// 
// 	- prgName string (nullable): the program name, needed by gdb for the
//   "[S]tack trace" option, or `NULL` to use a default string 
//
// Invokes gdb, which attaches to the current process and shows a
// stack trace. Called by g_on_error_query() when the "[S]tack trace"
// option is selected. You can get the current process's program name
// with g_get_prgname(), assuming that you have called gtk_init() or
// gdk_init().
// 
// This function may cause different actions on non-UNIX platforms.
// 
// When running on Windows, this function is *not* called by
// g_on_error_query(). If called directly, it will raise an
// exception, which will crash the program. If the `G_DEBUGGER` environment
// variable is set, a debugger will be invoked to attach and
// handle that exception (see [Running GLib Applications](running.html)).
func OnErrorStackTrace(prgName string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if prgName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgName)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_on_error_stack_trace(carg1)
	runtime.KeepAlive(prgName)
}

// OptionErrorQuark wraps g_option_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func OptionErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_option_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ParseDebugString wraps g_parse_debug_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a list of debug options separated by colons, spaces, or
// commas, or %NULL. 
// 	- keys []DebugKey: pointer to an array of #GDebugKey which associate
//     strings with bit flags. 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Parses a string containing debugging options
// into a %guint containing bit flags. This is used
// within GDK and GTK to parse the debug options passed on the
// command line or through environment variables.
// 
// If @string is equal to "all", all flags are set. Any flags
// specified along with "all" in @string are inverted; thus,
// "all,foo,bar" or "foo,bar,all" sets all flags except those
// corresponding to "foo" and "bar".
// 
// If @string is equal to "help", all the available keys in @keys
// are printed out to standard error.
func ParseDebugString(str string, keys []DebugKey) uint {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var carg2 *C.GDebugKey // in, transfer: none, C Pointers: 1, Name: array[DebugKey], array (inner GDebugKey (*typesystem.Record), length-by: carg3)
	var carg3 C.guint      // implicit
	var cret  C.guint      // return, none, casted

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = keys
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []DebugKey (const GDebugKey*) because of unimplemented: non-fixed size array")

	cret = C.g_parse_debug_string(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(keys)

	var goret uint

	goret = uint(cret)

	return goret
}

// PathGetBasename wraps g_path_get_basename
// 
// The function takes the following parameters:
// 
// 	- fileName string: the name of the file 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the last component of the filename.
// 
// If @file_name ends with a directory separator it gets the component
// before the last slash. If @file_name consists only of directory
// separators (and on Windows, possibly a drive letter), a single
// separator is returned. If @file_name is empty, it gets ".".
func PathGetBasename(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_get_basename(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// PathGetDirname wraps g_path_get_dirname
// 
// The function takes the following parameters:
// 
// 	- fileName string: the name of the file 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the directory components of a file name. For example, the directory
// component of `/usr/bin/test` is `/usr/bin`. The directory component of `/`
// is `/`.
// 
// If the file name has no directory components "." is returned.
// The returned string should be freed when no longer needed.
func PathGetDirname(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_get_dirname(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// PathIsAbsolute wraps g_path_is_absolute
// 
// The function takes the following parameters:
// 
// 	- fileName string: a file name 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns %TRUE if the given @file_name is an absolute file name.
// Note that this is a somewhat vague concept on Windows.
// 
// On POSIX systems, an absolute file name is well-defined. It always
// starts from the single root directory. For example "/usr/local".
// 
// On Windows, the concepts of current drive and drive-specific
// current directory introduce vagueness. This function interprets as
// an absolute file name one that either begins with a directory
// separator such as "\Users\tml" or begins with the root on a drive,
// for example "C:\Windows". The first case also includes UNC paths
// such as "\\\\myserver\docs\foo". In all cases, either slashes or
// backslashes are accepted.
// 
// Note that a file name relative to the current drive root does not
// truly specify a file uniquely over time and across processes, as
// the current drive is a per-process value and can be changed.
// 
// File names relative the current directory on some specific drive,
// such as "D:foo/bar", are not interpreted as absolute by this
// function, but they obviously are not relative to the normal current
// directory as returned by getcwd() or g_get_current_dir()
// either. Such paths should be avoided, or need to be handled using
// Windows-specific code.
func PathIsAbsolute(fileName string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_is_absolute(carg1)
	runtime.KeepAlive(fileName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PathSkipRoot wraps g_path_skip_root
// 
// The function takes the following parameters:
// 
// 	- fileName string: a file name 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns a pointer into @file_name after the root component,
// i.e. after the "/" in UNIX or "C:\" under Windows. If @file_name
// is not an absolute path it returns %NULL.
func PathSkipRoot(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_skip_root(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PatternMatchSimple wraps g_pattern_match_simple
// 
// The function takes the following parameters:
// 
// 	- pattern string: the UTF-8 encoded pattern 
// 	- str string: the UTF-8 encoded string to match 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Matches a string against a pattern given as a string.
// 
// If this
// function is to be called in a loop, it&#x2019;s more efficient to compile
// the pattern once with [ctor@GLib.PatternSpec.new] and call
// [method@GLib.PatternSpec.match_string] repeatedly.
func PatternMatchSimple(pattern string, str string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_pattern_match_simple(carg1, carg2)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Poll wraps g_poll
// 
// The function takes the following parameters:
// 
// 	- fds *PollFD: file descriptors to poll 
// 	- nfds uint: the number of file descriptors in @fds 
// 	- timeout int32: amount of time to wait, in milliseconds, or -1 to wait forever 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Polls @fds, as with the poll() system call, but portably. (On
// systems that don't have poll(), it is emulated using select().)
// This is used internally by #GMainContext, but it can be called
// directly if you need to block until a file descriptor is ready, but
// don't want to run the full main loop.
// 
// Each element of @fds is a #GPollFD describing a single file
// descriptor to poll. The @fd field indicates the file descriptor,
// and the @events field indicates the events to poll for. On return,
// the @revents fields will be filled with the events that actually
// occurred.
// 
// On POSIX systems, the file descriptors in @fds can be any sort of
// file descriptor, but the situation is much more complicated on
// Windows. If you need to use g_poll() in code that has to run on
// Windows, the easiest solution is to construct all of your
// #GPollFDs with g_io_channel_win32_make_pollfd().
func Poll(fds *PollFD, nfds uint, timeout int32) int32 {
	var carg1 *C.GPollFD // in, none, converted
	var carg2 C.guint    // in, none, casted
	var carg3 C.gint     // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fds))
	carg2 = C.guint(nfds)
	carg3 = C.gint(timeout)

	cret = C.g_poll(carg1, carg2, carg3)
	runtime.KeepAlive(fds)
	runtime.KeepAlive(nfds)
	runtime.KeepAlive(timeout)

	var goret int32

	goret = int32(cret)

	return goret
}

// PropagateError wraps g_propagate_error
// 
// The function takes the following parameters:
// 
// 	- src error: error to move into the return location 
// 
// The function returns the following values:
// 
// 	- dest error (nullable): error return location 
//
// If @dest is %NULL, free @src; otherwise, moves @src into `*dest`.
// The error variable @dest points to must be %NULL.
// 
// @src must be non-%NULL.
// 
// Note that @src is no longer valid after this call. If you want
// to keep using the same GError*, you need to set it to %NULL
// after calling this function on it.
func PropagateError(src error) error {
	var carg2 *C.GError // in, full, converted
	var carg1 *C.GError // out, full, converted, nullable

	carg2 = (*C.GError)(UnsafeErrorToGlibFull(src))

	C.g_propagate_error(&carg1, carg2)
	runtime.KeepAlive(src)

	var dest error

	if carg1 != nil {
		dest = UnsafeErrorFromGlibFull(unsafe.Pointer(carg1))
	}

	return dest
}

// QuarkFromStaticString wraps g_quark_from_static_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a string 
// 
// The function returns the following values:
// 
// 	- goret Quark 
//
// Gets the #GQuark identifying the given (static) string. If the
// string does not currently have an associated #GQuark, a new #GQuark
// is created, linked to the given string.
// 
// Note that this function is identical to g_quark_from_string() except
// that if a new #GQuark is created the string itself is used rather
// than a copy. This saves memory, but can only be used if the string
// will continue to exist until the program terminates. It can be used
// with statically allocated strings in the main program, but not with
// statically allocated memory in dynamically loaded modules, if you
// expect to ever unload the module again (e.g. do not use this
// function in GTK theme engines).
// 
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func QuarkFromStaticString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_from_static_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// QuarkFromString wraps g_quark_from_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a string 
// 
// The function returns the following values:
// 
// 	- goret Quark 
//
// Gets the #GQuark identifying the given string. If the string does
// not currently have an associated #GQuark, a new #GQuark is created,
// using a copy of the string.
// 
// This function must not be used before library constructors have finished
// running. In particular, this means it cannot be used to initialize global
// variables in C++.
func QuarkFromString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_from_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// QuarkToString wraps g_quark_to_string
// 
// The function takes the following parameters:
// 
// 	- quark Quark: a #GQuark. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the string associated with the given #GQuark.
func QuarkToString(quark Quark) string {
	var carg1 C.GQuark // in, none, casted, alias
	var cret  *C.gchar // return, none, string

	carg1 = C.GQuark(quark)

	cret = C.g_quark_to_string(carg1)
	runtime.KeepAlive(quark)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// QuarkTryString wraps g_quark_try_string
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): a string 
// 
// The function returns the following values:
// 
// 	- goret Quark 
//
// Gets the #GQuark associated with the given string, or 0 if string is
// %NULL or it has no associated #GQuark.
// 
// If you want the GQuark to be created if it doesn't already exist,
// use g_quark_from_string() or g_quark_from_static_string().
// 
// This function must not be used before library constructors have finished
// running.
func QuarkTryString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_try_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// RandomDouble wraps g_random_double
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Returns a random #gdouble equally distributed over the range [0..1).
func RandomDouble() float64 {
	var cret C.gdouble // return, none, casted

	cret = C.g_random_double()

	var goret float64

	goret = float64(cret)

	return goret
}

// RandomDoubleRange wraps g_random_double_range
// 
// The function takes the following parameters:
// 
// 	- begin float64: lower closed bound of the interval 
// 	- end float64: upper open bound of the interval 
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Returns a random #gdouble equally distributed over the range
// [@begin..@end).
func RandomDoubleRange(begin float64, end float64) float64 {
	var carg1 C.gdouble // in, none, casted
	var carg2 C.gdouble // in, none, casted
	var cret  C.gdouble // return, none, casted

	carg1 = C.gdouble(begin)
	carg2 = C.gdouble(end)

	cret = C.g_random_double_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret float64

	goret = float64(cret)

	return goret
}

// RandomInt wraps g_random_int
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Return a random #guint32 equally distributed over the range
// [0..2^32-1].
func RandomInt() uint32 {
	var cret C.guint32 // return, none, casted

	cret = C.g_random_int()

	var goret uint32

	goret = uint32(cret)

	return goret
}

// RandomIntRange wraps g_random_int_range
// 
// The function takes the following parameters:
// 
// 	- begin int32: lower closed bound of the interval 
// 	- end int32: upper open bound of the interval 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns a random #gint32 equally distributed over the range
// [@begin..@end-1].
func RandomIntRange(begin int32, end int32) int32 {
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_random_int_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// RandomSetSeed wraps g_random_set_seed
// 
// The function takes the following parameters:
// 
// 	- seed uint32: a value to reinitialize the global random number generator 
//
// Sets the seed for the global random number generator, which is used
// by the g_random_* functions, to @seed.
func RandomSetSeed(seed uint32) {
	var carg1 C.guint32 // in, none, casted

	carg1 = C.guint32(seed)

	C.g_random_set_seed(carg1)
	runtime.KeepAlive(seed)
}

// RefCountCompare wraps g_ref_count_compare
// 
// The function takes the following parameters:
// 
// 	- rc *int32: the address of a reference count variable 
// 	- val int32: the value to compare 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Compares the current value of @rc with @val.
func RefCountCompare(rc *int32, val int32) bool {
	var carg1 *C.grefcount // in, transfer: none, C Pointers: 1, Name: gint
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	_ = rc
	_ = carg1
	panic("unimplemented conversion of *int32 (grefcount*) because of no basic converter found")
	carg2 = C.gint(val)

	cret = C.g_ref_count_compare(carg1, carg2)
	runtime.KeepAlive(rc)
	runtime.KeepAlive(val)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RefCountInit wraps g_ref_count_init
// 
// The function returns the following values:
// 
// 	- rc int32: the address of a reference count variable 
//
// Initializes a reference count variable to 1.
func RefCountInit() int32 {
	var carg1 C.grefcount // out, full, casted

	C.g_ref_count_init(&carg1)

	var rc int32

	rc = int32(carg1)

	return rc
}

// RefStringAcquire wraps g_ref_string_acquire
// 
// The function takes the following parameters:
// 
// 	- str string: a reference counted string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Acquires a reference on a string.
func RefStringAcquire(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_acquire(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringLength wraps g_ref_string_length
// 
// The function takes the following parameters:
// 
// 	- str string: a reference counted string 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Retrieves the length of @str.
func RefStringLength(str string) uint {
	var carg1 *C.char // in, none, string
	var cret  C.gsize // return, none, casted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_length(carg1)
	runtime.KeepAlive(str)

	var goret uint

	goret = uint(cret)

	return goret
}

// NewRefString wraps g_ref_string_new
// 
// The function takes the following parameters:
// 
// 	- str string: a NUL-terminated string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a new reference counted string and copies the contents of @str
// into it.
func NewRefString(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_new(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringNewIntern wraps g_ref_string_new_intern
// 
// The function takes the following parameters:
// 
// 	- str string: a NUL-terminated string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a new reference counted string and copies the content of @str
// into it.
// 
// If you call this function multiple times with the same @str, or with
// the same contents of @str, it will return a new reference, instead of
// creating a new string.
func RefStringNewIntern(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_new_intern(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringNewLen wraps g_ref_string_new_len
// 
// The function takes the following parameters:
// 
// 	- str string: a string 
// 	- len int: length of @str to use, or -1 if @str is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a new reference counted string and copies the contents of @str
// into it, up to @len bytes.
// 
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @str has at least @len addressable bytes.
func RefStringNewLen(str string, len int) string {
	var carg1 *C.char  // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.char  // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ref_string_new_len(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringRelease wraps g_ref_string_release
// 
// The function takes the following parameters:
// 
// 	- str string: a reference counted string 
//
// Releases a reference on a string; if it was the last reference, the
// resources allocated by the string are freed as well.
func RefStringRelease(str string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_ref_string_release(carg1)
	runtime.KeepAlive(str)
}

// ReloadUserSpecialDirsCache wraps g_reload_user_special_dirs_cache
//
// Resets the cache used for g_get_user_special_dir(), so
// that the latest on-disk version is used. Call this only
// if you just changed the data on disk yourself.
// 
// Due to thread safety issues this may cause leaking of strings
// that were previously returned from g_get_user_special_dir()
// that can't be freed. We ensure to only leak the data for
// the directories that actually changed value though.
func ReloadUserSpecialDirsCache() {

	C.g_reload_user_special_dirs_cache()
}

// SetApplicationName wraps g_set_application_name
// 
// The function takes the following parameters:
// 
// 	- applicationName string: localized name of the application 
//
// Sets a human-readable name for the application. This name should be
// localized if possible, and is intended for display to the user.
// Contrast with g_set_prgname(), which sets a non-localized name.
// g_set_prgname() will be called automatically by gtk_init(),
// but g_set_application_name() will not.
// 
// Note that for thread safety reasons, this function can only
// be called once.
// 
// The application name will be used in contexts such as error messages,
// or when displaying an application's name in the task list.
func SetApplicationName(applicationName string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_set_application_name(carg1)
	runtime.KeepAlive(applicationName)
}

// SetErrorLiteral wraps g_set_error_literal
// 
// The function takes the following parameters:
// 
// 	- domain Quark: error domain 
// 	- code int32: error code 
// 	- message string: error message 
// 
// The function returns the following values:
// 
// 	- err error: a return location for a #GError 
//
// Does nothing if @err is %NULL; if @err is non-%NULL, then `*err`
// must be %NULL. A new #GError is created and assigned to `*err`.
// Unlike g_set_error(), @message is not a printf()-style format string.
// Use this function if @message contains text you don't have control over,
// that could include printf() escape sequences.
func SetErrorLiteral(domain Quark, code int32, message string) error {
	var carg2 C.GQuark  // in, none, casted, alias
	var carg3 C.gint    // in, none, casted
	var carg4 *C.gchar  // in, none, string
	var carg1 *C.GError // out, full, converted

	carg2 = C.GQuark(domain)
	carg3 = C.gint(code)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_set_error_literal(&carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)

	var err error

	err = UnsafeErrorFromGlibFull(unsafe.Pointer(carg1))

	return err
}

// SetPrgname wraps g_set_prgname
// 
// The function takes the following parameters:
// 
// 	- prgname string: the name of the program. 
//
// Sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
// 
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK it is set in
// gdk_init(), which is called by gtk_init() and the
// #GtkApplication::startup handler. By default, the program name is
// found by taking the last component of @argv[0].
// 
// Since GLib 2.72, this function can be called multiple times
// and is fully thread safe. Prior to GLib 2.72, this function
// could only be called once per process.
// 
// See the [GTK documentation](https://docs.gtk.org/gtk4/migrating-3to4.html#set-a-proper-application-id)
// for requirements on integrating g_set_prgname() with GTK applications.
func SetPrgname(prgname string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_set_prgname(carg1)
	runtime.KeepAlive(prgname)
}

// Setenv wraps g_setenv
// 
// The function takes the following parameters:
// 
// 	- variable string: the environment variable to set, must not
//     contain '='. 
// 	- value string: the value for to set the variable to. 
// 	- overwrite bool: whether to change the variable if it already exists. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets an environment variable. On UNIX, both the variable's name and
// value can be arbitrary byte strings, except that the variable's name
// cannot contain '='. On Windows, they should be in UTF-8.
// 
// Note that on some systems, when variables are overwritten, the memory
// used for the previous variables and its value isn't reclaimed.
// 
// You should be mindful of the fact that environment variable handling
// in UNIX is not thread-safe, and your program may crash if one thread
// calls g_setenv() while another thread is calling getenv(). (And note
// that many functions, such as gettext(), call getenv() internally.)
// This function is only safe to use at the very start of your program,
// before creating any other threads (or creating objects that create
// worker threads of their own).
// 
// If you need to set up the environment for a child process, you can
// use g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that
// array directly to execvpe(), g_spawn_async(), or the like.
func Setenv(variable string, value string, overwrite bool) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var carg3 C.gboolean // in
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	if overwrite {
		carg3 = C.TRUE
	}

	cret = C.g_setenv(carg1, carg2, carg3)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ShellErrorQuark wraps g_shell_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func ShellErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_shell_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ShellParseArgv wraps g_shell_parse_argv
// 
// The function takes the following parameters:
// 
// 	- commandLine string: command line to parse 
// 
// The function returns the following values:
// 
// 	- argcp int32: return location for number of args 
// 	- argvp []string: 
//   return location for array of args 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Parses a command line into an argument vector, in much the same way
// the shell would, but without many of the expansions the shell would
// perform (variable expansion, globs, operators, filename expansion,
// etc. are not supported).
// 
// The results are defined to be the same as those you would get from
// a UNIX98 `/bin/sh`, as long as the input contains none of the
// unsupported shell expansions. If the input does contain such expansions,
// they are passed through literally.
// 
// Possible errors are those from the %G_SHELL_ERROR domain.
// 
// In particular, if @command_line is an empty string (or a string containing
// only whitespace), %G_SHELL_ERROR_EMPTY_STRING will be returned. It&#x2019;s
// guaranteed that @argvp will be a non-empty array if this function returns
// successfully.
// 
// Free the returned vector with g_strfreev().
func ShellParseArgv(commandLine string) ([]string, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gint     // implicit
	var carg3 **C.gchar  // out, transfer: full, C Pointers: 2, Name: array[filename], optional, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg2)
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_parse_argv(carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(commandLine)

	var argvp  []string
	var goret  bool
	var _goerr error

	_ = argvp
	_ = carg3
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return argvp, goret, _goerr
}

// ShellQuote wraps g_shell_quote
// 
// The function takes the following parameters:
// 
// 	- unquotedString string: a literal string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Quotes a string so that the shell (/bin/sh) will interpret the
// quoted string to mean @unquoted_string.
// 
// If you pass a filename to the shell, for example, you should first
// quote it with this function.
// 
// The return value must be freed with g_free().
// 
// The quoting style used is undefined (single or double quotes may be
// used).
func ShellQuote(unquotedString string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(unquotedString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_quote(carg1)
	runtime.KeepAlive(unquotedString)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ShellUnquote wraps g_shell_unquote
// 
// The function takes the following parameters:
// 
// 	- quotedString string: shell-quoted string 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Unquotes a string as the shell (/bin/sh) would.
// 
// This function only handles quotes; if a string contains file globs,
// arithmetic operators, variables, backticks, redirections, or other
// special-to-the-shell features, the result will be different from the
// result a real shell would produce (the variables, backticks, etc.
// will be passed through literally instead of being expanded).
// 
// This function is guaranteed to succeed if applied to the result of
// g_shell_quote(). If it fails, it returns %NULL and sets the
// error.
// 
// The @quoted_string need not actually contain quoted or escaped text;
// g_shell_unquote() simply goes through the string and unquotes/unescapes
// anything that the shell would. Both single and double quotes are
// handled, as are escapes including escaped newlines.
// 
// The return value must be freed with g_free().
// 
// Possible errors are in the %G_SHELL_ERROR domain.
// 
// Shell quoting rules are a bit strange. Single quotes preserve the
// literal string exactly. escape sequences are not allowed; not even
// `\'` - if you want a `'` in the quoted text, you have to do something
// like `'foo'\''bar'`. Double quotes allow `$`, ```, `"`, `\`, and
// newline to be escaped with backslash. Otherwise double quotes
// preserve things literally.
func ShellUnquote(quotedString string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(quotedString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_unquote(carg1, &_cerr)
	runtime.KeepAlive(quotedString)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SliceGetConfig wraps g_slice_get_config
// 
// The function takes the following parameters:
// 
// 	- ckey SliceConfig 
// 
// The function returns the following values:
// 
// 	- goret int64 
func SliceGetConfig(ckey SliceConfig) int64 {
	var carg1 C.GSliceConfig // in, none, casted
	var cret  C.gint64       // return, none, casted

	carg1 = C.GSliceConfig(ckey)

	cret = C.g_slice_get_config(carg1)
	runtime.KeepAlive(ckey)

	var goret int64

	goret = int64(cret)

	return goret
}

// SliceGetConfigState wraps g_slice_get_config_state
// 
// The function takes the following parameters:
// 
// 	- ckey SliceConfig 
// 	- address int64 
// 	- nValues *uint 
// 
// The function returns the following values:
// 
// 	- goret *int64 
func SliceGetConfigState(ckey SliceConfig, address int64, nValues *uint) *int64 {
	var carg1 C.GSliceConfig // in, none, casted
	var carg2 C.gint64       // in, none, casted
	var carg3 *C.guint       // in, transfer: none, C Pointers: 1, Name: guint
	var cret  *C.gint64      // return, transfer: none, C Pointers: 1, Name: gint64, scope: 

	carg1 = C.GSliceConfig(ckey)
	carg2 = C.gint64(address)
	_ = nValues
	_ = carg3
	panic("unimplemented conversion of *uint (guint*) because of no basic converter found")

	cret = C.g_slice_get_config_state(carg1, carg2, carg3)
	runtime.KeepAlive(ckey)
	runtime.KeepAlive(address)
	runtime.KeepAlive(nValues)

	var goret *int64

	_ = goret
	_ = cret
	panic("unimplemented conversion of *int64 (gint64*) because of unknown reason")

	return goret
}

// SliceSetConfig wraps g_slice_set_config
// 
// The function takes the following parameters:
// 
// 	- ckey SliceConfig 
// 	- value int64 
func SliceSetConfig(ckey SliceConfig, value int64) {
	var carg1 C.GSliceConfig // in, none, casted
	var carg2 C.gint64       // in, none, casted

	carg1 = C.GSliceConfig(ckey)
	carg2 = C.gint64(value)

	C.g_slice_set_config(carg1, carg2)
	runtime.KeepAlive(ckey)
	runtime.KeepAlive(value)
}

// SpacedPrimesClosest wraps g_spaced_primes_closest
// 
// The function takes the following parameters:
// 
// 	- num uint: a #guint 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the smallest prime number from a built-in array of primes which
// is larger than @num. This is used within GLib to calculate the optimum
// size of a #GHashTable.
// 
// The built-in array of primes ranges from 11 to 13845163 such that
// each prime is approximately 1.5-2 times the previous prime.
func SpacedPrimesClosest(num uint) uint {
	var carg1 C.guint // in, none, casted
	var cret  C.guint // return, none, casted

	carg1 = C.guint(num)

	cret = C.g_spaced_primes_closest(carg1)
	runtime.KeepAlive(num)

	var goret uint

	goret = uint(cret)

	return goret
}

// SpawnCheckWaitStatus wraps g_spawn_check_wait_status
// 
// The function takes the following parameters:
// 
// 	- waitStatus int32: A platform-specific wait status as returned from g_spawn_sync() 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Set @error if @wait_status indicates the child exited abnormally
// (e.g. with a nonzero exit code, or via a fatal signal).
// 
// The g_spawn_sync() and g_child_watch_add() family of APIs return the
// status of subprocesses encoded in a platform-specific way.
// On Unix, this is guaranteed to be in the same format waitpid() returns,
// and on Windows it is guaranteed to be the result of GetExitCodeProcess().
// 
// Prior to the introduction of this function in GLib 2.34, interpreting
// @wait_status required use of platform-specific APIs, which is problematic
// for software using GLib as a cross-platform layer.
// 
// Additionally, many programs simply want to determine whether or not
// the child exited successfully, and either propagate a #GError or
// print a message to standard error. In that common case, this function
// can be used. Note that the error message in @error will contain
// human-readable information about the wait status.
// 
// The @domain and @code of @error have special semantics in the case
// where the process has an "exit code", as opposed to being killed by
// a signal. On Unix, this happens if WIFEXITED() would be true of
// @wait_status. On Windows, it is always the case.
// 
// The special semantics are that the actual exit code will be the
// code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
// This allows you to differentiate between different exit codes.
// 
// If the process was terminated by some means other than an exit
// status (for example if it was killed by a signal), the domain will be
// %G_SPAWN_ERROR and the code will be %G_SPAWN_ERROR_FAILED.
// 
// This function just offers convenience; you can of course also check
// the available platform via a macro such as %G_OS_UNIX, and use
// WIFEXITED() and WEXITSTATUS() on @wait_status directly. Do not attempt
// to scan or parse the error message string; it may be translated and/or
// change in future versions of GLib.
// 
// Prior to version 2.70, g_spawn_check_exit_status() provides the same
// functionality, although under a misleading name.
func SpawnCheckWaitStatus(waitStatus int32) (bool, error) {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = C.gint(waitStatus)

	cret = C.g_spawn_check_wait_status(carg1, &_cerr)
	runtime.KeepAlive(waitStatus)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpawnClosePid wraps g_spawn_close_pid
// 
// The function takes the following parameters:
// 
// 	- pid Pid: The process reference to close 
//
// On some platforms, notably Windows, the #GPid type represents a resource
// which must be closed to prevent resource leaking. g_spawn_close_pid()
// is provided for this purpose. It should be used on all platforms, even
// though it doesn't do anything under UNIX.
func SpawnClosePid(pid Pid) {
	var carg1 C.GPid // in, none, casted, alias

	carg1 = C.GPid(pid)

	C.g_spawn_close_pid(carg1)
	runtime.KeepAlive(pid)
}

// SpawnCommandLineAsync wraps g_spawn_command_line_async
// 
// The function takes the following parameters:
// 
// 	- commandLine string: a command line 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// A simple version of g_spawn_async() that parses a command line with
// g_shell_parse_argv() and passes it to g_spawn_async().
// 
// Runs a command line in the background. Unlike g_spawn_async(), the
// %G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note
// that %G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_async() directly if appropriate. Possible
// errors are those from g_shell_parse_argv() and g_spawn_async().
// 
// The same concerns on Windows apply as for g_spawn_command_line_sync().
func SpawnCommandLineAsync(commandLine string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_spawn_command_line_async(carg1, &_cerr)
	runtime.KeepAlive(commandLine)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpawnCommandLineSync wraps g_spawn_command_line_sync
// 
// The function takes the following parameters:
// 
// 	- commandLine string: a command line 
// 
// The function returns the following values:
// 
// 	- standardOutput string: return location for child output 
// 	- standardError string: return location for child errors 
// 	- waitStatus int32: return location for child wait status, as returned by waitpid() 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// A simple version of g_spawn_sync() with little-used parameters
// removed, taking a command line instead of an argument vector.
// 
// See g_spawn_sync() for full details.
// 
// The @command_line argument will be parsed by g_shell_parse_argv().
// 
// Unlike g_spawn_sync(), the %G_SPAWN_SEARCH_PATH flag is enabled.
// Note that %G_SPAWN_SEARCH_PATH can have security implications, so
// consider using g_spawn_sync() directly if appropriate.
// 
// Possible errors are those from g_spawn_sync() and those
// from g_shell_parse_argv().
// 
// If @wait_status is non-%NULL, the platform-specific status of
// the child is stored there; see the documentation of
// g_spawn_check_wait_status() for how to use and interpret this.
// On Unix platforms, note that it is usually not equal
// to the integer passed to `exit()` or returned from `main()`.
// 
// On Windows, please note the implications of g_shell_parse_argv()
// parsing @command_line. Parsing is done according to Unix shell rules, not
// Windows command interpreter rules.
// Space is a separator, and backslashes are
// special. Thus you cannot simply pass a @command_line containing
// canonical Windows paths, like "c:\\program files\\app\\app.exe", as
// the backslashes will be eaten, and the space will act as a
// separator. You need to enclose such paths with single quotes, like
// "'c:\\program files\\app\\app.exe' 'e:\\folder\\argument.txt'".
func SpawnCommandLineSync(commandLine string) (string, string, int32, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], optional, array (inner unknown, zero-terminated)
	var carg3 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], optional, array (inner unknown, zero-terminated)
	var carg4 C.gint     // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_spawn_command_line_sync(carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(commandLine)

	var standardOutput string
	var standardError  string
	var waitStatus     int32
	var goret          bool
	var _goerr         error

	_ = standardOutput
	_ = carg2
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	_ = standardError
	_ = carg3
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	waitStatus = int32(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return standardOutput, standardError, waitStatus, goret, _goerr
}

// SpawnErrorQuark wraps g_spawn_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func SpawnErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_spawn_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// SpawnExitErrorQuark wraps g_spawn_exit_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func SpawnExitErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_spawn_exit_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// Stpcpy wraps g_stpcpy
// 
// The function takes the following parameters:
// 
// 	- dest string: destination buffer 
// 	- src string: source string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Copies a nul-terminated string into the destination buffer, including
// the trailing nul byte, and returns a pointer to the trailing nul byte
// in `dest`.  The return value is useful for concatenating multiple
// strings without having to repeatedly scan for the end.
func Stpcpy(dest string, src string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.char  // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_stpcpy(carg1, carg2)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// StrHasPrefix wraps g_str_has_prefix
// 
// The function takes the following parameters:
// 
// 	- str string: a string to look in 
// 	- prefix string: the prefix to look for 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks whether the string @str begins with @prefix.
func StrHasPrefix(str string, prefix string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(prefix)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_str_has_prefix(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(prefix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrHasSuffix wraps g_str_has_suffix
// 
// The function takes the following parameters:
// 
// 	- str string: a string to look in 
// 	- suffix string: the suffix to look for 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks whether a string ends with @suffix.
func StrHasSuffix(str string, suffix string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(suffix)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_str_has_suffix(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(suffix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrIsASCII wraps g_str_is_ascii
// 
// The function takes the following parameters:
// 
// 	- str string: a string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a string is pure ASCII. A string is pure ASCII if it
// contains no bytes with the high bit set.
func StrIsASCII(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_str_is_ascii(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrMatchString wraps g_str_match_string
// 
// The function takes the following parameters:
// 
// 	- searchTerm string: the search term from the user 
// 	- potentialHit string: the text that may be a hit 
// 	- acceptAlternates bool: if true, ASCII alternates are accepted 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if a search conducted for @search_term should match
// @potential_hit.
// 
// This function calls [func@GLib.str_tokenize_and_fold] on both
// @search_term and @potential_hit. ASCII alternates are never taken
// for @search_term but will be taken for @potential_hit according to
// the value of @accept_alternates.
// 
// A hit occurs when each folded token in @search_term is a prefix of a
// folded token from @potential_hit.
// 
// Depending on how you're performing the search, it will typically be
// faster to call `g_str_tokenize_and_fold()` on each string in
// your corpus and build an index on the returned folded tokens, then
// call `g_str_tokenize_and_fold()` on the search term and
// perform lookups into that index.
// 
// As some examples, searching for &#x2018;fred&#x2019; would match the potential hit
// &#x2018;Smith, Fred&#x2019; and also &#x2018;Fr&#xE9;d&#xE9;ric&#x2019;.  Searching for &#x2018;Fr&#xE9;d&#x2019; would match
// &#x2018;Fr&#xE9;d&#xE9;ric&#x2019; but not &#x2018;Frederic&#x2019; (due to the one-directional nature of
// accent matching).  Searching &#x2018;fo&#x2019; would match &#x2018;Foo&#x2019; and &#x2018;Bar Foo
// Baz&#x2019;, but not &#x2018;SFO&#x2019; (because no word has &#x2018;fo&#x2019; as a prefix).
func StrMatchString(searchTerm string, potentialHit string, acceptAlternates bool) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var carg3 C.gboolean // in
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(searchTerm)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(potentialHit)))
	defer C.free(unsafe.Pointer(carg2))
	if acceptAlternates {
		carg3 = C.TRUE
	}

	cret = C.g_str_match_string(carg1, carg2, carg3)
	runtime.KeepAlive(searchTerm)
	runtime.KeepAlive(potentialHit)
	runtime.KeepAlive(acceptAlternates)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrToASCII wraps g_str_to_ascii
// 
// The function takes the following parameters:
// 
// 	- str string: a string, in UTF-8 
// 	- fromLocale string (nullable): the source locale, if known 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Transliterate @str to plain ASCII.
// 
// For best results, @str should be in composed normalised form.
// 
// This function performs a reasonably good set of character
// replacements.  The particular set of replacements that is done may
// change by version or even by runtime environment.
// 
// If the source language of @str is known, it can used to improve the
// accuracy of the translation by passing it as @from_locale.  It should
// be a valid POSIX locale string (of the form
// `language[_territory][.codeset][@modifier]`).
// 
// If @from_locale is %NULL then the current locale is used.
// 
// If you want to do translation for no specific locale, and you want it
// to be done independently of the currently locale, specify `"C"` for
// @from_locale.
func StrToASCII(str string, fromLocale string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if fromLocale != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(fromLocale)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_str_to_ascii(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(fromLocale)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strcanon wraps g_strcanon
// 
// The function takes the following parameters:
// 
// 	- str string: a nul-terminated array of bytes 
// 	- validChars string: bytes permitted in @string 
// 	- substitutor byte: replacement character for disallowed bytes 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// For each character in @string, if the character is not in @valid_chars,
// replaces the character with @substitutor.
// 
// Modifies @string in place, and return @string itself, not a copy. The
// return value is to allow nesting such as:
// ```C
// g_ascii_strup (g_strcanon (str, "abc", '?'))
// ```
// 
// In order to modify a copy, you may use [func@GLib.strdup]:
// ```C
// reformatted = g_strcanon (g_strdup (const_str), "abc", '?');
// &#x2026;
// g_free (reformatted);
// ```
func Strcanon(str string, validChars string, substitutor byte) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(validChars)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gchar(substitutor)

	cret = C.g_strcanon(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(validChars)
	runtime.KeepAlive(substitutor)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strchomp wraps g_strchomp
// 
// The function takes the following parameters:
// 
// 	- str string: a string to remove the trailing whitespace from 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Removes trailing whitespace from a string.
// 
// This function doesn't allocate or reallocate any memory;
// it modifies @string in place. Therefore, it cannot be used
// on statically allocated strings.
// 
// The pointer to @string is returned to allow the nesting of functions.
// 
// Also see [func@GLib.strchug] and [func@GLib.strstrip].
func Strchomp(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strchomp(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strchug wraps g_strchug
// 
// The function takes the following parameters:
// 
// 	- str string: a string to remove the leading whitespace from 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Removes leading whitespace from a string, by moving the rest
// of the characters forward.
// 
// This function doesn't allocate or reallocate any memory;
// it modifies @string in place. Therefore, it cannot be used on
// statically allocated strings.
// 
// The pointer to @string is returned to allow the nesting of functions.
// 
// Also see [func@GLib.strchomp] and [func@GLib.strstrip].
func Strchug(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strchug(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strcmp0 wraps g_strcmp0
// 
// The function takes the following parameters:
// 
// 	- str1 string (nullable): a string 
// 	- str2 string (nullable): another string 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compares @str1 and @str2 like `strcmp()`.
// 
// Handles `NULL` gracefully by sorting it before non-`NULL` strings.
// Comparing two `NULL` pointers returns 0.
func Strcmp0(str1 string, str2 string) int32 {
	var carg1 *C.char // in, none, string, nullable-string
	var carg2 *C.char // in, none, string, nullable-string
	var cret  C.int   // return, none, casted

	if str1 != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(str1)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if str2 != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(str2)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_strcmp0(carg1, carg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var goret int32

	goret = int32(cret)

	return goret
}

// Strcompress wraps g_strcompress
// 
// The function takes the following parameters:
// 
// 	- source string: a string to compress 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Makes a copy of a string replacing C string-style escape
// sequences with their one byte equivalent:
// 
// - `\b` &#x2192; [U+0008 Backspace](https://en.wikipedia.org/wiki/Backspace)
// - `\f` &#x2192; [U+000C Form Feed](https://en.wikipedia.org/wiki/Form_feed)
// - `\n` &#x2192; [U+000A Line Feed](https://en.wikipedia.org/wiki/Newline)
// - `\r` &#x2192; [U+000D Carriage Return](https://en.wikipedia.org/wiki/Carriage_return)
// - `\t` &#x2192; [U+0009 Horizontal Tabulation](https://en.wikipedia.org/wiki/Tab_character)
// - `\v` &#x2192; [U+000B Vertical Tabulation](https://en.wikipedia.org/wiki/Vertical_Tab)
// - `\` followed by one to three octal digits &#x2192; the numeric value (mod 255)
// - `\` followed by any other character &#x2192; the character as is.
//   For example, `\\` will turn into a backslash (`\`) and `\"` into a double quote (`"`).
// 
// [func@GLib.strescape] does the reverse conversion.
func Strcompress(source string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strcompress(carg1)
	runtime.KeepAlive(source)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdelimit wraps g_strdelimit
// 
// The function takes the following parameters:
// 
// 	- str string: the string to convert 
// 	- delimiters string (nullable): a string containing the current delimiters, or
//   `NULL` to use the standard delimiters defined in [const@GLib.STR_DELIMITERS] 
// 	- newDelimiter byte: the new delimiter character 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts any delimiter characters in @string to @new_delimiter.
// 
// Any characters in @string which are found in @delimiters are
// changed to the @new_delimiter character. Modifies @string in place,
// and returns @string itself, not a copy.
// 
// The return value is to allow nesting such as:
// ```C
// g_ascii_strup (g_strdelimit (str, "abc", '?'))
// ```
// 
// In order to modify a copy, you may use [func@GLib.strdup]:
// ```C
// reformatted = g_strdelimit (g_strdup (const_str), "abc", '?');
// &#x2026;
// g_free (reformatted);
// ```
func Strdelimit(str string, delimiters string, newDelimiter byte) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var carg3 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if delimiters != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiters)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = C.gchar(newDelimiter)

	cret = C.g_strdelimit(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiters)
	runtime.KeepAlive(newDelimiter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdup wraps g_strdup
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): the string to duplicate 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Duplicates a string. If @str is `NULL` it returns `NULL`.
func Strdup(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_strdup(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdupv wraps g_strdupv
// 
// The function takes the following parameters:
// 
// 	- strArray []string (nullable): an array of strings to copy 
// 
// The function returns the following values:
// 
// 	- goret []string (nullable) 
//
// Copies an array of strings. The copy is a deep copy; each string is also
// copied.
// 
// If called on a `NULL` value, `g_strdupv()` simply returns `NULL`.
func Strdupv(strArray []string) []string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strdupv(carg1)
	runtime.KeepAlive(strArray)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// Strerror wraps g_strerror
// 
// The function takes the following parameters:
// 
// 	- errnum int32: the system error number. See the standard C `errno` documentation 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a string corresponding to the given error code, e.g. "no
// such process".
// 
// Unlike `strerror()`, this always returns a string in
// UTF-8 encoding, and the pointer is guaranteed to remain valid for
// the lifetime of the process. If the error code is unknown, it returns a
// string like &#x201C;Unknown error &lt;code\&gt;&#x201D;.
// 
// Note that the string may be translated according to the current locale.
// 
// The value of `errno` will not be changed by this function. However, it may
// be changed by intermediate function calls, so you should save its value
// as soon as the call returns:
// ```C
// int saved_errno;
// 
// ret = read (blah);
// saved_errno = errno;
// 
// g_strerror (saved_errno);
// ```
func Strerror(errnum int32) string {
	var carg1 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = C.gint(errnum)

	cret = C.g_strerror(carg1)
	runtime.KeepAlive(errnum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strescape wraps g_strescape
// 
// The function takes the following parameters:
// 
// 	- source string: a string to escape 
// 	- exceptions string (nullable): a string of characters not to escape in @source 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// It replaces the following special characters in the string @source
// with their corresponding C escape sequence:
// 
// | Symbol                                                                      | Escape |
// |-----------------------------------------------------------------------------|--------|
// | [U+0008 Backspace](https://en.wikipedia.org/wiki/Backspace)                 | `\b`   |
// | [U+000C Form Feed](https://en.wikipedia.org/wiki/Form_feed)                 | `\f`   |
// | [U+000A Line Feed](https://en.wikipedia.org/wiki/Newline)                   | `\n`   |
// | [U+000D Carriage Return](https://en.wikipedia.org/wiki/Carriage_return)     | `\r`   |
// | [U+0009 Horizontal Tabulation](https://en.wikipedia.org/wiki/Tab_character) | `\t`   |
// | [U+000B Vertical Tabulation](https://en.wikipedia.org/wiki/Vertical_Tab)    | `\v`   |
// 
// It also inserts a backslash (`\`) before any backslash or a double quote (`"`).
// Additionally all characters in the range 0x01-0x1F (everything
// below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are
// replaced with a backslash followed by their octal representation.
// Characters supplied in @exceptions are not escaped.
// 
// [func@GLib.strcompress] does the reverse conversion.
func Strescape(source string, exceptions string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))
	if exceptions != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(exceptions)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_strescape(carg1, carg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(exceptions)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strfreev wraps g_strfreev
// 
// The function takes the following parameters:
// 
// 	- strArray []string (nullable): an
//   array of strings to free 
//
// Frees an array of strings, as well as each string it contains.
// 
// If @str_array is `NULL`, this function simply returns.
func Strfreev(strArray []string) {
	var carg1 **C.gchar // in, transfer: full, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	C.g_strfreev(carg1)
	runtime.KeepAlive(strArray)
}

// StripContext wraps g_strip_context
// 
// The function takes the following parameters:
// 
// 	- msgid string: a string 
// 	- msgval string: another string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// An auxiliary function for gettext() support (see Q_()).
func StripContext(msgid string, msgval string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgval)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strip_context(carg1, carg2)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgval)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strjoinv wraps g_strjoinv
// 
// The function takes the following parameters:
// 
// 	- separator string (nullable): a string to insert between each of the strings 
// 	- strArray []string: an array of strings to join 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Joins an array of strings together to form one long string, with the
// optional @separator inserted between each of them.
// 
// If @str_array has no items, the return value will be an
// empty string. If @str_array contains a single item, @separator will not
// appear in the resulting string.
func Strjoinv(separator string, strArray []string) string {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var carg2 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	if separator != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(separator)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = strArray
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strjoinv(carg1, carg2)
	runtime.KeepAlive(separator)
	runtime.KeepAlive(strArray)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strlcat wraps g_strlcat
// 
// The function takes the following parameters:
// 
// 	- dest string: destination buffer, already containing one nul-terminated string 
// 	- src string: source buffer 
// 	- destSize uint: length of @dest buffer in bytes (not length of existing string
//   inside @dest) 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Portability wrapper that calls `strlcat()` on systems which have it,
// and emulates it otherwise. Appends nul-terminated @src string to @dest,
// guaranteeing nul-termination for @dest. The total size of @dest won't
// exceed @dest_size.
// 
// At most @dest_size - 1 characters will be copied. Unlike `strncat()`,
// @dest_size is the full size of dest, not the space left over. This
// function does not allocate memory. It always nul-terminates (unless
// @dest_size == 0 or there were no nul characters in the @dest_size
// characters of dest to start with).
// 
// Caveat: this is supposedly a more secure alternative to `strcat()` or
// `strncat()`, but for real security [func@GLib.strconcat] is harder to mess up.
func Strlcat(dest string, src string, destSize uint) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(destSize)

	cret = C.g_strlcat(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destSize)

	var goret uint

	goret = uint(cret)

	return goret
}

// Strlcpy wraps g_strlcpy
// 
// The function takes the following parameters:
// 
// 	- dest string: destination buffer 
// 	- src string: source buffer 
// 	- destSize uint: length of @dest in bytes 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Portability wrapper that calls `strlcpy()` on systems which have it,
// and emulates `strlcpy()` otherwise. Copies @src to @dest; @dest is
// guaranteed to be nul-terminated; @src must be nul-terminated;
// @dest_size is the buffer size, not the number of bytes to copy.
// 
// At most @dest_size - 1 characters will be copied. Always nul-terminates
// (unless @dest_size is 0). This function does not allocate memory. Unlike
// `strncpy()`, this function doesn't pad @dest (so it's often faster). It
// returns the size of the attempted result, `strlen (src)`, so if
// @retval &gt;= @dest_size, truncation occurred.
// 
// Caveat: `strlcpy()` is supposedly more secure than `strcpy()` or `strncpy()`,
// but if you really want to avoid screwups, [func@GLib.strdup] is an even better
// idea.
func Strlcpy(dest string, src string, destSize uint) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(destSize)

	cret = C.g_strlcpy(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destSize)

	var goret uint

	goret = uint(cret)

	return goret
}

// Strndup wraps g_strndup
// 
// The function takes the following parameters:
// 
// 	- str string (nullable): the string to duplicate 
// 	- n uint: the maximum number of bytes to copy from @str 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Duplicates the first @n bytes of a string, returning a newly-allocated
// buffer @n + 1 bytes long which will always be nul-terminated. If @str
// is less than @n bytes long the buffer is padded with nuls. If @str is
// `NULL` it returns `NULL`.
// 
// To copy a number of characters from a UTF-8 encoded string,
// use [func@GLib.utf8_strncpy] instead.
func Strndup(str string, n uint) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 C.gsize  // in, none, casted
	var cret  *C.gchar // return, full, string, nullable-string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.gsize(n)

	cret = C.g_strndup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(n)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Strnfill wraps g_strnfill
// 
// The function takes the following parameters:
// 
// 	- length uint: the length of the new string 
// 	- fillChar byte: the byte to fill the string with 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Creates a new string @length bytes long filled with @fill_char.
func Strnfill(length uint, fillChar byte) string {
	var carg1 C.gsize  // in, none, casted
	var carg2 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.gsize(length)
	carg2 = C.gchar(fillChar)

	cret = C.g_strnfill(carg1, carg2)
	runtime.KeepAlive(length)
	runtime.KeepAlive(fillChar)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strreverse wraps g_strreverse
// 
// The function takes the following parameters:
// 
// 	- str string: the string to reverse 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Reverses all of the bytes in a string. For example,
// `g_strreverse ("abcdef")` will result in "fedcba".
// 
// Note that `g_strreverse()` doesn't work on UTF-8 strings
// containing multibyte characters. For that purpose, use
// [func@GLib.utf8_strreverse].
func Strreverse(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strreverse(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strrstr wraps g_strrstr
// 
// The function takes the following parameters:
// 
// 	- haystack string: a string to search in 
// 	- needle string: the string to search for 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Searches the string @haystack for the last occurrence
// of the string @needle.
// 
// The fact that this function returns `gchar *` rather than `const gchar *` is
// a historical artifact.
func Strrstr(haystack string, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strrstr(carg1, carg2)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// StrrstrLen wraps g_strrstr_len
// 
// The function takes the following parameters:
// 
// 	- haystack string: a string to search in 
// 	- haystackLen int: the maximum length of @haystack in bytes. A length of `-1`
//   can be used to mean "search the entire string", like [func@GLib.strrstr] 
// 	- needle string: the string to search for 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Searches the string @haystack for the last occurrence
// of the string @needle, limiting the length of the search
// to @haystack_len.
// 
// The fact that this function returns `gchar *` rather than `const gchar *` is
// a historical artifact.
func StrrstrLen(haystack string, haystackLen int, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(haystackLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_strrstr_len(carg1, carg2, carg3)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(haystackLen)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Strsignal wraps g_strsignal
// 
// The function takes the following parameters:
// 
// 	- signum int32: the signal number. See the `signal` documentation 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a string describing the given signal, e.g. "Segmentation fault".
// If the signal is unknown, it returns &#x201C;unknown signal (&lt;signum\&gt;)&#x201D;.
// 
// You should use this function in preference to `strsignal()`, because it
// returns a string in UTF-8 encoding, and since not all platforms support
// the `strsignal()` function.
func Strsignal(signum int32) string {
	var carg1 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = C.gint(signum)

	cret = C.g_strsignal(carg1)
	runtime.KeepAlive(signum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strsplit wraps g_strsplit
// 
// The function takes the following parameters:
// 
// 	- str string: a string to split 
// 	- delimiter string: a string which specifies the places at which to split
//   the string. The delimiter is not included in any of the resulting
//   strings, unless @max_tokens is reached. 
// 	- maxTokens int32: the maximum number of pieces to split @string into
//   If this is less than 1, the string is split completely 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Splits a string into a maximum of @max_tokens pieces, using the given
// @delimiter. If @max_tokens is reached, the remainder of @string is
// appended to the last token.
// 
// As an example, the result of `g_strsplit (":a:bc::d:", ":", -1)` is an array
// containing the six strings "", "a", "bc", "", "d" and "".
// 
// As a special case, the result of splitting the empty string "" is an empty
// array, not an array containing a single string. The reason for this
// special case is that being able to represent an empty array is typically
// more useful than consistent handling of empty elements. If you do need
// to represent empty elements, you'll need to check for the empty string
// before calling `g_strsplit()`.
func Strsplit(str string, delimiter string, maxTokens int32) []string {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string
	var carg3 C.gint    // in, none, casted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiter)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(maxTokens)

	cret = C.g_strsplit(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiter)
	runtime.KeepAlive(maxTokens)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// StrsplitSet wraps g_strsplit_set
// 
// The function takes the following parameters:
// 
// 	- str string: a string to split 
// 	- delimiters string: a string containing characters that are used to split the
//   string. Can be empty, which will result in no string splitting 
// 	- maxTokens int32: the maximum number of tokens to split @string into.
//   If this is less than 1, the string is split completely 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Splits @string into a number of tokens not containing any of the characters
// in @delimiters. A token is the (possibly empty) longest string that does not
// contain any of the characters in @delimiters. If @max_tokens is reached, the
// remainder is appended to the last token.
// 
// For example, the result of g_strsplit_set ("abc:def/ghi", ":/", -1) is an
// array containing the three strings "abc", "def", and "ghi".
// 
// The result of g_strsplit_set (":def/ghi:", ":/", -1) is an array containing
// the four strings "", "def", "ghi", and "".
// 
// As a special case, the result of splitting the empty string "" is an empty
// array, not an array containing a single string. The reason for this
// special case is that being able to represent an empty array is typically
// more useful than consistent handling of empty elements. If you do need
// to represent empty elements, you'll need to check for the empty string
// before calling `g_strsplit_set()`.
// 
// Note that this function works on bytes not characters, so it can't be used
// to delimit UTF-8 strings for anything but ASCII characters.
func StrsplitSet(str string, delimiters string, maxTokens int32) []string {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string
	var carg3 C.gint    // in, none, casted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiters)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(maxTokens)

	cret = C.g_strsplit_set(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiters)
	runtime.KeepAlive(maxTokens)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// StrstrLen wraps g_strstr_len
// 
// The function takes the following parameters:
// 
// 	- haystack string: a string to search in 
// 	- haystackLen int: the maximum length of @haystack in bytes, or `-1` to
//   search it entirely 
// 	- needle string: the string to search for 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Searches the string @haystack for the first occurrence
// of the string @needle, limiting the length of the search
// to @haystack_len or a nul terminator byte (whichever is reached first).
// 
// A length of `-1` can be used to mean &#x201C;search the entire string&#x201D;, like
// `strstr()`.
// 
// The fact that this function returns `gchar *` rather than `const gchar *` is
// a historical artifact.
func StrstrLen(haystack string, haystackLen int, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(haystackLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_strstr_len(carg1, carg2, carg3)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(haystackLen)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Strtod wraps g_strtod
// 
// The function takes the following parameters:
// 
// 	- nptr string: the string to convert to a numeric value 
// 
// The function returns the following values:
// 
// 	- endptr string: if non-`NULL`, it returns the
//   character after the last character used in the conversion 
// 	- goret float64 
//
// Converts a string to a floating point value.
// 
// It calls the standard `strtod()` function to handle the conversion, but
// if the string is not completely converted it attempts the conversion
// again with [func@GLib.ascii_strtod], and returns the best match.
// 
// This function should seldom be used. The normal situation when reading
// numbers not for human consumption is to use [func@GLib.ascii_strtod]. Only when
// you know that you must expect both locale formatted and C formatted numbers
// should you use this. Make sure that you don't pass strings such as comma
// separated lists of values, since the commas may be interpreted as a decimal
// point in some locales, causing unexpected results.
func Strtod(nptr string) (string, float64) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, none, string
	var cret  C.gdouble // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strtod(carg1, &carg2)
	runtime.KeepAlive(nptr)

	var endptr string
	var goret  float64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = float64(cret)

	return endptr, goret
}

// StrvContains wraps g_strv_contains
// 
// The function takes the following parameters:
// 
// 	- strv []string: an array of strings to search in 
// 	- str string: the string to search for 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if an array of strings contains the string @str according to
// [func@GLib.str_equal]. @strv must not be `NULL`.
func StrvContains(strv []string, str string) bool {
	var carg1 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	_ = strv
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strv_contains(carg1, carg2)
	runtime.KeepAlive(strv)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrvEqual wraps g_strv_equal
// 
// The function takes the following parameters:
// 
// 	- strv1 []string: an array of strings to compare to @strv2 
// 	- strv2 []string: an array of strings to compare to @strv1 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if two arrays of strings contain exactly the same elements in
// exactly the same order.
// 
// Elements are compared using [func@GLib.str_equal]. To match independently
// of order, sort the arrays first (using [func@GLib.qsort_with_data]
// or similar).
// 
// Two empty arrays are considered equal. Neither @strv1 nor @strv2 may be
// `NULL`.
func StrvEqual(strv1 []string, strv2 []string) bool {
	var carg1 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.gboolean // return

	_ = strv1
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")
	_ = strv2
	_ = carg2
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_strv_equal(carg1, carg2)
	runtime.KeepAlive(strv1)
	runtime.KeepAlive(strv2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrvLength wraps g_strv_length
// 
// The function takes the following parameters:
// 
// 	- strArray []string: an array of strings 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the length of an array of strings. @str_array must not be `NULL`.
func StrvLength(strArray []string) uint {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.guint   // return, none, casted

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strv_length(carg1)
	runtime.KeepAlive(strArray)

	var goret uint

	goret = uint(cret)

	return goret
}

// TestAssertExpectedMessagesInternal wraps g_test_assert_expected_messages_internal
// 
// The function takes the following parameters:
// 
// 	- domain string 
// 	- file string 
// 	- line int32 
// 	- fn string 
func TestAssertExpectedMessagesInternal(domain string, file string, line int32, fn string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_test_assert_expected_messages_internal(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
}

// TestBug wraps g_test_bug
// 
// The function takes the following parameters:
// 
// 	- bugUriSnippet string: Bug specific bug tracker URI or URI portion. 
//
// Adds a message to test reports that associates a bug URI with a test case.
// 
// Bug URIs are constructed from a base URI set with [func@GLib.test_bug_base]
// and @bug_uri_snippet. If [func@GLib.test_bug_base] has not been called, it is
// assumed to be the empty string, so a full URI can be provided to
// [func@GLib.test_bug] instead.
// 
// See also [func@GLib.test_summary].
// 
// Since GLib 2.70, the base URI is not prepended to @bug_uri_snippet
// if it is already a valid URI.
func TestBug(bugUriSnippet string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(bugUriSnippet)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_bug(carg1)
	runtime.KeepAlive(bugUriSnippet)
}

// TestBugBase wraps g_test_bug_base
// 
// The function takes the following parameters:
// 
// 	- uriPattern string: the base pattern for bug URIs 
//
// Specifies the base URI for bug reports.
// 
// The base URI is used to construct bug report messages for
// [func@GLib.test_message] when [func@GLib.test_bug] is called.
// Calling this function outside of a test case sets the
// default base URI for all test cases. Calling it from within
// a test case changes the base URI for the scope of the test
// case only.
// Bug URIs are constructed by appending a bug specific URI
// portion to @uri_pattern, or by replacing the special string
// `%s` within @uri_pattern if that is present.
// 
// If [func@GLib.test_bug_base] is not called, bug URIs are formed
// solely from the value provided by [func@GLib.test_bug].
func TestBugBase(uriPattern string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriPattern)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_bug_base(carg1)
	runtime.KeepAlive(uriPattern)
}

// TestDisableCrashReporting wraps g_test_disable_crash_reporting
//
// Attempts to disable system crash reporting infrastructure.
// 
// This function should be called before exercising code paths that are
// expected or intended to crash, to avoid wasting resources in system-wide
// crash collection infrastructure such as systemd-coredump or abrt.
func TestDisableCrashReporting() {

	C.g_test_disable_crash_reporting()
}

// TestExpectMessage wraps g_test_expect_message
// 
// The function takes the following parameters:
// 
// 	- logDomain string (nullable): the log domain of the message 
// 	- logLevel LogLevelFlags: the log level of the message 
// 	- pattern string: a glob-style pattern (see [type@GLib.PatternSpec]) 
//
// Indicates that a message with the given @log_domain and @log_level,
// with text matching @pattern, is expected to be logged.
// 
// When this message is logged, it will not be printed, and the test case will
// not abort.
// 
// This API may only be used with the old logging API ([func@GLib.log] without
// `G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging
// API. See [Testing for Messages](logging.html#testing-for-messages).
// 
// Use [func@GLib.test_assert_expected_messages] to assert that all
// previously-expected messages have been seen and suppressed.
// 
// You can call this multiple times in a row, if multiple messages are
// expected as a result of a single call. (The messages must appear in
// the same order as the calls to [func@GLib.test_expect_message].)
// 
// For example:
// 
// ```c
// // g_main_context_push_thread_default() should fail if the
// // context is already owned by another thread.
// g_test_expect_message (G_LOG_DOMAIN,
//                        G_LOG_LEVEL_CRITICAL,
//                        "assertion*acquired_context*failed");
// g_main_context_push_thread_default (bad_context);
// g_test_assert_expected_messages ();
// ```
// 
// Note that you cannot use this to test [func@GLib.error] messages, since
// [func@GLib.error] intentionally never returns even if the program doesn&#x2019;t
// abort; use [func@GLib.test_trap_subprocess] in this case.
// 
// If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly
// expected via [func@GLib.test_expect_message] then they will be ignored.
func TestExpectMessage(logDomain string, logLevel LogLevelFlags, pattern string) {
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 C.GLogLevelFlags // in, none, casted
	var carg3 *C.gchar         // in, none, string

	if logDomain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GLogLevelFlags(logLevel)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_test_expect_message(carg1, carg2, carg3)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(pattern)
}

// TestFail wraps g_test_fail
//
// Indicates that a test failed.
// 
// This function can be called multiple times from the same test.
// You can use this function if your test failed in a recoverable way.
// 
// Do not use this function if the failure of a test could cause
// other tests to malfunction.
// 
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
// 
// If not called from inside a test, this function does nothing.
// 
// Note that unlike [func@GLib.test_skip] and [func@GLib.test_incomplete],
// this function does not log a message alongside the test failure.
// If details of the test failure are available, either log them with
// [func@GLib.test_message] before [func@GLib.test_fail], or use
// [func@GLib.test_fail_printf] instead.
func TestFail() {

	C.g_test_fail()
}

// TestFailed wraps g_test_failed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether a test has already failed.
// 
// This will be the case when [func@GLib.test_fail],
// [func@GLib.test_incomplete] or [func@GLib.test_skip] have
// been called, but also if an assertion has failed.
// 
// This can be useful to return early from a test if
// continuing after a failed assertion might be harmful.
// 
// The return value of this function is only meaningful
// if it is called from inside a test function.
func TestFailed() bool {
	var cret C.gboolean // return

	cret = C.g_test_failed()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestGetDir wraps g_test_get_dir
// 
// The function takes the following parameters:
// 
// 	- fileType TestFileType: the type of file (built vs. distributed) 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the pathname of the directory containing test files of the type
// specified by @file_type.
// 
// This is approximately the same as calling `g_test_build_filename(".")`,
// but you don't need to free the return value.
func TestGetDir(fileType TestFileType) string {
	var carg1 C.GTestFileType // in, none, casted
	var cret  *C.gchar        // return, none, string

	carg1 = C.GTestFileType(fileType)

	cret = C.g_test_get_dir(carg1)
	runtime.KeepAlive(fileType)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestGetPath wraps g_test_get_path
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the test path for the test currently being run.
// 
// In essence, it will be the same string passed as the first argument
// to e.g. [func@GLib.test_add] when the test was added.
// 
// This function returns a valid string only within a test function.
// 
// Note that this is a test path, not a file system path.
func TestGetPath() string {
	var cret *C.char // return, none, string

	cret = C.g_test_get_path()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestIncomplete wraps g_test_incomplete
// 
// The function takes the following parameters:
// 
// 	- msg string (nullable): explanation 
//
// Indicates that a test failed because of some incomplete
// functionality.
// 
// This function can be called multiple times from the same test.
// 
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
// 
// If not called from inside a test, this function does nothing.
func TestIncomplete(msg string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if msg != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msg)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_test_incomplete(carg1)
	runtime.KeepAlive(msg)
}

// TestLogTypeName wraps g_test_log_type_name
// 
// The function takes the following parameters:
// 
// 	- logType TestLogType 
// 
// The function returns the following values:
// 
// 	- goret string 
func TestLogTypeName(logType TestLogType) string {
	var carg1 C.GTestLogType // in, none, casted
	var cret  *C.char        // return, none, string

	carg1 = C.GTestLogType(logType)

	cret = C.g_test_log_type_name(carg1)
	runtime.KeepAlive(logType)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestRandDouble wraps g_test_rand_double
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Gets a reproducible random floating point number.
// 
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandDouble() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_rand_double()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestRandDoubleRange wraps g_test_rand_double_range
// 
// The function takes the following parameters:
// 
// 	- rangeStart float64: the minimum value returned by this function 
// 	- rangeEnd float64: the minimum value not returned by this function 
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Gets a reproducible random floating point number out of a specified range.
// 
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandDoubleRange(rangeStart float64, rangeEnd float64) float64 {
	var carg1 C.double // in, none, casted
	var carg2 C.double // in, none, casted
	var cret  C.double // return, none, casted

	carg1 = C.double(rangeStart)
	carg2 = C.double(rangeEnd)

	cret = C.g_test_rand_double_range(carg1, carg2)
	runtime.KeepAlive(rangeStart)
	runtime.KeepAlive(rangeEnd)

	var goret float64

	goret = float64(cret)

	return goret
}

// TestRandInt wraps g_test_rand_int
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets a reproducible random integer number.
// 
// The random numbers generated by the g_test_rand_*() family of functions
// change with every new test program start, unless the --seed option is
// given when starting test programs.
// 
// For individual test cases however, the random number generator is
// reseeded, to avoid dependencies between tests and to make --seed
// effective for all test cases.
func TestRandInt() int32 {
	var cret C.gint32 // return, none, casted

	cret = C.g_test_rand_int()

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRandIntRange wraps g_test_rand_int_range
// 
// The function takes the following parameters:
// 
// 	- begin int32: the minimum value returned by this function 
// 	- end int32: the smallest value not to be returned by this function 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets a reproducible random integer number out of a specified range.
// 
// See [func@GLib.test_rand_int] for details on test case random numbers.
func TestRandIntRange(begin int32, end int32) int32 {
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_test_rand_int_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRun wraps g_test_run
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Runs all tests under the toplevel suite.
// 
// The toplevel suite can be retrieved with [func@GLib.test_get_root].
// 
// Similar to [func@GLib.test_run_suite], the test cases to be run are
// filtered according to test path arguments (`-p testpath` and `-s testpath`)
// as parsed by [func@GLib.test_init]. [func@GLib.test_run_suite] or
// [func@GLib.test_run] may only be called once in a program.
// 
// In general, the tests and sub-suites within each suite are run in
// the order in which they are defined. However, note that prior to
// GLib 2.36, there was a bug in the `g_test_add_*`
// functions which caused them to create multiple suites with the same
// name, meaning that if you created tests "/foo/simple",
// "/bar/simple", and "/foo/using-bar" in that order, they would get
// run in that order (since [func@GLib.test_run] would run the first "/foo"
// suite, then the "/bar" suite, then the second "/foo" suite). As of
// 2.36, this bug is fixed, and adding the tests in that order would
// result in a running order of "/foo/simple", "/foo/using-bar",
// "/bar/simple". If this new ordering is sub-optimal (because it puts
// more-complicated tests before simpler ones, making it harder to
// figure out exactly what has failed), you can fix it by changing the
// test paths to group tests by suite in a way that will result in the
// desired running order. Eg, "/simple/foo", "/simple/bar",
// "/complex/foo-using-bar".
// 
// However, you should never make the actual result of a test depend
// on the order that tests are run in. If you need to ensure that some
// particular code runs before or after a given test case, use
// [func@GLib.test_add], which lets you specify setup and teardown functions.
// 
// If all tests are skipped or marked as incomplete (expected failures),
// this function will return 0 if producing TAP output, or 77 (treated
// as "skip test" by Automake) otherwise.
func TestRun() int32 {
	var cret C.int // return, none, casted

	cret = C.g_test_run()

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRunSuite wraps g_test_run_suite
// 
// The function takes the following parameters:
// 
// 	- suite *TestSuite: a test suite 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Executes the tests within @suite and all nested test suites.
// 
// The test suites to be executed are filtered according to
// test path arguments (`-p testpath` and `-s testpath`) as parsed by
// [func@GLib.test_init]. See the [func@GLib.test_run] documentation
// for more information on the order that tests are run in.
// 
// [func@GLib.test_run_suite] or [func@GLib.test_run] may only be
// called once in a program.
func TestRunSuite(suite *TestSuite) int32 {
	var carg1 *C.GTestSuite // in, none, converted
	var cret  C.int         // return, none, casted

	carg1 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))

	cret = C.g_test_run_suite(carg1)
	runtime.KeepAlive(suite)

	var goret int32

	goret = int32(cret)

	return goret
}

// TestSetNonfatalAssertions wraps g_test_set_nonfatal_assertions
//
// Changes the behaviour of the various assertion macros.
// 
// The `g_assert_*()` macros, `g_test_assert_expected_messages()`
// and the various `g_test_trap_assert_*()` macros are changed
// to not abort to program.
// 
// Instead, they will call [func@GLib.test_fail] and continue.
// (This also changes the behavior of [func@GLib.test_fail] so that
// it will not cause the test program to abort after completing
// the failed test.)
// 
// Note that the [func@GLib.assert_not_reached] and [func@GLib.assert]
// macros are not affected by this.
// 
// This function can only be called after [func@GLib.test_init].
func TestSetNonfatalAssertions() {

	C.g_test_set_nonfatal_assertions()
}

// TestSkip wraps g_test_skip
// 
// The function takes the following parameters:
// 
// 	- msg string (nullable): explanation 
//
// Indicates that a test was skipped.
// 
// Calling this function will not stop the test from running, you
// need to return from the test function yourself. So you can
// produce additional diagnostic messages or even continue running
// the test.
// 
// If not called from inside a test, this function does nothing.
func TestSkip(msg string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if msg != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msg)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_test_skip(carg1)
	runtime.KeepAlive(msg)
}

// TestSubprocess wraps g_test_subprocess
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns true if the test program is running under [func@GLib.test_trap_subprocess].
func TestSubprocess() bool {
	var cret C.gboolean // return

	cret = C.g_test_subprocess()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestSummary wraps g_test_summary
// 
// The function takes the following parameters:
// 
// 	- summary string: summary of the test purpose 
//
// Sets the summary for a test.
// 
// This may be included in test report output, and is useful documentation for
// anyone reading the source code or modifying a test in future. It must be a
// single line, and it should summarise what the test checks, and how.
// 
// This should be called at the top of a test function.
// 
// For example:
// 
// ```c
// static void
// test_array_sort (void)
// {
//   g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
//                   "including testing zero length and one-element arrays.");
// 
//   // ...
// }
// ```
// 
// See also [func@GLib.test_bug].
func TestSummary(summary string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(summary)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_summary(carg1)
	runtime.KeepAlive(summary)
}

// TestTimerElapsed wraps g_test_timer_elapsed
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Gets the number of seconds since the last start of the timer with
// [func@GLib.test_timer_start].
func TestTimerElapsed() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_timer_elapsed()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestTimerLast wraps g_test_timer_last
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Reports the last result of [func@GLib.test_timer_elapsed].
func TestTimerLast() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_timer_last()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestTimerStart wraps g_test_timer_start
//
// Starts a timing test.
// 
// Call [func@GLib.test_timer_elapsed] when the task is supposed
// to be done. Call this function again to restart the timer.
func TestTimerStart() {

	C.g_test_timer_start()
}

// TestTrapAssertions wraps g_test_trap_assertions
// 
// The function takes the following parameters:
// 
// 	- domain string 
// 	- file string 
// 	- line int32 
// 	- fn string 
// 	- assertionFlags uint64 
// 	- pattern string 
func TestTrapAssertions(domain string, file string, line int32, fn string, assertionFlags uint64, pattern string) {
	var carg1 *C.char   // in, none, string
	var carg2 *C.char   // in, none, string
	var carg3 C.int     // in, none, casted
	var carg4 *C.char   // in, none, string
	var carg5 C.guint64 // in, none, casted
	var carg6 *C.char   // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.guint64(assertionFlags)
	carg6 = (*C.char)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg6))

	C.g_test_trap_assertions(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(assertionFlags)
	runtime.KeepAlive(pattern)
}

// TestTrapHasPassed wraps g_test_trap_has_passed
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks the result of the last [func@GLib.test_trap_subprocess] call.
func TestTrapHasPassed() bool {
	var cret C.gboolean // return

	cret = C.g_test_trap_has_passed()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestTrapReachedTimeout wraps g_test_trap_reached_timeout
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks the result of the last [func@GLib.test_trap_subprocess] call.
func TestTrapReachedTimeout() bool {
	var cret C.gboolean // return

	cret = C.g_test_trap_reached_timeout()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestTrapSubprocess wraps g_test_trap_subprocess
// 
// The function takes the following parameters:
// 
// 	- testPath string (nullable): test to run in a subprocess 
// 	- usecTimeout uint64: timeout for the subprocess test in microseconds. 
// 	- testFlags TestSubprocessFlags: flags to modify subprocess behaviour 
//
// Respawns the test program to run only @test_path in a subprocess.
// 
// This is equivalent to calling [func@GLib.test_trap_subprocess_with_envp]
// with `envp` set to `NULL`. See the documentation for that function
// for full details.
func TestTrapSubprocess(testPath string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var carg1 *C.char                // in, none, string, nullable-string
	var carg2 C.guint64              // in, none, casted
	var carg3 C.GTestSubprocessFlags // in, none, casted

	if testPath != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(testPath)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.guint64(usecTimeout)
	carg3 = C.GTestSubprocessFlags(testFlags)

	C.g_test_trap_subprocess(carg1, carg2, carg3)
	runtime.KeepAlive(testPath)
	runtime.KeepAlive(usecTimeout)
	runtime.KeepAlive(testFlags)
}

// TestTrapSubprocessWithEnvp wraps g_test_trap_subprocess_with_envp
// 
// The function takes the following parameters:
// 
// 	- testPath string (nullable): test to run in a subprocess 
// 	- envp []string (nullable): environment
//   to run the test in 
// 	- usecTimeout uint64: timeout for the subprocess test in microseconds 
// 	- testFlags TestSubprocessFlags: flags to modify subprocess behaviour 
//
// Respawns the test program to run only @test_path in a subprocess with
// a given environment.
// 
// This can be used for a test case that might not return, or that
// might abort.
// 
// If @test_path is `NULL` then the same test is re-run in a subprocess.
// You can use [func@GLib.test_subprocess] to determine whether the test
// is in a subprocess or not.
// 
// @test_path can also be the name of the parent test, followed by
// "`/subprocess/`" and then a name for the specific subtest (or just
// ending with "`/subprocess`" if the test only has one child test);
// tests with names of this form will automatically be skipped in the
// parent process.
// 
// If @envp is `NULL`, the parent process&#x2019; environment will be inherited.
// 
// If @usec_timeout is non-0, the test subprocess is aborted and
// considered failing if its run time exceeds it.
// 
// The subprocess behavior can be configured with [flags@GLib.TestSubprocessFlags]
// flags.
// 
// You can use methods such as [func@GLib.test_trap_assert_passed],
// [func@GLib.test_trap_assert_failed], and [func@GLib.test_trap_assert_stderr] to
// check the results of the subprocess. (But note that
// [func@GLib.test_trap_assert_stdout] and [func@GLib.test_trap_assert_stderr]
// cannot be used if @test_flags specifies that the child should
// inherit the parent stdout/stderr.)
// 
// If your `main ()` needs to behave differently in the subprocess, you can
// call [func@GLib.test_subprocess] (after calling [func@GLib.test_init])
// to see whether you are in a subprocess.
// 
// Internally, this function tracks the child process using
// [func@GLib.child_watch_source_new], so your process must not ignore
// `SIGCHLD`, and must not attempt to watch or wait for the child process
// via another mechanism.
// 
// The following example tests that calling `my_object_new(1000000)` will
// abort with an error message.
// 
// ```c
//   static void
//   test_create_large_object (void)
//   {
//     if (g_test_subprocess ())
//       {
//         my_object_new (1000000);
//         return;
//       }
// 
//     // Reruns this same test in a subprocess
//     g_test_trap_subprocess (NULL, 0, G_TEST_SUBPROCESS_DEFAULT);
//     g_test_trap_assert_failed ();
//     g_test_trap_assert_stderr ("*ERROR*too large*");
//   }
// 
//   static void
//   test_different_username (void)
//   {
//     if (g_test_subprocess ())
//       {
//         // Code under test goes here
//         g_message ("Username is now simulated as %s", g_getenv ("USER"));
//         return;
//       }
// 
//     // Reruns this same test in a subprocess
//     g_autoptr(GStrv) envp = g_get_environ ();
//     envp = g_environ_setenv (g_steal_pointer (&amp;envp), "USER", "charlie", TRUE);
//     g_test_trap_subprocess_with_envp (NULL, envp, 0, G_TEST_SUBPROCESS_DEFAULT);
//     g_test_trap_assert_passed ();
//     g_test_trap_assert_stdout ("Username is now simulated as charlie");
//   }
// 
//   int
//   main (int argc, char **argv)
//   {
//     g_test_init (&amp;argc, &amp;argv, NULL);
// 
//     g_test_add_func ("/myobject/create-large-object",
//                      test_create_large_object);
//     g_test_add_func ("/myobject/different-username",
//                      test_different_username);
//     return g_test_run ();
//   }
// ```
func TestTrapSubprocessWithEnvp(testPath string, envp []string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var carg1 *C.char                // in, none, string, nullable-string
	var carg2 **C.char               // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg3 C.guint64              // in, none, casted
	var carg4 C.GTestSubprocessFlags // in, none, casted

	if testPath != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(testPath)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = envp
	_ = carg2
	panic("unimplemented conversion of []string (const char* const*) because of unimplemented: inner pointers in array")
	carg3 = C.guint64(usecTimeout)
	carg4 = C.GTestSubprocessFlags(testFlags)

	C.g_test_trap_subprocess_with_envp(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(testPath)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(usecTimeout)
	runtime.KeepAlive(testFlags)
}

// TimeoutAddFull wraps g_timeout_add_full
// 
// The function takes the following parameters:
// 
// 	- priority int32: the priority of the timeout source. Typically this will be in
//   the range between [const@GLib.PRIORITY_DEFAULT] and
//   [const@GLib.PRIORITY_HIGH]. 
// 	- interval uint: the time between calls to the function, in milliseconds
//   (1/1000ths of a second) 
// 	- function SourceFunc: function to call 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Sets a function to be called at regular intervals, with the given
// priority.  The function is called repeatedly until it returns
// %FALSE, at which point the timeout is automatically destroyed and
// the function will not be called again.  The @notify function is
// called when the timeout is destroyed.  The first call to the
// function will be at the end of the first @interval.
// 
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given interval
// (it does not try to 'catch up' time lost in delays).
// 
// See [mainloop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
// 
// This internally creates a main loop source using
// [func@GLib.timeout_source_new] and attaches it to the global
// [struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback
// will be invoked in whichever thread is running that main context. You can do
// these steps manually if you need greater control or to use a custom main
// context.
// 
// The interval given is in terms of monotonic time, not wall clock time.
// See [func@GLib.get_monotonic_time].
func TimeoutAddFull(priority int32, interval uint, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.guint          // in, none, casted
	var carg3 C.GSourceFunc    // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.guint(interval)
	carg3 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_timeout_add_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// TimeoutAddSecondsFull wraps g_timeout_add_seconds_full
// 
// The function takes the following parameters:
// 
// 	- priority int32: the priority of the timeout source. Typically this will be in
//   the range between [const@GLib.PRIORITY_DEFAULT] and
//   [const@GLib.PRIORITY_HIGH]. 
// 	- interval uint: the time between calls to the function, in seconds 
// 	- function SourceFunc: function to call 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Sets a function to be called at regular intervals, with @priority.
// 
// The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE]
// or %FALSE, at which point the timeout is automatically destroyed and
// the function will not be called again.
// 
// Unlike [func@GLib.timeout_add], this function operates at whole second
// granularity. The initial starting point of the timer is determined by the
// implementation and the implementation is expected to group multiple timers
// together so that they fire all at the same time. To allow this grouping, the
// @interval to the first timer is rounded and can deviate up to one second
// from the specified interval. Subsequent timer iterations will generally run
// at the specified interval.
// 
// Note that timeout functions may be delayed, due to the processing of other
// event sources. Thus they should not be relied on for precise timing.
// After each call to the timeout function, the time of the next
// timeout is recalculated based on the current time and the given @interval
// 
// See [mainloop memory management](main-loop.html#memory-management-of-sources) for details
// on how to handle the return value and memory management of @data.
// 
// If you want timing more precise than whole seconds, use
// [func@GLib.timeout_add] instead.
// 
// The grouping of timers to fire at the same time results in a more power
// and CPU efficient behavior so if your timer is in multiples of seconds
// and you don't require the first timer exactly one second from now, the
// use of [func@GLib.timeout_add_seconds] is preferred over
// [func@GLib.timeout_add].
// 
// This internally creates a main loop source using
// [func@GLib.timeout_source_new_seconds] and attaches it to the main loop
// context using [method@GLib.Source.attach]. You can do these steps manually
// if you need greater control.
// 
// It is safe to call this function from any thread.
// 
// The interval given is in terms of monotonic time, not wall clock
// time. See [func@GLib.get_monotonic_time].
func TimeoutAddSecondsFull(priority int32, interval uint, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.guint          // in, none, casted
	var carg3 C.GSourceFunc    // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.guint(interval)
	carg3 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_timeout_add_seconds_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// UCS4ToUTF8 wraps g_ucs4_to_utf8
// 
// The function takes the following parameters:
// 
// 	- str []uint32: a UCS-4 encoded string 
// 
// The function returns the following values:
// 
// 	- itemsRead int32: location to store number of
//   characters read, or `NULL`. 
// 	- itemsWritten int32: location to store number
//   of bytes written or `NULL`. The value here stored does not include the
//   trailing nul byte. 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Convert a string from a 32-bit fixed width representation as UCS-4.
// to UTF-8.
// 
// The result will be terminated with a nul byte.
func UCS4ToUTF8(str []uint32) (int32, int32, string, error) {
	var carg1 *C.gunichar // in, transfer: none, C Pointers: 1, Name: array[gunichar], array (inner gunichar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong     // implicit
	var carg3 C.glong     // out, full, casted
	var carg4 C.glong     // out, full, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint32 (const gunichar*) because of unimplemented: non-fixed size array")

	cret = C.g_ucs4_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        string
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UnicharBreakType wraps g_unichar_break_type
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret UnicodeBreakType 
//
// Determines the break type of @c. @c should be a Unicode character
// (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line
// breaks ("text boundaries"), Pango implements the Unicode boundary
// resolution algorithms and normally you would use a function such
// as pango_break() instead of caring about break types yourself.
func UnicharBreakType(c uint32) UnicodeBreakType {
	var carg1 C.gunichar          // in, none, casted
	var cret  C.GUnicodeBreakType // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_break_type(carg1)
	runtime.KeepAlive(c)

	var goret UnicodeBreakType

	goret = UnicodeBreakType(cret)

	return goret
}

// UnicharCombiningClass wraps g_unichar_combining_class
// 
// The function takes the following parameters:
// 
// 	- uc uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the canonical combining class of a Unicode character.
func UnicharCombiningClass(uc uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(uc)

	cret = C.g_unichar_combining_class(carg1)
	runtime.KeepAlive(uc)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicharCompose wraps g_unichar_compose
// 
// The function takes the following parameters:
// 
// 	- a uint32: a Unicode character 
// 	- b uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- ch uint32: return location for the composed character 
// 	- goret bool 
//
// Performs a single composition step of the
// Unicode canonical composition algorithm.
// 
// This function includes algorithmic Hangul Jamo composition,
// but it is not exactly the inverse of g_unichar_decompose().
// No composition can have either of @a or @b equal to zero.
// To be precise, this function composes if and only if
// there exists a Primary Composite P which is canonically
// equivalent to the sequence &lt;@a,@b&gt;.  See the Unicode
// Standard for the definition of Primary Composite.
// 
// If @a and @b do not compose a new character, @ch is set to zero.
// 
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharCompose(a uint32, b uint32) (uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // in, none, casted
	var carg3 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(a)
	carg2 = C.gunichar(b)

	cret = C.g_unichar_compose(carg1, carg2, &carg3)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var ch    uint32
	var goret bool

	ch = uint32(carg3)
	if cret != 0 {
		goret = true
	}

	return ch, goret
}

// UnicharDecompose wraps g_unichar_decompose
// 
// The function takes the following parameters:
// 
// 	- ch uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- a uint32: return location for the first component of @ch 
// 	- b uint32: return location for the second component of @ch 
// 	- goret bool 
//
// Performs a single decomposition step of the
// Unicode canonical decomposition algorithm.
// 
// This function does not include compatibility
// decompositions. It does, however, include algorithmic
// Hangul Jamo decomposition, as well as 'singleton'
// decompositions which replace a character by a single
// other character. In the case of singletons `*b` will
// be set to zero.
// 
// If @ch is not decomposable, `*a` is set to @ch and `*b`
// is set to zero.
// 
// Note that the way Unicode decomposition pairs are
// defined, it is guaranteed that @b would not decompose
// further, but @a may itself decompose.  To get the full
// canonical decomposition for @ch, one would need to
// recursively call this function on @a.  Or use
// g_unichar_fully_decompose().
// 
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharDecompose(ch uint32) (uint32, uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // out, full, casted
	var carg3 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_decompose(carg1, &carg2, &carg3)
	runtime.KeepAlive(ch)

	var a     uint32
	var b     uint32
	var goret bool

	a = uint32(carg2)
	b = uint32(carg3)
	if cret != 0 {
		goret = true
	}

	return a, b, goret
}

// UnicharDigitValue wraps g_unichar_digit_value
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the numeric value of a character as a decimal
// digit.
func UnicharDigitValue(c uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_digit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicharFullyDecompose wraps g_unichar_fully_decompose
// 
// The function takes the following parameters:
// 
// 	- ch uint32: a Unicode character. 
// 	- compat bool: whether perform canonical or compatibility decomposition 
// 	- resultLen uint: length of @result 
// 
// The function returns the following values:
// 
// 	- result uint32: location to store decomposed result, or %NULL 
// 	- goret uint 
//
// Computes the canonical or compatibility decomposition of a
// Unicode character.  For compatibility decomposition,
// pass %TRUE for @compat; for canonical decomposition
// pass %FALSE for @compat.
// 
// The decomposed sequence is placed in @result.  Only up to
// @result_len characters are written into @result.  The length
// of the full decomposition (irrespective of @result_len) is
// returned by the function.  For canonical decomposition,
// currently all decompositions are of length at most 4, but
// this may change in the future (very unlikely though).
// At any rate, Unicode does guarantee that a buffer of length
// 18 is always enough for both compatibility and canonical
// decompositions, so that is the size recommended. This is provided
// as %G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
// 
// See
// [UAX#15](http://unicode.org/reports/tr15/)
// for details.
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gboolean // in
	var carg4 C.gsize    // in, none, casted
	var carg3 C.gunichar // out, transfer: none, C Pointers: 0, Name: gunichar, optional, caller-allocates
	var cret  C.gsize    // return, none, casted

	carg1 = C.gunichar(ch)
	if compat {
		carg2 = C.TRUE
	}
	carg4 = C.gsize(resultLen)

	cret = C.g_unichar_fully_decompose(carg1, carg2, &carg3, carg4)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(compat)
	runtime.KeepAlive(resultLen)

	var result uint32
	var goret  uint

	_ = result
	_ = carg3
	panic("unimplemented conversion of uint32 (gunichar) because of unknown reason")
	goret = uint(cret)

	return result, goret
}

// UnicharGetMirrorChar wraps g_unichar_get_mirror_char
// 
// The function takes the following parameters:
// 
// 	- ch uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- mirroredCh uint32: location to store the mirrored character 
// 	- goret bool 
//
// In Unicode, some characters are "mirrored". This means that their
// images are mirrored horizontally in text that is laid out from right
// to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
// 
// If @ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of @ch's
// glyph and @mirrored_ch is set, it puts that character in the address
// pointed to by @mirrored_ch.  Otherwise the original character is put.
func UnicharGetMirrorChar(ch uint32) (uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_get_mirror_char(carg1, &carg2)
	runtime.KeepAlive(ch)

	var mirroredCh uint32
	var goret      bool

	mirroredCh = uint32(carg2)
	if cret != 0 {
		goret = true
	}

	return mirroredCh, goret
}

// UnicharGetScript wraps g_unichar_get_script
// 
// The function takes the following parameters:
// 
// 	- ch uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret UnicodeScript 
//
// Looks up the #GUnicodeScript for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for @ch being a
// valid Unicode character; if you pass in invalid character, the
// result is undefined.
// 
// This function is equivalent to pango_script_for_unichar() and the
// two are interchangeable.
func UnicharGetScript(ch uint32) UnicodeScript {
	var carg1 C.gunichar       // in, none, casted
	var cret  C.GUnicodeScript // return, none, casted

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_get_script(carg1)
	runtime.KeepAlive(ch)

	var goret UnicodeScript

	goret = UnicodeScript(cret)

	return goret
}

// UnicharIsalnum wraps g_unichar_isalnum
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is alphanumeric.
// Given some UTF-8 text, obtain a character value
// with g_utf8_get_char().
func UnicharIsalnum(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isalnum(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsalpha wraps g_unichar_isalpha
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsalpha(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isalpha(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIscntrl wraps g_unichar_iscntrl
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is a control character.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIscntrl(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iscntrl(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsdefined wraps g_unichar_isdefined
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a given character is assigned in the Unicode
// standard.
func UnicharIsdefined(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isdefined(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsdigit wraps g_unichar_isdigit
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is numeric (i.e. a digit).  This
// covers ASCII 0-9 and also digits in other languages/scripts.  Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
func UnicharIsdigit(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isdigit(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsgraph wraps g_unichar_isgraph
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is printable and not a space
// (returns %FALSE for control characters, format characters, and
// spaces). g_unichar_isprint() is similar, but returns %TRUE for
// spaces. Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsgraph(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isgraph(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIslower wraps g_unichar_islower
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is a lowercase letter.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIslower(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_islower(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsmark wraps g_unichar_ismark
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak).
// Given some UTF-8 text, obtain a character value
// with g_utf8_get_char().
// 
// Note: in most cases where isalpha characters are allowed,
// ismark characters should be allowed to as they are essential
// for writing most European languages as well as many non-Latin
// scripts.
func UnicharIsmark(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_ismark(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsprint wraps g_unichar_isprint
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is printable.
// Unlike g_unichar_isgraph(), returns %TRUE for spaces.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIsprint(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isprint(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIspunct wraps g_unichar_ispunct
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with
// g_utf8_get_char().
func UnicharIspunct(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_ispunct(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsspace wraps g_unichar_isspace
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether a character is a space, tab, or line separator
// (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
// 
// (Note: don't use this to do word breaking; you have to use
// Pango or equivalent to get word breaking right, the algorithm
// is fairly complex.)
func UnicharIsspace(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isspace(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIstitle wraps g_unichar_istitle
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph
// have three case variants instead of just two. The titlecase
// form is used at the beginning of a word where only the
// first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
func UnicharIstitle(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_istitle(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsupper wraps g_unichar_isupper
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a character is uppercase.
func UnicharIsupper(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isupper(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIswide wraps g_unichar_iswide
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a character is typically rendered in a double-width
// cell.
func UnicharIswide(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iswide(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIswideCjk wraps g_unichar_iswide_cjk
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a character is typically rendered in a double-width
// cell under legacy East Asian locales.  If a character is wide according to
// g_unichar_iswide(), then it is also reported wide with this function, but
// the converse is not necessarily true. See the
// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
// for details.
// 
// If a character passes the g_unichar_iswide() test then it will also pass
// this test, but not the other way around.  Note that some characters may
// pass both this test and g_unichar_iszerowidth().
func UnicharIswideCjk(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iswide_cjk(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsxdigit wraps g_unichar_isxdigit
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a character is a hexadecimal digit.
func UnicharIsxdigit(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isxdigit(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIszerowidth wraps g_unichar_iszerowidth
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if a given character typically takes zero width when rendered.
// The return value is %TRUE for all non-spacing and enclosing marks
// (e.g., combining accents), format characters, zero-width
// space, but not U+00AD SOFT HYPHEN.
// 
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals).  However, note that not all
// terminals support zero-width rendering of zero-width marks.
func UnicharIszerowidth(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iszerowidth(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharToUTF8 wraps g_unichar_to_utf8
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character code 
// 
// The function returns the following values:
// 
// 	- outbuf byte: output buffer, must have at
//   least 6 bytes of space. If `NULL`, the length will be computed and
//   returned and nothing will be written to @outbuf. 
// 	- goret int32 
//
// Converts a single character to UTF-8.
func UnicharToUTF8(c uint32) (byte, int32) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gchar    // out, transfer: none, C Pointers: 0, Name: gchar, optional, caller-allocates
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_to_utf8(carg1, &carg2)
	runtime.KeepAlive(c)

	var outbuf byte
	var goret  int32

	_ = outbuf
	_ = carg2
	panic("unimplemented conversion of byte (gchar) because of unknown reason")
	goret = int32(cret)

	return outbuf, goret
}

// UnicharTolower wraps g_unichar_tolower
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character. 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Converts a character to lower case.
func UnicharTolower(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_tolower(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharTotitle wraps g_unichar_totitle
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Converts a character to the titlecase.
func UnicharTotitle(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_totitle(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharToupper wraps g_unichar_toupper
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Converts a character to uppercase.
func UnicharToupper(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_toupper(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharType wraps g_unichar_type
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret UnicodeType 
//
// Classifies a Unicode character by type.
func UnicharType(c uint32) UnicodeType {
	var carg1 C.gunichar     // in, none, casted
	var cret  C.GUnicodeType // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_type(carg1)
	runtime.KeepAlive(c)

	var goret UnicodeType

	goret = UnicodeType(cret)

	return goret
}

// UnicharValidate wraps g_unichar_validate
// 
// The function takes the following parameters:
// 
// 	- ch uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks whether @ch is a valid Unicode character.
// 
// Some possible integer values of @ch will not be valid. U+0000 is considered a
// valid character, though it&#x2019;s normally a string terminator.
func UnicharValidate(ch uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_validate(carg1)
	runtime.KeepAlive(ch)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharXdigitValue wraps g_unichar_xdigit_value
// 
// The function takes the following parameters:
// 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the numeric value of a character as a hexadecimal
// digit.
func UnicharXdigitValue(c uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_xdigit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicodeCanonicalOrdering wraps g_unicode_canonical_ordering
// 
// The function takes the following parameters:
// 
// 	- str []uint32: a UCS-4 encoded string. 
//
// Computes the canonical ordering of a string in-place.
// This rearranges decomposed characters in the string
// according to their combining classes.  See the Unicode
// manual for more information.
func UnicodeCanonicalOrdering(str []uint32) {
	var carg1 *C.gunichar // in, transfer: none, C Pointers: 1, Name: array[gunichar], array (inner gunichar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize     // implicit

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint32 (gunichar*) because of unimplemented: non-fixed size array")

	C.g_unicode_canonical_ordering(carg1, carg2)
	runtime.KeepAlive(str)
}

// Unsetenv wraps g_unsetenv
// 
// The function takes the following parameters:
// 
// 	- variable string: the environment variable to remove, must
//     not contain '=' 
//
// Removes an environment variable from the environment.
// 
// Note that on some systems, when variables are overwritten, the
// memory used for the previous variables and its value isn't reclaimed.
// 
// You should be mindful of the fact that environment variable handling
// in UNIX is not thread-safe, and your program may crash if one thread
// calls g_unsetenv() while another thread is calling getenv(). (And note
// that many functions, such as gettext(), call getenv() internally.) This
// function is only safe to use at the very start of your program, before
// creating any other threads (or creating objects that create worker
// threads of their own).
// 
// If you need to set up the environment for a child process, you can
// use g_get_environ() to get an environment array, modify that with
// g_environ_setenv() and g_environ_unsetenv(), and then pass that
// array directly to execvpe(), g_spawn_async(), or the like.
func Unsetenv(variable string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_unsetenv(carg1)
	runtime.KeepAlive(variable)
}

// Usleep wraps g_usleep
// 
// The function takes the following parameters:
// 
// 	- microseconds uint32: number of microseconds to pause 
//
// Pauses the current thread for the given number of microseconds.
// 
// There are 1 million microseconds per second (represented by the
// %G_USEC_PER_SEC macro). g_usleep() may have limited precision,
// depending on hardware and operating system; don't rely on the exact
// length of the sleep.
func Usleep(microseconds uint32) {
	var carg1 C.gulong // in, none, casted

	carg1 = C.gulong(microseconds)

	C.g_usleep(carg1)
	runtime.KeepAlive(microseconds)
}

// UTF16ToUCS4 wraps g_utf16_to_ucs4
// 
// The function takes the following parameters:
// 
// 	- str []uint16: a UTF-16 encoded string 
// 
// The function returns the following values:
// 
// 	- itemsRead int32: location to store number of words read, or
//   `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will be
//   returned in case @str contains a trailing partial character. If
//   an error occurs then the index of the invalid input is stored here. 
// 	- itemsWritten int32: location to store number
//   of characters written, or `NULL`. The value stored here does not include
//   the trailing nul character. 
// 	- goret *uint32 
// 	- _goerr error (nullable): an error 
//
// Convert a string from UTF-16 to UCS-4.
// 
// The result will be nul-terminated.
func UTF16ToUCS4(str []uint16) (int32, int32, *uint32, error) {
	var carg1 *C.gunichar2 // in, transfer: none, C Pointers: 1, Name: array[guint16], array (inner guint16 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong      // implicit
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gunichar  // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 
	var _cerr *C.GError    // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint16 (const gunichar2*) because of unimplemented: non-fixed size array")

	cret = C.g_utf16_to_ucs4(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint32
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF16ToUTF8 wraps g_utf16_to_utf8
// 
// The function takes the following parameters:
// 
// 	- str []uint16: a UTF-16 encoded string 
// 
// The function returns the following values:
// 
// 	- itemsRead int32: location to store number of words read, or
//   `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will
//   be returned in case @str contains a trailing partial character. If
//   an error occurs then the index of the invalid input is stored here.
//   It&#x2019;s guaranteed to be non-negative. 
// 	- itemsWritten int32: location to store number
//   of bytes written, or `NULL`. The value stored here does not include the
//   trailing nul byte. It&#x2019;s guaranteed to be non-negative. 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Convert a string from UTF-16 to UTF-8.
// 
// The result will be terminated with a nul byte.
// 
// Note that the input is expected to be already in native endianness,
// an initial byte-order-mark character is not handled specially.
// [func@GLib.convert] can be used to convert a byte buffer of UTF-16 data of
// ambiguous endianness.
// 
// Further note that this function does not validate the result
// string; it may (for example) include embedded nul characters. The only
// validation done by this function is to ensure that the input can
// be correctly interpreted as UTF-16, i.e. it doesn&#x2019;t contain
// unpaired surrogates or partial character sequences.
func UTF16ToUTF8(str []uint16) (int32, int32, string, error) {
	var carg1 *C.gunichar2 // in, transfer: none, C Pointers: 1, Name: array[guint16], array (inner guint16 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong      // implicit
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gchar     // return, full, string
	var _cerr *C.GError    // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint16 (const gunichar2*) because of unimplemented: non-fixed size array")

	cret = C.g_utf16_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        string
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8Casefold wraps g_utf8_casefold
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be
// compared for equality or ordered with the results of calling
// g_utf8_casefold() on other strings.
// 
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is
// only an approximation to the correct linguistic case insensitive
// ordering, though it is a fairly good one. Getting this exactly
// right would require a more sophisticated collation function that
// takes case sensitivity into account. GLib does not currently
// provide such a function.
func UTF8Casefold(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_casefold(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Collate wraps g_utf8_collate
// 
// The function takes the following parameters:
// 
// 	- str1 string: a UTF-8 encoded string 
// 	- str2 string: a UTF-8 encoded string 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compares two strings for ordering using the linguistically
// correct rules for the [current locale](running.html#locale).
// When sorting a large number of strings, it will be significantly
// faster to obtain collation keys with g_utf8_collate_key() and
// compare the keys with strcmp() when sorting instead of sorting
// the original strings.
// 
// If the two strings are not comparable due to being in different collation
// sequences, the result is undefined. This can happen if the strings are in
// different language scripts, for example.
func UTF8Collate(str1 string, str2 string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_collate(carg1, carg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8CollateKey wraps g_utf8_collate_key
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string. 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a string into a collation key that can be compared
// with other collation keys produced by the same function using
// strcmp().
// 
// The results of comparing the collation keys of two strings
// with strcmp() will always be the same as comparing the two
// original keys with g_utf8_collate().
// 
// Note that this function depends on the [current locale](running.html#locale).
// 
// Note that the returned string is not guaranteed to be in any
// encoding, especially UTF-8. The returned value is meant to be
// used only for comparisons.
func UTF8CollateKey(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_collate_key(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8CollateKeyForFilename wraps g_utf8_collate_key_for_filename
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string. 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
// 
// In order to sort filenames correctly, this function treats the dot '.'
// as a special case. Most dictionary orderings seem to consider it
// insignificant, thus producing the ordering "event.c" "eventgenerator.c"
// "event.h" instead of "event.c" "event.h" "eventgenerator.c". Also, we
// would like to treat numbers intelligently so that "file1" "file10" "file5"
// is sorted as "file1" "file5" "file10".
// 
// Note that this function depends on the [current locale](running.html#locale).
// 
// Note that the returned string is not guaranteed to be in any
// encoding, especially UTF-8. The returned value is meant to be
// used only for comparisons.
func UTF8CollateKeyForFilename(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_collate_key_for_filename(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8FindNextChar wraps g_utf8_find_next_char
// 
// The function takes the following parameters:
// 
// 	- p string: a pointer to a position within a UTF-8 encoded string 
// 	- end string (nullable): a pointer to the byte following the end of the string,
//     or `NULL` to indicate that the string is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Finds the start of the next UTF-8 character in the string after @p.
// 
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte.
// 
// If @end is `NULL`, the return value will never be `NULL`: if the end of the
// string is reached, a pointer to the terminating nul byte is returned. If
// @end is non-`NULL`, the return value will be `NULL` if the end of the string
// is reached.
func UTF8FindNextChar(p string, end string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	if end != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(end)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_utf8_find_next_char(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(end)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8FindPrevChar wraps g_utf8_find_prev_char
// 
// The function takes the following parameters:
// 
// 	- str string: pointer to the beginning of a UTF-8 encoded string 
// 	- p string: pointer to some position within @str 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Given a position @p with a UTF-8 encoded string @str, find the start
// of the previous UTF-8 character starting before @p. Returns `NULL` if no
// UTF-8 characters are present in @str before @p.
// 
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte.
func UTF8FindPrevChar(str string, p string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_find_prev_char(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(p)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8GetChar wraps g_utf8_get_char
// 
// The function takes the following parameters:
// 
// 	- p string: a pointer to Unicode character encoded as UTF-8 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Converts a sequence of bytes encoded as UTF-8 to a Unicode character.
// 
// If @p does not point to a valid UTF-8 encoded character, results
// are undefined. If you are not sure that the bytes are complete
// valid Unicode characters, you should use [func@GLib.utf8_get_char_validated]
// instead.
func UTF8GetChar(p string) uint32 {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gunichar // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_utf8_get_char(carg1)
	runtime.KeepAlive(p)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UTF8GetCharValidated wraps g_utf8_get_char_validated
// 
// The function takes the following parameters:
// 
// 	- p string: a pointer to Unicode character encoded as UTF-8 
// 	- maxLen int: the maximum number of bytes to read, or `-1` if @p is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
// 
// This function checks for incomplete characters, for invalid characters
// such as characters that are out of the range of Unicode, and for
// overlong encodings of valid characters.
// 
// Note that [func@GLib.utf8_get_char_validated] returns `(gunichar)-2` if
// @max_len is positive and any of the bytes in the first UTF-8 character
// sequence are nul.
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(maxLen)

	cret = C.g_utf8_get_char_validated(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(maxLen)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UTF8MakeValid wraps g_utf8_make_valid
// 
// The function takes the following parameters:
// 
// 	- str string: string to coerce into UTF-8 
// 	- len int: the maximum length of @str to use, in bytes. If @len is negative,
//   then the string is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// If the provided string is valid UTF-8, return a copy of it. If not,
// return a copy in which bytes that could not be interpreted as valid Unicode
// are replaced with the Unicode replacement character (U+FFFD).
// 
// For example, this is an appropriate function to use if you have received
// a string that was incorrectly declared to be UTF-8, and you need a valid
// UTF-8 version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly
// readable as-is.
func UTF8MakeValid(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_make_valid(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Normalize wraps g_utf8_normalize
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string. 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 	- mode NormalizeMode: the type of normalization to perform. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Converts a string into canonical form, standardizing
// such issues as whether a character with an accent
// is represented as a base character and combining
// accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise %NULL is
// returned. You should generally call g_utf8_normalize()
// before comparing two Unicode strings.
// 
// The normalization mode %G_NORMALIZE_DEFAULT only
// standardizes differences that do not affect the
// text content, such as the above-mentioned accent
// representation. %G_NORMALIZE_ALL also standardizes
// the "compatibility" characters in Unicode, such
// as SUPERSCRIPT THREE to the standard forms
// (in this case DIGIT THREE). Formatting information
// may be lost but for most text operations such
// characters should be considered the same.
// 
// %G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE
// are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,
// but returned a result with composed forms rather
// than a maximally decomposed form. This is often
// useful if you intend to convert the string to
// a legacy encoding or pass it to a system with
// less capable Unicode handling.
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gssize         // in, none, casted
	var carg3 C.GNormalizeMode // in, none, casted
	var cret  *C.gchar         // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.GNormalizeMode(mode)

	cret = C.g_utf8_normalize(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)
	runtime.KeepAlive(mode)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UTF8OffsetToPointer wraps g_utf8_offset_to_pointer
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- offset int32: a character offset within @str 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts from an integer character offset to a pointer to a position
// within the string.
// 
// Since 2.10, this function allows to pass a negative @offset to
// step backwards. It is usually worth stepping backwards from the end
// instead of forwards if @offset is in the last fourth of the string,
// since moving forward is about 3 times faster than moving backward.
// 
// Note that this function doesn&#x2019;t abort when reaching the end of @str.
// Therefore you should be sure that @offset is within string boundaries
// before calling that function. Call [func@GLib.utf8_strlen] when unsure.
// This limitation exists as this function is called frequently during
// text rendering and therefore has to be as fast as possible.
func UTF8OffsetToPointer(str string, offset int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.glong  // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(offset)

	cret = C.g_utf8_offset_to_pointer(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(offset)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8PointerToOffset wraps g_utf8_pointer_to_offset
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- pos string: a pointer to a position within @str 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Converts from a pointer to position within a string to an integer
// character offset.
// 
// Since 2.10, this function allows @pos to be before @str, and returns
// a negative offset in this case.
func UTF8PointerToOffset(str string, pos string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.glong  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(pos)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_pointer_to_offset(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(pos)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8PrevChar wraps g_utf8_prev_char
// 
// The function takes the following parameters:
// 
// 	- p string: a pointer to a position within a UTF-8 encoded string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Finds the previous UTF-8 character in the string before @p.
// 
// @p does not have to be at the beginning of a UTF-8 character. No check
// is made to see if the character found is actually valid other than
// it starts with an appropriate byte. If @p might be the first
// character of the string, you must use [func@GLib.utf8_find_prev_char]
// instead.
func UTF8PrevChar(p string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_utf8_prev_char(carg1)
	runtime.KeepAlive(p)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8Strchr wraps g_utf8_strchr
// 
// The function takes the following parameters:
// 
// 	- p string: a nul-terminated UTF-8 encoded string 
// 	- len int: the maximum length of @p 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Finds the leftmost occurrence of the given Unicode character
// in a UTF-8 encoded string, while limiting the search to @len bytes.
// 
// If @len is `-1`, allow unbounded search.
func UTF8Strchr(p string, len int, c uint32) string {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var carg3 C.gunichar // in, none, casted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.gunichar(c)

	cret = C.g_utf8_strchr(carg1, carg2, carg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8Strdown wraps g_utf8_strdown
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts all Unicode characters in the string that have a case
// to lowercase. The exact manner that this is done depends
// on the current locale, and may result in the number of
// characters in the string changing.
func UTF8Strdown(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strdown(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Strlen wraps g_utf8_strlen
// 
// The function takes the following parameters:
// 
// 	- p string: pointer to the start of a UTF-8 encoded string 
// 	- max int: the maximum number of bytes to examine. If @max
//   is less than 0, then the string is assumed to be
//   nul-terminated. If @max is 0, @p will not be examined and
//   may be `NULL`. If @max is greater than 0, up to @max
//   bytes are examined 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Computes the length of the string in characters, not including
// the terminating nul character. If the @max&#x2019;th byte falls in the
// middle of a character, the last (partial) character is not counted.
func UTF8Strlen(p string, max int) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  C.glong  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(max)

	cret = C.g_utf8_strlen(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(max)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8Strncpy wraps g_utf8_strncpy
// 
// The function takes the following parameters:
// 
// 	- dest string: buffer to fill with characters from @src 
// 	- src string: UTF-8 encoded string 
// 	- n uint: character count 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Like the standard C [`strncpy()`](man:strncpy) function, but copies a given
// number of characters instead of a given number of bytes.
// 
// The @src string must be valid UTF-8 encoded text. (Use
// [func@GLib.utf8_validate] on all text before trying to use UTF-8 utility
// functions with it.)
// 
// Note you must ensure @dest is at least 4 * @n + 1 to fit the
// largest possible UTF-8 characters
func UTF8Strncpy(dest string, src string, n uint) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(n)

	cret = C.g_utf8_strncpy(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(n)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8Strrchr wraps g_utf8_strrchr
// 
// The function takes the following parameters:
// 
// 	- p string: a nul-terminated UTF-8 encoded string 
// 	- len int: the maximum length of @p 
// 	- c uint32: a Unicode character 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Find the rightmost occurrence of the given Unicode character
// in a UTF-8 encoded string, while limiting the search to @len bytes.
// 
// If @len is `-1`, allow unbounded search.
func UTF8Strrchr(p string, len int, c uint32) string {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var carg3 C.gunichar // in, none, casted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.gunichar(c)

	cret = C.g_utf8_strrchr(carg1, carg2, carg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8Strreverse wraps g_utf8_strreverse
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int: the maximum length of @str to use, in bytes. If @len is negative,
//   then the string is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Reverses a UTF-8 string.
// 
// @str must be valid UTF-8 encoded text. (Use [func@GLib.utf8_validate] on all
// text before trying to use UTF-8 utility functions with it.)
// 
// This function is intended for programmatic uses of reversed strings.
// It pays no attention to decomposed characters, combining marks, byte
// order marks, directional indicators (LRM, LRO, etc) and similar
// characters which might need special handling when reversing a string
// for display purposes.
// 
// Note that unlike [func@GLib.strreverse], this function returns
// newly-allocated memory, which should be freed with [func@GLib.free] when
// no longer needed.
func UTF8Strreverse(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strreverse(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Strup wraps g_utf8_strup
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int: length of @str, in bytes, or -1 if @str is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Converts all Unicode characters in the string that have a case
// to uppercase. The exact manner that this is done depends
// on the current locale, and may result in the number of
// characters in the string increasing. (For instance, the
// German ess-zet will be changed to SS.)
func UTF8Strup(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Substring wraps g_utf8_substring
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- startPos int32: a character offset within @str 
// 	- endPos int32: another character offset within @str,
//   or `-1` to indicate the end of the string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Copies a substring out of a UTF-8 encoded string.
// The substring will contain @end_pos - @start_pos characters.
// 
// Since GLib 2.72, `-1` can be passed to @end_pos to indicate the
// end of the string.
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.glong  // in, none, casted
	var carg3 C.glong  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(startPos)
	carg3 = C.glong(endPos)

	cret = C.g_utf8_substring(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8ToUCS4 wraps g_utf8_to_ucs4
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int32: the maximum length of @str to use, in bytes. If @len is negative,
//   then the string is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- itemsRead int32: location to store number of
//  bytes read, or `NULL`.
//   If `NULL`, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
//   returned in case @str contains a trailing partial
//   character. If an error occurs then the index of the
//   invalid input is stored here. 
// 	- itemsWritten int32: location to store number
//   of characters written or `NULL`. The value here stored does not include
//   the trailing nul character. 
// 	- goret *uint32 
// 	- _goerr error (nullable): an error 
//
// Convert a string from UTF-8 to a 32-bit fixed width representation as UCS-4.
// 
// A trailing nul character (U+0000) will be added to the string after the
// converted text.
func UTF8ToUCS4(str string, len int32) (int32, int32, *uint32, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.glong     // in, none, casted
	var carg3 C.glong     // out, full, casted
	var carg4 C.glong     // out, full, casted
	var cret  *C.gunichar // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_ucs4(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint32
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8ToUCS4Fast wraps g_utf8_to_ucs4_fast
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int32: the maximum length of @str to use, in bytes. If @len is negative,
//   then the string is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- itemsWritten int32: location to store the
//   number of characters in the result, or `NULL`. 
// 	- goret *uint32 
//
// Convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input.
// 
// This function is roughly twice as fast as [func@GLib.utf8_to_ucs4]
// but does no error checking on the input. A trailing nul character (U+0000)
// will be added to the string after the converted text.
func UTF8ToUCS4Fast(str string, len int32) (int32, *uint32) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.glong     // in, none, casted
	var carg3 C.glong     // out, full, casted
	var cret  *C.gunichar // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_ucs4_fast(carg1, carg2, &carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsWritten int32
	var goret        *uint32

	itemsWritten = int32(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")

	return itemsWritten, goret
}

// UTF8ToUTF16 wraps g_utf8_to_utf16
// 
// The function takes the following parameters:
// 
// 	- str string: a UTF-8 encoded string 
// 	- len int32: the maximum length (number of bytes) of @str to use.
//   If @len is negative, then the string is nul-terminated. 
// 
// The function returns the following values:
// 
// 	- itemsRead int32: location to store number of bytes read, or
//   `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will
//   be returned in case @str contains a trailing partial character. If
//   an error occurs then the index of the invalid input is stored here. 
// 	- itemsWritten int32: location to store number
//   of `gunichar2` written, or `NULL`. The value stored here does not include
//   the trailing nul. 
// 	- goret *uint16 
// 	- _goerr error (nullable): an error 
//
// Convert a string from UTF-8 to UTF-16.
// 
// A nul character (U+0000) will be added to the result after the converted text.
func UTF8ToUTF16(str string, len int32) (int32, int32, *uint16, error) {
	var carg1 *C.gchar     // in, none, string
	var carg2 C.glong      // in, none, casted
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gunichar2 // return, transfer: full, C Pointers: 1, Name: guint16, scope: 
	var _cerr *C.GError    // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_utf16(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint16
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint16 (gunichar2*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8TruncateMiddle wraps g_utf8_truncate_middle
// 
// The function takes the following parameters:
// 
// 	- str string: a nul-terminated UTF-8 encoded string 
// 	- truncateLength uint: the new size of @string, in characters, including the ellipsis character 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Cuts off the middle of the string, preserving half of @truncate_length
// characters at the beginning and half at the end.
// 
// If @string is already short enough, this returns a copy of @string.
// If @truncate_length is `0`, an empty string is returned.
func UTF8TruncateMiddle(str string, truncateLength uint) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gsize  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gsize(truncateLength)

	cret = C.g_utf8_truncate_middle(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(truncateLength)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Validate wraps g_utf8_validate
// 
// The function takes the following parameters:
// 
// 	- str string: a pointer to character data 
// 
// The function returns the following values:
// 
// 	- end string: return location for end of valid data 
// 	- goret bool 
//
// Validates UTF-8 encoded text.
// 
// @str is the text to validate; if @str is nul-terminated, then @max_len can be
// `-1`, otherwise @max_len should be the number of bytes to validate.
// 
// If @end is non-`NULL`, then the end of the valid range will be stored there.
// This is the first byte of the first invalid character if some bytes were
// invalid, or the end of the text being validated otherwise &#x2014; either the
// trailing nul byte, or the first byte beyond @max_len (if it&#x2019;s positive).
// 
// Note that `g_utf8_validate()` returns `FALSE` if @max_len is  positive and
// any of the @max_len bytes are nul.
// 
// Returns `TRUE` if all of @str was valid. Many GLib and GTK
// routines require valid UTF-8 as input; so data read from a file
// or the network should be checked with `g_utf8_validate()` before
// doing anything else with it.
func UTF8Validate(str string) (string, bool) {
	var carg1 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize   // implicit
	var carg3 *C.gchar   // out, none, string
	var cret  C.gboolean // return

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_utf8_validate(carg1, carg2, &carg3)
	runtime.KeepAlive(str)

	var end   string
	var goret bool

	end = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	if cret != 0 {
		goret = true
	}

	return end, goret
}

// UTF8ValidateLen wraps g_utf8_validate_len
// 
// The function takes the following parameters:
// 
// 	- str string: a pointer to character data 
// 
// The function returns the following values:
// 
// 	- end string: return location for end of valid data 
// 	- goret bool 
//
// Validates UTF-8 encoded text.
// 
// As with [func@GLib.utf8_validate], but @max_len must be set, and hence this
// function will always return `FALSE` if any of the bytes of @str are nul.
func UTF8ValidateLen(str string) (string, bool) {
	var carg1 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize    // implicit
	var carg3 *C.gchar   // out, none, string
	var cret  C.gboolean // return

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_utf8_validate_len(carg1, carg2, &carg3)
	runtime.KeepAlive(str)

	var end   string
	var goret bool

	end = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	if cret != 0 {
		goret = true
	}

	return end, goret
}

// UuidStringIsValid wraps g_uuid_string_is_valid
// 
// The function takes the following parameters:
// 
// 	- str string: a string representing a UUID 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Parses the string @str and verify if it is a UUID.
// 
// The function accepts the following syntax:
// 
// - simple forms (e.g. `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`)
// 
// Note that hyphens are required within the UUID string itself,
// as per the aforementioned RFC.
func UuidStringIsValid(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uuid_string_is_valid(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UuidStringRandom wraps g_uuid_string_random
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Generates a random UUID (RFC 4122 version 4) as a string. It has the same
// randomness guarantees as #GRand, so must not be used for cryptographic
// purposes such as key generation, nonces, salts or one-time pads.
func UuidStringRandom() string {
	var cret *C.gchar // return, full, string

	cret = C.g_uuid_string_random()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// AsyncQueue wraps GAsyncQueue
//
// An opaque data structure which represents an asynchronous queue.
// 
// It should only be accessed through the `g_async_queue_*` functions.
type AsyncQueue struct {
	*asyncQueue
}

// asyncQueue is the struct that's finalized
type asyncQueue struct {
	native *C.GAsyncQueue
}

// UnsafeAsyncQueueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncQueue) instance() *C.GAsyncQueue {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncQueueFromGlibBorrow is used to convert raw C.GAsyncQueue pointers to go. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibBorrow(p unsafe.Pointer) *AsyncQueue {
	if p == nil {
		return nil
	}
	return &AsyncQueue{&asyncQueue{(*C.GAsyncQueue)(p)}}
}

// UnsafeAsyncQueueFromGlibNone is used to convert raw C.GAsyncQueue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibNone(p unsafe.Pointer) *AsyncQueue {
	C.g_async_queue_ref((*C.GAsyncQueue)(p))
	wrapped := UnsafeAsyncQueueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.asyncQueue,
		func (intern *asyncQueue) {
			C.g_async_queue_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeAsyncQueueFromGlibFull is used to convert raw C.GAsyncQueue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibFull(p unsafe.Pointer) *AsyncQueue {
	wrapped := UnsafeAsyncQueueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncQueue,
		func (intern *asyncQueue) {
			C.g_async_queue_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeAsyncQueueRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [AsyncQueue.UnsafeAsyncQueueUnref], then [AsyncQueue] will leak memory.
func UnsafeAsyncQueueRef(a *AsyncQueue) {
	C.g_async_queue_ref(a.native)
}

// UnsafeAsyncQueueUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncQueue] is expected to work anymore.
func UnsafeAsyncQueueUnref(a *AsyncQueue) {
	C.g_async_queue_unref(a.native)
}

// UnsafeAsyncQueueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncQueueToGlibNone(a *AsyncQueue) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncQueueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncQueueToGlibFull(a *AsyncQueue) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncQueue, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncQueue is invalid from here on
	return _p
}

// NewAsyncQueue wraps g_async_queue_new
// 
// The function returns the following values:
// 
// 	- goret *AsyncQueue 
//
// Creates a new asynchronous queue.
func NewAsyncQueue() *AsyncQueue {
	var cret *C.GAsyncQueue // return, full, converted

	cret = C.g_async_queue_new()

	var goret *AsyncQueue

	goret = UnsafeAsyncQueueFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Length wraps g_async_queue_length
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the length of the queue.
// 
// Actually this function returns the number of data items in
// the queue minus the number of waiting threads, so a negative
// value means waiting threads, and a positive value means available
// entries in the @queue. A return value of 0 could mean n entries
// in the queue and n threads waiting. This can happen due to locking
// of the queue or due to scheduling.
func (queue *AsyncQueue) Length() int32 {
	var carg0 *C.GAsyncQueue // in, none, converted
	var cret  C.gint         // return, none, casted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	cret = C.g_async_queue_length(carg0)
	runtime.KeepAlive(queue)

	var goret int32

	goret = int32(cret)

	return goret
}

// LengthUnlocked wraps g_async_queue_length_unlocked
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the length of the queue.
// 
// Actually this function returns the number of data items in
// the queue minus the number of waiting threads, so a negative
// value means waiting threads, and a positive value means available
// entries in the @queue. A return value of 0 could mean n entries
// in the queue and n threads waiting. This can happen due to locking
// of the queue or due to scheduling.
// 
// This function must be called while holding the @queue's lock.
func (queue *AsyncQueue) LengthUnlocked() int32 {
	var carg0 *C.GAsyncQueue // in, none, converted
	var cret  C.gint         // return, none, casted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	cret = C.g_async_queue_length_unlocked(carg0)
	runtime.KeepAlive(queue)

	var goret int32

	goret = int32(cret)

	return goret
}

// Lock wraps g_async_queue_lock
//
// Acquires the @queue's lock. If another thread is already
// holding the lock, this call will block until the lock
// becomes available.
// 
// Call g_async_queue_unlock() to drop the lock again.
// 
// While holding the lock, you can only call the
// g_async_queue_*_unlocked() functions on @queue. Otherwise,
// deadlock may occur.
func (queue *AsyncQueue) Lock() {
	var carg0 *C.GAsyncQueue // in, none, converted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	C.g_async_queue_lock(carg0)
	runtime.KeepAlive(queue)
}

// Unlock wraps g_async_queue_unlock
//
// Releases the queue's lock.
// 
// Calling this function when you have not acquired
// the with g_async_queue_lock() leads to undefined
// behaviour.
func (queue *AsyncQueue) Unlock() {
	var carg0 *C.GAsyncQueue // in, none, converted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	C.g_async_queue_unlock(carg0)
	runtime.KeepAlive(queue)
}

// BookmarkFile wraps GBookmarkFile
//
// `GBookmarkFile` lets you parse, edit or create files containing bookmarks.
// 
// Bookmarks refer to a URI, along with some meta-data about the resource
// pointed by the URI like its MIME type, the application that is registering
// the bookmark and the icon that should be used to represent the bookmark.
// The data is stored using the
// [Desktop Bookmark Specification](https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/).
// 
// The syntax of the bookmark files is described in detail inside the
// Desktop Bookmark Specification, here is a quick summary: bookmark
// files use a sub-class of the XML Bookmark Exchange Language
// specification, consisting of valid UTF-8 encoded XML, under the
// `&lt;xbel&gt;` root element; each bookmark is stored inside a
// `&lt;bookmark&gt;` element, using its URI: no relative paths can
// be used inside a bookmark file. The bookmark may have a user defined
// title and description, to be used instead of the URI. Under the
// `&lt;metadata&gt;` element, with its owner attribute set to
// `http://freedesktop.org`, is stored the meta-data about a resource
// pointed by its URI. The meta-data consists of the resource's MIME
// type; the applications that have registered a bookmark; the groups
// to which a bookmark belongs to; a visibility flag, used to set the
// bookmark as "private" to the applications and groups that has it
// registered; the URI and MIME type of an icon, to be used when
// displaying the bookmark inside a GUI.
// 
// Here is an example of a bookmark file:
// [bookmarks.xbel](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/glib/tests/bookmarks.xbel)
// 
// A bookmark file might contain more than one bookmark; each bookmark
// is accessed through its URI.
// 
// The important caveat of bookmark files is that when you add a new
// bookmark you must also add the application that is registering it, using
// [method@GLib.BookmarkFile.add_application] or [method@GLib.BookmarkFile.set_application_info].
// If a bookmark has no applications then it won't be dumped when creating
// the on disk representation, using [method@GLib.BookmarkFile.to_data] or
// [method@GLib.BookmarkFile.to_file].
type BookmarkFile struct {
	*bookmarkFile
}

// bookmarkFile is the struct that's finalized
type bookmarkFile struct {
	native *C.GBookmarkFile
}

// UnsafeBookmarkFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BookmarkFile) instance() *C.GBookmarkFile {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBookmarkFileFromGlibBorrow is used to convert raw C.GBookmarkFile pointers to go. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibBorrow(p unsafe.Pointer) *BookmarkFile {
	if p == nil {
		return nil
	}
	return &BookmarkFile{&bookmarkFile{(*C.GBookmarkFile)(p)}}
}

// UnsafeBookmarkFileFromGlibNone is used to convert raw C.GBookmarkFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibNone(p unsafe.Pointer) *BookmarkFile {
	wrapped := UnsafeBookmarkFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeBookmarkFileFromGlibFull is used to convert raw C.GBookmarkFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibFull(p unsafe.Pointer) *BookmarkFile {
	wrapped := UnsafeBookmarkFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.bookmarkFile,
		func (intern *bookmarkFile) {
			C.g_bookmark_file_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeBookmarkFileFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BookmarkFile] is expected to work anymore.
func UnsafeBookmarkFileFree(b *BookmarkFile) {
	C.g_bookmark_file_free(b.native)
}

// UnsafeBookmarkFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBookmarkFileToGlibNone(b *BookmarkFile) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeBookmarkFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeBookmarkFileToGlibFull(b *BookmarkFile) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.bookmarkFile, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // BookmarkFile is invalid from here on
	return _p
}

// NewBookmarkFile wraps g_bookmark_file_new
// 
// The function returns the following values:
// 
// 	- goret *BookmarkFile 
//
// Creates a new empty #GBookmarkFile object.
// 
// Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
// or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
// file.
func NewBookmarkFile() *BookmarkFile {
	var cret *C.GBookmarkFile // return, full, converted

	cret = C.g_bookmark_file_new()

	var goret *BookmarkFile

	goret = UnsafeBookmarkFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// BookmarkFileErrorQuark wraps g_bookmark_file_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func BookmarkFileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_bookmark_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// AddApplication wraps g_bookmark_file_add_application
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- name string (nullable): the name of the application registering the bookmark
//   or %NULL 
// 	- exec string (nullable): command line to be used to launch the bookmark or %NULL 
//
// Adds the application with @name and @exec to the list of
// applications that have registered a bookmark for @uri into
// @bookmark.
// 
// Every bookmark inside a #GBookmarkFile must have at least an
// application registered.  Each application must provide a name, a
// command line useful for launching the bookmark, the number of times
// the bookmark has been registered by the application and the last
// time the application registered this bookmark.
// 
// If @name is %NULL, the name of the application will be the
// same returned by g_get_application_name(); if @exec is %NULL, the
// command line will be a composition of the program name as
// returned by g_get_prgname() and the "\%u" modifier, which will be
// expanded to the bookmark's URI.
// 
// This function will automatically take care of updating the
// registrations count and timestamping in case an application
// with the same @name had already registered a bookmark for
// @uri inside @bookmark.
// 
// If no bookmark for @uri is found, one is created.
func (bookmark *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var carg3 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if name != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if exec != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(exec)))
		defer C.free(unsafe.Pointer(carg3))
	}

	C.g_bookmark_file_add_application(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)
	runtime.KeepAlive(exec)
}

// AddGroup wraps g_bookmark_file_add_group
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- group string: the group name to be added 
//
// Adds @group to the list of groups to which the bookmark for @uri
// belongs to.
// 
// If no bookmark for @uri is found then it is created.
func (bookmark *BookmarkFile) AddGroup(uri string, group string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_add_group(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)
}

// Copy wraps g_bookmark_file_copy
// 
// The function returns the following values:
// 
// 	- goret *BookmarkFile 
//
// Deeply copies a @bookmark #GBookmarkFile object to a new one.
func (bookmark *BookmarkFile) Copy() *BookmarkFile {
	var carg0 *C.GBookmarkFile // in, none, converted
	var cret  *C.GBookmarkFile // return, full, converted

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_copy(carg0)
	runtime.KeepAlive(bookmark)

	var goret *BookmarkFile

	goret = UnsafeBookmarkFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetApplications wraps g_bookmark_file_get_applications
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- length uint: return location of the length of the returned list, or %NULL 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the names of the applications that have registered the
// bookmark for @uri.
// 
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) GetApplications(uri string) (uint, []string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_applications(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetDescription wraps g_bookmark_file_get_description
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the description of the bookmark for @uri.
// 
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) GetDescription(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_description(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetGroups wraps g_bookmark_file_get_groups
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- length uint: return location for the length of the returned string, or %NULL 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the list of group names of the bookmark for @uri.
// 
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
// 
// The returned array is %NULL terminated, so @length may optionally
// be %NULL.
func (bookmark *BookmarkFile) GetGroups(uri string) (uint, []string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_groups(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetIcon wraps g_bookmark_file_get_icon
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- href string: return location for the icon's location or %NULL 
// 	- mimeType string: return location for the icon's MIME type or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets the icon of the bookmark for @uri.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) GetIcon(uri string) (string, string, bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // out, full, string
	var carg3 *C.gchar         // out, full, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_icon(carg0, carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var href     string
	var mimeType string
	var goret    bool
	var _goerr   error

	href = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	mimeType = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return href, mimeType, goret, _goerr
}

// GetIsPrivate wraps g_bookmark_file_get_is_private
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Gets whether the private flag of the bookmark for @uri is set.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that the private flag cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) GetIsPrivate(uri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_is_private(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetMimeType wraps g_bookmark_file_get_mime_type
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Retrieves the MIME type of the resource pointed by @uri.
// 
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
// event that the MIME type cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) GetMimeType(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_mime_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSize wraps g_bookmark_file_get_size
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the number of bookmarks inside @bookmark.
func (bookmark *BookmarkFile) GetSize() int32 {
	var carg0 *C.GBookmarkFile // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_get_size(carg0)
	runtime.KeepAlive(bookmark)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetTitle wraps g_bookmark_file_get_title
// 
// The function takes the following parameters:
// 
// 	- uri string (nullable): a valid URI or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Returns the title of the bookmark for @uri.
// 
// If @uri is %NULL, the title of @bookmark is returned.
// 
// In the event the URI cannot be found, %NULL is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) GetTitle(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_bookmark_file_get_title(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetUris wraps g_bookmark_file_get_uris
// 
// The function returns the following values:
// 
// 	- length uint: return location for the number of returned URIs, or %NULL 
// 	- goret []string 
//
// Returns all URIs of the bookmarks in the bookmark file @bookmark.
// The array of returned URIs will be %NULL-terminated, so @length may
// optionally be %NULL.
func (bookmark *BookmarkFile) GetUris() (uint, []string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_get_uris(carg0, &carg1)
	runtime.KeepAlive(bookmark)

	var length uint
	var goret  []string

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return length, goret
}

// HasApplication wraps g_bookmark_file_has_application
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- name string: the name of the application 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Checks whether the bookmark for @uri inside @bookmark has been
// registered by application @name.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) HasApplication(uri string, name string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_has_application(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasGroup wraps g_bookmark_file_has_group
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- group string: the group name to be searched 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Checks whether @group appears in the list of groups to which
// the bookmark for @uri belongs to.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) HasGroup(uri string, group string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_has_group(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasItem wraps g_bookmark_file_has_item
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks whether the desktop bookmark has an item with its URI set to @uri.
func (bookmark *BookmarkFile) HasItem(uri string) bool {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_has_item(carg0, carg1)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadFromData wraps g_bookmark_file_load_from_data
// 
// The function takes the following parameters:
// 
// 	- data string: desktop bookmarks
//    loaded in memory 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads a bookmark file from memory into an empty #GBookmarkFile
// structure.  If the object cannot be created then @error is set to a
// #GBookmarkFileError.
func (bookmark *BookmarkFile) LoadFromData(data string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_bookmark_file_load_from_data(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(data)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromDataDirs wraps g_bookmark_file_load_from_data_dirs
// 
// The function takes the following parameters:
// 
// 	- file string: a relative path to a filename to open and parse 
// 
// The function returns the following values:
// 
// 	- fullPath string: return location for a string
//    containing the full path of the file, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// This function looks for a desktop bookmark file named @file in the
// paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
// loads the file into @bookmark and returns the file's full path in
// @full_path.  If the file could not be loaded then @error is
// set to either a #GFileError or #GBookmarkFileError.
func (bookmark *BookmarkFile) LoadFromDataDirs(file string) (string, bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // out, full, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_load_from_data_dirs(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(file)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromFile wraps g_bookmark_file_load_from_file
// 
// The function takes the following parameters:
// 
// 	- filename string: the path of a filename to load, in the
//     GLib file name encoding 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads a desktop bookmark file into an empty #GBookmarkFile structure.
// If the file could not be loaded then @error is set to either a #GFileError
// or #GBookmarkFileError.
func (bookmark *BookmarkFile) LoadFromFile(filename string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_load_from_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MoveItem wraps g_bookmark_file_move_item
// 
// The function takes the following parameters:
// 
// 	- oldUri string: a valid URI 
// 	- newUri string (nullable): a valid URI, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
// existing bookmark for @new_uri will be overwritten.  If @new_uri is
// %NULL, then the bookmark is removed.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
func (bookmark *BookmarkFile) MoveItem(oldUri string, newUri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(oldUri)))
	defer C.free(unsafe.Pointer(carg1))
	if newUri != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(newUri)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_bookmark_file_move_item(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(oldUri)
	runtime.KeepAlive(newUri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveApplication wraps g_bookmark_file_remove_application
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- name string: the name of the application 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes application registered with @name from the list of applications
// that have registered a bookmark for @uri inside @bookmark.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
// In the event that no application with name @app_name has registered
// a bookmark for @uri,  %FALSE is returned and error is set to
// %G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
func (bookmark *BookmarkFile) RemoveApplication(uri string, name string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_remove_application(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveGroup wraps g_bookmark_file_remove_group
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- group string: the group name to be removed 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes @group from the list of groups to which the bookmark
// for @uri belongs to.
// 
// In the event the URI cannot be found, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
// In the event no group was defined, %FALSE is returned and
// @error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
func (bookmark *BookmarkFile) RemoveGroup(uri string, group string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_remove_group(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveItem wraps g_bookmark_file_remove_item
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes the bookmark for @uri from the bookmark file @bookmark.
func (bookmark *BookmarkFile) RemoveItem(uri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_remove_item(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDescription wraps g_bookmark_file_set_description
// 
// The function takes the following parameters:
// 
// 	- uri string (nullable): a valid URI or %NULL 
// 	- description string: a string 
//
// Sets @description as the description of the bookmark for @uri.
// 
// If @uri is %NULL, the description of @bookmark is set.
// 
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetDescription(uri string, description string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_description(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(description)
}

// SetGroups wraps g_bookmark_file_set_groups
// 
// The function takes the following parameters:
// 
// 	- uri string: an item's URI 
// 	- groups []string (nullable): an array of
//    group names, or %NULL to remove all groups 
//
// Sets a list of group names for the item with URI @uri.  Each previously
// set group name list is removed.
// 
// If @uri cannot be found then an item for it is created.
func (bookmark *BookmarkFile) SetGroups(uri string, groups []string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 **C.gchar        // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), length-by: carg3)
	var carg3 C.gsize          // implicit

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	_ = groups
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []string (const gchar**) because of unimplemented: inner pointers in array")

	C.g_bookmark_file_set_groups(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(groups)
}

// SetIcon wraps g_bookmark_file_set_icon
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- href string (nullable): the URI of the icon for the bookmark, or %NULL 
// 	- mimeType string: the MIME type of the icon for the bookmark 
//
// Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
// the currently set icon. @href can either be a full URL for the icon
// file or the icon name following the Icon Naming specification.
// 
// If no bookmark for @uri is found one is created.
func (bookmark *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var carg3 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if href != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(href)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_bookmark_file_set_icon(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(href)
	runtime.KeepAlive(mimeType)
}

// SetIsPrivate wraps g_bookmark_file_set_is_private
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- isPrivate bool: %TRUE if the bookmark should be marked as private 
//
// Sets the private flag of the bookmark for @uri.
// 
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gboolean       // in

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if isPrivate {
		carg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(isPrivate)
}

// SetMimeType wraps g_bookmark_file_set_mime_type
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI 
// 	- mimeType string: a MIME type 
//
// Sets @mime_type as the MIME type of the bookmark for @uri.
// 
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetMimeType(uri string, mimeType string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_mime_type(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(mimeType)
}

// SetTitle wraps g_bookmark_file_set_title
// 
// The function takes the following parameters:
// 
// 	- uri string (nullable): a valid URI or %NULL 
// 	- title string: a UTF-8 encoded string 
//
// Sets @title as the title of the bookmark for @uri inside the
// bookmark file @bookmark.
// 
// If @uri is %NULL, the title of @bookmark is set.
// 
// If a bookmark for @uri cannot be found then it is created.
func (bookmark *BookmarkFile) SetTitle(uri string, title string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_title(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(title)
}

// ToData wraps g_bookmark_file_to_data
// 
// The function returns the following values:
// 
// 	- length uint: return location for the length of the returned string, or %NULL 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// This function outputs @bookmark as a string.
func (bookmark *BookmarkFile) ToData() (uint, string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 C.gsize          // out, full, casted
	var cret  *C.gchar         // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_to_data(carg0, &carg1, &_cerr)
	runtime.KeepAlive(bookmark)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ToFile wraps g_bookmark_file_to_file
// 
// The function takes the following parameters:
// 
// 	- filename string: path of the output file 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// This function outputs @bookmark into a file.  The write process is
// guaranteed to be atomic by using g_file_set_contents() internally.
func (bookmark *BookmarkFile) ToFile(filename string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_to_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ByteArray wraps GByteArray
//
// Contains the public fields of a GByteArray.
type ByteArray struct {
	*byteArray
}

// byteArray is the struct that's finalized
type byteArray struct {
	native *C.GByteArray
}

// UnsafeByteArrayToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *ByteArray) instance() *C.GByteArray {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeByteArrayFromGlibBorrow is used to convert raw C.GByteArray pointers to go. This is used by the bindings internally.
func UnsafeByteArrayFromGlibBorrow(p unsafe.Pointer) *ByteArray {
	if p == nil {
		return nil
	}
	return &ByteArray{&byteArray{(*C.GByteArray)(p)}}
}

// UnsafeByteArrayFromGlibNone is used to convert raw C.GByteArray pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeByteArrayFromGlibNone(p unsafe.Pointer) *ByteArray {
	wrapped := UnsafeByteArrayFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ByteArray because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeByteArrayFromGlibFull is used to convert raw C.GByteArray pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeByteArrayFromGlibFull(p unsafe.Pointer) *ByteArray {
	wrapped := UnsafeByteArrayFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.byteArray,
		func (intern *byteArray) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeByteArrayFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ByteArray] is expected to work anymore.
func UnsafeByteArrayFree(b *ByteArray) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeByteArrayToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeByteArrayToGlibNone(b *ByteArray) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeByteArrayToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeByteArrayToGlibFull(b *ByteArray) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.byteArray, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // ByteArray is invalid from here on
	return _p
}

// Bytes wraps GBytes
//
// A simple reference counted data type representing an immutable sequence of
// zero or more bytes from an unspecified origin.
// 
// The purpose of a `GBytes` is to keep the memory region that it holds
// alive for as long as anyone holds a reference to the bytes.  When
// the last reference count is dropped, the memory is released. Multiple
// unrelated callers can use byte data in the `GBytes` without coordinating
// their activities, resting assured that the byte data will not change or
// move while they hold a reference.
// 
// A `GBytes` can come from many different origins that may have
// different procedures for freeing the memory region.  Examples are
// memory from [func@GLib.malloc], from memory slices, from a
// [struct@GLib.MappedFile] or memory from other allocators.
// 
// `GBytes` work well as keys in [struct@GLib.HashTable]. Use
// [method@GLib.Bytes.equal] and [method@GLib.Bytes.hash] as parameters to
// [func@GLib.HashTable.new] or [func@GLib.HashTable.new_full].
// `GBytes` can also be used as keys in a [struct@GLib.Tree] by passing the
// [method@GLib.Bytes.compare] function to [ctor@GLib.Tree.new].
// 
// The data pointed to by this bytes must not be modified. For a mutable
// array of bytes see [struct@GLib.ByteArray]. Use
// [method@GLib.Bytes.unref_to_array] to create a mutable array for a `GBytes`
// sequence. To create an immutable `GBytes` from a mutable
// [struct@GLib.ByteArray], use the [func@GLib.ByteArray.free_to_bytes]
// function.
type Bytes struct {
	*bytes
}

// bytes is the struct that's finalized
type bytes struct {
	native *C.GBytes
}

// UnsafeBytesToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *Bytes) instance() *C.GBytes {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBytesFromGlibBorrow is used to convert raw C.GBytes pointers to go. This is used by the bindings internally.
func UnsafeBytesFromGlibBorrow(p unsafe.Pointer) *Bytes {
	if p == nil {
		return nil
	}
	return &Bytes{&bytes{(*C.GBytes)(p)}}
}

// UnsafeBytesFromGlibNone is used to convert raw C.GBytes pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeBytesFromGlibNone(p unsafe.Pointer) *Bytes {
	C.g_bytes_ref((*C.GBytes)(p))
	wrapped := UnsafeBytesFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.bytes,
		func (intern *bytes) {
			C.g_bytes_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeBytesFromGlibFull is used to convert raw C.GBytes pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeBytesFromGlibFull(p unsafe.Pointer) *Bytes {
	wrapped := UnsafeBytesFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.bytes,
		func (intern *bytes) {
			C.g_bytes_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeBytesRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Bytes.UnsafeBytesUnref], then [Bytes] will leak memory.
func UnsafeBytesRef(b *Bytes) {
	C.g_bytes_ref(b.native)
}

// UnsafeBytesUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Bytes] is expected to work anymore.
func UnsafeBytesUnref(b *Bytes) {
	C.g_bytes_unref(b.native)
}

// UnsafeBytesToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBytesToGlibNone(b *Bytes) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeBytesToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeBytesToGlibFull(b *Bytes) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.bytes, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // Bytes is invalid from here on
	return _p
}

// GetSize wraps g_bytes_get_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Get the size of the byte data in the [struct@GLib.Bytes].
// 
// This function will always return the same value for a given `GBytes`.
func (bytes *Bytes) GetSize() uint {
	var carg0 *C.GBytes // in, none, converted
	var cret  C.gsize   // return, none, casted

	carg0 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))

	cret = C.g_bytes_get_size(carg0)
	runtime.KeepAlive(bytes)

	var goret uint

	goret = uint(cret)

	return goret
}

// NewFromBytes wraps g_bytes_new_from_bytes
// 
// The function takes the following parameters:
// 
// 	- offset uint: offset which subsection starts at 
// 	- length uint: length of subsection 
// 
// The function returns the following values:
// 
// 	- goret *Bytes 
//
// Creates a [struct@GLib.Bytes] which is a subsection of another `GBytes`.
// 
// The @offset + @length may not be longer than the size of @bytes.
// 
// A reference to @bytes will be held by the newly created `GBytes` until
// the byte data is no longer needed.
// 
// Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
// @bytes will be returned with the reference count incremented by 1. If @bytes
// is a slice of another `GBytes`, then the resulting `GBytes` will reference
// the same `GBytes` instead of @bytes. This allows consumers to simplify the
// usage of `GBytes` when asynchronously writing to streams.
func (bytes *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var carg0 *C.GBytes // in, none, converted
	var carg1 C.gsize   // in, none, casted
	var carg2 C.gsize   // in, none, casted
	var cret  *C.GBytes // return, full, converted

	carg0 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))
	carg1 = C.gsize(offset)
	carg2 = C.gsize(length)

	cret = C.g_bytes_new_from_bytes(carg0, carg1, carg2)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(length)

	var goret *Bytes

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Checksum wraps GChecksum
//
// GLib provides a generic API for computing checksums (or &#x2018;digests&#x2019;)
// for a sequence of arbitrary bytes, using various hashing algorithms
// like MD5, SHA-1 and SHA-256. Checksums are commonly used in various
// environments and specifications.
// 
// To create a new `GChecksum`, use [ctor@GLib.Checksum.new]. To free
// a `GChecksum`, use [method@GLib.Checksum.free].
// 
// GLib supports incremental checksums using the `GChecksum` data
// structure, by calling [method@GLib.Checksum.update] as long as there&#x2019;s data
// available and then using [method@GLib.Checksum.get_string] or
// [method@GLib.Checksum.get_digest] to compute the checksum and return it
// either as a string in hexadecimal form, or as a raw sequence of bytes. To
// compute the checksum for binary blobs and nul-terminated strings in
// one go, use the convenience functions [func@GLib.compute_checksum_for_data]
// and [func@GLib.compute_checksum_for_string], respectively.
type Checksum struct {
	*checksum
}

// checksum is the struct that's finalized
type checksum struct {
	native *C.GChecksum
}

// UnsafeChecksumToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *Checksum) instance() *C.GChecksum {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeChecksumFromGlibBorrow is used to convert raw C.GChecksum pointers to go. This is used by the bindings internally.
func UnsafeChecksumFromGlibBorrow(p unsafe.Pointer) *Checksum {
	if p == nil {
		return nil
	}
	return &Checksum{&checksum{(*C.GChecksum)(p)}}
}

// UnsafeChecksumFromGlibNone is used to convert raw C.GChecksum pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeChecksumFromGlibNone(p unsafe.Pointer) *Checksum {
	wrapped := UnsafeChecksumFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeChecksumFromGlibFull is used to convert raw C.GChecksum pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeChecksumFromGlibFull(p unsafe.Pointer) *Checksum {
	wrapped := UnsafeChecksumFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.checksum,
		func (intern *checksum) {
			C.g_checksum_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeChecksumFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Checksum] is expected to work anymore.
func UnsafeChecksumFree(c *Checksum) {
	C.g_checksum_free(c.native)
}

// UnsafeChecksumToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeChecksumToGlibNone(c *Checksum) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeChecksumToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeChecksumToGlibFull(c *Checksum) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.checksum, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // Checksum is invalid from here on
	return _p
}

// NewChecksum wraps g_checksum_new
// 
// The function takes the following parameters:
// 
// 	- checksumType ChecksumType: the desired type of checksum 
// 
// The function returns the following values:
// 
// 	- goret *Checksum (nullable) 
//
// Creates a new #GChecksum, using the checksum algorithm @checksum_type.
// If the @checksum_type is not known, %NULL is returned.
// A #GChecksum can be used to compute the checksum, or digest, of an
// arbitrary binary blob, using different hashing algorithms.
// 
// A #GChecksum works by feeding a binary blob through g_checksum_update()
// until there is data to be checked; the digest can then be extracted
// using g_checksum_get_string(), which will return the checksum as a
// hexadecimal string; or g_checksum_get_digest(), which will return a
// vector of raw bytes. Once either g_checksum_get_string() or
// g_checksum_get_digest() have been called on a #GChecksum, the checksum
// will be closed and it won't be possible to call g_checksum_update()
// on it anymore.
func NewChecksum(checksumType ChecksumType) *Checksum {
	var carg1 C.GChecksumType // in, none, casted
	var cret  *C.GChecksum    // return, full, converted, nullable

	carg1 = C.GChecksumType(checksumType)

	cret = C.g_checksum_new(carg1)
	runtime.KeepAlive(checksumType)

	var goret *Checksum

	if cret != nil {
		goret = UnsafeChecksumFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ChecksumTypeGetLength wraps g_checksum_type_get_length
// 
// The function takes the following parameters:
// 
// 	- checksumType ChecksumType: a #GChecksumType 
// 
// The function returns the following values:
// 
// 	- goret int 
//
// Gets the length in bytes of digests of type @checksum_type
func ChecksumTypeGetLength(checksumType ChecksumType) int {
	var carg1 C.GChecksumType // in, none, casted
	var cret  C.gssize        // return, none, casted

	carg1 = C.GChecksumType(checksumType)

	cret = C.g_checksum_type_get_length(carg1)
	runtime.KeepAlive(checksumType)

	var goret int

	goret = int(cret)

	return goret
}

// Copy wraps g_checksum_copy
// 
// The function returns the following values:
// 
// 	- goret *Checksum 
//
// Copies a #GChecksum. If @checksum has been closed, by calling
// g_checksum_get_string() or g_checksum_get_digest(), the copied
// checksum will be closed as well.
func (checksum *Checksum) Copy() *Checksum {
	var carg0 *C.GChecksum // in, none, converted
	var cret  *C.GChecksum // return, full, converted

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	cret = C.g_checksum_copy(carg0)
	runtime.KeepAlive(checksum)

	var goret *Checksum

	goret = UnsafeChecksumFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_checksum_get_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the digest as a hexadecimal string.
// 
// Once this function has been called the #GChecksum can no longer be
// updated with g_checksum_update().
// 
// The hexadecimal characters will be lower case.
func (checksum *Checksum) GetString() string {
	var carg0 *C.GChecksum // in, none, converted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	cret = C.g_checksum_get_string(carg0)
	runtime.KeepAlive(checksum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Reset wraps g_checksum_reset
//
// Resets the state of the @checksum back to its initial state.
func (checksum *Checksum) Reset() {
	var carg0 *C.GChecksum // in, none, converted

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	C.g_checksum_reset(carg0)
	runtime.KeepAlive(checksum)
}

// Update wraps g_checksum_update
// 
// The function takes the following parameters:
// 
// 	- data []uint8: buffer used to compute the checksum 
//
// Feeds @data into an existing #GChecksum. The checksum must still be
// open, that is g_checksum_get_string() or g_checksum_get_digest() must
// not have been called on @checksum.
func (checksum *Checksum) Update(data []uint8) {
	var carg0 *C.GChecksum // in, none, converted
	var carg1 *C.guchar    // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize     // implicit

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	C.g_checksum_update(carg0, carg1, carg2)
	runtime.KeepAlive(checksum)
	runtime.KeepAlive(data)
}

// Cond wraps GCond
//
// The #GCond struct is an opaque data structure that represents a
// condition. Threads can block on a #GCond if they find a certain
// condition to be false. If other threads change the state of this
// condition they signal the #GCond, and that causes the waiting
// threads to be woken up.
// 
// Consider the following example of a shared variable.  One or more
// threads can wait for data to be published to the variable and when
// another thread publishes the data, it can signal one of the waiting
// threads to wake up to collect the data.
// 
// Here is an example for using GCond to block a thread until a condition
// is satisfied:
// |[&lt;!-- language="C" --&gt;
//   gpointer current_data = NULL;
//   GMutex data_mutex;
//   GCond data_cond;
// 
//   void
//   push_data (gpointer data)
//   {
//     g_mutex_lock (&amp;data_mutex);
//     current_data = data;
//     g_cond_signal (&amp;data_cond);
//     g_mutex_unlock (&amp;data_mutex);
//   }
// 
//   gpointer
//   pop_data (void)
//   {
//     gpointer data;
// 
//     g_mutex_lock (&amp;data_mutex);
//     while (!current_data)
//       g_cond_wait (&amp;data_cond, &amp;data_mutex);
//     data = current_data;
//     current_data = NULL;
//     g_mutex_unlock (&amp;data_mutex);
// 
//     return data;
//   }
// ]|
// Whenever a thread calls pop_data() now, it will wait until
// current_data is non-%NULL, i.e. until some other thread
// has called push_data().
// 
// The example shows that use of a condition variable must always be
// paired with a mutex.  Without the use of a mutex, there would be a
// race between the check of @current_data by the while loop in
// pop_data() and waiting. Specifically, another thread could set
// @current_data after the check, and signal the cond (with nobody
// waiting on it) before the first thread goes to sleep. #GCond is
// specifically useful for its ability to release the mutex and go
// to sleep atomically.
// 
// It is also important to use the g_cond_wait() and g_cond_wait_until()
// functions only inside a loop which checks for the condition to be
// true.  See g_cond_wait() for an explanation of why the condition may
// not be true even after it returns.
// 
// If a #GCond is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call g_cond_init()
// on it and g_cond_clear() when done.
// 
// A #GCond should only be accessed via the g_cond_ functions.
type Cond struct {
	*cond
}

// cond is the struct that's finalized
type cond struct {
	native *C.GCond
}

// UnsafeCondToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *Cond) instance() *C.GCond {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCondFromGlibBorrow is used to convert raw C.GCond pointers to go. This is used by the bindings internally.
func UnsafeCondFromGlibBorrow(p unsafe.Pointer) *Cond {
	if p == nil {
		return nil
	}
	return &Cond{&cond{(*C.GCond)(p)}}
}

// UnsafeCondFromGlibNone is used to convert raw C.GCond pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeCondFromGlibNone(p unsafe.Pointer) *Cond {
	wrapped := UnsafeCondFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Cond because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeCondFromGlibFull is used to convert raw C.GCond pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeCondFromGlibFull(p unsafe.Pointer) *Cond {
	wrapped := UnsafeCondFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.cond,
		func (intern *cond) {
			C.g_cond_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeCondFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Cond] is expected to work anymore.
func UnsafeCondFree(c *Cond) {
	C.g_cond_free(c.native)
}

// UnsafeCondToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCondToGlibNone(c *Cond) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeCondToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeCondToGlibFull(c *Cond) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.cond, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // Cond is invalid from here on
	return _p
}

// Broadcast wraps g_cond_broadcast
//
// If threads are waiting for @cond, all of them are unblocked.
// If no threads are waiting for @cond, this function has no effect.
// It is good practice to lock the same mutex as the waiting threads
// while calling this function, though not required.
func (cond *Cond) Broadcast() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_broadcast(carg0)
	runtime.KeepAlive(cond)
}

// Clear wraps g_cond_clear
//
// Frees the resources allocated to a #GCond with g_cond_init().
// 
// This function should not be used with a #GCond that has been
// statically allocated.
// 
// Calling g_cond_clear() for a #GCond on which threads are
// blocking leads to undefined behaviour.
func (cond *Cond) Clear() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_clear(carg0)
	runtime.KeepAlive(cond)
}

// Init wraps g_cond_init
//
// Initialises a #GCond so that it can be used.
// 
// This function is useful to initialise a #GCond that has been
// allocated as part of a larger structure.  It is not necessary to
// initialise a #GCond that has been statically allocated.
// 
// To undo the effect of g_cond_init() when a #GCond is no longer
// needed, use g_cond_clear().
// 
// Calling g_cond_init() on an already-initialised #GCond leads
// to undefined behaviour.
func (cond *Cond) Init() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_init(carg0)
	runtime.KeepAlive(cond)
}

// Signal wraps g_cond_signal
//
// If threads are waiting for @cond, at least one of them is unblocked.
// If no threads are waiting for @cond, this function has no effect.
// It is good practice to hold the same lock as the waiting thread
// while calling this function, though not required.
func (cond *Cond) Signal() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_signal(carg0)
	runtime.KeepAlive(cond)
}

// Data wraps GData
//
// An opaque data structure that represents a keyed data list.
// 
// See also: [Keyed data lists](datalist-and-dataset.html).
type Data struct {
	*data
}

// data is the struct that's finalized
type data struct {
	native *C.GData
}

// UnsafeDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *Data) instance() *C.GData {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataFromGlibBorrow is used to convert raw C.GData pointers to go. This is used by the bindings internally.
func UnsafeDataFromGlibBorrow(p unsafe.Pointer) *Data {
	if p == nil {
		return nil
	}
	return &Data{&data{(*C.GData)(p)}}
}

// UnsafeDataFromGlibNone is used to convert raw C.GData pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDataFromGlibNone(p unsafe.Pointer) *Data {
	wrapped := UnsafeDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Data because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDataFromGlibFull is used to convert raw C.GData pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDataFromGlibFull(p unsafe.Pointer) *Data {
	wrapped := UnsafeDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.data,
		func (intern *data) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDataFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Data] is expected to work anymore.
func UnsafeDataFree(d *Data) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataToGlibNone(d *Data) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDataToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDataToGlibFull(d *Data) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.data, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // Data is invalid from here on
	return _p
}

// DebugKey wraps GDebugKey
//
// Associates a string with a bit flag.
// Used in g_parse_debug_string().
type DebugKey struct {
	*debugKey
}

// debugKey is the struct that's finalized
type debugKey struct {
	native *C.GDebugKey
}

// UnsafeDebugKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DebugKey) instance() *C.GDebugKey {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDebugKeyFromGlibBorrow is used to convert raw C.GDebugKey pointers to go. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibBorrow(p unsafe.Pointer) *DebugKey {
	if p == nil {
		return nil
	}
	return &DebugKey{&debugKey{(*C.GDebugKey)(p)}}
}

// UnsafeDebugKeyFromGlibNone is used to convert raw C.GDebugKey pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibNone(p unsafe.Pointer) *DebugKey {
	wrapped := UnsafeDebugKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DebugKey because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDebugKeyFromGlibFull is used to convert raw C.GDebugKey pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibFull(p unsafe.Pointer) *DebugKey {
	wrapped := UnsafeDebugKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.debugKey,
		func (intern *debugKey) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDebugKeyFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DebugKey] is expected to work anymore.
func UnsafeDebugKeyFree(d *DebugKey) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDebugKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDebugKeyToGlibNone(d *DebugKey) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDebugKeyToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDebugKeyToGlibFull(d *DebugKey) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.debugKey, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DebugKey is invalid from here on
	return _p
}

// Dir wraps GDir
//
// An opaque structure representing an opened directory.
type Dir struct {
	*dir
}

// dir is the struct that's finalized
type dir struct {
	native *C.GDir
}

// UnsafeDirToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *Dir) instance() *C.GDir {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDirFromGlibBorrow is used to convert raw C.GDir pointers to go. This is used by the bindings internally.
func UnsafeDirFromGlibBorrow(p unsafe.Pointer) *Dir {
	if p == nil {
		return nil
	}
	return &Dir{&dir{(*C.GDir)(p)}}
}

// UnsafeDirFromGlibNone is used to convert raw C.GDir pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDirFromGlibNone(p unsafe.Pointer) *Dir {
	C.g_dir_ref((*C.GDir)(p))
	wrapped := UnsafeDirFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.dir,
		func (intern *dir) {
			C.g_dir_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeDirFromGlibFull is used to convert raw C.GDir pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDirFromGlibFull(p unsafe.Pointer) *Dir {
	wrapped := UnsafeDirFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dir,
		func (intern *dir) {
			C.g_dir_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeDirRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Dir.UnsafeDirUnref], then [Dir] will leak memory.
func UnsafeDirRef(d *Dir) {
	C.g_dir_ref(d.native)
}

// UnsafeDirUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Dir] is expected to work anymore.
func UnsafeDirUnref(d *Dir) {
	C.g_dir_unref(d.native)
}

// UnsafeDirToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDirToGlibNone(d *Dir) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDirToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDirToGlibFull(d *Dir) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dir, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // Dir is invalid from here on
	return _p
}

// DirOpen wraps g_dir_open
// 
// The function takes the following parameters:
// 
// 	- path string: the path to the directory you are interested in. On Unix
//         in the on-disk encoding. On Windows in UTF-8 
// 	- flags uint: Currently must be set to 0. Reserved for future use. 
// 
// The function returns the following values:
// 
// 	- goret *Dir 
// 	- _goerr error (nullable): an error 
//
// Opens a directory for reading. The names of the files in the
// directory can then be retrieved using g_dir_read_name().  Note
// that the ordering is not defined.
func DirOpen(path string, flags uint) (*Dir, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.guint   // in, none, casted
	var cret  *C.GDir   // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(flags)

	cret = C.g_dir_open(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(flags)

	var goret  *Dir
	var _goerr error

	goret = UnsafeDirFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DirMakeTmp wraps g_dir_make_tmp
// 
// The function takes the following parameters:
// 
// 	- tmpl string (nullable): Template for directory name,
//   as in g_mkdtemp(), basename only, or %NULL for a default template 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Creates a subdirectory in the preferred directory for temporary
// files (as returned by g_get_tmp_dir()).
// 
// @tmpl should be a string in the GLib file name encoding containing
// a sequence of six 'X' characters, as the parameter to g_mkstemp().
// However, unlike these functions, the template should only be a
// basename, no directory components are allowed. If template is
// %NULL, a default template is used.
// 
// Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not
// modified, and might thus be a read-only literal string.
func DirMakeTmp(tmpl string) (string, error) {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_dir_make_tmp(carg1, &_cerr)
	runtime.KeepAlive(tmpl)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_dir_close
//
// Closes the directory immediately and decrements the reference count.
// 
// Once the reference count reaches zero, the `GDir` structure itself will be
// freed. Prior to GLib 2.80, `GDir` was not reference counted.
// 
// It is an error to call any of the `GDir` methods other than
// [method@GLib.Dir.ref] and [method@GLib.Dir.unref] on a `GDir` after calling
// [method@GLib.Dir.close] on it.
func (dir *Dir) Close() {
	var carg0 *C.GDir // in, none, converted

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	C.g_dir_close(carg0)
	runtime.KeepAlive(dir)
}

// ReadName wraps g_dir_read_name
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Retrieves the name of another entry in the directory, or %NULL.
// The order of entries returned from this function is not defined,
// and may vary by file system or other operating-system dependent
// factors.
// 
// %NULL may also be returned in case of errors. On Unix, you can
// check `errno` to find out if %NULL was returned because of an error.
// 
// On Unix, the '.' and '..' entries are omitted, and the returned
// name is in the on-disk encoding.
// 
// On Windows, as is true of all GLib functions which operate on
// filenames, the returned name is in UTF-8.
func (dir *Dir) ReadName() string {
	var carg0 *C.GDir  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	cret = C.g_dir_read_name(carg0)
	runtime.KeepAlive(dir)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Rewind wraps g_dir_rewind
//
// Resets the given directory. The next call to g_dir_read_name()
// will return the first entry again.
func (dir *Dir) Rewind() {
	var carg0 *C.GDir // in, none, converted

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	C.g_dir_rewind(carg0)
	runtime.KeepAlive(dir)
}

// HashTableIter wraps GHashTableIter
//
// A GHashTableIter structure represents an iterator that can be used
// to iterate over the elements of a #GHashTable. GHashTableIter
// structures are typically allocated on the stack and then initialized
// with g_hash_table_iter_init().
// 
// The iteration order of a #GHashTableIter over the keys/values in a hash
// table is not defined.
type HashTableIter struct {
	*hashTableIter
}

// hashTableIter is the struct that's finalized
type hashTableIter struct {
	native *C.GHashTableIter
}

// UnsafeHashTableIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *HashTableIter) instance() *C.GHashTableIter {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHashTableIterFromGlibBorrow is used to convert raw C.GHashTableIter pointers to go. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibBorrow(p unsafe.Pointer) *HashTableIter {
	if p == nil {
		return nil
	}
	return &HashTableIter{&hashTableIter{(*C.GHashTableIter)(p)}}
}

// UnsafeHashTableIterFromGlibNone is used to convert raw C.GHashTableIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibNone(p unsafe.Pointer) *HashTableIter {
	wrapped := UnsafeHashTableIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to HashTableIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHashTableIterFromGlibFull is used to convert raw C.GHashTableIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibFull(p unsafe.Pointer) *HashTableIter {
	wrapped := UnsafeHashTableIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hashTableIter,
		func (intern *hashTableIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHashTableIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [HashTableIter] is expected to work anymore.
func UnsafeHashTableIterFree(h *HashTableIter) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHashTableIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHashTableIterToGlibNone(h *HashTableIter) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHashTableIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHashTableIterToGlibFull(h *HashTableIter) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hashTableIter, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // HashTableIter is invalid from here on
	return _p
}

// Remove wraps g_hash_table_iter_remove
//
// Removes the key/value pair currently pointed to by the iterator
// from its associated #GHashTable. Can only be called after
// g_hash_table_iter_next() returned %TRUE, and cannot be called
// more than once for the same key/value pair.
// 
// If the #GHashTable was created using g_hash_table_new_full(),
// the key and value are freed using the supplied destroy functions,
// otherwise you have to make sure that any dynamically allocated
// values are freed yourself.
// 
// It is safe to continue iterating the #GHashTable afterward:
// |[&lt;!-- language="C" --&gt;
// while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
//   {
//     if (condition)
//       g_hash_table_iter_remove (&amp;iter);
//   }
// ]|
func (iter *HashTableIter) Remove() {
	var carg0 *C.GHashTableIter // in, none, converted

	carg0 = (*C.GHashTableIter)(UnsafeHashTableIterToGlibNone(iter))

	C.g_hash_table_iter_remove(carg0)
	runtime.KeepAlive(iter)
}

// Steal wraps g_hash_table_iter_steal
//
// Removes the key/value pair currently pointed to by the
// iterator from its associated #GHashTable, without calling
// the key and value destroy functions. Can only be called
// after g_hash_table_iter_next() returned %TRUE, and cannot
// be called more than once for the same key/value pair.
func (iter *HashTableIter) Steal() {
	var carg0 *C.GHashTableIter // in, none, converted

	carg0 = (*C.GHashTableIter)(UnsafeHashTableIterToGlibNone(iter))

	C.g_hash_table_iter_steal(carg0)
	runtime.KeepAlive(iter)
}

// Hmac wraps GHmac
//
// HMACs should be used when producing a cookie or hash based on data
// and a key. Simple mechanisms for using SHA1 and other algorithms to
// digest a key and data together are vulnerable to various security
// issues.
// [HMAC](http://en.wikipedia.org/wiki/HMAC)
// uses algorithms like SHA1 in a secure way to produce a digest of a
// key and data.
// 
// Both the key and data are arbitrary byte arrays of bytes or characters.
// 
// Support for HMAC Digests has been added in GLib 2.30, and support for SHA-512
// in GLib 2.42. Support for SHA-384 was added in GLib 2.52.
// 
// To create a new `GHmac`, use [ctor@GLib.Hmac.new]. To free a `GHmac`, use
// [method@GLib.Hmac.unref].
type Hmac struct {
	*hmac
}

// hmac is the struct that's finalized
type hmac struct {
	native *C.GHmac
}

// UnsafeHmacToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *Hmac) instance() *C.GHmac {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHmacFromGlibBorrow is used to convert raw C.GHmac pointers to go. This is used by the bindings internally.
func UnsafeHmacFromGlibBorrow(p unsafe.Pointer) *Hmac {
	if p == nil {
		return nil
	}
	return &Hmac{&hmac{(*C.GHmac)(p)}}
}

// UnsafeHmacFromGlibNone is used to convert raw C.GHmac pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHmacFromGlibNone(p unsafe.Pointer) *Hmac {
	C.g_hmac_ref((*C.GHmac)(p))
	wrapped := UnsafeHmacFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.hmac,
		func (intern *hmac) {
			C.g_hmac_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeHmacFromGlibFull is used to convert raw C.GHmac pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHmacFromGlibFull(p unsafe.Pointer) *Hmac {
	wrapped := UnsafeHmacFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hmac,
		func (intern *hmac) {
			C.g_hmac_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeHmacRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Hmac.UnsafeHmacUnref], then [Hmac] will leak memory.
func UnsafeHmacRef(h *Hmac) {
	C.g_hmac_ref(h.native)
}

// UnsafeHmacUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Hmac] is expected to work anymore.
func UnsafeHmacUnref(h *Hmac) {
	C.g_hmac_unref(h.native)
}

// UnsafeHmacToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHmacToGlibNone(h *Hmac) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHmacToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHmacToGlibFull(h *Hmac) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hmac, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // Hmac is invalid from here on
	return _p
}

// NewHmac wraps g_hmac_new
// 
// The function takes the following parameters:
// 
// 	- digestType ChecksumType: the desired type of digest 
// 	- key []byte: the key for the HMAC 
// 
// The function returns the following values:
// 
// 	- goret *Hmac (nullable) 
//
// Creates a new #GHmac, using the digest algorithm @digest_type.
// If the @digest_type is not known, %NULL is returned.
// A #GHmac can be used to compute the HMAC of a key and an
// arbitrary binary blob, using different hashing algorithms.
// 
// A #GHmac works by feeding a binary blob through g_hmac_update()
// until the data is complete; the digest can then be extracted
// using g_hmac_get_string(), which will return the checksum as a
// hexadecimal string; or g_hmac_get_digest(), which will return a
// array of raw bytes. Once either g_hmac_get_string() or
// g_hmac_get_digest() have been called on a #GHmac, the HMAC
// will be closed and it won't be possible to call g_hmac_update()
// on it anymore.
// 
// Support for digests of type %G_CHECKSUM_SHA512 has been added in GLib 2.42.
// Support for %G_CHECKSUM_SHA384 was added in GLib 2.52.
func NewHmac(digestType ChecksumType, key []byte) *Hmac {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var cret  *C.GHmac        // return, full, converted, nullable

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_hmac_new(carg1, carg2, carg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)

	var goret *Hmac

	if cret != nil {
		goret = UnsafeHmacFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// Copy wraps g_hmac_copy
// 
// The function returns the following values:
// 
// 	- goret *Hmac 
//
// Copies a #GHmac. If @hmac has been closed, by calling
// g_hmac_get_string() or g_hmac_get_digest(), the copied
// HMAC will be closed as well.
func (hmac *Hmac) Copy() *Hmac {
	var carg0 *C.GHmac // in, none, converted
	var cret  *C.GHmac // return, full, converted

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))

	cret = C.g_hmac_copy(carg0)
	runtime.KeepAlive(hmac)

	var goret *Hmac

	goret = UnsafeHmacFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_hmac_get_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the HMAC as a hexadecimal string.
// 
// Once this function has been called the #GHmac can no longer be
// updated with g_hmac_update().
// 
// The hexadecimal characters will be lower case.
func (hmac *Hmac) GetString() string {
	var carg0 *C.GHmac // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))

	cret = C.g_hmac_get_string(carg0)
	runtime.KeepAlive(hmac)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Update wraps g_hmac_update
// 
// The function takes the following parameters:
// 
// 	- data []byte: buffer used to compute the checksum 
//
// Feeds @data into an existing #GHmac.
// 
// The HMAC must still be open, that is g_hmac_get_string() or
// g_hmac_get_digest() must not have been called on @hmac.
func (hmac *Hmac) Update(data []byte) {
	var carg0 *C.GHmac  // in, none, converted
	var carg1 *C.guchar // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize  // implicit

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	C.g_hmac_update(carg0, carg1, carg2)
	runtime.KeepAlive(hmac)
	runtime.KeepAlive(data)
}

// Hook wraps GHook
//
// The #GHook struct represents a single hook function in a #GHookList.
type Hook struct {
	*hook
}

// hook is the struct that's finalized
type hook struct {
	native *C.GHook
}

// UnsafeHookToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *Hook) instance() *C.GHook {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHookFromGlibBorrow is used to convert raw C.GHook pointers to go. This is used by the bindings internally.
func UnsafeHookFromGlibBorrow(p unsafe.Pointer) *Hook {
	if p == nil {
		return nil
	}
	return &Hook{&hook{(*C.GHook)(p)}}
}

// UnsafeHookFromGlibNone is used to convert raw C.GHook pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHookFromGlibNone(p unsafe.Pointer) *Hook {
	wrapped := UnsafeHookFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Hook because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHookFromGlibFull is used to convert raw C.GHook pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHookFromGlibFull(p unsafe.Pointer) *Hook {
	wrapped := UnsafeHookFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hook,
		func (intern *hook) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHookFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Hook] is expected to work anymore.
func UnsafeHookFree(h *Hook) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHookToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHookToGlibNone(h *Hook) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHookToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHookToGlibFull(h *Hook) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hook, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // Hook is invalid from here on
	return _p
}

// HookDestroy wraps g_hook_destroy
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- hookId uint32: a hook ID 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Destroys a #GHook, given its ID.
func HookDestroy(hookList *HookList, hookId uint32) bool {
	var carg1 *C.GHookList // in, none, converted
	var carg2 C.gulong     // in, none, casted
	var cret  C.gboolean   // return

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = C.gulong(hookId)

	cret = C.g_hook_destroy(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hookId)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HookDestroyLink wraps g_hook_destroy_link
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- hook *Hook: the #GHook to remove 
//
// Removes one #GHook from a #GHookList, marking it
// inactive and calling g_hook_unref() on it.
func HookDestroyLink(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_destroy_link(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookFree wraps g_hook_free
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- hook *Hook: the #GHook to free 
//
// Calls the #GHookList @finalize_hook function if it exists,
// and frees the memory allocated for the #GHook.
func HookFree(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_free(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookInsertBefore wraps g_hook_insert_before
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- sibling *Hook (nullable): the #GHook to insert the new #GHook before 
// 	- hook *Hook: the #GHook to insert 
//
// Inserts a #GHook into a #GHookList, before a given #GHook.
func HookInsertBefore(hookList *HookList, sibling *Hook, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted, nullable
	var carg3 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if sibling != nil {
		carg2 = (*C.GHook)(UnsafeHookToGlibNone(sibling))
	}
	carg3 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_insert_before(carg1, carg2, carg3)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(hook)
}

// HookPrepend wraps g_hook_prepend
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- hook *Hook: the #GHook to add to the start of @hook_list 
//
// Prepends a #GHook on the start of a #GHookList.
func HookPrepend(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_prepend(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookUnref wraps g_hook_unref
// 
// The function takes the following parameters:
// 
// 	- hookList *HookList: a #GHookList 
// 	- hook *Hook: the #GHook to unref 
//
// Decrements the reference count of a #GHook.
// If the reference count falls to 0, the #GHook is removed
// from the #GHookList and g_hook_free() is called to free it.
func HookUnref(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_unref(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// CompareIDs wraps g_hook_compare_ids
// 
// The function takes the following parameters:
// 
// 	- sibling *Hook: a #GHook to compare with @new_hook 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Compares the ids of two #GHook elements, returning a negative value
// if the second id is greater than the first.
func (newHook *Hook) CompareIDs(sibling *Hook) int32 {
	var carg0 *C.GHook // in, none, converted
	var carg1 *C.GHook // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GHook)(UnsafeHookToGlibNone(newHook))
	carg1 = (*C.GHook)(UnsafeHookToGlibNone(sibling))

	cret = C.g_hook_compare_ids(carg0, carg1)
	runtime.KeepAlive(newHook)
	runtime.KeepAlive(sibling)

	var goret int32

	goret = int32(cret)

	return goret
}

// HookList wraps GHookList
//
// The #GHookList struct represents a list of hook functions.
type HookList struct {
	*hookList
}

// hookList is the struct that's finalized
type hookList struct {
	native *C.GHookList
}

// UnsafeHookListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *HookList) instance() *C.GHookList {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHookListFromGlibBorrow is used to convert raw C.GHookList pointers to go. This is used by the bindings internally.
func UnsafeHookListFromGlibBorrow(p unsafe.Pointer) *HookList {
	if p == nil {
		return nil
	}
	return &HookList{&hookList{(*C.GHookList)(p)}}
}

// UnsafeHookListFromGlibNone is used to convert raw C.GHookList pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHookListFromGlibNone(p unsafe.Pointer) *HookList {
	wrapped := UnsafeHookListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to HookList because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHookListFromGlibFull is used to convert raw C.GHookList pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHookListFromGlibFull(p unsafe.Pointer) *HookList {
	wrapped := UnsafeHookListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hookList,
		func (intern *hookList) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHookListFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [HookList] is expected to work anymore.
func UnsafeHookListFree(h *HookList) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHookListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHookListToGlibNone(h *HookList) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHookListToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHookListToGlibFull(h *HookList) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hookList, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // HookList is invalid from here on
	return _p
}

// Clear wraps g_hook_list_clear
//
// Removes all the #GHook elements from a #GHookList.
func (hookList *HookList) Clear() {
	var carg0 *C.GHookList // in, none, converted

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))

	C.g_hook_list_clear(carg0)
	runtime.KeepAlive(hookList)
}

// Init wraps g_hook_list_init
// 
// The function takes the following parameters:
// 
// 	- hookSize uint: the size of each element in the #GHookList,
//     typically `sizeof (GHook)`. 
//
// Initializes a #GHookList.
// This must be called before the #GHookList is used.
func (hookList *HookList) Init(hookSize uint) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.guint      // in, none, casted

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg1 = C.guint(hookSize)

	C.g_hook_list_init(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hookSize)
}

// Invoke wraps g_hook_list_invoke
// 
// The function takes the following parameters:
// 
// 	- mayRecurse bool: %TRUE if functions which are already running
//     (e.g. in another thread) can be called. If set to %FALSE,
//     these are skipped 
//
// Calls all of the #GHook functions in a #GHookList.
func (hookList *HookList) Invoke(mayRecurse bool) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if mayRecurse {
		carg1 = C.TRUE
	}

	C.g_hook_list_invoke(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(mayRecurse)
}

// InvokeCheck wraps g_hook_list_invoke_check
// 
// The function takes the following parameters:
// 
// 	- mayRecurse bool: %TRUE if functions which are already running
//     (e.g. in another thread) can be called. If set to %FALSE,
//     these are skipped 
//
// Calls all of the #GHook functions in a #GHookList.
// Any function which returns %FALSE is removed from the #GHookList.
func (hookList *HookList) InvokeCheck(mayRecurse bool) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if mayRecurse {
		carg1 = C.TRUE
	}

	C.g_hook_list_invoke_check(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(mayRecurse)
}

// IOChannel wraps GIOChannel
//
// The `GIOChannel` data type aims to provide a portable method for
// using file descriptors, pipes, and sockets, and integrating them
// into the main event loop (see [struct@GLib.MainContext]). Currently,
// full support is available on UNIX platforms; support for Windows
// is only partially complete.
// 
// To create a new `GIOChannel` on UNIX systems use
// [ctor@GLib.IOChannel.unix_new]. This works for plain file descriptors,
// pipes and sockets. Alternatively, a channel can be created for a
// file in a system independent manner using [ctor@GLib.IOChannel.new_file].
// 
// Once a `GIOChannel` has been created, it can be used in a generic
// manner with the functions [method@GLib.IOChannel.read_chars],
// [method@GLib.IOChannel.write_chars], [method@GLib.IOChannel.seek_position],
// and [method@GLib.IOChannel.shutdown].
// 
// To add a `GIOChannel` to the main event loop, use [func@GLib.io_add_watch] or
// [func@GLib.io_add_watch_full]. Here you specify which events you are
// interested in on the `GIOChannel`, and provide a function to be called
// whenever these events occur.
// 
// `GIOChannel` instances are created with an initial reference count of 1.
// [method@GLib.IOChannel.ref] and [method@GLib.IOChannel.unref] can be used to
// increment or decrement the reference count respectively. When the
// reference count falls to 0, the `GIOChannel` is freed. (Though it
// isn&#x2019;t closed automatically, unless it was created using
// [ctor@GLib.IOChannel.new_file].) Using [func@GLib.io_add_watch] or
// [func@GLib.io_add_watch_full] increments a channel&#x2019;s reference count.
// 
// The new functions [method@GLib.IOChannel.read_chars],
// [method@GLib.IOChannel.read_line], [method@GLib.IOChannel.read_line_string],
// [method@GLib.IOChannel.read_to_end], [method@GLib.IOChannel.write_chars],
// [method@GLib.IOChannel.seek_position], and [method@GLib.IOChannel.flush]
// should not be mixed with the deprecated functions
// [method@GLib.IOChannel.read], [method@GLib.IOChannel.write], and
// [method@GLib.IOChannel.seek] on the same channel.
type IOChannel struct {
	*iOChannel
}

// iOChannel is the struct that's finalized
type iOChannel struct {
	native *C.GIOChannel
}

// UnsafeIOChannelToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOChannel) instance() *C.GIOChannel {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOChannelFromGlibBorrow is used to convert raw C.GIOChannel pointers to go. This is used by the bindings internally.
func UnsafeIOChannelFromGlibBorrow(p unsafe.Pointer) *IOChannel {
	if p == nil {
		return nil
	}
	return &IOChannel{&iOChannel{(*C.GIOChannel)(p)}}
}

// UnsafeIOChannelFromGlibNone is used to convert raw C.GIOChannel pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOChannelFromGlibNone(p unsafe.Pointer) *IOChannel {
	C.g_io_channel_ref((*C.GIOChannel)(p))
	wrapped := UnsafeIOChannelFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.iOChannel,
		func (intern *iOChannel) {
			C.g_io_channel_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOChannelFromGlibFull is used to convert raw C.GIOChannel pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOChannelFromGlibFull(p unsafe.Pointer) *IOChannel {
	wrapped := UnsafeIOChannelFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOChannel,
		func (intern *iOChannel) {
			C.g_io_channel_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOChannelRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [IOChannel.UnsafeIOChannelUnref], then [IOChannel] will leak memory.
func UnsafeIOChannelRef(i *IOChannel) {
	C.g_io_channel_ref(i.native)
}

// UnsafeIOChannelUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOChannel] is expected to work anymore.
func UnsafeIOChannelUnref(i *IOChannel) {
	C.g_io_channel_unref(i.native)
}

// UnsafeIOChannelToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOChannelToGlibNone(i *IOChannel) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOChannelToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOChannelToGlibFull(i *IOChannel) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOChannel, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOChannel is invalid from here on
	return _p
}

// NewIOChannelFile wraps g_io_channel_new_file
// 
// The function takes the following parameters:
// 
// 	- filename string: A string containing the name of a file 
// 	- mode string: One of "r", "w", "a", "r+", "w+", "a+". These have
//        the same meaning as in fopen() 
// 
// The function returns the following values:
// 
// 	- goret *IOChannel 
// 	- _goerr error (nullable): an error 
//
// Open a file @filename as a #GIOChannel using mode @mode. This
// channel will be closed when the last reference to it is dropped,
// so there is no need to call g_io_channel_close() (though doing
// so will not cause problems, as long as no attempt is made to
// access the channel after it is closed).
func NewIOChannelFile(filename string, mode string) (*IOChannel, error) {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GIOChannel // return, full, converted
	var _cerr *C.GError     // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mode)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_io_channel_new_file(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(mode)

	var goret  *IOChannel
	var _goerr error

	goret = UnsafeIOChannelFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IOChannelErrorFromErrno wraps g_io_channel_error_from_errno
// 
// The function takes the following parameters:
// 
// 	- en int32: an `errno` error number, e.g. `EINVAL` 
// 
// The function returns the following values:
// 
// 	- goret IOChannelError 
//
// Converts an `errno` error number to a #GIOChannelError.
func IOChannelErrorFromErrno(en int32) IOChannelError {
	var carg1 C.gint            // in, none, casted
	var cret  C.GIOChannelError // return, none, casted

	carg1 = C.gint(en)

	cret = C.g_io_channel_error_from_errno(carg1)
	runtime.KeepAlive(en)

	var goret IOChannelError

	goret = IOChannelError(cret)

	return goret
}

// IOChannelErrorQuark wraps g_io_channel_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func IOChannelErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_io_channel_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// Flush wraps g_io_channel_flush
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Flushes the write buffer for the GIOChannel.
func (channel *IOChannel) Flush() (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_flush(carg0, &_cerr)
	runtime.KeepAlive(channel)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBufferCondition wraps g_io_channel_get_buffer_condition
// 
// The function returns the following values:
// 
// 	- goret IOCondition 
//
// This function returns a #GIOCondition depending on whether there
// is data to be read/space to write data in the internal buffers in
// the #GIOChannel. Only the flags %G_IO_IN and %G_IO_OUT may be set.
func (channel *IOChannel) GetBufferCondition() IOCondition {
	var carg0 *C.GIOChannel  // in, none, converted
	var cret  C.GIOCondition // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffer_condition(carg0)
	runtime.KeepAlive(channel)

	var goret IOCondition

	goret = IOCondition(cret)

	return goret
}

// GetBufferSize wraps g_io_channel_get_buffer_size
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the buffer size.
func (channel *IOChannel) GetBufferSize() uint {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gsize       // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffer_size(carg0)
	runtime.KeepAlive(channel)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetBuffered wraps g_io_channel_get_buffered
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether @channel is buffered.
func (channel *IOChannel) GetBuffered() bool {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffered(carg0)
	runtime.KeepAlive(channel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCloseOnUnref wraps g_io_channel_get_close_on_unref
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the file/socket/whatever associated with @channel
// will be closed when @channel receives its final unref and is
// destroyed. The default value of this is %TRUE for channels created
// by g_io_channel_new_file (), and %FALSE for all other channels.
func (channel *IOChannel) GetCloseOnUnref() bool {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_close_on_unref(carg0)
	runtime.KeepAlive(channel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetEncoding wraps g_io_channel_get_encoding
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the encoding for the input/output of the channel.
// The internal encoding is always UTF-8. The encoding %NULL
// makes the channel safe for binary data.
func (channel *IOChannel) GetEncoding() string {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_encoding(carg0)
	runtime.KeepAlive(channel)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetFlags wraps g_io_channel_get_flags
// 
// The function returns the following values:
// 
// 	- goret IOFlags 
//
// Gets the current flags for a #GIOChannel, including read-only
// flags such as %G_IO_FLAG_IS_READABLE.
// 
// The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITABLE
// are cached for internal use by the channel when it is created.
// If they should change at some later point (e.g. partial shutdown
// of a socket with the UNIX shutdown() function), the user
// should immediately call g_io_channel_get_flags() to update
// the internal values of these flags.
func (channel *IOChannel) GetFlags() IOFlags {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.GIOFlags    // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_flags(carg0)
	runtime.KeepAlive(channel)

	var goret IOFlags

	goret = IOFlags(cret)

	return goret
}

// GetLineTerm wraps g_io_channel_get_line_term
// 
// The function returns the following values:
// 
// 	- length int32: a location to return the length of the line terminator 
// 	- goret string 
//
// This returns the string that #GIOChannel uses to determine
// where in the file a line break occurs. A value of %NULL
// indicates autodetection. Since 2.84, the return value is always
// nul-terminated.
func (channel *IOChannel) GetLineTerm() (int32, string) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gint        // out, full, casted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_line_term(carg0, &carg1)
	runtime.KeepAlive(channel)

	var length int32
	var goret  string

	length = int32(carg1)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return length, goret
}

// Init wraps g_io_channel_init
//
// Initializes a #GIOChannel struct.
// 
// This is called by each of the above functions when creating a
// #GIOChannel, and so is not often needed by the application
// programmer (unless you are creating a new type of #GIOChannel).
func (channel *IOChannel) Init() {
	var carg0 *C.GIOChannel // in, none, converted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	C.g_io_channel_init(carg0)
	runtime.KeepAlive(channel)
}

// ReadLine wraps g_io_channel_read_line
// 
// The function returns the following values:
// 
// 	- strReturn string: The line read from the #GIOChannel, including the
//              line terminator. This data should be freed with g_free()
//              when no longer needed. This is a nul-terminated string.
//              If a @length of zero is returned, this will be %NULL instead. 
// 	- length uint: location to store length of the read data, or %NULL 
// 	- terminatorPos uint: location to store position of line terminator, or %NULL 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Reads a line, including the terminating character(s),
// from a #GIOChannel into a newly-allocated string.
// @str_return will contain allocated memory if the return
// is %G_IO_STATUS_NORMAL.
func (channel *IOChannel) ReadLine() (string, uint, uint, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // out, full, string
	var carg2 C.gsize       // out, full, casted
	var carg3 C.gsize       // out, full, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_line(carg0, &carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(channel)

	var strReturn     string
	var length        uint
	var terminatorPos uint
	var goret         IOStatus
	var _goerr        error

	strReturn = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	defer C.free(unsafe.Pointer(carg1))
	length = uint(carg2)
	terminatorPos = uint(carg3)
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return strReturn, length, terminatorPos, goret, _goerr
}

// ReadToEnd wraps g_io_channel_read_to_end
// 
// The function returns the following values:
// 
// 	- strReturn string: Location to
//              store a pointer to a string holding the remaining data in the
//              #GIOChannel. This data should be freed with g_free() when no
//              longer needed. This data is terminated by an extra nul
//              character, but there may be other nuls in the intervening data. 
// 	- length uint: location to store length of the data 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Reads all the remaining data from the file.
func (channel *IOChannel) ReadToEnd() (string, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize       // implicit
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_to_end(carg0, &carg1, &carg2, &_cerr)
	runtime.KeepAlive(channel)

	var strReturn string
	var goret     IOStatus
	var _goerr    error

	_ = strReturn
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return strReturn, goret, _goerr
}

// ReadUnichar wraps g_io_channel_read_unichar
// 
// The function returns the following values:
// 
// 	- thechar uint32: a location to return a character 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Reads a Unicode character from @channel.
// This function cannot be called on a channel with %NULL encoding.
func (channel *IOChannel) ReadUnichar() (uint32, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gunichar    // out, full, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_unichar(carg0, &carg1, &_cerr)
	runtime.KeepAlive(channel)

	var thechar uint32
	var goret   IOStatus
	var _goerr  error

	thechar = uint32(carg1)
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return thechar, goret, _goerr
}

// SeekPosition wraps g_io_channel_seek_position
// 
// The function takes the following parameters:
// 
// 	- offset int64: The offset in bytes from the position specified by @type 
// 	- typ SeekType: a #GSeekType. The type %G_SEEK_CUR is only allowed in those
//                      cases where a call to g_io_channel_set_encoding ()
//                      is allowed. See the documentation for
//                      g_io_channel_set_encoding () for details. 
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Replacement for g_io_channel_seek() with the new API.
func (channel *IOChannel) SeekPosition(offset int64, typ SeekType) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gint64      // in, none, casted
	var carg2 C.GSeekType   // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gint64(offset)
	carg2 = C.GSeekType(typ)

	cret = C.g_io_channel_seek_position(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBufferSize wraps g_io_channel_set_buffer_size
// 
// The function takes the following parameters:
// 
// 	- size uint: the size of the buffer, or 0 to let GLib pick a good size 
//
// Sets the buffer size.
func (channel *IOChannel) SetBufferSize(size uint) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gsize       // in, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gsize(size)

	C.g_io_channel_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(size)
}

// SetBuffered wraps g_io_channel_set_buffered
// 
// The function takes the following parameters:
// 
// 	- buffered bool: whether to set the channel buffered or unbuffered 
//
// The buffering state can only be set if the channel's encoding
// is %NULL. For any other encoding, the channel must be buffered.
// 
// A buffered channel can only be set unbuffered if the channel's
// internal buffers have been flushed. Newly created channels or
// channels which have returned %G_IO_STATUS_EOF
// not require such a flush. For write-only channels, a call to
// g_io_channel_flush () is sufficient. For all other channels,
// the buffers may be flushed by a call to g_io_channel_seek_position ().
// This includes the possibility of seeking with seek type %G_SEEK_CUR
// and an offset of zero. Note that this means that socket-based
// channels cannot be set unbuffered once they have had data
// read from them.
// 
// On unbuffered channels, it is safe to mix read and write
// calls from the new and old APIs, if this is necessary for
// maintaining old code.
// 
// The default state of the channel is buffered.
func (channel *IOChannel) SetBuffered(buffered bool) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if buffered {
		carg1 = C.TRUE
	}

	C.g_io_channel_set_buffered(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buffered)
}

// SetCloseOnUnref wraps g_io_channel_set_close_on_unref
// 
// The function takes the following parameters:
// 
// 	- doClose bool: Whether to close the channel on the final unref of
//            the GIOChannel data structure. 
//
// Whether to close the channel on the final unref of the #GIOChannel
// data structure. The default value of this is %TRUE for channels
// created by g_io_channel_new_file (), and %FALSE for all other channels.
// 
// Setting this flag to %TRUE for a channel you have already closed
// can cause problems when the final reference to the #GIOChannel is dropped.
func (channel *IOChannel) SetCloseOnUnref(doClose bool) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if doClose {
		carg1 = C.TRUE
	}

	C.g_io_channel_set_close_on_unref(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(doClose)
}

// SetEncoding wraps g_io_channel_set_encoding
// 
// The function takes the following parameters:
// 
// 	- encoding string (nullable): the encoding type 
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Sets the encoding for the input/output of the channel.
// The internal encoding is always UTF-8. The default encoding
// for the external file is UTF-8.
// 
// The encoding %NULL is safe to use with binary data.
// 
// The encoding can only be set if one of the following conditions
// is true:
// 
// - The channel was just created, and has not been written to or read from yet.
// 
// - The channel is write-only.
// 
// - The channel is a file, and the file pointer was just repositioned
//   by a call to g_io_channel_seek_position(). (This flushes all the
//   internal buffers.)
// 
// - The current encoding is %NULL or UTF-8.
// 
// - One of the (new API) read functions has just returned %G_IO_STATUS_EOF
//   (or, in the case of g_io_channel_read_to_end(), %G_IO_STATUS_NORMAL).
// 
// -  One of the functions g_io_channel_read_chars() or
//    g_io_channel_read_unichar() has returned %G_IO_STATUS_AGAIN or
//    %G_IO_STATUS_ERROR. This may be useful in the case of
//    %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
//    Returning one of these statuses from g_io_channel_read_line(),
//    g_io_channel_read_line_string(), or g_io_channel_read_to_end()
//    does not guarantee that the encoding can be changed.
// 
// Channels which do not meet one of the above conditions cannot call
// g_io_channel_seek_position() with an offset of %G_SEEK_CUR, and, if
// they are "seekable", cannot call g_io_channel_write_chars() after
// calling one of the API "read" functions.
func (channel *IOChannel) SetEncoding(encoding string) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if encoding != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(encoding)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_io_channel_set_encoding(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(encoding)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetFlags wraps g_io_channel_set_flags
// 
// The function takes the following parameters:
// 
// 	- flags IOFlags: the flags to set on the IO channel 
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Sets the (writeable) flags in @channel to (@flags &amp; %G_IO_FLAG_SET_MASK).
func (channel *IOChannel) SetFlags(flags IOFlags) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.GIOFlags    // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.GIOFlags(flags)

	cret = C.g_io_channel_set_flags(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flags)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetLineTerm wraps g_io_channel_set_line_term
// 
// The function takes the following parameters:
// 
// 	- lineTerm string (nullable): The line termination string. Use %NULL for
//             autodetect.  Autodetection breaks on "\n", "\r\n", "\r", "\0",
//             and the Unicode paragraph separator. Autodetection should not be
//             used for anything other than file-based channels. 
// 	- length int32: The length of the termination string. If -1 is passed, the
//          string is assumed to be nul-terminated. This option allows
//          termination strings with embedded nuls. 
//
// This sets the string that #GIOChannel uses to determine
// where in the file a line break occurs.
func (channel *IOChannel) SetLineTerm(lineTerm string, length int32) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 C.gint        // in, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if lineTerm != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(lineTerm)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.gint(length)

	C.g_io_channel_set_line_term(carg0, carg1, carg2)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(lineTerm)
	runtime.KeepAlive(length)
}

// Shutdown wraps g_io_channel_shutdown
// 
// The function takes the following parameters:
// 
// 	- flush bool: if %TRUE, flush pending 
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Close an IO channel. Any pending data to be written will be
// flushed if @flush is %TRUE. The channel will not be freed until the
// last reference is dropped using g_io_channel_unref().
func (channel *IOChannel) Shutdown(flush bool) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if flush {
		carg1 = C.TRUE
	}

	cret = C.g_io_channel_shutdown(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flush)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteUnichar wraps g_io_channel_write_unichar
// 
// The function takes the following parameters:
// 
// 	- thechar uint32: a character 
// 
// The function returns the following values:
// 
// 	- goret IOStatus 
// 	- _goerr error (nullable): an error 
//
// Writes a Unicode character to @channel.
// This function cannot be called on a channel with %NULL encoding.
func (channel *IOChannel) WriteUnichar(thechar uint32) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gunichar    // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gunichar(thechar)

	cret = C.g_io_channel_write_unichar(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(thechar)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IOFuncs wraps GIOFuncs
//
// A table of functions used to handle different types of #GIOChannel
// in a generic way.
type IOFuncs struct {
	*iOFuncs
}

// iOFuncs is the struct that's finalized
type iOFuncs struct {
	native *C.GIOFuncs
}

// UnsafeIOFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOFuncs) instance() *C.GIOFuncs {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOFuncsFromGlibBorrow is used to convert raw C.GIOFuncs pointers to go. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibBorrow(p unsafe.Pointer) *IOFuncs {
	if p == nil {
		return nil
	}
	return &IOFuncs{&iOFuncs{(*C.GIOFuncs)(p)}}
}

// UnsafeIOFuncsFromGlibNone is used to convert raw C.GIOFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibNone(p unsafe.Pointer) *IOFuncs {
	wrapped := UnsafeIOFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOFuncsFromGlibFull is used to convert raw C.GIOFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibFull(p unsafe.Pointer) *IOFuncs {
	wrapped := UnsafeIOFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOFuncs,
		func (intern *iOFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOFuncs] is expected to work anymore.
func UnsafeIOFuncsFree(i *IOFuncs) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOFuncsToGlibNone(i *IOFuncs) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOFuncsToGlibFull(i *IOFuncs) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOFuncs, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOFuncs is invalid from here on
	return _p
}

// KeyFile wraps GKeyFile
//
// `GKeyFile` parses .ini-like config files.
// 
// `GKeyFile` lets you parse, edit or create files containing groups of
// key-value pairs, which we call &#x2018;key files&#x2019; for lack of a better name.
// Several freedesktop.org specifications use key files. For example, the
// [Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/)
// and the [Icon Theme Specification](https://specifications.freedesktop.org/icon-theme-spec/latest/).
// 
// The syntax of key files is described in detail in the
// [Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/),
// here is a quick summary: Key files consists of groups of key-value pairs, interspersed
// with comments.
// 
// ```txt
// # this is just an example
// # there can be comments before the first group
// 
// [First Group]
// 
// Name=Key File Example\tthis value shows\nescaping
// 
// # localized strings are stored in multiple key-value pairs
// Welcome=Hello
// Welcome[de]=Hallo
// Welcome[fr_FR]=Bonjour
// Welcome[it]=Ciao
// 
// [Another Group]
// 
// Numbers=2;20;-200;0
// 
// Booleans=true;false;true;true
// ```
// 
// Lines beginning with a `#` and blank lines are considered comments.
// 
// Groups are started by a header line containing the group name enclosed
// in `[` and `]`, and ended implicitly by the start of the next group or
// the end of the file. Each key-value pair must be contained in a group.
// 
// Key-value pairs generally have the form `key=value`, with the exception
// of localized strings, which have the form `key[locale]=value`, with a
// locale identifier of the form `lang_COUNTRY@MODIFIER` where `COUNTRY`
// and `MODIFIER` are optional. As a special case, the locale `C` is associated
// with the untranslated pair `key=value` (since GLib 2.84). Space before and
// after the `=` character is ignored. Newline, tab, carriage return and
// backslash characters in value are escaped as `\n`, `\t`, `\r`, and `\\\\`,
// respectively. To preserve leading spaces in values, these can also be escaped
// as `\s`.
// 
// Key files can store strings (possibly with localized variants), integers,
// booleans and lists of these. Lists are separated by a separator character,
// typically `;` or `,`. To use the list separator character in a value in
// a list, it has to be escaped by prefixing it with a backslash.
// 
// This syntax is obviously inspired by the .ini files commonly met
// on Windows, but there are some important differences:
// 
// - .ini files use the `;` character to begin comments,
//   key files use the `#` character.
// 
// - Key files do not allow for ungrouped keys meaning only
//   comments can precede the first group.
// 
// - Key files are always encoded in UTF-8.
// 
// - Key and Group names are case-sensitive. For example, a group called
//   `[GROUP]` is a different from `[group]`.
// 
// - .ini files don&#x2019;t have a strongly typed boolean entry type,
//    they only have `GetProfileInt()`. In key files, only
//    `true` and `false` (in lower case) are allowed.
// 
// Note that in contrast to the
// [Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/),
// groups in key files may contain the same key multiple times; the last entry wins.
// Key files may also contain multiple groups with the same name; they are merged
// together. Another difference is that keys and group names in key files are not
// restricted to ASCII characters.
// 
// Here is an example of loading a key file and reading a value:
// 
// ```c
// g_autoptr(GError) error = NULL;
// g_autoptr(GKeyFile) key_file = g_key_file_new ();
// 
// if (!g_key_file_load_from_file (key_file, "key-file.ini", flags, &amp;error))
//   {
//     if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
//       g_warning ("Error loading key file: %s", error-&gt;message);
//     return;
//   }
// 
// g_autofree gchar *val = g_key_file_get_string (key_file, "Group Name", "SomeKey", &amp;error);
// if (val == NULL &amp;&amp;
//     !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
//   {
//     g_warning ("Error finding key in key file: %s", error-&gt;message);
//     return;
//   }
// else if (val == NULL)
//   {
//     // Fall back to a default value.
//     val = g_strdup ("default-value");
//   }
// ```
// 
// Here is an example of creating and saving a key file:
// 
// ```c
// g_autoptr(GKeyFile) key_file = g_key_file_new ();
// const gchar *val = &#x2026;;
// g_autoptr(GError) error = NULL;
// 
// g_key_file_set_string (key_file, "Group Name", "SomeKey", val);
// 
// // Save as a file.
// if (!g_key_file_save_to_file (key_file, "key-file.ini", &amp;error))
//   {
//     g_warning ("Error saving key file: %s", error-&gt;message);
//     return;
//   }
// 
// // Or store to a GBytes for use elsewhere.
// gsize data_len;
// g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &amp;data_len, &amp;error);
// if (data == NULL)
//   {
//     g_warning ("Error saving key file: %s", error-&gt;message);
//     return;
//   }
// g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&amp;data), data_len);
// ```
type KeyFile struct {
	*keyFile
}

// keyFile is the struct that's finalized
type keyFile struct {
	native *C.GKeyFile
}

// UnsafeKeyFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (k *KeyFile) instance() *C.GKeyFile {
	if k == nil {
		return nil
	}
	return k.native
}

// UnsafeKeyFileFromGlibBorrow is used to convert raw C.GKeyFile pointers to go. This is used by the bindings internally.
func UnsafeKeyFileFromGlibBorrow(p unsafe.Pointer) *KeyFile {
	if p == nil {
		return nil
	}
	return &KeyFile{&keyFile{(*C.GKeyFile)(p)}}
}

// UnsafeKeyFileFromGlibNone is used to convert raw C.GKeyFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeKeyFileFromGlibNone(p unsafe.Pointer) *KeyFile {
	C.g_key_file_ref((*C.GKeyFile)(p))
	wrapped := UnsafeKeyFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.keyFile,
		func (intern *keyFile) {
			C.g_key_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeKeyFileFromGlibFull is used to convert raw C.GKeyFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeKeyFileFromGlibFull(p unsafe.Pointer) *KeyFile {
	wrapped := UnsafeKeyFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.keyFile,
		func (intern *keyFile) {
			C.g_key_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeKeyFileRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [KeyFile.UnsafeKeyFileUnref], then [KeyFile] will leak memory.
func UnsafeKeyFileRef(k *KeyFile) {
	C.g_key_file_ref(k.native)
}

// UnsafeKeyFileUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [KeyFile] is expected to work anymore.
func UnsafeKeyFileUnref(k *KeyFile) {
	C.g_key_file_unref(k.native)
}

// UnsafeKeyFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeKeyFileToGlibNone(k *KeyFile) unsafe.Pointer {
	if k == nil {
		return nil
	}
	return unsafe.Pointer(k.native)
}

// UnsafeKeyFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeKeyFileToGlibFull(k *KeyFile) unsafe.Pointer {
	if k == nil {
		return nil
	}
	runtime.SetFinalizer(k.keyFile, nil)
	_p := unsafe.Pointer(k.native)
	k.native = nil // KeyFile is invalid from here on
	return _p
}

// NewKeyFile wraps g_key_file_new
// 
// The function returns the following values:
// 
// 	- goret *KeyFile 
//
// Creates a new empty [struct@GLib.KeyFile] object.
// 
// Use [method@GLib.KeyFile.load_from_file],
// [method@GLib.KeyFile.load_from_data], [method@GLib.KeyFile.load_from_dirs] or
// [method@GLib.KeyFile.load_from_data_dirs] to
// read an existing key file.
func NewKeyFile() *KeyFile {
	var cret *C.GKeyFile // return, full, converted

	cret = C.g_key_file_new()

	var goret *KeyFile

	goret = UnsafeKeyFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// KeyFileErrorQuark wraps g_key_file_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func KeyFileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_key_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// GetBoolean wraps g_key_file_get_boolean
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name as a
// boolean.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the value associated with @key cannot be interpreted
// as a boolean then [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetBoolean(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_boolean(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBooleanList wraps g_key_file_get_boolean_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- length uint: the number of booleans returned 
// 	- goret []bool 
// 	- _goerr error (nullable): an error 
//
// Returns the values associated with @key under @group_name as
// booleans.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the values associated with @key cannot be interpreted
// as booleans then [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetBooleanList(groupName string, key string) (uint, []bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gboolean // return, transfer: container, C Pointers: 1, Name: array[gboolean], scope: , array (inner gboolean (*typesystem.BooleanPrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_boolean_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []bool
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []bool (gboolean*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetComment wraps g_key_file_get_comment
// 
// The function takes the following parameters:
// 
// 	- groupName string (nullable): a group name, or `NULL` to get a top-level comment 
// 	- key string (nullable): a key, or `NULL` to get a group comment 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Retrieves a comment above @key from @group_name.
// 
// If @key is `NULL` then @comment will be read from above
// @group_name. If both @key and @group_name are `NULL`, then
// @comment will be read from above the first group in the file.
// 
// Note that the returned string does not include the `#` comment markers,
// but does include any whitespace after them (on each line). It includes
// the line breaks between lines, but does not include the final line break.
func (keyFile *KeyFile) GetComment(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_key_file_get_comment(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDouble wraps g_key_file_get_double
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret float64 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name as a double.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the value associated with @key cannot be interpreted
// as a double then [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetDouble(groupName string, key string) (float64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gdouble   // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_double(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  float64
	var _goerr error

	goret = float64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDoubleList wraps g_key_file_get_double_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- length uint: the number of doubles returned 
// 	- goret []float64 
// 	- _goerr error (nullable): an error 
//
// Returns the values associated with @key under @group_name as
// doubles.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the values associated with @key cannot be interpreted
// as doubles then [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetDoubleList(groupName string, key string) (uint, []float64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gdouble  // return, transfer: container, C Pointers: 1, Name: array[gdouble], scope: , array (inner gdouble (*typesystem.CastablePrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_double_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []float64
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []float64 (gdouble*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetGroups wraps g_key_file_get_groups
// 
// The function returns the following values:
// 
// 	- length uint: return location for the number of returned groups,
//    or `NULL` to ignore 
// 	- goret []string 
//
// Returns all groups in the key file loaded with @key_file.
// 
// The array of returned groups will be `NULL`-terminated, so
// @length may optionally be `NULL`.
func (keyFile *KeyFile) GetGroups() (uint, []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_get_groups(carg0, &carg1)
	runtime.KeepAlive(keyFile)

	var length uint
	var goret  []string

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return length, goret
}

// GetInt64 wraps g_key_file_get_int64
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret int64 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name as a signed
// 64-bit integer.
// 
// This is similar to [method@GLib.KeyFile.get_integer] but can return
// 64-bit results without truncation.
func (keyFile *KeyFile) GetInt64(groupName string, key string) (int64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gint64    // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_int64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  int64
	var _goerr error

	goret = int64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetInteger wraps g_key_file_get_integer
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret int32 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name as an
// integer.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the value associated with @key cannot be interpreted
// as an integer, or is out of range for a `gint`, then
// [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetInteger(groupName string, key string) (int32, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gint      // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_integer(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetIntegerList wraps g_key_file_get_integer_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- length uint: the number of integers returned 
// 	- goret []int32 
// 	- _goerr error (nullable): an error 
//
// Returns the values associated with @key under @group_name as
// integers.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. Likewise, if the values associated with @key cannot be interpreted
// as integers, or are out of range for `gint`, then
// [error@GLib.KeyFileError.INVALID_VALUE] is returned.
func (keyFile *KeyFile) GetIntegerList(groupName string, key string) (uint, []int32, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gint     // return, transfer: container, C Pointers: 1, Name: array[gint], scope: , array (inner gint (*typesystem.CastablePrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_integer_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []int32
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []int32 (gint*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetKeys wraps g_key_file_get_keys
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 
// The function returns the following values:
// 
// 	- length uint: return location for the number of keys returned,
//    or `NULL` to ignore 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Returns all keys for the group name @group_name.
// 
// The array of returned keys will be `NULL`-terminated, so @length may
// optionally be `NULL`. If the @group_name cannot be found,
// [error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.
func (keyFile *KeyFile) GetKeys(groupName string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_get_keys(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetLocaleForKey wraps g_key_file_get_locale_for_key
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- locale string (nullable): a locale identifier or `NULL` to use the current locale 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the actual locale which the result of
// [method@GLib.KeyFile.get_locale_string] or
// [method@GLib.KeyFile.get_locale_string_list] came from.
// 
// If calling [method@GLib.KeyFile.get_locale_string] or
// [method@GLib.KeyFile.get_locale_string_list] with exactly the same @key_file,
// @group_name, @key and @locale, the result of those functions will
// have originally been tagged with the locale that is the result of
// this function.
func (keyFile *KeyFile) GetLocaleForKey(groupName string, key string, locale string) string {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string, nullable-string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_for_key(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetLocaleString wraps g_key_file_get_locale_string
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- locale string (nullable): a locale identifier or `NULL` to use the current locale 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name
// translated in the given @locale if available.
// 
// If @locale is `C` then the untranslated value is returned (since GLib 2.84).
// 
// If @locale is `NULL` then the current locale is assumed.
// 
// If @locale is to be non-`NULL`, or if the current locale will change over
// the lifetime of the [struct@GLib.KeyFile], it must be loaded with
// [flags@GLib.KeyFileFlags.KEEP_TRANSLATIONS] in order to load strings for all
// locales.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. If the value associated
// with @key cannot be interpreted or no suitable translation can
// be found then the untranslated value is returned.
func (keyFile *KeyFile) GetLocaleString(groupName string, key string, locale string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_string(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetLocaleStringList wraps g_key_file_get_locale_string_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- locale string (nullable): a locale identifier or `NULL` to use the current locale 
// 
// The function returns the following values:
// 
// 	- length uint: return location for the number of returned strings
//    or `NULL` to ignore 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Returns the values associated with @key under @group_name
// translated in the given @locale if available.
// 
// If @locale is `C` then the untranslated value is returned (since GLib 2.84).
// 
// If @locale is `NULL` then the current locale is assumed.
// 
// If @locale is to be non-`NULL`, or if the current locale will change over
// the lifetime of the [struct@GLib.KeyFile], it must be loaded with
// [flags@GLib.KeyFileFlags.KEEP_TRANSLATIONS] in order to load strings for all
// locales.
// 
// If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. If the values associated
// with @key cannot be interpreted or no suitable translations
// can be found then the untranslated values are returned. The
// returned array is `NULL`-terminated, so @length may optionally
// be `NULL`.
func (keyFile *KeyFile) GetLocaleStringList(groupName string, key string, locale string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_string_list(carg0, carg1, carg2, carg3, &carg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetStartGroup wraps g_key_file_get_start_group
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the name of the start group of the file.
func (keyFile *KeyFile) GetStartGroup() string {
	var carg0 *C.GKeyFile // in, none, converted
	var cret  *C.gchar    // return, full, string, nullable-string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_get_start_group(carg0)
	runtime.KeepAlive(keyFile)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetString wraps g_key_file_get_string
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Returns the string value associated with @key under @group_name.
// 
// Unlike [method@GLib.KeyFile.get_value], this function handles escape
// sequences like `\s`.
// 
// If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. If the @group_name cannot be found,
// [error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.
func (keyFile *KeyFile) GetString(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_string(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetStringList wraps g_key_file_get_string_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- length uint: return location for the number of returned
//    strings, or `NULL` to ignore 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Returns the values associated with @key under @group_name.
// 
// If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND] is
// returned. If the @group_name cannot be found,
// [error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.
func (keyFile *KeyFile) GetStringList(groupName string, key string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_string_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetUint64 wraps g_key_file_get_uint64
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret uint64 
// 	- _goerr error (nullable): an error 
//
// Returns the value associated with @key under @group_name as an unsigned
// 64-bit integer.
// 
// This is similar to [method@GLib.KeyFile.get_integer] but can return
// large positive results without truncation.
func (keyFile *KeyFile) GetUint64(groupName string, key string) (uint64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.guint64   // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_uint64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  uint64
	var _goerr error

	goret = uint64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetValue wraps g_key_file_get_value
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Returns the raw value associated with @key under @group_name.
// 
// Use [method@GLib.KeyFile.get_string] to retrieve an unescaped UTF-8 string.
// 
// If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND]
// is returned.  If the @group_name cannot be found,
// [error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.
func (keyFile *KeyFile) GetValue(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_value(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasGroup wraps g_key_file_has_group
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Looks whether the key file has the group @group_name.
func (keyFile *KeyFile) HasGroup(groupName string) bool {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_has_group(carg0, carg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadFromBytes wraps g_key_file_load_from_bytes
// 
// The function takes the following parameters:
// 
// 	- bytes *Bytes: a [struct@GLib.Bytes] 
// 	- flags KeyFileFlags: flags from [flags@GLib.KeyFileFlags] 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads a key file from the data in @bytes into an empty [struct@GLib.KeyFile]
// structure.
// 
// If the object cannot be created then a [error@GLib.KeyFileError] is returned.
func (keyFile *KeyFile) LoadFromBytes(bytes *Bytes, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.GBytes       // in, none, converted
	var carg2 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))
	carg2 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromData wraps g_key_file_load_from_data
// 
// The function takes the following parameters:
// 
// 	- data string: key file loaded in memory 
// 	- length uint: the length of @data in bytes (or `(gsize)-1` if data is nul-terminated) 
// 	- flags KeyFileFlags: flags from [flags@GLib.KeyFileFlags] 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads a key file from memory into an empty [struct@GLib.KeyFile] structure.
// 
// If the object cannot be created then a [error@GLib.KeyFileError is returned.
func (keyFile *KeyFile) LoadFromData(data string, length uint, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gsize         // in, none, casted
	var carg3 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(data)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gsize(length)
	carg3 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_data(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromDataDirs wraps g_key_file_load_from_data_dirs
// 
// The function takes the following parameters:
// 
// 	- file string: a relative path to a filename to open and parse 
// 	- flags KeyFileFlags: flags from [flags@GLib.KeyFileFlags] 
// 
// The function returns the following values:
// 
// 	- fullPath string: return location for a string
//    containing the full path of the file, or `NULL` to ignore 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Looks for a key file named @file in the paths returned from
// [func@GLib.get_user_data_dir] and [func@GLib.get_system_data_dirs].
// 
// The search algorithm from [method@GLib.KeyFile.load_from_dirs] is used. If
// @file is found, it&#x2019;s loaded into @key_file and its full path is returned in
// @full_path.
// 
// If the file could not be loaded then either a [error@GLib.FileError] or
// [error@GLib.KeyFileError] is returned.
func (keyFile *KeyFile) LoadFromDataDirs(file string, flags KeyFileFlags) (string, bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg3 C.GKeyFileFlags // in, none, casted
	var carg2 *C.gchar        // out, full, string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_data_dirs(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromDirs wraps g_key_file_load_from_dirs
// 
// The function takes the following parameters:
// 
// 	- file string: a relative path to a filename to open and parse 
// 	- searchDirs []string: `NULL`-terminated
//    array of directories to search 
// 	- flags KeyFileFlags: flags from [flags@GLib.KeyFileFlags] 
// 
// The function returns the following values:
// 
// 	- fullPath string: return location for a string
//    containing the full path of the file, or `NULL` to ignore 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Looks for a key file named @file in the paths specified in @search_dirs,
// loads the file into @key_file and returns the file&#x2019;s full path in @full_path.
// 
// @search_dirs are checked in the order listed in the array, with the highest
// priority directory listed first. Within each directory, @file is looked for.
// If it&#x2019;s not found, `-` characters in @file are progressively replaced with
// directory separators to search subdirectories of the search directory. If the
// file has not been found after all `-` characters have been replaced, the next
// search directory in @search_dirs is checked.
// 
// If the file could not be found in any of the @search_dirs,
// [error@GLib.KeyFileError.NOT_FOUND] is returned. If
// the file is found but the OS returns an error when opening or reading the
// file, a [error@GLib.FileError] is returned. If there is a problem parsing the
// file, a [error@GLib.KeyFileError] is returned.
func (keyFile *KeyFile) LoadFromDirs(file string, searchDirs []string, flags KeyFileFlags) (string, bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 **C.gchar       // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg4 C.GKeyFileFlags // in, none, casted
	var carg3 *C.gchar        // out, full, string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	_ = searchDirs
	_ = carg2
	panic("unimplemented conversion of []string (const gchar**) because of unimplemented: inner pointers in array")
	carg4 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_dirs(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(searchDirs)
	runtime.KeepAlive(flags)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromFile wraps g_key_file_load_from_file
// 
// The function takes the following parameters:
// 
// 	- file string: the path of a filename to load, in the GLib filename encoding 
// 	- flags KeyFileFlags: flags from [flags@GLib.KeyFileFlags] 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Loads a key file into an empty [struct@GLib.KeyFile] structure.
// 
// If the OS returns an error when opening or reading the file, a
// [error@GLib.FileError] is returned. If there is a problem parsing the file,
// a [error@GLib.KeyFileError] is returned.
// 
// This function will never return a [error@GLib.KeyFileError.NOT_FOUND]
// error. If the @file is not found, [error@GLib.FileError.NOENT] is returned.
func (keyFile *KeyFile) LoadFromFile(file string, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_file(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveComment wraps g_key_file_remove_comment
// 
// The function takes the following parameters:
// 
// 	- groupName string (nullable): a group name, or `NULL` to get a top-level comment 
// 	- key string (nullable): a key, or `NULL` to get a group comment 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes a comment above @key from @group_name.
// 
// If @key is `NULL` then @comment will be removed above @group_name.
// If both @key and @group_name are `NULL`, then @comment will
// be removed above the first group in the file.
func (keyFile *KeyFile) RemoveComment(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_key_file_remove_comment(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveGroup wraps g_key_file_remove_group
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes the specified group, @group_name,
// from the key file.
func (keyFile *KeyFile) RemoveGroup(groupName string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_remove_group(carg0, carg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveKey wraps g_key_file_remove_key
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key name to remove 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Removes @key in @group_name from the key file.
func (keyFile *KeyFile) RemoveKey(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_remove_key(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SaveToFile wraps g_key_file_save_to_file
// 
// The function takes the following parameters:
// 
// 	- filename string: the name of the file to write to 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Writes the contents of @key_file to @filename using
// [func@GLib.file_set_contents].
// 
// If you need stricter guarantees about durability of
// the written file than are provided by [func@GLib.file_set_contents], use
// [func@GLib.file_set_contents_full] with the return value of
// [method@GLib.KeyFile.to_data].
// 
// This function can fail for any of the reasons that
// [func@GLib.file_set_contents] may fail.
func (keyFile *KeyFile) SaveToFile(filename string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_save_to_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBoolean wraps g_key_file_set_boolean
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value bool: true or false 
//
// Associates a new boolean value with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetBoolean(groupName string, key string, value bool) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gboolean  // in

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if value {
		carg3 = C.TRUE
	}

	C.g_key_file_set_boolean(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetBooleanList wraps g_key_file_set_boolean_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- list []bool: an array of boolean values 
//
// Associates a list of boolean values with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetBooleanList(groupName string, key string, list []bool) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gboolean // in, transfer: none, C Pointers: 1, Name: array[gboolean], array (inner gboolean (*typesystem.BooleanPrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []bool (gboolean*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_boolean_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetComment wraps g_key_file_set_comment
// 
// The function takes the following parameters:
// 
// 	- groupName string (nullable): a group name, or `NULL` to write a top-level comment 
// 	- key string (nullable): a key, or `NULL` to write a group comment 
// 	- comment string: a comment 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Places a comment above @key from @group_name.
// 
// If @key is `NULL` then @comment will be written above @group_name.
// If both @key and @group_name are `NULL`, then @comment will be
// written above the first group in the file.
// 
// Passing a non-existent @group_name or @key to this function returns
// false and populates @error. (In contrast, passing a non-existent
// `group_name` or `key` to [method@GLib.KeyFile.set_string]
// creates the associated group name and key.)
// 
// Note that this function prepends a `#` comment marker to
// each line of @comment.
func (keyFile *KeyFile) SetComment(groupName string, key string, comment string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var carg3 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(comment)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_key_file_set_comment(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(comment)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDouble wraps g_key_file_set_double
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value float64: a double value 
//
// Associates a new double value with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetDouble(groupName string, key string, value float64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gdouble   // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gdouble(value)

	C.g_key_file_set_double(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetDoubleList wraps g_key_file_set_double_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- list []float64: an array of double values 
//
// Associates a list of double values with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetDoubleList(groupName string, key string, list []float64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gdouble  // in, transfer: none, C Pointers: 1, Name: array[gdouble], array (inner gdouble (*typesystem.CastablePrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []float64 (gdouble*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_double_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetInt64 wraps g_key_file_set_int64
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value int64: an integer value 
//
// Associates a new integer value with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetInt64(groupName string, key string, value int64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gint64    // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint64(value)

	C.g_key_file_set_int64(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetInteger wraps g_key_file_set_integer
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value int32: an integer value 
//
// Associates a new integer value with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetInteger(groupName string, key string, value int32) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gint      // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(value)

	C.g_key_file_set_integer(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetIntegerList wraps g_key_file_set_integer_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- list []int32: an array of integer values 
//
// Associates a list of integer values with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetIntegerList(groupName string, key string, list []int32) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gint     // in, transfer: none, C Pointers: 1, Name: array[gint], array (inner gint (*typesystem.CastablePrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []int32 (gint*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_integer_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetListSeparator wraps g_key_file_set_list_separator
// 
// The function takes the following parameters:
// 
// 	- separator byte: the separator 
//
// Sets the character which is used to separate values in lists.
// 
// Typically `;` or `,` are used as separators. The default list separator
// is `;`.
func (keyFile *KeyFile) SetListSeparator(separator byte) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gchar     // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = C.gchar(separator)

	C.g_key_file_set_list_separator(carg0, carg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(separator)
}

// SetLocaleString wraps g_key_file_set_locale_string
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- locale string: a locale identifier 
// 	- str string: a string 
//
// Associates a string value for @key and @locale under @group_name.
// 
// If the translation for @key cannot be found then it is created.
// 
// If @locale is `C` then the untranslated value is set (since GLib 2.84).
func (keyFile *KeyFile) SetLocaleString(groupName string, key string, locale string, str string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string
	var carg4 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_key_file_set_locale_string(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(str)
}

// SetLocaleStringList wraps g_key_file_set_locale_string_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- locale string: a locale identifier 
// 	- list []string: a `NULL`-terminated array of
//    locale string values 
//
// Associates a list of string values for @key and @locale under
// @group_name.
// 
// If @locale is `C` then the untranslated value is set (since GLib 2.84).
// 
// If the translation for @key cannot be found then it is created.
func (keyFile *KeyFile) SetLocaleStringList(groupName string, key string, locale string, list []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string
	var carg4 **C.gchar   // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg5)
	var carg5 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg3))
	_ = list
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_key_file_set_locale_string_list(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(list)
}

// SetString wraps g_key_file_set_string
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- str string: a string 
//
// Associates a new string value with @key under @group_name.
// 
// If @key cannot be found then it is created.
// If @group_name cannot be found then it is created.
// Unlike [method@GLib.KeyFile.set_value], this function handles characters
// that need escaping, such as newlines.
func (keyFile *KeyFile) SetString(groupName string, key string, str string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_key_file_set_string(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)
}

// SetStringList wraps g_key_file_set_string_list
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- list []string: an array
//    of string values 
//
// Associates a list of string values for @key under @group_name.
// 
// If @key cannot be found then it is created.
// If @group_name cannot be found then it is created.
func (keyFile *KeyFile) SetStringList(groupName string, key string, list []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 **C.gchar   // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_key_file_set_string_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetUint64 wraps g_key_file_set_uint64
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value uint64: an integer value 
//
// Associates a new integer value with @key under @group_name.
// 
// If @key cannot be found then it is created.
func (keyFile *KeyFile) SetUint64(groupName string, key string, value uint64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.guint64   // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.guint64(value)

	C.g_key_file_set_uint64(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetValue wraps g_key_file_set_value
// 
// The function takes the following parameters:
// 
// 	- groupName string: a group name 
// 	- key string: a key 
// 	- value string: a string 
//
// Associates a new value with @key under @group_name.
// 
// If @key cannot be found then it is created. If @group_name cannot
// be found then it is created. To set an UTF-8 string which may contain
// characters that need escaping (such as newlines or spaces), use
// [method@GLib.KeyFile.set_string].
func (keyFile *KeyFile) SetValue(groupName string, key string, value string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_key_file_set_value(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// ToData wraps g_key_file_to_data
// 
// The function returns the following values:
// 
// 	- length uint: return location for the length of the
//   returned string, or `NULL` to ignore 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Outputs @key_file as a string.
// 
// Note that this function never reports an error.
func (keyFile *KeyFile) ToData() (uint, string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gsize     // out, full, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_to_data(carg0, &carg1, &_cerr)
	runtime.KeepAlive(keyFile)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// LogField wraps GLogField
//
// Structure representing a single field in a structured log entry. See
// g_log_structured() for details.
// 
// Log fields may contain arbitrary values, including binary with embedded nul
// bytes. If the field contains a string, the string must be UTF-8 encoded and
// have a trailing nul byte. Otherwise, @length must be set to a non-negative
// value.
type LogField struct {
	*logField
}

// logField is the struct that's finalized
type logField struct {
	native *C.GLogField
}

// UnsafeLogFieldToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *LogField) instance() *C.GLogField {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeLogFieldFromGlibBorrow is used to convert raw C.GLogField pointers to go. This is used by the bindings internally.
func UnsafeLogFieldFromGlibBorrow(p unsafe.Pointer) *LogField {
	if p == nil {
		return nil
	}
	return &LogField{&logField{(*C.GLogField)(p)}}
}

// UnsafeLogFieldFromGlibNone is used to convert raw C.GLogField pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeLogFieldFromGlibNone(p unsafe.Pointer) *LogField {
	wrapped := UnsafeLogFieldFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to LogField because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeLogFieldFromGlibFull is used to convert raw C.GLogField pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeLogFieldFromGlibFull(p unsafe.Pointer) *LogField {
	wrapped := UnsafeLogFieldFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.logField,
		func (intern *logField) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeLogFieldFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [LogField] is expected to work anymore.
func UnsafeLogFieldFree(l *LogField) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeLogFieldToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeLogFieldToGlibNone(l *LogField) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeLogFieldToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeLogFieldToGlibFull(l *LogField) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.logField, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // LogField is invalid from here on
	return _p
}

// MainContext wraps GMainContext
//
// The `GMainContext` struct is an opaque data
// type representing a set of sources to be handled in a main loop.
type MainContext struct {
	*mainContext
}

// mainContext is the struct that's finalized
type mainContext struct {
	native *C.GMainContext
}

// UnsafeMainContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MainContext) instance() *C.GMainContext {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMainContextFromGlibBorrow is used to convert raw C.GMainContext pointers to go. This is used by the bindings internally.
func UnsafeMainContextFromGlibBorrow(p unsafe.Pointer) *MainContext {
	if p == nil {
		return nil
	}
	return &MainContext{&mainContext{(*C.GMainContext)(p)}}
}

// UnsafeMainContextFromGlibNone is used to convert raw C.GMainContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMainContextFromGlibNone(p unsafe.Pointer) *MainContext {
	C.g_main_context_ref((*C.GMainContext)(p))
	wrapped := UnsafeMainContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mainContext,
		func (intern *mainContext) {
			C.g_main_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainContextFromGlibFull is used to convert raw C.GMainContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMainContextFromGlibFull(p unsafe.Pointer) *MainContext {
	wrapped := UnsafeMainContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mainContext,
		func (intern *mainContext) {
			C.g_main_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainContextRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MainContext.UnsafeMainContextUnref], then [MainContext] will leak memory.
func UnsafeMainContextRef(m *MainContext) {
	C.g_main_context_ref(m.native)
}

// UnsafeMainContextUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MainContext] is expected to work anymore.
func UnsafeMainContextUnref(m *MainContext) {
	C.g_main_context_unref(m.native)
}

// UnsafeMainContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMainContextToGlibNone(m *MainContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMainContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMainContextToGlibFull(m *MainContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mainContext, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MainContext is invalid from here on
	return _p
}

// NewMainContext wraps g_main_context_new
// 
// The function returns the following values:
// 
// 	- goret *MainContext 
//
// Creates a new [struct@GLib.MainContext] structure.
func NewMainContext() *MainContext {
	var cret *C.GMainContext // return, full, converted

	cret = C.g_main_context_new()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMainContextWithFlags wraps g_main_context_new_with_flags
// 
// The function takes the following parameters:
// 
// 	- flags MainContextFlags: a bitwise-OR combination of #GMainContextFlags flags that can only be
//         set at creation time. 
// 
// The function returns the following values:
// 
// 	- goret *MainContext 
//
// Creates a new [struct@GLib.MainContext] structure.
func NewMainContextWithFlags(flags MainContextFlags) *MainContext {
	var carg1 C.GMainContextFlags // in, none, casted
	var cret  *C.GMainContext     // return, full, converted

	carg1 = C.GMainContextFlags(flags)

	cret = C.g_main_context_new_with_flags(carg1)
	runtime.KeepAlive(flags)

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// MainContextDefault wraps g_main_context_default
// 
// The function returns the following values:
// 
// 	- goret *MainContext 
//
// Returns the global-default main context. This is the main context
// used for main loop functions when a main loop is not explicitly
// specified, and corresponds to the "main" main loop. See also
// [func@GLib.MainContext.get_thread_default].
func MainContextDefault() *MainContext {
	var cret *C.GMainContext // return, none, converted

	cret = C.g_main_context_default()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// MainContextGetThreadDefault wraps g_main_context_get_thread_default
// 
// The function returns the following values:
// 
// 	- goret *MainContext (nullable) 
//
// Gets the thread-default #GMainContext for this thread. Asynchronous
// operations that want to be able to be run in contexts other than
// the default one should call this method or
// [func@GLib.MainContext.ref_thread_default] to get a
// [struct@GLib.MainContext] to add their [struct@GLib.Source]s to. (Note that
// even in single-threaded programs applications may sometimes want to
// temporarily push a non-default context, so it is not safe to assume that
// this will always return %NULL if you are running in the default thread.)
// 
// If you need to hold a reference on the context, use
// [func@GLib.MainContext.ref_thread_default] instead.
func MainContextGetThreadDefault() *MainContext {
	var cret *C.GMainContext // return, none, converted, nullable

	cret = C.g_main_context_get_thread_default()

	var goret *MainContext

	if cret != nil {
		goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// MainContextRefThreadDefault wraps g_main_context_ref_thread_default
// 
// The function returns the following values:
// 
// 	- goret *MainContext 
//
// Gets the thread-default [struct@GLib.MainContext] for this thread, as with
// [func@GLib.MainContext.get_thread_default], but also adds a reference to
// it with [method@GLib.MainContext.ref]. In addition, unlike
// [func@GLib.MainContext.get_thread_default], if the thread-default context
// is the global-default context, this will return that
// [struct@GLib.MainContext] (with a ref added to it) rather than returning
// %NULL.
func MainContextRefThreadDefault() *MainContext {
	var cret *C.GMainContext // return, full, converted

	cret = C.g_main_context_ref_thread_default()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Acquire wraps g_main_context_acquire
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tries to become the owner of the specified context.
// If some other thread is the owner of the context,
// returns %FALSE immediately. Ownership is properly
// recursive: the owner can require ownership again
// and will release ownership when [method@GLib.MainContext.release]
// is called as many times as [method@GLib.MainContext.acquire].
// 
// You must be the owner of a context before you
// can call [method@GLib.MainContext.prepare], [method@GLib.MainContext.query],
// [method@GLib.MainContext.check], [method@GLib.MainContext.dispatch],
// [method@GLib.MainContext.release].
// 
// Since 2.76 @context can be %NULL to use the global-default
// main context.
func (_context *MainContext) Acquire() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_acquire(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// AddPoll wraps g_main_context_add_poll
// 
// The function takes the following parameters:
// 
// 	- fd *PollFD: a #GPollFD structure holding information about a file
//      descriptor to watch. 
// 	- priority int32: the priority for this file descriptor which should be
//      the same as the priority used for [method@GLib.Source.attach] to ensure
//      that the file descriptor is polled whenever the results may be needed. 
//
// Adds a file descriptor to the set of file descriptors polled for
// this context. This will very seldom be used directly. Instead
// a typical event source will use `g_source_add_unix_fd` instead.
func (_context *MainContext) AddPoll(fd *PollFD, priority int32) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted
	var carg2 C.gint          // in, none, casted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fd))
	carg2 = C.gint(priority)

	C.g_main_context_add_poll(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(priority)
}

// Check wraps g_main_context_check
// 
// The function takes the following parameters:
// 
// 	- maxPriority int32: the maximum numerical priority of sources to check 
// 	- fds []PollFD: array of #GPollFD's that was passed to
//       the last call to [method@GLib.MainContext.query] 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Passes the results of polling back to the main loop. You should be
// careful to pass @fds and its length @n_fds as received from
// [method@GLib.MainContext.query], as this functions relies on assumptions
// on how @fds is filled.
// 
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
// 
// Since 2.76 @context can be %NULL to use the global-default
// main context.
func (_context *MainContext) Check(maxPriority int32, fds []PollFD) bool {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gint          // in, none, casted
	var carg2 *C.GPollFD      // in, transfer: none, C Pointers: 1, Name: array[PollFD], array (inner GPollFD (*typesystem.Record), length-by: carg3)
	var carg3 C.gint          // implicit
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = C.gint(maxPriority)
	_ = fds
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []PollFD (GPollFD*) because of unimplemented: non-fixed size array")

	cret = C.g_main_context_check(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(maxPriority)
	runtime.KeepAlive(fds)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Dispatch wraps g_main_context_dispatch
//
// Dispatches all pending sources.
// 
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
// 
// Since 2.76 @context can be %NULL to use the global-default
// main context.
func (_context *MainContext) Dispatch() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_dispatch(carg0)
	runtime.KeepAlive(_context)
}

// InvokeFull wraps g_main_context_invoke_full
// 
// The function takes the following parameters:
// 
// 	- priority int32: the priority at which to run @function 
// 	- function SourceFunc: function to call 
//
// Invokes a function in such a way that @context is owned during the
// invocation of @function.
// 
// This function is the same as [method@GLib.MainContext.invoke] except that it
// lets you specify the priority in case @function ends up being
// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
// 
// @notify should not assume that it is called from any particular
// thread or with any particular context acquired.
func (_context *MainContext) InvokeFull(priority int32, function SourceFunc) {
	var carg0 *C.GMainContext  // in, none, converted
	var carg1 C.gint           // in, none, casted
	var carg2 C.GSourceFunc    // callback, scope: notified, closure: carg3, destroy: carg4
	var carg3 C.gpointer       // implicit
	var carg4 C.GDestroyNotify // implicit

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = C.gint(priority)
	carg2 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg3 = C.gpointer(userdata.Register(function))
	carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	C.g_main_context_invoke_full(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)
}

// IsOwner wraps g_main_context_is_owner
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines whether this thread holds the (recursive)
// ownership of this [struct@GLib.MainContext]. This is useful to
// know before waiting on another thread that may be
// blocking to get ownership of @context.
func (_context *MainContext) IsOwner() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_is_owner(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Iteration wraps g_main_context_iteration
// 
// The function takes the following parameters:
// 
// 	- mayBlock bool: whether the call may block. 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed,
// then if no events sources are ready and @may_block is %TRUE, waiting
// for a source to become ready, then dispatching the highest priority
// events sources that are ready. Otherwise, if @may_block is %FALSE
// sources are not waited to become ready, only those highest priority
// events sources will be dispatched (if any), that are ready at this
// given moment without further waiting.
// 
// Note that even when @may_block is %TRUE, it is still possible for
// [method@GLib.MainContext.iteration] to return %FALSE, since the wait may
// be interrupted for other reasons than an event source becoming ready.
func (_context *MainContext) Iteration(mayBlock bool) bool {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gboolean      // in
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	if mayBlock {
		carg1 = C.TRUE
	}

	cret = C.g_main_context_iteration(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(mayBlock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Pending wraps g_main_context_pending
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if any sources have pending events for the given context.
func (_context *MainContext) Pending() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_pending(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PopThreadDefault wraps g_main_context_pop_thread_default
//
// Pops @context off the thread-default context stack (verifying that
// it was on the top of the stack).
func (_context *MainContext) PopThreadDefault() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_pop_thread_default(carg0)
	runtime.KeepAlive(_context)
}

// Prepare wraps g_main_context_prepare
// 
// The function returns the following values:
// 
// 	- priority int32: location to store priority of highest priority
//            source already ready. 
// 	- goret bool 
//
// Prepares to poll sources within a main loop. The resulting information
// for polling is determined by calling [method@GLib.MainContext.query].
// 
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
func (_context *MainContext) Prepare() (int32, bool) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gint          // out, full, casted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_prepare(carg0, &carg1)
	runtime.KeepAlive(_context)

	var priority int32
	var goret    bool

	priority = int32(carg1)
	if cret != 0 {
		goret = true
	}

	return priority, goret
}

// PushThreadDefault wraps g_main_context_push_thread_default
//
// Acquires @context and sets it as the thread-default context for the
// current thread. This will cause certain asynchronous operations
// (such as most [Gio](../gio/index.html)-based I/O) which are
// started in this thread to run under @context and deliver their
// results to its main loop, rather than running under the global
// default main context in the main thread. Note that calling this function
// changes the context returned by [func@GLib.MainContext.get_thread_default],
// not the one returned by [func@GLib.MainContext.default], so it does not
// affect the context used by functions like [func@GLib.idle_add].
// 
// Normally you would call this function shortly after creating a new
// thread, passing it a [struct@GLib.MainContext] which will be run by a
// [struct@GLib.MainLoop] in that thread, to set a new default context for all
// async operations in that thread. In this case you may not need to
// ever call [method@GLib.MainContext.pop_thread_default], assuming you want
// the new [struct@GLib.MainContext] to be the default for the whole lifecycle
// of the thread.
// 
// If you don't have control over how the new thread was created (e.g.
// in the new thread isn't newly created, or if the thread life
// cycle is managed by a #GThreadPool), it is always suggested to wrap
// the logic that needs to use the new [struct@GLib.MainContext] inside a
// [method@GLib.MainContext.push_thread_default] /
// [method@GLib.MainContext.pop_thread_default] pair, otherwise threads that
// are re-used will end up never explicitly releasing the
// [struct@GLib.MainContext] reference they hold.
// 
// In some cases you may want to schedule a single operation in a
// non-default context, or temporarily use a non-default context in
// the main thread. In that case, you can wrap the call to the
// asynchronous operation inside a
// [method@GLib.MainContext.push_thread_default] /
// [method@GLib.MainContext.pop_thread_default] pair, but it is up to you to
// ensure that no other asynchronous operations accidentally get
// started while the non-default context is active.
// 
// Beware that libraries that predate this function may not correctly
// handle being used from a thread with a thread-default context. Eg,
// see g_file_supports_thread_contexts().
func (_context *MainContext) PushThreadDefault() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_push_thread_default(carg0)
	runtime.KeepAlive(_context)
}

// Release wraps g_main_context_release
//
// Releases ownership of a context previously acquired by this thread
// with [method@GLib.MainContext.acquire]. If the context was acquired multiple
// times, the ownership will be released only when [method@GLib.MainContext.release]
// is called as many times as it was acquired.
// 
// You must have successfully acquired the context with
// [method@GLib.MainContext.acquire] before you may call this function.
func (_context *MainContext) Release() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_release(carg0)
	runtime.KeepAlive(_context)
}

// RemovePoll wraps g_main_context_remove_poll
// 
// The function takes the following parameters:
// 
// 	- fd *PollFD: a #GPollFD descriptor previously added with
//   [method@GLib.MainContext.add_poll] 
//
// Removes file descriptor from the set of file descriptors to be
// polled for a particular context.
func (_context *MainContext) RemovePoll(fd *PollFD) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fd))

	C.g_main_context_remove_poll(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(fd)
}

// Wakeup wraps g_main_context_wakeup
//
// If @context is currently blocking in [method@GLib.MainContext.iteration]
// waiting for a source to become ready, cause it to stop blocking
// and return.  Otherwise, cause the next invocation of
// [method@GLib.MainContext.iteration] to return without blocking.
// 
// This API is useful for low-level control over [struct@GLib.MainContext]; for
// example, integrating it with main loop implementations such as
// [struct@GLib.MainLoop].
// 
// Another related use for this function is when implementing a main
// loop with a termination condition, computed from multiple threads:
// 
// |[&lt;!-- language="C" --&gt;
//   #define NUM_TASKS 10
//   static gint tasks_remaining = NUM_TASKS;  // (atomic)
//   ...
//  
//   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
//     g_main_context_iteration (NULL, TRUE);
// ]|
//  
// Then in a thread:
// |[&lt;!-- language="C" --&gt;
//   perform_work();
// 
//   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
//     g_main_context_wakeup (NULL);
// ]|
func (_context *MainContext) Wakeup() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_wakeup(carg0)
	runtime.KeepAlive(_context)
}

// MainLoop wraps GMainLoop
//
// The `GMainLoop` struct is an opaque data type
// representing the main event loop of a GLib or GTK application.
type MainLoop struct {
	*mainLoop
}

// mainLoop is the struct that's finalized
type mainLoop struct {
	native *C.GMainLoop
}

// UnsafeMainLoopToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MainLoop) instance() *C.GMainLoop {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMainLoopFromGlibBorrow is used to convert raw C.GMainLoop pointers to go. This is used by the bindings internally.
func UnsafeMainLoopFromGlibBorrow(p unsafe.Pointer) *MainLoop {
	if p == nil {
		return nil
	}
	return &MainLoop{&mainLoop{(*C.GMainLoop)(p)}}
}

// UnsafeMainLoopFromGlibNone is used to convert raw C.GMainLoop pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMainLoopFromGlibNone(p unsafe.Pointer) *MainLoop {
	C.g_main_loop_ref((*C.GMainLoop)(p))
	wrapped := UnsafeMainLoopFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mainLoop,
		func (intern *mainLoop) {
			C.g_main_loop_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainLoopFromGlibFull is used to convert raw C.GMainLoop pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMainLoopFromGlibFull(p unsafe.Pointer) *MainLoop {
	wrapped := UnsafeMainLoopFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mainLoop,
		func (intern *mainLoop) {
			C.g_main_loop_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainLoopRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MainLoop.UnsafeMainLoopUnref], then [MainLoop] will leak memory.
func UnsafeMainLoopRef(m *MainLoop) {
	C.g_main_loop_ref(m.native)
}

// UnsafeMainLoopUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MainLoop] is expected to work anymore.
func UnsafeMainLoopUnref(m *MainLoop) {
	C.g_main_loop_unref(m.native)
}

// UnsafeMainLoopToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMainLoopToGlibNone(m *MainLoop) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMainLoopToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMainLoopToGlibFull(m *MainLoop) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mainLoop, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MainLoop is invalid from here on
	return _p
}

// NewMainLoop wraps g_main_loop_new
// 
// The function takes the following parameters:
// 
// 	- _context *MainContext (nullable): a #GMainContext  (if %NULL, the global-default
//   main context will be used). 
// 	- isRunning bool: set to %TRUE to indicate that the loop is running. This
// is not very important since calling [method@GLib.MainLoop.run] will set this
// to %TRUE anyway. 
// 
// The function returns the following values:
// 
// 	- goret *MainLoop 
//
// Creates a new [struct@GLib.MainLoop] structure.
func NewMainLoop(_context *MainContext, isRunning bool) *MainLoop {
	var carg1 *C.GMainContext // in, none, converted, nullable
	var carg2 C.gboolean      // in
	var cret  *C.GMainLoop    // return, full, converted

	if _context != nil {
		carg1 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	}
	if isRunning {
		carg2 = C.TRUE
	}

	cret = C.g_main_loop_new(carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(isRunning)

	var goret *MainLoop

	goret = UnsafeMainLoopFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContext wraps g_main_loop_get_context
// 
// The function returns the following values:
// 
// 	- goret *MainContext 
//
// Returns the [struct@GLib.MainContext] of @loop.
func (loop *MainLoop) GetContext() *MainContext {
	var carg0 *C.GMainLoop    // in, none, converted
	var cret  *C.GMainContext // return, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	cret = C.g_main_loop_get_context(carg0)
	runtime.KeepAlive(loop)

	var goret *MainContext

	goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsRunning wraps g_main_loop_is_running
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks to see if the main loop is currently being run via
// [method@GLib.MainLoop.run].
func (loop *MainLoop) IsRunning() bool {
	var carg0 *C.GMainLoop // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	cret = C.g_main_loop_is_running(carg0)
	runtime.KeepAlive(loop)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Quit wraps g_main_loop_quit
//
// Stops a [struct@GLib.MainLoop] from running. Any calls to
// [method@GLib.MainLoop.run] for the loop will return.
// 
// Note that sources that have already been dispatched when
// [method@GLib.MainLoop.quit] is called will still be executed.
func (loop *MainLoop) Quit() {
	var carg0 *C.GMainLoop // in, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	C.g_main_loop_quit(carg0)
	runtime.KeepAlive(loop)
}

// Run wraps g_main_loop_run
//
// Runs a main loop until [method@GLib.MainLoop.quit] is called on the loop.
// If this is called for the thread of the loop's #GMainContext,
// it will process events from the loop, otherwise it will
// simply wait.
func (loop *MainLoop) Run() {
	var carg0 *C.GMainLoop // in, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	C.g_main_loop_run(carg0)
	runtime.KeepAlive(loop)
}

// MappedFile wraps GMappedFile
//
// The #GMappedFile represents a file mapping created with
// g_mapped_file_new(). It has only private members and should
// not be accessed directly.
type MappedFile struct {
	*mappedFile
}

// mappedFile is the struct that's finalized
type mappedFile struct {
	native *C.GMappedFile
}

// UnsafeMappedFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MappedFile) instance() *C.GMappedFile {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMappedFileFromGlibBorrow is used to convert raw C.GMappedFile pointers to go. This is used by the bindings internally.
func UnsafeMappedFileFromGlibBorrow(p unsafe.Pointer) *MappedFile {
	if p == nil {
		return nil
	}
	return &MappedFile{&mappedFile{(*C.GMappedFile)(p)}}
}

// UnsafeMappedFileFromGlibNone is used to convert raw C.GMappedFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMappedFileFromGlibNone(p unsafe.Pointer) *MappedFile {
	C.g_mapped_file_ref((*C.GMappedFile)(p))
	wrapped := UnsafeMappedFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mappedFile,
		func (intern *mappedFile) {
			C.g_mapped_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMappedFileFromGlibFull is used to convert raw C.GMappedFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMappedFileFromGlibFull(p unsafe.Pointer) *MappedFile {
	wrapped := UnsafeMappedFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mappedFile,
		func (intern *mappedFile) {
			C.g_mapped_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMappedFileRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MappedFile.UnsafeMappedFileUnref], then [MappedFile] will leak memory.
func UnsafeMappedFileRef(m *MappedFile) {
	C.g_mapped_file_ref(m.native)
}

// UnsafeMappedFileUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MappedFile] is expected to work anymore.
func UnsafeMappedFileUnref(m *MappedFile) {
	C.g_mapped_file_unref(m.native)
}

// UnsafeMappedFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMappedFileToGlibNone(m *MappedFile) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMappedFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMappedFileToGlibFull(m *MappedFile) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mappedFile, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MappedFile is invalid from here on
	return _p
}

// NewMappedFile wraps g_mapped_file_new
// 
// The function takes the following parameters:
// 
// 	- filename string: The path of the file to load, in the GLib
//     filename encoding 
// 	- writable bool: whether the mapping should be writable 
// 
// The function returns the following values:
// 
// 	- goret *MappedFile 
// 	- _goerr error (nullable): an error 
//
// Maps a file into memory. On UNIX, this is using the mmap() function.
// 
// If @writable is %TRUE, the mapped buffer may be modified, otherwise
// it is an error to modify the mapped buffer. Modifications to the buffer
// are not visible to other processes mapping the same file, and are not
// written back to the file.
// 
// Note that modifications of the underlying file might affect the contents
// of the #GMappedFile. Therefore, mapping should only be used if the file
// will not be modified, or if all modifications of the file are done
// atomically (e.g. using g_file_set_contents()).
// 
// If @filename is the name of an empty, regular file, the function
// will successfully return an empty #GMappedFile. In other cases of
// size 0 (e.g. device files such as /dev/null), @error will be set
// to the #GFileError value %G_FILE_ERROR_INVAL.
func NewMappedFile(filename string, writable bool) (*MappedFile, error) {
	var carg1 *C.gchar       // in, none, string
	var carg2 C.gboolean     // in
	var cret  *C.GMappedFile // return, full, converted
	var _cerr *C.GError      // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if writable {
		carg2 = C.TRUE
	}

	cret = C.g_mapped_file_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(writable)

	var goret  *MappedFile
	var _goerr error

	goret = UnsafeMappedFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewMappedFileFromFd wraps g_mapped_file_new_from_fd
// 
// The function takes the following parameters:
// 
// 	- fd int32: The file descriptor of the file to load 
// 	- writable bool: whether the mapping should be writable 
// 
// The function returns the following values:
// 
// 	- goret *MappedFile 
// 	- _goerr error (nullable): an error 
//
// Maps a file into memory. On UNIX, this is using the mmap() function.
// 
// If @writable is %TRUE, the mapped buffer may be modified, otherwise
// it is an error to modify the mapped buffer. Modifications to the buffer
// are not visible to other processes mapping the same file, and are not
// written back to the file.
// 
// Note that modifications of the underlying file might affect the contents
// of the #GMappedFile. Therefore, mapping should only be used if the file
// will not be modified, or if all modifications of the file are done
// atomically (e.g. using g_file_set_contents()).
func NewMappedFileFromFd(fd int32, writable bool) (*MappedFile, error) {
	var carg1 C.gint         // in, none, casted
	var carg2 C.gboolean     // in
	var cret  *C.GMappedFile // return, full, converted
	var _cerr *C.GError      // out, full, converted, nullable

	carg1 = C.gint(fd)
	if writable {
		carg2 = C.TRUE
	}

	cret = C.g_mapped_file_new_from_fd(carg1, carg2, &_cerr)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(writable)

	var goret  *MappedFile
	var _goerr error

	goret = UnsafeMappedFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBytes wraps g_mapped_file_get_bytes
// 
// The function returns the following values:
// 
// 	- goret *Bytes 
//
// Creates a new #GBytes which references the data mapped from @file.
// The mapped contents of the file must not be modified after creating this
// bytes object, because a #GBytes should be immutable.
func (file *MappedFile) GetBytes() *Bytes {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  *C.GBytes      // return, full, converted

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_bytes(carg0)
	runtime.KeepAlive(file)

	var goret *Bytes

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContents wraps g_mapped_file_get_contents
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Returns the contents of a #GMappedFile.
// 
// Note that the contents may not be zero-terminated,
// even if the #GMappedFile is backed by a text file.
// 
// If the file is empty then %NULL is returned.
func (file *MappedFile) GetContents() string {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  *C.gchar       // return, none, string, nullable-string

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_contents(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetLength wraps g_mapped_file_get_length
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the length of the contents of a #GMappedFile.
func (file *MappedFile) GetLength() uint {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  C.gsize        // return, none, casted

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_length(carg0)
	runtime.KeepAlive(file)

	var goret uint

	goret = uint(cret)

	return goret
}

// MarkupParseContext wraps GMarkupParseContext
//
// A parse context is used to parse a stream of bytes that
// you expect to contain marked-up text.
// 
// See g_markup_parse_context_new(), #GMarkupParser, and so
// on for more details.
type MarkupParseContext struct {
	*markupParseContext
}

// markupParseContext is the struct that's finalized
type markupParseContext struct {
	native *C.GMarkupParseContext
}

// UnsafeMarkupParseContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MarkupParseContext) instance() *C.GMarkupParseContext {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMarkupParseContextFromGlibBorrow is used to convert raw C.GMarkupParseContext pointers to go. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibBorrow(p unsafe.Pointer) *MarkupParseContext {
	if p == nil {
		return nil
	}
	return &MarkupParseContext{&markupParseContext{(*C.GMarkupParseContext)(p)}}
}

// UnsafeMarkupParseContextFromGlibNone is used to convert raw C.GMarkupParseContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibNone(p unsafe.Pointer) *MarkupParseContext {
	C.g_markup_parse_context_ref((*C.GMarkupParseContext)(p))
	wrapped := UnsafeMarkupParseContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.markupParseContext,
		func (intern *markupParseContext) {
			C.g_markup_parse_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMarkupParseContextFromGlibFull is used to convert raw C.GMarkupParseContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibFull(p unsafe.Pointer) *MarkupParseContext {
	wrapped := UnsafeMarkupParseContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.markupParseContext,
		func (intern *markupParseContext) {
			C.g_markup_parse_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMarkupParseContextRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MarkupParseContext.UnsafeMarkupParseContextUnref], then [MarkupParseContext] will leak memory.
func UnsafeMarkupParseContextRef(m *MarkupParseContext) {
	C.g_markup_parse_context_ref(m.native)
}

// UnsafeMarkupParseContextUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MarkupParseContext] is expected to work anymore.
func UnsafeMarkupParseContextUnref(m *MarkupParseContext) {
	C.g_markup_parse_context_unref(m.native)
}

// UnsafeMarkupParseContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMarkupParseContextToGlibNone(m *MarkupParseContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMarkupParseContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMarkupParseContextToGlibFull(m *MarkupParseContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.markupParseContext, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MarkupParseContext is invalid from here on
	return _p
}

// EndParse wraps g_markup_parse_context_end_parse
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Signals to the #GMarkupParseContext that all data has been
// fed into the parse context with g_markup_parse_context_parse().
// 
// This function reports an error if the document isn't complete,
// for example if elements are still open.
func (_context *MarkupParseContext) EndParse() (bool, error) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_end_parse(carg0, &_cerr)
	runtime.KeepAlive(_context)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetElement wraps g_markup_parse_context_get_element
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Retrieves the name of the currently open element.
// 
// If called from the start_element or end_element handlers this will
// give the element_name as passed to those functions. For the parent
// elements, see g_markup_parse_context_get_element_stack().
func (_context *MarkupParseContext) GetElement() string {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  *C.gchar               // return, none, string

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_get_element(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetElementStack wraps g_markup_parse_context_get_element_stack
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Retrieves the element stack from the internal state of the parser.
// 
// The returned #GSList is a list of strings where the first item is
// the currently open tag (as would be returned by
// g_markup_parse_context_get_element()) and the next item is its
// immediate parent.
// 
// This function is intended to be used in the start_element and
// end_element handlers where g_markup_parse_context_get_element()
// would merely return the name of the element that is being
// processed.
func (_context *MarkupParseContext) GetElementStack() []string {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  *C.GSList              // container, transfer: none

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_get_element_stack(carg0)
	runtime.KeepAlive(_context)

	var goret []string

	goret = UnsafeSListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) string {
			var dst string // string
			dst = C.GoString((*C.char)(v))
			return dst
		},
	)

	return goret
}

// GetPosition wraps g_markup_parse_context_get_position
// 
// The function returns the following values:
// 
// 	- lineNumber int32: return location for a line number, or %NULL 
// 	- charNumber int32: return location for a char-on-line number, or %NULL 
//
// Retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict
// semantics for what constitutes the "current" line number other than
// "the best number we could come up with for error messages."
func (_context *MarkupParseContext) GetPosition() (int32, int32) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var carg1 C.gint                 // out, full, casted
	var carg2 C.gint                 // out, full, casted

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	C.g_markup_parse_context_get_position(carg0, &carg1, &carg2)
	runtime.KeepAlive(_context)

	var lineNumber int32
	var charNumber int32

	lineNumber = int32(carg1)
	charNumber = int32(carg2)

	return lineNumber, charNumber
}

// Parse wraps g_markup_parse_context_parse
// 
// The function takes the following parameters:
// 
// 	- text string: chunk of text to parse 
// 	- textLen int: length of @text in bytes 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Feed some data to the #GMarkupParseContext.
// 
// The data need not be valid UTF-8; an error will be signaled if
// it's invalid. The data need not be an entire document; you can
// feed a document into the parser incrementally, via multiple calls
// to this function. Typically, as you receive data from a network
// connection or file, you feed each received chunk of data into this
// function, aborting the process if an error occurs. Once an error
// is reported, no further data may be fed to the #GMarkupParseContext;
// all errors are fatal.
func (_context *MarkupParseContext) Parse(text string, textLen int) (bool, error) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var carg1 *C.gchar               // in, none, string
	var carg2 C.gssize               // in, none, casted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(textLen)

	cret = C.g_markup_parse_context_parse(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(textLen)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MarkupParser wraps GMarkupParser
//
// Any of the fields in #GMarkupParser can be %NULL, in which case they
// will be ignored. Except for the @error function, any of these callbacks
// can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
// %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
// errors are intended to be set from these callbacks. If you set an error
// from a callback, g_markup_parse_context_parse() will report that error
// back to its caller.
// 
// Refer to the [GMarkup](../glib/markup.html) documentation to understand
// the scope and limitations of `GMarkupParser`. In particular, it is not a
// full XML parser and it must not be used to process untrusted data.
type MarkupParser struct {
	*markupParser
}

// markupParser is the struct that's finalized
type markupParser struct {
	native *C.GMarkupParser
}

// UnsafeMarkupParserToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MarkupParser) instance() *C.GMarkupParser {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMarkupParserFromGlibBorrow is used to convert raw C.GMarkupParser pointers to go. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibBorrow(p unsafe.Pointer) *MarkupParser {
	if p == nil {
		return nil
	}
	return &MarkupParser{&markupParser{(*C.GMarkupParser)(p)}}
}

// UnsafeMarkupParserFromGlibNone is used to convert raw C.GMarkupParser pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibNone(p unsafe.Pointer) *MarkupParser {
	wrapped := UnsafeMarkupParserFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MarkupParser because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMarkupParserFromGlibFull is used to convert raw C.GMarkupParser pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibFull(p unsafe.Pointer) *MarkupParser {
	wrapped := UnsafeMarkupParserFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.markupParser,
		func (intern *markupParser) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMarkupParserFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MarkupParser] is expected to work anymore.
func UnsafeMarkupParserFree(m *MarkupParser) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMarkupParserToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMarkupParserToGlibNone(m *MarkupParser) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMarkupParserToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMarkupParserToGlibFull(m *MarkupParser) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.markupParser, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MarkupParser is invalid from here on
	return _p
}

// MatchInfo wraps GMatchInfo
//
// A GMatchInfo is an opaque struct used to return information about
// matches.
type MatchInfo struct {
	*matchInfo
}

// matchInfo is the struct that's finalized
type matchInfo struct {
	native *C.GMatchInfo
}

// UnsafeMatchInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MatchInfo) instance() *C.GMatchInfo {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMatchInfoFromGlibBorrow is used to convert raw C.GMatchInfo pointers to go. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibBorrow(p unsafe.Pointer) *MatchInfo {
	if p == nil {
		return nil
	}
	return &MatchInfo{&matchInfo{(*C.GMatchInfo)(p)}}
}

// UnsafeMatchInfoFromGlibNone is used to convert raw C.GMatchInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibNone(p unsafe.Pointer) *MatchInfo {
	C.g_match_info_ref((*C.GMatchInfo)(p))
	wrapped := UnsafeMatchInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.matchInfo,
		func (intern *matchInfo) {
			C.g_match_info_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMatchInfoFromGlibFull is used to convert raw C.GMatchInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibFull(p unsafe.Pointer) *MatchInfo {
	wrapped := UnsafeMatchInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.matchInfo,
		func (intern *matchInfo) {
			C.g_match_info_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMatchInfoRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MatchInfo.UnsafeMatchInfoUnref], then [MatchInfo] will leak memory.
func UnsafeMatchInfoRef(m *MatchInfo) {
	C.g_match_info_ref(m.native)
}

// UnsafeMatchInfoUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MatchInfo] is expected to work anymore.
func UnsafeMatchInfoUnref(m *MatchInfo) {
	C.g_match_info_unref(m.native)
}

// UnsafeMatchInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMatchInfoToGlibNone(m *MatchInfo) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMatchInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMatchInfoToGlibFull(m *MatchInfo) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.matchInfo, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MatchInfo is invalid from here on
	return _p
}

// ExpandReferences wraps g_match_info_expand_references
// 
// The function takes the following parameters:
// 
// 	- stringToExpand string: the string to expand 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
// 	- _goerr error (nullable): an error 
//
// Returns a new string containing the text in @string_to_expand with
// references and escape sequences expanded. References refer to the last
// match done with @string against @regex and have the same syntax used by
// g_regex_replace().
// 
// The @string_to_expand must be UTF-8 encoded even if %G_REGEX_RAW was
// passed to g_regex_new().
// 
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
// 
// @match_info may be %NULL in which case @string_to_expand must not
// contain references. For instance "foo\n" does not refer to an actual
// pattern and '\n' merely will be replaced with \n character,
// while to expand "\0" (whole match) one needs the result of a match.
// Use g_regex_check_replacement() to find out whether @string_to_expand
// contains references.
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.gchar      // return, full, string, nullable-string
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stringToExpand)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_expand_references(carg0, carg1, &_cerr)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(stringToExpand)

	var goret  string
	var _goerr error

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Fetch wraps g_match_info_fetch
// 
// The function takes the following parameters:
// 
// 	- matchNum int32: number of the sub expression 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Retrieves the text matching the @match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren
// set, 2 the second, and so on.
// 
// If @match_num is a valid sub pattern but it didn't match anything
// (e.g. sub pattern 1, matching "b" against "(a)?b") then an empty
// string is returned.
// 
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved
// string is not that of a set of parentheses but that of a matched
// substring. Substrings are matched in reverse order of length, so
// 0 is the longest match.
// 
// The string is fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (matchInfo *MatchInfo) Fetch(matchNum int32) string {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 C.gint        // in, none, casted
	var cret  *C.gchar      // return, full, string, nullable-string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = C.gint(matchNum)

	cret = C.g_match_info_fetch(carg0, carg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FetchAll wraps g_match_info_fetch_all
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in
// the returned array is the match number 0, i.e. the entire matched
// text.
// 
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching
// "b" against "(a)?b") then an empty string is inserted.
// 
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved
// strings are not that matched by sets of parentheses but that of the
// matched substring. Substrings are matched in reverse order of length,
// so the first one is the longest match.
// 
// The strings are fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchAll() []string {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  **C.gchar     // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_fetch_all(carg0)
	runtime.KeepAlive(matchInfo)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// FetchNamed wraps g_match_info_fetch_named
// 
// The function takes the following parameters:
// 
// 	- name string: name of the subexpression 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Retrieves the text matching the capturing parentheses named @name.
// 
// If @name is a valid sub pattern name but it didn't match anything
// (e.g. sub pattern `"X"`, matching `"b"` against `"(?P&lt;X&gt;a)?b"`)
// then an empty string is returned.
// 
// The string is fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.gchar      // return, full, string, nullable-string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_fetch_named(carg0, carg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FetchNamedPos wraps g_match_info_fetch_named_pos
// 
// The function takes the following parameters:
// 
// 	- name string: name of the subexpression 
// 
// The function returns the following values:
// 
// 	- startPos int32: pointer to location where to store
//     the start position, or %NULL 
// 	- endPos int32: pointer to location where to store
//     the end position (the byte after the final byte of the match), or %NULL 
// 	- goret bool 
//
// Retrieves the position in bytes of the capturing parentheses named @name.
// 
// If @name is a valid sub pattern name but it didn't match anything
// (e.g. sub pattern `"X"`, matching `"b"` against `"(?P&lt;X&gt;a)?b"`)
// then @start_pos and @end_pos are set to -1 and %TRUE is returned.
// 
// As @end_pos is set to the byte after the final byte of the match (on success),
// the length of the match can be calculated as `end_pos - start_pos`.
func (matchInfo *MatchInfo) FetchNamedPos(name string) (int32, int32, bool) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var carg2 C.gint        // out, full, casted
	var carg3 C.gint        // out, full, casted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_fetch_named_pos(carg0, carg1, &carg2, &carg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var startPos int32
	var endPos   int32
	var goret    bool

	startPos = int32(carg2)
	endPos = int32(carg3)
	if cret != 0 {
		goret = true
	}

	return startPos, endPos, goret
}

// FetchPos wraps g_match_info_fetch_pos
// 
// The function takes the following parameters:
// 
// 	- matchNum int32: number of the capture parenthesis 
// 
// The function returns the following values:
// 
// 	- startPos int32: pointer to location where to store
//     the start position, or %NULL 
// 	- endPos int32: pointer to location where to store
//     the end position (the byte after the final byte of the match), or %NULL 
// 	- goret bool 
//
// Returns the start and end positions (in bytes) of a successfully matching
// capture parenthesis.
// 
// Valid values for @match_num are `0` for the full text of the match,
// `1` for the first paren set, `2` for the second, and so on.
// 
// As @end_pos is set to the byte after the final byte of the match (on success),
// the length of the match can be calculated as `end_pos - start_pos`.
// 
// As a best practice, initialize @start_pos and @end_pos to identifiable
// values, such as `G_MAXINT`, so that you can test if
// `g_match_info_fetch_pos()` actually changed the value for a given
// capture parenthesis.
// 
// The parameter @match_num corresponds to a matched capture parenthesis. The
// actual value you use for @match_num depends on the method used to generate
// @match_info. The following sections describe those methods.
// 
// ## Methods Using Non-deterministic Finite Automata Matching
// 
// The methods [method@GLib.Regex.match] and [method@GLib.Regex.match_full]
// return a [struct@GLib.MatchInfo] using traditional (greedy) pattern
// matching, also known as
// [Non-deterministic Finite Automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton)
// (NFA) matching. You pass the returned `GMatchInfo` from these methods to
// `g_match_info_fetch_pos()` to determine the start and end positions
// of capture parentheses. The values for @match_num correspond to the capture
// parentheses in order, with `0` corresponding to the entire matched string.
// 
// @match_num can refer to a capture parenthesis with no match. For example,
// the string `b` matches against the pattern `(a)?b`, but the capture
// parenthesis `(a)` has no match. In this case, `g_match_info_fetch_pos()`
// returns true and sets @start_pos and @end_pos to `-1` when called with
// `match_num` as `1` (for `(a)`).
// 
// For an expanded example, a regex pattern is `(a)?(.*?)the (.*)`,
// and a candidate string is `glib regexes are the best`. In this scenario
// there are four capture parentheses numbered 0&#x2013;3: an implicit one
// for the entire string, and three explicitly declared in the regex pattern.
// 
// Given this example, the following table describes the return values
// from `g_match_info_fetch_pos()` for various values of @match_num.
// 
// `match_num` | Contents | Return value | Returned `start_pos` | Returned `end_pos`
// ----------- | -------- | ------------ | -------------------- | ------------------
// 0 | Matches entire string | True | 0 | 25
// 1 | Does not match first character | True | -1 | -1
// 2 | All text before `the ` | True | 0 | 17
// 3 | All text after `the ` | True | 21 | 25
// 4 | Capture paren out of range | False | Unchanged | Unchanged
// 
// The following code sample and output implements this example.
// 
// ``` { .c }
// #include &lt;glib.h&gt;
// 
// int
// main (int argc, char *argv[])
// {
//   g_autoptr(GError) local_error = NULL;
//   const char *regex_pattern = "(a)?(.*?)the (.*)";
//   const char *test_string = "glib regexes are the best";
//   g_autoptr(GRegex) regex = NULL;
// 
//   regex = g_regex_new (regex_pattern,
//                        G_REGEX_DEFAULT,
//                        G_REGEX_MATCH_DEFAULT,
//                        &amp;local_error);
//   if (regex == NULL)
//     {
//       g_printerr ("Error creating regex: %s\n", local_error-&gt;message);
//       return 1;
//     }
// 
//   g_autoptr(GMatchInfo) match_info = NULL;
//   g_regex_match (regex, test_string, G_REGEX_MATCH_DEFAULT, &amp;match_info);
// 
//   int n_matched_strings = g_match_info_get_match_count (match_info);
// 
//   // Print header line
//   g_print ("match_num Contents                  Return value returned start_pos returned end_pos\n");
// 
//   // Iterate over each capture paren, including one that is out of range as a demonstration.
//   for (int match_num = 0; match_num &lt;= n_matched_strings; match_num++)
//     {
//       gboolean found_match;
//       g_autofree char *paren_string = NULL;
//       int start_pos = G_MAXINT;
//       int end_pos = G_MAXINT;
// 
//       found_match = g_match_info_fetch_pos (match_info,
//                                             match_num,
//                                             &amp;start_pos,
//                                             &amp;end_pos);
// 
//       // If no match, display N/A as the found string.
//       if (start_pos == G_MAXINT || start_pos == -1)
//         paren_string = g_strdup ("N/A");
//       else
//         paren_string = g_strndup (test_string + start_pos, end_pos - start_pos);
// 
//       g_print ("%-9d %-25s %-12d %-18d %d\n", match_num, paren_string, found_match, start_pos, end_pos);
//     }
// 
//   return 0;
// }
// ```
// 
// ```
// match_num Contents                  Return value returned start_pos returned end_pos
// 0         glib regexes are the best 1            0                  25
// 1         N/A                       1            -1                 -1
// 2         glib regexes are          1            0                  17
// 3         best                      1            21                 25
// 4         N/A                       0            2147483647         2147483647
// ```
// ## Methods Using Deterministic Finite Automata Matching
// 
// The methods [method@GLib.Regex.match_all] and
// [method@GLib.Regex.match_all_full]
// return a `GMatchInfo` using
// [Deterministic Finite Automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton)
// (DFA) pattern matching. This algorithm detects overlapping matches. You pass
// the returned `GMatchInfo` from these methods to `g_match_info_fetch_pos()`
// to determine the start and end positions of each overlapping match. Use the
// method [method@GLib.MatchInfo.get_match_count] to determine the number
// of overlapping matches.
// 
// For example, a regex pattern is `&lt;.*&gt;`, and a candidate string is
// `&lt;a&gt; &lt;b&gt; &lt;c&gt;`. In this scenario there are three implicit capture
// parentheses: one for the entire string, one for `&lt;a&gt; &lt;b&gt;`, and one for `&lt;a&gt;`.
// 
// Given this example, the following table describes the return values from
// `g_match_info_fetch_pos()` for various values of @match_num.
// 
// `match_num` | Contents | Return value | Returned `start_pos` | Returned `end_pos`
// ----------- | -------- | ------------ | -------------------- | ------------------
// 0 | Matches entire string | True | 0 | 11
// 1 | Matches `&lt;a&gt; &lt;b&gt;` | True | 0 | 7
// 2 | Matches `&lt;a&gt;` | True | 0 | 3
// 3 | Capture paren out of range | False | Unchanged | Unchanged
// 
// The following code sample and output implements this example.
// 
// ``` { .c }
// #include &lt;glib.h&gt;
// 
// int
// main (int argc, char *argv[])
// {
//   g_autoptr(GError) local_error = NULL;
//   const char *regex_pattern = "&lt;.*&gt;";
//   const char *test_string = "&lt;a&gt; &lt;b&gt; &lt;c&gt;";
//   g_autoptr(GRegex) regex = NULL;
// 
//   regex = g_regex_new (regex_pattern,
//                        G_REGEX_DEFAULT,
//                        G_REGEX_MATCH_DEFAULT,
//                        &amp;local_error);
//   if (regex == NULL)
//     {
//       g_printerr ("Error creating regex: %s\n", local_error-&gt;message);
//       return -1;
//     }
// 
//   g_autoptr(GMatchInfo) match_info = NULL;
//   g_regex_match_all (regex, test_string, G_REGEX_MATCH_DEFAULT, &amp;match_info);
// 
//   int n_matched_strings = g_match_info_get_match_count (match_info);
// 
//   // Print header line
//   g_print ("match_num Contents                  Return value returned start_pos returned end_pos\n");
// 
//   // Iterate over each capture paren, including one that is out of range as a demonstration.
//   for (int match_num = 0; match_num &lt;= n_matched_strings; match_num++)
//     {
//       gboolean found_match;
//       g_autofree char *paren_string = NULL;
//       int start_pos = G_MAXINT;
//       int end_pos = G_MAXINT;
// 
//       found_match = g_match_info_fetch_pos (match_info, match_num, &amp;start_pos, &amp;end_pos);
// 
//       // If no match, display N/A as the found string.
//       if (start_pos == G_MAXINT || start_pos == -1)
//         paren_string = g_strdup ("N/A");
//       else
//         paren_string = g_strndup (test_string + start_pos, end_pos - start_pos);
// 
//       g_print ("%-9d %-25s %-12d %-18d %d\n", match_num, paren_string, found_match, start_pos, end_pos);
//     }
// 
//   return 0;
// }
// ```
// 
// ```
// match_num Contents                  Return value returned start_pos returned end_pos
// 0         &lt;a&gt; &lt;b&gt; &lt;c&gt;               1            0                  11
// 1         &lt;a&gt; &lt;b&gt;                   1            0                  7
// 2         &lt;a&gt;                       1            0                  3
// 3         N/A                       0            2147483647         2147483647
// ```
func (matchInfo *MatchInfo) FetchPos(matchNum int32) (int32, int32, bool) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 C.gint        // out, full, casted
	var carg3 C.gint        // out, full, casted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = C.gint(matchNum)

	cret = C.g_match_info_fetch_pos(carg0, carg1, &carg2, &carg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var startPos int32
	var endPos   int32
	var goret    bool

	startPos = int32(carg2)
	endPos = int32(carg3)
	if cret != 0 {
		goret = true
	}

	return startPos, endPos, goret
}

// GetMatchCount wraps g_match_info_get_match_count
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern
// has no substrings in it and 0 is returned if the match failed.
// 
// If the last match was obtained using the DFA algorithm, that is
// using g_regex_match_all() or g_regex_match_all_full(), the retrieved
// count is not that of the number of capturing parentheses but that of
// the number of matched substrings.
func (matchInfo *MatchInfo) GetMatchCount() int32 {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gint        // return, none, casted

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_match_count(carg0)
	runtime.KeepAlive(matchInfo)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetRegex wraps g_match_info_get_regex
// 
// The function returns the following values:
// 
// 	- goret *Regex 
//
// Returns #GRegex object used in @match_info. It belongs to Glib
// and must not be freed. Use g_regex_ref() if you need to keep it
// after you free @match_info object.
func (matchInfo *MatchInfo) GetRegex() *Regex {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  *C.GRegex     // return, none, converted

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_regex(carg0)
	runtime.KeepAlive(matchInfo)

	var goret *Regex

	goret = UnsafeRegexFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_match_info_get_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns the string searched with @match_info. This is the
// string passed to g_regex_match() or g_regex_replace() so
// you may not free it before calling this function.
func (matchInfo *MatchInfo) GetString() string {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_string(carg0)
	runtime.KeepAlive(matchInfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// IsPartialMatch wraps g_match_info_is_partial_match
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Usually if the string passed to g_regex_match*() matches as far as
// it goes, but is too short to match the entire pattern, %FALSE is
// returned. There are circumstances where it might be helpful to
// distinguish this case from other cases in which there is no match.
// 
// Consider, for example, an application where a human is required to
// type in data for a field with specific formatting requirements. An
// example might be a date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$".
// If the application sees the user&#x2019;s keystrokes one by one, and can
// check that what has been typed so far is potentially valid, it is
// able to raise an error as soon as a mistake is made.
// 
// GRegex supports the concept of partial matching by means of the
// %G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD flags.
// When they are used, the return code for
// g_regex_match() or g_regex_match_full() is, as usual, %TRUE
// for a complete match, %FALSE otherwise. But, when these functions
// return %FALSE, you can check if the match was partial calling
// g_match_info_is_partial_match().
// 
// The difference between %G_REGEX_MATCH_PARTIAL_SOFT and
// %G_REGEX_MATCH_PARTIAL_HARD is that when a partial match is encountered
// with %G_REGEX_MATCH_PARTIAL_SOFT, matching continues to search for a
// possible complete match, while with %G_REGEX_MATCH_PARTIAL_HARD matching
// stops at the partial match.
// When both %G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD
// are set, the latter takes precedence.
// 
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
// 
// See pcrepartial(3) for more information on partial matching.
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_is_partial_match(carg0)
	runtime.KeepAlive(matchInfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Matches wraps g_match_info_matches
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether the previous match operation succeeded.
func (matchInfo *MatchInfo) Matches() bool {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_matches(carg0)
	runtime.KeepAlive(matchInfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Next wraps g_match_info_next
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Scans for the next match using the same parameters of the previous
// call to g_regex_match_full() or g_regex_match() that returned
// @match_info.
// 
// The match is done on the string passed to the match function, so you
// cannot free it before calling this function.
func (matchInfo *MatchInfo) Next() (bool, error) {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_next(carg0, &_cerr)
	runtime.KeepAlive(matchInfo)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MemVTable wraps GMemVTable
//
// A set of functions used to perform memory allocation. The same #GMemVTable must
// be used for all allocations in the same program; a call to g_mem_set_vtable(),
// if it exists, should be prior to any use of GLib.
// 
// This functions related to this has been deprecated in 2.46, and no longer work.
type MemVTable struct {
	*memVTable
}

// memVTable is the struct that's finalized
type memVTable struct {
	native *C.GMemVTable
}

// UnsafeMemVTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemVTable) instance() *C.GMemVTable {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemVTableFromGlibBorrow is used to convert raw C.GMemVTable pointers to go. This is used by the bindings internally.
func UnsafeMemVTableFromGlibBorrow(p unsafe.Pointer) *MemVTable {
	if p == nil {
		return nil
	}
	return &MemVTable{&memVTable{(*C.GMemVTable)(p)}}
}

// UnsafeMemVTableFromGlibNone is used to convert raw C.GMemVTable pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMemVTableFromGlibNone(p unsafe.Pointer) *MemVTable {
	wrapped := UnsafeMemVTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MemVTable because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMemVTableFromGlibFull is used to convert raw C.GMemVTable pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMemVTableFromGlibFull(p unsafe.Pointer) *MemVTable {
	wrapped := UnsafeMemVTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.memVTable,
		func (intern *memVTable) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMemVTableFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemVTable] is expected to work anymore.
func UnsafeMemVTableFree(m *MemVTable) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemVTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemVTableToGlibNone(m *MemVTable) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMemVTableToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMemVTableToGlibFull(m *MemVTable) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.memVTable, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MemVTable is invalid from here on
	return _p
}

// Node wraps GNode
//
// The #GNode struct represents one node in a [n-ary tree](data-structures.html#n-ary-trees).
type Node struct {
	*node
}

// node is the struct that's finalized
type node struct {
	native *C.GNode
}

// UnsafeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *Node) instance() *C.GNode {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNodeFromGlibBorrow is used to convert raw C.GNode pointers to go. This is used by the bindings internally.
func UnsafeNodeFromGlibBorrow(p unsafe.Pointer) *Node {
	if p == nil {
		return nil
	}
	return &Node{&node{(*C.GNode)(p)}}
}

// UnsafeNodeFromGlibNone is used to convert raw C.GNode pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeNodeFromGlibNone(p unsafe.Pointer) *Node {
	wrapped := UnsafeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Node because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeNodeFromGlibFull is used to convert raw C.GNode pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeNodeFromGlibFull(p unsafe.Pointer) *Node {
	wrapped := UnsafeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.node,
		func (intern *node) {
			C.g_node_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeNodeDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Node] is expected to work anymore.
func UnsafeNodeDestroy(n *Node) {
	C.g_node_destroy(n.native)
}

// UnsafeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNodeToGlibNone(n *Node) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// UnsafeNodeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeNodeToGlibFull(n *Node) unsafe.Pointer {
	if n == nil {
		return nil
	}
	runtime.SetFinalizer(n.node, nil)
	_p := unsafe.Pointer(n.native)
	n.native = nil // Node is invalid from here on
	return _p
}

// ChildPosition wraps g_node_child_position
// 
// The function takes the following parameters:
// 
// 	- child *Node: a child of @node 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the position of a #GNode with respect to its siblings.
// @child must be a child of @node. The first child is numbered 0,
// the second 1, and so on.
func (node *Node) ChildPosition(child *Node) int32 {
	var carg0 *C.GNode // in, none, converted
	var carg1 *C.GNode // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))
	carg1 = (*C.GNode)(UnsafeNodeToGlibNone(child))

	cret = C.g_node_child_position(carg0, carg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(child)

	var goret int32

	goret = int32(cret)

	return goret
}

// Depth wraps g_node_depth
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the depth of a #GNode.
// 
// If @node is %NULL the depth is 0. The root node has a depth of 1.
// For the children of the root node the depth is 2. And so on.
func (node *Node) Depth() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	cret = C.g_node_depth(carg0)
	runtime.KeepAlive(node)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsAncestor wraps g_node_is_ancestor
// 
// The function takes the following parameters:
// 
// 	- descendant *Node: a #GNode 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns %TRUE if @node is an ancestor of @descendant.
// This is true if node is the parent of @descendant,
// or if node is the grandparent of @descendant etc.
func (node *Node) IsAncestor(descendant *Node) bool {
	var carg0 *C.GNode   // in, none, converted
	var carg1 *C.GNode   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))
	carg1 = (*C.GNode)(UnsafeNodeToGlibNone(descendant))

	cret = C.g_node_is_ancestor(carg0, carg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(descendant)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MaxHeight wraps g_node_max_height
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the maximum height of all branches beneath a #GNode.
// This is the maximum distance from the #GNode to all leaf nodes.
// 
// If @root is %NULL, 0 is returned. If @root has no children,
// 1 is returned. If @root has children, 2 is returned. And so on.
func (root *Node) MaxHeight() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(root))

	cret = C.g_node_max_height(carg0)
	runtime.KeepAlive(root)

	var goret uint

	goret = uint(cret)

	return goret
}

// NChildren wraps g_node_n_children
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the number of children of a #GNode.
func (node *Node) NChildren() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	cret = C.g_node_n_children(carg0)
	runtime.KeepAlive(node)

	var goret uint

	goret = uint(cret)

	return goret
}

// NNodes wraps g_node_n_nodes
// 
// The function takes the following parameters:
// 
// 	- flags TraverseFlags: which types of children are to be counted, one of
//     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Gets the number of nodes in a tree.
func (root *Node) NNodes(flags TraverseFlags) uint {
	var carg0 *C.GNode         // in, none, converted
	var carg1 C.GTraverseFlags // in, none, casted
	var cret  C.guint          // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(root))
	carg1 = C.GTraverseFlags(flags)

	cret = C.g_node_n_nodes(carg0, carg1)
	runtime.KeepAlive(root)
	runtime.KeepAlive(flags)

	var goret uint

	goret = uint(cret)

	return goret
}

// ReverseChildren wraps g_node_reverse_children
//
// Reverses the order of the children of a #GNode.
// (It doesn't change the order of the grandchildren.)
func (node *Node) ReverseChildren() {
	var carg0 *C.GNode // in, none, converted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	C.g_node_reverse_children(carg0)
	runtime.KeepAlive(node)
}

// Unlink wraps g_node_unlink
//
// Unlinks a #GNode from a tree, resulting in two separate trees.
func (node *Node) Unlink() {
	var carg0 *C.GNode // in, none, converted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	C.g_node_unlink(carg0)
	runtime.KeepAlive(node)
}

// Once wraps GOnce
//
// A #GOnce struct controls a one-time initialization function. Any
// one-time initialization function must have its own unique #GOnce
// struct.
type Once struct {
	*once
}

// once is the struct that's finalized
type once struct {
	native *C.GOnce
}

// UnsafeOnceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *Once) instance() *C.GOnce {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOnceFromGlibBorrow is used to convert raw C.GOnce pointers to go. This is used by the bindings internally.
func UnsafeOnceFromGlibBorrow(p unsafe.Pointer) *Once {
	if p == nil {
		return nil
	}
	return &Once{&once{(*C.GOnce)(p)}}
}

// UnsafeOnceFromGlibNone is used to convert raw C.GOnce pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOnceFromGlibNone(p unsafe.Pointer) *Once {
	wrapped := UnsafeOnceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Once because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOnceFromGlibFull is used to convert raw C.GOnce pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOnceFromGlibFull(p unsafe.Pointer) *Once {
	wrapped := UnsafeOnceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.once,
		func (intern *once) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOnceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Once] is expected to work anymore.
func UnsafeOnceFree(o *Once) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOnceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOnceToGlibNone(o *Once) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOnceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOnceToGlibFull(o *Once) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.once, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // Once is invalid from here on
	return _p
}

// OnceInitEnterImpl wraps g_once_init_enter_impl
// 
// The function takes the following parameters:
// 
// 	- location *uint 
// 
// The function returns the following values:
// 
// 	- goret bool 
func OnceInitEnterImpl(location *uint) bool {
	var carg1 *C.gsize   // in, transfer: none, C Pointers: 1, Name: gsize
	var cret  C.gboolean // return

	_ = location
	_ = carg1
	panic("unimplemented conversion of *uint (volatile gsize*) because of no basic converter found")

	cret = C.g_once_init_enter_impl(carg1)
	runtime.KeepAlive(location)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// OptionContext wraps GOptionContext
//
// A `GOptionContext` struct defines which options
// are accepted by the commandline option parser. The struct has only private
// fields and should not be directly accessed.
type OptionContext struct {
	*optionContext
}

// optionContext is the struct that's finalized
type optionContext struct {
	native *C.GOptionContext
}

// UnsafeOptionContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionContext) instance() *C.GOptionContext {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionContextFromGlibBorrow is used to convert raw C.GOptionContext pointers to go. This is used by the bindings internally.
func UnsafeOptionContextFromGlibBorrow(p unsafe.Pointer) *OptionContext {
	if p == nil {
		return nil
	}
	return &OptionContext{&optionContext{(*C.GOptionContext)(p)}}
}

// UnsafeOptionContextFromGlibNone is used to convert raw C.GOptionContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionContextFromGlibNone(p unsafe.Pointer) *OptionContext {
	wrapped := UnsafeOptionContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OptionContext because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOptionContextFromGlibFull is used to convert raw C.GOptionContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionContextFromGlibFull(p unsafe.Pointer) *OptionContext {
	wrapped := UnsafeOptionContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionContext,
		func (intern *optionContext) {
			C.g_option_context_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionContextFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionContext] is expected to work anymore.
func UnsafeOptionContextFree(o *OptionContext) {
	C.g_option_context_free(o.native)
}

// UnsafeOptionContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionContextToGlibNone(o *OptionContext) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionContextToGlibFull(o *OptionContext) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionContext, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionContext is invalid from here on
	return _p
}

// AddGroup wraps g_option_context_add_group
// 
// The function takes the following parameters:
// 
// 	- group *OptionGroup: the group to add 
//
// Adds a #GOptionGroup to the @context, so that parsing with @context
// will recognize the options in the group. Note that this will take
// ownership of the @group and thus the @group should not be freed.
func (_context *OptionContext) AddGroup(group *OptionGroup) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionGroup   // in, full, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibFull(group))

	C.g_option_context_add_group(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(group)
}

// AddMainEntries wraps g_option_context_add_main_entries
// 
// The function takes the following parameters:
// 
// 	- entries []OptionEntry: a %NULL-terminated array of #GOptionEntrys 
// 	- translationDomain string (nullable): a translation domain to use for translating
//    the `--help` output for the options in @entries
//    with gettext(), or %NULL 
//
// A convenience function which creates a main group if it doesn't
// exist, adds the @entries to it and sets the translation domain.
func (_context *OptionContext) AddMainEntries(entries []OptionEntry, translationDomain string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionEntry   // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)
	var carg2 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")
	if translationDomain != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(translationDomain)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_option_context_add_main_entries(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(entries)
	runtime.KeepAlive(translationDomain)
}

// GetDescription wraps g_option_context_get_description
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns the description. See g_option_context_set_description().
func (_context *OptionContext) GetDescription() string {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.gchar          // return, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_description(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetHelp wraps g_option_context_get_help
// 
// The function takes the following parameters:
// 
// 	- mainHelp bool: if %TRUE, only include the main group 
// 	- group *OptionGroup (nullable): the #GOptionGroup to create help for, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a formatted, translated help text for the given context.
// To obtain the text produced by `--help`, call
// `g_option_context_get_help (context, TRUE, NULL)`.
// To obtain the text produced by `--help-all`, call
// `g_option_context_get_help (context, FALSE, NULL)`.
// To obtain the help text for an option group, call
// `g_option_context_get_help (context, FALSE, group)`.
func (_context *OptionContext) GetHelp(mainHelp bool, group *OptionGroup) string {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in
	var carg2 *C.GOptionGroup   // in, none, converted, nullable
	var cret  *C.gchar          // return, full, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if mainHelp {
		carg1 = C.TRUE
	}
	if group != nil {
		carg2 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	}

	cret = C.g_option_context_get_help(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(mainHelp)
	runtime.KeepAlive(group)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetHelpEnabled wraps g_option_context_get_help_enabled
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether automatic `--help` generation
// is turned on for @context. See g_option_context_set_help_enabled().
func (_context *OptionContext) GetHelpEnabled() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_help_enabled(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIgnoreUnknownOptions wraps g_option_context_get_ignore_unknown_options
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether unknown options are ignored or not. See
// g_option_context_set_ignore_unknown_options().
func (_context *OptionContext) GetIgnoreUnknownOptions() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_ignore_unknown_options(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMainGroup wraps g_option_context_get_main_group
// 
// The function returns the following values:
// 
// 	- goret *OptionGroup 
//
// Returns a pointer to the main group of @context.
func (_context *OptionContext) GetMainGroup() *OptionGroup {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.GOptionGroup   // return, none, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_main_group(carg0)
	runtime.KeepAlive(_context)

	var goret *OptionGroup

	goret = UnsafeOptionGroupFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetStrictPosix wraps g_option_context_get_strict_posix
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether strict POSIX code is enabled.
// 
// See g_option_context_set_strict_posix() for more information.
func (_context *OptionContext) GetStrictPosix() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_strict_posix(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetSummary wraps g_option_context_get_summary
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns the summary. See g_option_context_set_summary().
func (_context *OptionContext) GetSummary() string {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.gchar          // return, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_summary(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetDescription wraps g_option_context_set_description
// 
// The function takes the following parameters:
// 
// 	- description string (nullable): a string to be shown in `--help` output
//   after the list of options, or %NULL 
//
// Adds a string to be displayed in `--help` output after the list
// of options. This text often includes a bug reporting address.
// 
// Note that the summary is translated (see
// g_option_context_set_translate_func()).
func (_context *OptionContext) SetDescription(description string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if description != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_option_context_set_description(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(description)
}

// SetHelpEnabled wraps g_option_context_set_help_enabled
// 
// The function takes the following parameters:
// 
// 	- helpEnabled bool: %TRUE to enable `--help`, %FALSE to disable it 
//
// Enables or disables automatic generation of `--help` output.
// By default, g_option_context_parse() recognizes `--help`, `-h`,
// `-?`, `--help-all` and `--help-groupname` and creates suitable
// output to stdout.
func (_context *OptionContext) SetHelpEnabled(helpEnabled bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if helpEnabled {
		carg1 = C.TRUE
	}

	C.g_option_context_set_help_enabled(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(helpEnabled)
}

// SetIgnoreUnknownOptions wraps g_option_context_set_ignore_unknown_options
// 
// The function takes the following parameters:
// 
// 	- ignoreUnknown bool: %TRUE to ignore unknown options, %FALSE to produce
//    an error when unknown options are met 
//
// Sets whether to ignore unknown options or not. If an argument is
// ignored, it is left in the @argv array after parsing. By default,
// g_option_context_parse() treats unknown options as error.
// 
// This setting does not affect non-option arguments (i.e. arguments
// which don't start with a dash). But note that GOption cannot reliably
// determine whether a non-option belongs to a preceding unknown option.
func (_context *OptionContext) SetIgnoreUnknownOptions(ignoreUnknown bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if ignoreUnknown {
		carg1 = C.TRUE
	}

	C.g_option_context_set_ignore_unknown_options(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(ignoreUnknown)
}

// SetMainGroup wraps g_option_context_set_main_group
// 
// The function takes the following parameters:
// 
// 	- group *OptionGroup: the group to set as main group 
//
// Sets a #GOptionGroup as main group of the @context.
// This has the same effect as calling g_option_context_add_group(),
// the only difference is that the options in the main group are
// treated differently when generating `--help` output.
func (_context *OptionContext) SetMainGroup(group *OptionGroup) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionGroup   // in, full, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibFull(group))

	C.g_option_context_set_main_group(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(group)
}

// SetStrictPosix wraps g_option_context_set_strict_posix
// 
// The function takes the following parameters:
// 
// 	- strictPosix bool: the new value 
//
// Sets strict POSIX mode.
// 
// By default, this mode is disabled.
// 
// In strict POSIX mode, the first non-argument parameter encountered
// (eg: filename) terminates argument processing.  Remaining arguments
// are treated as non-options and are not attempted to be parsed.
// 
// If strict POSIX mode is disabled then parsing is done in the GNU way
// where option arguments can be freely mixed with non-options.
// 
// As an example, consider "ls foo -l".  With GNU style parsing, this
// will list "foo" in long mode.  In strict POSIX style, this will list
// the files named "foo" and "-l".
// 
// It may be useful to force strict POSIX mode when creating "verb
// style" command line tools.  For example, the "gsettings" command line
// tool supports the global option "--schemadir" as well as many
// subcommands ("get", "set", etc.) which each have their own set of
// arguments.  Using strict POSIX mode will allow parsing the global
// options up to the verb name while leaving the remaining options to be
// parsed by the relevant subcommand (which can be determined by
// examining the verb name, which should be present in argv[1] after
// parsing).
func (_context *OptionContext) SetStrictPosix(strictPosix bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if strictPosix {
		carg1 = C.TRUE
	}

	C.g_option_context_set_strict_posix(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(strictPosix)
}

// SetSummary wraps g_option_context_set_summary
// 
// The function takes the following parameters:
// 
// 	- summary string (nullable): a string to be shown in `--help` output
//  before the list of options, or %NULL 
//
// Adds a string to be displayed in `--help` output before the list
// of options. This is typically a summary of the program functionality.
// 
// Note that the summary is translated (see
// g_option_context_set_translate_func() and
// g_option_context_set_translation_domain()).
func (_context *OptionContext) SetSummary(summary string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if summary != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_option_context_set_summary(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(summary)
}

// SetTranslationDomain wraps g_option_context_set_translation_domain
// 
// The function takes the following parameters:
// 
// 	- domain string: the domain to use 
//
// A convenience function to use gettext() for translating
// user-visible strings.
func (_context *OptionContext) SetTranslationDomain(domain string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_option_context_set_translation_domain(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(domain)
}

// OptionEntry wraps GOptionEntry
//
// - %G_OPTION_ARG_NONE: %gboolean
//     - %G_OPTION_ARG_STRING: %gchar*
//     - %G_OPTION_ARG_INT: %gint
//     - %G_OPTION_ARG_FILENAME: %gchar*
//     - %G_OPTION_ARG_STRING_ARRAY: %gchar**
//     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
//     - %G_OPTION_ARG_DOUBLE: %gdouble
// 
//     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
//     the location will contain a newly allocated string if the option
//     was given. That string needs to be freed by the callee using g_free().
//     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
//     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
// A GOptionEntry struct defines a single option. To have an effect, they
// must be added to a #GOptionGroup with g_option_context_add_main_entries()
// or g_option_group_add_entries().
type OptionEntry struct {
	*optionEntry
}

// optionEntry is the struct that's finalized
type optionEntry struct {
	native *C.GOptionEntry
}

// UnsafeOptionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionEntry) instance() *C.GOptionEntry {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionEntryFromGlibBorrow is used to convert raw C.GOptionEntry pointers to go. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibBorrow(p unsafe.Pointer) *OptionEntry {
	if p == nil {
		return nil
	}
	return &OptionEntry{&optionEntry{(*C.GOptionEntry)(p)}}
}

// UnsafeOptionEntryFromGlibNone is used to convert raw C.GOptionEntry pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibNone(p unsafe.Pointer) *OptionEntry {
	wrapped := UnsafeOptionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OptionEntry because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOptionEntryFromGlibFull is used to convert raw C.GOptionEntry pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibFull(p unsafe.Pointer) *OptionEntry {
	wrapped := UnsafeOptionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionEntry,
		func (intern *optionEntry) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOptionEntryFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionEntry] is expected to work anymore.
func UnsafeOptionEntryFree(o *OptionEntry) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOptionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionEntryToGlibNone(o *OptionEntry) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionEntryToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionEntryToGlibFull(o *OptionEntry) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionEntry, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionEntry is invalid from here on
	return _p
}

// OptionGroup wraps GOptionGroup
//
// A `GOptionGroup` struct defines the options in a single
// group. The struct has only private fields and should not be directly accessed.
// 
// All options in a group share the same translation function. Libraries which
// need to parse commandline options are expected to provide a function for
// getting a `GOptionGroup` holding their options, which
// the application can then add to its #GOptionContext.
type OptionGroup struct {
	*optionGroup
}

// optionGroup is the struct that's finalized
type optionGroup struct {
	native *C.GOptionGroup
}

// UnsafeOptionGroupToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionGroup) instance() *C.GOptionGroup {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionGroupFromGlibBorrow is used to convert raw C.GOptionGroup pointers to go. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibBorrow(p unsafe.Pointer) *OptionGroup {
	if p == nil {
		return nil
	}
	return &OptionGroup{&optionGroup{(*C.GOptionGroup)(p)}}
}

// UnsafeOptionGroupFromGlibNone is used to convert raw C.GOptionGroup pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibNone(p unsafe.Pointer) *OptionGroup {
	C.g_option_group_ref((*C.GOptionGroup)(p))
	wrapped := UnsafeOptionGroupFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.optionGroup,
		func (intern *optionGroup) {
			C.g_option_group_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionGroupFromGlibFull is used to convert raw C.GOptionGroup pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibFull(p unsafe.Pointer) *OptionGroup {
	wrapped := UnsafeOptionGroupFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionGroup,
		func (intern *optionGroup) {
			C.g_option_group_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionGroupRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [OptionGroup.UnsafeOptionGroupUnref], then [OptionGroup] will leak memory.
func UnsafeOptionGroupRef(o *OptionGroup) {
	C.g_option_group_ref(o.native)
}

// UnsafeOptionGroupUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionGroup] is expected to work anymore.
func UnsafeOptionGroupUnref(o *OptionGroup) {
	C.g_option_group_unref(o.native)
}

// UnsafeOptionGroupToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionGroupToGlibNone(o *OptionGroup) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionGroupToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionGroupToGlibFull(o *OptionGroup) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionGroup, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionGroup is invalid from here on
	return _p
}

// AddEntries wraps g_option_group_add_entries
// 
// The function takes the following parameters:
// 
// 	- entries []OptionEntry: a %NULL-terminated array of #GOptionEntrys 
//
// Adds the options specified in @entries to @group.
func (group *OptionGroup) AddEntries(entries []OptionEntry) {
	var carg0 *C.GOptionGroup // in, none, converted
	var carg1 *C.GOptionEntry // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)

	carg0 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")

	C.g_option_group_add_entries(carg0, carg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(entries)
}

// SetTranslationDomain wraps g_option_group_set_translation_domain
// 
// The function takes the following parameters:
// 
// 	- domain string: the domain to use 
//
// A convenience function to use gettext() for translating
// user-visible strings.
func (group *OptionGroup) SetTranslationDomain(domain string) {
	var carg0 *C.GOptionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_option_group_set_translation_domain(carg0, carg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(domain)
}

// PathBuf wraps GPathBuf
//
// `GPathBuf` is a helper type that allows you to easily build paths from
// individual elements, using the platform specific conventions for path
// separators.
// 
// ```c
// g_auto (GPathBuf) path;
// 
// g_path_buf_init (&amp;path);
// 
// g_path_buf_push (&amp;path, "usr");
// g_path_buf_push (&amp;path, "bin");
// g_path_buf_push (&amp;path, "echo");
// 
// g_autofree char *echo = g_path_buf_to_path (&amp;path);
// g_assert_cmpstr (echo, ==, "/usr/bin/echo");
// ```
// 
// You can also load a full path and then operate on its components:
// 
// ```c
// g_auto (GPathBuf) path;
// 
// g_path_buf_init_from_path (&amp;path, "/usr/bin/echo");
// 
// g_path_buf_pop (&amp;path);
// g_path_buf_push (&amp;path, "sh");
// 
// g_autofree char *sh = g_path_buf_to_path (&amp;path);
// g_assert_cmpstr (sh, ==, "/usr/bin/sh");
// ```
type PathBuf struct {
	*pathBuf
}

// pathBuf is the struct that's finalized
type pathBuf struct {
	native *C.GPathBuf
}

// UnsafePathBufToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PathBuf) instance() *C.GPathBuf {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePathBufFromGlibBorrow is used to convert raw C.GPathBuf pointers to go. This is used by the bindings internally.
func UnsafePathBufFromGlibBorrow(p unsafe.Pointer) *PathBuf {
	if p == nil {
		return nil
	}
	return &PathBuf{&pathBuf{(*C.GPathBuf)(p)}}
}

// UnsafePathBufFromGlibNone is used to convert raw C.GPathBuf pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePathBufFromGlibNone(p unsafe.Pointer) *PathBuf {
	wrapped := UnsafePathBufFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PathBuf because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePathBufFromGlibFull is used to convert raw C.GPathBuf pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePathBufFromGlibFull(p unsafe.Pointer) *PathBuf {
	wrapped := UnsafePathBufFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pathBuf,
		func (intern *pathBuf) {
			C.g_path_buf_free(intern.native)
		},
	)
	return wrapped
}

// UnsafePathBufFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PathBuf] is expected to work anymore.
func UnsafePathBufFree(p *PathBuf) {
	C.g_path_buf_free(p.native)
}

// UnsafePathBufToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePathBufToGlibNone(p *PathBuf) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePathBufToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePathBufToGlibFull(p *PathBuf) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pathBuf, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PathBuf is invalid from here on
	return _p
}

// Clear wraps g_path_buf_clear
//
// Clears the contents of the path buffer.
// 
// This function should be use to free the resources in a stack-allocated
// `GPathBuf` initialized using g_path_buf_init() or
// g_path_buf_init_from_path().
func (buf *PathBuf) Clear() {
	var carg0 *C.GPathBuf // in, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	C.g_path_buf_clear(carg0)
	runtime.KeepAlive(buf)
}

// ClearToPath wraps g_path_buf_clear_to_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Clears the contents of the path buffer and returns the built path.
// 
// This function returns `NULL` if the `GPathBuf` is empty.
// 
// See also: g_path_buf_to_path()
func (buf *PathBuf) ClearToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_clear_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FreeToPath wraps g_path_buf_free_to_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Frees a `GPathBuf` allocated by g_path_buf_new(), and
// returns the path inside the buffer.
// 
// This function returns `NULL` if the `GPathBuf` is empty.
// 
// See also: g_path_buf_to_path()
func (buf *PathBuf) FreeToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_free_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Init wraps g_path_buf_init
// 
// The function returns the following values:
// 
// 	- goret *PathBuf 
//
// Initializes a `GPathBuf` instance.
func (buf *PathBuf) Init() *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_init(carg0)
	runtime.KeepAlive(buf)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// InitFromPath wraps g_path_buf_init_from_path
// 
// The function takes the following parameters:
// 
// 	- path string (nullable): a file system path 
// 
// The function returns the following values:
// 
// 	- goret *PathBuf 
//
// Initializes a `GPathBuf` instance with the given path.
func (buf *PathBuf) InitFromPath(path string) *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string, nullable-string
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	if path != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_path_buf_init_from_path(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Pop wraps g_path_buf_pop
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Removes the last element of the path buffer.
// 
// If there is only one element in the path buffer (for example, `/` on
// Unix-like operating systems or the drive on Windows systems), it will
// not be removed and %FALSE will be returned instead.
// 
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
// 
// g_path_buf_init_from_path (&amp;buf, "/bin/sh");
// 
// g_path_buf_pop (&amp;buf);
// g_path_buf_init_from_path (&amp;cmp, "/bin");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_pop (&amp;buf);
// g_path_buf_init_from_path (&amp;cmp, "/");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_clear (&amp;buf);
// ]|
func (buf *PathBuf) Pop() bool {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_pop(carg0)
	runtime.KeepAlive(buf)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Push wraps g_path_buf_push
// 
// The function takes the following parameters:
// 
// 	- path string: a path 
// 
// The function returns the following values:
// 
// 	- goret *PathBuf 
//
// Extends the given path buffer with @path.
// 
// If @path is absolute, it replaces the current path.
// 
// If @path contains a directory separator, the buffer is extended by
// as many elements the path provides.
// 
// On Windows, both forward slashes and backslashes are treated as
// directory separators. On other platforms, %G_DIR_SEPARATOR_S is the
// only directory separator.
// 
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
// 
// g_path_buf_init_from_path (&amp;buf, "/tmp");
// g_path_buf_push (&amp;buf, ".X11-unix/X0");
// g_path_buf_init_from_path (&amp;cmp, "/tmp/.X11-unix/X0");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_push (&amp;buf, "/etc/locale.conf");
// g_path_buf_init_from_path (&amp;cmp, "/etc/locale.conf");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_clear (&amp;buf);
// ]|
func (buf *PathBuf) Push(path string) *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_buf_push(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SetExtension wraps g_path_buf_set_extension
// 
// The function takes the following parameters:
// 
// 	- extension string (nullable): the file extension 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Adds an extension to the file name in the path buffer.
// 
// If @extension is `NULL`, the extension will be unset.
// 
// If the path buffer does not have a file name set, this function returns
// `FALSE` and leaves the path buffer unmodified.
func (buf *PathBuf) SetExtension(extension string) bool {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string, nullable-string
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	if extension != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_path_buf_set_extension(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(extension)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetFilename wraps g_path_buf_set_filename
// 
// The function takes the following parameters:
// 
// 	- fileName string: the file name in the path 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Sets the file name of the path.
// 
// If the path buffer is empty, the filename is left unset and this
// function returns `FALSE`.
// 
// If the path buffer only contains the root element (on Unix-like operating
// systems) or the drive (on Windows), this is the equivalent of pushing
// the new @file_name.
// 
// If the path buffer contains a path, this is the equivalent of
// popping the path buffer and pushing @file_name, creating a
// sibling of the original path.
// 
// |[&lt;!-- language="C" --&gt;
// GPathBuf buf, cmp;
// 
// g_path_buf_init_from_path (&amp;buf, "/");
// 
// g_path_buf_set_filename (&amp;buf, "bar");
// g_path_buf_init_from_path (&amp;cmp, "/bar");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_set_filename (&amp;buf, "baz.txt");
// g_path_buf_init_from_path (&amp;cmp, "/baz.txt");
// g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp);
// g_path_buf_clear (&amp;cmp);
// 
// g_path_buf_clear (&amp;buf);
// ]|
func (buf *PathBuf) SetFilename(fileName string) bool {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_buf_set_filename(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(fileName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ToPath wraps g_path_buf_to_path
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Retrieves the built path from the path buffer.
// 
// On Windows, the result contains backslashes as directory separators,
// even if forward slashes were used in input.
// 
// If the path buffer is empty, this function returns `NULL`.
func (buf *PathBuf) ToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// PatternSpec wraps GPatternSpec
//
// A `GPatternSpec` struct is the &#x2018;compiled&#x2019; form of a glob-style pattern.
// 
// The [func@GLib.pattern_match_simple] and [method@GLib.PatternSpec.match] functions
// match a string against a pattern containing `*` and `?` wildcards with similar
// semantics as the standard `glob()` function: `*` matches an arbitrary,
// possibly empty, string, `?` matches an arbitrary character.
// 
// Note that in contrast to [`glob()`](man:glob(3)), the `/` character can be
// matched by the wildcards, there are no `[&#x2026;]` character ranges and `*` and `?`
// can not be escaped to include them literally in a pattern.
// 
// When multiple strings must be matched against the same pattern, it is better
// to compile the pattern to a [struct@GLib.PatternSpec] using
// [ctor@GLib.PatternSpec.new] and use [method@GLib.PatternSpec.match_string]
// instead of [func@GLib.pattern_match_simple]. This avoids the overhead of repeated
// pattern compilation.
type PatternSpec struct {
	*patternSpec
}

// patternSpec is the struct that's finalized
type patternSpec struct {
	native *C.GPatternSpec
}

// UnsafePatternSpecToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PatternSpec) instance() *C.GPatternSpec {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePatternSpecFromGlibBorrow is used to convert raw C.GPatternSpec pointers to go. This is used by the bindings internally.
func UnsafePatternSpecFromGlibBorrow(p unsafe.Pointer) *PatternSpec {
	if p == nil {
		return nil
	}
	return &PatternSpec{&patternSpec{(*C.GPatternSpec)(p)}}
}

// UnsafePatternSpecFromGlibNone is used to convert raw C.GPatternSpec pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePatternSpecFromGlibNone(p unsafe.Pointer) *PatternSpec {
	wrapped := UnsafePatternSpecFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafePatternSpecFromGlibFull is used to convert raw C.GPatternSpec pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePatternSpecFromGlibFull(p unsafe.Pointer) *PatternSpec {
	wrapped := UnsafePatternSpecFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.patternSpec,
		func (intern *patternSpec) {
			C.g_pattern_spec_free(intern.native)
		},
	)
	return wrapped
}

// UnsafePatternSpecFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PatternSpec] is expected to work anymore.
func UnsafePatternSpecFree(p *PatternSpec) {
	C.g_pattern_spec_free(p.native)
}

// UnsafePatternSpecToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePatternSpecToGlibNone(p *PatternSpec) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePatternSpecToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePatternSpecToGlibFull(p *PatternSpec) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.patternSpec, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PatternSpec is invalid from here on
	return _p
}

// NewPatternSpec wraps g_pattern_spec_new
// 
// The function takes the following parameters:
// 
// 	- pattern string: a zero-terminated UTF-8 encoded string 
// 
// The function returns the following values:
// 
// 	- goret *PatternSpec 
//
// Compiles a pattern to a [type@GLib.PatternSpec].
func NewPatternSpec(pattern string) *PatternSpec {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GPatternSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pattern_spec_new(carg1)
	runtime.KeepAlive(pattern)

	var goret *PatternSpec

	goret = UnsafePatternSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_pattern_spec_copy
// 
// The function returns the following values:
// 
// 	- goret *PatternSpec 
//
// Copies @pspec in a new [type@GLib.PatternSpec].
func (pspec *PatternSpec) Copy() *PatternSpec {
	var carg0 *C.GPatternSpec // in, none, converted
	var cret  *C.GPatternSpec // return, full, converted

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))

	cret = C.g_pattern_spec_copy(carg0)
	runtime.KeepAlive(pspec)

	var goret *PatternSpec

	goret = UnsafePatternSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_pattern_spec_equal
// 
// The function takes the following parameters:
// 
// 	- pspec2 *PatternSpec: another #GPatternSpec 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Compares two compiled pattern specs and returns whether they will
// match the same set of strings.
func (pspec1 *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 *C.GPatternSpec // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec1))
	carg1 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec2))

	cret = C.g_pattern_spec_equal(carg0, carg1)
	runtime.KeepAlive(pspec1)
	runtime.KeepAlive(pspec2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Match wraps g_pattern_spec_match
// 
// The function takes the following parameters:
// 
// 	- stringLength uint: the length of @string (in bytes, i.e. `strlen()`,
//    not [func@GLib.utf8_strlen]) 
// 	- str string: the UTF-8 encoded string to match 
// 	- stringReversed string (nullable): the reverse of @string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Matches a string against a compiled pattern.
// 
// Passing the correct
// length of the string given is mandatory. The reversed string can be
// omitted by passing `NULL`, this is more efficient if the reversed
// version of the string to be matched is not at hand, as
// [method@GLib.PatternSpec.match] will only construct it if the compiled pattern
// requires reverse matches.
// 
// Note that, if the user code will (possibly) match a string against a
// multitude of patterns containing wildcards, chances are high that
// some patterns will require a reversed string. In this case, it&#x2019;s
// more efficient to provide the reversed string to avoid multiple
// constructions thereof in the various calls to [method@GLib.PatternSpec.match].
// 
// Note also that the reverse of a UTF-8 encoded string can in general
// not be obtained by [func@GLib.strreverse]. This works only if the string
// does not contain any multibyte characters. GLib offers the
// [func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.
func (pspec *PatternSpec) Match(stringLength uint, str string, stringReversed string) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.gchar        // in, none, string
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))
	carg1 = C.gsize(stringLength)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	if stringReversed != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(stringReversed)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_pattern_spec_match(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(stringLength)
	runtime.KeepAlive(str)
	runtime.KeepAlive(stringReversed)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MatchString wraps g_pattern_spec_match_string
// 
// The function takes the following parameters:
// 
// 	- str string: the UTF-8 encoded string to match 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Matches a string against a compiled pattern.
// 
// If the string is to be
// matched against more than one pattern, consider using
// [method@GLib.PatternSpec.match] instead while supplying the reversed string.
func (pspec *PatternSpec) MatchString(str string) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pattern_spec_match_string(carg0, carg1)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollFD wraps GPollFD
//
// Represents a file descriptor, which events to poll for, and which events
// occurred.
type PollFD struct {
	*pollFD
}

// pollFD is the struct that's finalized
type pollFD struct {
	native *C.GPollFD
}

// UnsafePollFDToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollFD) instance() *C.GPollFD {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollFDFromGlibBorrow is used to convert raw C.GPollFD pointers to go. This is used by the bindings internally.
func UnsafePollFDFromGlibBorrow(p unsafe.Pointer) *PollFD {
	if p == nil {
		return nil
	}
	return &PollFD{&pollFD{(*C.GPollFD)(p)}}
}

// UnsafePollFDFromGlibNone is used to convert raw C.GPollFD pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollFDFromGlibNone(p unsafe.Pointer) *PollFD {
	wrapped := UnsafePollFDFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollFD because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollFDFromGlibFull is used to convert raw C.GPollFD pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollFDFromGlibFull(p unsafe.Pointer) *PollFD {
	wrapped := UnsafePollFDFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollFD,
		func (intern *pollFD) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollFDFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollFD] is expected to work anymore.
func UnsafePollFDFree(p *PollFD) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollFDToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollFDToGlibNone(p *PollFD) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollFDToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollFDToGlibFull(p *PollFD) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollFD, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollFD is invalid from here on
	return _p
}

// RWLock wraps GRWLock
//
// The GRWLock struct is an opaque data structure to represent a
// reader-writer lock. It is similar to a #GMutex in that it allows
// multiple threads to coordinate access to a shared resource.
// 
// The difference to a mutex is that a reader-writer lock discriminates
// between read-only ('reader') and full ('writer') access. While only
// one thread at a time is allowed write access (by holding the 'writer'
// lock via g_rw_lock_writer_lock()), multiple threads can gain
// simultaneous read-only access (by holding the 'reader' lock via
// g_rw_lock_reader_lock()).
// 
// It is unspecified whether readers or writers have priority in acquiring the
// lock when a reader already holds the lock and a writer is queued to acquire
// it.
// 
// Here is an example for an array with access functions:
// |[&lt;!-- language="C" --&gt;
//   GRWLock lock;
//   GPtrArray *array;
// 
//   gpointer
//   my_array_get (guint index)
//   {
//     gpointer retval = NULL;
// 
//     if (!array)
//       return NULL;
// 
//     g_rw_lock_reader_lock (&amp;lock);
//     if (index &lt; array-&gt;len)
//       retval = g_ptr_array_index (array, index);
//     g_rw_lock_reader_unlock (&amp;lock);
// 
//     return retval;
//   }
// 
//   void
//   my_array_set (guint index, gpointer data)
//   {
//     g_rw_lock_writer_lock (&amp;lock);
// 
//     if (!array)
//       array = g_ptr_array_new ();
// 
//     if (index &gt;= array-&gt;len)
//       g_ptr_array_set_size (array, index+1);
//     g_ptr_array_index (array, index) = data;
// 
//     g_rw_lock_writer_unlock (&amp;lock);
//   }
//  ]|
// This example shows an array which can be accessed by many readers
// (the my_array_get() function) simultaneously, whereas the writers
// (the my_array_set() function) will only be allowed one at a time
// and only if no readers currently access the array. This is because
// of the potentially dangerous resizing of the array. Using these
// functions is fully multi-thread safe now.
// 
// If a #GRWLock is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call
// g_rw_lock_init() on it and g_rw_lock_clear() when done.
// 
// A GRWLock should only be accessed with the g_rw_lock_ functions.
type RWLock struct {
	*rWLock
}

// rWLock is the struct that's finalized
type rWLock struct {
	native *C.GRWLock
}

// UnsafeRWLockToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RWLock) instance() *C.GRWLock {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRWLockFromGlibBorrow is used to convert raw C.GRWLock pointers to go. This is used by the bindings internally.
func UnsafeRWLockFromGlibBorrow(p unsafe.Pointer) *RWLock {
	if p == nil {
		return nil
	}
	return &RWLock{&rWLock{(*C.GRWLock)(p)}}
}

// UnsafeRWLockFromGlibNone is used to convert raw C.GRWLock pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRWLockFromGlibNone(p unsafe.Pointer) *RWLock {
	wrapped := UnsafeRWLockFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RWLock because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRWLockFromGlibFull is used to convert raw C.GRWLock pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRWLockFromGlibFull(p unsafe.Pointer) *RWLock {
	wrapped := UnsafeRWLockFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.rWLock,
		func (intern *rWLock) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRWLockFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RWLock] is expected to work anymore.
func UnsafeRWLockFree(r *RWLock) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRWLockToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRWLockToGlibNone(r *RWLock) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRWLockToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRWLockToGlibFull(r *RWLock) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.rWLock, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RWLock is invalid from here on
	return _p
}

// Clear wraps g_rw_lock_clear
//
// Frees the resources allocated to a lock with g_rw_lock_init().
// 
// This function should not be used with a #GRWLock that has been
// statically allocated.
// 
// Calling g_rw_lock_clear() when any thread holds the lock
// leads to undefined behaviour.
func (rwLock *RWLock) Clear() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_clear(carg0)
	runtime.KeepAlive(rwLock)
}

// Init wraps g_rw_lock_init
//
// Initializes a #GRWLock so that it can be used.
// 
// This function is useful to initialize a lock that has been
// allocated on the stack, or as part of a larger structure.  It is not
// necessary to initialise a reader-writer lock that has been statically
// allocated.
// 
// |[&lt;!-- language="C" --&gt;
//   typedef struct {
//     GRWLock l;
//     ...
//   } Blob;
// 
// Blob *b;
// 
// b = g_new (Blob, 1);
// g_rw_lock_init (&amp;b-&gt;l);
// ]|
// 
// To undo the effect of g_rw_lock_init() when a lock is no longer
// needed, use g_rw_lock_clear().
// 
// Calling g_rw_lock_init() on an already initialized #GRWLock leads
// to undefined behaviour.
func (rwLock *RWLock) Init() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_init(carg0)
	runtime.KeepAlive(rwLock)
}

// ReaderLock wraps g_rw_lock_reader_lock
//
// Obtain a read lock on @rw_lock. If another thread currently holds
// the write lock on @rw_lock, the current thread will block until the
// write lock was (held and) released. If another thread does not hold
// the write lock, but is waiting for it, it is implementation defined
// whether the reader or writer will block. Read locks can be taken
// recursively.
// 
// Calling g_rw_lock_reader_lock() while the current thread already
// owns a write lock leads to undefined behaviour. Read locks however
// can be taken recursively, in which case you need to make sure to
// call g_rw_lock_reader_unlock() the same amount of times.
// 
// It is implementation-defined how many read locks are allowed to be
// held on the same lock simultaneously. If the limit is hit,
// or if a deadlock is detected, a critical warning will be emitted.
func (rwLock *RWLock) ReaderLock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_reader_lock(carg0)
	runtime.KeepAlive(rwLock)
}

// ReaderTrylock wraps g_rw_lock_reader_trylock
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tries to obtain a read lock on @rw_lock and returns %TRUE if
// the read lock was successfully obtained. Otherwise it
// returns %FALSE.
func (rwLock *RWLock) ReaderTrylock() bool {
	var carg0 *C.GRWLock // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	cret = C.g_rw_lock_reader_trylock(carg0)
	runtime.KeepAlive(rwLock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReaderUnlock wraps g_rw_lock_reader_unlock
//
// Release a read lock on @rw_lock.
// 
// Calling g_rw_lock_reader_unlock() on a lock that is not held
// by the current thread leads to undefined behaviour.
func (rwLock *RWLock) ReaderUnlock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_reader_unlock(carg0)
	runtime.KeepAlive(rwLock)
}

// WriterLock wraps g_rw_lock_writer_lock
//
// Obtain a write lock on @rw_lock. If another thread currently holds
// a read or write lock on @rw_lock, the current thread will block
// until all other threads have dropped their locks on @rw_lock.
// 
// Calling g_rw_lock_writer_lock() while the current thread already
// owns a read or write lock on @rw_lock leads to undefined behaviour.
func (rwLock *RWLock) WriterLock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_writer_lock(carg0)
	runtime.KeepAlive(rwLock)
}

// WriterTrylock wraps g_rw_lock_writer_trylock
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tries to obtain a write lock on @rw_lock. If another thread
// currently holds a read or write lock on @rw_lock, it immediately
// returns %FALSE.
// Otherwise it locks @rw_lock and returns %TRUE.
func (rwLock *RWLock) WriterTrylock() bool {
	var carg0 *C.GRWLock // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	cret = C.g_rw_lock_writer_trylock(carg0)
	runtime.KeepAlive(rwLock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// WriterUnlock wraps g_rw_lock_writer_unlock
//
// Release a write lock on @rw_lock.
// 
// Calling g_rw_lock_writer_unlock() on a lock that is not held
// by the current thread leads to undefined behaviour.
func (rwLock *RWLock) WriterUnlock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_writer_unlock(carg0)
	runtime.KeepAlive(rwLock)
}

// Rand wraps GRand
//
// The GRand struct is an opaque data structure. It should only be
// accessed through the g_rand_* functions.
type Rand struct {
	*rand
}

// rand is the struct that's finalized
type rand struct {
	native *C.GRand
}

// UnsafeRandToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *Rand) instance() *C.GRand {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRandFromGlibBorrow is used to convert raw C.GRand pointers to go. This is used by the bindings internally.
func UnsafeRandFromGlibBorrow(p unsafe.Pointer) *Rand {
	if p == nil {
		return nil
	}
	return &Rand{&rand{(*C.GRand)(p)}}
}

// UnsafeRandFromGlibNone is used to convert raw C.GRand pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRandFromGlibNone(p unsafe.Pointer) *Rand {
	wrapped := UnsafeRandFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeRandFromGlibFull is used to convert raw C.GRand pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRandFromGlibFull(p unsafe.Pointer) *Rand {
	wrapped := UnsafeRandFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.rand,
		func (intern *rand) {
			C.g_rand_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeRandFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Rand] is expected to work anymore.
func UnsafeRandFree(r *Rand) {
	C.g_rand_free(r.native)
}

// UnsafeRandToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRandToGlibNone(r *Rand) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRandToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRandToGlibFull(r *Rand) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.rand, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // Rand is invalid from here on
	return _p
}

// NewRand wraps g_rand_new
// 
// The function returns the following values:
// 
// 	- goret *Rand 
//
// Creates a new random number generator initialized with a seed taken
// either from `/dev/urandom` (if existing) or from the current time
// (as a fallback).
// 
// On Windows, the seed is taken from rand_s().
func NewRand() *Rand {
	var cret *C.GRand // return, full, converted

	cret = C.g_rand_new()

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewRandWithSeed wraps g_rand_new_with_seed
// 
// The function takes the following parameters:
// 
// 	- seed uint32: a value to initialize the random number generator 
// 
// The function returns the following values:
// 
// 	- goret *Rand 
//
// Creates a new random number generator initialized with @seed.
func NewRandWithSeed(seed uint32) *Rand {
	var carg1 C.guint32 // in, none, casted
	var cret  *C.GRand  // return, full, converted

	carg1 = C.guint32(seed)

	cret = C.g_rand_new_with_seed(carg1)
	runtime.KeepAlive(seed)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewRandWithSeedArray wraps g_rand_new_with_seed_array
// 
// The function takes the following parameters:
// 
// 	- seed *uint32: an array of seeds to initialize the random number generator 
// 	- seedLength uint: an array of seeds to initialize the random number
//     generator 
// 
// The function returns the following values:
// 
// 	- goret *Rand 
//
// Creates a new random number generator initialized with @seed.
func NewRandWithSeedArray(seed *uint32, seedLength uint) *Rand {
	var carg1 *C.guint32 // in, transfer: none, C Pointers: 1, Name: guint32
	var carg2 C.guint    // in, none, casted
	var cret  *C.GRand   // return, full, converted

	_ = seed
	_ = carg1
	panic("unimplemented conversion of *uint32 (const guint32*) because of no basic converter found")
	carg2 = C.guint(seedLength)

	cret = C.g_rand_new_with_seed_array(carg1, carg2)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_rand_copy
// 
// The function returns the following values:
// 
// 	- goret *Rand 
//
// Copies a #GRand into a new one with the same exact state as before.
// This way you can take a snapshot of the random number generator for
// replaying later.
func (rand *Rand) Copy() *Rand {
	var carg0 *C.GRand // in, none, converted
	var cret  *C.GRand // return, full, converted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_copy(carg0)
	runtime.KeepAlive(rand)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Double wraps g_rand_double
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Returns the next random #gdouble from @rand_ equally distributed over
// the range [0..1).
func (rand *Rand) Double() float64 {
	var carg0 *C.GRand  // in, none, converted
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_double(carg0)
	runtime.KeepAlive(rand)

	var goret float64

	goret = float64(cret)

	return goret
}

// DoubleRange wraps g_rand_double_range
// 
// The function takes the following parameters:
// 
// 	- begin float64: lower closed bound of the interval 
// 	- end float64: upper open bound of the interval 
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// Returns the next random #gdouble from @rand_ equally distributed over
// the range [@begin..@end).
func (rand *Rand) DoubleRange(begin float64, end float64) float64 {
	var carg0 *C.GRand  // in, none, converted
	var carg1 C.gdouble // in, none, casted
	var carg2 C.gdouble // in, none, casted
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.gdouble(begin)
	carg2 = C.gdouble(end)

	cret = C.g_rand_double_range(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret float64

	goret = float64(cret)

	return goret
}

// Int wraps g_rand_int
// 
// The function returns the following values:
// 
// 	- goret uint32 
//
// Returns the next random #guint32 from @rand_ equally distributed over
// the range [0..2^32-1].
func (rand *Rand) Int() uint32 {
	var carg0 *C.GRand  // in, none, converted
	var cret  C.guint32 // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_int(carg0)
	runtime.KeepAlive(rand)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// IntRange wraps g_rand_int_range
// 
// The function takes the following parameters:
// 
// 	- begin int32: lower closed bound of the interval 
// 	- end int32: upper open bound of the interval 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the next random #gint32 from @rand_ equally distributed over
// the range [@begin..@end-1].
func (rand *Rand) IntRange(begin int32, end int32) int32 {
	var carg0 *C.GRand // in, none, converted
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_rand_int_range(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// SetSeed wraps g_rand_set_seed
// 
// The function takes the following parameters:
// 
// 	- seed uint32: a value to reinitialize the random number generator 
//
// Sets the seed for the random number generator #GRand to @seed.
func (rand *Rand) SetSeed(seed uint32) {
	var carg0 *C.GRand  // in, none, converted
	var carg1 C.guint32 // in, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.guint32(seed)

	C.g_rand_set_seed(carg0, carg1)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(seed)
}

// SetSeedArray wraps g_rand_set_seed_array
// 
// The function takes the following parameters:
// 
// 	- seed *uint32: array to initialize with 
// 	- seedLength uint: length of array 
//
// Initializes the random number generator by an array of longs.
// Array can be of arbitrary size, though only the first 624 values
// are taken.  This function is useful if you have many low entropy
// seeds, or if you require more then 32 bits of actual entropy for
// your application.
func (rand *Rand) SetSeedArray(seed *uint32, seedLength uint) {
	var carg0 *C.GRand   // in, none, converted
	var carg1 *C.guint32 // in, transfer: none, C Pointers: 1, Name: guint32
	var carg2 C.guint    // in, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	_ = seed
	_ = carg1
	panic("unimplemented conversion of *uint32 (const guint32*) because of no basic converter found")
	carg2 = C.guint(seedLength)

	C.g_rand_set_seed_array(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)
}

// RecMutex wraps GRecMutex
//
// The GRecMutex struct is an opaque data structure to represent a
// recursive mutex. It is similar to a #GMutex with the difference
// that it is possible to lock a GRecMutex multiple times in the same
// thread without deadlock. When doing so, care has to be taken to
// unlock the recursive mutex as often as it has been locked.
// 
// If a #GRecMutex is allocated in static storage then it can be used
// without initialisation.  Otherwise, you should call
// g_rec_mutex_init() on it and g_rec_mutex_clear() when done.
// 
// A GRecMutex should only be accessed with the
// g_rec_mutex_ functions.
type RecMutex struct {
	*recMutex
}

// recMutex is the struct that's finalized
type recMutex struct {
	native *C.GRecMutex
}

// UnsafeRecMutexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RecMutex) instance() *C.GRecMutex {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRecMutexFromGlibBorrow is used to convert raw C.GRecMutex pointers to go. This is used by the bindings internally.
func UnsafeRecMutexFromGlibBorrow(p unsafe.Pointer) *RecMutex {
	if p == nil {
		return nil
	}
	return &RecMutex{&recMutex{(*C.GRecMutex)(p)}}
}

// UnsafeRecMutexFromGlibNone is used to convert raw C.GRecMutex pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRecMutexFromGlibNone(p unsafe.Pointer) *RecMutex {
	wrapped := UnsafeRecMutexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RecMutex because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRecMutexFromGlibFull is used to convert raw C.GRecMutex pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRecMutexFromGlibFull(p unsafe.Pointer) *RecMutex {
	wrapped := UnsafeRecMutexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.recMutex,
		func (intern *recMutex) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRecMutexFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RecMutex] is expected to work anymore.
func UnsafeRecMutexFree(r *RecMutex) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRecMutexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRecMutexToGlibNone(r *RecMutex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRecMutexToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRecMutexToGlibFull(r *RecMutex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.recMutex, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RecMutex is invalid from here on
	return _p
}

// Clear wraps g_rec_mutex_clear
//
// Frees the resources allocated to a recursive mutex with
// g_rec_mutex_init().
// 
// This function should not be used with a #GRecMutex that has been
// statically allocated.
// 
// Calling g_rec_mutex_clear() on a locked recursive mutex leads
// to undefined behaviour.
func (recMutex *RecMutex) Clear() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_clear(carg0)
	runtime.KeepAlive(recMutex)
}

// Init wraps g_rec_mutex_init
//
// Initializes a #GRecMutex so that it can be used.
// 
// This function is useful to initialize a recursive mutex
// that has been allocated on the stack, or as part of a larger
// structure.
// 
// It is not necessary to initialise a recursive mutex that has been
// statically allocated.
// 
// |[&lt;!-- language="C" --&gt;
//   typedef struct {
//     GRecMutex m;
//     ...
//   } Blob;
// 
// Blob *b;
// 
// b = g_new (Blob, 1);
// g_rec_mutex_init (&amp;b-&gt;m);
// ]|
// 
// Calling g_rec_mutex_init() on an already initialized #GRecMutex
// leads to undefined behaviour.
// 
// To undo the effect of g_rec_mutex_init() when a recursive mutex
// is no longer needed, use g_rec_mutex_clear().
func (recMutex *RecMutex) Init() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_init(carg0)
	runtime.KeepAlive(recMutex)
}

// Lock wraps g_rec_mutex_lock
//
// Locks @rec_mutex. If @rec_mutex is already locked by another
// thread, the current thread will block until @rec_mutex is
// unlocked by the other thread. If @rec_mutex is already locked
// by the current thread, the 'lock count' of @rec_mutex is increased.
// The mutex will only become available again when it is unlocked
// as many times as it has been locked.
func (recMutex *RecMutex) Lock() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_lock(carg0)
	runtime.KeepAlive(recMutex)
}

// Trylock wraps g_rec_mutex_trylock
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Tries to lock @rec_mutex. If @rec_mutex is already locked
// by another thread, it immediately returns %FALSE. Otherwise
// it locks @rec_mutex and returns %TRUE.
func (recMutex *RecMutex) Trylock() bool {
	var carg0 *C.GRecMutex // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	cret = C.g_rec_mutex_trylock(carg0)
	runtime.KeepAlive(recMutex)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Unlock wraps g_rec_mutex_unlock
//
// Unlocks @rec_mutex. If another thread is blocked in a
// g_rec_mutex_lock() call for @rec_mutex, it will become unblocked
// and can lock @rec_mutex itself.
// 
// Calling g_rec_mutex_unlock() on a recursive mutex that is not
// locked by the current thread leads to undefined behaviour.
func (recMutex *RecMutex) Unlock() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_unlock(carg0)
	runtime.KeepAlive(recMutex)
}

// Regex wraps GRegex
//
// A `GRegex` is a compiled form of a regular expression.
// 
// After instantiating a `GRegex`, you can use its methods to find matches
// in a string, replace matches within a string, or split the string at matches.
// 
// `GRegex` implements regular expression pattern matching using syntax and
// semantics (such as character classes, quantifiers, and capture groups)
// similar to Perl regular expression. See the
// [PCRE documentation](man:pcre2pattern(3)) for details.
// 
// A typical scenario for regex pattern matching is to check if a string
// matches a pattern. The following statements implement this scenario.
// 
// ``` { .c }
// const char *regex_pattern = ".*GLib.*";
// const char *string_to_search = "You will love the GLib implementation of regex";
// g_autoptr(GMatchInfo) match_info = NULL;
// g_autoptr(GRegex) regex = NULL;
// 
// regex = g_regex_new (regex_pattern, G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
// g_assert (regex != NULL);
// 
// if (g_regex_match (regex, string_to_search, G_REGEX_MATCH_DEFAULT, &amp;match_info))
//   {
//     int start_pos, end_pos;
//     g_match_info_fetch_pos (match_info, 0, &amp;start_pos, &amp;end_pos);
//     g_print ("Match successful! Overall pattern matches bytes %d to %d\n", start_pos, end_pos);
//   }
// else
//   {
//     g_print ("No match!\n");
//   }
// ```
// 
// The constructor for `GRegex` includes two sets of bitmapped flags:
// 
// * [flags@GLib.RegexCompileFlags]&#x2014;These flags
// control how GLib compiles the regex. There are options for case
// sensitivity, multiline, ignoring whitespace, etc.
// * [flags@GLib.RegexMatchFlags]&#x2014;These flags control
// `GRegex`&#x2019;s matching behavior, such as anchoring and customizing definitions
// for newline characters.
// 
// Some regex patterns include backslash assertions, such as `\d` (digit) or
// `\D` (non-digit). The regex pattern must escape those backslashes. For
// example, the pattern `"\\d\\D"` matches a digit followed by a non-digit.
// 
// GLib&#x2019;s implementation of pattern matching includes a `start_position`
// argument for some of the match, replace, and split methods. Specifying
// a start position provides flexibility when you want to ignore the first
// _n_ characters of a string, but want to incorporate backslash assertions
// at character _n_ - 1. For example, a database field contains inconsistent
// spelling for a job title: `healthcare provider` and `health-care provider`.
// The database manager wants to make the spelling consistent by adding a
// hyphen when it is missing. The following regex pattern tests for the string
// `care` preceded by a non-word boundary character (instead of a hyphen)
// and followed by a space.
// 
// ``` { .c }
// const char *regex_pattern = "\\Bcare\\s";
// ```
// 
// An efficient way to match with this pattern is to start examining at
// `start_position` 6 in the string `healthcare` or `health-care`.
// 
// ``` { .c }
// const char *regex_pattern = "\\Bcare\\s";
// const char *string_to_search = "healthcare provider";
// g_autoptr(GMatchInfo) match_info = NULL;
// g_autoptr(GRegex) regex = NULL;
// 
// regex = g_regex_new (
//   regex_pattern,
//   G_REGEX_DEFAULT,
//   G_REGEX_MATCH_DEFAULT,
//   NULL);
// g_assert (regex != NULL);
// 
// g_regex_match_full (
//   regex,
//   string_to_search,
//   -1,
//   6, // position of 'c' in the test string.
//   G_REGEX_MATCH_DEFAULT,
//   &amp;match_info,
//   NULL);
// ```
// 
// The method [method@GLib.Regex.match_full] (and other methods implementing
// `start_pos`) allow for lookback before the start position to determine if
// the previous character satisfies an assertion.
// 
// Unless you set the [flags@GLib.RegexCompileFlags.RAW] as one of
// the `GRegexCompileFlags`, all the strings passed to `GRegex` methods must
// be encoded in UTF-8. The lengths and the positions inside the strings are
// in bytes and not in characters, so, for instance, `\xc3\xa0` (i.e., `&#xE0;`)
// is two bytes long but it is treated as a single character. If you set
// `G_REGEX_RAW`, the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so `\xc3\xa0` is two bytes and two characters long.
// 
// Regarding line endings, `\n` matches a `\n` character, and `\r` matches
// a `\r` character. More generally, `\R` matches all typical line endings:
// CR + LF (`\r\n`), LF (linefeed, U+000A, `\n`), VT (vertical tab, U+000B,
// `\v`), FF (formfeed, U+000C, `\f`), CR (carriage return, U+000D, `\r`),
// NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph
// separator, U+2029).
// 
// The behaviour of the dot, circumflex, and dollar metacharacters are
// affected by newline characters. By default, `GRegex` matches any newline
// character matched by `\R`. You can limit the matched newline characters by
// specifying the [flags@GLib.RegexMatchFlags.NEWLINE_CR],
// [flags@GLib.RegexMatchFlags.NEWLINE_LF], and
// [flags@GLib.RegexMatchFlags.NEWLINE_CRLF] compile options, and
// with [flags@GLib.RegexMatchFlags.NEWLINE_ANY],
// [flags@GLib.RegexMatchFlags.NEWLINE_CR],
// [flags@GLib.RegexMatchFlags.NEWLINE_LF] and
// [flags@GLib.RegexMatchFlags.NEWLINE_CRLF] match options.
// These settings are also relevant when compiling a pattern if
// [flags@GLib.RegexCompileFlags.EXTENDED] is set and an unescaped
// `#` outside a character class is encountered. This indicates a comment
// that lasts until after the next newline.
// 
// Because `GRegex` does not modify its internal state between creation and
// destruction, you can create and modify the same `GRegex` instance from
// different threads. In contrast, [struct@GLib.MatchInfo] is not thread safe.
// 
// The regular expression low-level functionalities are obtained through
// the excellent [PCRE](http://www.pcre.org/) library written by Philip Hazel.
type Regex struct {
	*regex
}

// regex is the struct that's finalized
type regex struct {
	native *C.GRegex
}

// UnsafeRegexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *Regex) instance() *C.GRegex {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRegexFromGlibBorrow is used to convert raw C.GRegex pointers to go. This is used by the bindings internally.
func UnsafeRegexFromGlibBorrow(p unsafe.Pointer) *Regex {
	if p == nil {
		return nil
	}
	return &Regex{&regex{(*C.GRegex)(p)}}
}

// UnsafeRegexFromGlibNone is used to convert raw C.GRegex pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRegexFromGlibNone(p unsafe.Pointer) *Regex {
	C.g_regex_ref((*C.GRegex)(p))
	wrapped := UnsafeRegexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.regex,
		func (intern *regex) {
			C.g_regex_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeRegexFromGlibFull is used to convert raw C.GRegex pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRegexFromGlibFull(p unsafe.Pointer) *Regex {
	wrapped := UnsafeRegexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.regex,
		func (intern *regex) {
			C.g_regex_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeRegexRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Regex.UnsafeRegexUnref], then [Regex] will leak memory.
func UnsafeRegexRef(r *Regex) {
	C.g_regex_ref(r.native)
}

// UnsafeRegexUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Regex] is expected to work anymore.
func UnsafeRegexUnref(r *Regex) {
	C.g_regex_unref(r.native)
}

// UnsafeRegexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRegexToGlibNone(r *Regex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRegexToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRegexToGlibFull(r *Regex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.regex, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // Regex is invalid from here on
	return _p
}

// NewRegex wraps g_regex_new
// 
// The function takes the following parameters:
// 
// 	- pattern string: the regular expression 
// 	- compileOptions RegexCompileFlags: compile options for the regular expression, or 0 
// 	- matchOptions RegexMatchFlags: match options for the regular expression, or 0 
// 
// The function returns the following values:
// 
// 	- goret *Regex (nullable) 
// 	- _goerr error (nullable): an error 
//
// Compiles the regular expression to an internal form, and does
// the initial setup of the #GRegex structure.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var carg1 *C.gchar             // in, none, string
	var carg2 C.GRegexCompileFlags // in, none, casted
	var carg3 C.GRegexMatchFlags   // in, none, casted
	var cret  *C.GRegex            // return, full, converted, nullable
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexCompileFlags(compileOptions)
	carg3 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_new(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret  *Regex
	var _goerr error

	if cret != nil {
		goret = UnsafeRegexFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegexCheckReplacement wraps g_regex_check_replacement
// 
// The function takes the following parameters:
// 
// 	- replacement string: the replacement string 
// 
// The function returns the following values:
// 
// 	- hasReferences bool: location to store information about
//   references in @replacement or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Checks whether @replacement is a valid replacement string
// (see g_regex_replace()), i.e. that all escape sequences in
// it are valid.
// 
// If @has_references is not %NULL then @replacement is checked
// for pattern references. For instance, replacement text 'foo\n'
// does not contain references and may be evaluated without information
// about actual match, but '\0\1' (whole match followed by first
// subpattern) requires valid #GMatchInfo object.
func RegexCheckReplacement(replacement string) (bool, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gboolean // out
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_regex_check_replacement(carg1, &carg2, &_cerr)
	runtime.KeepAlive(replacement)

	var hasReferences bool
	var goret         bool
	var _goerr        error

	if carg2 != 0 {
		hasReferences = true
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return hasReferences, goret, _goerr
}

// RegexErrorQuark wraps g_regex_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func RegexErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_regex_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// RegexEscapeNul wraps g_regex_escape_nul
// 
// The function takes the following parameters:
// 
// 	- str string: the string to escape 
// 	- length int32: the length of @string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes the nul characters in @string to "\x00".  It can be used
// to compile a regex with embedded nul characters.
// 
// For completeness, @length can be -1 for a nul-terminated string.
// In this case the output string will be of course equal to @string.
func RegexEscapeNul(str string, length int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(length)

	cret = C.g_regex_escape_nul(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegexEscapeString wraps g_regex_escape_string
// 
// The function takes the following parameters:
// 
// 	- str string: the string to escape 
// 	- length int32: the length of @string, in bytes, or -1 if @string is nul-terminated 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes the special characters used for regular expressions
// in @string, for instance "a.b*c" becomes "a\.b\*c". This
// function is useful to dynamically generate regular expressions.
// 
// @string can contain nul characters that are replaced with "\0",
// in this case remember to specify the correct length of @string
// in @length.
func RegexEscapeString(str string, length int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(length)

	cret = C.g_regex_escape_string(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegexMatchSimple wraps g_regex_match_simple
// 
// The function takes the following parameters:
// 
// 	- pattern string: the regular expression 
// 	- str string: the string to scan for matches 
// 	- compileOptions RegexCompileFlags: compile options for the regular expression, or 0 
// 	- matchOptions RegexMatchFlags: match options, or 0 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Scans for a match in @string for @pattern.
// 
// This function is equivalent to g_regex_match() but it does not
// require to compile the pattern with g_regex_new(), avoiding some
// lines of code when you need just to do a match without extracting
// substrings, capture counts, and so on.
// 
// If this function is to be called on the same @pattern more than
// once, it's more efficient to compile the pattern once with
// g_regex_new() and then use g_regex_match().
func RegexMatchSimple(pattern string, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 C.GRegexCompileFlags // in, none, casted
	var carg4 C.GRegexMatchFlags   // in, none, casted
	var cret  C.gboolean           // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GRegexCompileFlags(compileOptions)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_simple(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegexSplitSimple wraps g_regex_split_simple
// 
// The function takes the following parameters:
// 
// 	- pattern string: the regular expression 
// 	- str string: the string to scan for matches 
// 	- compileOptions RegexCompileFlags: compile options for the regular expression, or 0 
// 	- matchOptions RegexMatchFlags: match options, or 0 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses,
// then the text for each of the substrings will also be returned.
// If the pattern does not match anywhere in the string, then the
// whole string is returned as the first token.
// 
// This function is equivalent to g_regex_split() but it does
// not require to compile the pattern with g_regex_new(), avoiding
// some lines of code when you need just to do a split without
// extracting substrings, capture counts, and so on.
// 
// If this function is to be called on the same @pattern more than
// once, it's more efficient to compile the pattern once with
// g_regex_new() and then use g_regex_split().
// 
// As a special case, the result of splitting the empty string ""
// is an empty vector, not a vector containing a single string.
// The reason for this special case is that being able to represent
// an empty vector is typically more useful than consistent handling
// of empty elements. If you do need to represent empty elements,
// you'll need to check for the empty string before calling this
// function.
// 
// A pattern that can match empty strings splits @string into
// separate characters wherever it matches the empty string between
// characters. For example splitting "ab c" using as a separator
// "\s*", you will get "a", "b" and "c".
func RegexSplitSimple(pattern string, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 C.GRegexCompileFlags // in, none, casted
	var carg4 C.GRegexMatchFlags   // in, none, casted
	var cret  **C.gchar            // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GRegexCompileFlags(compileOptions)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_split_simple(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetCaptureCount wraps g_regex_get_capture_count
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the number of capturing subpatterns in the pattern.
func (regex *Regex) GetCaptureCount() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_capture_count(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetCompileFlags wraps g_regex_get_compile_flags
// 
// The function returns the following values:
// 
// 	- goret RegexCompileFlags 
//
// Returns the compile options that @regex was created with.
// 
// Depending on the version of PCRE that is used, this may or may not
// include flags set by option expressions such as `(?i)` found at the
// top-level within the compiled pattern.
func (regex *Regex) GetCompileFlags() RegexCompileFlags {
	var carg0 *C.GRegex            // in, none, converted
	var cret  C.GRegexCompileFlags // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_compile_flags(carg0)
	runtime.KeepAlive(regex)

	var goret RegexCompileFlags

	goret = RegexCompileFlags(cret)

	return goret
}

// GetHasCrOrLf wraps g_regex_get_has_cr_or_lf
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks whether the pattern contains explicit CR or LF references.
func (regex *Regex) GetHasCrOrLf() bool {
	var carg0 *C.GRegex  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_has_cr_or_lf(carg0)
	runtime.KeepAlive(regex)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMatchFlags wraps g_regex_get_match_flags
// 
// The function returns the following values:
// 
// 	- goret RegexMatchFlags 
//
// Returns the match options that @regex was created with.
func (regex *Regex) GetMatchFlags() RegexMatchFlags {
	var carg0 *C.GRegex          // in, none, converted
	var cret  C.GRegexMatchFlags // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_match_flags(carg0)
	runtime.KeepAlive(regex)

	var goret RegexMatchFlags

	goret = RegexMatchFlags(cret)

	return goret
}

// GetMaxBackref wraps g_regex_get_max_backref
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the number of the highest back reference
// in the pattern, or 0 if the pattern does not contain
// back references.
func (regex *Regex) GetMaxBackref() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_max_backref(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetMaxLookbehind wraps g_regex_get_max_lookbehind
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets the number of characters in the longest lookbehind assertion in the
// pattern. This information is useful when doing multi-segment matching using
// the partial matching facilities.
func (regex *Regex) GetMaxLookbehind() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_max_lookbehind(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetPattern wraps g_regex_get_pattern
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets the pattern string associated with @regex, i.e. a copy of
// the string passed to g_regex_new().
func (regex *Regex) GetPattern() string {
	var carg0 *C.GRegex // in, none, converted
	var cret  *C.gchar  // return, none, string

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_pattern(carg0)
	runtime.KeepAlive(regex)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetStringNumber wraps g_regex_get_string_number
// 
// The function takes the following parameters:
// 
// 	- name string: name of the subexpression 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Retrieves the number of the subexpression named @name.
func (regex *Regex) GetStringNumber(name string) int32 {
	var carg0 *C.GRegex // in, none, converted
	var carg1 *C.gchar  // in, none, string
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_regex_get_string_number(carg0, carg1)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(name)

	var goret int32

	goret = int32(cret)

	return goret
}

// Match wraps g_regex_match
// 
// The function takes the following parameters:
// 
// 	- str string: the string to scan for matches 
// 	- matchOptions RegexMatchFlags: match options 
// 
// The function returns the following values:
// 
// 	- matchInfo *MatchInfo: pointer to location where to store
//     the #GMatchInfo, or %NULL if you do not need it 
// 	- goret bool 
//
// Scans for a match in @string for the pattern in @regex.
// The @match_options are combined with the match options specified
// when the @regex structure was created, letting you have more
// flexibility in reusing #GRegex structures.
// 
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
// 
// A #GMatchInfo structure, used to get information on the match,
// is stored in @match_info if not %NULL. Note that if @match_info
// is not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually matched.
// 
// To retrieve all the non-overlapping matches of the pattern in
// string you can use g_match_info_next().
// 
// |[&lt;!-- language="C" --&gt;
// static void
// print_uppercase_words (const gchar *string)
// {
//   // Print all uppercase-only words.
//   GRegex *regex;
//   GMatchInfo *match_info;
//  
//   regex = g_regex_new ("[A-Z]+", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
//   g_regex_match (regex, string, 0, &amp;match_info);
//   while (g_match_info_matches (match_info))
//     {
//       gchar *word = g_match_info_fetch (match_info, 0);
//       g_print ("Found: %s\n", word);
//       g_free (word);
//       g_match_info_next (match_info, NULL);
//     }
//   g_match_info_free (match_info);
//   g_regex_unref (regex);
// }
// ]|
// 
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (regex *Regex) Match(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var carg3 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match(carg0, carg1, carg2, &carg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return matchInfo, goret
}

// MatchAll wraps g_regex_match_all
// 
// The function takes the following parameters:
// 
// 	- str string: the string to scan for matches 
// 	- matchOptions RegexMatchFlags: match options 
// 
// The function returns the following values:
// 
// 	- matchInfo *MatchInfo: pointer to location where to store
//     the #GMatchInfo, or %NULL if you do not need it 
// 	- goret bool 
//
// Using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses
// a different algorithm so it can retrieve all the possible matches.
// For more documentation see g_regex_match_all_full().
// 
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
// 
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (regex *Regex) MatchAll(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var carg3 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_all(carg0, carg1, carg2, &carg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return matchInfo, goret
}

// MatchAllFull wraps g_regex_match_all_full
// 
// The function takes the following parameters:
// 
// 	- str string: the string to scan for matches 
// 	- startPosition int32: starting index of the string to match, in bytes 
// 	- matchOptions RegexMatchFlags: match options 
// 
// The function returns the following values:
// 
// 	- matchInfo *MatchInfo: pointer to location where to store
//     the #GMatchInfo, or %NULL if you do not need it 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Using the standard algorithm for regular expression matching only
// the longest match in the @string is retrieved, it is not possible
// to obtain all the available matches. For instance matching
// `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"` against the pattern `"&lt;.*&gt;"`
// you get `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"`.
// 
// This function uses a different algorithm (called DFA, i.e. deterministic
// finite automaton), so it can retrieve all the possible matches, all
// starting at the same point in the string. For instance matching
// `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"` against the pattern `"&lt;.*&gt;"`
// you would obtain three matches: `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"`,
// `"&lt;a&gt; &lt;b&gt;"` and `"&lt;a&gt;"`.
// 
// The number of matched strings is retrieved using
// g_match_info_get_match_count(). To obtain the matched strings and
// their position you can use, respectively, g_match_info_fetch() and
// g_match_info_fetch_pos(). Note that the strings are returned in
// reverse order of length; that is, the longest matching string is
// given first.
// 
// Note that the DFA algorithm is slower than the standard one and it
// is not able to capture substrings, so backreferences do not work.
// 
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
// 
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
// 
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
// 
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
func (regex *Regex) MatchAllFull(str string, startPosition int32, matchOptions RegexMatchFlags) (*MatchInfo, bool, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_all_full(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool
	var _goerr    error

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return matchInfo, goret, _goerr
}

// MatchFull wraps g_regex_match_full
// 
// The function takes the following parameters:
// 
// 	- str string: the string to scan for matches 
// 	- startPosition int32: starting index of the string to match, in bytes 
// 	- matchOptions RegexMatchFlags: match options 
// 
// The function returns the following values:
// 
// 	- matchInfo *MatchInfo: pointer to location where to store
//     the #GMatchInfo, or %NULL if you do not need it 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Scans for a match in @string for the pattern in @regex.
// The @match_options are combined with the match options specified
// when the @regex structure was created, letting you have more
// flexibility in reusing #GRegex structures.
// 
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
// 
// Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.
// 
// A #GMatchInfo structure, used to get information on the match, is
// stored in @match_info if not %NULL. Note that if @match_info is
// not %NULL then it is created even if the function returns %FALSE,
// i.e. you must free it regardless if regular expression actually
// matched.
// 
// @string is not copied and is used in #GMatchInfo internally. If
// you use any #GMatchInfo method (except g_match_info_free()) after
// freeing or modifying @string then the behaviour is undefined.
// 
// To retrieve all the non-overlapping matches of the pattern in
// string you can use g_match_info_next().
// 
// |[&lt;!-- language="C" --&gt;
// static void
// print_uppercase_words (const gchar *string)
// {
//   // Print all uppercase-only words.
//   GRegex *regex;
//   GMatchInfo *match_info;
//   GError *error = NULL;
//   
//   regex = g_regex_new ("[A-Z]+", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
//   g_regex_match_full (regex, string, -1, 0, 0, &amp;match_info, &amp;error);
//   while (g_match_info_matches (match_info))
//     {
//       gchar *word = g_match_info_fetch (match_info, 0);
//       g_print ("Found: %s\n", word);
//       g_free (word);
//       g_match_info_next (match_info, &amp;error);
//     }
//   g_match_info_free (match_info);
//   g_regex_unref (regex);
//   if (error != NULL)
//     {
//       g_printerr ("Error while matching: %s\n", error-&gt;message);
//       g_error_free (error);
//     }
// }
// ]|
func (regex *Regex) MatchFull(str string, startPosition int32, matchOptions RegexMatchFlags) (*MatchInfo, bool, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_full(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool
	var _goerr    error

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return matchInfo, goret, _goerr
}

// Replace wraps g_regex_replace
// 
// The function takes the following parameters:
// 
// 	- str string: the string to perform matches against 
// 	- startPosition int32: starting index of the string to match, in bytes 
// 	- replacement string: text to replace each match with 
// 	- matchOptions RegexMatchFlags: options for the match 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Replaces all occurrences of the pattern in @regex with the
// replacement text. Backreferences of the form `\number` or
// `\g&lt;number&gt;` in the replacement text are interpolated by the
// number-th captured subexpression of the match, `\g&lt;name&gt;` refers
// to the captured subexpression with the given name. `\0` refers
// to the complete match, but `\0` followed by a number is the octal
// representation of a character. To include a literal `\` in the
// replacement, write `\\\\`.
// 
// There are also escapes that changes the case of the following text:
// 
// - \l: Convert to lower case the next character
// - \u: Convert to upper case the next character
// - \L: Convert to lower case till \E
// - \U: Convert to upper case till \E
// - \E: End case modification
// 
// If you do not need to use backreferences use g_regex_replace_literal().
// 
// The @replacement string must be UTF-8 encoded even if %G_REGEX_RAW was
// passed to g_regex_new(). If you want to use not UTF-8 encoded strings
// you can use g_regex_replace_literal().
// 
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern that
// begins with any kind of lookbehind assertion, such as "\b".
func (regex *Regex) Replace(str string, startPosition int32, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 *C.gchar           // in, none, string
	var carg5 C.GRegexMatchFlags // in, none, casted
	var cret  *C.gchar           // return, full, string
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_replace(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(replacement)
	runtime.KeepAlive(matchOptions)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceLiteral wraps g_regex_replace_literal
// 
// The function takes the following parameters:
// 
// 	- str string: the string to perform matches against 
// 	- startPosition int32: starting index of the string to match, in bytes 
// 	- replacement string: text to replace each match with 
// 	- matchOptions RegexMatchFlags: options for the match 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Replaces all occurrences of the pattern in @regex with the
// replacement text. @replacement is replaced literally, to
// include backreferences use g_regex_replace().
// 
// Setting @start_position differs from just passing over a
// shortened string and setting %G_REGEX_MATCH_NOTBOL in the
// case of a pattern that begins with any kind of lookbehind
// assertion, such as "\b".
func (regex *Regex) ReplaceLiteral(str string, startPosition int32, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 *C.gchar           // in, none, string
	var carg5 C.GRegexMatchFlags // in, none, casted
	var cret  *C.gchar           // return, full, string
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_replace_literal(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(replacement)
	runtime.KeepAlive(matchOptions)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Split wraps g_regex_split
// 
// The function takes the following parameters:
// 
// 	- str string: the string to split with the pattern 
// 	- matchOptions RegexMatchFlags: match time option flags 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first
// token.
// 
// As a special case, the result of splitting the empty string "" is an
// empty vector, not a vector containing a single string. The reason for
// this special case is that being able to represent an empty vector is
// typically more useful than consistent handling of empty elements. If
// you do need to represent empty elements, you'll need to check for the
// empty string before calling this function.
// 
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters.
// For example splitting "ab c" using as a separator "\s*", you will get
// "a", "b" and "c".
func (regex *Regex) Split(str string, matchOptions RegexMatchFlags) []string {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_split(carg0, carg1, carg2)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// SplitFull wraps g_regex_split_full
// 
// The function takes the following parameters:
// 
// 	- str string: the string to split with the pattern 
// 	- startPosition int32: starting index of the string to match, in bytes 
// 	- matchOptions RegexMatchFlags: match time option flags 
// 	- maxTokens int32: the maximum number of tokens to split @string into.
//   If this is less than 1, the string is split completely 
// 
// The function returns the following values:
// 
// 	- goret []string 
// 	- _goerr error (nullable): an error 
//
// Breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each
// of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first
// token.
// 
// As a special case, the result of splitting the empty string "" is an
// empty vector, not a vector containing a single string. The reason for
// this special case is that being able to represent an empty vector is
// typically more useful than consistent handling of empty elements. If
// you do need to represent empty elements, you'll need to check for the
// empty string before calling this function.
// 
// A pattern that can match empty strings splits @string into separate
// characters wherever it matches the empty string between characters.
// For example splitting "ab c" using as a separator "\s*", you will get
// "a", "b" and "c".
// 
// Setting @start_position differs from just passing over a shortened
// string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
// that begins with any kind of lookbehind assertion, such as "\b".
func (regex *Regex) SplitFull(str string, startPosition int32, matchOptions RegexMatchFlags, maxTokens int32) ([]string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 C.gint             // in, none, casted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)
	carg5 = C.gint(maxTokens)

	cret = C.g_regex_split_full(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)
	runtime.KeepAlive(maxTokens)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Scanner wraps GScanner
//
// `GScanner` provides a general-purpose lexical scanner.
// 
// You should set @input_name after creating the scanner, since
// it is used by the default message handler when displaying
// warnings and errors. If you are scanning a file, the filename
// would be a good choice.
// 
// The @user_data and @max_parse_errors fields are not used.
// If you need to associate extra data with the scanner you
// can place them here.
// 
// If you want to use your own message handler you can set the
// @msg_handler field. The type of the message handler function
// is declared by #GScannerMsgFunc.
type Scanner struct {
	*scanner
}

// scanner is the struct that's finalized
type scanner struct {
	native *C.GScanner
}

// UnsafeScannerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *Scanner) instance() *C.GScanner {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeScannerFromGlibBorrow is used to convert raw C.GScanner pointers to go. This is used by the bindings internally.
func UnsafeScannerFromGlibBorrow(p unsafe.Pointer) *Scanner {
	if p == nil {
		return nil
	}
	return &Scanner{&scanner{(*C.GScanner)(p)}}
}

// UnsafeScannerFromGlibNone is used to convert raw C.GScanner pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeScannerFromGlibNone(p unsafe.Pointer) *Scanner {
	wrapped := UnsafeScannerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Scanner because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeScannerFromGlibFull is used to convert raw C.GScanner pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeScannerFromGlibFull(p unsafe.Pointer) *Scanner {
	wrapped := UnsafeScannerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.scanner,
		func (intern *scanner) {
			C.g_scanner_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeScannerDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Scanner] is expected to work anymore.
func UnsafeScannerDestroy(s *Scanner) {
	C.g_scanner_destroy(s.native)
}

// UnsafeScannerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeScannerToGlibNone(s *Scanner) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeScannerToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeScannerToGlibFull(s *Scanner) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.scanner, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // Scanner is invalid from here on
	return _p
}

// CurLine wraps g_scanner_cur_line
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the current line in the input stream (counting
// from 1). This is the line of the last token parsed via
// g_scanner_get_next_token().
func (scanner *Scanner) CurLine() uint {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_line(carg0)
	runtime.KeepAlive(scanner)

	var goret uint

	goret = uint(cret)

	return goret
}

// CurPosition wraps g_scanner_cur_position
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the current position in the current line (counting
// from 0). This is the position of the last token parsed via
// g_scanner_get_next_token().
func (scanner *Scanner) CurPosition() uint {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_position(carg0)
	runtime.KeepAlive(scanner)

	var goret uint

	goret = uint(cret)

	return goret
}

// CurToken wraps g_scanner_cur_token
// 
// The function returns the following values:
// 
// 	- goret TokenType 
//
// Gets the current token type. This is simply the @token
// field in the #GScanner structure.
func (scanner *Scanner) CurToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// EOF wraps g_scanner_eof
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns %TRUE if the scanner has reached the end of
// the file or text buffer.
func (scanner *Scanner) EOF() bool {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_eof(carg0)
	runtime.KeepAlive(scanner)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNextToken wraps g_scanner_get_next_token
// 
// The function returns the following values:
// 
// 	- goret TokenType 
//
// Parses the next token just like g_scanner_peek_next_token()
// and also removes it from the input stream. The token data is
// placed in the @token, @value, @line, and @position fields of
// the #GScanner structure.
func (scanner *Scanner) GetNextToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_get_next_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// InputFile wraps g_scanner_input_file
// 
// The function takes the following parameters:
// 
// 	- inputFd int32: a file descriptor 
//
// Prepares to scan a file.
func (scanner *Scanner) InputFile(inputFd int32) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.gint      // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.gint(inputFd)

	C.g_scanner_input_file(carg0, carg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(inputFd)
}

// InputText wraps g_scanner_input_text
// 
// The function takes the following parameters:
// 
// 	- text string: the text buffer to scan 
// 	- textLen uint: the length of the text buffer 
//
// Prepares to scan a text buffer.
func (scanner *Scanner) InputText(text string, textLen uint) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.guint     // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(textLen)

	C.g_scanner_input_text(carg0, carg1, carg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(text)
	runtime.KeepAlive(textLen)
}

// PeekNextToken wraps g_scanner_peek_next_token
// 
// The function returns the following values:
// 
// 	- goret TokenType 
//
// Parses the next token, without removing it from the input stream.
// The token data is placed in the @next_token, @next_value, @next_line,
// and @next_position fields of the #GScanner structure.
// 
// Note that, while the token is not removed from the input stream
// (i.e. the next call to g_scanner_get_next_token() will return the
// same token), it will not be reevaluated. This can lead to surprising
// results when changing scope or the scanner configuration after peeking
// the next token. Getting the next token after switching the scope or
// configuration will return whatever was peeked before, regardless of
// any symbols that may have been added or removed in the new scope.
func (scanner *Scanner) PeekNextToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_peek_next_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// ScopeRemoveSymbol wraps g_scanner_scope_remove_symbol
// 
// The function takes the following parameters:
// 
// 	- scopeId uint: the scope id 
// 	- symbol string: the symbol to remove 
//
// Removes a symbol from a scope.
func (scanner *Scanner) ScopeRemoveSymbol(scopeId uint, symbol string) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.guint     // in, none, casted
	var carg2 *C.gchar    // in, none, string

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.guint(scopeId)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_scanner_scope_remove_symbol(carg0, carg1, carg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
}

// SetScope wraps g_scanner_set_scope
// 
// The function takes the following parameters:
// 
// 	- scopeId uint: the new scope id 
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Sets the current scope.
func (scanner *Scanner) SetScope(scopeId uint) uint {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.guint     // in, none, casted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.guint(scopeId)

	cret = C.g_scanner_set_scope(carg0, carg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)

	var goret uint

	goret = uint(cret)

	return goret
}

// SyncFileOffset wraps g_scanner_sync_file_offset
//
// Rewinds the filedescriptor to the current buffer position
// and blows the file read ahead buffer. This is useful for
// third party uses of the scanners filedescriptor, which hooks
// onto the current scanning position.
func (scanner *Scanner) SyncFileOffset() {
	var carg0 *C.GScanner // in, none, converted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	C.g_scanner_sync_file_offset(carg0)
	runtime.KeepAlive(scanner)
}

// UnexpToken wraps g_scanner_unexp_token
// 
// The function takes the following parameters:
// 
// 	- expectedToken TokenType: the expected token 
// 	- identifierSpec string: a string describing how the scanner's user
//     refers to identifiers (%NULL defaults to "identifier").
//     This is used if @expected_token is %G_TOKEN_IDENTIFIER or
//     %G_TOKEN_IDENTIFIER_NULL. 
// 	- symbolSpec string: a string describing how the scanner's user refers
//     to symbols (%NULL defaults to "symbol"). This is used if
//     @expected_token is %G_TOKEN_SYMBOL or any token value greater
//     than %G_TOKEN_LAST. 
// 	- symbolName string: the name of the symbol, if the scanner's current
//     token is a symbol. 
// 	- message string: a message string to output at the end of the
//     warning/error, or %NULL. 
// 	- isError int32: if %TRUE it is output as an error. If %FALSE it is
//     output as a warning. 
//
// Outputs a message through the scanner's msg_handler,
// resulting from an unexpected token in the input stream.
// Note that you should not call g_scanner_peek_next_token()
// followed by g_scanner_unexp_token() without an intermediate
// call to g_scanner_get_next_token(), as g_scanner_unexp_token()
// evaluates the scanner's current token (not the peeked token)
// to construct part of the message.
func (scanner *Scanner) UnexpToken(expectedToken TokenType, identifierSpec string, symbolSpec string, symbolName string, message string, isError int32) {
	var carg0 *C.GScanner  // in, none, converted
	var carg1 C.GTokenType // in, none, casted
	var carg2 *C.gchar     // in, none, string
	var carg3 *C.gchar     // in, none, string
	var carg4 *C.gchar     // in, none, string
	var carg5 *C.gchar     // in, none, string
	var carg6 C.gint       // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.GTokenType(expectedToken)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(identifierSpec)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(symbolSpec)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(symbolName)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = C.gint(isError)

	C.g_scanner_unexp_token(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(expectedToken)
	runtime.KeepAlive(identifierSpec)
	runtime.KeepAlive(symbolSpec)
	runtime.KeepAlive(symbolName)
	runtime.KeepAlive(message)
	runtime.KeepAlive(isError)
}

// ScannerConfig wraps GScannerConfig
//
// Specifies the #GScanner parser configuration. Most settings can
// be changed during the parsing phase and will affect the lexical
// parsing of the next unpeeked token.
type ScannerConfig struct {
	*scannerConfig
}

// scannerConfig is the struct that's finalized
type scannerConfig struct {
	native *C.GScannerConfig
}

// UnsafeScannerConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *ScannerConfig) instance() *C.GScannerConfig {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeScannerConfigFromGlibBorrow is used to convert raw C.GScannerConfig pointers to go. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibBorrow(p unsafe.Pointer) *ScannerConfig {
	if p == nil {
		return nil
	}
	return &ScannerConfig{&scannerConfig{(*C.GScannerConfig)(p)}}
}

// UnsafeScannerConfigFromGlibNone is used to convert raw C.GScannerConfig pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibNone(p unsafe.Pointer) *ScannerConfig {
	wrapped := UnsafeScannerConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ScannerConfig because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeScannerConfigFromGlibFull is used to convert raw C.GScannerConfig pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibFull(p unsafe.Pointer) *ScannerConfig {
	wrapped := UnsafeScannerConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.scannerConfig,
		func (intern *scannerConfig) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeScannerConfigFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ScannerConfig] is expected to work anymore.
func UnsafeScannerConfigFree(s *ScannerConfig) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeScannerConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeScannerConfigToGlibNone(s *ScannerConfig) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeScannerConfigToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeScannerConfigToGlibFull(s *ScannerConfig) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.scannerConfig, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // ScannerConfig is invalid from here on
	return _p
}

// Sequence wraps GSequence
//
// The #GSequence struct is an opaque data type representing a
// [sequence](data-structures.html#scalable-lists) data type.
type Sequence struct {
	*sequence
}

// sequence is the struct that's finalized
type sequence struct {
	native *C.GSequence
}

// UnsafeSequenceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *Sequence) instance() *C.GSequence {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSequenceFromGlibBorrow is used to convert raw C.GSequence pointers to go. This is used by the bindings internally.
func UnsafeSequenceFromGlibBorrow(p unsafe.Pointer) *Sequence {
	if p == nil {
		return nil
	}
	return &Sequence{&sequence{(*C.GSequence)(p)}}
}

// UnsafeSequenceFromGlibNone is used to convert raw C.GSequence pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSequenceFromGlibNone(p unsafe.Pointer) *Sequence {
	wrapped := UnsafeSequenceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Sequence because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSequenceFromGlibFull is used to convert raw C.GSequence pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSequenceFromGlibFull(p unsafe.Pointer) *Sequence {
	wrapped := UnsafeSequenceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sequence,
		func (intern *sequence) {
			C.g_sequence_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeSequenceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Sequence] is expected to work anymore.
func UnsafeSequenceFree(s *Sequence) {
	C.g_sequence_free(s.native)
}

// UnsafeSequenceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSequenceToGlibNone(s *Sequence) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSequenceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSequenceToGlibFull(s *Sequence) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sequence, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // Sequence is invalid from here on
	return _p
}

// SequenceMove wraps g_sequence_move
// 
// The function takes the following parameters:
// 
// 	- src *SequenceIter: a #GSequenceIter pointing to the item to move 
// 	- dest *SequenceIter: a #GSequenceIter pointing to the position to which
//     the item is moved 
//
// Moves the item pointed to by @src to the position indicated by @dest.
// After calling this function @dest will point to the position immediately
// after @src. It is allowed for @src and @dest to point into different
// sequences.
func SequenceMove(src *SequenceIter, dest *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(src))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(dest))

	C.g_sequence_move(carg1, carg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// SequenceMoveRange wraps g_sequence_move_range
// 
// The function takes the following parameters:
// 
// 	- dest *SequenceIter: a #GSequenceIter 
// 	- begin *SequenceIter: a #GSequenceIter 
// 	- end *SequenceIter: a #GSequenceIter 
//
// Inserts the (@begin, @end) range at the destination pointed to by @dest.
// The @begin and @end iters must point into the same sequence. It is
// allowed for @dest to point to a different sequence than the one pointed
// into by @begin and @end.
// 
// If @dest is %NULL, the range indicated by @begin and @end is
// removed from the sequence. If @dest points to a place within
// the (@begin, @end) range, the range does not move.
func SequenceMoveRange(dest *SequenceIter, begin *SequenceIter, end *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted
	var carg3 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(dest))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg3 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	C.g_sequence_move_range(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)
}

// SequenceRangeGetMidpoint wraps g_sequence_range_get_midpoint
// 
// The function takes the following parameters:
// 
// 	- begin *SequenceIter: a #GSequenceIter 
// 	- end *SequenceIter: a #GSequenceIter 
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Finds an iterator somewhere in the range (@begin, @end). This
// iterator will be close to the middle of the range, but is not
// guaranteed to be exactly in the middle.
// 
// The @begin and @end iterators must both point to the same sequence
// and @begin must come before or be equal to @end in the sequence.
func SequenceRangeGetMidpoint(begin *SequenceIter, end *SequenceIter) *SequenceIter {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	cret = C.g_sequence_range_get_midpoint(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SequenceRemove wraps g_sequence_remove
// 
// The function takes the following parameters:
// 
// 	- iter *SequenceIter: a #GSequenceIter 
//
// Removes the item pointed to by @iter. It is an error to pass the
// end iterator to this function.
// 
// If the sequence has a data destroy function associated with it, this
// function is called on the data for the removed item.
func SequenceRemove(iter *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	C.g_sequence_remove(carg1)
	runtime.KeepAlive(iter)
}

// SequenceRemoveRange wraps g_sequence_remove_range
// 
// The function takes the following parameters:
// 
// 	- begin *SequenceIter: a #GSequenceIter 
// 	- end *SequenceIter: a #GSequenceIter 
//
// Removes all items in the (@begin, @end) range.
// 
// If the sequence has a data destroy function associated with it, this
// function is called on the data for the removed items.
func SequenceRemoveRange(begin *SequenceIter, end *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	C.g_sequence_remove_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)
}

// SequenceSwap wraps g_sequence_swap
// 
// The function takes the following parameters:
// 
// 	- a *SequenceIter: a #GSequenceIter 
// 	- b *SequenceIter: a #GSequenceIter 
//
// Swaps the items pointed to by @a and @b. It is allowed for @a and @b
// to point into difference sequences.
func SequenceSwap(a *SequenceIter, b *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(a))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(b))

	C.g_sequence_swap(carg1, carg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)
}

// GetBeginIter wraps g_sequence_get_begin_iter
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns the begin iterator for @seq.
func (seq *Sequence) GetBeginIter() *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_begin_iter(carg0)
	runtime.KeepAlive(seq)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetEndIter wraps g_sequence_get_end_iter
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns the end iterator for @seg
func (seq *Sequence) GetEndIter() *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_end_iter(carg0)
	runtime.KeepAlive(seq)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetIterAtPos wraps g_sequence_get_iter_at_pos
// 
// The function takes the following parameters:
// 
// 	- pos int32: a position in @seq, or -1 for the end 
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns the iterator at position @pos. If @pos is negative or larger
// than the number of items in @seq, the end iterator is returned.
func (seq *Sequence) GetIterAtPos(pos int32) *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))
	carg1 = C.gint(pos)

	cret = C.g_sequence_get_iter_at_pos(carg0, carg1)
	runtime.KeepAlive(seq)
	runtime.KeepAlive(pos)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetLength wraps g_sequence_get_length
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the positive length (&gt;= 0) of @seq. Note that this method is
// O(h) where `h' is the height of the tree. It is thus more efficient
// to use g_sequence_is_empty() when comparing the length to zero.
func (seq *Sequence) GetLength() int32 {
	var carg0 *C.GSequence // in, none, converted
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_length(carg0)
	runtime.KeepAlive(seq)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsEmpty wraps g_sequence_is_empty
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns %TRUE if the sequence contains zero items.
// 
// This function is functionally identical to checking the result of
// g_sequence_get_length() being equal to zero. However this function is
// implemented in O(1) running time.
func (seq *Sequence) IsEmpty() bool {
	var carg0 *C.GSequence // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_is_empty(carg0)
	runtime.KeepAlive(seq)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SequenceIter wraps GSequenceIter
//
// The #GSequenceIter struct is an opaque data type representing an
// iterator pointing into a #GSequence.
type SequenceIter struct {
	*sequenceIter
}

// sequenceIter is the struct that's finalized
type sequenceIter struct {
	native *C.GSequenceIter
}

// UnsafeSequenceIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SequenceIter) instance() *C.GSequenceIter {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSequenceIterFromGlibBorrow is used to convert raw C.GSequenceIter pointers to go. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibBorrow(p unsafe.Pointer) *SequenceIter {
	if p == nil {
		return nil
	}
	return &SequenceIter{&sequenceIter{(*C.GSequenceIter)(p)}}
}

// UnsafeSequenceIterFromGlibNone is used to convert raw C.GSequenceIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibNone(p unsafe.Pointer) *SequenceIter {
	wrapped := UnsafeSequenceIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SequenceIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSequenceIterFromGlibFull is used to convert raw C.GSequenceIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibFull(p unsafe.Pointer) *SequenceIter {
	wrapped := UnsafeSequenceIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sequenceIter,
		func (intern *sequenceIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSequenceIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SequenceIter] is expected to work anymore.
func UnsafeSequenceIterFree(s *SequenceIter) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSequenceIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSequenceIterToGlibNone(s *SequenceIter) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSequenceIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSequenceIterToGlibFull(s *SequenceIter) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sequenceIter, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SequenceIter is invalid from here on
	return _p
}

// Compare wraps g_sequence_iter_compare
// 
// The function takes the following parameters:
// 
// 	- b *SequenceIter: a #GSequenceIter 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns a negative number if @a comes before @b, 0 if they are equal,
// and a positive number if @a comes after @b.
// 
// The @a and @b iterators must point into the same sequence.
func (a *SequenceIter) Compare(b *SequenceIter) int32 {
	var carg0 *C.GSequenceIter // in, none, converted
	var carg1 *C.GSequenceIter // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(a))
	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(b))

	cret = C.g_sequence_iter_compare(carg0, carg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetPosition wraps g_sequence_iter_get_position
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Returns the position of @iter
func (iter *SequenceIter) GetPosition() int32 {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_get_position(carg0)
	runtime.KeepAlive(iter)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSequence wraps g_sequence_iter_get_sequence
// 
// The function returns the following values:
// 
// 	- goret *Sequence 
//
// Returns the #GSequence that @iter points into.
func (iter *SequenceIter) GetSequence() *Sequence {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequence     // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_get_sequence(carg0)
	runtime.KeepAlive(iter)

	var goret *Sequence

	goret = UnsafeSequenceFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsBegin wraps g_sequence_iter_is_begin
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether @iter is the begin iterator
func (iter *SequenceIter) IsBegin() bool {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_is_begin(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsEnd wraps g_sequence_iter_is_end
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Returns whether @iter is the end iterator
func (iter *SequenceIter) IsEnd() bool {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_is_end(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Move wraps g_sequence_iter_move
// 
// The function takes the following parameters:
// 
// 	- delta int32: A positive or negative number indicating how many positions away
//    from @iter the returned #GSequenceIter will be 
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns the #GSequenceIter which is @delta positions away from @iter.
// If @iter is closer than -@delta positions to the beginning of the sequence,
// the begin iterator is returned. If @iter is closer than @delta positions
// to the end of the sequence, the end iterator is returned.
func (iter *SequenceIter) Move(delta int32) *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))
	carg1 = C.gint(delta)

	cret = C.g_sequence_iter_move(carg0, carg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(delta)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Next wraps g_sequence_iter_next
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns an iterator pointing to the next position after @iter.
// If @iter is the end iterator, the end iterator is returned.
func (iter *SequenceIter) Next() *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Prev wraps g_sequence_iter_prev
// 
// The function returns the following values:
// 
// 	- goret *SequenceIter 
//
// Returns an iterator pointing to the previous position before @iter.
// If @iter is the begin iterator, the begin iterator is returned.
func (iter *SequenceIter) Prev() *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_prev(carg0)
	runtime.KeepAlive(iter)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SourceCallbackFuncs wraps GSourceCallbackFuncs
//
// The `GSourceCallbackFuncs` struct contains
// functions for managing callback objects.
type SourceCallbackFuncs struct {
	*sourceCallbackFuncs
}

// sourceCallbackFuncs is the struct that's finalized
type sourceCallbackFuncs struct {
	native *C.GSourceCallbackFuncs
}

// UnsafeSourceCallbackFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SourceCallbackFuncs) instance() *C.GSourceCallbackFuncs {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSourceCallbackFuncsFromGlibBorrow is used to convert raw C.GSourceCallbackFuncs pointers to go. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibBorrow(p unsafe.Pointer) *SourceCallbackFuncs {
	if p == nil {
		return nil
	}
	return &SourceCallbackFuncs{&sourceCallbackFuncs{(*C.GSourceCallbackFuncs)(p)}}
}

// UnsafeSourceCallbackFuncsFromGlibNone is used to convert raw C.GSourceCallbackFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibNone(p unsafe.Pointer) *SourceCallbackFuncs {
	wrapped := UnsafeSourceCallbackFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SourceCallbackFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSourceCallbackFuncsFromGlibFull is used to convert raw C.GSourceCallbackFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibFull(p unsafe.Pointer) *SourceCallbackFuncs {
	wrapped := UnsafeSourceCallbackFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sourceCallbackFuncs,
		func (intern *sourceCallbackFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSourceCallbackFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SourceCallbackFuncs] is expected to work anymore.
func UnsafeSourceCallbackFuncsFree(s *SourceCallbackFuncs) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSourceCallbackFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsToGlibNone(s *SourceCallbackFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSourceCallbackFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSourceCallbackFuncsToGlibFull(s *SourceCallbackFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sourceCallbackFuncs, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SourceCallbackFuncs is invalid from here on
	return _p
}

// SourceFuncs wraps GSourceFuncs
//
// The `GSourceFuncs` struct contains a table of
// functions used to handle event sources in a generic manner.
// 
// For idle sources, the prepare and check functions always return %TRUE
// to indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
// 
// For timeout sources, the prepare and check functions both return %TRUE
// if the timeout interval has expired. The prepare function also returns
// a timeout value to ensure that the poll() call doesn't block too long
// and miss the next timeout.
// 
// For file descriptor sources, the prepare function typically returns %FALSE,
// since it must wait until poll() has been called before it knows whether
// any events need to be processed. It sets the returned timeout to -1 to
// indicate that it doesn't mind how long the poll() call blocks. In the
// check function, it tests the results of the poll() call to see if the
// required condition has been met, and returns %TRUE if so.
type SourceFuncs struct {
	*sourceFuncs
}

// sourceFuncs is the struct that's finalized
type sourceFuncs struct {
	native *C.GSourceFuncs
}

// UnsafeSourceFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SourceFuncs) instance() *C.GSourceFuncs {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSourceFuncsFromGlibBorrow is used to convert raw C.GSourceFuncs pointers to go. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibBorrow(p unsafe.Pointer) *SourceFuncs {
	if p == nil {
		return nil
	}
	return &SourceFuncs{&sourceFuncs{(*C.GSourceFuncs)(p)}}
}

// UnsafeSourceFuncsFromGlibNone is used to convert raw C.GSourceFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibNone(p unsafe.Pointer) *SourceFuncs {
	wrapped := UnsafeSourceFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SourceFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSourceFuncsFromGlibFull is used to convert raw C.GSourceFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibFull(p unsafe.Pointer) *SourceFuncs {
	wrapped := UnsafeSourceFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sourceFuncs,
		func (intern *sourceFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSourceFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SourceFuncs] is expected to work anymore.
func UnsafeSourceFuncsFree(s *SourceFuncs) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSourceFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSourceFuncsToGlibNone(s *SourceFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSourceFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSourceFuncsToGlibFull(s *SourceFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sourceFuncs, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SourceFuncs is invalid from here on
	return _p
}

// StringChunk wraps GStringChunk
//
// `GStringChunk` provides efficient storage of groups of strings
// 
// String chunks are used to store groups of strings. Memory is
// allocated in blocks, and as strings are added to the `GStringChunk`
// they are copied into the next free position in a block. When a block
// is full a new block is allocated.
// 
// When storing a large number of strings, string chunks are more
// efficient than using [func@GLib.strdup] since fewer calls to `malloc()`
// are needed, and less memory is wasted in memory allocation overheads.
// 
// By adding strings with [method@GLib.StringChunk.insert_const] it is also
// possible to remove duplicates.
// 
// To create a new `GStringChunk` use [func@GLib.StringChunk.new].
// 
// To add strings to a `GStringChunk` use [method@GLib.StringChunk.insert].
// 
// To add strings to a `GStringChunk`, but without duplicating strings
// which are already in the `GStringChunk`, use [method@GLib.StringChunk.insert_const].
// 
// To free the entire `GStringChunk` use [method@GLib.StringChunk.free].
// It is not possible to free individual strings.
type StringChunk struct {
	*stringChunk
}

// stringChunk is the struct that's finalized
type stringChunk struct {
	native *C.GStringChunk
}

// UnsafeStringChunkToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StringChunk) instance() *C.GStringChunk {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStringChunkFromGlibBorrow is used to convert raw C.GStringChunk pointers to go. This is used by the bindings internally.
func UnsafeStringChunkFromGlibBorrow(p unsafe.Pointer) *StringChunk {
	if p == nil {
		return nil
	}
	return &StringChunk{&stringChunk{(*C.GStringChunk)(p)}}
}

// UnsafeStringChunkFromGlibNone is used to convert raw C.GStringChunk pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStringChunkFromGlibNone(p unsafe.Pointer) *StringChunk {
	wrapped := UnsafeStringChunkFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to StringChunk because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeStringChunkFromGlibFull is used to convert raw C.GStringChunk pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStringChunkFromGlibFull(p unsafe.Pointer) *StringChunk {
	wrapped := UnsafeStringChunkFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.stringChunk,
		func (intern *stringChunk) {
			C.g_string_chunk_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeStringChunkFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StringChunk] is expected to work anymore.
func UnsafeStringChunkFree(s *StringChunk) {
	C.g_string_chunk_free(s.native)
}

// UnsafeStringChunkToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStringChunkToGlibNone(s *StringChunk) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStringChunkToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStringChunkToGlibFull(s *StringChunk) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.stringChunk, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StringChunk is invalid from here on
	return _p
}

// Clear wraps g_string_chunk_clear
//
// Frees all strings contained within the #GStringChunk.
// After calling g_string_chunk_clear() it is not safe to
// access any of the strings which were contained within it.
func (chunk *StringChunk) Clear() {
	var carg0 *C.GStringChunk // in, none, converted

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))

	C.g_string_chunk_clear(carg0)
	runtime.KeepAlive(chunk)
}

// Insert wraps g_string_chunk_insert
// 
// The function takes the following parameters:
// 
// 	- str string: the string to add 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Adds a copy of @string to the #GStringChunk.
// It returns a pointer to the new copy of the string
// in the #GStringChunk. The characters in the string
// can be changed, if necessary, though you should not
// change anything after the end of the string.
// 
// Unlike g_string_chunk_insert_const(), this function
// does not check for duplicates. Also strings added
// with g_string_chunk_insert() will not be searched
// by g_string_chunk_insert_const() when looking for
// duplicates.
func (chunk *StringChunk) Insert(str string) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_string_chunk_insert(carg0, carg1)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InsertConst wraps g_string_chunk_insert_const
// 
// The function takes the following parameters:
// 
// 	- str string: the string to add 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Adds a copy of @string to the #GStringChunk, unless the same
// string has already been added to the #GStringChunk with
// g_string_chunk_insert_const().
// 
// This function is useful if you need to copy a large number
// of strings but do not want to waste space storing duplicates.
// But you must remember that there may be several pointers to
// the same string, and so any changes made to the strings
// should be done very carefully.
// 
// Note that g_string_chunk_insert_const() will not return a
// pointer to a string added with g_string_chunk_insert(), even
// if they do match.
func (chunk *StringChunk) InsertConst(str string) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_string_chunk_insert_const(carg0, carg1)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InsertLen wraps g_string_chunk_insert_len
// 
// The function takes the following parameters:
// 
// 	- str string: bytes to insert 
// 	- len int: number of bytes of @string to insert, or -1 to insert a
//     nul-terminated string 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Adds a copy of the first @len bytes of @string to the #GStringChunk.
// The copy is nul-terminated.
// 
// Since this function does not stop at nul bytes, it is the caller's
// responsibility to ensure that @string has at least @len addressable
// bytes.
// 
// The characters in the returned string can be changed, if necessary,
// though you should not change anything after the end of the string.
func (chunk *StringChunk) InsertLen(str string, len int) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_string_chunk_insert_len(carg0, carg1, carg2)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// StrvBuilder wraps GStrvBuilder
//
// `GStrvBuilder` is a helper object to build a %NULL-terminated string arrays.
// 
// The following example shows how to build a two element array:
// 
// ```c
//   g_autoptr(GStrvBuilder) builder = g_strv_builder_new ();
//   g_strv_builder_add (builder, "hello");
//   g_strv_builder_add (builder, "world");
// 
//   g_auto(GStrv) array = g_strv_builder_end (builder);
// 
//   g_assert_true (g_strv_equal (array, (const char *[]) { "hello", "world", NULL }));
// ```
type StrvBuilder struct {
	*strvBuilder
}

// strvBuilder is the struct that's finalized
type strvBuilder struct {
	native *C.GStrvBuilder
}

// UnsafeStrvBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StrvBuilder) instance() *C.GStrvBuilder {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStrvBuilderFromGlibBorrow is used to convert raw C.GStrvBuilder pointers to go. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibBorrow(p unsafe.Pointer) *StrvBuilder {
	if p == nil {
		return nil
	}
	return &StrvBuilder{&strvBuilder{(*C.GStrvBuilder)(p)}}
}

// UnsafeStrvBuilderFromGlibNone is used to convert raw C.GStrvBuilder pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibNone(p unsafe.Pointer) *StrvBuilder {
	C.g_strv_builder_ref((*C.GStrvBuilder)(p))
	wrapped := UnsafeStrvBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.strvBuilder,
		func (intern *strvBuilder) {
			C.g_strv_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeStrvBuilderFromGlibFull is used to convert raw C.GStrvBuilder pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibFull(p unsafe.Pointer) *StrvBuilder {
	wrapped := UnsafeStrvBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.strvBuilder,
		func (intern *strvBuilder) {
			C.g_strv_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeStrvBuilderRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [StrvBuilder.UnsafeStrvBuilderUnref], then [StrvBuilder] will leak memory.
func UnsafeStrvBuilderRef(s *StrvBuilder) {
	C.g_strv_builder_ref(s.native)
}

// UnsafeStrvBuilderUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StrvBuilder] is expected to work anymore.
func UnsafeStrvBuilderUnref(s *StrvBuilder) {
	C.g_strv_builder_unref(s.native)
}

// UnsafeStrvBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStrvBuilderToGlibNone(s *StrvBuilder) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStrvBuilderToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStrvBuilderToGlibFull(s *StrvBuilder) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.strvBuilder, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StrvBuilder is invalid from here on
	return _p
}

// NewStrvBuilder wraps g_strv_builder_new
// 
// The function returns the following values:
// 
// 	- goret *StrvBuilder 
//
// Creates a new #GStrvBuilder with a reference count of 1.
// Use g_strv_builder_unref() on the returned value when no longer needed.
func NewStrvBuilder() *StrvBuilder {
	var cret *C.GStrvBuilder // return, full, converted

	cret = C.g_strv_builder_new()

	var goret *StrvBuilder

	goret = UnsafeStrvBuilderFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Add wraps g_strv_builder_add
// 
// The function takes the following parameters:
// 
// 	- value string: a string. 
//
// Add a string to the end of the array.
// 
// Since 2.68
func (builder *StrvBuilder) Add(value string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 *C.char         // in, none, string

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_strv_builder_add(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Addv wraps g_strv_builder_addv
// 
// The function takes the following parameters:
// 
// 	- value []string: the vector of strings to add 
//
// Appends all the strings in the given vector to the builder.
// 
// Since 2.70
func (builder *StrvBuilder) Addv(value []string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 **C.char        // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	_ = value
	_ = carg1
	panic("unimplemented conversion of []string (const char**) because of unimplemented: inner pointers in array")

	C.g_strv_builder_addv(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Take wraps g_strv_builder_take
// 
// The function takes the following parameters:
// 
// 	- value string: a string.
//     Ownership of the string is transferred to the #GStrvBuilder 
//
// Add a string to the end of the array. After @value belongs to the
// #GStrvBuilder and may no longer be modified by the caller.
// 
// Since 2.80
func (builder *StrvBuilder) Take(value string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 *C.char         // in, full, string

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(value)))

	C.g_strv_builder_take(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// TestCase wraps GTestCase
//
// An opaque structure representing a test case.
type TestCase struct {
	*testCase
}

// testCase is the struct that's finalized
type testCase struct {
	native *C.GTestCase
}

// UnsafeTestCaseToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestCase) instance() *C.GTestCase {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestCaseFromGlibBorrow is used to convert raw C.GTestCase pointers to go. This is used by the bindings internally.
func UnsafeTestCaseFromGlibBorrow(p unsafe.Pointer) *TestCase {
	if p == nil {
		return nil
	}
	return &TestCase{&testCase{(*C.GTestCase)(p)}}
}

// UnsafeTestCaseFromGlibNone is used to convert raw C.GTestCase pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestCaseFromGlibNone(p unsafe.Pointer) *TestCase {
	wrapped := UnsafeTestCaseFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestCase because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestCaseFromGlibFull is used to convert raw C.GTestCase pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestCaseFromGlibFull(p unsafe.Pointer) *TestCase {
	wrapped := UnsafeTestCaseFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testCase,
		func (intern *testCase) {
			C.g_test_case_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestCaseFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestCase] is expected to work anymore.
func UnsafeTestCaseFree(t *TestCase) {
	C.g_test_case_free(t.native)
}

// UnsafeTestCaseToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestCaseToGlibNone(t *TestCase) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestCaseToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestCaseToGlibFull(t *TestCase) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testCase, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestCase is invalid from here on
	return _p
}

// TestConfig wraps GTestConfig
type TestConfig struct {
	*testConfig
}

// testConfig is the struct that's finalized
type testConfig struct {
	native *C.GTestConfig
}

// UnsafeTestConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestConfig) instance() *C.GTestConfig {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestConfigFromGlibBorrow is used to convert raw C.GTestConfig pointers to go. This is used by the bindings internally.
func UnsafeTestConfigFromGlibBorrow(p unsafe.Pointer) *TestConfig {
	if p == nil {
		return nil
	}
	return &TestConfig{&testConfig{(*C.GTestConfig)(p)}}
}

// UnsafeTestConfigFromGlibNone is used to convert raw C.GTestConfig pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestConfigFromGlibNone(p unsafe.Pointer) *TestConfig {
	wrapped := UnsafeTestConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestConfig because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestConfigFromGlibFull is used to convert raw C.GTestConfig pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestConfigFromGlibFull(p unsafe.Pointer) *TestConfig {
	wrapped := UnsafeTestConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testConfig,
		func (intern *testConfig) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTestConfigFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestConfig] is expected to work anymore.
func UnsafeTestConfigFree(t *TestConfig) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTestConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestConfigToGlibNone(t *TestConfig) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestConfigToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestConfigToGlibFull(t *TestConfig) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testConfig, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestConfig is invalid from here on
	return _p
}

// TestLogBuffer wraps GTestLogBuffer
type TestLogBuffer struct {
	*testLogBuffer
}

// testLogBuffer is the struct that's finalized
type testLogBuffer struct {
	native *C.GTestLogBuffer
}

// UnsafeTestLogBufferToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestLogBuffer) instance() *C.GTestLogBuffer {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestLogBufferFromGlibBorrow is used to convert raw C.GTestLogBuffer pointers to go. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibBorrow(p unsafe.Pointer) *TestLogBuffer {
	if p == nil {
		return nil
	}
	return &TestLogBuffer{&testLogBuffer{(*C.GTestLogBuffer)(p)}}
}

// UnsafeTestLogBufferFromGlibNone is used to convert raw C.GTestLogBuffer pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibNone(p unsafe.Pointer) *TestLogBuffer {
	wrapped := UnsafeTestLogBufferFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestLogBuffer because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestLogBufferFromGlibFull is used to convert raw C.GTestLogBuffer pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibFull(p unsafe.Pointer) *TestLogBuffer {
	wrapped := UnsafeTestLogBufferFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testLogBuffer,
		func (intern *testLogBuffer) {
			C.g_test_log_buffer_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestLogBufferFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestLogBuffer] is expected to work anymore.
func UnsafeTestLogBufferFree(t *TestLogBuffer) {
	C.g_test_log_buffer_free(t.native)
}

// UnsafeTestLogBufferToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestLogBufferToGlibNone(t *TestLogBuffer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestLogBufferToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestLogBufferToGlibFull(t *TestLogBuffer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testLogBuffer, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestLogBuffer is invalid from here on
	return _p
}

// Push wraps g_test_log_buffer_push
// 
// The function takes the following parameters:
// 
// 	- nBytes uint 
// 	- bytes *uint8 
//
// Internal function for gtester to decode test log messages, no ABI guarantees provided.
func (tbuffer *TestLogBuffer) Push(nBytes uint, bytes *uint8) {
	var carg0 *C.GTestLogBuffer // in, none, converted
	var carg1 C.guint           // in, none, casted
	var carg2 *C.guint8         // in, transfer: none, C Pointers: 1, Name: guint8

	carg0 = (*C.GTestLogBuffer)(UnsafeTestLogBufferToGlibNone(tbuffer))
	carg1 = C.guint(nBytes)
	_ = bytes
	_ = carg2
	panic("unimplemented conversion of *uint8 (const guint8*) because of no basic converter found")

	C.g_test_log_buffer_push(carg0, carg1, carg2)
	runtime.KeepAlive(tbuffer)
	runtime.KeepAlive(nBytes)
	runtime.KeepAlive(bytes)
}

// TestSuite wraps GTestSuite
//
// An opaque structure representing a test suite.
type TestSuite struct {
	*testSuite
}

// testSuite is the struct that's finalized
type testSuite struct {
	native *C.GTestSuite
}

// UnsafeTestSuiteToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestSuite) instance() *C.GTestSuite {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestSuiteFromGlibBorrow is used to convert raw C.GTestSuite pointers to go. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibBorrow(p unsafe.Pointer) *TestSuite {
	if p == nil {
		return nil
	}
	return &TestSuite{&testSuite{(*C.GTestSuite)(p)}}
}

// UnsafeTestSuiteFromGlibNone is used to convert raw C.GTestSuite pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibNone(p unsafe.Pointer) *TestSuite {
	wrapped := UnsafeTestSuiteFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestSuite because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestSuiteFromGlibFull is used to convert raw C.GTestSuite pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibFull(p unsafe.Pointer) *TestSuite {
	wrapped := UnsafeTestSuiteFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testSuite,
		func (intern *testSuite) {
			C.g_test_suite_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestSuiteFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestSuite] is expected to work anymore.
func UnsafeTestSuiteFree(t *TestSuite) {
	C.g_test_suite_free(t.native)
}

// UnsafeTestSuiteToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestSuiteToGlibNone(t *TestSuite) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestSuiteToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestSuiteToGlibFull(t *TestSuite) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testSuite, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestSuite is invalid from here on
	return _p
}

// Add wraps g_test_suite_add
// 
// The function takes the following parameters:
// 
// 	- testCase *TestCase: a test case 
//
// Adds @test_case to @suite.
func (suite *TestSuite) Add(testCase *TestCase) {
	var carg0 *C.GTestSuite // in, none, converted
	var carg1 *C.GTestCase  // in, none, converted

	carg0 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))
	carg1 = (*C.GTestCase)(UnsafeTestCaseToGlibNone(testCase))

	C.g_test_suite_add(carg0, carg1)
	runtime.KeepAlive(suite)
	runtime.KeepAlive(testCase)
}

// AddSuite wraps g_test_suite_add_suite
// 
// The function takes the following parameters:
// 
// 	- nestedsuite *TestSuite: another test suite 
//
// Adds @nestedsuite to @suite.
func (suite *TestSuite) AddSuite(nestedsuite *TestSuite) {
	var carg0 *C.GTestSuite // in, none, converted
	var carg1 *C.GTestSuite // in, none, converted

	carg0 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))
	carg1 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(nestedsuite))

	C.g_test_suite_add_suite(carg0, carg1)
	runtime.KeepAlive(suite)
	runtime.KeepAlive(nestedsuite)
}

// TimeZone wraps GTimeZone
//
// A `GTimeZone` represents a time zone, at no particular point in time.
// 
// The `GTimeZone` struct is refcounted and immutable.
// 
// Each time zone has an identifier (for example, &#x2018;Europe/London&#x2019;) which is
// platform dependent. See [ctor@GLib.TimeZone.new] for information on the
// identifier formats. The identifier of a time zone can be retrieved using
// [method@GLib.TimeZone.get_identifier].
// 
// A time zone contains a number of intervals. Each interval has an abbreviation
// to describe it (for example, &#x2018;PDT&#x2019;), an offset to UTC and a flag indicating
// if the daylight savings time is in effect during that interval. A time zone
// always has at least one interval &#x2014; interval 0. Note that interval abbreviations
// are not the same as time zone identifiers (apart from &#x2018;UTC&#x2019;), and cannot be
// passed to [ctor@GLib.TimeZone.new].
// 
// Every UTC time is contained within exactly one interval, but a given
// local time may be contained within zero, one or two intervals (due to
// incontinuities associated with daylight savings time).
// 
// An interval may refer to a specific period of time (eg: the duration
// of daylight savings time during 2010) or it may refer to many periods
// of time that share the same properties (eg: all periods of daylight
// savings time).  It is also possible (usually for political reasons)
// that some properties (like the abbreviation) change between intervals
// without other properties changing.
type TimeZone struct {
	*timeZone
}

// timeZone is the struct that's finalized
type timeZone struct {
	native *C.GTimeZone
}

// UnsafeTimeZoneToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TimeZone) instance() *C.GTimeZone {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTimeZoneFromGlibBorrow is used to convert raw C.GTimeZone pointers to go. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibBorrow(p unsafe.Pointer) *TimeZone {
	if p == nil {
		return nil
	}
	return &TimeZone{&timeZone{(*C.GTimeZone)(p)}}
}

// UnsafeTimeZoneFromGlibNone is used to convert raw C.GTimeZone pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibNone(p unsafe.Pointer) *TimeZone {
	C.g_time_zone_ref((*C.GTimeZone)(p))
	wrapped := UnsafeTimeZoneFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.timeZone,
		func (intern *timeZone) {
			C.g_time_zone_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimeZoneFromGlibFull is used to convert raw C.GTimeZone pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibFull(p unsafe.Pointer) *TimeZone {
	wrapped := UnsafeTimeZoneFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.timeZone,
		func (intern *timeZone) {
			C.g_time_zone_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimeZoneRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [TimeZone.UnsafeTimeZoneUnref], then [TimeZone] will leak memory.
func UnsafeTimeZoneRef(t *TimeZone) {
	C.g_time_zone_ref(t.native)
}

// UnsafeTimeZoneUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TimeZone] is expected to work anymore.
func UnsafeTimeZoneUnref(t *TimeZone) {
	C.g_time_zone_unref(t.native)
}

// UnsafeTimeZoneToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTimeZoneToGlibNone(t *TimeZone) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTimeZoneToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTimeZoneToGlibFull(t *TimeZone) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.timeZone, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TimeZone is invalid from here on
	return _p
}

// NewTimeZoneIdentifier wraps g_time_zone_new_identifier
// 
// The function takes the following parameters:
// 
// 	- identifier string (nullable): a timezone identifier 
// 
// The function returns the following values:
// 
// 	- goret *TimeZone (nullable) 
//
// Creates a #GTimeZone corresponding to @identifier. If @identifier cannot be
// parsed or loaded, %NULL is returned.
// 
// @identifier can either be an RFC3339/ISO 8601 time offset or
// something that would pass as a valid value for the `TZ` environment
// variable (including %NULL).
// 
// In Windows, @identifier can also be the unlocalized name of a time
// zone for standard time, for example "Pacific Standard Time".
// 
// Valid RFC3339 time offsets are `"Z"` (for UTC) or
// `"&#xB1;hh:mm"`.  ISO 8601 additionally specifies
// `"&#xB1;hhmm"` and `"&#xB1;hh"`.  Offsets are
// time values to be added to Coordinated Universal Time (UTC) to get
// the local time.
// 
// In UNIX, the `TZ` environment variable typically corresponds
// to the name of a file in the zoneinfo database, an absolute path to a file
// somewhere else, or a string in
// "std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
// There  are  no spaces in the specification. The name of standard
// and daylight savings time zone must be three or more alphabetic
// characters. Offsets are time values to be added to local time to
// get Coordinated Universal Time (UTC) and should be
// `"[&#xB1;]hh[[:]mm[:ss]]"`.  Dates are either
// `"Jn"` (Julian day with n between 1 and 365, leap
// years not counted), `"n"` (zero-based Julian day
// with n between 0 and 365) or `"Mm.w.d"` (day d
// (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
// 0 is a Sunday).  Times are in local wall clock time, the default is
// 02:00:00.
// 
// In Windows, the "tzn[+|&#x2013;]hh[:mm[:ss]][dzn]" format is used, but also
// accepts POSIX format.  The Windows format uses US rules for all time
// zones; daylight savings time is 60 minutes behind the standard time
// with date and time of change taken from Pacific Standard Time.
// Offsets are time values to be added to the local time to get
// Coordinated Universal Time (UTC).
// 
// g_time_zone_new_local() calls this function with the value of the
// `TZ` environment variable. This function itself is independent of
// the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
// will be consulted to discover the correct time zone on UNIX and the
// registry will be consulted or GetTimeZoneInformation() will be used
// to get the local time zone on Windows.
// 
// If intervals are not available, only time zone rules from `TZ`
// environment variable or other means, then they will be computed
// from year 1900 to 2037.  If the maximum year for the rules is
// available and it is greater than 2037, then it will followed
// instead.
// 
// See
// [RFC3339 &#xA7;5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
// for a precise definition of valid RFC3339 time offsets
// (the `time-offset` expansion) and ISO 8601 for the
// full list of valid time offsets.  See
// [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
// for an explanation of the possible
// values of the `TZ` environment variable. See
// [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
// for the list of time zones on Windows.
// 
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneIdentifier(identifier string) *TimeZone {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var cret  *C.GTimeZone // return, full, converted, nullable

	if identifier != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(identifier)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_time_zone_new_identifier(carg1)
	runtime.KeepAlive(identifier)

	var goret *TimeZone

	if cret != nil {
		goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// NewTimeZoneLocal wraps g_time_zone_new_local
// 
// The function returns the following values:
// 
// 	- goret *TimeZone 
//
// Creates a #GTimeZone corresponding to local time.  The local time
// zone may change between invocations to this function; for example,
// if the system administrator changes it.
// 
// This is equivalent to calling g_time_zone_new() with the value of
// the `TZ` environment variable (including the possibility of %NULL).
// 
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneLocal() *TimeZone {
	var cret *C.GTimeZone // return, full, converted

	cret = C.g_time_zone_new_local()

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewTimeZoneOffset wraps g_time_zone_new_offset
// 
// The function takes the following parameters:
// 
// 	- seconds int32: offset to UTC, in seconds 
// 
// The function returns the following values:
// 
// 	- goret *TimeZone 
//
// Creates a #GTimeZone corresponding to the given constant offset from UTC,
// in seconds.
// 
// This is equivalent to calling g_time_zone_new() with a string in the form
// `[+|-]hh[:mm[:ss]]`.
// 
// It is possible for this function to fail if @seconds is too big (greater than
// 24 hours), in which case this function will return the UTC timezone for
// backwards compatibility. To detect failures like this, use
// g_time_zone_new_identifier() directly.
func NewTimeZoneOffset(seconds int32) *TimeZone {
	var carg1 C.gint32     // in, none, casted
	var cret  *C.GTimeZone // return, full, converted

	carg1 = C.gint32(seconds)

	cret = C.g_time_zone_new_offset(carg1)
	runtime.KeepAlive(seconds)

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewTimeZoneUtc wraps g_time_zone_new_utc
// 
// The function returns the following values:
// 
// 	- goret *TimeZone 
//
// Creates a #GTimeZone corresponding to UTC.
// 
// This is equivalent to calling g_time_zone_new() with a value like
// "Z", "UTC", "+00", etc.
// 
// You should release the return value by calling g_time_zone_unref()
// when you are done with it.
func NewTimeZoneUtc() *TimeZone {
	var cret *C.GTimeZone // return, full, converted

	cret = C.g_time_zone_new_utc()

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// FindInterval wraps g_time_zone_find_interval
// 
// The function takes the following parameters:
// 
// 	- typ TimeType: the #GTimeType of @time_ 
// 	- time int64: a number of seconds since January 1, 1970 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Finds an interval within @tz that corresponds to the given @time_.
// The meaning of @time_ depends on @type.
// 
// If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
// succeed (since universal time is monotonic and continuous).
// 
// Otherwise @time_ is treated as local time.  The distinction between
// %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
// the case that the given @time_ is ambiguous.  In Toronto, for example,
// 01:30 on November 7th 2010 occurred twice (once inside of daylight
// savings time and the next, an hour later, outside of daylight savings
// time).  In this case, the different value of @type would result in a
// different interval being returned.
// 
// It is still possible for this function to fail.  In Toronto, for
// example, 02:00 on March 14th 2010 does not exist (due to the leap
// forward to begin daylight savings time).  -1 is returned in that
// case.
func (tz *TimeZone) FindInterval(typ TimeType, time int64) int32 {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.GTimeType  // in, none, casted
	var carg2 C.gint64     // in, none, casted
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.GTimeType(typ)
	carg2 = C.gint64(time)

	cret = C.g_time_zone_find_interval(carg0, carg1, carg2)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(time)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetAbbreviation wraps g_time_zone_get_abbreviation
// 
// The function takes the following parameters:
// 
// 	- interval int32: an interval within the timezone 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Determines the time zone abbreviation to be used during a particular
// @interval of time in the time zone @tz.
// 
// For example, in Toronto this is currently "EST" during the winter
// months and "EDT" during the summer months when daylight savings time
// is in effect.
func (tz *TimeZone) GetAbbreviation(interval int32) string {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_get_abbreviation(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetIdentifier wraps g_time_zone_get_identifier
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
// If the identifier passed at construction time was not recognised, `UTC` will
// be returned. If it was %NULL, the identifier of the local timezone at
// construction time will be returned.
// 
// The identifier will be returned in the same format as provided at
// construction time: if provided as a time offset, that will be returned by
// this function.
func (tz *TimeZone) GetIdentifier() string {
	var carg0 *C.GTimeZone // in, none, converted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))

	cret = C.g_time_zone_get_identifier(carg0)
	runtime.KeepAlive(tz)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetOffset wraps g_time_zone_get_offset
// 
// The function takes the following parameters:
// 
// 	- interval int32: an interval within the timezone 
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Determines the offset to UTC in effect during a particular @interval
// of time in the time zone @tz.
// 
// The offset is the number of seconds that you add to UTC time to
// arrive at local time for @tz (ie: negative numbers for time zones
// west of GMT, positive numbers for east).
func (tz *TimeZone) GetOffset(interval int32) int32 {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_get_offset(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsDst wraps g_time_zone_is_dst
// 
// The function takes the following parameters:
// 
// 	- interval int32: an interval within the timezone 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if daylight savings time is in effect during a particular
// @interval of time in the time zone @tz.
func (tz *TimeZone) IsDst(interval int32) bool {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_is_dst(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Timer wraps GTimer
//
// `GTimer` records a start time, and counts microseconds elapsed since
// that time.
// 
// This is done somewhat differently on different platforms, and can be
// tricky to get exactly right, so `GTimer` provides a portable/convenient interface.
type Timer struct {
	*timer
}

// timer is the struct that's finalized
type timer struct {
	native *C.GTimer
}

// UnsafeTimerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *Timer) instance() *C.GTimer {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTimerFromGlibBorrow is used to convert raw C.GTimer pointers to go. This is used by the bindings internally.
func UnsafeTimerFromGlibBorrow(p unsafe.Pointer) *Timer {
	if p == nil {
		return nil
	}
	return &Timer{&timer{(*C.GTimer)(p)}}
}

// UnsafeTimerFromGlibNone is used to convert raw C.GTimer pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTimerFromGlibNone(p unsafe.Pointer) *Timer {
	wrapped := UnsafeTimerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Timer because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTimerFromGlibFull is used to convert raw C.GTimer pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTimerFromGlibFull(p unsafe.Pointer) *Timer {
	wrapped := UnsafeTimerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.timer,
		func (intern *timer) {
			C.g_timer_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimerDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Timer] is expected to work anymore.
func UnsafeTimerDestroy(t *Timer) {
	C.g_timer_destroy(t.native)
}

// UnsafeTimerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTimerToGlibNone(t *Timer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTimerToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTimerToGlibFull(t *Timer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.timer, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // Timer is invalid from here on
	return _p
}

// Continue wraps g_timer_continue
//
// Resumes a timer that has previously been stopped with
// g_timer_stop(). g_timer_stop() must be called before using this
// function.
func (timer *Timer) Continue() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_continue(carg0)
	runtime.KeepAlive(timer)
}

// Elapsed wraps g_timer_elapsed
// 
// The function takes the following parameters:
// 
// 	- microseconds *uint32: return location for the fractional part of seconds
//                elapsed, in microseconds (that is, the total number
//                of microseconds elapsed, modulo 1000000), or %NULL 
// 
// The function returns the following values:
// 
// 	- goret float64 
//
// If @timer has been started but not stopped, obtains the time since
// the timer was started. If @timer has been stopped, obtains the
// elapsed time between the time it was started and the time it was
// stopped. The return value is the number of seconds elapsed,
// including any fractional part. The @microseconds out parameter is
// essentially useless.
func (timer *Timer) Elapsed(microseconds *uint32) float64 {
	var carg0 *C.GTimer // in, none, converted
	var carg1 *C.gulong // in, transfer: none, C Pointers: 1, Name: gulong
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))
	_ = microseconds
	_ = carg1
	panic("unimplemented conversion of *uint32 (gulong*) because of no basic converter found")

	cret = C.g_timer_elapsed(carg0, carg1)
	runtime.KeepAlive(timer)
	runtime.KeepAlive(microseconds)

	var goret float64

	goret = float64(cret)

	return goret
}

// IsActive wraps g_timer_is_active
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Exposes whether the timer is currently active.
func (timer *Timer) IsActive() bool {
	var carg0 *C.GTimer  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	cret = C.g_timer_is_active(carg0)
	runtime.KeepAlive(timer)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Reset wraps g_timer_reset
//
// This function is useless; it's fine to call g_timer_start() on an
// already-started timer to reset the start time, so g_timer_reset()
// serves no purpose.
func (timer *Timer) Reset() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_reset(carg0)
	runtime.KeepAlive(timer)
}

// Start wraps g_timer_start
//
// Marks a start time, so that future calls to g_timer_elapsed() will
// report the time since g_timer_start() was called. g_timer_new()
// automatically marks the start time, so no need to call
// g_timer_start() immediately after creating the timer.
func (timer *Timer) Start() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_start(carg0)
	runtime.KeepAlive(timer)
}

// Stop wraps g_timer_stop
//
// Marks an end time, so calls to g_timer_elapsed() will return the
// difference between this end time and the start time.
func (timer *Timer) Stop() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_stop(carg0)
	runtime.KeepAlive(timer)
}

// TreeNode wraps GTreeNode
//
// An opaque type which identifies a specific node in a #GTree.
type TreeNode struct {
	*treeNode
}

// treeNode is the struct that's finalized
type treeNode struct {
	native *C.GTreeNode
}

// UnsafeTreeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TreeNode) instance() *C.GTreeNode {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTreeNodeFromGlibBorrow is used to convert raw C.GTreeNode pointers to go. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibBorrow(p unsafe.Pointer) *TreeNode {
	if p == nil {
		return nil
	}
	return &TreeNode{&treeNode{(*C.GTreeNode)(p)}}
}

// UnsafeTreeNodeFromGlibNone is used to convert raw C.GTreeNode pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibNone(p unsafe.Pointer) *TreeNode {
	wrapped := UnsafeTreeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TreeNode because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTreeNodeFromGlibFull is used to convert raw C.GTreeNode pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibFull(p unsafe.Pointer) *TreeNode {
	wrapped := UnsafeTreeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.treeNode,
		func (intern *treeNode) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTreeNodeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TreeNode] is expected to work anymore.
func UnsafeTreeNodeFree(t *TreeNode) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTreeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTreeNodeToGlibNone(t *TreeNode) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTreeNodeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTreeNodeToGlibFull(t *TreeNode) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.treeNode, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TreeNode is invalid from here on
	return _p
}

// Next wraps g_tree_node_next
// 
// The function returns the following values:
// 
// 	- goret *TreeNode (nullable) 
//
// Returns the next in-order node of the tree, or %NULL
// if the passed node was already the last one.
func (node *TreeNode) Next() *TreeNode {
	var carg0 *C.GTreeNode // in, none, converted
	var cret  *C.GTreeNode // return, none, converted, nullable

	carg0 = (*C.GTreeNode)(UnsafeTreeNodeToGlibNone(node))

	cret = C.g_tree_node_next(carg0)
	runtime.KeepAlive(node)

	var goret *TreeNode

	if cret != nil {
		goret = UnsafeTreeNodeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Previous wraps g_tree_node_previous
// 
// The function returns the following values:
// 
// 	- goret *TreeNode (nullable) 
//
// Returns the previous in-order node of the tree, or %NULL
// if the passed node was already the first one.
func (node *TreeNode) Previous() *TreeNode {
	var carg0 *C.GTreeNode // in, none, converted
	var cret  *C.GTreeNode // return, none, converted, nullable

	carg0 = (*C.GTreeNode)(UnsafeTreeNodeToGlibNone(node))

	cret = C.g_tree_node_previous(carg0)
	runtime.KeepAlive(node)

	var goret *TreeNode

	if cret != nil {
		goret = UnsafeTreeNodeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Uri wraps GUri
//
// The `GUri` type and related functions can be used to parse URIs into
// their components, and build valid URIs from individual components.
// 
// Since `GUri` only represents absolute URIs, all `GUri`s will have a
// URI scheme, so [method@GLib.Uri.get_scheme] will always return a non-`NULL`
// answer. Likewise, by definition, all URIs have a path component, so
// [method@GLib.Uri.get_path] will always return a non-`NULL` string (which may
// be empty).
// 
// If the URI string has an
// [&#x2018;authority&#x2019; component](https://tools.ietf.org/html/rfc3986#section-3) (that
// is, if the scheme is followed by `://` rather than just `:`), then the
// `GUri` will contain a hostname, and possibly a port and &#x2018;userinfo&#x2019;.
// Additionally, depending on how the `GUri` was constructed/parsed (for example,
// using the `G_URI_FLAGS_HAS_PASSWORD` and `G_URI_FLAGS_HAS_AUTH_PARAMS` flags),
// the userinfo may be split out into a username, password, and
// additional authorization-related parameters.
// 
// Normally, the components of a `GUri` will have all `%`-encoded
// characters decoded. However, if you construct/parse a `GUri` with
// `G_URI_FLAGS_ENCODED`, then the `%`-encoding will be preserved instead in
// the userinfo, path, and query fields (and in the host field if also
// created with `G_URI_FLAGS_NON_DNS`). In particular, this is necessary if
// the URI may contain binary data or non-UTF-8 text, or if decoding
// the components might change the interpretation of the URI.
// 
// For example, with the encoded flag:
// 
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_ENCODED, &amp;err);
// g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue");
// ```
// 
// While the default `%`-decoding behaviour would give:
// 
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_NONE, &amp;err);
// g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http://host/path?param=value");
// ```
// 
// During decoding, if an invalid UTF-8 string is encountered, parsing will fail
// with an error indicating the bad string location:
// 
// ```c
// g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fbad%3D%00alue", G_URI_FLAGS_NONE, &amp;err);
// g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);
// ```
// 
// You should pass `G_URI_FLAGS_ENCODED` or `G_URI_FLAGS_ENCODED_QUERY` if you
// need to handle that case manually. In particular, if the query string
// contains `=` characters that are `%`-encoded, you should let
// [func@GLib.Uri.parse_params] do the decoding once of the query.
// 
// `GUri` is immutable once constructed, and can safely be accessed from
// multiple threads. Its reference counting is atomic.
// 
// Note that the scope of `GUri` is to help manipulate URIs in various applications,
// following [RFC 3986](https://tools.ietf.org/html/rfc3986). In particular,
// it doesn't intend to cover web browser needs, and doesn&#x2019;t implement the
// [WHATWG URL](https://url.spec.whatwg.org/) standard. No APIs are provided to
// help prevent
// [homograph attacks](https://en.wikipedia.org/wiki/IDN_homograph_attack), so
// `GUri` is not suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
// 
// ## Relative and absolute URIs
// 
// As defined in [RFC 3986](https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be &#x2018;relative
// references&#x2019; (sometimes referred to as &#x2018;relative URIs&#x2019;) or &#x2018;URIs&#x2019; (for
// clarity, &#x2018;URIs&#x2019; are referred to in this documentation as
// &#x2018;absolute URIs&#x2019; &#x2014; although
// [in contrast to RFC 3986](https://tools.ietf.org/html/rfc3986#section-4.3),
// fragment identifiers are always allowed).
// 
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with `./` rather than `/`.
// 
// For example, a valid relative reference is `./path?query`,
// `/?query#fragment` or `//example.com`.
// 
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using [method@GLib.Uri.parse_relative].
// 
// For example, a valid absolute URI is `file:///home/bob` or
// `https://search.com?query=string`.
// 
// A `GUri` instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
// 
// ## Parsing URIs
// 
// The most minimalist APIs for parsing URIs are [func@GLib.Uri.split] and
// [func@GLib.Uri.split_with_user]. These split a URI into its component
// parts, and return the parts; the difference between the two is that
// [func@GLib.Uri.split] treats the &#x2018;userinfo&#x2019; component of the URI as a
// single element, while [func@GLib.Uri.split_with_user] can (depending on the
// [flags@GLib.UriFlags] you pass) treat it as containing a username, password,
// and authentication parameters. Alternatively, [func@GLib.Uri.split_network]
// can be used when you are only interested in the components that are
// needed to initiate a network connection to the service (scheme,
// host, and port).
// 
// [func@GLib.Uri.parse] is similar to [func@GLib.Uri.split], but instead of
// returning individual strings, it returns a `GUri` structure (and it requires
// that the URI be an absolute URI).
// 
// [func@GLib.Uri.resolve_relative] and [method@GLib.Uri.parse_relative] allow
// you to resolve a relative URI relative to a base URI.
// [func@GLib.Uri.resolve_relative] takes two strings and returns a string,
// and [method@GLib.Uri.parse_relative] takes a `GUri` and a string and returns a
// `GUri`.
// 
// All of the parsing functions take a [flags@GLib.UriFlags] argument describing
// exactly how to parse the URI; see the documentation for that type
// for more details on the specific flags that you can pass. If you
// need to choose different flags based on the type of URI, you can
// use [func@GLib.Uri.peek_scheme] on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
// 
// For example, you might want to use `G_URI_PARAMS_WWW_FORM` when parsing the
// params for a web URI, so compare the result of [func@GLib.Uri.peek_scheme]
// against `http` and `https`.
// 
// ## Building URIs
// 
// [func@GLib.Uri.join] and [func@GLib.Uri.join_with_user] can be used to construct
// valid URI strings from a set of component strings. They are the
// inverse of [func@GLib.Uri.split] and [func@GLib.Uri.split_with_user].
// 
// Similarly, [func@GLib.Uri.build] and [func@GLib.Uri.build_with_user] can be
// used to construct a `GUri` from a set of component strings.
// 
// As with the parsing functions, the building functions take a
// [flags@GLib.UriFlags] argument. In particular, it is important to keep in mind
// whether the URI components you are using are already `%`-encoded. If so,
// you must pass the `G_URI_FLAGS_ENCODED` flag.
// 
// ## `file://` URIs
// 
// Note that Windows and Unix both define special rules for parsing
// `file://` URIs (involving non-UTF-8 character sets on Unix, and the
// interpretation of path separators on Windows). `GUri` does not
// implement these rules. Use [func@GLib.filename_from_uri] and
// [func@GLib.filename_to_uri] if you want to properly convert between
// `file://` URIs and local filenames.
// 
// ## URI Equality
// 
// Note that there is no `g_uri_equal ()` function, because comparing
// URIs usefully requires scheme-specific knowledge that `GUri` does
// not have. `GUri` can help with normalization if you use the various
// encoded [flags@GLib.UriFlags] as well as `G_URI_FLAGS_SCHEME_NORMALIZE`
// however it is not comprehensive.
// For example, `data:,foo` and `data:;base64,Zm9v` resolve to the same
// thing according to the `data:` URI specification which GLib does not
// handle.
type Uri struct {
	*uri
}

// uri is the struct that's finalized
type uri struct {
	native *C.GUri
}

// UnsafeUriToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (u *Uri) instance() *C.GUri {
	if u == nil {
		return nil
	}
	return u.native
}

// UnsafeUriFromGlibBorrow is used to convert raw C.GUri pointers to go. This is used by the bindings internally.
func UnsafeUriFromGlibBorrow(p unsafe.Pointer) *Uri {
	if p == nil {
		return nil
	}
	return &Uri{&uri{(*C.GUri)(p)}}
}

// UnsafeUriFromGlibNone is used to convert raw C.GUri pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeUriFromGlibNone(p unsafe.Pointer) *Uri {
	C.g_uri_ref((*C.GUri)(p))
	wrapped := UnsafeUriFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.uri,
		func (intern *uri) {
			C.g_uri_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeUriFromGlibFull is used to convert raw C.GUri pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeUriFromGlibFull(p unsafe.Pointer) *Uri {
	wrapped := UnsafeUriFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.uri,
		func (intern *uri) {
			C.g_uri_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeUriRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Uri.UnsafeUriUnref], then [Uri] will leak memory.
func UnsafeUriRef(u *Uri) {
	C.g_uri_ref(u.native)
}

// UnsafeUriUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Uri] is expected to work anymore.
func UnsafeUriUnref(u *Uri) {
	C.g_uri_unref(u.native)
}

// UnsafeUriToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeUriToGlibNone(u *Uri) unsafe.Pointer {
	if u == nil {
		return nil
	}
	return unsafe.Pointer(u.native)
}

// UnsafeUriToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeUriToGlibFull(u *Uri) unsafe.Pointer {
	if u == nil {
		return nil
	}
	runtime.SetFinalizer(u.uri, nil)
	_p := unsafe.Pointer(u.native)
	u.native = nil // Uri is invalid from here on
	return _p
}

// UriBuild wraps g_uri_build
// 
// The function takes the following parameters:
// 
// 	- flags UriFlags: flags describing how to build the #GUri 
// 	- scheme string: the URI scheme 
// 	- userinfo string (nullable): the userinfo component, or %NULL 
// 	- host string (nullable): the host component, or %NULL 
// 	- port int32: the port, or `-1` 
// 	- path string: the path component 
// 	- query string (nullable): the query component, or %NULL 
// 	- fragment string (nullable): the fragment, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret *Uri 
//
// Creates a new #GUri from the given components according to @flags.
// 
// See also g_uri_build_with_user(), which allows specifying the
// components of the "userinfo" separately.
func UriBuild(flags UriFlags, scheme string, userinfo string, host string, port int32, path string, query string, fragment string) *Uri {
	var carg1 C.GUriFlags // in, none, casted
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 *C.gchar    // in, none, string, nullable-string
	var carg5 C.gint      // in, none, casted
	var carg6 *C.gchar    // in, none, string
	var carg7 *C.gchar    // in, none, string, nullable-string
	var carg8 *C.gchar    // in, none, string, nullable-string
	var cret  *C.GUri     // return, full, converted

	carg1 = C.GUriFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg2))
	if userinfo != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if host != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.gint(port)
	carg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg6))
	if query != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg7))
	}
	if fragment != "" {
		carg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg8))
	}

	cret = C.g_uri_build(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret *Uri

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// UriBuildWithUser wraps g_uri_build_with_user
// 
// The function takes the following parameters:
// 
// 	- flags UriFlags: flags describing how to build the #GUri 
// 	- scheme string: the URI scheme 
// 	- user string (nullable): the user component of the userinfo, or %NULL 
// 	- password string (nullable): the password component of the userinfo, or %NULL 
// 	- authParams string (nullable): the auth params of the userinfo, or %NULL 
// 	- host string (nullable): the host component, or %NULL 
// 	- port int32: the port, or `-1` 
// 	- path string: the path component 
// 	- query string (nullable): the query component, or %NULL 
// 	- fragment string (nullable): the fragment, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret *Uri 
//
// Creates a new #GUri from the given components according to @flags
// (%G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must be
// coherent with the passed values, in particular use `%`-encoded values with
// %G_URI_FLAGS_ENCODED.
// 
// In contrast to g_uri_build(), this allows specifying the components
// of the &#x2018;userinfo&#x2019; field separately. Note that @user must be non-%NULL
// if either @password or @auth_params is non-%NULL.
func UriBuildWithUser(flags UriFlags, scheme string, user string, password string, authParams string, host string, port int32, path string, query string, fragment string) *Uri {
	var carg1  C.GUriFlags // in, none, casted
	var carg2  *C.gchar    // in, none, string
	var carg3  *C.gchar    // in, none, string, nullable-string
	var carg4  *C.gchar    // in, none, string, nullable-string
	var carg5  *C.gchar    // in, none, string, nullable-string
	var carg6  *C.gchar    // in, none, string, nullable-string
	var carg7  C.gint      // in, none, casted
	var carg8  *C.gchar    // in, none, string
	var carg9  *C.gchar    // in, none, string, nullable-string
	var carg10 *C.gchar    // in, none, string, nullable-string
	var cret   *C.GUri     // return, full, converted

	carg1 = C.GUriFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg2))
	if user != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if password != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if authParams != "" {
		carg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if host != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg6))
	}
	carg7 = C.gint(port)
	carg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg8))
	if query != "" {
		carg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if fragment != "" {
		carg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg10))
	}

	cret = C.g_uri_build_with_user(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9, carg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret *Uri

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// UriErrorQuark wraps g_uri_error_quark
// 
// The function returns the following values:
// 
// 	- goret Quark 
func UriErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_uri_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// UriEscapeBytes wraps g_uri_escape_bytes
// 
// The function takes the following parameters:
// 
// 	- unescaped []uint8: the unescaped input data. 
// 	- reservedCharsAllowed string (nullable): a string of reserved
//   characters that are allowed to be used, or %NULL. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes arbitrary data for use in a URI.
// 
// Normally all characters that are not &#x2018;unreserved&#x2019; (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the &#x2018;reserved&#x2019; characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
// 
// Though technically incorrect, this will also allow escaping nul
// bytes as `%``00`.
func UriEscapeBytes(unescaped []uint8, reservedCharsAllowed string) string {
	var carg1 *C.guint8 // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize   // implicit
	var carg3 *C.char   // in, none, string, nullable-string
	var cret  *C.char   // return, full, string

	_ = unescaped
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")
	if reservedCharsAllowed != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_escape_bytes(carg1, carg2, carg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriEscapeString wraps g_uri_escape_string
// 
// The function takes the following parameters:
// 
// 	- unescaped string: the unescaped input string. 
// 	- reservedCharsAllowed string (nullable): a string of reserved
//   characters that are allowed to be used, or %NULL. 
// 	- allowUtf8 bool: %TRUE if the result can include UTF-8 characters. 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Escapes a string for use in a URI.
// 
// Normally all characters that are not "unreserved" (i.e. ASCII
// alphanumerical characters plus dash, dot, underscore and tilde) are
// escaped. But if you specify characters in @reserved_chars_allowed
// they are not escaped. This is useful for the "reserved" characters
// in the URI specification, since those are allowed unescaped in some
// portions of a URI.
func UriEscapeString(unescaped string, reservedCharsAllowed string, allowUtf8 bool) string {
	var carg1 *C.char    // in, none, string
	var carg2 *C.char    // in, none, string, nullable-string
	var carg3 C.gboolean // in
	var cret  *C.char    // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(unescaped)))
	defer C.free(unsafe.Pointer(carg1))
	if reservedCharsAllowed != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if allowUtf8 {
		carg3 = C.TRUE
	}

	cret = C.g_uri_escape_string(carg1, carg2, carg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)
	runtime.KeepAlive(allowUtf8)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriIsValid wraps g_uri_is_valid
// 
// The function takes the following parameters:
// 
// 	- uriString string: a string containing an absolute URI 
// 	- flags UriFlags: flags for parsing @uri_string 
// 
// The function returns the following values:
// 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_string according to @flags, to determine whether it is a valid
// [absolute URI](#relative-and-absolute-uris), i.e. it does not need to be resolved
// relative to another URI using g_uri_parse_relative().
// 
// If it&#x2019;s not a valid URI, an error is returned explaining how it&#x2019;s invalid.
// 
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags.
func UriIsValid(uriString string, flags UriFlags) (bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_is_valid(carg1, carg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriJoin wraps g_uri_join
// 
// The function takes the following parameters:
// 
// 	- flags UriFlags: flags describing how to build the URI string 
// 	- scheme string (nullable): the URI scheme, or %NULL 
// 	- userinfo string (nullable): the userinfo component, or %NULL 
// 	- host string (nullable): the host component, or %NULL 
// 	- port int32: the port, or `-1` 
// 	- path string: the path component 
// 	- query string (nullable): the query component, or %NULL 
// 	- fragment string (nullable): the fragment, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
// 
// When @host is present, @path must either be empty or begin with a slash (`/`)
// character. When @host is not present, @path cannot begin with two slash
// characters (`//`). See
// [RFC 3986, section 3](https://tools.ietf.org/html/rfc3986#section-3).
// 
// See also g_uri_join_with_user(), which allows specifying the
// components of the &#x2018;userinfo&#x2019; separately.
// 
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoin(flags UriFlags, scheme string, userinfo string, host string, port int32, path string, query string, fragment string) string {
	var carg1 C.GUriFlags // in, none, casted
	var carg2 *C.gchar    // in, none, string, nullable-string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 *C.gchar    // in, none, string, nullable-string
	var carg5 C.gint      // in, none, casted
	var carg6 *C.gchar    // in, none, string
	var carg7 *C.gchar    // in, none, string, nullable-string
	var carg8 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string

	carg1 = C.GUriFlags(flags)
	if scheme != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if userinfo != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if host != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.gint(port)
	carg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg6))
	if query != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg7))
	}
	if fragment != "" {
		carg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg8))
	}

	cret = C.g_uri_join(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriJoinWithUser wraps g_uri_join_with_user
// 
// The function takes the following parameters:
// 
// 	- flags UriFlags: flags describing how to build the URI string 
// 	- scheme string (nullable): the URI scheme, or %NULL 
// 	- user string (nullable): the user component of the userinfo, or %NULL 
// 	- password string (nullable): the password component of the userinfo, or
//   %NULL 
// 	- authParams string (nullable): the auth params of the userinfo, or
//   %NULL 
// 	- host string (nullable): the host component, or %NULL 
// 	- port int32: the port, or `-1` 
// 	- path string: the path component 
// 	- query string (nullable): the query component, or %NULL 
// 	- fragment string (nullable): the fragment, or %NULL 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Joins the given components together according to @flags to create
// an absolute URI string. @path may not be %NULL (though it may be the empty
// string).
// 
// In contrast to g_uri_join(), this allows specifying the components
// of the &#x2018;userinfo&#x2019; separately. It otherwise behaves the same.
// 
// %G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in @flags.
func UriJoinWithUser(flags UriFlags, scheme string, user string, password string, authParams string, host string, port int32, path string, query string, fragment string) string {
	var carg1  C.GUriFlags // in, none, casted
	var carg2  *C.gchar    // in, none, string, nullable-string
	var carg3  *C.gchar    // in, none, string, nullable-string
	var carg4  *C.gchar    // in, none, string, nullable-string
	var carg5  *C.gchar    // in, none, string, nullable-string
	var carg6  *C.gchar    // in, none, string, nullable-string
	var carg7  C.gint      // in, none, casted
	var carg8  *C.gchar    // in, none, string
	var carg9  *C.gchar    // in, none, string, nullable-string
	var carg10 *C.gchar    // in, none, string, nullable-string
	var cret   *C.gchar    // return, full, string

	carg1 = C.GUriFlags(flags)
	if scheme != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if user != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if password != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if authParams != "" {
		carg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if host != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg6))
	}
	carg7 = C.gint(port)
	carg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg8))
	if query != "" {
		carg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if fragment != "" {
		carg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg10))
	}

	cret = C.g_uri_join_with_user(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9, carg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriListExtractUris wraps g_uri_list_extract_uris
// 
// The function takes the following parameters:
// 
// 	- uriList string: an URI list 
// 
// The function returns the following values:
// 
// 	- goret []string 
//
// Splits an URI list conforming to the text/uri-list
// mime type defined in RFC 2483 into individual URIs,
// discarding any comments. The URIs are not validated.
func UriListExtractUris(uriList string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriList)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_list_extract_uris(carg1)
	runtime.KeepAlive(uriList)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// UriParse wraps g_uri_parse
// 
// The function takes the following parameters:
// 
// 	- uriString string: a string representing an absolute URI 
// 	- flags UriFlags: flags describing how to parse @uri_string 
// 
// The function returns the following values:
// 
// 	- goret *Uri 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_string according to @flags. If the result is not a
// valid [absolute URI](#relative-and-absolute-uris), it will be discarded, and an
// error returned.
func UriParse(uriString string, flags UriFlags) (*Uri, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  *C.GUri     // return, full, converted
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_parse(carg1, carg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var goret  *Uri
	var _goerr error

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriParseScheme wraps g_uri_parse_scheme
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
func UriParseScheme(uri string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_parse_scheme(carg1)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UriPeekScheme wraps g_uri_peek_scheme
// 
// The function takes the following parameters:
// 
// 	- uri string: a valid URI. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the scheme portion of a URI string.
// [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
// as:
// |[
// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
// ]|
// Common schemes include `file`, `https`, `svn+ssh`, etc.
// 
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
func UriPeekScheme(uri string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, none, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_peek_scheme(carg1)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UriResolveRelative wraps g_uri_resolve_relative
// 
// The function takes the following parameters:
// 
// 	- baseUriString string (nullable): a string representing a base URI 
// 	- uriRef string: a string representing a relative or absolute URI 
// 	- flags UriFlags: flags describing how to parse @uri_ref 
// 
// The function returns the following values:
// 
// 	- goret string 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_ref according to @flags and, if it is a
// [relative URI](#relative-and-absolute-uris), resolves it relative to
// @base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
// 
// (If @base_uri_string is %NULL, this just returns @uri_ref, or
// %NULL if @uri_ref is invalid or not absolute.)
func UriResolveRelative(baseUriString string, uriRef string, flags UriFlags) (string, error) {
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.GUriFlags // in, none, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	if baseUriString != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(baseUriString)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GUriFlags(flags)

	cret = C.g_uri_resolve_relative(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(baseUriString)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriSplit wraps g_uri_split
// 
// The function takes the following parameters:
// 
// 	- uriRef string: a string containing a relative or absolute URI 
// 	- flags UriFlags: flags for parsing @uri_ref 
// 
// The function returns the following values:
// 
// 	- scheme string (nullable): on return, contains
//    the scheme (converted to lowercase), or %NULL 
// 	- userinfo string (nullable): on return, contains
//    the userinfo, or %NULL 
// 	- host string (nullable): on return, contains the
//    host, or %NULL 
// 	- port int32: on return, contains the
//    port, or `-1` 
// 	- path string: on return, contains the
//    path 
// 	- query string (nullable): on return, contains the
//    query, or %NULL 
// 	- fragment string (nullable): on return, contains
//    the fragment, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_ref (which can be an
// [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
// 
// If @flags contains %G_URI_FLAGS_ENCODED, then `%`-encoded characters in
// @uri_ref will remain encoded in the output strings. (If not,
// then all such characters will be decoded.) Note that decoding will
// only work if the URI components are ASCII or UTF-8, so you will
// need to use %G_URI_FLAGS_ENCODED if they are not.
// 
// Note that the %G_URI_FLAGS_HAS_PASSWORD and
// %G_URI_FLAGS_HAS_AUTH_PARAMS @flags are ignored by g_uri_split(),
// since it always returns only the full userinfo; use
// g_uri_split_with_user() if you want it split up.
func UriSplit(uriRef string, flags UriFlags) (string, string, string, int32, string, string, string, bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var carg3 *C.gchar    // out, full, string, nullable-string
	var carg4 *C.gchar    // out, full, string, nullable-string
	var carg5 *C.gchar    // out, full, string, nullable-string
	var carg6 C.gint      // out, full, casted
	var carg7 *C.gchar    // out, full, string
	var carg8 *C.gchar    // out, full, string, nullable-string
	var carg9 *C.gchar    // out, full, string, nullable-string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split(carg1, carg2, &carg3, &carg4, &carg5, &carg6, &carg7, &carg8, &carg9, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var scheme   string
	var userinfo string
	var host     string
	var port     int32
	var path     string
	var query    string
	var fragment string
	var goret    bool
	var _goerr   error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		userinfo = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if carg5 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg5)))
		defer C.free(unsafe.Pointer(carg5))
	}
	port = int32(carg6)
	path = C.GoString((*C.char)(unsafe.Pointer(carg7)))
	defer C.free(unsafe.Pointer(carg7))
	if carg8 != nil {
		query = C.GoString((*C.char)(unsafe.Pointer(carg8)))
		defer C.free(unsafe.Pointer(carg8))
	}
	if carg9 != nil {
		fragment = C.GoString((*C.char)(unsafe.Pointer(carg9)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, userinfo, host, port, path, query, fragment, goret, _goerr
}

// UriSplitNetwork wraps g_uri_split_network
// 
// The function takes the following parameters:
// 
// 	- uriString string: a string containing an absolute URI 
// 	- flags UriFlags: flags for parsing @uri_string 
// 
// The function returns the following values:
// 
// 	- scheme string (nullable): on return, contains
//    the scheme (converted to lowercase), or %NULL 
// 	- host string (nullable): on return, contains the
//    host, or %NULL 
// 	- port int32: on return, contains the
//    port, or `-1` 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_string (which must be an [absolute URI](#relative-and-absolute-uris))
// according to @flags, and returns the pieces relevant to connecting to a host.
// See the documentation for g_uri_split() for more details; this is
// mostly a wrapper around that function with simpler arguments.
// However, it will return an error if @uri_string is a relative URI,
// or does not contain a hostname component.
func UriSplitNetwork(uriString string, flags UriFlags) (string, string, int32, bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var carg3 *C.gchar    // out, full, string, nullable-string
	var carg4 *C.gchar    // out, full, string, nullable-string
	var carg5 C.gint      // out, full, casted
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split_network(carg1, carg2, &carg3, &carg4, &carg5, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var scheme string
	var host   string
	var port   int32
	var goret  bool
	var _goerr error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	port = int32(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, host, port, goret, _goerr
}

// UriSplitWithUser wraps g_uri_split_with_user
// 
// The function takes the following parameters:
// 
// 	- uriRef string: a string containing a relative or absolute URI 
// 	- flags UriFlags: flags for parsing @uri_ref 
// 
// The function returns the following values:
// 
// 	- scheme string (nullable): on return, contains
//    the scheme (converted to lowercase), or %NULL 
// 	- user string (nullable): on return, contains
//    the user, or %NULL 
// 	- password string (nullable): on return, contains
//    the password, or %NULL 
// 	- authParams string (nullable): on return, contains
//    the auth_params, or %NULL 
// 	- host string (nullable): on return, contains the
//    host, or %NULL 
// 	- port int32: on return, contains the
//    port, or `-1` 
// 	- path string: on return, contains the
//    path 
// 	- query string (nullable): on return, contains the
//    query, or %NULL 
// 	- fragment string (nullable): on return, contains
//    the fragment, or %NULL 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_ref (which can be an
// [absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
// returns the pieces. Any component that doesn't appear in @uri_ref will be
// returned as %NULL (but note that all URIs always have a path component,
// though it may be the empty string).
// 
// See g_uri_split(), and the definition of #GUriFlags, for more
// information on the effect of @flags. Note that @password will only
// be parsed out if @flags contains %G_URI_FLAGS_HAS_PASSWORD, and
// @auth_params will only be parsed out if @flags contains
// %G_URI_FLAGS_HAS_AUTH_PARAMS.
func UriSplitWithUser(uriRef string, flags UriFlags) (string, string, string, string, string, int32, string, string, string, bool, error) {
	var carg1  *C.gchar    // in, none, string
	var carg2  C.GUriFlags // in, none, casted
	var carg3  *C.gchar    // out, full, string, nullable-string
	var carg4  *C.gchar    // out, full, string, nullable-string
	var carg5  *C.gchar    // out, full, string, nullable-string
	var carg6  *C.gchar    // out, full, string, nullable-string
	var carg7  *C.gchar    // out, full, string, nullable-string
	var carg8  C.gint      // out, full, casted
	var carg9  *C.gchar    // out, full, string
	var carg10 *C.gchar    // out, full, string, nullable-string
	var carg11 *C.gchar    // out, full, string, nullable-string
	var cret   C.gboolean  // return
	var _cerr  *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split_with_user(carg1, carg2, &carg3, &carg4, &carg5, &carg6, &carg7, &carg8, &carg9, &carg10, &carg11, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var scheme     string
	var user       string
	var password   string
	var authParams string
	var host       string
	var port       int32
	var path       string
	var query      string
	var fragment   string
	var goret      bool
	var _goerr     error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		user = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if carg5 != nil {
		password = C.GoString((*C.char)(unsafe.Pointer(carg5)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if carg6 != nil {
		authParams = C.GoString((*C.char)(unsafe.Pointer(carg6)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if carg7 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg7)))
		defer C.free(unsafe.Pointer(carg7))
	}
	port = int32(carg8)
	path = C.GoString((*C.char)(unsafe.Pointer(carg9)))
	defer C.free(unsafe.Pointer(carg9))
	if carg10 != nil {
		query = C.GoString((*C.char)(unsafe.Pointer(carg10)))
		defer C.free(unsafe.Pointer(carg10))
	}
	if carg11 != nil {
		fragment = C.GoString((*C.char)(unsafe.Pointer(carg11)))
		defer C.free(unsafe.Pointer(carg11))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, user, password, authParams, host, port, path, query, fragment, goret, _goerr
}

// UriUnescapeBytes wraps g_uri_unescape_bytes
// 
// The function takes the following parameters:
// 
// 	- escapedString string: A URI-escaped string 
// 	- length int: the length (in bytes) of @escaped_string to escape, or `-1` if it
//   is nul-terminated. 
// 	- illegalCharacters string (nullable): a string of illegal characters
//   not to be allowed, or %NULL. 
// 
// The function returns the following values:
// 
// 	- goret *Bytes 
// 	- _goerr error (nullable): an error 
//
// Unescapes a segment of an escaped string as binary data.
// 
// Note that in contrast to g_uri_unescape_string(), this does allow
// nul bytes to appear in the output.
// 
// If any of the characters in @illegal_characters appears as an escaped
// character in @escaped_string, then that is an error and %NULL will be
// returned. This is useful if you want to avoid for instance having a slash
// being expanded in an escaped path element, which might confuse pathname
// handling.
func UriUnescapeBytes(escapedString string, length int, illegalCharacters string) (*Bytes, error) {
	var carg1 *C.char   // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 *C.char   // in, none, string, nullable-string
	var cret  *C.GBytes // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)
	if illegalCharacters != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_unescape_bytes(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(length)
	runtime.KeepAlive(illegalCharacters)

	var goret  *Bytes
	var _goerr error

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriUnescapeSegment wraps g_uri_unescape_segment
// 
// The function takes the following parameters:
// 
// 	- escapedString string (nullable): A string, may be %NULL 
// 	- escapedStringEnd string (nullable): Pointer to end of @escaped_string,
//   may be %NULL 
// 	- illegalCharacters string (nullable): An optional string of illegal
//   characters not to be allowed, may be %NULL 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Unescapes a segment of an escaped string.
// 
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
// 
// Note: `NUL` byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
func UriUnescapeSegment(escapedString string, escapedStringEnd string, illegalCharacters string) string {
	var carg1 *C.char // in, none, string, nullable-string
	var carg2 *C.char // in, none, string, nullable-string
	var carg3 *C.char // in, none, string, nullable-string
	var cret  *C.char // return, full, string, nullable-string

	if escapedString != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if escapedStringEnd != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(escapedStringEnd)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if illegalCharacters != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_unescape_segment(carg1, carg2, carg3)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(escapedStringEnd)
	runtime.KeepAlive(illegalCharacters)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UriUnescapeString wraps g_uri_unescape_string
// 
// The function takes the following parameters:
// 
// 	- escapedString string: an escaped string to be unescaped. 
// 	- illegalCharacters string (nullable): a string of illegal characters
//   not to be allowed, or %NULL. 
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Unescapes a whole escaped string.
// 
// If any of the characters in @illegal_characters or the NUL
// character appears as an escaped character in @escaped_string, then
// that is an error and %NULL will be returned. This is useful if you
// want to avoid for instance having a slash being expanded in an
// escaped path element, which might confuse pathname handling.
func UriUnescapeString(escapedString string, illegalCharacters string) string {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string, nullable-string
	var cret  *C.char // return, full, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(carg1))
	if illegalCharacters != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_uri_unescape_string(carg1, carg2)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetAuthParams wraps g_uri_get_auth_params
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's authentication parameters, which may contain
// `%`-encoding, depending on the flags with which @uri was created.
// (If @uri was not created with %G_URI_FLAGS_HAS_AUTH_PARAMS then this will
// be %NULL.)
// 
// Depending on the URI scheme, g_uri_parse_params() may be useful for
// further parsing this information.
func (uri *Uri) GetAuthParams() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_auth_params(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFlags wraps g_uri_get_flags
// 
// The function returns the following values:
// 
// 	- goret UriFlags 
//
// Gets @uri's flags set upon construction.
func (uri *Uri) GetFlags() UriFlags {
	var carg0 *C.GUri     // in, none, converted
	var cret  C.GUriFlags // return, none, casted

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_flags(carg0)
	runtime.KeepAlive(uri)

	var goret UriFlags

	goret = UriFlags(cret)

	return goret
}

// GetFragment wraps g_uri_get_fragment
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's fragment, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (uri *Uri) GetFragment() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_fragment(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetHost wraps g_uri_get_host
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's host. This will never have `%`-encoded characters,
// unless it is non-UTF-8 (which can only be the case if @uri was
// created with %G_URI_FLAGS_NON_DNS).
// 
// If @uri contained an IPv6 address literal, this value will be just
// that address, without the brackets around it that are necessary in
// the string form of the URI. Note that in this case there may also
// be a scope ID attached to the address. Eg, `fe80::1234%``em1` (or
// `fe80::1234%``25em1` if the string is still encoded).
func (uri *Uri) GetHost() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_host(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPassword wraps g_uri_get_password
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's password, which may contain `%`-encoding, depending on
// the flags with which @uri was created. (If @uri was not created
// with %G_URI_FLAGS_HAS_PASSWORD then this will be %NULL.)
func (uri *Uri) GetPassword() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_password(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPath wraps g_uri_get_path
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @uri's path, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
func (uri *Uri) GetPath() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_path(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_uri_get_port
// 
// The function returns the following values:
// 
// 	- goret int32 
//
// Gets @uri's port.
func (uri *Uri) GetPort() int32 {
	var carg0 *C.GUri // in, none, converted
	var cret  C.gint  // return, none, casted

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_port(carg0)
	runtime.KeepAlive(uri)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetQuery wraps g_uri_get_query
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's query, which may contain `%`-encoding, depending on the
// flags with which @uri was created.
// 
// For queries consisting of a series of `name=value` parameters,
// #GUriParamsIter or g_uri_parse_params() may be useful.
func (uri *Uri) GetQuery() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_query(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetScheme wraps g_uri_get_scheme
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Gets @uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that @uri was created from.
func (uri *Uri) GetScheme() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_scheme(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUser wraps g_uri_get_user
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets the &#x2018;username&#x2019; component of @uri's userinfo, which may contain
// `%`-encoding, depending on the flags with which @uri was created.
// If @uri was not created with %G_URI_FLAGS_HAS_PASSWORD or
// %G_URI_FLAGS_HAS_AUTH_PARAMS, this is the same as g_uri_get_userinfo().
func (uri *Uri) GetUser() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_user(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUserinfo wraps g_uri_get_userinfo
// 
// The function returns the following values:
// 
// 	- goret string (nullable) 
//
// Gets @uri's userinfo, which may contain `%`-encoding, depending on
// the flags with which @uri was created.
func (uri *Uri) GetUserinfo() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_userinfo(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ParseRelative wraps g_uri_parse_relative
// 
// The function takes the following parameters:
// 
// 	- uriRef string: a string representing a relative or absolute URI 
// 	- flags UriFlags: flags describing how to parse @uri_ref 
// 
// The function returns the following values:
// 
// 	- goret *Uri 
// 	- _goerr error (nullable): an error 
//
// Parses @uri_ref according to @flags and, if it is a
// [relative URI](#relative-and-absolute-uris), resolves it relative to @base_uri.
// If the result is not a valid absolute URI, it will be discarded, and an error
// returned.
func (baseUri *Uri) ParseRelative(uriRef string, flags UriFlags) (*Uri, error) {
	var carg0 *C.GUri     // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  *C.GUri     // return, full, converted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(baseUri))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_parse_relative(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var goret  *Uri
	var _goerr error

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// String wraps g_uri_to_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a string representing @uri.
// 
// This is not guaranteed to return a string which is identical to the
// string that @uri was parsed from. However, if the source URI was
// syntactically correct (according to RFC 3986), and it was parsed
// with %G_URI_FLAGS_ENCODED, then g_uri_to_string() is guaranteed to return
// a string which is at least semantically equivalent to the source
// URI (according to RFC 3986).
// 
// If @uri might contain sensitive details, such as authentication parameters,
// or private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (uri *Uri) String() string {
	var carg0 *C.GUri // in, none, converted
	var cret  *C.char // return, full, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_to_string(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ToStringPartial wraps g_uri_to_string_partial
// 
// The function takes the following parameters:
// 
// 	- flags UriHideFlags: flags describing what parts of @uri to hide 
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a string representing @uri, subject to the options in
// @flags. See g_uri_to_string() and #GUriHideFlags for more details.
func (uri *Uri) ToStringPartial(flags UriHideFlags) string {
	var carg0 *C.GUri         // in, none, converted
	var carg1 C.GUriHideFlags // in, none, casted
	var cret  *C.char         // return, full, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))
	carg1 = C.GUriHideFlags(flags)

	cret = C.g_uri_to_string_partial(carg0, carg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(flags)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriParamsIter wraps GUriParamsIter
//
// Many URI schemes include one or more attribute/value pairs as part of the URI
// value. For example `scheme://server/path?query=string&amp;is=there` has two
// attributes &#x2013; `query=string` and `is=there` &#x2013; in its query part.
// 
// A #GUriParamsIter structure represents an iterator that can be used to
// iterate over the attribute/value pairs of a URI query string. #GUriParamsIter
// structures are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
type UriParamsIter struct {
	*uriParamsIter
}

// uriParamsIter is the struct that's finalized
type uriParamsIter struct {
	native *C.GUriParamsIter
}

// UnsafeUriParamsIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (u *UriParamsIter) instance() *C.GUriParamsIter {
	if u == nil {
		return nil
	}
	return u.native
}

// UnsafeUriParamsIterFromGlibBorrow is used to convert raw C.GUriParamsIter pointers to go. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibBorrow(p unsafe.Pointer) *UriParamsIter {
	if p == nil {
		return nil
	}
	return &UriParamsIter{&uriParamsIter{(*C.GUriParamsIter)(p)}}
}

// UnsafeUriParamsIterFromGlibNone is used to convert raw C.GUriParamsIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibNone(p unsafe.Pointer) *UriParamsIter {
	wrapped := UnsafeUriParamsIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to UriParamsIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeUriParamsIterFromGlibFull is used to convert raw C.GUriParamsIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibFull(p unsafe.Pointer) *UriParamsIter {
	wrapped := UnsafeUriParamsIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.uriParamsIter,
		func (intern *uriParamsIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeUriParamsIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [UriParamsIter] is expected to work anymore.
func UnsafeUriParamsIterFree(u *UriParamsIter) {
	C.free(unsafe.Pointer(u.native))
}

// UnsafeUriParamsIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeUriParamsIterToGlibNone(u *UriParamsIter) unsafe.Pointer {
	if u == nil {
		return nil
	}
	return unsafe.Pointer(u.native)
}

// UnsafeUriParamsIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeUriParamsIterToGlibFull(u *UriParamsIter) unsafe.Pointer {
	if u == nil {
		return nil
	}
	runtime.SetFinalizer(u.uriParamsIter, nil)
	_p := unsafe.Pointer(u.native)
	u.native = nil // UriParamsIter is invalid from here on
	return _p
}

// Init wraps g_uri_params_iter_init
// 
// The function takes the following parameters:
// 
// 	- params string: a `%`-encoded string containing `attribute=value`
//   parameters 
// 	- length int: the length of @params, or `-1` if it is nul-terminated 
// 	- separators string: the separator byte character set between parameters. (usually
//   `&amp;`, but sometimes `;` or both `&amp;;`). Note that this function works on
//   bytes not characters, so it can't be used to delimit UTF-8 strings for
//   anything but ASCII characters. You may pass an empty set, in which case
//   no splitting will occur. 
// 	- flags UriParamsFlags: flags to modify the way the parameters are handled. 
//
// Initializes an attribute/value pair iterator.
// 
// The iterator keeps pointers to the @params and @separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
// 
// If %G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
// string will be replaced with spaces in the output. For example, `foo=bar+baz`
// will give attribute `foo` with value `bar baz`. This is commonly used on the
// web (the `https` and `http` schemes only), but is deprecated in favour of
// the equivalent of encoding spaces as `%20`.
// 
// Unlike with g_uri_parse_params(), %G_URI_PARAMS_CASE_INSENSITIVE has no
// effect if passed to @flags for g_uri_params_iter_init(). The caller is
// responsible for doing their own case-insensitive comparisons.
// 
// |[&lt;!-- language="C" --&gt;
// GUriParamsIter iter;
// GError *error = NULL;
// gchar *unowned_attr, *unowned_value;
// 
// g_uri_params_iter_init (&amp;iter, "foo=bar&amp;baz=bar&amp;Foo=frob&amp;baz=bar2", -1, "&amp;", G_URI_PARAMS_NONE);
// while (g_uri_params_iter_next (&amp;iter, &amp;unowned_attr, &amp;unowned_value, &amp;error))
//   {
//     g_autofree gchar *attr = g_steal_pointer (&amp;unowned_attr);
//     g_autofree gchar *value = g_steal_pointer (&amp;unowned_value);
//     // do something with attr and value; this code will be called 4 times
//     // for the params string in this example: once with attr=foo and value=bar,
//     // then with baz/bar, then Foo/frob, then baz/bar2.
//   }
// if (error)
//   // handle parsing error
// ]|
func (iter *UriParamsIter) Init(params string, length int, separators string, flags UriParamsFlags) {
	var carg0 *C.GUriParamsIter // in, none, converted
	var carg1 *C.gchar          // in, none, string
	var carg2 C.gssize          // in, none, casted
	var carg3 *C.gchar          // in, none, string
	var carg4 C.GUriParamsFlags // in, none, casted

	carg0 = (*C.GUriParamsIter)(UnsafeUriParamsIterToGlibNone(iter))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(params)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.GUriParamsFlags(flags)

	C.g_uri_params_iter_init(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(params)
	runtime.KeepAlive(length)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)
}

// Next wraps g_uri_params_iter_next
// 
// The function returns the following values:
// 
// 	- attribute string (nullable): on return, contains
//     the attribute, or %NULL. 
// 	- value string (nullable): on return, contains
//     the value, or %NULL. 
// 	- goret bool 
// 	- _goerr error (nullable): an error 
//
// Advances @iter and retrieves the next attribute/value. %FALSE is returned if
// an error has occurred (in which case @error is set), or if the end of the
// iteration is reached (in which case @attribute and @value are set to %NULL
// and the iterator becomes invalid). If %TRUE is returned,
// g_uri_params_iter_next() may be called again to receive another
// attribute/value pair.
// 
// Note that the same @attribute may be returned multiple times, since URIs
// allow repeated attributes.
func (iter *UriParamsIter) Next() (string, string, bool, error) {
	var carg0 *C.GUriParamsIter // in, none, converted
	var carg1 *C.gchar          // out, full, string, nullable-string
	var carg2 *C.gchar          // out, full, string, nullable-string
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GUriParamsIter)(UnsafeUriParamsIterToGlibNone(iter))

	cret = C.g_uri_params_iter_next(carg0, &carg1, &carg2, &_cerr)
	runtime.KeepAlive(iter)

	var attribute string
	var value     string
	var goret     bool
	var _goerr    error

	if carg1 != nil {
		attribute = C.GoString((*C.char)(unsafe.Pointer(carg1)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if carg2 != nil {
		value = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return attribute, value, goret, _goerr
}

// VariantBuilder wraps GVariantBuilder
//
// A utility type for constructing container-type #GVariant instances.
// 
// This is an opaque structure and may only be accessed using the
// following functions.
// 
// #GVariantBuilder is not threadsafe in any way.  Do not attempt to
// access it from more than one thread.
type VariantBuilder struct {
	*variantBuilder
}

// variantBuilder is the struct that's finalized
type variantBuilder struct {
	native *C.GVariantBuilder
}

// UnsafeVariantBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantBuilder) instance() *C.GVariantBuilder {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantBuilderFromGlibBorrow is used to convert raw C.GVariantBuilder pointers to go. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibBorrow(p unsafe.Pointer) *VariantBuilder {
	if p == nil {
		return nil
	}
	return &VariantBuilder{&variantBuilder{(*C.GVariantBuilder)(p)}}
}

// UnsafeVariantBuilderFromGlibNone is used to convert raw C.GVariantBuilder pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibNone(p unsafe.Pointer) *VariantBuilder {
	C.g_variant_builder_ref((*C.GVariantBuilder)(p))
	wrapped := UnsafeVariantBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.variantBuilder,
		func (intern *variantBuilder) {
			C.g_variant_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantBuilderFromGlibFull is used to convert raw C.GVariantBuilder pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibFull(p unsafe.Pointer) *VariantBuilder {
	wrapped := UnsafeVariantBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantBuilder,
		func (intern *variantBuilder) {
			C.g_variant_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantBuilderRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [VariantBuilder.UnsafeVariantBuilderUnref], then [VariantBuilder] will leak memory.
func UnsafeVariantBuilderRef(v *VariantBuilder) {
	C.g_variant_builder_ref(v.native)
}

// UnsafeVariantBuilderUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantBuilder] is expected to work anymore.
func UnsafeVariantBuilderUnref(v *VariantBuilder) {
	C.g_variant_builder_unref(v.native)
}

// UnsafeVariantBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantBuilderToGlibNone(v *VariantBuilder) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantBuilderToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantBuilderToGlibFull(v *VariantBuilder) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantBuilder, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantBuilder is invalid from here on
	return _p
}

// NewVariantBuilder wraps g_variant_builder_new
// 
// The function takes the following parameters:
// 
// 	- typ *VariantType: a container type 
// 
// The function returns the following values:
// 
// 	- goret *VariantBuilder 
//
// Allocates and initialises a new #GVariantBuilder.
// 
// You should call g_variant_builder_unref() on the return value when it
// is no longer needed.  The memory will not be automatically freed by
// any other call.
// 
// In most cases it is easier to place a #GVariantBuilder directly on
// the stack of the calling function and initialise it with
// g_variant_builder_init_static().
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var carg1 *C.GVariantType    // in, none, converted
	var cret  *C.GVariantBuilder // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_builder_new(carg1)
	runtime.KeepAlive(typ)

	var goret *VariantBuilder

	goret = UnsafeVariantBuilderFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Close wraps g_variant_builder_close
//
// Closes the subcontainer inside the given @builder that was opened by
// the most recent call to g_variant_builder_open().
// 
// It is an error to call this function in any way that would create an
// inconsistent value to be constructed (ie: too few values added to the
// subcontainer).
func (builder *VariantBuilder) Close() {
	var carg0 *C.GVariantBuilder // in, none, converted

	carg0 = (*C.GVariantBuilder)(UnsafeVariantBuilderToGlibNone(builder))

	C.g_variant_builder_close(carg0)
	runtime.KeepAlive(builder)
}

// Open wraps g_variant_builder_open
// 
// The function takes the following parameters:
// 
// 	- typ *VariantType: the #GVariantType of the container 
//
// Opens a subcontainer inside the given @builder.  When done adding
// items to the subcontainer, g_variant_builder_close() must be called. @type
// is the type of the container: so to build a tuple of several values, @type
// must include the tuple itself.
// 
// It is an error to call this function in any way that would cause an
// inconsistent value to be constructed (ie: adding too many values or
// a value of an incorrect type).
// 
// Example of building a nested variant:
// |[&lt;!-- language="C" --&gt;
// GVariantBuilder builder;
// guint32 some_number = get_number ();
// g_autoptr (GHashTable) some_dict = get_dict ();
// GHashTableIter iter;
// const gchar *key;
// const GVariant *value;
// g_autoptr (GVariant) output = NULL;
// 
// g_variant_builder_init (&amp;builder, G_VARIANT_TYPE ("(ua{sv})"));
// g_variant_builder_add (&amp;builder, "u", some_number);
// g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("a{sv}"));
// 
// g_hash_table_iter_init (&amp;iter, some_dict);
// while (g_hash_table_iter_next (&amp;iter, (gpointer *) &amp;key, (gpointer *) &amp;value))
//   {
//     g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("{sv}"));
//     g_variant_builder_add (&amp;builder, "s", key);
//     g_variant_builder_add (&amp;builder, "v", value);
//     g_variant_builder_close (&amp;builder);
//   }
// 
// g_variant_builder_close (&amp;builder);
// 
// output = g_variant_builder_end (&amp;builder);
// ]|
func (builder *VariantBuilder) Open(typ *VariantType) {
	var carg0 *C.GVariantBuilder // in, none, converted
	var carg1 *C.GVariantType    // in, none, converted

	carg0 = (*C.GVariantBuilder)(UnsafeVariantBuilderToGlibNone(builder))
	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	C.g_variant_builder_open(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
}

// VariantDict wraps GVariantDict
//
// #GVariantDict is a mutable interface to #GVariant dictionaries.
// 
// It can be used for doing a sequence of dictionary lookups in an
// efficient way on an existing #GVariant dictionary or it can be used
// to construct new dictionaries with a hashtable-like interface.  It
// can also be used for taking existing dictionaries and modifying them
// in order to create new ones.
// 
// #GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
// dictionaries.
// 
// It is possible to use #GVariantDict allocated on the stack or on the
// heap.  When using a stack-allocated #GVariantDict, you begin with a
// call to g_variant_dict_init() and free the resources with a call to
// g_variant_dict_clear().
// 
// Heap-allocated #GVariantDict follows normal refcounting rules: you
// allocate it with g_variant_dict_new() and use g_variant_dict_ref()
// and g_variant_dict_unref().
// 
// g_variant_dict_end() is used to convert the #GVariantDict back into a
// dictionary-type #GVariant.  When used with stack-allocated instances,
// this also implicitly frees all associated memory, but for
// heap-allocated instances, you must still call g_variant_dict_unref()
// afterwards.
// 
// You will typically want to use a heap-allocated #GVariantDict when
// you expose it as part of an API.  For most other uses, the
// stack-allocated form will be more convenient.
// 
// Consider the following two examples that do the same thing in each
// style: take an existing dictionary and look up the "count" uint32
// key, adding 1 to it if it is found, or returning an error if the
// key is not found.  Each returns the new dictionary as a floating
// #GVariant.
// 
// ## Using a stack-allocated GVariantDict
// 
// |[&lt;!-- language="C" --&gt;
//   GVariant *
//   add_to_count (GVariant  *orig,
//                 GError   **error)
//   {
//     GVariantDict dict;
//     guint32 count;
// 
//     g_variant_dict_init (&amp;dict, orig);
//     if (!g_variant_dict_lookup (&amp;dict, "count", "u", &amp;count))
//       {
//         g_set_error (...);
//         g_variant_dict_clear (&amp;dict);
//         return NULL;
//       }
// 
//     g_variant_dict_insert (&amp;dict, "count", "u", count + 1);
// 
//     return g_variant_dict_end (&amp;dict);
//   }
// ]|
// 
// ## Using heap-allocated GVariantDict
// 
// |[&lt;!-- language="C" --&gt;
//   GVariant *
//   add_to_count (GVariant  *orig,
//                 GError   **error)
//   {
//     GVariantDict *dict;
//     GVariant *result;
//     guint32 count;
// 
//     dict = g_variant_dict_new (orig);
// 
//     if (g_variant_dict_lookup (dict, "count", "u", &amp;count))
//       {
//         g_variant_dict_insert (dict, "count", "u", count + 1);
//         result = g_variant_dict_end (dict);
//       }
//     else
//       {
//         g_set_error (...);
//         result = NULL;
//       }
// 
//     g_variant_dict_unref (dict);
// 
//     return result;
//   }
// ]|
type VariantDict struct {
	*variantDict
}

// variantDict is the struct that's finalized
type variantDict struct {
	native *C.GVariantDict
}

// UnsafeVariantDictToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantDict) instance() *C.GVariantDict {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantDictFromGlibBorrow is used to convert raw C.GVariantDict pointers to go. This is used by the bindings internally.
func UnsafeVariantDictFromGlibBorrow(p unsafe.Pointer) *VariantDict {
	if p == nil {
		return nil
	}
	return &VariantDict{&variantDict{(*C.GVariantDict)(p)}}
}

// UnsafeVariantDictFromGlibNone is used to convert raw C.GVariantDict pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantDictFromGlibNone(p unsafe.Pointer) *VariantDict {
	C.g_variant_dict_ref((*C.GVariantDict)(p))
	wrapped := UnsafeVariantDictFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.variantDict,
		func (intern *variantDict) {
			C.g_variant_dict_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantDictFromGlibFull is used to convert raw C.GVariantDict pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantDictFromGlibFull(p unsafe.Pointer) *VariantDict {
	wrapped := UnsafeVariantDictFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantDict,
		func (intern *variantDict) {
			C.g_variant_dict_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantDictRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [VariantDict.UnsafeVariantDictUnref], then [VariantDict] will leak memory.
func UnsafeVariantDictRef(v *VariantDict) {
	C.g_variant_dict_ref(v.native)
}

// UnsafeVariantDictUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantDict] is expected to work anymore.
func UnsafeVariantDictUnref(v *VariantDict) {
	C.g_variant_dict_unref(v.native)
}

// UnsafeVariantDictToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantDictToGlibNone(v *VariantDict) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantDictToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantDictToGlibFull(v *VariantDict) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantDict, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantDict is invalid from here on
	return _p
}

// Clear wraps g_variant_dict_clear
//
// Releases all memory associated with a #GVariantDict without freeing
// the #GVariantDict structure itself.
// 
// It typically only makes sense to do this on a stack-allocated
// #GVariantDict if you want to abort building the value part-way
// through.  This function need not be called if you call
// g_variant_dict_end() and it also doesn't need to be called on dicts
// allocated with g_variant_dict_new (see g_variant_dict_unref() for
// that).
// 
// It is valid to call this function on either an initialised
// #GVariantDict or one that was previously cleared by an earlier call
// to g_variant_dict_clear() but it is not valid to call this function
// on uninitialised memory.
func (dict *VariantDict) Clear() {
	var carg0 *C.GVariantDict // in, none, converted

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))

	C.g_variant_dict_clear(carg0)
	runtime.KeepAlive(dict)
}

// Contains wraps g_variant_dict_contains
// 
// The function takes the following parameters:
// 
// 	- key string: the key to look up in the dictionary 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @key exists in @dict.
func (dict *VariantDict) Contains(key string) bool {
	var carg0 *C.GVariantDict // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_dict_contains(carg0, carg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Remove wraps g_variant_dict_remove
// 
// The function takes the following parameters:
// 
// 	- key string: the key to remove 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Removes a key and its associated value from a #GVariantDict.
func (dict *VariantDict) Remove(key string) bool {
	var carg0 *C.GVariantDict // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_dict_remove(carg0, carg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantType wraps GVariantType
//
// A type in the [type@GLib.Variant] type system.
// 
// [type@GLib.Variant] types are represented as strings, but have a strict
// syntax described below. All [type@GLib.VariantType]s passed to GLib must be
// valid, and they are typically expected to be static (i.e. not provided by
// user input) as they determine how binary [type@GLib.Variant] data is
// interpreted.
// 
// To convert a static string to a [type@GLib.VariantType] in C, use the
// [func@GLib.VARIANT_TYPE] casting macro. When GLib is compiled with checks
// enabled, it will validate the type. To check if an arbitrary string is a
// valid [type@GLib.VariantType], use [func@GLib.VariantType.string_is_valid].
// 
// ## GVariant Type System
// 
// This section introduces the [type@GLib.Variant] type system. It is based, in
// large part, on the D-Bus type system, with two major changes and
// some minor lifting of restrictions. The
// [D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),
// therefore, provides a significant amount of
// information that is useful when working with [type@GLib.Variant].
// 
// The first major change with respect to the D-Bus type system is the
// introduction of maybe (or &#x2018;nullable&#x2019;) types.  Any type in [type@GLib.Variant]
// can be converted to a maybe type, in which case, `nothing` (or `null`)
// becomes a valid value.  Maybe types have been added by introducing the
// character `m` to type strings.
// 
// The second major change is that the [type@GLib.Variant] type system supports
// the concept of &#x2018;indefinite types&#x2019; &#x2014; types that are less specific than
// the normal types found in D-Bus.  For example, it is possible to speak
// of &#x2018;an array of any type&#x2019; in [type@GLib.Variant], where the D-Bus type system
// would require you to speak of &#x2018;an array of integers&#x2019; or &#x2018;an array of
// strings&#x2019;.  Indefinite types have been added by introducing the
// characters `*`, `?` and `r` to type strings.
// 
// Finally, all arbitrary restrictions relating to the complexity of
// types are lifted along with the restriction that dictionary entries
// may only appear nested inside of arrays.
// 
// Just as in D-Bus, [type@GLib.Variant] types are described with strings (&#x2018;type
// strings&#x2019;).  Subject to the differences mentioned above, these strings
// are of the same form as those found in D-Bus.  Note, however: D-Bus
// always works in terms of messages and therefore individual type
// strings appear nowhere in its interface.  Instead, &#x2018;signatures&#x2019;
// are a concatenation of the strings of the type of each argument in a
// message.  [type@GLib.Variant] deals with single values directly so
// [type@GLib.Variant] type strings always describe the type of exactly one
// value.  This means that a D-Bus signature string is generally not a valid
// [type@GLib.Variant] type string &#x2014; except in the case that it is the signature
// of a message containing exactly one argument.
// 
// An indefinite type is similar in spirit to what may be called an
// abstract type in other type systems.  No value can exist that has an
// indefinite type as its type, but values can exist that have types
// that are subtypes of indefinite types.  That is to say,
// [method@GLib.Variant.get_type] will never return an indefinite type, but
// calling [method@GLib.Variant.is_of_type] with an indefinite type may return
// true.  For example, you cannot have a value that represents &#x2018;an
// array of no particular type&#x2019;, but you can have an &#x2018;array of integers&#x2019;
// which certainly matches the type of &#x2018;an array of no particular type&#x2019;,
// since &#x2018;array of integers&#x2019; is a subtype of &#x2018;array of no particular
// type&#x2019;.
// 
// This is similar to how instances of abstract classes may not
// directly exist in other type systems, but instances of their
// non-abstract subtypes may.  For example, in GTK, no object that has
// the type of [`GtkWidget`](https://docs.gtk.org/gtk4/class.Widget.html) can
// exist (since `GtkWidget` is an abstract class), but a [`GtkWindow`](https://docs.gtk.org/gtk4/class.Window.html)
// can certainly be instantiated, and you would say that a `GtkWindow` is a
// `GtkWidget` (since `GtkWindow` is a subclass of `GtkWidget`).
// 
// Two types may not be compared by value; use [method@GLib.VariantType.equal]
// or [method@GLib.VariantType.is_subtype_of]  May be copied using
// [method@GLib.VariantType.copy] and freed using [method@GLib.VariantType.free].
// 
// ## GVariant Type Strings
// 
// A [type@GLib.Variant] type string can be any of the following:
// 
// - any basic type string (listed below)
// - `v`, `r` or `*`
// - one of the characters `a` or `m`, followed by another type string
// - the character `(`, followed by a concatenation of zero or more other
//   type strings, followed by the character `)`
// - the character `{`, followed by a basic type string (see below),
//   followed by another type string, followed by the character `}`
// 
// A basic type string describes a basic type (as per
// [method@GLib.VariantType.is_basic]) and is always a single character in
// length. The valid basic type strings are `b`, `y`, `n`, `q`, `i`, `u`, `x`,
// `t`, `h`, `d`, `s`, `o`, `g` and `?`.
// 
// The above definition is recursive to arbitrary depth. `aaaaai` and
// `(ui(nq((y)))s)` are both valid type strings, as is
// `a(aa(ui)(qna{ya(yd)}))`. In order to not hit memory limits,
// [type@GLib.Variant] imposes a limit on recursion depth of 65 nested
// containers. This is the limit in the D-Bus specification (64) plus one to
// allow a [`GDBusMessage`](../gio/class.DBusMessage.html) to be nested in
// a top-level tuple.
// 
// The meaning of each of the characters is as follows:
// 
// - `b`: the type string of `G_VARIANT_TYPE_BOOLEAN`; a boolean value.
// - `y`: the type string of `G_VARIANT_TYPE_BYTE`; a byte.
// - `n`: the type string of `G_VARIANT_TYPE_INT16`; a signed 16 bit integer.
// - `q`: the type string of `G_VARIANT_TYPE_UINT16`; an unsigned 16 bit integer.
// - `i`: the type string of `G_VARIANT_TYPE_INT32`; a signed 32 bit integer.
// - `u`: the type string of `G_VARIANT_TYPE_UINT32`; an unsigned 32 bit integer.
// - `x`: the type string of `G_VARIANT_TYPE_INT64`; a signed 64 bit integer.
// - `t`: the type string of `G_VARIANT_TYPE_UINT64`; an unsigned 64 bit integer.
// - `h`: the type string of `G_VARIANT_TYPE_HANDLE`; a signed 32 bit value
//   that, by convention, is used as an index into an array of file
//   descriptors that are sent alongside a D-Bus message.
// - `d`: the type string of `G_VARIANT_TYPE_DOUBLE`; a double precision
//   floating point value.
// - `s`: the type string of `G_VARIANT_TYPE_STRING`; a string.
// - `o`: the type string of `G_VARIANT_TYPE_OBJECT_PATH`; a string in the form
//   of a D-Bus object path.
// - `g`: the type string of `G_VARIANT_TYPE_SIGNATURE`; a string in the form of
//   a D-Bus type signature.
// - `?`: the type string of `G_VARIANT_TYPE_BASIC`; an indefinite type that
//   is a supertype of any of the basic types.
// - `v`: the type string of `G_VARIANT_TYPE_VARIANT`; a container type that
//   contain any other type of value.
// - `a`: used as a prefix on another type string to mean an array of that
//   type; the type string `ai`, for example, is the type of an array of
//   signed 32-bit integers.
// - `m`: used as a prefix on another type string to mean a &#x2018;maybe&#x2019;, or
//   &#x2018;nullable&#x2019;, version of that type; the type string `ms`, for example,
//   is the type of a value that maybe contains a string, or maybe contains
//   nothing.
// - `()`: used to enclose zero or more other concatenated type strings to
//   create a tuple type; the type string `(is)`, for example, is the type of
//   a pair of an integer and a string.
// - `r`: the type string of `G_VARIANT_TYPE_TUPLE`; an indefinite type that is
//   a supertype of any tuple type, regardless of the number of items.
// - `{}`: used to enclose a basic type string concatenated with another type
//   string to create a dictionary entry type, which usually appears inside of
//   an array to form a dictionary; the type string `a{sd}`, for example, is
//   the type of a dictionary that maps strings to double precision floating
//   point values.
// 
//   The first type (the basic type) is the key type and the second type is
//   the value type. The reason that the first type is restricted to being a
//   basic type is so that it can easily be hashed.
// - `*`: the type string of `G_VARIANT_TYPE_ANY`; the indefinite type that is
//   a supertype of all types.  Note that, as with all type strings, this
//   character represents exactly one type. It cannot be used inside of tuples
//   to mean &#x2018;any number of items&#x2019;.
// 
// Any type string of a container that contains an indefinite type is,
// itself, an indefinite type. For example, the type string `a*`
// (corresponding to `G_VARIANT_TYPE_ARRAY`) is an indefinite type
// that is a supertype of every array type. `(*s)` is a supertype
// of all tuples that contain exactly two items where the second
// item is a string.
// 
// `a{?*}` is an indefinite type that is a supertype of all arrays
// containing dictionary entries where the key is any basic type and
// the value is any type at all.  This is, by definition, a dictionary,
// so this type string corresponds to `G_VARIANT_TYPE_DICTIONARY`. Note
// that, due to the restriction that the key of a dictionary entry must
// be a basic type, `{**}` is not a valid type string.
type VariantType struct {
	*variantType
}

// variantType is the struct that's finalized
type variantType struct {
	native *C.GVariantType
}

// UnsafeVariantTypeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantType) instance() *C.GVariantType {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantTypeFromGlibBorrow is used to convert raw C.GVariantType pointers to go. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibBorrow(p unsafe.Pointer) *VariantType {
	if p == nil {
		return nil
	}
	return &VariantType{&variantType{(*C.GVariantType)(p)}}
}

// UnsafeVariantTypeFromGlibNone is used to convert raw C.GVariantType pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibNone(p unsafe.Pointer) *VariantType {
	wrapped := UnsafeVariantTypeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeVariantTypeFromGlibFull is used to convert raw C.GVariantType pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibFull(p unsafe.Pointer) *VariantType {
	wrapped := UnsafeVariantTypeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantType,
		func (intern *variantType) {
			C.g_variant_type_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantTypeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantType] is expected to work anymore.
func UnsafeVariantTypeFree(v *VariantType) {
	C.g_variant_type_free(v.native)
}

// UnsafeVariantTypeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantTypeToGlibNone(v *VariantType) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantTypeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantTypeToGlibFull(v *VariantType) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantType, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantType is invalid from here on
	return _p
}

// NewVariantType wraps g_variant_type_new
// 
// The function takes the following parameters:
// 
// 	- typeString string: a valid [GVariant type string](./struct.VariantType.html#gvariant-type-strings) 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Creates a new [type@GLib.VariantType] corresponding to the type string given
// by @type_string.
// 
// It is appropriate to call [method@GLib.VariantType.free] on the return value.
// 
// It is a programmer error to call this function with an invalid type
// string.  Use [func@GLib.VariantType.string_is_valid] if you are unsure.
func NewVariantType(typeString string) *VariantType {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_new(carg1)
	runtime.KeepAlive(typeString)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeArray wraps g_variant_type_new_array
// 
// The function takes the following parameters:
// 
// 	- element *VariantType: an element type 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Constructs the type corresponding to an array of elements of the
// type @type.
// 
// It is appropriate to call [method@GLib.VariantType.first] on the return value.
func NewVariantTypeArray(element *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(element))

	cret = C.g_variant_type_new_array(carg1)
	runtime.KeepAlive(element)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeDictEntry wraps g_variant_type_new_dict_entry
// 
// The function takes the following parameters:
// 
// 	- key *VariantType: a basic type to use for the key 
// 	- value *VariantType: a type to use for the value 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Constructs the type corresponding to a dictionary entry with a key
// of type @key and a value of type @value.
// 
// It is appropriate to call [method@GLib.VariantType.free] on the return value.
func NewVariantTypeDictEntry(key *VariantType, value *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var carg2 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(key))
	carg2 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(value))

	cret = C.g_variant_type_new_dict_entry(carg1, carg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeMaybe wraps g_variant_type_new_maybe
// 
// The function takes the following parameters:
// 
// 	- element *VariantType: an element type 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Constructs the type corresponding to a &#x2018;maybe&#x2019; instance containing
// type @type or `Nothing`.
// 
// It is appropriate to call [method@GLib.VariantType.free] on the return value.
func NewVariantTypeMaybe(element *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(element))

	cret = C.g_variant_type_new_maybe(carg1)
	runtime.KeepAlive(element)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeTuple wraps g_variant_type_new_tuple
// 
// The function takes the following parameters:
// 
// 	- items []*VariantType: an array of types, one for each item 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Constructs a new tuple type, from @items.
// 
// @length is the number of items in @items, or `-1` to indicate that
// @items is `NULL`-terminated.
// 
// It is appropriate to call [method@GLib.VariantType.free] on the return value.
func NewVariantTypeTuple(items []*VariantType) *VariantType {
	var carg1 **C.GVariantType // in, transfer: none, C Pointers: 2, Name: array[VariantType], array (inner GVariantType* (*typesystem.Record), length-by: carg2)
	var carg2 C.gint           // implicit
	var cret  *C.GVariantType  // return, full, converted

	_ = items
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []*VariantType (const GVariantType* const*) because of unimplemented: inner pointers in array")

	cret = C.g_variant_type_new_tuple(carg1, carg2)
	runtime.KeepAlive(items)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// VariantTypeChecked wraps g_variant_type_checked_
// 
// The function takes the following parameters:
// 
// 	- typeString string 
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
func VariantTypeChecked(typeString string) *VariantType {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_checked_(carg1)
	runtime.KeepAlive(typeString)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// VariantTypeStringGetDepth wraps g_variant_type_string_get_depth_
// 
// The function takes the following parameters:
// 
// 	- typeString string 
// 
// The function returns the following values:
// 
// 	- goret uint 
func VariantTypeStringGetDepth(typeString string) uint {
	var carg1 *C.gchar // in, none, string
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_string_get_depth_(carg1)
	runtime.KeepAlive(typeString)

	var goret uint

	goret = uint(cret)

	return goret
}

// VariantTypeStringIsValid wraps g_variant_type_string_is_valid
// 
// The function takes the following parameters:
// 
// 	- typeString string: a pointer to any string 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @type_string is a valid
// [GVariant type string](./struct.VariantType.html#gvariant-type-strings).
// 
// This call is equivalent to calling [func@GLib.VariantType.string_scan] and
// confirming that the following character is a nul terminator.
func VariantTypeStringIsValid(typeString string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_string_is_valid(carg1)
	runtime.KeepAlive(typeString)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantTypeStringScan wraps g_variant_type_string_scan
// 
// The function takes the following parameters:
// 
// 	- str string: a pointer to any string 
// 	- limit string (nullable): the end of @string 
// 
// The function returns the following values:
// 
// 	- endptr string: location to store the end pointer 
// 	- goret bool 
//
// Scan for a single complete and valid GVariant type string in @string.
// 
// The memory pointed to by @limit (or bytes beyond it) is never
// accessed.
// 
// If a valid type string is found, @endptr is updated to point to the
// first character past the end of the string that was found and %TRUE
// is returned.
// 
// If there is no valid type string starting at @string, or if the type
// string does not end before @limit then %FALSE is returned.
// 
// For the simple case of checking if a string is a valid type string,
// see [func@GLib.VariantType.string_is_valid].
func VariantTypeStringScan(str string, limit string) (string, bool) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string, nullable-string
	var carg3 *C.gchar   // out, full, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if limit != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(limit)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_variant_type_string_scan(carg1, carg2, &carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(limit)

	var endptr string
	var goret  bool

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return endptr, goret
}

// Copy wraps g_variant_type_copy
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Makes a copy of a [type@GLib.VariantType].
// 
// It is appropriate to call [method@GLib.VariantType.free] on the return value.
// @type may not be `NULL`.
func (typ *VariantType) Copy() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_copy(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// DupString wraps g_variant_type_dup_string
// 
// The function returns the following values:
// 
// 	- goret string 
//
// Returns a newly-allocated copy of the type string corresponding to @type.
// 
// The returned string is nul-terminated.  It is appropriate to call
// [func@GLib.free] on the return value.
func (typ *VariantType) DupString() string {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_dup_string(carg0)
	runtime.KeepAlive(typ)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Element wraps g_variant_type_element
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Determines the element type of an array or &#x2018;maybe&#x2019; type.
// 
// This function may only be used with array or &#x2018;maybe&#x2019; types.
func (typ *VariantType) Element() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_element(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// First wraps g_variant_type_first
// 
// The function returns the following values:
// 
// 	- goret *VariantType (nullable) 
//
// Determines the first item type of a tuple or dictionary entry
// type.
// 
// This function may only be used with tuple or dictionary entry types,
// but must not be used with the generic tuple type
// `G_VARIANT_TYPE_TUPLE`.
// 
// In the case of a dictionary entry type, this returns the type of
// the key.
// 
// `NULL` is returned in case of @type being `G_VARIANT_TYPE_UNIT`.
// 
// This call, together with [method@GLib.VariantType.next] provides an iterator
// interface over tuple and dictionary entry types.
func (typ *VariantType) First() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_first(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	if cret != nil {
		goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetStringLength wraps g_variant_type_get_string_length
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Returns the length of the type string corresponding to the given @type.
// 
// This function must be used to determine the valid extent of
// the memory region returned by [method@GLib.VariantType.peek_string].
func (typ *VariantType) GetStringLength() uint {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_get_string_length(carg0)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsArray wraps g_variant_type_is_array
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is an array type.
// 
// This is true if the type string for @type starts with an `a`.
// 
// This function returns true for any indefinite type for which every
// definite subtype is an array type &#x2014; `G_VARIANT_TYPE_ARRAY`, for
// example.
func (typ *VariantType) IsArray() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_array(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsBasic wraps g_variant_type_is_basic
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is a basic type.
// 
// Basic types are booleans, bytes, integers, doubles, strings, object
// paths and signatures.
// 
// Only a basic type may be used as the key of a dictionary entry.
// 
// This function returns `FALSE` for all indefinite types except
// `G_VARIANT_TYPE_BASIC`.
func (typ *VariantType) IsBasic() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_basic(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsContainer wraps g_variant_type_is_container
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is a container type.
// 
// Container types are any array, maybe, tuple, or dictionary
// entry types plus the variant type.
// 
// This function returns true for any indefinite type for which every
// definite subtype is a container &#x2014; `G_VARIANT_TYPE_ARRAY`, for
// example.
func (typ *VariantType) IsContainer() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_container(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsDefinite wraps g_variant_type_is_definite
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is definite (ie: not indefinite).
// 
// A type is definite if its type string does not contain any indefinite
// type characters (`*`, `?`, or `r`).
// 
// A [type@GLib.Variant] instance may not have an indefinite type, so calling
// this function on the result of [method@GLib.Variant.get_type] will always
// result in true being returned.  Calling this function on an
// indefinite type like `G_VARIANT_TYPE_ARRAY`, however, will result in
// `FALSE` being returned.
func (typ *VariantType) IsDefinite() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_definite(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsDictEntry wraps g_variant_type_is_dict_entry
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is a dictionary entry type.
// 
// This is true if the type string for @type starts with a `{`.
// 
// This function returns true for any indefinite type for which every
// definite subtype is a dictionary entry type &#x2014;
// `G_VARIANT_TYPE_DICT_ENTRY`, for example.
func (typ *VariantType) IsDictEntry() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_dict_entry(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMaybe wraps g_variant_type_is_maybe
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is a &#x2018;maybe&#x2019; type.
// 
// This is true if the type string for @type starts with an `m`.
// 
// This function returns true for any indefinite type for which every
// definite subtype is a &#x2018;maybe&#x2019; type &#x2014; `G_VARIANT_TYPE_MAYBE`, for
// example.
func (typ *VariantType) IsMaybe() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_maybe(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsSubtypeOf wraps g_variant_type_is_subtype_of
// 
// The function takes the following parameters:
// 
// 	- supertype *VariantType: type of potential supertype 
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Checks if @type is a subtype of @supertype.
// 
// This function returns true if @type is a subtype of @supertype.  All
// types are considered to be subtypes of themselves.  Aside from that,
// only indefinite types can have subtypes.
func (typ *VariantType) IsSubtypeOf(supertype *VariantType) bool {
	var carg0 *C.GVariantType // in, none, converted
	var carg1 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))
	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(supertype))

	cret = C.g_variant_type_is_subtype_of(carg0, carg1)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsTuple wraps g_variant_type_is_tuple
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is a tuple type.
// 
// This is true if the type string for @type starts with a `(` or if @type is
// `G_VARIANT_TYPE_TUPLE`.
// 
// This function returns true for any indefinite type for which every
// definite subtype is a tuple type &#x2014; `G_VARIANT_TYPE_TUPLE`, for
// example.
func (typ *VariantType) IsTuple() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_tuple(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsVariant wraps g_variant_type_is_variant
// 
// The function returns the following values:
// 
// 	- goret bool 
//
// Determines if the given @type is the variant type.
func (typ *VariantType) IsVariant() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_variant(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Key wraps g_variant_type_key
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Determines the key type of a dictionary entry type.
// 
// This function may only be used with a dictionary entry type.  Other
// than the additional restriction, this call is equivalent to
// [method@GLib.VariantType.first].
func (typ *VariantType) Key() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_key(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// NItems wraps g_variant_type_n_items
// 
// The function returns the following values:
// 
// 	- goret uint 
//
// Determines the number of items contained in a tuple or
// dictionary entry type.
// 
// This function may only be used with tuple or dictionary entry types,
// but must not be used with the generic tuple type
// `G_VARIANT_TYPE_TUPLE`.
// 
// In the case of a dictionary entry type, this function will always
// return `2`.
func (typ *VariantType) NItems() uint {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_n_items(carg0)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// Next wraps g_variant_type_next
// 
// The function returns the following values:
// 
// 	- goret *VariantType (nullable) 
//
// Determines the next item type of a tuple or dictionary entry
// type.
// 
// @type must be the result of a previous call to
// [method@GLib.VariantType.first] or [method@GLib.VariantType.next].
// 
// If called on the key type of a dictionary entry then this call
// returns the value type.  If called on the value type of a dictionary
// entry then this call returns `NULL`.
// 
// For tuples, `NULL` is returned when @type is the last item in the tuple.
func (typ *VariantType) Next() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_next(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	if cret != nil {
		goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Value wraps g_variant_type_value
// 
// The function returns the following values:
// 
// 	- goret *VariantType 
//
// Determines the value type of a dictionary entry type.
// 
// This function may only be used with a dictionary entry type.
func (typ *VariantType) Value() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_value(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

