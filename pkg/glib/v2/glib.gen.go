// Code generated by girgen for GLib-2. DO NOT EDIT.

package glib

import (
	"fmt"
	"log"
	"runtime"
	"strings"
	"unsafe"

	"github.com/go-gst/go-glib/pkg/core/userdata"
)

// #cgo pkg-config: glib-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
// extern GLogWriterOutput _goglib_glib2_LogWriterFunc(GLogLevelFlags, const GLogField*, gsize, gpointer);
// extern gboolean _goglib_glib2_SourceFunc(gpointer);
// extern void _goglib_glib2_ChildWatchFunc(GPid, gint, gpointer);
// extern void _goglib_glib2_LogFunc(const gchar*, GLogLevelFlags, const gchar*, gpointer);
// extern void destroyUserdata(gpointer);
import "C"


// ANALYZER_ANALYZING wraps G_ANALYZER_ANALYZING
// 
// see also https://docs.gtk.org/glib/const.ANALYZER_ANALYZING.html
const ANALYZER_ANALYZING = 1
// ASCII_DTOSTR_BUF_SIZE wraps G_ASCII_DTOSTR_BUF_SIZE
// 
// see also https://docs.gtk.org/glib/const.ASCII_DTOSTR_BUF_SIZE.html
//
const ASCII_DTOSTR_BUF_SIZE = 39
// BIG_ENDIAN wraps G_BIG_ENDIAN
// 
// see also https://docs.gtk.org/glib/const.BIG_ENDIAN.html
//
const BIG_ENDIAN = 4321
// C_STD_VERSION wraps G_C_STD_VERSION
// 
// see also https://docs.gtk.org/glib/const.C_STD_VERSION.html
//
const C_STD_VERSION = 199000
// DATALIST_FLAGS_MASK wraps G_DATALIST_FLAGS_MASK
// 
// see also https://docs.gtk.org/glib/const.DATALIST_FLAGS_MASK.html
//
const DATALIST_FLAGS_MASK = 3
// DATE_BAD_DAY wraps G_DATE_BAD_DAY
// 
// see also https://docs.gtk.org/glib/const.DATE_BAD_DAY.html
//
const DATE_BAD_DAY = 0
// DATE_BAD_JULIAN wraps G_DATE_BAD_JULIAN
// 
// see also https://docs.gtk.org/glib/const.DATE_BAD_JULIAN.html
//
const DATE_BAD_JULIAN = 0
// DATE_BAD_YEAR wraps G_DATE_BAD_YEAR
// 
// see also https://docs.gtk.org/glib/const.DATE_BAD_YEAR.html
//
const DATE_BAD_YEAR = 0
// DIR_SEPARATOR wraps G_DIR_SEPARATOR
// 
// see also https://docs.gtk.org/glib/const.DIR_SEPARATOR.html
//
const DIR_SEPARATOR = 47
// E wraps G_E
// 
// see also https://docs.gtk.org/glib/const.E.html
//
const E = 2.718282
// HAVE_GINT64 wraps G_HAVE_GINT64
// 
// see also https://docs.gtk.org/glib/const.HAVE_GINT64.html
const HAVE_GINT64 = 1
// HAVE_GNUC_VARARGS wraps G_HAVE_GNUC_VARARGS
// 
// see also https://docs.gtk.org/glib/const.HAVE_GNUC_VARARGS.html
const HAVE_GNUC_VARARGS = 1
// HAVE_GNUC_VISIBILITY wraps G_HAVE_GNUC_VISIBILITY
// 
// see also https://docs.gtk.org/glib/const.HAVE_GNUC_VISIBILITY.html
//
const HAVE_GNUC_VISIBILITY = 1
// HAVE_GROWING_STACK wraps G_HAVE_GROWING_STACK
// 
// see also https://docs.gtk.org/glib/const.HAVE_GROWING_STACK.html
const HAVE_GROWING_STACK = 0
// HAVE_ISO_VARARGS wraps G_HAVE_ISO_VARARGS
// 
// see also https://docs.gtk.org/glib/const.HAVE_ISO_VARARGS.html
const HAVE_ISO_VARARGS = 1
// HOOK_FLAG_USER_SHIFT wraps G_HOOK_FLAG_USER_SHIFT
// 
// see also https://docs.gtk.org/glib/const.HOOK_FLAG_USER_SHIFT.html
//
const HOOK_FLAG_USER_SHIFT = 4
// IEEE754_DOUBLE_BIAS wraps G_IEEE754_DOUBLE_BIAS
// 
// see also https://docs.gtk.org/glib/const.IEEE754_DOUBLE_BIAS.html
//
const IEEE754_DOUBLE_BIAS = 1023
// IEEE754_FLOAT_BIAS wraps G_IEEE754_FLOAT_BIAS
// 
// see also https://docs.gtk.org/glib/const.IEEE754_FLOAT_BIAS.html
//
const IEEE754_FLOAT_BIAS = 127
// LITTLE_ENDIAN wraps G_LITTLE_ENDIAN
// 
// see also https://docs.gtk.org/glib/const.LITTLE_ENDIAN.html
//
const LITTLE_ENDIAN = 1234
// LN10 wraps G_LN10
// 
// see also https://docs.gtk.org/glib/const.LN10.html
//
const LN10 = 2.302585
// LN2 wraps G_LN2
// 
// see also https://docs.gtk.org/glib/const.LN2.html
//
const LN2 = 0.693147
// LOG_2_BASE_10 wraps G_LOG_2_BASE_10
// 
// see also https://docs.gtk.org/glib/const.LOG_2_BASE_10.html
//
const LOG_2_BASE_10 = 0.301030
// LOG_DOMAIN wraps G_LOG_DOMAIN
// 
// see also https://docs.gtk.org/glib/const.LOG_DOMAIN.html
//
const LOG_DOMAIN = 0
// LOG_FATAL_MASK wraps G_LOG_FATAL_MASK
// 
// see also https://docs.gtk.org/glib/const.LOG_FATAL_MASK.html
//
const LOG_FATAL_MASK = 5
// LOG_LEVEL_USER_SHIFT wraps G_LOG_LEVEL_USER_SHIFT
// 
// see also https://docs.gtk.org/glib/const.LOG_LEVEL_USER_SHIFT.html
//
const LOG_LEVEL_USER_SHIFT = 8
// MAJOR_VERSION wraps GLIB_MAJOR_VERSION
// 
// see also https://docs.gtk.org/glib/const.MAJOR_VERSION.html
//
const MAJOR_VERSION = 2
// MAXINT16 wraps G_MAXINT16
// 
// see also https://docs.gtk.org/glib/const.MAXINT16.html
const MAXINT16 = 32767
// MAXINT32 wraps G_MAXINT32
// 
// see also https://docs.gtk.org/glib/const.MAXINT32.html
const MAXINT32 = 2147483647
// MAXINT64 wraps G_MAXINT64
// 
// see also https://docs.gtk.org/glib/const.MAXINT64.html
const MAXINT64 = 9223372036854775807
// MAXINT8 wraps G_MAXINT8
// 
// see also https://docs.gtk.org/glib/const.MAXINT8.html
const MAXINT8 = 127
// MAXUINT16 wraps G_MAXUINT16
// 
// see also https://docs.gtk.org/glib/const.MAXUINT16.html
const MAXUINT16 = 65535
// MAXUINT32 wraps G_MAXUINT32
// 
// see also https://docs.gtk.org/glib/const.MAXUINT32.html
const MAXUINT32 = 4294967295
// MAXUINT64 wraps G_MAXUINT64
// 
// see also https://docs.gtk.org/glib/const.MAXUINT64.html
const MAXUINT64 = 18446744073709551615
// MAXUINT8 wraps G_MAXUINT8
// 
// see also https://docs.gtk.org/glib/const.MAXUINT8.html
const MAXUINT8 = 255
// MICRO_VERSION wraps GLIB_MICRO_VERSION
// 
// see also https://docs.gtk.org/glib/const.MICRO_VERSION.html
//
const MICRO_VERSION = 1
// MININT16 wraps G_MININT16
// 
// see also https://docs.gtk.org/glib/const.MININT16.html
//
const MININT16 = -32768
// MININT32 wraps G_MININT32
// 
// see also https://docs.gtk.org/glib/const.MININT32.html
//
const MININT32 = -2147483648
// MININT64 wraps G_MININT64
// 
// see also https://docs.gtk.org/glib/const.MININT64.html
//
const MININT64 = -9223372036854775808
// MININT8 wraps G_MININT8
// 
// see also https://docs.gtk.org/glib/const.MININT8.html
//
const MININT8 = -128
// MINOR_VERSION wraps GLIB_MINOR_VERSION
// 
// see also https://docs.gtk.org/glib/const.MINOR_VERSION.html
//
const MINOR_VERSION = 85
// PDP_ENDIAN wraps G_PDP_ENDIAN
// 
// see also https://docs.gtk.org/glib/const.PDP_ENDIAN.html
//
const PDP_ENDIAN = 3412
// PI wraps G_PI
// 
// see also https://docs.gtk.org/glib/const.PI.html
//
const PI = 3.141593
// PI_2 wraps G_PI_2
// 
// see also https://docs.gtk.org/glib/const.PI_2.html
//
const PI_2 = 1.570796
// PI_4 wraps G_PI_4
// 
// see also https://docs.gtk.org/glib/const.PI_4.html
//
const PI_4 = 0.785398
// PRIORITY_DEFAULT wraps G_PRIORITY_DEFAULT
// 
// see also https://docs.gtk.org/glib/const.PRIORITY_DEFAULT.html
//
const PRIORITY_DEFAULT = 0
// PRIORITY_DEFAULT_IDLE wraps G_PRIORITY_DEFAULT_IDLE
// 
// see also https://docs.gtk.org/glib/const.PRIORITY_DEFAULT_IDLE.html
//
const PRIORITY_DEFAULT_IDLE = 200
// PRIORITY_HIGH wraps G_PRIORITY_HIGH
// 
// see also https://docs.gtk.org/glib/const.PRIORITY_HIGH.html
//
const PRIORITY_HIGH = -100
// PRIORITY_HIGH_IDLE wraps G_PRIORITY_HIGH_IDLE
// 
// see also https://docs.gtk.org/glib/const.PRIORITY_HIGH_IDLE.html
//
const PRIORITY_HIGH_IDLE = 100
// PRIORITY_LOW wraps G_PRIORITY_LOW
// 
// see also https://docs.gtk.org/glib/const.PRIORITY_LOW.html
//
const PRIORITY_LOW = 300
// REF_COUNT_INIT wraps G_REF_COUNT_INIT
// 
// see also https://docs.gtk.org/glib/const.REF_COUNT_INIT.html
//
const REF_COUNT_INIT = -1
// SEARCHPATH_SEPARATOR wraps G_SEARCHPATH_SEPARATOR
// 
// see also https://docs.gtk.org/glib/const.SEARCHPATH_SEPARATOR.html
//
const SEARCHPATH_SEPARATOR = 58
// SIZEOF_LONG wraps GLIB_SIZEOF_LONG
// 
// see also https://docs.gtk.org/glib/const.SIZEOF_LONG.html
const SIZEOF_LONG = 8
// SIZEOF_SIZE_T wraps GLIB_SIZEOF_SIZE_T
// 
// see also https://docs.gtk.org/glib/const.SIZEOF_SIZE_T.html
const SIZEOF_SIZE_T = 8
// SIZEOF_SSIZE_T wraps GLIB_SIZEOF_SSIZE_T
// 
// see also https://docs.gtk.org/glib/const.SIZEOF_SSIZE_T.html
const SIZEOF_SSIZE_T = 8
// SIZEOF_VOID_P wraps GLIB_SIZEOF_VOID_P
// 
// see also https://docs.gtk.org/glib/const.SIZEOF_VOID_P.html
const SIZEOF_VOID_P = 8
// SQRT2 wraps G_SQRT2
// 
// see also https://docs.gtk.org/glib/const.SQRT2.html
//
const SQRT2 = 1.414214
// SYSDEF_AF_INET wraps GLIB_SYSDEF_AF_INET
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_AF_INET.html
const SYSDEF_AF_INET = 2
// SYSDEF_AF_INET6 wraps GLIB_SYSDEF_AF_INET6
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_AF_INET6.html
const SYSDEF_AF_INET6 = 10
// SYSDEF_AF_UNIX wraps GLIB_SYSDEF_AF_UNIX
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_AF_UNIX.html
const SYSDEF_AF_UNIX = 1
// SYSDEF_MSG_DONTROUTE wraps GLIB_SYSDEF_MSG_DONTROUTE
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_MSG_DONTROUTE.html
const SYSDEF_MSG_DONTROUTE = 4
// SYSDEF_MSG_OOB wraps GLIB_SYSDEF_MSG_OOB
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_MSG_OOB.html
const SYSDEF_MSG_OOB = 1
// SYSDEF_MSG_PEEK wraps GLIB_SYSDEF_MSG_PEEK
// 
// see also https://docs.gtk.org/glib/const.SYSDEF_MSG_PEEK.html
const SYSDEF_MSG_PEEK = 2
// TIME_SPAN_DAY wraps G_TIME_SPAN_DAY
// 
// see also https://docs.gtk.org/glib/const.TIME_SPAN_DAY.html
//
const TIME_SPAN_DAY = 86400000000
// TIME_SPAN_HOUR wraps G_TIME_SPAN_HOUR
// 
// see also https://docs.gtk.org/glib/const.TIME_SPAN_HOUR.html
//
const TIME_SPAN_HOUR = 3600000000
// TIME_SPAN_MILLISECOND wraps G_TIME_SPAN_MILLISECOND
// 
// see also https://docs.gtk.org/glib/const.TIME_SPAN_MILLISECOND.html
//
const TIME_SPAN_MILLISECOND = 1000
// TIME_SPAN_MINUTE wraps G_TIME_SPAN_MINUTE
// 
// see also https://docs.gtk.org/glib/const.TIME_SPAN_MINUTE.html
//
const TIME_SPAN_MINUTE = 60000000
// TIME_SPAN_SECOND wraps G_TIME_SPAN_SECOND
// 
// see also https://docs.gtk.org/glib/const.TIME_SPAN_SECOND.html
//
const TIME_SPAN_SECOND = 1000000
// UNICHAR_MAX_DECOMPOSITION_LENGTH wraps G_UNICHAR_MAX_DECOMPOSITION_LENGTH
// 
// see also https://docs.gtk.org/glib/const.UNICHAR_MAX_DECOMPOSITION_LENGTH.html
//
const UNICHAR_MAX_DECOMPOSITION_LENGTH = 18
// USEC_PER_SEC wraps G_USEC_PER_SEC
// 
// see also https://docs.gtk.org/glib/const.USEC_PER_SEC.html
//
const USEC_PER_SEC = 1000000
// VA_COPY_AS_ARRAY wraps G_VA_COPY_AS_ARRAY
// 
// see also https://docs.gtk.org/glib/const.VA_COPY_AS_ARRAY.html
const VA_COPY_AS_ARRAY = 1
// VERSION_MIN_REQUIRED wraps GLIB_VERSION_MIN_REQUIRED
// 
// see also https://docs.gtk.org/glib/const.VERSION_MIN_REQUIRED.html
//
const VERSION_MIN_REQUIRED = 2
// WIN32_MSG_HANDLE wraps G_WIN32_MSG_HANDLE
// 
// see also https://docs.gtk.org/glib/const.WIN32_MSG_HANDLE.html
const WIN32_MSG_HANDLE = 19981206
// macro__has_attribute___noreturn__ wraps g_macro__has_attribute___noreturn__
// 
// see also https://docs.gtk.org/glib/const.macro__has_attribute___noreturn__.html
const macro__has_attribute___noreturn__ = 0
// macro__has_attribute_ifunc wraps g_macro__has_attribute_ifunc
// 
// see also https://docs.gtk.org/glib/const.macro__has_attribute_ifunc.html
const macro__has_attribute_ifunc = 0
// macro__has_attribute_no_sanitize_address wraps g_macro__has_attribute_no_sanitize_address
// 
// see also https://docs.gtk.org/glib/const.macro__has_attribute_no_sanitize_address.html
const macro__has_attribute_no_sanitize_address = 0
// Pid wraps GPid
// 
// see also https://docs.gtk.org/glib/alias.Pid.html
//
type Pid = int32
// Quark wraps GQuark
// 
// see also https://docs.gtk.org/glib/alias.Quark.html
//
type Quark = uint32
// RefString wraps GRefString
// 
// see also https://docs.gtk.org/glib/alias.RefString.html
//
type RefString = byte
// TimeSpan wraps GTimeSpan
// 
// see also https://docs.gtk.org/glib/alias.TimeSpan.html
//
type TimeSpan = int64
// BookmarkFileError wraps GBookmarkFileError
// 
// see also https://docs.gtk.org/glib/enum.BookmarkFileError.html
//
type BookmarkFileError C.int

const (
	// BookmarkFileErrorInvalidURI wraps G_BOOKMARK_FILE_ERROR_INVALID_URI
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#invalid_uri
	//
	BookmarkFileErrorInvalidURI BookmarkFileError = 0
	// BookmarkFileErrorInvalidValue wraps G_BOOKMARK_FILE_ERROR_INVALID_VALUE
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#invalid_value
	//
	BookmarkFileErrorInvalidValue BookmarkFileError = 1
	// BookmarkFileErrorAppNotRegistered wraps G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#app_not_registered
	//
	BookmarkFileErrorAppNotRegistered BookmarkFileError = 2
	// BookmarkFileErrorURINotFound wraps G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#uri_not_found
	//
	BookmarkFileErrorURINotFound BookmarkFileError = 3
	// BookmarkFileErrorRead wraps G_BOOKMARK_FILE_ERROR_READ
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#read
	//
	BookmarkFileErrorRead BookmarkFileError = 4
	// BookmarkFileErrorUnknownEncoding wraps G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#unknown_encoding
	//
	BookmarkFileErrorUnknownEncoding BookmarkFileError = 5
	// BookmarkFileErrorWrite wraps G_BOOKMARK_FILE_ERROR_WRITE
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#write
	//
	BookmarkFileErrorWrite BookmarkFileError = 6
	// BookmarkFileErrorFileNotFound wraps G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
	// 
	// see also https://docs.gtk.org/glib/flags.BookmarkFileError.html#file_not_found
	//
	BookmarkFileErrorFileNotFound BookmarkFileError = 7
)


func (e BookmarkFileError) String() string {
	switch e {
		case BookmarkFileErrorAppNotRegistered: return "BookmarkFileErrorAppNotRegistered"
		case BookmarkFileErrorFileNotFound: return "BookmarkFileErrorFileNotFound"
		case BookmarkFileErrorInvalidURI: return "BookmarkFileErrorInvalidURI"
		case BookmarkFileErrorInvalidValue: return "BookmarkFileErrorInvalidValue"
		case BookmarkFileErrorRead: return "BookmarkFileErrorRead"
		case BookmarkFileErrorURINotFound: return "BookmarkFileErrorURINotFound"
		case BookmarkFileErrorUnknownEncoding: return "BookmarkFileErrorUnknownEncoding"
		case BookmarkFileErrorWrite: return "BookmarkFileErrorWrite"
		default: return fmt.Sprintf("BookmarkFileError(%d)", e)
	}
}

// ChecksumType wraps GChecksumType
// 
// see also https://docs.gtk.org/glib/enum.ChecksumType.html
//
type ChecksumType C.int

const (
	// ChecksumMD5 wraps G_CHECKSUM_MD5
	// 
	// see also https://docs.gtk.org/glib/flags.ChecksumType.html#md5
	//
	ChecksumMD5 ChecksumType = 0
	// ChecksumSHA1 wraps G_CHECKSUM_SHA1
	// 
	// see also https://docs.gtk.org/glib/flags.ChecksumType.html#sha1
	//
	ChecksumSHA1 ChecksumType = 1
	// ChecksumSHA256 wraps G_CHECKSUM_SHA256
	// 
	// see also https://docs.gtk.org/glib/flags.ChecksumType.html#sha256
	//
	ChecksumSHA256 ChecksumType = 2
	// ChecksumSHA512 wraps G_CHECKSUM_SHA512
	// 
	// see also https://docs.gtk.org/glib/flags.ChecksumType.html#sha512
	//
	ChecksumSHA512 ChecksumType = 3
	// ChecksumSHA384 wraps G_CHECKSUM_SHA384
	// 
	// see also https://docs.gtk.org/glib/flags.ChecksumType.html#sha384
	//
	ChecksumSHA384 ChecksumType = 4
)


func (e ChecksumType) String() string {
	switch e {
		case ChecksumMD5: return "ChecksumMD5"
		case ChecksumSHA1: return "ChecksumSHA1"
		case ChecksumSHA256: return "ChecksumSHA256"
		case ChecksumSHA384: return "ChecksumSHA384"
		case ChecksumSHA512: return "ChecksumSHA512"
		default: return fmt.Sprintf("ChecksumType(%d)", e)
	}
}

// ConvertError wraps GConvertError
// 
// see also https://docs.gtk.org/glib/enum.ConvertError.html
//
type ConvertError C.int

const (
	// ConvertErrorNoConversion wraps G_CONVERT_ERROR_NO_CONVERSION
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#no_conversion
	//
	ConvertErrorNoConversion ConvertError = 0
	// ConvertErrorIllegalSequence wraps G_CONVERT_ERROR_ILLEGAL_SEQUENCE
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#illegal_sequence
	//
	ConvertErrorIllegalSequence ConvertError = 1
	// ConvertErrorFailed wraps G_CONVERT_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#failed
	//
	ConvertErrorFailed ConvertError = 2
	// ConvertErrorPartialInput wraps G_CONVERT_ERROR_PARTIAL_INPUT
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#partial_input
	//
	ConvertErrorPartialInput ConvertError = 3
	// ConvertErrorBadURI wraps G_CONVERT_ERROR_BAD_URI
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#bad_uri
	//
	ConvertErrorBadURI ConvertError = 4
	// ConvertErrorNotAbsolutePath wraps G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#not_absolute_path
	//
	ConvertErrorNotAbsolutePath ConvertError = 5
	// ConvertErrorNoMemory wraps G_CONVERT_ERROR_NO_MEMORY
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#no_memory
	//
	ConvertErrorNoMemory ConvertError = 6
	// ConvertErrorEmbeddedNul wraps G_CONVERT_ERROR_EMBEDDED_NUL
	// 
	// see also https://docs.gtk.org/glib/flags.ConvertError.html#embedded_nul
	//
	ConvertErrorEmbeddedNul ConvertError = 7
)


func (e ConvertError) String() string {
	switch e {
		case ConvertErrorBadURI: return "ConvertErrorBadURI"
		case ConvertErrorEmbeddedNul: return "ConvertErrorEmbeddedNul"
		case ConvertErrorFailed: return "ConvertErrorFailed"
		case ConvertErrorIllegalSequence: return "ConvertErrorIllegalSequence"
		case ConvertErrorNoConversion: return "ConvertErrorNoConversion"
		case ConvertErrorNoMemory: return "ConvertErrorNoMemory"
		case ConvertErrorNotAbsolutePath: return "ConvertErrorNotAbsolutePath"
		case ConvertErrorPartialInput: return "ConvertErrorPartialInput"
		default: return fmt.Sprintf("ConvertError(%d)", e)
	}
}

// ErrorType wraps GErrorType
// 
// see also https://docs.gtk.org/glib/enum.ErrorType.html
//
type ErrorType C.int

const (
	// ErrUnknown wraps G_ERR_UNKNOWN
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#unknown
	//
	ErrUnknown ErrorType = 0
	// ErrUnexpEOF wraps G_ERR_UNEXP_EOF
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#unexp_eof
	//
	ErrUnexpEOF ErrorType = 1
	// ErrUnexpEOFInString wraps G_ERR_UNEXP_EOF_IN_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#unexp_eof_in_string
	//
	ErrUnexpEOFInString ErrorType = 2
	// ErrUnexpEOFInComment wraps G_ERR_UNEXP_EOF_IN_COMMENT
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#unexp_eof_in_comment
	//
	ErrUnexpEOFInComment ErrorType = 3
	// ErrNonDigitInConst wraps G_ERR_NON_DIGIT_IN_CONST
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#non_digit_in_const
	//
	ErrNonDigitInConst ErrorType = 4
	// ErrDigitRadix wraps G_ERR_DIGIT_RADIX
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#digit_radix
	//
	ErrDigitRadix ErrorType = 5
	// ErrFloatRadix wraps G_ERR_FLOAT_RADIX
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#float_radix
	//
	ErrFloatRadix ErrorType = 6
	// ErrFloatMalformed wraps G_ERR_FLOAT_MALFORMED
	// 
	// see also https://docs.gtk.org/glib/flags.ErrorType.html#float_malformed
	//
	ErrFloatMalformed ErrorType = 7
)


func (e ErrorType) String() string {
	switch e {
		case ErrDigitRadix: return "ErrDigitRadix"
		case ErrFloatMalformed: return "ErrFloatMalformed"
		case ErrFloatRadix: return "ErrFloatRadix"
		case ErrNonDigitInConst: return "ErrNonDigitInConst"
		case ErrUnexpEOF: return "ErrUnexpEOF"
		case ErrUnexpEOFInComment: return "ErrUnexpEOFInComment"
		case ErrUnexpEOFInString: return "ErrUnexpEOFInString"
		case ErrUnknown: return "ErrUnknown"
		default: return fmt.Sprintf("ErrorType(%d)", e)
	}
}

// FileError wraps GFileError
// 
// see also https://docs.gtk.org/glib/enum.FileError.html
//
type FileError C.int

const (
	// FileErrorExist wraps G_FILE_ERROR_EXIST
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#exist
	//
	FileErrorExist FileError = 0
	// FileErrorIsdir wraps G_FILE_ERROR_ISDIR
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#isdir
	//
	FileErrorIsdir FileError = 1
	// FileErrorAcces wraps G_FILE_ERROR_ACCES
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#acces
	//
	FileErrorAcces FileError = 2
	// FileErrorNametoolong wraps G_FILE_ERROR_NAMETOOLONG
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nametoolong
	//
	FileErrorNametoolong FileError = 3
	// FileErrorNoent wraps G_FILE_ERROR_NOENT
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#noent
	//
	FileErrorNoent FileError = 4
	// FileErrorNotdir wraps G_FILE_ERROR_NOTDIR
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#notdir
	//
	FileErrorNotdir FileError = 5
	// FileErrorNxio wraps G_FILE_ERROR_NXIO
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nxio
	//
	FileErrorNxio FileError = 6
	// FileErrorNodev wraps G_FILE_ERROR_NODEV
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nodev
	//
	FileErrorNodev FileError = 7
	// FileErrorRofs wraps G_FILE_ERROR_ROFS
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#rofs
	//
	FileErrorRofs FileError = 8
	// FileErrorTxtbsy wraps G_FILE_ERROR_TXTBSY
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#txtbsy
	//
	FileErrorTxtbsy FileError = 9
	// FileErrorFault wraps G_FILE_ERROR_FAULT
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#fault
	//
	FileErrorFault FileError = 10
	// FileErrorLoop wraps G_FILE_ERROR_LOOP
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#loop
	//
	FileErrorLoop FileError = 11
	// FileErrorNospc wraps G_FILE_ERROR_NOSPC
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nospc
	//
	FileErrorNospc FileError = 12
	// FileErrorNomem wraps G_FILE_ERROR_NOMEM
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nomem
	//
	FileErrorNomem FileError = 13
	// FileErrorMfile wraps G_FILE_ERROR_MFILE
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#mfile
	//
	FileErrorMfile FileError = 14
	// FileErrorNfile wraps G_FILE_ERROR_NFILE
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nfile
	//
	FileErrorNfile FileError = 15
	// FileErrorBadf wraps G_FILE_ERROR_BADF
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#badf
	//
	FileErrorBadf FileError = 16
	// FileErrorInval wraps G_FILE_ERROR_INVAL
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#inval
	//
	FileErrorInval FileError = 17
	// FileErrorPipe wraps G_FILE_ERROR_PIPE
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#pipe
	//
	FileErrorPipe FileError = 18
	// FileErrorAgain wraps G_FILE_ERROR_AGAIN
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#again
	//
	FileErrorAgain FileError = 19
	// FileErrorIntr wraps G_FILE_ERROR_INTR
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#intr
	//
	FileErrorIntr FileError = 20
	// FileErrorIO wraps G_FILE_ERROR_IO
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#io
	//
	FileErrorIO FileError = 21
	// FileErrorPerm wraps G_FILE_ERROR_PERM
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#perm
	//
	FileErrorPerm FileError = 22
	// FileErrorNosys wraps G_FILE_ERROR_NOSYS
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#nosys
	//
	FileErrorNosys FileError = 23
	// FileErrorFailed wraps G_FILE_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.FileError.html#failed
	//
	FileErrorFailed FileError = 24
)


func (e FileError) String() string {
	switch e {
		case FileErrorAcces: return "FileErrorAcces"
		case FileErrorAgain: return "FileErrorAgain"
		case FileErrorBadf: return "FileErrorBadf"
		case FileErrorExist: return "FileErrorExist"
		case FileErrorFailed: return "FileErrorFailed"
		case FileErrorFault: return "FileErrorFault"
		case FileErrorIO: return "FileErrorIO"
		case FileErrorIntr: return "FileErrorIntr"
		case FileErrorInval: return "FileErrorInval"
		case FileErrorIsdir: return "FileErrorIsdir"
		case FileErrorLoop: return "FileErrorLoop"
		case FileErrorMfile: return "FileErrorMfile"
		case FileErrorNametoolong: return "FileErrorNametoolong"
		case FileErrorNfile: return "FileErrorNfile"
		case FileErrorNodev: return "FileErrorNodev"
		case FileErrorNoent: return "FileErrorNoent"
		case FileErrorNomem: return "FileErrorNomem"
		case FileErrorNospc: return "FileErrorNospc"
		case FileErrorNosys: return "FileErrorNosys"
		case FileErrorNotdir: return "FileErrorNotdir"
		case FileErrorNxio: return "FileErrorNxio"
		case FileErrorPerm: return "FileErrorPerm"
		case FileErrorPipe: return "FileErrorPipe"
		case FileErrorRofs: return "FileErrorRofs"
		case FileErrorTxtbsy: return "FileErrorTxtbsy"
		default: return fmt.Sprintf("FileError(%d)", e)
	}
}

// IOChannelError wraps GIOChannelError
// 
// see also https://docs.gtk.org/glib/enum.IOChannelError.html
//
type IOChannelError C.int

const (
	// IOChannelErrorFbig wraps G_IO_CHANNEL_ERROR_FBIG
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#fbig
	//
	IOChannelErrorFbig IOChannelError = 0
	// IOChannelErrorInval wraps G_IO_CHANNEL_ERROR_INVAL
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#inval
	//
	IOChannelErrorInval IOChannelError = 1
	// IOChannelErrorIO wraps G_IO_CHANNEL_ERROR_IO
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#io
	//
	IOChannelErrorIO IOChannelError = 2
	// IOChannelErrorIsdir wraps G_IO_CHANNEL_ERROR_ISDIR
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#isdir
	//
	IOChannelErrorIsdir IOChannelError = 3
	// IOChannelErrorNospc wraps G_IO_CHANNEL_ERROR_NOSPC
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#nospc
	//
	IOChannelErrorNospc IOChannelError = 4
	// IOChannelErrorNxio wraps G_IO_CHANNEL_ERROR_NXIO
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#nxio
	//
	IOChannelErrorNxio IOChannelError = 5
	// IOChannelErrorOverflow wraps G_IO_CHANNEL_ERROR_OVERFLOW
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#overflow
	//
	IOChannelErrorOverflow IOChannelError = 6
	// IOChannelErrorPipe wraps G_IO_CHANNEL_ERROR_PIPE
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#pipe
	//
	IOChannelErrorPipe IOChannelError = 7
	// IOChannelErrorFailed wraps G_IO_CHANNEL_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.IOChannelError.html#failed
	//
	IOChannelErrorFailed IOChannelError = 8
)


func (e IOChannelError) String() string {
	switch e {
		case IOChannelErrorFailed: return "IOChannelErrorFailed"
		case IOChannelErrorFbig: return "IOChannelErrorFbig"
		case IOChannelErrorIO: return "IOChannelErrorIO"
		case IOChannelErrorInval: return "IOChannelErrorInval"
		case IOChannelErrorIsdir: return "IOChannelErrorIsdir"
		case IOChannelErrorNospc: return "IOChannelErrorNospc"
		case IOChannelErrorNxio: return "IOChannelErrorNxio"
		case IOChannelErrorOverflow: return "IOChannelErrorOverflow"
		case IOChannelErrorPipe: return "IOChannelErrorPipe"
		default: return fmt.Sprintf("IOChannelError(%d)", e)
	}
}

// IOError wraps GIOError
// 
// see also https://docs.gtk.org/glib/enum.IOError.html
//
type IOError C.int

const (
	// IOErrorNone wraps G_IO_ERROR_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.IOError.html#none
	//
	IOErrorNone IOError = 0
	// IOErrorAgain wraps G_IO_ERROR_AGAIN
	// 
	// see also https://docs.gtk.org/glib/flags.IOError.html#again
	//
	IOErrorAgain IOError = 1
	// IOErrorInval wraps G_IO_ERROR_INVAL
	// 
	// see also https://docs.gtk.org/glib/flags.IOError.html#inval
	//
	IOErrorInval IOError = 2
	// IOErrorUnknown wraps G_IO_ERROR_UNKNOWN
	// 
	// see also https://docs.gtk.org/glib/flags.IOError.html#unknown
	//
	IOErrorUnknown IOError = 3
)


func (e IOError) String() string {
	switch e {
		case IOErrorAgain: return "IOErrorAgain"
		case IOErrorInval: return "IOErrorInval"
		case IOErrorNone: return "IOErrorNone"
		case IOErrorUnknown: return "IOErrorUnknown"
		default: return fmt.Sprintf("IOError(%d)", e)
	}
}

// IOStatus wraps GIOStatus
// 
// see also https://docs.gtk.org/glib/enum.IOStatus.html
//
type IOStatus C.int

const (
	// IOStatusError wraps G_IO_STATUS_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.IOStatus.html#error
	//
	IOStatusError IOStatus = 0
	// IOStatusNormal wraps G_IO_STATUS_NORMAL
	// 
	// see also https://docs.gtk.org/glib/flags.IOStatus.html#normal
	//
	IOStatusNormal IOStatus = 1
	// IOStatusEOF wraps G_IO_STATUS_EOF
	// 
	// see also https://docs.gtk.org/glib/flags.IOStatus.html#eof
	//
	IOStatusEOF IOStatus = 2
	// IOStatusAgain wraps G_IO_STATUS_AGAIN
	// 
	// see also https://docs.gtk.org/glib/flags.IOStatus.html#again
	//
	IOStatusAgain IOStatus = 3
)


func (e IOStatus) String() string {
	switch e {
		case IOStatusAgain: return "IOStatusAgain"
		case IOStatusEOF: return "IOStatusEOF"
		case IOStatusError: return "IOStatusError"
		case IOStatusNormal: return "IOStatusNormal"
		default: return fmt.Sprintf("IOStatus(%d)", e)
	}
}

// KeyFileError wraps GKeyFileError
// 
// see also https://docs.gtk.org/glib/enum.KeyFileError.html
//
type KeyFileError C.int

const (
	// KeyFileErrorUnknownEncoding wraps G_KEY_FILE_ERROR_UNKNOWN_ENCODING
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#unknown_encoding
	//
	KeyFileErrorUnknownEncoding KeyFileError = 0
	// KeyFileErrorParse wraps G_KEY_FILE_ERROR_PARSE
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#parse
	//
	KeyFileErrorParse KeyFileError = 1
	// KeyFileErrorNotFound wraps G_KEY_FILE_ERROR_NOT_FOUND
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#not_found
	//
	KeyFileErrorNotFound KeyFileError = 2
	// KeyFileErrorKeyNotFound wraps G_KEY_FILE_ERROR_KEY_NOT_FOUND
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#key_not_found
	//
	KeyFileErrorKeyNotFound KeyFileError = 3
	// KeyFileErrorGroupNotFound wraps G_KEY_FILE_ERROR_GROUP_NOT_FOUND
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#group_not_found
	//
	KeyFileErrorGroupNotFound KeyFileError = 4
	// KeyFileErrorInvalidValue wraps G_KEY_FILE_ERROR_INVALID_VALUE
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileError.html#invalid_value
	//
	KeyFileErrorInvalidValue KeyFileError = 5
)


func (e KeyFileError) String() string {
	switch e {
		case KeyFileErrorGroupNotFound: return "KeyFileErrorGroupNotFound"
		case KeyFileErrorInvalidValue: return "KeyFileErrorInvalidValue"
		case KeyFileErrorKeyNotFound: return "KeyFileErrorKeyNotFound"
		case KeyFileErrorNotFound: return "KeyFileErrorNotFound"
		case KeyFileErrorParse: return "KeyFileErrorParse"
		case KeyFileErrorUnknownEncoding: return "KeyFileErrorUnknownEncoding"
		default: return fmt.Sprintf("KeyFileError(%d)", e)
	}
}

// LogWriterOutput wraps GLogWriterOutput
// 
// see also https://docs.gtk.org/glib/enum.LogWriterOutput.html
//
type LogWriterOutput C.int

const (
	// LogWriterHandled wraps G_LOG_WRITER_HANDLED
	// 
	// see also https://docs.gtk.org/glib/flags.LogWriterOutput.html#handled
	//
	LogWriterHandled LogWriterOutput = 1
	// LogWriterUnhandled wraps G_LOG_WRITER_UNHANDLED
	// 
	// see also https://docs.gtk.org/glib/flags.LogWriterOutput.html#unhandled
	//
	LogWriterUnhandled LogWriterOutput = 0
)


func (e LogWriterOutput) String() string {
	switch e {
		case LogWriterHandled: return "LogWriterHandled"
		case LogWriterUnhandled: return "LogWriterUnhandled"
		default: return fmt.Sprintf("LogWriterOutput(%d)", e)
	}
}

// MarkupError wraps GMarkupError
// 
// see also https://docs.gtk.org/glib/enum.MarkupError.html
//
type MarkupError C.int

const (
	// MarkupErrorBadUTF8 wraps G_MARKUP_ERROR_BAD_UTF8
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#bad_utf8
	//
	MarkupErrorBadUTF8 MarkupError = 0
	// MarkupErrorEmpty wraps G_MARKUP_ERROR_EMPTY
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#empty
	//
	MarkupErrorEmpty MarkupError = 1
	// MarkupErrorParse wraps G_MARKUP_ERROR_PARSE
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#parse
	//
	MarkupErrorParse MarkupError = 2
	// MarkupErrorUnknownElement wraps G_MARKUP_ERROR_UNKNOWN_ELEMENT
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#unknown_element
	//
	MarkupErrorUnknownElement MarkupError = 3
	// MarkupErrorUnknownAttribute wraps G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#unknown_attribute
	//
	MarkupErrorUnknownAttribute MarkupError = 4
	// MarkupErrorInvalidContent wraps G_MARKUP_ERROR_INVALID_CONTENT
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#invalid_content
	//
	MarkupErrorInvalidContent MarkupError = 5
	// MarkupErrorMissingAttribute wraps G_MARKUP_ERROR_MISSING_ATTRIBUTE
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupError.html#missing_attribute
	//
	MarkupErrorMissingAttribute MarkupError = 6
)


func (e MarkupError) String() string {
	switch e {
		case MarkupErrorBadUTF8: return "MarkupErrorBadUTF8"
		case MarkupErrorEmpty: return "MarkupErrorEmpty"
		case MarkupErrorInvalidContent: return "MarkupErrorInvalidContent"
		case MarkupErrorMissingAttribute: return "MarkupErrorMissingAttribute"
		case MarkupErrorParse: return "MarkupErrorParse"
		case MarkupErrorUnknownAttribute: return "MarkupErrorUnknownAttribute"
		case MarkupErrorUnknownElement: return "MarkupErrorUnknownElement"
		default: return fmt.Sprintf("MarkupError(%d)", e)
	}
}

// NormalizeMode wraps GNormalizeMode
// 
// see also https://docs.gtk.org/glib/enum.NormalizeMode.html
//
type NormalizeMode C.int

const (
	// NormalizeDefault wraps G_NORMALIZE_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#default
	//
	NormalizeDefault NormalizeMode = 0
	// NormalizeNFD wraps G_NORMALIZE_NFD
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#nfd
	//
	NormalizeNFD NormalizeMode = 0
	// NormalizeDefaultCompose wraps G_NORMALIZE_DEFAULT_COMPOSE
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#default_compose
	//
	NormalizeDefaultCompose NormalizeMode = 1
	// NormalizeNFC wraps G_NORMALIZE_NFC
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#nfc
	//
	NormalizeNFC NormalizeMode = 1
	// NormalizeAll wraps G_NORMALIZE_ALL
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#all
	//
	NormalizeAll NormalizeMode = 2
	// NormalizeNFKD wraps G_NORMALIZE_NFKD
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#nfkd
	//
	NormalizeNFKD NormalizeMode = 2
	// NormalizeAllCompose wraps G_NORMALIZE_ALL_COMPOSE
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#all_compose
	//
	NormalizeAllCompose NormalizeMode = 3
	// NormalizeNFKC wraps G_NORMALIZE_NFKC
	// 
	// see also https://docs.gtk.org/glib/flags.NormalizeMode.html#nfkc
	//
	NormalizeNFKC NormalizeMode = 3
)


func (e NormalizeMode) String() string {
	switch e {
		case NormalizeAll: return "NormalizeAll"
		case NormalizeAllCompose: return "NormalizeAllCompose"
		case NormalizeDefault: return "NormalizeDefault"
		case NormalizeDefaultCompose: return "NormalizeDefaultCompose"
		default: return fmt.Sprintf("NormalizeMode(%d)", e)
	}
}

// NumberParserError wraps GNumberParserError
// 
// see also https://docs.gtk.org/glib/enum.NumberParserError.html
//
type NumberParserError C.int

const (
	// NumberParserErrorInvalid wraps G_NUMBER_PARSER_ERROR_INVALID
	// 
	// see also https://docs.gtk.org/glib/flags.NumberParserError.html#invalid
	//
	NumberParserErrorInvalid NumberParserError = 0
	// NumberParserErrorOutOfBounds wraps G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS
	// 
	// see also https://docs.gtk.org/glib/flags.NumberParserError.html#out_of_bounds
	//
	NumberParserErrorOutOfBounds NumberParserError = 1
)


func (e NumberParserError) String() string {
	switch e {
		case NumberParserErrorInvalid: return "NumberParserErrorInvalid"
		case NumberParserErrorOutOfBounds: return "NumberParserErrorOutOfBounds"
		default: return fmt.Sprintf("NumberParserError(%d)", e)
	}
}

// OnceStatus wraps GOnceStatus
// 
// see also https://docs.gtk.org/glib/enum.OnceStatus.html
//
type OnceStatus C.int

const (
	// OnceStatusNotcalled wraps G_ONCE_STATUS_NOTCALLED
	// 
	// see also https://docs.gtk.org/glib/flags.OnceStatus.html#notcalled
	//
	OnceStatusNotcalled OnceStatus = 0
	// OnceStatusProgress wraps G_ONCE_STATUS_PROGRESS
	// 
	// see also https://docs.gtk.org/glib/flags.OnceStatus.html#progress
	//
	OnceStatusProgress OnceStatus = 1
	// OnceStatusReady wraps G_ONCE_STATUS_READY
	// 
	// see also https://docs.gtk.org/glib/flags.OnceStatus.html#ready
	//
	OnceStatusReady OnceStatus = 2
)


func (e OnceStatus) String() string {
	switch e {
		case OnceStatusNotcalled: return "OnceStatusNotcalled"
		case OnceStatusProgress: return "OnceStatusProgress"
		case OnceStatusReady: return "OnceStatusReady"
		default: return fmt.Sprintf("OnceStatus(%d)", e)
	}
}

// OptionArg wraps GOptionArg
// 
// see also https://docs.gtk.org/glib/enum.OptionArg.html
//
type OptionArg C.int

const (
	// OptionArgNone wraps G_OPTION_ARG_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#none
	//
	OptionArgNone OptionArg = 0
	// OptionArgString wraps G_OPTION_ARG_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#string
	//
	OptionArgString OptionArg = 1
	// OptionArgInt wraps G_OPTION_ARG_INT
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#int
	//
	OptionArgInt OptionArg = 2
	// OptionArgCallback wraps G_OPTION_ARG_CALLBACK
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#callback
	//
	OptionArgCallback OptionArg = 3
	// OptionArgFilename wraps G_OPTION_ARG_FILENAME
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#filename
	//
	OptionArgFilename OptionArg = 4
	// OptionArgStringArray wraps G_OPTION_ARG_STRING_ARRAY
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#string_array
	//
	OptionArgStringArray OptionArg = 5
	// OptionArgFilenameArray wraps G_OPTION_ARG_FILENAME_ARRAY
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#filename_array
	//
	OptionArgFilenameArray OptionArg = 6
	// OptionArgDouble wraps G_OPTION_ARG_DOUBLE
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#double
	//
	OptionArgDouble OptionArg = 7
	// OptionArgInt64 wraps G_OPTION_ARG_INT64
	// 
	// see also https://docs.gtk.org/glib/flags.OptionArg.html#int64
	//
	OptionArgInt64 OptionArg = 8
)


func (e OptionArg) String() string {
	switch e {
		case OptionArgCallback: return "OptionArgCallback"
		case OptionArgDouble: return "OptionArgDouble"
		case OptionArgFilename: return "OptionArgFilename"
		case OptionArgFilenameArray: return "OptionArgFilenameArray"
		case OptionArgInt: return "OptionArgInt"
		case OptionArgInt64: return "OptionArgInt64"
		case OptionArgNone: return "OptionArgNone"
		case OptionArgString: return "OptionArgString"
		case OptionArgStringArray: return "OptionArgStringArray"
		default: return fmt.Sprintf("OptionArg(%d)", e)
	}
}

// OptionError wraps GOptionError
// 
// see also https://docs.gtk.org/glib/enum.OptionError.html
//
type OptionError C.int

const (
	// OptionErrorUnknownOption wraps G_OPTION_ERROR_UNKNOWN_OPTION
	// 
	// see also https://docs.gtk.org/glib/flags.OptionError.html#unknown_option
	//
	OptionErrorUnknownOption OptionError = 0
	// OptionErrorBadValue wraps G_OPTION_ERROR_BAD_VALUE
	// 
	// see also https://docs.gtk.org/glib/flags.OptionError.html#bad_value
	//
	OptionErrorBadValue OptionError = 1
	// OptionErrorFailed wraps G_OPTION_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.OptionError.html#failed
	//
	OptionErrorFailed OptionError = 2
)


func (e OptionError) String() string {
	switch e {
		case OptionErrorBadValue: return "OptionErrorBadValue"
		case OptionErrorFailed: return "OptionErrorFailed"
		case OptionErrorUnknownOption: return "OptionErrorUnknownOption"
		default: return fmt.Sprintf("OptionError(%d)", e)
	}
}

// RegexError wraps GRegexError
// 
// see also https://docs.gtk.org/glib/enum.RegexError.html
//
type RegexError C.int

const (
	// RegexErrorCompile wraps G_REGEX_ERROR_COMPILE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#compile
	//
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize wraps G_REGEX_ERROR_OPTIMIZE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#optimize
	//
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace wraps G_REGEX_ERROR_REPLACE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#replace
	//
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch wraps G_REGEX_ERROR_MATCH
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#match
	//
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal wraps G_REGEX_ERROR_INTERNAL
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#internal
	//
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash wraps G_REGEX_ERROR_STRAY_BACKSLASH
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#stray_backslash
	//
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar wraps G_REGEX_ERROR_MISSING_CONTROL_CHAR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_control_char
	//
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape wraps G_REGEX_ERROR_UNRECOGNIZED_ESCAPE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unrecognized_escape
	//
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder wraps G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#quantifiers_out_of_order
	//
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig wraps G_REGEX_ERROR_QUANTIFIER_TOO_BIG
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#quantifier_too_big
	//
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass wraps G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unterminated_character_class
	//
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass wraps G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_escape_in_character_class
	//
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder wraps G_REGEX_ERROR_RANGE_OUT_OF_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#range_out_of_order
	//
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat wraps G_REGEX_ERROR_NOTHING_TO_REPEAT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#nothing_to_repeat
	//
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter wraps G_REGEX_ERROR_UNRECOGNIZED_CHARACTER
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unrecognized_character
	//
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass wraps G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#posix_named_class_outside_class
	//
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis wraps G_REGEX_ERROR_UNMATCHED_PARENTHESIS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unmatched_parenthesis
	//
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference wraps G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#inexistent_subpattern_reference
	//
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment wraps G_REGEX_ERROR_UNTERMINATED_COMMENT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unterminated_comment
	//
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge wraps G_REGEX_ERROR_EXPRESSION_TOO_LARGE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#expression_too_large
	//
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError wraps G_REGEX_ERROR_MEMORY_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#memory_error
	//
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind wraps G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#variable_length_lookbehind
	//
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition wraps G_REGEX_ERROR_MALFORMED_CONDITION
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#malformed_condition
	//
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches wraps G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#too_many_conditional_branches
	//
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected wraps G_REGEX_ERROR_ASSERTION_EXPECTED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#assertion_expected
	//
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName wraps G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unknown_posix_class_name
	//
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported wraps G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#posix_collating_elements_not_supported
	//
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge wraps G_REGEX_ERROR_HEX_CODE_TOO_LARGE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#hex_code_too_large
	//
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition wraps G_REGEX_ERROR_INVALID_CONDITION
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_condition
	//
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind wraps G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#single_byte_match_in_lookbehind
	//
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop wraps G_REGEX_ERROR_INFINITE_LOOP
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#infinite_loop
	//
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator wraps G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_subpattern_name_terminator
	//
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName wraps G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#duplicate_subpattern_name
	//
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty wraps G_REGEX_ERROR_MALFORMED_PROPERTY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#malformed_property
	//
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty wraps G_REGEX_ERROR_UNKNOWN_PROPERTY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unknown_property
	//
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong wraps G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#subpattern_name_too_long
	//
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns wraps G_REGEX_ERROR_TOO_MANY_SUBPATTERNS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#too_many_subpatterns
	//
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue wraps G_REGEX_ERROR_INVALID_OCTAL_VALUE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_octal_value
	//
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine wraps G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#too_many_branches_in_define
	//
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion wraps G_REGEX_ERROR_DEFINE_REPETION
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#define_repetion
	//
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions wraps G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#inconsistent_newline_options
	//
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference wraps G_REGEX_ERROR_MISSING_BACK_REFERENCE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_back_reference
	//
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference wraps G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_relative_reference
	//
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden wraps G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#backtracking_control_verb_argument_forbidden
	//
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb wraps G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#unknown_backtracking_control_verb
	//
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig wraps G_REGEX_ERROR_NUMBER_TOO_BIG
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#number_too_big
	//
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName wraps G_REGEX_ERROR_MISSING_SUBPATTERN_NAME
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_subpattern_name
	//
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit wraps G_REGEX_ERROR_MISSING_DIGIT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_digit
	//
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter wraps G_REGEX_ERROR_INVALID_DATA_CHARACTER
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_data_character
	//
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName wraps G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#extra_subpattern_name
	//
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired wraps G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#backtracking_control_verb_argument_required
	//
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar wraps G_REGEX_ERROR_INVALID_CONTROL_CHAR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#invalid_control_char
	//
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName wraps G_REGEX_ERROR_MISSING_NAME
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#missing_name
	//
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass wraps G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#not_supported_in_class
	//
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences wraps G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#too_many_forward_references
	//
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong wraps G_REGEX_ERROR_NAME_TOO_LONG
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#name_too_long
	//
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge wraps G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexError.html#character_value_too_large
	//
	RegexErrorCharacterValueTooLarge RegexError = 176
)


func (e RegexError) String() string {
	switch e {
		case RegexErrorAssertionExpected: return "RegexErrorAssertionExpected"
		case RegexErrorBacktrackingControlVerbArgumentForbidden: return "RegexErrorBacktrackingControlVerbArgumentForbidden"
		case RegexErrorBacktrackingControlVerbArgumentRequired: return "RegexErrorBacktrackingControlVerbArgumentRequired"
		case RegexErrorCharacterValueTooLarge: return "RegexErrorCharacterValueTooLarge"
		case RegexErrorCompile: return "RegexErrorCompile"
		case RegexErrorDefineRepetion: return "RegexErrorDefineRepetion"
		case RegexErrorDuplicateSubpatternName: return "RegexErrorDuplicateSubpatternName"
		case RegexErrorExpressionTooLarge: return "RegexErrorExpressionTooLarge"
		case RegexErrorExtraSubpatternName: return "RegexErrorExtraSubpatternName"
		case RegexErrorHexCodeTooLarge: return "RegexErrorHexCodeTooLarge"
		case RegexErrorInconsistentNewlineOptions: return "RegexErrorInconsistentNewlineOptions"
		case RegexErrorInexistentSubpatternReference: return "RegexErrorInexistentSubpatternReference"
		case RegexErrorInfiniteLoop: return "RegexErrorInfiniteLoop"
		case RegexErrorInternal: return "RegexErrorInternal"
		case RegexErrorInvalidCondition: return "RegexErrorInvalidCondition"
		case RegexErrorInvalidControlChar: return "RegexErrorInvalidControlChar"
		case RegexErrorInvalidDataCharacter: return "RegexErrorInvalidDataCharacter"
		case RegexErrorInvalidEscapeInCharacterClass: return "RegexErrorInvalidEscapeInCharacterClass"
		case RegexErrorInvalidOctalValue: return "RegexErrorInvalidOctalValue"
		case RegexErrorInvalidRelativeReference: return "RegexErrorInvalidRelativeReference"
		case RegexErrorMalformedCondition: return "RegexErrorMalformedCondition"
		case RegexErrorMalformedProperty: return "RegexErrorMalformedProperty"
		case RegexErrorMatch: return "RegexErrorMatch"
		case RegexErrorMemoryError: return "RegexErrorMemoryError"
		case RegexErrorMissingBackReference: return "RegexErrorMissingBackReference"
		case RegexErrorMissingControlChar: return "RegexErrorMissingControlChar"
		case RegexErrorMissingDigit: return "RegexErrorMissingDigit"
		case RegexErrorMissingName: return "RegexErrorMissingName"
		case RegexErrorMissingSubpatternName: return "RegexErrorMissingSubpatternName"
		case RegexErrorMissingSubpatternNameTerminator: return "RegexErrorMissingSubpatternNameTerminator"
		case RegexErrorNameTooLong: return "RegexErrorNameTooLong"
		case RegexErrorNotSupportedInClass: return "RegexErrorNotSupportedInClass"
		case RegexErrorNothingToRepeat: return "RegexErrorNothingToRepeat"
		case RegexErrorNumberTooBig: return "RegexErrorNumberTooBig"
		case RegexErrorOptimize: return "RegexErrorOptimize"
		case RegexErrorPosixCollatingElementsNotSupported: return "RegexErrorPosixCollatingElementsNotSupported"
		case RegexErrorPosixNamedClassOutsideClass: return "RegexErrorPosixNamedClassOutsideClass"
		case RegexErrorQuantifierTooBig: return "RegexErrorQuantifierTooBig"
		case RegexErrorQuantifiersOutOfOrder: return "RegexErrorQuantifiersOutOfOrder"
		case RegexErrorRangeOutOfOrder: return "RegexErrorRangeOutOfOrder"
		case RegexErrorReplace: return "RegexErrorReplace"
		case RegexErrorSingleByteMatchInLookbehind: return "RegexErrorSingleByteMatchInLookbehind"
		case RegexErrorStrayBackslash: return "RegexErrorStrayBackslash"
		case RegexErrorSubpatternNameTooLong: return "RegexErrorSubpatternNameTooLong"
		case RegexErrorTooManyBranchesInDefine: return "RegexErrorTooManyBranchesInDefine"
		case RegexErrorTooManyConditionalBranches: return "RegexErrorTooManyConditionalBranches"
		case RegexErrorTooManyForwardReferences: return "RegexErrorTooManyForwardReferences"
		case RegexErrorTooManySubpatterns: return "RegexErrorTooManySubpatterns"
		case RegexErrorUnknownBacktrackingControlVerb: return "RegexErrorUnknownBacktrackingControlVerb"
		case RegexErrorUnknownPosixClassName: return "RegexErrorUnknownPosixClassName"
		case RegexErrorUnknownProperty: return "RegexErrorUnknownProperty"
		case RegexErrorUnmatchedParenthesis: return "RegexErrorUnmatchedParenthesis"
		case RegexErrorUnrecognizedCharacter: return "RegexErrorUnrecognizedCharacter"
		case RegexErrorUnrecognizedEscape: return "RegexErrorUnrecognizedEscape"
		case RegexErrorUnterminatedCharacterClass: return "RegexErrorUnterminatedCharacterClass"
		case RegexErrorUnterminatedComment: return "RegexErrorUnterminatedComment"
		case RegexErrorVariableLengthLookbehind: return "RegexErrorVariableLengthLookbehind"
		default: return fmt.Sprintf("RegexError(%d)", e)
	}
}

// SeekType wraps GSeekType
// 
// see also https://docs.gtk.org/glib/enum.SeekType.html
//
type SeekType C.int

const (
	// SeekCur wraps G_SEEK_CUR
	// 
	// see also https://docs.gtk.org/glib/flags.SeekType.html#cur
	//
	SeekCur SeekType = 0
	// SeekSet wraps G_SEEK_SET
	// 
	// see also https://docs.gtk.org/glib/flags.SeekType.html#set
	//
	SeekSet SeekType = 1
	// SeekEnd wraps G_SEEK_END
	// 
	// see also https://docs.gtk.org/glib/flags.SeekType.html#end
	//
	SeekEnd SeekType = 2
)


func (e SeekType) String() string {
	switch e {
		case SeekCur: return "SeekCur"
		case SeekEnd: return "SeekEnd"
		case SeekSet: return "SeekSet"
		default: return fmt.Sprintf("SeekType(%d)", e)
	}
}

// ShellError wraps GShellError
// 
// see also https://docs.gtk.org/glib/enum.ShellError.html
//
type ShellError C.int

const (
	// ShellErrorBadQuoting wraps G_SHELL_ERROR_BAD_QUOTING
	// 
	// see also https://docs.gtk.org/glib/flags.ShellError.html#bad_quoting
	//
	ShellErrorBadQuoting ShellError = 0
	// ShellErrorEmptyString wraps G_SHELL_ERROR_EMPTY_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.ShellError.html#empty_string
	//
	ShellErrorEmptyString ShellError = 1
	// ShellErrorFailed wraps G_SHELL_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.ShellError.html#failed
	//
	ShellErrorFailed ShellError = 2
)


func (e ShellError) String() string {
	switch e {
		case ShellErrorBadQuoting: return "ShellErrorBadQuoting"
		case ShellErrorEmptyString: return "ShellErrorEmptyString"
		case ShellErrorFailed: return "ShellErrorFailed"
		default: return fmt.Sprintf("ShellError(%d)", e)
	}
}

// SliceConfig wraps GSliceConfig
// 
// see also https://docs.gtk.org/glib/enum.SliceConfig.html
type SliceConfig C.int

const (
	// SliceConfigAlwaysMalloc wraps G_SLICE_CONFIG_ALWAYS_MALLOC
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#always_malloc
	SliceConfigAlwaysMalloc SliceConfig = 1
	// SliceConfigBypassMagazines wraps G_SLICE_CONFIG_BYPASS_MAGAZINES
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#bypass_magazines
	SliceConfigBypassMagazines SliceConfig = 2
	// SliceConfigWorkingSetMsecs wraps G_SLICE_CONFIG_WORKING_SET_MSECS
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#working_set_msecs
	SliceConfigWorkingSetMsecs SliceConfig = 3
	// SliceConfigColorIncrement wraps G_SLICE_CONFIG_COLOR_INCREMENT
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#color_increment
	SliceConfigColorIncrement SliceConfig = 4
	// SliceConfigChunkSizes wraps G_SLICE_CONFIG_CHUNK_SIZES
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#chunk_sizes
	SliceConfigChunkSizes SliceConfig = 5
	// SliceConfigContentionCounter wraps G_SLICE_CONFIG_CONTENTION_COUNTER
	// 
	// see also https://docs.gtk.org/glib/flags.SliceConfig.html#contention_counter
	SliceConfigContentionCounter SliceConfig = 6
)


func (e SliceConfig) String() string {
	switch e {
		case SliceConfigAlwaysMalloc: return "SliceConfigAlwaysMalloc"
		case SliceConfigBypassMagazines: return "SliceConfigBypassMagazines"
		case SliceConfigChunkSizes: return "SliceConfigChunkSizes"
		case SliceConfigColorIncrement: return "SliceConfigColorIncrement"
		case SliceConfigContentionCounter: return "SliceConfigContentionCounter"
		case SliceConfigWorkingSetMsecs: return "SliceConfigWorkingSetMsecs"
		default: return fmt.Sprintf("SliceConfig(%d)", e)
	}
}

// SpawnError wraps GSpawnError
// 
// see also https://docs.gtk.org/glib/enum.SpawnError.html
//
type SpawnError C.int

const (
	// SpawnErrorFork wraps G_SPAWN_ERROR_FORK
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#fork
	//
	SpawnErrorFork SpawnError = 0
	// SpawnErrorRead wraps G_SPAWN_ERROR_READ
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#read
	//
	SpawnErrorRead SpawnError = 1
	// SpawnErrorChdir wraps G_SPAWN_ERROR_CHDIR
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#chdir
	//
	SpawnErrorChdir SpawnError = 2
	// SpawnErrorAcces wraps G_SPAWN_ERROR_ACCES
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#acces
	//
	SpawnErrorAcces SpawnError = 3
	// SpawnErrorPerm wraps G_SPAWN_ERROR_PERM
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#perm
	//
	SpawnErrorPerm SpawnError = 4
	// SpawnErrorTooBig wraps G_SPAWN_ERROR_TOO_BIG
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#too_big
	//
	SpawnErrorTooBig SpawnError = 5
	// SpawnError2big wraps G_SPAWN_ERROR_2BIG
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#2big
	//
	SpawnError2big SpawnError = 5
	// SpawnErrorNoexec wraps G_SPAWN_ERROR_NOEXEC
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#noexec
	//
	SpawnErrorNoexec SpawnError = 6
	// SpawnErrorNametoolong wraps G_SPAWN_ERROR_NAMETOOLONG
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#nametoolong
	//
	SpawnErrorNametoolong SpawnError = 7
	// SpawnErrorNoent wraps G_SPAWN_ERROR_NOENT
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#noent
	//
	SpawnErrorNoent SpawnError = 8
	// SpawnErrorNomem wraps G_SPAWN_ERROR_NOMEM
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#nomem
	//
	SpawnErrorNomem SpawnError = 9
	// SpawnErrorNotdir wraps G_SPAWN_ERROR_NOTDIR
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#notdir
	//
	SpawnErrorNotdir SpawnError = 10
	// SpawnErrorLoop wraps G_SPAWN_ERROR_LOOP
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#loop
	//
	SpawnErrorLoop SpawnError = 11
	// SpawnErrorTxtbusy wraps G_SPAWN_ERROR_TXTBUSY
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#txtbusy
	//
	SpawnErrorTxtbusy SpawnError = 12
	// SpawnErrorIO wraps G_SPAWN_ERROR_IO
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#io
	//
	SpawnErrorIO SpawnError = 13
	// SpawnErrorNfile wraps G_SPAWN_ERROR_NFILE
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#nfile
	//
	SpawnErrorNfile SpawnError = 14
	// SpawnErrorMfile wraps G_SPAWN_ERROR_MFILE
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#mfile
	//
	SpawnErrorMfile SpawnError = 15
	// SpawnErrorInval wraps G_SPAWN_ERROR_INVAL
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#inval
	//
	SpawnErrorInval SpawnError = 16
	// SpawnErrorIsdir wraps G_SPAWN_ERROR_ISDIR
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#isdir
	//
	SpawnErrorIsdir SpawnError = 17
	// SpawnErrorLibbad wraps G_SPAWN_ERROR_LIBBAD
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#libbad
	//
	SpawnErrorLibbad SpawnError = 18
	// SpawnErrorFailed wraps G_SPAWN_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnError.html#failed
	//
	SpawnErrorFailed SpawnError = 19
)


func (e SpawnError) String() string {
	switch e {
		case SpawnErrorAcces: return "SpawnErrorAcces"
		case SpawnErrorChdir: return "SpawnErrorChdir"
		case SpawnErrorFailed: return "SpawnErrorFailed"
		case SpawnErrorFork: return "SpawnErrorFork"
		case SpawnErrorIO: return "SpawnErrorIO"
		case SpawnErrorInval: return "SpawnErrorInval"
		case SpawnErrorIsdir: return "SpawnErrorIsdir"
		case SpawnErrorLibbad: return "SpawnErrorLibbad"
		case SpawnErrorLoop: return "SpawnErrorLoop"
		case SpawnErrorMfile: return "SpawnErrorMfile"
		case SpawnErrorNametoolong: return "SpawnErrorNametoolong"
		case SpawnErrorNfile: return "SpawnErrorNfile"
		case SpawnErrorNoent: return "SpawnErrorNoent"
		case SpawnErrorNoexec: return "SpawnErrorNoexec"
		case SpawnErrorNomem: return "SpawnErrorNomem"
		case SpawnErrorNotdir: return "SpawnErrorNotdir"
		case SpawnErrorPerm: return "SpawnErrorPerm"
		case SpawnErrorRead: return "SpawnErrorRead"
		case SpawnErrorTooBig: return "SpawnErrorTooBig"
		case SpawnErrorTxtbusy: return "SpawnErrorTxtbusy"
		default: return fmt.Sprintf("SpawnError(%d)", e)
	}
}

// TestFileType wraps GTestFileType
// 
// see also https://docs.gtk.org/glib/enum.TestFileType.html
//
type TestFileType C.int

const (
	// TestDist wraps G_TEST_DIST
	// 
	// see also https://docs.gtk.org/glib/flags.TestFileType.html#dist
	//
	TestDist TestFileType = 0
	// TestBuilt wraps G_TEST_BUILT
	// 
	// see also https://docs.gtk.org/glib/flags.TestFileType.html#built
	//
	TestBuilt TestFileType = 1
)


func (e TestFileType) String() string {
	switch e {
		case TestBuilt: return "TestBuilt"
		case TestDist: return "TestDist"
		default: return fmt.Sprintf("TestFileType(%d)", e)
	}
}

// TestLogType wraps GTestLogType
// 
// see also https://docs.gtk.org/glib/enum.TestLogType.html
type TestLogType C.int

const (
	// TestLogNone wraps G_TEST_LOG_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#none
	TestLogNone TestLogType = 0
	// TestLogError wraps G_TEST_LOG_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#error
	TestLogError TestLogType = 1
	// TestLogStartBinary wraps G_TEST_LOG_START_BINARY
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#start_binary
	TestLogStartBinary TestLogType = 2
	// TestLogListCase wraps G_TEST_LOG_LIST_CASE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#list_case
	TestLogListCase TestLogType = 3
	// TestLogSkipCase wraps G_TEST_LOG_SKIP_CASE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#skip_case
	TestLogSkipCase TestLogType = 4
	// TestLogStartCase wraps G_TEST_LOG_START_CASE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#start_case
	TestLogStartCase TestLogType = 5
	// TestLogStopCase wraps G_TEST_LOG_STOP_CASE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#stop_case
	TestLogStopCase TestLogType = 6
	// TestLogMinResult wraps G_TEST_LOG_MIN_RESULT
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#min_result
	TestLogMinResult TestLogType = 7
	// TestLogMaxResult wraps G_TEST_LOG_MAX_RESULT
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#max_result
	TestLogMaxResult TestLogType = 8
	// TestLogMessage wraps G_TEST_LOG_MESSAGE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#message
	TestLogMessage TestLogType = 9
	// TestLogStartSuite wraps G_TEST_LOG_START_SUITE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#start_suite
	TestLogStartSuite TestLogType = 10
	// TestLogStopSuite wraps G_TEST_LOG_STOP_SUITE
	// 
	// see also https://docs.gtk.org/glib/flags.TestLogType.html#stop_suite
	TestLogStopSuite TestLogType = 11
)


func (e TestLogType) String() string {
	switch e {
		case TestLogError: return "TestLogError"
		case TestLogListCase: return "TestLogListCase"
		case TestLogMaxResult: return "TestLogMaxResult"
		case TestLogMessage: return "TestLogMessage"
		case TestLogMinResult: return "TestLogMinResult"
		case TestLogNone: return "TestLogNone"
		case TestLogSkipCase: return "TestLogSkipCase"
		case TestLogStartBinary: return "TestLogStartBinary"
		case TestLogStartCase: return "TestLogStartCase"
		case TestLogStartSuite: return "TestLogStartSuite"
		case TestLogStopCase: return "TestLogStopCase"
		case TestLogStopSuite: return "TestLogStopSuite"
		default: return fmt.Sprintf("TestLogType(%d)", e)
	}
}

// TestResult wraps GTestResult
// 
// see also https://docs.gtk.org/glib/enum.TestResult.html
type TestResult C.int

const (
	// TestRunSuccess wraps G_TEST_RUN_SUCCESS
	// 
	// see also https://docs.gtk.org/glib/flags.TestResult.html#success
	TestRunSuccess TestResult = 0
	// TestRunSkipped wraps G_TEST_RUN_SKIPPED
	// 
	// see also https://docs.gtk.org/glib/flags.TestResult.html#skipped
	TestRunSkipped TestResult = 1
	// TestRunFailure wraps G_TEST_RUN_FAILURE
	// 
	// see also https://docs.gtk.org/glib/flags.TestResult.html#failure
	TestRunFailure TestResult = 2
	// TestRunIncomplete wraps G_TEST_RUN_INCOMPLETE
	// 
	// see also https://docs.gtk.org/glib/flags.TestResult.html#incomplete
	TestRunIncomplete TestResult = 3
)


func (e TestResult) String() string {
	switch e {
		case TestRunFailure: return "TestRunFailure"
		case TestRunIncomplete: return "TestRunIncomplete"
		case TestRunSkipped: return "TestRunSkipped"
		case TestRunSuccess: return "TestRunSuccess"
		default: return fmt.Sprintf("TestResult(%d)", e)
	}
}

// ThreadError wraps GThreadError
// 
// see also https://docs.gtk.org/glib/enum.ThreadError.html
//
type ThreadError C.int

const (
	// ThreadErrorAgain wraps G_THREAD_ERROR_AGAIN
	// 
	// see also https://docs.gtk.org/glib/flags.ThreadError.html#thread_error_again
	//
	ThreadErrorAgain ThreadError = 0
)


func (e ThreadError) String() string {
	switch e {
		case ThreadErrorAgain: return "ThreadErrorAgain"
		default: return fmt.Sprintf("ThreadError(%d)", e)
	}
}

// TimeType wraps GTimeType
// 
// see also https://docs.gtk.org/glib/enum.TimeType.html
//
type TimeType C.int

const (
	// TimeTypeStandard wraps G_TIME_TYPE_STANDARD
	// 
	// see also https://docs.gtk.org/glib/flags.TimeType.html#standard
	//
	TimeTypeStandard TimeType = 0
	// TimeTypeDaylight wraps G_TIME_TYPE_DAYLIGHT
	// 
	// see also https://docs.gtk.org/glib/flags.TimeType.html#daylight
	//
	TimeTypeDaylight TimeType = 1
	// TimeTypeUniversal wraps G_TIME_TYPE_UNIVERSAL
	// 
	// see also https://docs.gtk.org/glib/flags.TimeType.html#universal
	//
	TimeTypeUniversal TimeType = 2
)


func (e TimeType) String() string {
	switch e {
		case TimeTypeDaylight: return "TimeTypeDaylight"
		case TimeTypeStandard: return "TimeTypeStandard"
		case TimeTypeUniversal: return "TimeTypeUniversal"
		default: return fmt.Sprintf("TimeType(%d)", e)
	}
}

// TokenType wraps GTokenType
// 
// see also https://docs.gtk.org/glib/enum.TokenType.html
//
type TokenType C.int

const (
	// TokenEOF wraps G_TOKEN_EOF
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#eof
	//
	TokenEOF TokenType = 0
	// TokenLeftParen wraps G_TOKEN_LEFT_PAREN
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#left_paren
	//
	TokenLeftParen TokenType = 40
	// TokenRightParen wraps G_TOKEN_RIGHT_PAREN
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#right_paren
	//
	TokenRightParen TokenType = 41
	// TokenLeftCurly wraps G_TOKEN_LEFT_CURLY
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#left_curly
	//
	TokenLeftCurly TokenType = 123
	// TokenRightCurly wraps G_TOKEN_RIGHT_CURLY
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#right_curly
	//
	TokenRightCurly TokenType = 125
	// TokenLeftBrace wraps G_TOKEN_LEFT_BRACE
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#left_brace
	//
	TokenLeftBrace TokenType = 91
	// TokenRightBrace wraps G_TOKEN_RIGHT_BRACE
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#right_brace
	//
	TokenRightBrace TokenType = 93
	// TokenEqualSign wraps G_TOKEN_EQUAL_SIGN
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#equal_sign
	//
	TokenEqualSign TokenType = 61
	// TokenComma wraps G_TOKEN_COMMA
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#comma
	//
	TokenComma TokenType = 44
	// TokenNone wraps G_TOKEN_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#none
	//
	TokenNone TokenType = 256
	// TokenError wraps G_TOKEN_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#error
	//
	TokenError TokenType = 257
	// TokenChar wraps G_TOKEN_CHAR
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#char
	//
	TokenChar TokenType = 258
	// TokenBinary wraps G_TOKEN_BINARY
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#binary
	//
	TokenBinary TokenType = 259
	// TokenOctal wraps G_TOKEN_OCTAL
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#octal
	//
	TokenOctal TokenType = 260
	// TokenInt wraps G_TOKEN_INT
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#int
	//
	TokenInt TokenType = 261
	// TokenHex wraps G_TOKEN_HEX
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#hex
	//
	TokenHex TokenType = 262
	// TokenFloat wraps G_TOKEN_FLOAT
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#float
	//
	TokenFloat TokenType = 263
	// TokenString wraps G_TOKEN_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#string
	//
	TokenString TokenType = 264
	// TokenSymbol wraps G_TOKEN_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#symbol
	//
	TokenSymbol TokenType = 265
	// TokenIdentifier wraps G_TOKEN_IDENTIFIER
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#identifier
	//
	TokenIdentifier TokenType = 266
	// TokenIdentifierNull wraps G_TOKEN_IDENTIFIER_NULL
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#identifier_null
	//
	TokenIdentifierNull TokenType = 267
	// TokenCommentSingle wraps G_TOKEN_COMMENT_SINGLE
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#comment_single
	//
	TokenCommentSingle TokenType = 268
	// TokenCommentMulti wraps G_TOKEN_COMMENT_MULTI
	// 
	// see also https://docs.gtk.org/glib/flags.TokenType.html#comment_multi
	//
	TokenCommentMulti TokenType = 269
)


func (e TokenType) String() string {
	switch e {
		case TokenBinary: return "TokenBinary"
		case TokenChar: return "TokenChar"
		case TokenComma: return "TokenComma"
		case TokenCommentMulti: return "TokenCommentMulti"
		case TokenCommentSingle: return "TokenCommentSingle"
		case TokenEOF: return "TokenEOF"
		case TokenEqualSign: return "TokenEqualSign"
		case TokenError: return "TokenError"
		case TokenFloat: return "TokenFloat"
		case TokenHex: return "TokenHex"
		case TokenIdentifier: return "TokenIdentifier"
		case TokenIdentifierNull: return "TokenIdentifierNull"
		case TokenInt: return "TokenInt"
		case TokenLeftBrace: return "TokenLeftBrace"
		case TokenLeftCurly: return "TokenLeftCurly"
		case TokenLeftParen: return "TokenLeftParen"
		case TokenNone: return "TokenNone"
		case TokenOctal: return "TokenOctal"
		case TokenRightBrace: return "TokenRightBrace"
		case TokenRightCurly: return "TokenRightCurly"
		case TokenRightParen: return "TokenRightParen"
		case TokenString: return "TokenString"
		case TokenSymbol: return "TokenSymbol"
		default: return fmt.Sprintf("TokenType(%d)", e)
	}
}

// TraverseType wraps GTraverseType
// 
// see also https://docs.gtk.org/glib/enum.TraverseType.html
//
type TraverseType C.int

const (
	// InOrder wraps G_IN_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseType.html#in_order
	//
	InOrder TraverseType = 0
	// PreOrder wraps G_PRE_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseType.html#pre_order
	//
	PreOrder TraverseType = 1
	// PostOrder wraps G_POST_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseType.html#post_order
	//
	PostOrder TraverseType = 2
	// LevelOrder wraps G_LEVEL_ORDER
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseType.html#level_order
	//
	LevelOrder TraverseType = 3
)


func (e TraverseType) String() string {
	switch e {
		case InOrder: return "InOrder"
		case LevelOrder: return "LevelOrder"
		case PostOrder: return "PostOrder"
		case PreOrder: return "PreOrder"
		default: return fmt.Sprintf("TraverseType(%d)", e)
	}
}

// UnicodeBreakType wraps GUnicodeBreakType
// 
// see also https://docs.gtk.org/glib/enum.UnicodeBreakType.html
//
type UnicodeBreakType C.int

const (
	// UnicodeBreakMandatory wraps G_UNICODE_BREAK_MANDATORY
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#mandatory
	//
	UnicodeBreakMandatory UnicodeBreakType = 0
	// UnicodeBreakCarriageReturn wraps G_UNICODE_BREAK_CARRIAGE_RETURN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#carriage_return
	//
	UnicodeBreakCarriageReturn UnicodeBreakType = 1
	// UnicodeBreakLineFeed wraps G_UNICODE_BREAK_LINE_FEED
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#line_feed
	//
	UnicodeBreakLineFeed UnicodeBreakType = 2
	// UnicodeBreakCombiningMark wraps G_UNICODE_BREAK_COMBINING_MARK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#combining_mark
	//
	UnicodeBreakCombiningMark UnicodeBreakType = 3
	// UnicodeBreakSurrogate wraps G_UNICODE_BREAK_SURROGATE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#surrogate
	//
	UnicodeBreakSurrogate UnicodeBreakType = 4
	// UnicodeBreakZeroWidthSpace wraps G_UNICODE_BREAK_ZERO_WIDTH_SPACE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#zero_width_space
	//
	UnicodeBreakZeroWidthSpace UnicodeBreakType = 5
	// UnicodeBreakInseparable wraps G_UNICODE_BREAK_INSEPARABLE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#inseparable
	//
	UnicodeBreakInseparable UnicodeBreakType = 6
	// UnicodeBreakNonBreakingGlue wraps G_UNICODE_BREAK_NON_BREAKING_GLUE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#non_breaking_glue
	//
	UnicodeBreakNonBreakingGlue UnicodeBreakType = 7
	// UnicodeBreakContingent wraps G_UNICODE_BREAK_CONTINGENT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#contingent
	//
	UnicodeBreakContingent UnicodeBreakType = 8
	// UnicodeBreakSpace wraps G_UNICODE_BREAK_SPACE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#space
	//
	UnicodeBreakSpace UnicodeBreakType = 9
	// UnicodeBreakAfter wraps G_UNICODE_BREAK_AFTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#after
	//
	UnicodeBreakAfter UnicodeBreakType = 10
	// UnicodeBreakBefore wraps G_UNICODE_BREAK_BEFORE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#before
	//
	UnicodeBreakBefore UnicodeBreakType = 11
	// UnicodeBreakBeforeAndAfter wraps G_UNICODE_BREAK_BEFORE_AND_AFTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#before_and_after
	//
	UnicodeBreakBeforeAndAfter UnicodeBreakType = 12
	// UnicodeBreakHyphen wraps G_UNICODE_BREAK_HYPHEN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hyphen
	//
	UnicodeBreakHyphen UnicodeBreakType = 13
	// UnicodeBreakNonStarter wraps G_UNICODE_BREAK_NON_STARTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#non_starter
	//
	UnicodeBreakNonStarter UnicodeBreakType = 14
	// UnicodeBreakOpenPunctuation wraps G_UNICODE_BREAK_OPEN_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#open_punctuation
	//
	UnicodeBreakOpenPunctuation UnicodeBreakType = 15
	// UnicodeBreakClosePunctuation wraps G_UNICODE_BREAK_CLOSE_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#close_punctuation
	//
	UnicodeBreakClosePunctuation UnicodeBreakType = 16
	// UnicodeBreakQuotation wraps G_UNICODE_BREAK_QUOTATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#quotation
	//
	UnicodeBreakQuotation UnicodeBreakType = 17
	// UnicodeBreakExclamation wraps G_UNICODE_BREAK_EXCLAMATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#exclamation
	//
	UnicodeBreakExclamation UnicodeBreakType = 18
	// UnicodeBreakIdeographic wraps G_UNICODE_BREAK_IDEOGRAPHIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#ideographic
	//
	UnicodeBreakIdeographic UnicodeBreakType = 19
	// UnicodeBreakNumeric wraps G_UNICODE_BREAK_NUMERIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#numeric
	//
	UnicodeBreakNumeric UnicodeBreakType = 20
	// UnicodeBreakInfixSeparator wraps G_UNICODE_BREAK_INFIX_SEPARATOR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#infix_separator
	//
	UnicodeBreakInfixSeparator UnicodeBreakType = 21
	// UnicodeBreakSymbol wraps G_UNICODE_BREAK_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#symbol
	//
	UnicodeBreakSymbol UnicodeBreakType = 22
	// UnicodeBreakAlphabetic wraps G_UNICODE_BREAK_ALPHABETIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#alphabetic
	//
	UnicodeBreakAlphabetic UnicodeBreakType = 23
	// UnicodeBreakPrefix wraps G_UNICODE_BREAK_PREFIX
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#prefix
	//
	UnicodeBreakPrefix UnicodeBreakType = 24
	// UnicodeBreakPostfix wraps G_UNICODE_BREAK_POSTFIX
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#postfix
	//
	UnicodeBreakPostfix UnicodeBreakType = 25
	// UnicodeBreakComplexContext wraps G_UNICODE_BREAK_COMPLEX_CONTEXT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#complex_context
	//
	UnicodeBreakComplexContext UnicodeBreakType = 26
	// UnicodeBreakAmbiguous wraps G_UNICODE_BREAK_AMBIGUOUS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#ambiguous
	//
	UnicodeBreakAmbiguous UnicodeBreakType = 27
	// UnicodeBreakUnknown wraps G_UNICODE_BREAK_UNKNOWN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#unknown
	//
	UnicodeBreakUnknown UnicodeBreakType = 28
	// UnicodeBreakNextLine wraps G_UNICODE_BREAK_NEXT_LINE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#next_line
	//
	UnicodeBreakNextLine UnicodeBreakType = 29
	// UnicodeBreakWordJoiner wraps G_UNICODE_BREAK_WORD_JOINER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#word_joiner
	//
	UnicodeBreakWordJoiner UnicodeBreakType = 30
	// UnicodeBreakHangulLJamo wraps G_UNICODE_BREAK_HANGUL_L_JAMO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hangul_l_jamo
	//
	UnicodeBreakHangulLJamo UnicodeBreakType = 31
	// UnicodeBreakHangulVJamo wraps G_UNICODE_BREAK_HANGUL_V_JAMO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hangul_v_jamo
	//
	UnicodeBreakHangulVJamo UnicodeBreakType = 32
	// UnicodeBreakHangulTJamo wraps G_UNICODE_BREAK_HANGUL_T_JAMO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hangul_t_jamo
	//
	UnicodeBreakHangulTJamo UnicodeBreakType = 33
	// UnicodeBreakHangulLvSyllable wraps G_UNICODE_BREAK_HANGUL_LV_SYLLABLE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hangul_lv_syllable
	//
	UnicodeBreakHangulLvSyllable UnicodeBreakType = 34
	// UnicodeBreakHangulLvtSyllable wraps G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hangul_lvt_syllable
	//
	UnicodeBreakHangulLvtSyllable UnicodeBreakType = 35
	// UnicodeBreakCloseParanthesis wraps G_UNICODE_BREAK_CLOSE_PARANTHESIS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#close_paranthesis
	//
	UnicodeBreakCloseParanthesis UnicodeBreakType = 36
	// UnicodeBreakCloseParenthesis wraps G_UNICODE_BREAK_CLOSE_PARENTHESIS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#close_parenthesis
	//
	UnicodeBreakCloseParenthesis UnicodeBreakType = 36
	// UnicodeBreakConditionalJapaneseStarter wraps G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#conditional_japanese_starter
	//
	UnicodeBreakConditionalJapaneseStarter UnicodeBreakType = 37
	// UnicodeBreakHebrewLetter wraps G_UNICODE_BREAK_HEBREW_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#hebrew_letter
	//
	UnicodeBreakHebrewLetter UnicodeBreakType = 38
	// UnicodeBreakRegionalIndicator wraps G_UNICODE_BREAK_REGIONAL_INDICATOR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#regional_indicator
	//
	UnicodeBreakRegionalIndicator UnicodeBreakType = 39
	// UnicodeBreakEmojiBase wraps G_UNICODE_BREAK_EMOJI_BASE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#emoji_base
	//
	UnicodeBreakEmojiBase UnicodeBreakType = 40
	// UnicodeBreakEmojiModifier wraps G_UNICODE_BREAK_EMOJI_MODIFIER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#emoji_modifier
	//
	UnicodeBreakEmojiModifier UnicodeBreakType = 41
	// UnicodeBreakZeroWidthJoiner wraps G_UNICODE_BREAK_ZERO_WIDTH_JOINER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#zero_width_joiner
	//
	UnicodeBreakZeroWidthJoiner UnicodeBreakType = 42
	// UnicodeBreakAksara wraps G_UNICODE_BREAK_AKSARA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#aksara
	//
	UnicodeBreakAksara UnicodeBreakType = 43
	// UnicodeBreakAksaraPreBase wraps G_UNICODE_BREAK_AKSARA_PRE_BASE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#aksara_pre_base
	//
	UnicodeBreakAksaraPreBase UnicodeBreakType = 44
	// UnicodeBreakAksaraStart wraps G_UNICODE_BREAK_AKSARA_START
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#aksara_start
	//
	UnicodeBreakAksaraStart UnicodeBreakType = 45
	// UnicodeBreakViramaFinal wraps G_UNICODE_BREAK_VIRAMA_FINAL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#virama_final
	//
	UnicodeBreakViramaFinal UnicodeBreakType = 46
	// UnicodeBreakVirama wraps G_UNICODE_BREAK_VIRAMA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeBreakType.html#virama
	//
	UnicodeBreakVirama UnicodeBreakType = 47
)


func (e UnicodeBreakType) String() string {
	switch e {
		case UnicodeBreakAfter: return "UnicodeBreakAfter"
		case UnicodeBreakAksara: return "UnicodeBreakAksara"
		case UnicodeBreakAksaraPreBase: return "UnicodeBreakAksaraPreBase"
		case UnicodeBreakAksaraStart: return "UnicodeBreakAksaraStart"
		case UnicodeBreakAlphabetic: return "UnicodeBreakAlphabetic"
		case UnicodeBreakAmbiguous: return "UnicodeBreakAmbiguous"
		case UnicodeBreakBefore: return "UnicodeBreakBefore"
		case UnicodeBreakBeforeAndAfter: return "UnicodeBreakBeforeAndAfter"
		case UnicodeBreakCarriageReturn: return "UnicodeBreakCarriageReturn"
		case UnicodeBreakCloseParanthesis: return "UnicodeBreakCloseParanthesis"
		case UnicodeBreakClosePunctuation: return "UnicodeBreakClosePunctuation"
		case UnicodeBreakCombiningMark: return "UnicodeBreakCombiningMark"
		case UnicodeBreakComplexContext: return "UnicodeBreakComplexContext"
		case UnicodeBreakConditionalJapaneseStarter: return "UnicodeBreakConditionalJapaneseStarter"
		case UnicodeBreakContingent: return "UnicodeBreakContingent"
		case UnicodeBreakEmojiBase: return "UnicodeBreakEmojiBase"
		case UnicodeBreakEmojiModifier: return "UnicodeBreakEmojiModifier"
		case UnicodeBreakExclamation: return "UnicodeBreakExclamation"
		case UnicodeBreakHangulLJamo: return "UnicodeBreakHangulLJamo"
		case UnicodeBreakHangulLvSyllable: return "UnicodeBreakHangulLvSyllable"
		case UnicodeBreakHangulLvtSyllable: return "UnicodeBreakHangulLvtSyllable"
		case UnicodeBreakHangulTJamo: return "UnicodeBreakHangulTJamo"
		case UnicodeBreakHangulVJamo: return "UnicodeBreakHangulVJamo"
		case UnicodeBreakHebrewLetter: return "UnicodeBreakHebrewLetter"
		case UnicodeBreakHyphen: return "UnicodeBreakHyphen"
		case UnicodeBreakIdeographic: return "UnicodeBreakIdeographic"
		case UnicodeBreakInfixSeparator: return "UnicodeBreakInfixSeparator"
		case UnicodeBreakInseparable: return "UnicodeBreakInseparable"
		case UnicodeBreakLineFeed: return "UnicodeBreakLineFeed"
		case UnicodeBreakMandatory: return "UnicodeBreakMandatory"
		case UnicodeBreakNextLine: return "UnicodeBreakNextLine"
		case UnicodeBreakNonBreakingGlue: return "UnicodeBreakNonBreakingGlue"
		case UnicodeBreakNonStarter: return "UnicodeBreakNonStarter"
		case UnicodeBreakNumeric: return "UnicodeBreakNumeric"
		case UnicodeBreakOpenPunctuation: return "UnicodeBreakOpenPunctuation"
		case UnicodeBreakPostfix: return "UnicodeBreakPostfix"
		case UnicodeBreakPrefix: return "UnicodeBreakPrefix"
		case UnicodeBreakQuotation: return "UnicodeBreakQuotation"
		case UnicodeBreakRegionalIndicator: return "UnicodeBreakRegionalIndicator"
		case UnicodeBreakSpace: return "UnicodeBreakSpace"
		case UnicodeBreakSurrogate: return "UnicodeBreakSurrogate"
		case UnicodeBreakSymbol: return "UnicodeBreakSymbol"
		case UnicodeBreakUnknown: return "UnicodeBreakUnknown"
		case UnicodeBreakVirama: return "UnicodeBreakVirama"
		case UnicodeBreakViramaFinal: return "UnicodeBreakViramaFinal"
		case UnicodeBreakWordJoiner: return "UnicodeBreakWordJoiner"
		case UnicodeBreakZeroWidthJoiner: return "UnicodeBreakZeroWidthJoiner"
		case UnicodeBreakZeroWidthSpace: return "UnicodeBreakZeroWidthSpace"
		default: return fmt.Sprintf("UnicodeBreakType(%d)", e)
	}
}

// UnicodeScript wraps GUnicodeScript
// 
// see also https://docs.gtk.org/glib/enum.UnicodeScript.html
//
type UnicodeScript C.int

const (
	// UnicodeScriptInvalidCode wraps G_UNICODE_SCRIPT_INVALID_CODE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#invalid_code
	//
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon wraps G_UNICODE_SCRIPT_COMMON
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#common
	//
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited wraps G_UNICODE_SCRIPT_INHERITED
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#inherited
	//
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic wraps G_UNICODE_SCRIPT_ARABIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#arabic
	//
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian wraps G_UNICODE_SCRIPT_ARMENIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#armenian
	//
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali wraps G_UNICODE_SCRIPT_BENGALI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#bengali
	//
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo wraps G_UNICODE_SCRIPT_BOPOMOFO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#bopomofo
	//
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee wraps G_UNICODE_SCRIPT_CHEROKEE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cherokee
	//
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic wraps G_UNICODE_SCRIPT_COPTIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#coptic
	//
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic wraps G_UNICODE_SCRIPT_CYRILLIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cyrillic
	//
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret wraps G_UNICODE_SCRIPT_DESERET
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#deseret
	//
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari wraps G_UNICODE_SCRIPT_DEVANAGARI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#devanagari
	//
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic wraps G_UNICODE_SCRIPT_ETHIOPIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ethiopic
	//
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian wraps G_UNICODE_SCRIPT_GEORGIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#georgian
	//
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic wraps G_UNICODE_SCRIPT_GOTHIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#gothic
	//
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek wraps G_UNICODE_SCRIPT_GREEK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#greek
	//
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati wraps G_UNICODE_SCRIPT_GUJARATI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#gujarati
	//
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi wraps G_UNICODE_SCRIPT_GURMUKHI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#gurmukhi
	//
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan wraps G_UNICODE_SCRIPT_HAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#han
	//
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul wraps G_UNICODE_SCRIPT_HANGUL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hangul
	//
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew wraps G_UNICODE_SCRIPT_HEBREW
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hebrew
	//
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana wraps G_UNICODE_SCRIPT_HIRAGANA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hiragana
	//
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada wraps G_UNICODE_SCRIPT_KANNADA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kannada
	//
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana wraps G_UNICODE_SCRIPT_KATAKANA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#katakana
	//
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer wraps G_UNICODE_SCRIPT_KHMER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#khmer
	//
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao wraps G_UNICODE_SCRIPT_LAO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#lao
	//
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin wraps G_UNICODE_SCRIPT_LATIN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#latin
	//
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam wraps G_UNICODE_SCRIPT_MALAYALAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#malayalam
	//
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian wraps G_UNICODE_SCRIPT_MONGOLIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#mongolian
	//
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar wraps G_UNICODE_SCRIPT_MYANMAR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#myanmar
	//
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham wraps G_UNICODE_SCRIPT_OGHAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ogham
	//
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic wraps G_UNICODE_SCRIPT_OLD_ITALIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_italic
	//
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya wraps G_UNICODE_SCRIPT_ORIYA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#oriya
	//
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic wraps G_UNICODE_SCRIPT_RUNIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#runic
	//
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala wraps G_UNICODE_SCRIPT_SINHALA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sinhala
	//
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac wraps G_UNICODE_SCRIPT_SYRIAC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#syriac
	//
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil wraps G_UNICODE_SCRIPT_TAMIL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tamil
	//
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu wraps G_UNICODE_SCRIPT_TELUGU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#telugu
	//
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana wraps G_UNICODE_SCRIPT_THAANA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#thaana
	//
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai wraps G_UNICODE_SCRIPT_THAI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#thai
	//
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan wraps G_UNICODE_SCRIPT_TIBETAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tibetan
	//
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal wraps G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#canadian_aboriginal
	//
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi wraps G_UNICODE_SCRIPT_YI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#yi
	//
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog wraps G_UNICODE_SCRIPT_TAGALOG
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tagalog
	//
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo wraps G_UNICODE_SCRIPT_HANUNOO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hanunoo
	//
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid wraps G_UNICODE_SCRIPT_BUHID
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#buhid
	//
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa wraps G_UNICODE_SCRIPT_TAGBANWA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tagbanwa
	//
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille wraps G_UNICODE_SCRIPT_BRAILLE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#braille
	//
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot wraps G_UNICODE_SCRIPT_CYPRIOT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cypriot
	//
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu wraps G_UNICODE_SCRIPT_LIMBU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#limbu
	//
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya wraps G_UNICODE_SCRIPT_OSMANYA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#osmanya
	//
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian wraps G_UNICODE_SCRIPT_SHAVIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#shavian
	//
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB wraps G_UNICODE_SCRIPT_LINEAR_B
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#linear_b
	//
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe wraps G_UNICODE_SCRIPT_TAI_LE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tai_le
	//
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic wraps G_UNICODE_SCRIPT_UGARITIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ugaritic
	//
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue wraps G_UNICODE_SCRIPT_NEW_TAI_LUE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#new_tai_lue
	//
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese wraps G_UNICODE_SCRIPT_BUGINESE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#buginese
	//
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic wraps G_UNICODE_SCRIPT_GLAGOLITIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#glagolitic
	//
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh wraps G_UNICODE_SCRIPT_TIFINAGH
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tifinagh
	//
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri wraps G_UNICODE_SCRIPT_SYLOTI_NAGRI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#syloti_nagri
	//
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian wraps G_UNICODE_SCRIPT_OLD_PERSIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_persian
	//
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi wraps G_UNICODE_SCRIPT_KHAROSHTHI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kharoshthi
	//
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown wraps G_UNICODE_SCRIPT_UNKNOWN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#unknown
	//
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese wraps G_UNICODE_SCRIPT_BALINESE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#balinese
	//
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform wraps G_UNICODE_SCRIPT_CUNEIFORM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cuneiform
	//
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician wraps G_UNICODE_SCRIPT_PHOENICIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#phoenician
	//
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa wraps G_UNICODE_SCRIPT_PHAGS_PA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#phags_pa
	//
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko wraps G_UNICODE_SCRIPT_NKO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nko
	//
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi wraps G_UNICODE_SCRIPT_KAYAH_LI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kayah_li
	//
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha wraps G_UNICODE_SCRIPT_LEPCHA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#lepcha
	//
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang wraps G_UNICODE_SCRIPT_REJANG
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#rejang
	//
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese wraps G_UNICODE_SCRIPT_SUNDANESE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sundanese
	//
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra wraps G_UNICODE_SCRIPT_SAURASHTRA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#saurashtra
	//
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham wraps G_UNICODE_SCRIPT_CHAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cham
	//
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki wraps G_UNICODE_SCRIPT_OL_CHIKI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ol_chiki
	//
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai wraps G_UNICODE_SCRIPT_VAI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#vai
	//
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian wraps G_UNICODE_SCRIPT_CARIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#carian
	//
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian wraps G_UNICODE_SCRIPT_LYCIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#lycian
	//
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian wraps G_UNICODE_SCRIPT_LYDIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#lydian
	//
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan wraps G_UNICODE_SCRIPT_AVESTAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#avestan
	//
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum wraps G_UNICODE_SCRIPT_BAMUM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#bamum
	//
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs wraps G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#egyptian_hieroglyphs
	//
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic wraps G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#imperial_aramaic
	//
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi wraps G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#inscriptional_pahlavi
	//
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian wraps G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#inscriptional_parthian
	//
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese wraps G_UNICODE_SCRIPT_JAVANESE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#javanese
	//
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi wraps G_UNICODE_SCRIPT_KAITHI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kaithi
	//
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu wraps G_UNICODE_SCRIPT_LISU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#lisu
	//
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek wraps G_UNICODE_SCRIPT_MEETEI_MAYEK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#meetei_mayek
	//
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian wraps G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_south_arabian
	//
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic wraps G_UNICODE_SCRIPT_OLD_TURKIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_turkic
	//
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan wraps G_UNICODE_SCRIPT_SAMARITAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#samaritan
	//
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham wraps G_UNICODE_SCRIPT_TAI_THAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tai_tham
	//
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet wraps G_UNICODE_SCRIPT_TAI_VIET
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tai_viet
	//
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak wraps G_UNICODE_SCRIPT_BATAK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#batak
	//
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi wraps G_UNICODE_SCRIPT_BRAHMI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#brahmi
	//
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic wraps G_UNICODE_SCRIPT_MANDAIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#mandaic
	//
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma wraps G_UNICODE_SCRIPT_CHAKMA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#chakma
	//
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive wraps G_UNICODE_SCRIPT_MEROITIC_CURSIVE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#meroitic_cursive
	//
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs wraps G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#meroitic_hieroglyphs
	//
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao wraps G_UNICODE_SCRIPT_MIAO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#miao
	//
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada wraps G_UNICODE_SCRIPT_SHARADA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sharada
	//
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng wraps G_UNICODE_SCRIPT_SORA_SOMPENG
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sora_sompeng
	//
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri wraps G_UNICODE_SCRIPT_TAKRI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#takri
	//
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah wraps G_UNICODE_SCRIPT_BASSA_VAH
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#bassa_vah
	//
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian wraps G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#caucasian_albanian
	//
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan wraps G_UNICODE_SCRIPT_DUPLOYAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#duployan
	//
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan wraps G_UNICODE_SCRIPT_ELBASAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#elbasan
	//
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha wraps G_UNICODE_SCRIPT_GRANTHA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#grantha
	//
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki wraps G_UNICODE_SCRIPT_KHOJKI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#khojki
	//
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi wraps G_UNICODE_SCRIPT_KHUDAWADI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#khudawadi
	//
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA wraps G_UNICODE_SCRIPT_LINEAR_A
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#linear_a
	//
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani wraps G_UNICODE_SCRIPT_MAHAJANI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#mahajani
	//
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean wraps G_UNICODE_SCRIPT_MANICHAEAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#manichaean
	//
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui wraps G_UNICODE_SCRIPT_MENDE_KIKAKUI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#mende_kikakui
	//
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi wraps G_UNICODE_SCRIPT_MODI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#modi
	//
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro wraps G_UNICODE_SCRIPT_MRO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#mro
	//
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean wraps G_UNICODE_SCRIPT_NABATAEAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nabataean
	//
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian wraps G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_north_arabian
	//
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic wraps G_UNICODE_SCRIPT_OLD_PERMIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_permic
	//
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong wraps G_UNICODE_SCRIPT_PAHAWH_HMONG
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#pahawh_hmong
	//
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene wraps G_UNICODE_SCRIPT_PALMYRENE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#palmyrene
	//
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau wraps G_UNICODE_SCRIPT_PAU_CIN_HAU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#pau_cin_hau
	//
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi wraps G_UNICODE_SCRIPT_PSALTER_PAHLAVI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#psalter_pahlavi
	//
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham wraps G_UNICODE_SCRIPT_SIDDHAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#siddham
	//
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta wraps G_UNICODE_SCRIPT_TIRHUTA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tirhuta
	//
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti wraps G_UNICODE_SCRIPT_WARANG_CITI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#warang_citi
	//
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom wraps G_UNICODE_SCRIPT_AHOM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ahom
	//
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs wraps G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#anatolian_hieroglyphs
	//
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran wraps G_UNICODE_SCRIPT_HATRAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hatran
	//
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani wraps G_UNICODE_SCRIPT_MULTANI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#multani
	//
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian wraps G_UNICODE_SCRIPT_OLD_HUNGARIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_hungarian
	//
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting wraps G_UNICODE_SCRIPT_SIGNWRITING
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#signwriting
	//
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam wraps G_UNICODE_SCRIPT_ADLAM
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#adlam
	//
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki wraps G_UNICODE_SCRIPT_BHAIKSUKI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#bhaiksuki
	//
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen wraps G_UNICODE_SCRIPT_MARCHEN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#marchen
	//
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa wraps G_UNICODE_SCRIPT_NEWA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#newa
	//
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage wraps G_UNICODE_SCRIPT_OSAGE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#osage
	//
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut wraps G_UNICODE_SCRIPT_TANGUT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tangut
	//
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi wraps G_UNICODE_SCRIPT_MASARAM_GONDI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#masaram_gondi
	//
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu wraps G_UNICODE_SCRIPT_NUSHU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nushu
	//
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo wraps G_UNICODE_SCRIPT_SOYOMBO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#soyombo
	//
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare wraps G_UNICODE_SCRIPT_ZANABAZAR_SQUARE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#zanabazar_square
	//
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra wraps G_UNICODE_SCRIPT_DOGRA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#dogra
	//
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi wraps G_UNICODE_SCRIPT_GUNJALA_GONDI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#gunjala_gondi
	//
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya wraps G_UNICODE_SCRIPT_HANIFI_ROHINGYA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#hanifi_rohingya
	//
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar wraps G_UNICODE_SCRIPT_MAKASAR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#makasar
	//
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin wraps G_UNICODE_SCRIPT_MEDEFAIDRIN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#medefaidrin
	//
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian wraps G_UNICODE_SCRIPT_OLD_SOGDIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_sogdian
	//
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian wraps G_UNICODE_SCRIPT_SOGDIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sogdian
	//
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic wraps G_UNICODE_SCRIPT_ELYMAIC
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#elymaic
	//
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari wraps G_UNICODE_SCRIPT_NANDINAGARI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nandinagari
	//
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong wraps G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nyiakeng_puachue_hmong
	//
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho wraps G_UNICODE_SCRIPT_WANCHO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#wancho
	//
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian wraps G_UNICODE_SCRIPT_CHORASMIAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#chorasmian
	//
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru wraps G_UNICODE_SCRIPT_DIVES_AKURU
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#dives_akuru
	//
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript wraps G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#khitan_small_script
	//
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi wraps G_UNICODE_SCRIPT_YEZIDI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#yezidi
	//
	UnicodeScriptYezidi UnicodeScript = 156
	// UnicodeScriptCyproMinoan wraps G_UNICODE_SCRIPT_CYPRO_MINOAN
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#cypro_minoan
	//
	UnicodeScriptCyproMinoan UnicodeScript = 157
	// UnicodeScriptOldUyghur wraps G_UNICODE_SCRIPT_OLD_UYGHUR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#old_uyghur
	//
	UnicodeScriptOldUyghur UnicodeScript = 158
	// UnicodeScriptTangsa wraps G_UNICODE_SCRIPT_TANGSA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tangsa
	//
	UnicodeScriptTangsa UnicodeScript = 159
	// UnicodeScriptToto wraps G_UNICODE_SCRIPT_TOTO
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#toto
	//
	UnicodeScriptToto UnicodeScript = 160
	// UnicodeScriptVithkuqi wraps G_UNICODE_SCRIPT_VITHKUQI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#vithkuqi
	//
	UnicodeScriptVithkuqi UnicodeScript = 161
	// UnicodeScriptMath wraps G_UNICODE_SCRIPT_MATH
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#math
	//
	UnicodeScriptMath UnicodeScript = 162
	// UnicodeScriptKawi wraps G_UNICODE_SCRIPT_KAWI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kawi
	//
	UnicodeScriptKawi UnicodeScript = 163
	// UnicodeScriptNagMundari wraps G_UNICODE_SCRIPT_NAG_MUNDARI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#nag_mundari
	//
	UnicodeScriptNagMundari UnicodeScript = 164
	// UnicodeScriptTodhri wraps G_UNICODE_SCRIPT_TODHRI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#todhri
	//
	UnicodeScriptTodhri UnicodeScript = 165
	// UnicodeScriptGaray wraps G_UNICODE_SCRIPT_GARAY
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#garay
	//
	UnicodeScriptGaray UnicodeScript = 166
	// UnicodeScriptTuluTigalari wraps G_UNICODE_SCRIPT_TULU_TIGALARI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#tulu_tigalari
	//
	UnicodeScriptTuluTigalari UnicodeScript = 167
	// UnicodeScriptSunuwar wraps G_UNICODE_SCRIPT_SUNUWAR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#sunuwar
	//
	UnicodeScriptSunuwar UnicodeScript = 168
	// UnicodeScriptGurungKhema wraps G_UNICODE_SCRIPT_GURUNG_KHEMA
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#gurung_khema
	//
	UnicodeScriptGurungKhema UnicodeScript = 169
	// UnicodeScriptKiratRai wraps G_UNICODE_SCRIPT_KIRAT_RAI
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#kirat_rai
	//
	UnicodeScriptKiratRai UnicodeScript = 170
	// UnicodeScriptOlOnal wraps G_UNICODE_SCRIPT_OL_ONAL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeScript.html#ol_onal
	//
	UnicodeScriptOlOnal UnicodeScript = 171
)


func (e UnicodeScript) String() string {
	switch e {
		case UnicodeScriptAdlam: return "UnicodeScriptAdlam"
		case UnicodeScriptAhom: return "UnicodeScriptAhom"
		case UnicodeScriptAnatolianHieroglyphs: return "UnicodeScriptAnatolianHieroglyphs"
		case UnicodeScriptArabic: return "UnicodeScriptArabic"
		case UnicodeScriptArmenian: return "UnicodeScriptArmenian"
		case UnicodeScriptAvestan: return "UnicodeScriptAvestan"
		case UnicodeScriptBalinese: return "UnicodeScriptBalinese"
		case UnicodeScriptBamum: return "UnicodeScriptBamum"
		case UnicodeScriptBassaVah: return "UnicodeScriptBassaVah"
		case UnicodeScriptBatak: return "UnicodeScriptBatak"
		case UnicodeScriptBengali: return "UnicodeScriptBengali"
		case UnicodeScriptBhaiksuki: return "UnicodeScriptBhaiksuki"
		case UnicodeScriptBopomofo: return "UnicodeScriptBopomofo"
		case UnicodeScriptBrahmi: return "UnicodeScriptBrahmi"
		case UnicodeScriptBraille: return "UnicodeScriptBraille"
		case UnicodeScriptBuginese: return "UnicodeScriptBuginese"
		case UnicodeScriptBuhid: return "UnicodeScriptBuhid"
		case UnicodeScriptCanadianAboriginal: return "UnicodeScriptCanadianAboriginal"
		case UnicodeScriptCarian: return "UnicodeScriptCarian"
		case UnicodeScriptCaucasianAlbanian: return "UnicodeScriptCaucasianAlbanian"
		case UnicodeScriptChakma: return "UnicodeScriptChakma"
		case UnicodeScriptCham: return "UnicodeScriptCham"
		case UnicodeScriptCherokee: return "UnicodeScriptCherokee"
		case UnicodeScriptChorasmian: return "UnicodeScriptChorasmian"
		case UnicodeScriptCommon: return "UnicodeScriptCommon"
		case UnicodeScriptCoptic: return "UnicodeScriptCoptic"
		case UnicodeScriptCuneiform: return "UnicodeScriptCuneiform"
		case UnicodeScriptCypriot: return "UnicodeScriptCypriot"
		case UnicodeScriptCyproMinoan: return "UnicodeScriptCyproMinoan"
		case UnicodeScriptCyrillic: return "UnicodeScriptCyrillic"
		case UnicodeScriptDeseret: return "UnicodeScriptDeseret"
		case UnicodeScriptDevanagari: return "UnicodeScriptDevanagari"
		case UnicodeScriptDivesAkuru: return "UnicodeScriptDivesAkuru"
		case UnicodeScriptDogra: return "UnicodeScriptDogra"
		case UnicodeScriptDuployan: return "UnicodeScriptDuployan"
		case UnicodeScriptEgyptianHieroglyphs: return "UnicodeScriptEgyptianHieroglyphs"
		case UnicodeScriptElbasan: return "UnicodeScriptElbasan"
		case UnicodeScriptElymaic: return "UnicodeScriptElymaic"
		case UnicodeScriptEthiopic: return "UnicodeScriptEthiopic"
		case UnicodeScriptGaray: return "UnicodeScriptGaray"
		case UnicodeScriptGeorgian: return "UnicodeScriptGeorgian"
		case UnicodeScriptGlagolitic: return "UnicodeScriptGlagolitic"
		case UnicodeScriptGothic: return "UnicodeScriptGothic"
		case UnicodeScriptGrantha: return "UnicodeScriptGrantha"
		case UnicodeScriptGreek: return "UnicodeScriptGreek"
		case UnicodeScriptGujarati: return "UnicodeScriptGujarati"
		case UnicodeScriptGunjalaGondi: return "UnicodeScriptGunjalaGondi"
		case UnicodeScriptGurmukhi: return "UnicodeScriptGurmukhi"
		case UnicodeScriptGurungKhema: return "UnicodeScriptGurungKhema"
		case UnicodeScriptHan: return "UnicodeScriptHan"
		case UnicodeScriptHangul: return "UnicodeScriptHangul"
		case UnicodeScriptHanifiRohingya: return "UnicodeScriptHanifiRohingya"
		case UnicodeScriptHanunoo: return "UnicodeScriptHanunoo"
		case UnicodeScriptHatran: return "UnicodeScriptHatran"
		case UnicodeScriptHebrew: return "UnicodeScriptHebrew"
		case UnicodeScriptHiragana: return "UnicodeScriptHiragana"
		case UnicodeScriptImperialAramaic: return "UnicodeScriptImperialAramaic"
		case UnicodeScriptInherited: return "UnicodeScriptInherited"
		case UnicodeScriptInscriptionalPahlavi: return "UnicodeScriptInscriptionalPahlavi"
		case UnicodeScriptInscriptionalParthian: return "UnicodeScriptInscriptionalParthian"
		case UnicodeScriptInvalidCode: return "UnicodeScriptInvalidCode"
		case UnicodeScriptJavanese: return "UnicodeScriptJavanese"
		case UnicodeScriptKaithi: return "UnicodeScriptKaithi"
		case UnicodeScriptKannada: return "UnicodeScriptKannada"
		case UnicodeScriptKatakana: return "UnicodeScriptKatakana"
		case UnicodeScriptKawi: return "UnicodeScriptKawi"
		case UnicodeScriptKayahLi: return "UnicodeScriptKayahLi"
		case UnicodeScriptKharoshthi: return "UnicodeScriptKharoshthi"
		case UnicodeScriptKhitanSmallScript: return "UnicodeScriptKhitanSmallScript"
		case UnicodeScriptKhmer: return "UnicodeScriptKhmer"
		case UnicodeScriptKhojki: return "UnicodeScriptKhojki"
		case UnicodeScriptKhudawadi: return "UnicodeScriptKhudawadi"
		case UnicodeScriptKiratRai: return "UnicodeScriptKiratRai"
		case UnicodeScriptLao: return "UnicodeScriptLao"
		case UnicodeScriptLatin: return "UnicodeScriptLatin"
		case UnicodeScriptLepcha: return "UnicodeScriptLepcha"
		case UnicodeScriptLimbu: return "UnicodeScriptLimbu"
		case UnicodeScriptLinearA: return "UnicodeScriptLinearA"
		case UnicodeScriptLinearB: return "UnicodeScriptLinearB"
		case UnicodeScriptLisu: return "UnicodeScriptLisu"
		case UnicodeScriptLycian: return "UnicodeScriptLycian"
		case UnicodeScriptLydian: return "UnicodeScriptLydian"
		case UnicodeScriptMahajani: return "UnicodeScriptMahajani"
		case UnicodeScriptMakasar: return "UnicodeScriptMakasar"
		case UnicodeScriptMalayalam: return "UnicodeScriptMalayalam"
		case UnicodeScriptMandaic: return "UnicodeScriptMandaic"
		case UnicodeScriptManichaean: return "UnicodeScriptManichaean"
		case UnicodeScriptMarchen: return "UnicodeScriptMarchen"
		case UnicodeScriptMasaramGondi: return "UnicodeScriptMasaramGondi"
		case UnicodeScriptMath: return "UnicodeScriptMath"
		case UnicodeScriptMedefaidrin: return "UnicodeScriptMedefaidrin"
		case UnicodeScriptMeeteiMayek: return "UnicodeScriptMeeteiMayek"
		case UnicodeScriptMendeKikakui: return "UnicodeScriptMendeKikakui"
		case UnicodeScriptMeroiticCursive: return "UnicodeScriptMeroiticCursive"
		case UnicodeScriptMeroiticHieroglyphs: return "UnicodeScriptMeroiticHieroglyphs"
		case UnicodeScriptMiao: return "UnicodeScriptMiao"
		case UnicodeScriptModi: return "UnicodeScriptModi"
		case UnicodeScriptMongolian: return "UnicodeScriptMongolian"
		case UnicodeScriptMro: return "UnicodeScriptMro"
		case UnicodeScriptMultani: return "UnicodeScriptMultani"
		case UnicodeScriptMyanmar: return "UnicodeScriptMyanmar"
		case UnicodeScriptNabataean: return "UnicodeScriptNabataean"
		case UnicodeScriptNagMundari: return "UnicodeScriptNagMundari"
		case UnicodeScriptNandinagari: return "UnicodeScriptNandinagari"
		case UnicodeScriptNewTaiLue: return "UnicodeScriptNewTaiLue"
		case UnicodeScriptNewa: return "UnicodeScriptNewa"
		case UnicodeScriptNko: return "UnicodeScriptNko"
		case UnicodeScriptNushu: return "UnicodeScriptNushu"
		case UnicodeScriptNyiakengPuachueHmong: return "UnicodeScriptNyiakengPuachueHmong"
		case UnicodeScriptOgham: return "UnicodeScriptOgham"
		case UnicodeScriptOlChiki: return "UnicodeScriptOlChiki"
		case UnicodeScriptOlOnal: return "UnicodeScriptOlOnal"
		case UnicodeScriptOldHungarian: return "UnicodeScriptOldHungarian"
		case UnicodeScriptOldItalic: return "UnicodeScriptOldItalic"
		case UnicodeScriptOldNorthArabian: return "UnicodeScriptOldNorthArabian"
		case UnicodeScriptOldPermic: return "UnicodeScriptOldPermic"
		case UnicodeScriptOldPersian: return "UnicodeScriptOldPersian"
		case UnicodeScriptOldSogdian: return "UnicodeScriptOldSogdian"
		case UnicodeScriptOldSouthArabian: return "UnicodeScriptOldSouthArabian"
		case UnicodeScriptOldTurkic: return "UnicodeScriptOldTurkic"
		case UnicodeScriptOldUyghur: return "UnicodeScriptOldUyghur"
		case UnicodeScriptOriya: return "UnicodeScriptOriya"
		case UnicodeScriptOsage: return "UnicodeScriptOsage"
		case UnicodeScriptOsmanya: return "UnicodeScriptOsmanya"
		case UnicodeScriptPahawhHmong: return "UnicodeScriptPahawhHmong"
		case UnicodeScriptPalmyrene: return "UnicodeScriptPalmyrene"
		case UnicodeScriptPauCinHau: return "UnicodeScriptPauCinHau"
		case UnicodeScriptPhagsPa: return "UnicodeScriptPhagsPa"
		case UnicodeScriptPhoenician: return "UnicodeScriptPhoenician"
		case UnicodeScriptPsalterPahlavi: return "UnicodeScriptPsalterPahlavi"
		case UnicodeScriptRejang: return "UnicodeScriptRejang"
		case UnicodeScriptRunic: return "UnicodeScriptRunic"
		case UnicodeScriptSamaritan: return "UnicodeScriptSamaritan"
		case UnicodeScriptSaurashtra: return "UnicodeScriptSaurashtra"
		case UnicodeScriptSharada: return "UnicodeScriptSharada"
		case UnicodeScriptShavian: return "UnicodeScriptShavian"
		case UnicodeScriptSiddham: return "UnicodeScriptSiddham"
		case UnicodeScriptSignwriting: return "UnicodeScriptSignwriting"
		case UnicodeScriptSinhala: return "UnicodeScriptSinhala"
		case UnicodeScriptSogdian: return "UnicodeScriptSogdian"
		case UnicodeScriptSoraSompeng: return "UnicodeScriptSoraSompeng"
		case UnicodeScriptSoyombo: return "UnicodeScriptSoyombo"
		case UnicodeScriptSundanese: return "UnicodeScriptSundanese"
		case UnicodeScriptSunuwar: return "UnicodeScriptSunuwar"
		case UnicodeScriptSylotiNagri: return "UnicodeScriptSylotiNagri"
		case UnicodeScriptSyriac: return "UnicodeScriptSyriac"
		case UnicodeScriptTagalog: return "UnicodeScriptTagalog"
		case UnicodeScriptTagbanwa: return "UnicodeScriptTagbanwa"
		case UnicodeScriptTaiLe: return "UnicodeScriptTaiLe"
		case UnicodeScriptTaiTham: return "UnicodeScriptTaiTham"
		case UnicodeScriptTaiViet: return "UnicodeScriptTaiViet"
		case UnicodeScriptTakri: return "UnicodeScriptTakri"
		case UnicodeScriptTamil: return "UnicodeScriptTamil"
		case UnicodeScriptTangsa: return "UnicodeScriptTangsa"
		case UnicodeScriptTangut: return "UnicodeScriptTangut"
		case UnicodeScriptTelugu: return "UnicodeScriptTelugu"
		case UnicodeScriptThaana: return "UnicodeScriptThaana"
		case UnicodeScriptThai: return "UnicodeScriptThai"
		case UnicodeScriptTibetan: return "UnicodeScriptTibetan"
		case UnicodeScriptTifinagh: return "UnicodeScriptTifinagh"
		case UnicodeScriptTirhuta: return "UnicodeScriptTirhuta"
		case UnicodeScriptTodhri: return "UnicodeScriptTodhri"
		case UnicodeScriptToto: return "UnicodeScriptToto"
		case UnicodeScriptTuluTigalari: return "UnicodeScriptTuluTigalari"
		case UnicodeScriptUgaritic: return "UnicodeScriptUgaritic"
		case UnicodeScriptUnknown: return "UnicodeScriptUnknown"
		case UnicodeScriptVai: return "UnicodeScriptVai"
		case UnicodeScriptVithkuqi: return "UnicodeScriptVithkuqi"
		case UnicodeScriptWancho: return "UnicodeScriptWancho"
		case UnicodeScriptWarangCiti: return "UnicodeScriptWarangCiti"
		case UnicodeScriptYezidi: return "UnicodeScriptYezidi"
		case UnicodeScriptYi: return "UnicodeScriptYi"
		case UnicodeScriptZanabazarSquare: return "UnicodeScriptZanabazarSquare"
		default: return fmt.Sprintf("UnicodeScript(%d)", e)
	}
}

// UnicodeScriptFromIso15924 wraps g_unicode_script_from_iso15924
// 
// see also https://docs.gtk.org/glib/func.g_unicode_script_from_iso15924.html
//
func UnicodeScriptFromIso15924(iso15924 uint32) UnicodeScript {
	var carg1 C.guint32        // in, none, casted
	var cret  C.GUnicodeScript // return, none, casted

	carg1 = C.guint32(iso15924)

	cret = C.g_unicode_script_from_iso15924(carg1)
	runtime.KeepAlive(iso15924)

	var goret UnicodeScript

	goret = UnicodeScript(cret)

	return goret
}

// UnicodeScriptToIso15924 wraps g_unicode_script_to_iso15924
// 
// see also https://docs.gtk.org/glib/func.g_unicode_script_to_iso15924.html
//
func UnicodeScriptToIso15924(script UnicodeScript) uint32 {
	var carg1 C.GUnicodeScript // in, none, casted
	var cret  C.guint32        // return, none, casted

	carg1 = C.GUnicodeScript(script)

	cret = C.g_unicode_script_to_iso15924(carg1)
	runtime.KeepAlive(script)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicodeType wraps GUnicodeType
// 
// see also https://docs.gtk.org/glib/enum.UnicodeType.html
//
type UnicodeType C.int

const (
	// UnicodeControl wraps G_UNICODE_CONTROL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#control
	//
	UnicodeControl UnicodeType = 0
	// UnicodeFormat wraps G_UNICODE_FORMAT
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#format
	//
	UnicodeFormat UnicodeType = 1
	// UnicodeUnassigned wraps G_UNICODE_UNASSIGNED
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#unassigned
	//
	UnicodeUnassigned UnicodeType = 2
	// UnicodePrivateUse wraps G_UNICODE_PRIVATE_USE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#private_use
	//
	UnicodePrivateUse UnicodeType = 3
	// UnicodeSurrogate wraps G_UNICODE_SURROGATE
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#surrogate
	//
	UnicodeSurrogate UnicodeType = 4
	// UnicodeLowercaseLetter wraps G_UNICODE_LOWERCASE_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#lowercase_letter
	//
	UnicodeLowercaseLetter UnicodeType = 5
	// UnicodeModifierLetter wraps G_UNICODE_MODIFIER_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#modifier_letter
	//
	UnicodeModifierLetter UnicodeType = 6
	// UnicodeOtherLetter wraps G_UNICODE_OTHER_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#other_letter
	//
	UnicodeOtherLetter UnicodeType = 7
	// UnicodeTitlecaseLetter wraps G_UNICODE_TITLECASE_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#titlecase_letter
	//
	UnicodeTitlecaseLetter UnicodeType = 8
	// UnicodeUppercaseLetter wraps G_UNICODE_UPPERCASE_LETTER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#uppercase_letter
	//
	UnicodeUppercaseLetter UnicodeType = 9
	// UnicodeSpacingMark wraps G_UNICODE_SPACING_MARK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#spacing_mark
	//
	UnicodeSpacingMark UnicodeType = 10
	// UnicodeEnclosingMark wraps G_UNICODE_ENCLOSING_MARK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#enclosing_mark
	//
	UnicodeEnclosingMark UnicodeType = 11
	// UnicodeNonSpacingMark wraps G_UNICODE_NON_SPACING_MARK
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#non_spacing_mark
	//
	UnicodeNonSpacingMark UnicodeType = 12
	// UnicodeDecimalNumber wraps G_UNICODE_DECIMAL_NUMBER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#decimal_number
	//
	UnicodeDecimalNumber UnicodeType = 13
	// UnicodeLetterNumber wraps G_UNICODE_LETTER_NUMBER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#letter_number
	//
	UnicodeLetterNumber UnicodeType = 14
	// UnicodeOtherNumber wraps G_UNICODE_OTHER_NUMBER
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#other_number
	//
	UnicodeOtherNumber UnicodeType = 15
	// UnicodeConnectPunctuation wraps G_UNICODE_CONNECT_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#connect_punctuation
	//
	UnicodeConnectPunctuation UnicodeType = 16
	// UnicodeDashPunctuation wraps G_UNICODE_DASH_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#dash_punctuation
	//
	UnicodeDashPunctuation UnicodeType = 17
	// UnicodeClosePunctuation wraps G_UNICODE_CLOSE_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#close_punctuation
	//
	UnicodeClosePunctuation UnicodeType = 18
	// UnicodeFinalPunctuation wraps G_UNICODE_FINAL_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#final_punctuation
	//
	UnicodeFinalPunctuation UnicodeType = 19
	// UnicodeInitialPunctuation wraps G_UNICODE_INITIAL_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#initial_punctuation
	//
	UnicodeInitialPunctuation UnicodeType = 20
	// UnicodeOtherPunctuation wraps G_UNICODE_OTHER_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#other_punctuation
	//
	UnicodeOtherPunctuation UnicodeType = 21
	// UnicodeOpenPunctuation wraps G_UNICODE_OPEN_PUNCTUATION
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#open_punctuation
	//
	UnicodeOpenPunctuation UnicodeType = 22
	// UnicodeCurrencySymbol wraps G_UNICODE_CURRENCY_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#currency_symbol
	//
	UnicodeCurrencySymbol UnicodeType = 23
	// UnicodeModifierSymbol wraps G_UNICODE_MODIFIER_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#modifier_symbol
	//
	UnicodeModifierSymbol UnicodeType = 24
	// UnicodeMathSymbol wraps G_UNICODE_MATH_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#math_symbol
	//
	UnicodeMathSymbol UnicodeType = 25
	// UnicodeOtherSymbol wraps G_UNICODE_OTHER_SYMBOL
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#other_symbol
	//
	UnicodeOtherSymbol UnicodeType = 26
	// UnicodeLineSeparator wraps G_UNICODE_LINE_SEPARATOR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#line_separator
	//
	UnicodeLineSeparator UnicodeType = 27
	// UnicodeParagraphSeparator wraps G_UNICODE_PARAGRAPH_SEPARATOR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#paragraph_separator
	//
	UnicodeParagraphSeparator UnicodeType = 28
	// UnicodeSpaceSeparator wraps G_UNICODE_SPACE_SEPARATOR
	// 
	// see also https://docs.gtk.org/glib/flags.UnicodeType.html#space_separator
	//
	UnicodeSpaceSeparator UnicodeType = 29
)


func (e UnicodeType) String() string {
	switch e {
		case UnicodeClosePunctuation: return "UnicodeClosePunctuation"
		case UnicodeConnectPunctuation: return "UnicodeConnectPunctuation"
		case UnicodeControl: return "UnicodeControl"
		case UnicodeCurrencySymbol: return "UnicodeCurrencySymbol"
		case UnicodeDashPunctuation: return "UnicodeDashPunctuation"
		case UnicodeDecimalNumber: return "UnicodeDecimalNumber"
		case UnicodeEnclosingMark: return "UnicodeEnclosingMark"
		case UnicodeFinalPunctuation: return "UnicodeFinalPunctuation"
		case UnicodeFormat: return "UnicodeFormat"
		case UnicodeInitialPunctuation: return "UnicodeInitialPunctuation"
		case UnicodeLetterNumber: return "UnicodeLetterNumber"
		case UnicodeLineSeparator: return "UnicodeLineSeparator"
		case UnicodeLowercaseLetter: return "UnicodeLowercaseLetter"
		case UnicodeMathSymbol: return "UnicodeMathSymbol"
		case UnicodeModifierLetter: return "UnicodeModifierLetter"
		case UnicodeModifierSymbol: return "UnicodeModifierSymbol"
		case UnicodeNonSpacingMark: return "UnicodeNonSpacingMark"
		case UnicodeOpenPunctuation: return "UnicodeOpenPunctuation"
		case UnicodeOtherLetter: return "UnicodeOtherLetter"
		case UnicodeOtherNumber: return "UnicodeOtherNumber"
		case UnicodeOtherPunctuation: return "UnicodeOtherPunctuation"
		case UnicodeOtherSymbol: return "UnicodeOtherSymbol"
		case UnicodeParagraphSeparator: return "UnicodeParagraphSeparator"
		case UnicodePrivateUse: return "UnicodePrivateUse"
		case UnicodeSpaceSeparator: return "UnicodeSpaceSeparator"
		case UnicodeSpacingMark: return "UnicodeSpacingMark"
		case UnicodeSurrogate: return "UnicodeSurrogate"
		case UnicodeTitlecaseLetter: return "UnicodeTitlecaseLetter"
		case UnicodeUnassigned: return "UnicodeUnassigned"
		case UnicodeUppercaseLetter: return "UnicodeUppercaseLetter"
		default: return fmt.Sprintf("UnicodeType(%d)", e)
	}
}

// UriError wraps GUriError
// 
// see also https://docs.gtk.org/glib/enum.UriError.html
//
type UriError C.int

const (
	// URIErrorFailed wraps G_URI_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#failed
	//
	URIErrorFailed UriError = 0
	// URIErrorBadScheme wraps G_URI_ERROR_BAD_SCHEME
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_scheme
	//
	URIErrorBadScheme UriError = 1
	// URIErrorBadUser wraps G_URI_ERROR_BAD_USER
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_user
	//
	URIErrorBadUser UriError = 2
	// URIErrorBadPassword wraps G_URI_ERROR_BAD_PASSWORD
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_password
	//
	URIErrorBadPassword UriError = 3
	// URIErrorBadAuthParams wraps G_URI_ERROR_BAD_AUTH_PARAMS
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_auth_params
	//
	URIErrorBadAuthParams UriError = 4
	// URIErrorBadHost wraps G_URI_ERROR_BAD_HOST
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_host
	//
	URIErrorBadHost UriError = 5
	// URIErrorBadPort wraps G_URI_ERROR_BAD_PORT
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_port
	//
	URIErrorBadPort UriError = 6
	// URIErrorBadPath wraps G_URI_ERROR_BAD_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_path
	//
	URIErrorBadPath UriError = 7
	// URIErrorBadQuery wraps G_URI_ERROR_BAD_QUERY
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_query
	//
	URIErrorBadQuery UriError = 8
	// URIErrorBadFragment wraps G_URI_ERROR_BAD_FRAGMENT
	// 
	// see also https://docs.gtk.org/glib/flags.UriError.html#bad_fragment
	//
	URIErrorBadFragment UriError = 9
)


func (e UriError) String() string {
	switch e {
		case URIErrorBadAuthParams: return "URIErrorBadAuthParams"
		case URIErrorBadFragment: return "URIErrorBadFragment"
		case URIErrorBadHost: return "URIErrorBadHost"
		case URIErrorBadPassword: return "URIErrorBadPassword"
		case URIErrorBadPath: return "URIErrorBadPath"
		case URIErrorBadPort: return "URIErrorBadPort"
		case URIErrorBadQuery: return "URIErrorBadQuery"
		case URIErrorBadScheme: return "URIErrorBadScheme"
		case URIErrorBadUser: return "URIErrorBadUser"
		case URIErrorFailed: return "URIErrorFailed"
		default: return fmt.Sprintf("UriError(%d)", e)
	}
}

// UserDirectory wraps GUserDirectory
// 
// see also https://docs.gtk.org/glib/enum.UserDirectory.html
//
type UserDirectory C.int

const (
	// UserDirectoryDesktop wraps G_USER_DIRECTORY_DESKTOP
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_desktop
	//
	UserDirectoryDesktop UserDirectory = 0
	// UserDirectoryDocuments wraps G_USER_DIRECTORY_DOCUMENTS
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_documents
	//
	UserDirectoryDocuments UserDirectory = 1
	// UserDirectoryDownload wraps G_USER_DIRECTORY_DOWNLOAD
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_download
	//
	UserDirectoryDownload UserDirectory = 2
	// UserDirectoryMusic wraps G_USER_DIRECTORY_MUSIC
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_music
	//
	UserDirectoryMusic UserDirectory = 3
	// UserDirectoryPictures wraps G_USER_DIRECTORY_PICTURES
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_pictures
	//
	UserDirectoryPictures UserDirectory = 4
	// UserDirectoryPublicShare wraps G_USER_DIRECTORY_PUBLIC_SHARE
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_public_share
	//
	UserDirectoryPublicShare UserDirectory = 5
	// UserDirectoryTemplates wraps G_USER_DIRECTORY_TEMPLATES
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_templates
	//
	UserDirectoryTemplates UserDirectory = 6
	// UserDirectoryVideos wraps G_USER_DIRECTORY_VIDEOS
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#directory_videos
	//
	UserDirectoryVideos UserDirectory = 7
	// UserNDirectories wraps G_USER_N_DIRECTORIES
	// 
	// see also https://docs.gtk.org/glib/flags.UserDirectory.html#n_directories
	//
	UserNDirectories UserDirectory = 8
)


func (e UserDirectory) String() string {
	switch e {
		case UserDirectoryDesktop: return "UserDirectoryDesktop"
		case UserDirectoryDocuments: return "UserDirectoryDocuments"
		case UserDirectoryDownload: return "UserDirectoryDownload"
		case UserDirectoryMusic: return "UserDirectoryMusic"
		case UserDirectoryPictures: return "UserDirectoryPictures"
		case UserDirectoryPublicShare: return "UserDirectoryPublicShare"
		case UserDirectoryTemplates: return "UserDirectoryTemplates"
		case UserDirectoryVideos: return "UserDirectoryVideos"
		case UserNDirectories: return "UserNDirectories"
		default: return fmt.Sprintf("UserDirectory(%d)", e)
	}
}

// VariantClass wraps GVariantClass
// 
// see also https://docs.gtk.org/glib/enum.VariantClass.html
//
type VariantClass C.int

const (
	// VariantClassBoolean wraps G_VARIANT_CLASS_BOOLEAN
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#boolean
	//
	VariantClassBoolean VariantClass = 98
	// VariantClassByte wraps G_VARIANT_CLASS_BYTE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#byte
	//
	VariantClassByte VariantClass = 121
	// VariantClassInt16 wraps G_VARIANT_CLASS_INT16
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#int16
	//
	VariantClassInt16 VariantClass = 110
	// VariantClassUint16 wraps G_VARIANT_CLASS_UINT16
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#uint16
	//
	VariantClassUint16 VariantClass = 113
	// VariantClassInt32 wraps G_VARIANT_CLASS_INT32
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#int32
	//
	VariantClassInt32 VariantClass = 105
	// VariantClassUint32 wraps G_VARIANT_CLASS_UINT32
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#uint32
	//
	VariantClassUint32 VariantClass = 117
	// VariantClassInt64 wraps G_VARIANT_CLASS_INT64
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#int64
	//
	VariantClassInt64 VariantClass = 120
	// VariantClassUint64 wraps G_VARIANT_CLASS_UINT64
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#uint64
	//
	VariantClassUint64 VariantClass = 116
	// VariantClassHandle wraps G_VARIANT_CLASS_HANDLE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#handle
	//
	VariantClassHandle VariantClass = 104
	// VariantClassDouble wraps G_VARIANT_CLASS_DOUBLE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#double
	//
	VariantClassDouble VariantClass = 100
	// VariantClassString wraps G_VARIANT_CLASS_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#string
	//
	VariantClassString VariantClass = 115
	// VariantClassObjectPath wraps G_VARIANT_CLASS_OBJECT_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#object_path
	//
	VariantClassObjectPath VariantClass = 111
	// VariantClassSignature wraps G_VARIANT_CLASS_SIGNATURE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#signature
	//
	VariantClassSignature VariantClass = 103
	// VariantClassVariant wraps G_VARIANT_CLASS_VARIANT
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#variant
	//
	VariantClassVariant VariantClass = 118
	// VariantClassMaybe wraps G_VARIANT_CLASS_MAYBE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#maybe
	//
	VariantClassMaybe VariantClass = 109
	// VariantClassArray wraps G_VARIANT_CLASS_ARRAY
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#array
	//
	VariantClassArray VariantClass = 97
	// VariantClassTuple wraps G_VARIANT_CLASS_TUPLE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#tuple
	//
	VariantClassTuple VariantClass = 40
	// VariantClassDictEntry wraps G_VARIANT_CLASS_DICT_ENTRY
	// 
	// see also https://docs.gtk.org/glib/flags.VariantClass.html#dict_entry
	//
	VariantClassDictEntry VariantClass = 123
)


func (e VariantClass) String() string {
	switch e {
		case VariantClassArray: return "VariantClassArray"
		case VariantClassBoolean: return "VariantClassBoolean"
		case VariantClassByte: return "VariantClassByte"
		case VariantClassDictEntry: return "VariantClassDictEntry"
		case VariantClassDouble: return "VariantClassDouble"
		case VariantClassHandle: return "VariantClassHandle"
		case VariantClassInt16: return "VariantClassInt16"
		case VariantClassInt32: return "VariantClassInt32"
		case VariantClassInt64: return "VariantClassInt64"
		case VariantClassMaybe: return "VariantClassMaybe"
		case VariantClassObjectPath: return "VariantClassObjectPath"
		case VariantClassSignature: return "VariantClassSignature"
		case VariantClassString: return "VariantClassString"
		case VariantClassTuple: return "VariantClassTuple"
		case VariantClassUint16: return "VariantClassUint16"
		case VariantClassUint32: return "VariantClassUint32"
		case VariantClassUint64: return "VariantClassUint64"
		case VariantClassVariant: return "VariantClassVariant"
		default: return fmt.Sprintf("VariantClass(%d)", e)
	}
}

// VariantParseError wraps GVariantParseError
// 
// see also https://docs.gtk.org/glib/enum.VariantParseError.html
//
type VariantParseError C.int

const (
	// VariantParseErrorFailed wraps G_VARIANT_PARSE_ERROR_FAILED
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#failed
	//
	VariantParseErrorFailed VariantParseError = 0
	// VariantParseErrorBasicTypeExpected wraps G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#basic_type_expected
	//
	VariantParseErrorBasicTypeExpected VariantParseError = 1
	// VariantParseErrorCannotInferType wraps G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#cannot_infer_type
	//
	VariantParseErrorCannotInferType VariantParseError = 2
	// VariantParseErrorDefiniteTypeExpected wraps G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#definite_type_expected
	//
	VariantParseErrorDefiniteTypeExpected VariantParseError = 3
	// VariantParseErrorInputNotAtEnd wraps G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#input_not_at_end
	//
	VariantParseErrorInputNotAtEnd VariantParseError = 4
	// VariantParseErrorInvalidCharacter wraps G_VARIANT_PARSE_ERROR_INVALID_CHARACTER
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#invalid_character
	//
	VariantParseErrorInvalidCharacter VariantParseError = 5
	// VariantParseErrorInvalidFormatString wraps G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#invalid_format_string
	//
	VariantParseErrorInvalidFormatString VariantParseError = 6
	// VariantParseErrorInvalidObjectPath wraps G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#invalid_object_path
	//
	VariantParseErrorInvalidObjectPath VariantParseError = 7
	// VariantParseErrorInvalidSignature wraps G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#invalid_signature
	//
	VariantParseErrorInvalidSignature VariantParseError = 8
	// VariantParseErrorInvalidTypeString wraps G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#invalid_type_string
	//
	VariantParseErrorInvalidTypeString VariantParseError = 9
	// VariantParseErrorNoCommonType wraps G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#no_common_type
	//
	VariantParseErrorNoCommonType VariantParseError = 10
	// VariantParseErrorNumberOutOfRange wraps G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#number_out_of_range
	//
	VariantParseErrorNumberOutOfRange VariantParseError = 11
	// VariantParseErrorNumberTooBig wraps G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#number_too_big
	//
	VariantParseErrorNumberTooBig VariantParseError = 12
	// VariantParseErrorTypeError wraps G_VARIANT_PARSE_ERROR_TYPE_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#type_error
	//
	VariantParseErrorTypeError VariantParseError = 13
	// VariantParseErrorUnexpectedToken wraps G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#unexpected_token
	//
	VariantParseErrorUnexpectedToken VariantParseError = 14
	// VariantParseErrorUnknownKeyword wraps G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#unknown_keyword
	//
	VariantParseErrorUnknownKeyword VariantParseError = 15
	// VariantParseErrorUnterminatedStringConstant wraps G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#unterminated_string_constant
	//
	VariantParseErrorUnterminatedStringConstant VariantParseError = 16
	// VariantParseErrorValueExpected wraps G_VARIANT_PARSE_ERROR_VALUE_EXPECTED
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#value_expected
	//
	VariantParseErrorValueExpected VariantParseError = 17
	// VariantParseErrorRecursion wraps G_VARIANT_PARSE_ERROR_RECURSION
	// 
	// see also https://docs.gtk.org/glib/flags.VariantParseError.html#recursion
	//
	VariantParseErrorRecursion VariantParseError = 18
)


func (e VariantParseError) String() string {
	switch e {
		case VariantParseErrorBasicTypeExpected: return "VariantParseErrorBasicTypeExpected"
		case VariantParseErrorCannotInferType: return "VariantParseErrorCannotInferType"
		case VariantParseErrorDefiniteTypeExpected: return "VariantParseErrorDefiniteTypeExpected"
		case VariantParseErrorFailed: return "VariantParseErrorFailed"
		case VariantParseErrorInputNotAtEnd: return "VariantParseErrorInputNotAtEnd"
		case VariantParseErrorInvalidCharacter: return "VariantParseErrorInvalidCharacter"
		case VariantParseErrorInvalidFormatString: return "VariantParseErrorInvalidFormatString"
		case VariantParseErrorInvalidObjectPath: return "VariantParseErrorInvalidObjectPath"
		case VariantParseErrorInvalidSignature: return "VariantParseErrorInvalidSignature"
		case VariantParseErrorInvalidTypeString: return "VariantParseErrorInvalidTypeString"
		case VariantParseErrorNoCommonType: return "VariantParseErrorNoCommonType"
		case VariantParseErrorNumberOutOfRange: return "VariantParseErrorNumberOutOfRange"
		case VariantParseErrorNumberTooBig: return "VariantParseErrorNumberTooBig"
		case VariantParseErrorRecursion: return "VariantParseErrorRecursion"
		case VariantParseErrorTypeError: return "VariantParseErrorTypeError"
		case VariantParseErrorUnexpectedToken: return "VariantParseErrorUnexpectedToken"
		case VariantParseErrorUnknownKeyword: return "VariantParseErrorUnknownKeyword"
		case VariantParseErrorUnterminatedStringConstant: return "VariantParseErrorUnterminatedStringConstant"
		case VariantParseErrorValueExpected: return "VariantParseErrorValueExpected"
		default: return fmt.Sprintf("VariantParseError(%d)", e)
	}
}

// AsciiType wraps GAsciiType
// 
// see also https://docs.gtk.org/glib/flags.AsciiType.html
type AsciiType C.gint

const (
	// ASCIIAlnum wraps G_ASCII_ALNUM
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#alnum
	ASCIIAlnum AsciiType = 1
	// ASCIIAlpha wraps G_ASCII_ALPHA
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#alpha
	ASCIIAlpha AsciiType = 2
	// ASCIICntrl wraps G_ASCII_CNTRL
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#cntrl
	ASCIICntrl AsciiType = 4
	// ASCIIDigit wraps G_ASCII_DIGIT
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#digit
	ASCIIDigit AsciiType = 8
	// ASCIIGraph wraps G_ASCII_GRAPH
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#graph
	ASCIIGraph AsciiType = 16
	// ASCIILower wraps G_ASCII_LOWER
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#lower
	ASCIILower AsciiType = 32
	// ASCIIPrint wraps G_ASCII_PRINT
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#print
	ASCIIPrint AsciiType = 64
	// ASCIIPunct wraps G_ASCII_PUNCT
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#punct
	ASCIIPunct AsciiType = 128
	// ASCIISpace wraps G_ASCII_SPACE
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#space
	ASCIISpace AsciiType = 256
	// ASCIIUpper wraps G_ASCII_UPPER
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#upper
	ASCIIUpper AsciiType = 512
	// ASCIIXdigit wraps G_ASCII_XDIGIT
	// 
	// see also https://docs.gtk.org/glib/flags.AsciiType.html#xdigit
	ASCIIXdigit AsciiType = 1024
)

// Has returns true if a contains other
func (a AsciiType) Has(other AsciiType) bool {
	return (a & other) == other
}

func (f AsciiType) String() string {
	if f == 0 {
		return "AsciiType(0)"
	}

	var parts []string
	if (f & ASCIIAlnum) != 0 {
		parts = append(parts, "ASCIIAlnum")
	}
	if (f & ASCIIAlpha) != 0 {
		parts = append(parts, "ASCIIAlpha")
	}
	if (f & ASCIICntrl) != 0 {
		parts = append(parts, "ASCIICntrl")
	}
	if (f & ASCIIDigit) != 0 {
		parts = append(parts, "ASCIIDigit")
	}
	if (f & ASCIIGraph) != 0 {
		parts = append(parts, "ASCIIGraph")
	}
	if (f & ASCIILower) != 0 {
		parts = append(parts, "ASCIILower")
	}
	if (f & ASCIIPrint) != 0 {
		parts = append(parts, "ASCIIPrint")
	}
	if (f & ASCIIPunct) != 0 {
		parts = append(parts, "ASCIIPunct")
	}
	if (f & ASCIISpace) != 0 {
		parts = append(parts, "ASCIISpace")
	}
	if (f & ASCIIUpper) != 0 {
		parts = append(parts, "ASCIIUpper")
	}
	if (f & ASCIIXdigit) != 0 {
		parts = append(parts, "ASCIIXdigit")
	}
	return "AsciiType(" + strings.Join(parts, "|") + ")"
}

// FileSetContentsFlags wraps GFileSetContentsFlags
// 
// see also https://docs.gtk.org/glib/flags.FileSetContentsFlags.html
//
type FileSetContentsFlags C.gint

const (
	// FileSetContentsNone wraps G_FILE_SET_CONTENTS_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.FileSetContentsFlags.html#none
	//
	FileSetContentsNone FileSetContentsFlags = 0
	// FileSetContentsConsistent wraps G_FILE_SET_CONTENTS_CONSISTENT
	// 
	// see also https://docs.gtk.org/glib/flags.FileSetContentsFlags.html#consistent
	//
	FileSetContentsConsistent FileSetContentsFlags = 1
	// FileSetContentsDurable wraps G_FILE_SET_CONTENTS_DURABLE
	// 
	// see also https://docs.gtk.org/glib/flags.FileSetContentsFlags.html#durable
	//
	FileSetContentsDurable FileSetContentsFlags = 2
	// FileSetContentsOnlyExisting wraps G_FILE_SET_CONTENTS_ONLY_EXISTING
	// 
	// see also https://docs.gtk.org/glib/flags.FileSetContentsFlags.html#only_existing
	//
	FileSetContentsOnlyExisting FileSetContentsFlags = 4
)

// Has returns true if f contains other
func (f FileSetContentsFlags) Has(other FileSetContentsFlags) bool {
	return (f & other) == other
}

func (f FileSetContentsFlags) String() string {
	if f == 0 {
		return "FileSetContentsFlags(0)"
	}

	var parts []string
	if (f & FileSetContentsNone) != 0 {
		parts = append(parts, "FileSetContentsNone")
	}
	if (f & FileSetContentsConsistent) != 0 {
		parts = append(parts, "FileSetContentsConsistent")
	}
	if (f & FileSetContentsDurable) != 0 {
		parts = append(parts, "FileSetContentsDurable")
	}
	if (f & FileSetContentsOnlyExisting) != 0 {
		parts = append(parts, "FileSetContentsOnlyExisting")
	}
	return "FileSetContentsFlags(" + strings.Join(parts, "|") + ")"
}

// FileTest wraps GFileTest
// 
// see also https://docs.gtk.org/glib/flags.FileTest.html
//
type FileTest C.gint

const (
	// FileTestIsRegular wraps G_FILE_TEST_IS_REGULAR
	// 
	// see also https://docs.gtk.org/glib/flags.FileTest.html#is_regular
	//
	FileTestIsRegular FileTest = 1
	// FileTestIsSymlink wraps G_FILE_TEST_IS_SYMLINK
	// 
	// see also https://docs.gtk.org/glib/flags.FileTest.html#is_symlink
	//
	FileTestIsSymlink FileTest = 2
	// FileTestIsDir wraps G_FILE_TEST_IS_DIR
	// 
	// see also https://docs.gtk.org/glib/flags.FileTest.html#is_dir
	//
	FileTestIsDir FileTest = 4
	// FileTestIsExecutable wraps G_FILE_TEST_IS_EXECUTABLE
	// 
	// see also https://docs.gtk.org/glib/flags.FileTest.html#is_executable
	//
	FileTestIsExecutable FileTest = 8
	// FileTestExists wraps G_FILE_TEST_EXISTS
	// 
	// see also https://docs.gtk.org/glib/flags.FileTest.html#exists
	//
	FileTestExists FileTest = 16
)

// Has returns true if f contains other
func (f FileTest) Has(other FileTest) bool {
	return (f & other) == other
}

func (f FileTest) String() string {
	if f == 0 {
		return "FileTest(0)"
	}

	var parts []string
	if (f & FileTestIsRegular) != 0 {
		parts = append(parts, "FileTestIsRegular")
	}
	if (f & FileTestIsSymlink) != 0 {
		parts = append(parts, "FileTestIsSymlink")
	}
	if (f & FileTestIsDir) != 0 {
		parts = append(parts, "FileTestIsDir")
	}
	if (f & FileTestIsExecutable) != 0 {
		parts = append(parts, "FileTestIsExecutable")
	}
	if (f & FileTestExists) != 0 {
		parts = append(parts, "FileTestExists")
	}
	return "FileTest(" + strings.Join(parts, "|") + ")"
}

// FormatSizeFlags wraps GFormatSizeFlags
// 
// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html
//
type FormatSizeFlags C.gint

const (
	// FormatSizeDefault wraps G_FORMAT_SIZE_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#default
	//
	FormatSizeDefault FormatSizeFlags = 0
	// FormatSizeLongFormat wraps G_FORMAT_SIZE_LONG_FORMAT
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#long_format
	//
	FormatSizeLongFormat FormatSizeFlags = 1
	// FormatSizeIecUnits wraps G_FORMAT_SIZE_IEC_UNITS
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#iec_units
	//
	FormatSizeIecUnits FormatSizeFlags = 2
	// FormatSizeBits wraps G_FORMAT_SIZE_BITS
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#bits
	//
	FormatSizeBits FormatSizeFlags = 4
	// FormatSizeOnlyValue wraps G_FORMAT_SIZE_ONLY_VALUE
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#only_value
	//
	FormatSizeOnlyValue FormatSizeFlags = 8
	// FormatSizeOnlyUnit wraps G_FORMAT_SIZE_ONLY_UNIT
	// 
	// see also https://docs.gtk.org/glib/flags.FormatSizeFlags.html#only_unit
	//
	FormatSizeOnlyUnit FormatSizeFlags = 16
)

// Has returns true if f contains other
func (f FormatSizeFlags) Has(other FormatSizeFlags) bool {
	return (f & other) == other
}

func (f FormatSizeFlags) String() string {
	if f == 0 {
		return "FormatSizeFlags(0)"
	}

	var parts []string
	if (f & FormatSizeDefault) != 0 {
		parts = append(parts, "FormatSizeDefault")
	}
	if (f & FormatSizeLongFormat) != 0 {
		parts = append(parts, "FormatSizeLongFormat")
	}
	if (f & FormatSizeIecUnits) != 0 {
		parts = append(parts, "FormatSizeIecUnits")
	}
	if (f & FormatSizeBits) != 0 {
		parts = append(parts, "FormatSizeBits")
	}
	if (f & FormatSizeOnlyValue) != 0 {
		parts = append(parts, "FormatSizeOnlyValue")
	}
	if (f & FormatSizeOnlyUnit) != 0 {
		parts = append(parts, "FormatSizeOnlyUnit")
	}
	return "FormatSizeFlags(" + strings.Join(parts, "|") + ")"
}

// IOCondition wraps GIOCondition
// 
// see also https://docs.gtk.org/glib/flags.IOCondition.html
//
type IOCondition C.gint

const (
	// IOIn wraps G_IO_IN
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#in
	//
	IOIn IOCondition = 1
	// IOOut wraps G_IO_OUT
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#out
	//
	IOOut IOCondition = 4
	// IOPri wraps G_IO_PRI
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#pri
	//
	IOPri IOCondition = 2
	// IOErr wraps G_IO_ERR
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#err
	//
	IOErr IOCondition = 8
	// IOHup wraps G_IO_HUP
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#hup
	//
	IOHup IOCondition = 16
	// IONval wraps G_IO_NVAL
	// 
	// see also https://docs.gtk.org/glib/flags.IOCondition.html#nval
	//
	IONval IOCondition = 32
)

// Has returns true if i contains other
func (i IOCondition) Has(other IOCondition) bool {
	return (i & other) == other
}

func (f IOCondition) String() string {
	if f == 0 {
		return "IOCondition(0)"
	}

	var parts []string
	if (f & IOIn) != 0 {
		parts = append(parts, "IOIn")
	}
	if (f & IOOut) != 0 {
		parts = append(parts, "IOOut")
	}
	if (f & IOPri) != 0 {
		parts = append(parts, "IOPri")
	}
	if (f & IOErr) != 0 {
		parts = append(parts, "IOErr")
	}
	if (f & IOHup) != 0 {
		parts = append(parts, "IOHup")
	}
	if (f & IONval) != 0 {
		parts = append(parts, "IONval")
	}
	return "IOCondition(" + strings.Join(parts, "|") + ")"
}

// IOFlags wraps GIOFlags
// 
// see also https://docs.gtk.org/glib/flags.IOFlags.html
//
type IOFlags C.gint

const (
	// IOFlagNone wraps G_IO_FLAG_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#none
	//
	IOFlagNone IOFlags = 0
	// IOFlagAppend wraps G_IO_FLAG_APPEND
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#append
	//
	IOFlagAppend IOFlags = 1
	// IOFlagNonblock wraps G_IO_FLAG_NONBLOCK
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#nonblock
	//
	IOFlagNonblock IOFlags = 2
	// IOFlagIsReadable wraps G_IO_FLAG_IS_READABLE
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#is_readable
	//
	IOFlagIsReadable IOFlags = 4
	// IOFlagIsWritable wraps G_IO_FLAG_IS_WRITABLE
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#is_writable
	//
	IOFlagIsWritable IOFlags = 8
	// IOFlagIsWriteable wraps G_IO_FLAG_IS_WRITEABLE
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#is_writeable
	//
	IOFlagIsWriteable IOFlags = 8
	// IOFlagIsSeekable wraps G_IO_FLAG_IS_SEEKABLE
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#is_seekable
	//
	IOFlagIsSeekable IOFlags = 16
	// IOFlagMask wraps G_IO_FLAG_MASK
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#mask
	//
	IOFlagMask IOFlags = 31
	// IOFlagGetMask wraps G_IO_FLAG_GET_MASK
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#get_mask
	//
	IOFlagGetMask IOFlags = 31
	// IOFlagSetMask wraps G_IO_FLAG_SET_MASK
	// 
	// see also https://docs.gtk.org/glib/flags.IOFlags.html#set_mask
	//
	IOFlagSetMask IOFlags = 3
)

// Has returns true if i contains other
func (i IOFlags) Has(other IOFlags) bool {
	return (i & other) == other
}

func (f IOFlags) String() string {
	if f == 0 {
		return "IOFlags(0)"
	}

	var parts []string
	if (f & IOFlagNone) != 0 {
		parts = append(parts, "IOFlagNone")
	}
	if (f & IOFlagAppend) != 0 {
		parts = append(parts, "IOFlagAppend")
	}
	if (f & IOFlagNonblock) != 0 {
		parts = append(parts, "IOFlagNonblock")
	}
	if (f & IOFlagIsReadable) != 0 {
		parts = append(parts, "IOFlagIsReadable")
	}
	if (f & IOFlagIsWritable) != 0 {
		parts = append(parts, "IOFlagIsWritable")
	}
	if (f & IOFlagIsWriteable) != 0 {
		parts = append(parts, "IOFlagIsWriteable")
	}
	if (f & IOFlagIsSeekable) != 0 {
		parts = append(parts, "IOFlagIsSeekable")
	}
	if (f & IOFlagMask) != 0 {
		parts = append(parts, "IOFlagMask")
	}
	if (f & IOFlagGetMask) != 0 {
		parts = append(parts, "IOFlagGetMask")
	}
	if (f & IOFlagSetMask) != 0 {
		parts = append(parts, "IOFlagSetMask")
	}
	return "IOFlags(" + strings.Join(parts, "|") + ")"
}

// KeyFileFlags wraps GKeyFileFlags
// 
// see also https://docs.gtk.org/glib/flags.KeyFileFlags.html
//
type KeyFileFlags C.gint

const (
	// KeyFileNone wraps G_KEY_FILE_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileFlags.html#none
	//
	KeyFileNone KeyFileFlags = 0
	// KeyFileKeepComments wraps G_KEY_FILE_KEEP_COMMENTS
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileFlags.html#keep_comments
	//
	KeyFileKeepComments KeyFileFlags = 1
	// KeyFileKeepTranslations wraps G_KEY_FILE_KEEP_TRANSLATIONS
	// 
	// see also https://docs.gtk.org/glib/flags.KeyFileFlags.html#keep_translations
	//
	KeyFileKeepTranslations KeyFileFlags = 2
)

// Has returns true if k contains other
func (k KeyFileFlags) Has(other KeyFileFlags) bool {
	return (k & other) == other
}

func (f KeyFileFlags) String() string {
	if f == 0 {
		return "KeyFileFlags(0)"
	}

	var parts []string
	if (f & KeyFileNone) != 0 {
		parts = append(parts, "KeyFileNone")
	}
	if (f & KeyFileKeepComments) != 0 {
		parts = append(parts, "KeyFileKeepComments")
	}
	if (f & KeyFileKeepTranslations) != 0 {
		parts = append(parts, "KeyFileKeepTranslations")
	}
	return "KeyFileFlags(" + strings.Join(parts, "|") + ")"
}

// LogLevelFlags wraps GLogLevelFlags
// 
// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html
//
type LogLevelFlags C.gint

const (
	// LogFlagRecursion wraps G_LOG_FLAG_RECURSION
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#flag_recursion
	//
	LogFlagRecursion LogLevelFlags = 1
	// LogFlagFatal wraps G_LOG_FLAG_FATAL
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#flag_fatal
	//
	LogFlagFatal LogLevelFlags = 2
	// LogLevelError wraps G_LOG_LEVEL_ERROR
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_error
	//
	LogLevelError LogLevelFlags = 4
	// LogLevelCritical wraps G_LOG_LEVEL_CRITICAL
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_critical
	//
	LogLevelCritical LogLevelFlags = 8
	// LogLevelWarning wraps G_LOG_LEVEL_WARNING
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_warning
	//
	LogLevelWarning LogLevelFlags = 16
	// LogLevelMessage wraps G_LOG_LEVEL_MESSAGE
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_message
	//
	LogLevelMessage LogLevelFlags = 32
	// LogLevelInfo wraps G_LOG_LEVEL_INFO
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_info
	//
	LogLevelInfo LogLevelFlags = 64
	// LogLevelDebug wraps G_LOG_LEVEL_DEBUG
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_debug
	//
	LogLevelDebug LogLevelFlags = 128
	// LogLevelMask wraps G_LOG_LEVEL_MASK
	// 
	// see also https://docs.gtk.org/glib/flags.LogLevelFlags.html#level_mask
	//
	LogLevelMask LogLevelFlags = -4
)

// Has returns true if l contains other
func (l LogLevelFlags) Has(other LogLevelFlags) bool {
	return (l & other) == other
}

func (f LogLevelFlags) String() string {
	if f == 0 {
		return "LogLevelFlags(0)"
	}

	var parts []string
	if (f & LogFlagRecursion) != 0 {
		parts = append(parts, "LogFlagRecursion")
	}
	if (f & LogFlagFatal) != 0 {
		parts = append(parts, "LogFlagFatal")
	}
	if (f & LogLevelError) != 0 {
		parts = append(parts, "LogLevelError")
	}
	if (f & LogLevelCritical) != 0 {
		parts = append(parts, "LogLevelCritical")
	}
	if (f & LogLevelWarning) != 0 {
		parts = append(parts, "LogLevelWarning")
	}
	if (f & LogLevelMessage) != 0 {
		parts = append(parts, "LogLevelMessage")
	}
	if (f & LogLevelInfo) != 0 {
		parts = append(parts, "LogLevelInfo")
	}
	if (f & LogLevelDebug) != 0 {
		parts = append(parts, "LogLevelDebug")
	}
	if (f & LogLevelMask) != 0 {
		parts = append(parts, "LogLevelMask")
	}
	return "LogLevelFlags(" + strings.Join(parts, "|") + ")"
}

// MainContextFlags wraps GMainContextFlags
// 
// see also https://docs.gtk.org/glib/flags.MainContextFlags.html
//
type MainContextFlags C.gint

const (
	// MainContextFlagsNone wraps G_MAIN_CONTEXT_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.MainContextFlags.html#none
	//
	MainContextFlagsNone MainContextFlags = 0
	// MainContextFlagsOwnerlessPolling wraps G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING
	// 
	// see also https://docs.gtk.org/glib/flags.MainContextFlags.html#ownerless_polling
	//
	MainContextFlagsOwnerlessPolling MainContextFlags = 1
)

// Has returns true if m contains other
func (m MainContextFlags) Has(other MainContextFlags) bool {
	return (m & other) == other
}

func (f MainContextFlags) String() string {
	if f == 0 {
		return "MainContextFlags(0)"
	}

	var parts []string
	if (f & MainContextFlagsNone) != 0 {
		parts = append(parts, "MainContextFlagsNone")
	}
	if (f & MainContextFlagsOwnerlessPolling) != 0 {
		parts = append(parts, "MainContextFlagsOwnerlessPolling")
	}
	return "MainContextFlags(" + strings.Join(parts, "|") + ")"
}

// MarkupCollectType wraps GMarkupCollectType
// 
// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html
//
type MarkupCollectType C.gint

const (
	// MarkupCollectInvalid wraps G_MARKUP_COLLECT_INVALID
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#invalid
	//
	MarkupCollectInvalid MarkupCollectType = 0
	// MarkupCollectString wraps G_MARKUP_COLLECT_STRING
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#string
	//
	MarkupCollectString MarkupCollectType = 1
	// MarkupCollectStrdup wraps G_MARKUP_COLLECT_STRDUP
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#strdup
	//
	MarkupCollectStrdup MarkupCollectType = 2
	// MarkupCollectBoolean wraps G_MARKUP_COLLECT_BOOLEAN
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#boolean
	//
	MarkupCollectBoolean MarkupCollectType = 3
	// MarkupCollectTristate wraps G_MARKUP_COLLECT_TRISTATE
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#tristate
	//
	MarkupCollectTristate MarkupCollectType = 4
	// MarkupCollectOptional wraps G_MARKUP_COLLECT_OPTIONAL
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupCollectType.html#optional
	//
	MarkupCollectOptional MarkupCollectType = 65536
)

// Has returns true if m contains other
func (m MarkupCollectType) Has(other MarkupCollectType) bool {
	return (m & other) == other
}

func (f MarkupCollectType) String() string {
	if f == 0 {
		return "MarkupCollectType(0)"
	}

	var parts []string
	if (f & MarkupCollectInvalid) != 0 {
		parts = append(parts, "MarkupCollectInvalid")
	}
	if (f & MarkupCollectString) != 0 {
		parts = append(parts, "MarkupCollectString")
	}
	if (f & MarkupCollectStrdup) != 0 {
		parts = append(parts, "MarkupCollectStrdup")
	}
	if (f & MarkupCollectBoolean) != 0 {
		parts = append(parts, "MarkupCollectBoolean")
	}
	if (f & MarkupCollectTristate) != 0 {
		parts = append(parts, "MarkupCollectTristate")
	}
	if (f & MarkupCollectOptional) != 0 {
		parts = append(parts, "MarkupCollectOptional")
	}
	return "MarkupCollectType(" + strings.Join(parts, "|") + ")"
}

// MarkupParseFlags wraps GMarkupParseFlags
// 
// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html
//
type MarkupParseFlags C.gint

const (
	// MarkupDefaultFlags wraps G_MARKUP_DEFAULT_FLAGS
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html#default_flags
	//
	MarkupDefaultFlags MarkupParseFlags = 0
	// MarkupDoNotUseThisUnsupportedFlag wraps G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html#do_not_use_this_unsupported_flag
	//
	MarkupDoNotUseThisUnsupportedFlag MarkupParseFlags = 1
	// MarkupTreatCdataAsText wraps G_MARKUP_TREAT_CDATA_AS_TEXT
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html#treat_cdata_as_text
	//
	MarkupTreatCdataAsText MarkupParseFlags = 2
	// MarkupPrefixErrorPosition wraps G_MARKUP_PREFIX_ERROR_POSITION
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html#prefix_error_position
	//
	MarkupPrefixErrorPosition MarkupParseFlags = 4
	// MarkupIgnoreQualified wraps G_MARKUP_IGNORE_QUALIFIED
	// 
	// see also https://docs.gtk.org/glib/flags.MarkupParseFlags.html#ignore_qualified
	//
	MarkupIgnoreQualified MarkupParseFlags = 8
)

// Has returns true if m contains other
func (m MarkupParseFlags) Has(other MarkupParseFlags) bool {
	return (m & other) == other
}

func (f MarkupParseFlags) String() string {
	if f == 0 {
		return "MarkupParseFlags(0)"
	}

	var parts []string
	if (f & MarkupDefaultFlags) != 0 {
		parts = append(parts, "MarkupDefaultFlags")
	}
	if (f & MarkupDoNotUseThisUnsupportedFlag) != 0 {
		parts = append(parts, "MarkupDoNotUseThisUnsupportedFlag")
	}
	if (f & MarkupTreatCdataAsText) != 0 {
		parts = append(parts, "MarkupTreatCdataAsText")
	}
	if (f & MarkupPrefixErrorPosition) != 0 {
		parts = append(parts, "MarkupPrefixErrorPosition")
	}
	if (f & MarkupIgnoreQualified) != 0 {
		parts = append(parts, "MarkupIgnoreQualified")
	}
	return "MarkupParseFlags(" + strings.Join(parts, "|") + ")"
}

// OptionFlags wraps GOptionFlags
// 
// see also https://docs.gtk.org/glib/flags.OptionFlags.html
//
type OptionFlags C.gint

const (
	// OptionFlagNone wraps G_OPTION_FLAG_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#none
	//
	OptionFlagNone OptionFlags = 0
	// OptionFlagHidden wraps G_OPTION_FLAG_HIDDEN
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#hidden
	//
	OptionFlagHidden OptionFlags = 1
	// OptionFlagInMain wraps G_OPTION_FLAG_IN_MAIN
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#in_main
	//
	OptionFlagInMain OptionFlags = 2
	// OptionFlagReverse wraps G_OPTION_FLAG_REVERSE
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#reverse
	//
	OptionFlagReverse OptionFlags = 4
	// OptionFlagNoArg wraps G_OPTION_FLAG_NO_ARG
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#no_arg
	//
	OptionFlagNoArg OptionFlags = 8
	// OptionFlagFilename wraps G_OPTION_FLAG_FILENAME
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#filename
	//
	OptionFlagFilename OptionFlags = 16
	// OptionFlagOptionalArg wraps G_OPTION_FLAG_OPTIONAL_ARG
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#optional_arg
	//
	OptionFlagOptionalArg OptionFlags = 32
	// OptionFlagNoalias wraps G_OPTION_FLAG_NOALIAS
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#noalias
	//
	OptionFlagNoalias OptionFlags = 64
	// OptionFlagDeprecated wraps G_OPTION_FLAG_DEPRECATED
	// 
	// see also https://docs.gtk.org/glib/flags.OptionFlags.html#deprecated
	//
	OptionFlagDeprecated OptionFlags = 128
)

// Has returns true if o contains other
func (o OptionFlags) Has(other OptionFlags) bool {
	return (o & other) == other
}

func (f OptionFlags) String() string {
	if f == 0 {
		return "OptionFlags(0)"
	}

	var parts []string
	if (f & OptionFlagNone) != 0 {
		parts = append(parts, "OptionFlagNone")
	}
	if (f & OptionFlagHidden) != 0 {
		parts = append(parts, "OptionFlagHidden")
	}
	if (f & OptionFlagInMain) != 0 {
		parts = append(parts, "OptionFlagInMain")
	}
	if (f & OptionFlagReverse) != 0 {
		parts = append(parts, "OptionFlagReverse")
	}
	if (f & OptionFlagNoArg) != 0 {
		parts = append(parts, "OptionFlagNoArg")
	}
	if (f & OptionFlagFilename) != 0 {
		parts = append(parts, "OptionFlagFilename")
	}
	if (f & OptionFlagOptionalArg) != 0 {
		parts = append(parts, "OptionFlagOptionalArg")
	}
	if (f & OptionFlagNoalias) != 0 {
		parts = append(parts, "OptionFlagNoalias")
	}
	if (f & OptionFlagDeprecated) != 0 {
		parts = append(parts, "OptionFlagDeprecated")
	}
	return "OptionFlags(" + strings.Join(parts, "|") + ")"
}

// RegexCompileFlags wraps GRegexCompileFlags
// 
// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html
//
type RegexCompileFlags C.gint

const (
	// RegexDefault wraps G_REGEX_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#default
	//
	RegexDefault RegexCompileFlags = 0
	// RegexCaseless wraps G_REGEX_CASELESS
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#caseless
	//
	RegexCaseless RegexCompileFlags = 1
	// RegexMultiline wraps G_REGEX_MULTILINE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#multiline
	//
	RegexMultiline RegexCompileFlags = 2
	// RegexDotall wraps G_REGEX_DOTALL
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#dotall
	//
	RegexDotall RegexCompileFlags = 4
	// RegexExtended wraps G_REGEX_EXTENDED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#extended
	//
	RegexExtended RegexCompileFlags = 8
	// RegexAnchored wraps G_REGEX_ANCHORED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#anchored
	//
	RegexAnchored RegexCompileFlags = 16
	// RegexDollarEndonly wraps G_REGEX_DOLLAR_ENDONLY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#dollar_endonly
	//
	RegexDollarEndonly RegexCompileFlags = 32
	// RegexUngreedy wraps G_REGEX_UNGREEDY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#ungreedy
	//
	RegexUngreedy RegexCompileFlags = 512
	// RegexRaw wraps G_REGEX_RAW
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#raw
	//
	RegexRaw RegexCompileFlags = 2048
	// RegexNoAutoCapture wraps G_REGEX_NO_AUTO_CAPTURE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#no_auto_capture
	//
	RegexNoAutoCapture RegexCompileFlags = 4096
	// RegexOptimize wraps G_REGEX_OPTIMIZE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#optimize
	//
	RegexOptimize RegexCompileFlags = 8192
	// RegexFirstline wraps G_REGEX_FIRSTLINE
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#firstline
	//
	RegexFirstline RegexCompileFlags = 262144
	// RegexDupnames wraps G_REGEX_DUPNAMES
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#dupnames
	//
	RegexDupnames RegexCompileFlags = 524288
	// RegexNewlineCr wraps G_REGEX_NEWLINE_CR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#newline_cr
	//
	RegexNewlineCr RegexCompileFlags = 1048576
	// RegexNewlineLf wraps G_REGEX_NEWLINE_LF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#newline_lf
	//
	RegexNewlineLf RegexCompileFlags = 2097152
	// RegexNewlineCrlf wraps G_REGEX_NEWLINE_CRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#newline_crlf
	//
	RegexNewlineCrlf RegexCompileFlags = 3145728
	// RegexNewlineAnycrlf wraps G_REGEX_NEWLINE_ANYCRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#newline_anycrlf
	//
	RegexNewlineAnycrlf RegexCompileFlags = 5242880
	// RegexBsrAnycrlf wraps G_REGEX_BSR_ANYCRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#bsr_anycrlf
	//
	RegexBsrAnycrlf RegexCompileFlags = 8388608
	// RegexJavascriptCompat wraps G_REGEX_JAVASCRIPT_COMPAT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexCompileFlags.html#javascript_compat
	//
	RegexJavascriptCompat RegexCompileFlags = 33554432
)

// Has returns true if r contains other
func (r RegexCompileFlags) Has(other RegexCompileFlags) bool {
	return (r & other) == other
}

func (f RegexCompileFlags) String() string {
	if f == 0 {
		return "RegexCompileFlags(0)"
	}

	var parts []string
	if (f & RegexDefault) != 0 {
		parts = append(parts, "RegexDefault")
	}
	if (f & RegexCaseless) != 0 {
		parts = append(parts, "RegexCaseless")
	}
	if (f & RegexMultiline) != 0 {
		parts = append(parts, "RegexMultiline")
	}
	if (f & RegexDotall) != 0 {
		parts = append(parts, "RegexDotall")
	}
	if (f & RegexExtended) != 0 {
		parts = append(parts, "RegexExtended")
	}
	if (f & RegexAnchored) != 0 {
		parts = append(parts, "RegexAnchored")
	}
	if (f & RegexDollarEndonly) != 0 {
		parts = append(parts, "RegexDollarEndonly")
	}
	if (f & RegexUngreedy) != 0 {
		parts = append(parts, "RegexUngreedy")
	}
	if (f & RegexRaw) != 0 {
		parts = append(parts, "RegexRaw")
	}
	if (f & RegexNoAutoCapture) != 0 {
		parts = append(parts, "RegexNoAutoCapture")
	}
	if (f & RegexOptimize) != 0 {
		parts = append(parts, "RegexOptimize")
	}
	if (f & RegexFirstline) != 0 {
		parts = append(parts, "RegexFirstline")
	}
	if (f & RegexDupnames) != 0 {
		parts = append(parts, "RegexDupnames")
	}
	if (f & RegexNewlineCr) != 0 {
		parts = append(parts, "RegexNewlineCr")
	}
	if (f & RegexNewlineLf) != 0 {
		parts = append(parts, "RegexNewlineLf")
	}
	if (f & RegexNewlineCrlf) != 0 {
		parts = append(parts, "RegexNewlineCrlf")
	}
	if (f & RegexNewlineAnycrlf) != 0 {
		parts = append(parts, "RegexNewlineAnycrlf")
	}
	if (f & RegexBsrAnycrlf) != 0 {
		parts = append(parts, "RegexBsrAnycrlf")
	}
	if (f & RegexJavascriptCompat) != 0 {
		parts = append(parts, "RegexJavascriptCompat")
	}
	return "RegexCompileFlags(" + strings.Join(parts, "|") + ")"
}

// RegexMatchFlags wraps GRegexMatchFlags
// 
// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html
//
type RegexMatchFlags C.gint

const (
	// RegexMatchDefault wraps G_REGEX_MATCH_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#default
	//
	RegexMatchDefault RegexMatchFlags = 0
	// RegexMatchAnchored wraps G_REGEX_MATCH_ANCHORED
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#anchored
	//
	RegexMatchAnchored RegexMatchFlags = 16
	// RegexMatchNotbol wraps G_REGEX_MATCH_NOTBOL
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#notbol
	//
	RegexMatchNotbol RegexMatchFlags = 128
	// RegexMatchNoteol wraps G_REGEX_MATCH_NOTEOL
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#noteol
	//
	RegexMatchNoteol RegexMatchFlags = 256
	// RegexMatchNotempty wraps G_REGEX_MATCH_NOTEMPTY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#notempty
	//
	RegexMatchNotempty RegexMatchFlags = 1024
	// RegexMatchPartial wraps G_REGEX_MATCH_PARTIAL
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#partial
	//
	RegexMatchPartial RegexMatchFlags = 32768
	// RegexMatchNewlineCr wraps G_REGEX_MATCH_NEWLINE_CR
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#newline_cr
	//
	RegexMatchNewlineCr RegexMatchFlags = 1048576
	// RegexMatchNewlineLf wraps G_REGEX_MATCH_NEWLINE_LF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#newline_lf
	//
	RegexMatchNewlineLf RegexMatchFlags = 2097152
	// RegexMatchNewlineCrlf wraps G_REGEX_MATCH_NEWLINE_CRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#newline_crlf
	//
	RegexMatchNewlineCrlf RegexMatchFlags = 3145728
	// RegexMatchNewlineAny wraps G_REGEX_MATCH_NEWLINE_ANY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#newline_any
	//
	RegexMatchNewlineAny RegexMatchFlags = 4194304
	// RegexMatchNewlineAnycrlf wraps G_REGEX_MATCH_NEWLINE_ANYCRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#newline_anycrlf
	//
	RegexMatchNewlineAnycrlf RegexMatchFlags = 5242880
	// RegexMatchBsrAnycrlf wraps G_REGEX_MATCH_BSR_ANYCRLF
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#bsr_anycrlf
	//
	RegexMatchBsrAnycrlf RegexMatchFlags = 8388608
	// RegexMatchBsrAny wraps G_REGEX_MATCH_BSR_ANY
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#bsr_any
	//
	RegexMatchBsrAny RegexMatchFlags = 16777216
	// RegexMatchPartialSoft wraps G_REGEX_MATCH_PARTIAL_SOFT
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#partial_soft
	//
	RegexMatchPartialSoft RegexMatchFlags = 32768
	// RegexMatchPartialHard wraps G_REGEX_MATCH_PARTIAL_HARD
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#partial_hard
	//
	RegexMatchPartialHard RegexMatchFlags = 134217728
	// RegexMatchNotemptyAtstart wraps G_REGEX_MATCH_NOTEMPTY_ATSTART
	// 
	// see also https://docs.gtk.org/glib/flags.RegexMatchFlags.html#notempty_atstart
	//
	RegexMatchNotemptyAtstart RegexMatchFlags = 268435456
)

// Has returns true if r contains other
func (r RegexMatchFlags) Has(other RegexMatchFlags) bool {
	return (r & other) == other
}

func (f RegexMatchFlags) String() string {
	if f == 0 {
		return "RegexMatchFlags(0)"
	}

	var parts []string
	if (f & RegexMatchDefault) != 0 {
		parts = append(parts, "RegexMatchDefault")
	}
	if (f & RegexMatchAnchored) != 0 {
		parts = append(parts, "RegexMatchAnchored")
	}
	if (f & RegexMatchNotbol) != 0 {
		parts = append(parts, "RegexMatchNotbol")
	}
	if (f & RegexMatchNoteol) != 0 {
		parts = append(parts, "RegexMatchNoteol")
	}
	if (f & RegexMatchNotempty) != 0 {
		parts = append(parts, "RegexMatchNotempty")
	}
	if (f & RegexMatchPartial) != 0 {
		parts = append(parts, "RegexMatchPartial")
	}
	if (f & RegexMatchNewlineCr) != 0 {
		parts = append(parts, "RegexMatchNewlineCr")
	}
	if (f & RegexMatchNewlineLf) != 0 {
		parts = append(parts, "RegexMatchNewlineLf")
	}
	if (f & RegexMatchNewlineCrlf) != 0 {
		parts = append(parts, "RegexMatchNewlineCrlf")
	}
	if (f & RegexMatchNewlineAny) != 0 {
		parts = append(parts, "RegexMatchNewlineAny")
	}
	if (f & RegexMatchNewlineAnycrlf) != 0 {
		parts = append(parts, "RegexMatchNewlineAnycrlf")
	}
	if (f & RegexMatchBsrAnycrlf) != 0 {
		parts = append(parts, "RegexMatchBsrAnycrlf")
	}
	if (f & RegexMatchBsrAny) != 0 {
		parts = append(parts, "RegexMatchBsrAny")
	}
	if (f & RegexMatchPartialSoft) != 0 {
		parts = append(parts, "RegexMatchPartialSoft")
	}
	if (f & RegexMatchPartialHard) != 0 {
		parts = append(parts, "RegexMatchPartialHard")
	}
	if (f & RegexMatchNotemptyAtstart) != 0 {
		parts = append(parts, "RegexMatchNotemptyAtstart")
	}
	return "RegexMatchFlags(" + strings.Join(parts, "|") + ")"
}

// SpawnFlags wraps GSpawnFlags
// 
// see also https://docs.gtk.org/glib/flags.SpawnFlags.html
//
type SpawnFlags C.gint

const (
	// SpawnDefault wraps G_SPAWN_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#default
	//
	SpawnDefault SpawnFlags = 0
	// SpawnLeaveDescriptorsOpen wraps G_SPAWN_LEAVE_DESCRIPTORS_OPEN
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#leave_descriptors_open
	//
	SpawnLeaveDescriptorsOpen SpawnFlags = 1
	// SpawnDoNotReapChild wraps G_SPAWN_DO_NOT_REAP_CHILD
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#do_not_reap_child
	//
	SpawnDoNotReapChild SpawnFlags = 2
	// SpawnSearchPath wraps G_SPAWN_SEARCH_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#search_path
	//
	SpawnSearchPath SpawnFlags = 4
	// SpawnStdoutToDevNull wraps G_SPAWN_STDOUT_TO_DEV_NULL
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#stdout_to_dev_null
	//
	SpawnStdoutToDevNull SpawnFlags = 8
	// SpawnStderrToDevNull wraps G_SPAWN_STDERR_TO_DEV_NULL
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#stderr_to_dev_null
	//
	SpawnStderrToDevNull SpawnFlags = 16
	// SpawnChildInheritsStdin wraps G_SPAWN_CHILD_INHERITS_STDIN
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#child_inherits_stdin
	//
	SpawnChildInheritsStdin SpawnFlags = 32
	// SpawnFileAndArgvZero wraps G_SPAWN_FILE_AND_ARGV_ZERO
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#file_and_argv_zero
	//
	SpawnFileAndArgvZero SpawnFlags = 64
	// SpawnSearchPathFromEnvp wraps G_SPAWN_SEARCH_PATH_FROM_ENVP
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#search_path_from_envp
	//
	SpawnSearchPathFromEnvp SpawnFlags = 128
	// SpawnCloexecPipes wraps G_SPAWN_CLOEXEC_PIPES
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#cloexec_pipes
	//
	SpawnCloexecPipes SpawnFlags = 256
	// SpawnChildInheritsStdout wraps G_SPAWN_CHILD_INHERITS_STDOUT
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#child_inherits_stdout
	//
	SpawnChildInheritsStdout SpawnFlags = 512
	// SpawnChildInheritsStderr wraps G_SPAWN_CHILD_INHERITS_STDERR
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#child_inherits_stderr
	//
	SpawnChildInheritsStderr SpawnFlags = 1024
	// SpawnStdinFromDevNull wraps G_SPAWN_STDIN_FROM_DEV_NULL
	// 
	// see also https://docs.gtk.org/glib/flags.SpawnFlags.html#stdin_from_dev_null
	//
	SpawnStdinFromDevNull SpawnFlags = 2048
)

// Has returns true if s contains other
func (s SpawnFlags) Has(other SpawnFlags) bool {
	return (s & other) == other
}

func (f SpawnFlags) String() string {
	if f == 0 {
		return "SpawnFlags(0)"
	}

	var parts []string
	if (f & SpawnDefault) != 0 {
		parts = append(parts, "SpawnDefault")
	}
	if (f & SpawnLeaveDescriptorsOpen) != 0 {
		parts = append(parts, "SpawnLeaveDescriptorsOpen")
	}
	if (f & SpawnDoNotReapChild) != 0 {
		parts = append(parts, "SpawnDoNotReapChild")
	}
	if (f & SpawnSearchPath) != 0 {
		parts = append(parts, "SpawnSearchPath")
	}
	if (f & SpawnStdoutToDevNull) != 0 {
		parts = append(parts, "SpawnStdoutToDevNull")
	}
	if (f & SpawnStderrToDevNull) != 0 {
		parts = append(parts, "SpawnStderrToDevNull")
	}
	if (f & SpawnChildInheritsStdin) != 0 {
		parts = append(parts, "SpawnChildInheritsStdin")
	}
	if (f & SpawnFileAndArgvZero) != 0 {
		parts = append(parts, "SpawnFileAndArgvZero")
	}
	if (f & SpawnSearchPathFromEnvp) != 0 {
		parts = append(parts, "SpawnSearchPathFromEnvp")
	}
	if (f & SpawnCloexecPipes) != 0 {
		parts = append(parts, "SpawnCloexecPipes")
	}
	if (f & SpawnChildInheritsStdout) != 0 {
		parts = append(parts, "SpawnChildInheritsStdout")
	}
	if (f & SpawnChildInheritsStderr) != 0 {
		parts = append(parts, "SpawnChildInheritsStderr")
	}
	if (f & SpawnStdinFromDevNull) != 0 {
		parts = append(parts, "SpawnStdinFromDevNull")
	}
	return "SpawnFlags(" + strings.Join(parts, "|") + ")"
}

// TestSubprocessFlags wraps GTestSubprocessFlags
// 
// see also https://docs.gtk.org/glib/flags.TestSubprocessFlags.html
//
type TestSubprocessFlags C.gint

const (
	// TestSubprocessDefault wraps G_TEST_SUBPROCESS_DEFAULT
	// 
	// see also https://docs.gtk.org/glib/flags.TestSubprocessFlags.html#default
	//
	TestSubprocessDefault TestSubprocessFlags = 0
	// TestSubprocessInheritStdin wraps G_TEST_SUBPROCESS_INHERIT_STDIN
	// 
	// see also https://docs.gtk.org/glib/flags.TestSubprocessFlags.html#inherit_stdin
	//
	TestSubprocessInheritStdin TestSubprocessFlags = 1
	// TestSubprocessInheritStdout wraps G_TEST_SUBPROCESS_INHERIT_STDOUT
	// 
	// see also https://docs.gtk.org/glib/flags.TestSubprocessFlags.html#inherit_stdout
	//
	TestSubprocessInheritStdout TestSubprocessFlags = 2
	// TestSubprocessInheritStderr wraps G_TEST_SUBPROCESS_INHERIT_STDERR
	// 
	// see also https://docs.gtk.org/glib/flags.TestSubprocessFlags.html#inherit_stderr
	//
	TestSubprocessInheritStderr TestSubprocessFlags = 4
)

// Has returns true if t contains other
func (t TestSubprocessFlags) Has(other TestSubprocessFlags) bool {
	return (t & other) == other
}

func (f TestSubprocessFlags) String() string {
	if f == 0 {
		return "TestSubprocessFlags(0)"
	}

	var parts []string
	if (f & TestSubprocessDefault) != 0 {
		parts = append(parts, "TestSubprocessDefault")
	}
	if (f & TestSubprocessInheritStdin) != 0 {
		parts = append(parts, "TestSubprocessInheritStdin")
	}
	if (f & TestSubprocessInheritStdout) != 0 {
		parts = append(parts, "TestSubprocessInheritStdout")
	}
	if (f & TestSubprocessInheritStderr) != 0 {
		parts = append(parts, "TestSubprocessInheritStderr")
	}
	return "TestSubprocessFlags(" + strings.Join(parts, "|") + ")"
}

// TraverseFlags wraps GTraverseFlags
// 
// see also https://docs.gtk.org/glib/flags.TraverseFlags.html
//
type TraverseFlags C.gint

const (
	// TraverseLeaves wraps G_TRAVERSE_LEAVES
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#leaves
	//
	TraverseLeaves TraverseFlags = 1
	// TraverseNonLeaves wraps G_TRAVERSE_NON_LEAVES
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#non_leaves
	//
	TraverseNonLeaves TraverseFlags = 2
	// TraverseAll wraps G_TRAVERSE_ALL
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#all
	//
	TraverseAll TraverseFlags = 3
	// TraverseMask wraps G_TRAVERSE_MASK
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#mask
	//
	TraverseMask TraverseFlags = 3
	// TraverseLeafs wraps G_TRAVERSE_LEAFS
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#leafs
	//
	TraverseLeafs TraverseFlags = 1
	// TraverseNonLeafs wraps G_TRAVERSE_NON_LEAFS
	// 
	// see also https://docs.gtk.org/glib/flags.TraverseFlags.html#non_leafs
	//
	TraverseNonLeafs TraverseFlags = 2
)

// Has returns true if t contains other
func (t TraverseFlags) Has(other TraverseFlags) bool {
	return (t & other) == other
}

func (f TraverseFlags) String() string {
	if f == 0 {
		return "TraverseFlags(0)"
	}

	var parts []string
	if (f & TraverseLeaves) != 0 {
		parts = append(parts, "TraverseLeaves")
	}
	if (f & TraverseNonLeaves) != 0 {
		parts = append(parts, "TraverseNonLeaves")
	}
	if (f & TraverseAll) != 0 {
		parts = append(parts, "TraverseAll")
	}
	if (f & TraverseMask) != 0 {
		parts = append(parts, "TraverseMask")
	}
	if (f & TraverseLeafs) != 0 {
		parts = append(parts, "TraverseLeafs")
	}
	if (f & TraverseNonLeafs) != 0 {
		parts = append(parts, "TraverseNonLeafs")
	}
	return "TraverseFlags(" + strings.Join(parts, "|") + ")"
}

// UriFlags wraps GUriFlags
// 
// see also https://docs.gtk.org/glib/flags.UriFlags.html
//
type UriFlags C.gint

const (
	// URIFlagsNone wraps G_URI_FLAGS_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#none
	//
	URIFlagsNone UriFlags = 0
	// URIFlagsParseRelaxed wraps G_URI_FLAGS_PARSE_RELAXED
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#parse_relaxed
	//
	URIFlagsParseRelaxed UriFlags = 1
	// URIFlagsHasPassword wraps G_URI_FLAGS_HAS_PASSWORD
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#has_password
	//
	URIFlagsHasPassword UriFlags = 2
	// URIFlagsHasAuthParams wraps G_URI_FLAGS_HAS_AUTH_PARAMS
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#has_auth_params
	//
	URIFlagsHasAuthParams UriFlags = 4
	// URIFlagsEncoded wraps G_URI_FLAGS_ENCODED
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#encoded
	//
	URIFlagsEncoded UriFlags = 8
	// URIFlagsNonDns wraps G_URI_FLAGS_NON_DNS
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#non_dns
	//
	URIFlagsNonDns UriFlags = 16
	// URIFlagsEncodedQuery wraps G_URI_FLAGS_ENCODED_QUERY
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#encoded_query
	//
	URIFlagsEncodedQuery UriFlags = 32
	// URIFlagsEncodedPath wraps G_URI_FLAGS_ENCODED_PATH
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#encoded_path
	//
	URIFlagsEncodedPath UriFlags = 64
	// URIFlagsEncodedFragment wraps G_URI_FLAGS_ENCODED_FRAGMENT
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#encoded_fragment
	//
	URIFlagsEncodedFragment UriFlags = 128
	// URIFlagsSchemeNormalize wraps G_URI_FLAGS_SCHEME_NORMALIZE
	// 
	// see also https://docs.gtk.org/glib/flags.UriFlags.html#scheme_normalize
	//
	URIFlagsSchemeNormalize UriFlags = 256
)

// Has returns true if u contains other
func (u UriFlags) Has(other UriFlags) bool {
	return (u & other) == other
}

func (f UriFlags) String() string {
	if f == 0 {
		return "UriFlags(0)"
	}

	var parts []string
	if (f & URIFlagsNone) != 0 {
		parts = append(parts, "URIFlagsNone")
	}
	if (f & URIFlagsParseRelaxed) != 0 {
		parts = append(parts, "URIFlagsParseRelaxed")
	}
	if (f & URIFlagsHasPassword) != 0 {
		parts = append(parts, "URIFlagsHasPassword")
	}
	if (f & URIFlagsHasAuthParams) != 0 {
		parts = append(parts, "URIFlagsHasAuthParams")
	}
	if (f & URIFlagsEncoded) != 0 {
		parts = append(parts, "URIFlagsEncoded")
	}
	if (f & URIFlagsNonDns) != 0 {
		parts = append(parts, "URIFlagsNonDns")
	}
	if (f & URIFlagsEncodedQuery) != 0 {
		parts = append(parts, "URIFlagsEncodedQuery")
	}
	if (f & URIFlagsEncodedPath) != 0 {
		parts = append(parts, "URIFlagsEncodedPath")
	}
	if (f & URIFlagsEncodedFragment) != 0 {
		parts = append(parts, "URIFlagsEncodedFragment")
	}
	if (f & URIFlagsSchemeNormalize) != 0 {
		parts = append(parts, "URIFlagsSchemeNormalize")
	}
	return "UriFlags(" + strings.Join(parts, "|") + ")"
}

// UriHideFlags wraps GUriHideFlags
// 
// see also https://docs.gtk.org/glib/flags.UriHideFlags.html
//
type UriHideFlags C.gint

const (
	// URIHideNone wraps G_URI_HIDE_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#none
	//
	URIHideNone UriHideFlags = 0
	// URIHideUserinfo wraps G_URI_HIDE_USERINFO
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#userinfo
	//
	URIHideUserinfo UriHideFlags = 1
	// URIHidePassword wraps G_URI_HIDE_PASSWORD
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#password
	//
	URIHidePassword UriHideFlags = 2
	// URIHideAuthParams wraps G_URI_HIDE_AUTH_PARAMS
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#auth_params
	//
	URIHideAuthParams UriHideFlags = 4
	// URIHideQuery wraps G_URI_HIDE_QUERY
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#query
	//
	URIHideQuery UriHideFlags = 8
	// URIHideFragment wraps G_URI_HIDE_FRAGMENT
	// 
	// see also https://docs.gtk.org/glib/flags.UriHideFlags.html#fragment
	//
	URIHideFragment UriHideFlags = 16
)

// Has returns true if u contains other
func (u UriHideFlags) Has(other UriHideFlags) bool {
	return (u & other) == other
}

func (f UriHideFlags) String() string {
	if f == 0 {
		return "UriHideFlags(0)"
	}

	var parts []string
	if (f & URIHideNone) != 0 {
		parts = append(parts, "URIHideNone")
	}
	if (f & URIHideUserinfo) != 0 {
		parts = append(parts, "URIHideUserinfo")
	}
	if (f & URIHidePassword) != 0 {
		parts = append(parts, "URIHidePassword")
	}
	if (f & URIHideAuthParams) != 0 {
		parts = append(parts, "URIHideAuthParams")
	}
	if (f & URIHideQuery) != 0 {
		parts = append(parts, "URIHideQuery")
	}
	if (f & URIHideFragment) != 0 {
		parts = append(parts, "URIHideFragment")
	}
	return "UriHideFlags(" + strings.Join(parts, "|") + ")"
}

// UriParamsFlags wraps GUriParamsFlags
// 
// see also https://docs.gtk.org/glib/flags.UriParamsFlags.html
//
type UriParamsFlags C.gint

const (
	// URIParamsNone wraps G_URI_PARAMS_NONE
	// 
	// see also https://docs.gtk.org/glib/flags.UriParamsFlags.html#none
	//
	URIParamsNone UriParamsFlags = 0
	// URIParamsCaseInsensitive wraps G_URI_PARAMS_CASE_INSENSITIVE
	// 
	// see also https://docs.gtk.org/glib/flags.UriParamsFlags.html#case_insensitive
	//
	URIParamsCaseInsensitive UriParamsFlags = 1
	// URIParamsWwwForm wraps G_URI_PARAMS_WWW_FORM
	// 
	// see also https://docs.gtk.org/glib/flags.UriParamsFlags.html#www_form
	//
	URIParamsWwwForm UriParamsFlags = 2
	// URIParamsParseRelaxed wraps G_URI_PARAMS_PARSE_RELAXED
	// 
	// see also https://docs.gtk.org/glib/flags.UriParamsFlags.html#parse_relaxed
	//
	URIParamsParseRelaxed UriParamsFlags = 4
)

// Has returns true if u contains other
func (u UriParamsFlags) Has(other UriParamsFlags) bool {
	return (u & other) == other
}

func (f UriParamsFlags) String() string {
	if f == 0 {
		return "UriParamsFlags(0)"
	}

	var parts []string
	if (f & URIParamsNone) != 0 {
		parts = append(parts, "URIParamsNone")
	}
	if (f & URIParamsCaseInsensitive) != 0 {
		parts = append(parts, "URIParamsCaseInsensitive")
	}
	if (f & URIParamsWwwForm) != 0 {
		parts = append(parts, "URIParamsWwwForm")
	}
	if (f & URIParamsParseRelaxed) != 0 {
		parts = append(parts, "URIParamsParseRelaxed")
	}
	return "UriParamsFlags(" + strings.Join(parts, "|") + ")"
}

// LogFunc wraps GLogFunc
// 
// see also https://docs.gtk.org/glib/callback.LogFunc.html
//
type LogFunc func(logDomain string, logLevel LogLevelFlags, message string)

// LogWriterFunc wraps GLogWriterFunc
// 
// see also https://docs.gtk.org/glib/callback.LogWriterFunc.html
//
type LogWriterFunc func(logLevel LogLevelFlags, fields []LogField) (goret LogWriterOutput)

// SourceFunc wraps GSourceFunc
// 
// see also https://docs.gtk.org/glib/callback.SourceFunc.html
//
type SourceFunc func() (goret bool)

// SourceOnceFunc wraps GSourceOnceFunc
// 
// see also https://docs.gtk.org/glib/callback.SourceOnceFunc.html
//
type SourceOnceFunc func()

// TestDataFunc wraps GTestDataFunc
// 
// see also https://docs.gtk.org/glib/callback.TestDataFunc.html
//
type TestDataFunc func()

// TestLogFatalFunc wraps GTestLogFatalFunc
// 
// see also https://docs.gtk.org/glib/callback.TestLogFatalFunc.html
//
type TestLogFatalFunc func(logDomain string, logLevel LogLevelFlags, message string) (goret bool)

// ChildWatchFunc wraps GChildWatchFunc
// 
// see also https://docs.gtk.org/glib/callback.ChildWatchFunc.html
//
type ChildWatchFunc func(pid Pid, waitStatus int32)

// ASCIIDigitValue wraps g_ascii_digit_value
// 
// see also https://docs.gtk.org/glib/func.g_ascii_digit_value.html
//
func ASCIIDigitValue(c byte) int32 {
	var carg1 C.gchar // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_digit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIDtostr wraps g_ascii_dtostr
// 
// see also https://docs.gtk.org/glib/func.g_ascii_dtostr.html
//
func ASCIIDtostr(buffer string, bufLen int32, d float64) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gint    // in, none, casted
	var carg3 C.gdouble // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(bufLen)
	carg3 = C.gdouble(d)

	cret = C.g_ascii_dtostr(carg1, carg2, carg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(bufLen)
	runtime.KeepAlive(d)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIFormatd wraps g_ascii_formatd
// 
// see also https://docs.gtk.org/glib/func.g_ascii_formatd.html
//
func ASCIIFormatd(buffer string, bufLen int32, format string, d float64) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gint    // in, none, casted
	var carg3 *C.gchar  // in, none, string
	var carg4 C.gdouble // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(bufLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(format)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gdouble(d)

	cret = C.g_ascii_formatd(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(bufLen)
	runtime.KeepAlive(format)
	runtime.KeepAlive(d)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIStrcasecmp wraps g_ascii_strcasecmp
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strcasecmp.html
//
func ASCIIStrcasecmp(s1 string, s2 string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(s2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_ascii_strcasecmp(carg1, carg2)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIStrdown wraps g_ascii_strdown
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strdown.html
//
func ASCIIStrdown(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ascii_strdown(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIIStringToSigned wraps g_ascii_string_to_signed
// 
// see also https://docs.gtk.org/glib/func.g_ascii_string_to_signed.html
//
func ASCIIStringToSigned(str string, base uint, min int64, max int64) (int64, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.guint    // in, none, casted
	var carg3 C.gint64   // in, none, casted
	var carg4 C.gint64   // in, none, casted
	var carg5 C.gint64   // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(base)
	carg3 = C.gint64(min)
	carg4 = C.gint64(max)

	cret = C.g_ascii_string_to_signed(carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(base)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)

	var outNum int64
	var goret  bool
	var _goerr error

	outNum = int64(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outNum, goret, _goerr
}

// ASCIIStringToUnsigned wraps g_ascii_string_to_unsigned
// 
// see also https://docs.gtk.org/glib/func.g_ascii_string_to_unsigned.html
//
func ASCIIStringToUnsigned(str string, base uint, min uint64, max uint64) (uint64, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.guint    // in, none, casted
	var carg3 C.guint64  // in, none, casted
	var carg4 C.guint64  // in, none, casted
	var carg5 C.guint64  // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(base)
	carg3 = C.guint64(min)
	carg4 = C.guint64(max)

	cret = C.g_ascii_string_to_unsigned(carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(base)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)

	var outNum uint64
	var goret  bool
	var _goerr error

	outNum = uint64(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return outNum, goret, _goerr
}

// ASCIIStrncasecmp wraps g_ascii_strncasecmp
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strncasecmp.html
//
func ASCIIStrncasecmp(s1 string, s2 string, n uint) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(s1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(s2)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(n)

	cret = C.g_ascii_strncasecmp(carg1, carg2, carg3)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)
	runtime.KeepAlive(n)

	var goret int32

	goret = int32(cret)

	return goret
}

// ASCIIStrtod wraps g_ascii_strtod
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strtod.html
//
func ASCIIStrtod(nptr string) (string, float64) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, none, string
	var cret  C.gdouble // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ascii_strtod(carg1, &carg2)
	runtime.KeepAlive(nptr)

	var endptr string
	var goret  float64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = float64(cret)

	return endptr, goret
}

// ASCIIStrtoll wraps g_ascii_strtoll
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strtoll.html
//
func ASCIIStrtoll(nptr string, base uint) (string, int64) {
	var carg1 *C.gchar // in, none, string
	var carg3 C.guint  // in, none, casted
	var carg2 *C.gchar // out, none, string
	var cret  C.gint64 // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.guint(base)

	cret = C.g_ascii_strtoll(carg1, &carg2, carg3)
	runtime.KeepAlive(nptr)
	runtime.KeepAlive(base)

	var endptr string
	var goret  int64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = int64(cret)

	return endptr, goret
}

// ASCIIStrtoull wraps g_ascii_strtoull
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strtoull.html
//
func ASCIIStrtoull(nptr string, base uint) (string, uint64) {
	var carg1 *C.gchar  // in, none, string
	var carg3 C.guint   // in, none, casted
	var carg2 *C.gchar  // out, none, string
	var cret  C.guint64 // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.guint(base)

	cret = C.g_ascii_strtoull(carg1, &carg2, carg3)
	runtime.KeepAlive(nptr)
	runtime.KeepAlive(base)

	var endptr string
	var goret  uint64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = uint64(cret)

	return endptr, goret
}

// ASCIIStrup wraps g_ascii_strup
// 
// see also https://docs.gtk.org/glib/func.g_ascii_strup.html
//
func ASCIIStrup(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ascii_strup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ASCIITolower wraps g_ascii_tolower
// 
// see also https://docs.gtk.org/glib/func.g_ascii_tolower.html
//
func ASCIITolower(c byte) byte {
	var carg1 C.gchar // in, none, casted
	var cret  C.gchar // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_tolower(carg1)
	runtime.KeepAlive(c)

	var goret byte

	goret = byte(cret)

	return goret
}

// ASCIIToupper wraps g_ascii_toupper
// 
// see also https://docs.gtk.org/glib/func.g_ascii_toupper.html
//
func ASCIIToupper(c byte) byte {
	var carg1 C.gchar // in, none, casted
	var cret  C.gchar // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_toupper(carg1)
	runtime.KeepAlive(c)

	var goret byte

	goret = byte(cret)

	return goret
}

// ASCIIXdigitValue wraps g_ascii_xdigit_value
// 
// see also https://docs.gtk.org/glib/func.g_ascii_xdigit_value.html
//
func ASCIIXdigitValue(c byte) int32 {
	var carg1 C.gchar // in, none, casted
	var cret  C.gint  // return, none, casted

	carg1 = C.gchar(c)

	cret = C.g_ascii_xdigit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// AssertWarning wraps g_assert_warning
// 
// see also https://docs.gtk.org/glib/func.g_assert_warning.html
func AssertWarning(logDomain string, file string, line int32, prettyFunction string, expression string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(prettyFunction)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expression)))
	defer C.free(unsafe.Pointer(carg5))

	C.g_assert_warning(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(prettyFunction)
	runtime.KeepAlive(expression)
}

// AssertionMessage wraps g_assertion_message
// 
// see also https://docs.gtk.org/glib/func.g_assertion_message.html
func AssertionMessage(domain string, file string, line int32, fn string, message string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg5))

	C.g_assertion_message(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(message)
}

// AssertionMessageCmpint wraps g_assertion_message_cmpint
// 
// see also https://docs.gtk.org/glib/func.g_assertion_message_cmpint.html
func AssertionMessageCmpint(domain string, file string, line int32, fn string, expr string, arg1 uint64, cmp string, arg2 uint64, numtype byte) {
	var carg1 *C.char   // in, none, string
	var carg2 *C.char   // in, none, string
	var carg3 C.int     // in, none, casted
	var carg4 *C.char   // in, none, string
	var carg5 *C.char   // in, none, string
	var carg6 C.guint64 // in, none, casted
	var carg7 *C.char   // in, none, string
	var carg8 C.guint64 // in, none, casted
	var carg9 C.char    // in, none, casted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expr)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = C.guint64(arg1)
	carg7 = (*C.char)(unsafe.Pointer(C.CString(cmp)))
	defer C.free(unsafe.Pointer(carg7))
	carg8 = C.guint64(arg2)
	carg9 = C.char(numtype)

	C.g_assertion_message_cmpint(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(arg1)
	runtime.KeepAlive(cmp)
	runtime.KeepAlive(arg2)
	runtime.KeepAlive(numtype)
}

// AssertionMessageCmpstr wraps g_assertion_message_cmpstr
// 
// see also https://docs.gtk.org/glib/func.g_assertion_message_cmpstr.html
func AssertionMessageCmpstr(domain string, file string, line int32, fn string, expr string, arg1 string, cmp string, arg2 string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string
	var carg5 *C.char // in, none, string
	var carg6 *C.char // in, none, string
	var carg7 *C.char // in, none, string
	var carg8 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.char)(unsafe.Pointer(C.CString(expr)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = (*C.char)(unsafe.Pointer(C.CString(arg1)))
	defer C.free(unsafe.Pointer(carg6))
	carg7 = (*C.char)(unsafe.Pointer(C.CString(cmp)))
	defer C.free(unsafe.Pointer(carg7))
	carg8 = (*C.char)(unsafe.Pointer(C.CString(arg2)))
	defer C.free(unsafe.Pointer(carg8))

	C.g_assertion_message_cmpstr(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(arg1)
	runtime.KeepAlive(cmp)
	runtime.KeepAlive(arg2)
}

// Base64Decode wraps g_base64_decode
// 
// see also https://docs.gtk.org/glib/func.g_base64_decode.html
//
func Base64Decode(text string) (uint, []uint8) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gsize   // out, full, casted
	var cret  *C.guchar // return, transfer: full, C Pointers: 1, Name: array[guint8], scope: , array (inner guint8 (*typesystem.CastablePrimitive))

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_base64_decode(carg1, &carg2)
	runtime.KeepAlive(text)

	var outLen uint
	var goret  []uint8

	outLen = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []uint8 (guchar*) because of unknown reason")

	return outLen, goret
}

// Base64Encode wraps g_base64_encode
// 
// see also https://docs.gtk.org/glib/func.g_base64_encode.html
//
func Base64Encode(data []uint8) string {
	var carg1 *C.guchar // in, transfer: none, C Pointers: 1, Name: array[guint8], nullable, array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize   // implicit
	var cret  *C.gchar  // return, full, string

	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_base64_encode(carg1, carg2)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// BitNthLsf wraps g_bit_nth_lsf
// 
// see also https://docs.gtk.org/glib/func.g_bit_nth_lsf.html
//
func BitNthLsf(mask uint32, nthBit int32) int32 {
	var carg1 C.gulong // in, none, casted
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = C.gulong(mask)
	carg2 = C.gint(nthBit)

	cret = C.g_bit_nth_lsf(carg1, carg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var goret int32

	goret = int32(cret)

	return goret
}

// BitNthMsf wraps g_bit_nth_msf
// 
// see also https://docs.gtk.org/glib/func.g_bit_nth_msf.html
//
func BitNthMsf(mask uint32, nthBit int32) int32 {
	var carg1 C.gulong // in, none, casted
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = C.gulong(mask)
	carg2 = C.gint(nthBit)

	cret = C.g_bit_nth_msf(carg1, carg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var goret int32

	goret = int32(cret)

	return goret
}

// BitStorage wraps g_bit_storage
// 
// see also https://docs.gtk.org/glib/func.g_bit_storage.html
//
func BitStorage(number uint32) uint {
	var carg1 C.gulong // in, none, casted
	var cret  C.guint  // return, none, casted

	carg1 = C.gulong(number)

	cret = C.g_bit_storage(carg1)
	runtime.KeepAlive(number)

	var goret uint

	goret = uint(cret)

	return goret
}

// BuildFilenamev wraps g_build_filenamev
// 
// see also https://docs.gtk.org/glib/func.g_build_filenamev.html
//
func BuildFilenamev(args []string) string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	_ = args
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_build_filenamev(carg1)
	runtime.KeepAlive(args)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// BuildPathv wraps g_build_pathv
// 
// see also https://docs.gtk.org/glib/func.g_build_pathv.html
//
func BuildPathv(separator string, args []string) string {
	var carg1 *C.gchar  // in, none, string
	var carg2 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(separator)))
	defer C.free(unsafe.Pointer(carg1))
	_ = args
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_build_pathv(carg1, carg2)
	runtime.KeepAlive(separator)
	runtime.KeepAlive(args)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// CanonicalizeFilename wraps g_canonicalize_filename
// 
// see also https://docs.gtk.org/glib/func.g_canonicalize_filename.html
//
func CanonicalizeFilename(filename string, relativeTo string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if relativeTo != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(relativeTo)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_canonicalize_filename(carg1, carg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(relativeTo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// CheckVersion wraps glib_check_version
// 
// see also https://docs.gtk.org/glib/func.glib_check_version.html
//
func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
	var carg1 C.guint  // in, none, casted
	var carg2 C.guint  // in, none, casted
	var carg3 C.guint  // in, none, casted
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = C.guint(requiredMajor)
	carg2 = C.guint(requiredMinor)
	carg3 = C.guint(requiredMicro)

	cret = C.glib_check_version(carg1, carg2, carg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ChildWatchAddFull wraps g_child_watch_add_full
// 
// see also https://docs.gtk.org/glib/func.g_child_watch_add_full.html
//
func ChildWatchAddFull(priority int32, pid Pid, function ChildWatchFunc) uint {
	var carg1 C.gint            // in, none, casted
	var carg2 C.GPid            // in, none, casted, alias
	var carg3 C.GChildWatchFunc // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer        // implicit
	var carg5 C.GDestroyNotify  // implicit
	var cret  C.guint           // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.GPid(pid)
	carg3 = (*[0]byte)(C._goglib_glib2_ChildWatchFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_child_watch_add_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(pid)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// ClearError wraps g_clear_error
// 
// see also https://docs.gtk.org/glib/func.g_clear_error.html
//
func ClearError() error {
	var _cerr *C.GError // out, full, converted, nullable

	C.g_clear_error(&_cerr)

	var _goerr error

	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ComputeChecksumForBytes wraps g_compute_checksum_for_bytes
// 
// see also https://docs.gtk.org/glib/func.g_compute_checksum_for_bytes.html
//
func ComputeChecksumForBytes(checksumType ChecksumType, data *Bytes) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.GBytes       // in, none, converted
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	carg2 = (*C.GBytes)(UnsafeBytesToGlibNone(data))

	cret = C.g_compute_checksum_for_bytes(carg1, carg2)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeChecksumForData wraps g_compute_checksum_for_data
// 
// see also https://docs.gtk.org/glib/func.g_compute_checksum_for_data.html
//
func ComputeChecksumForData(checksumType ChecksumType, data []uint8) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	_ = data
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_compute_checksum_for_data(carg1, carg2, carg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(data)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeChecksumForString wraps g_compute_checksum_for_string
// 
// see also https://docs.gtk.org/glib/func.g_compute_checksum_for_string.html
//
func ComputeChecksumForString(checksumType ChecksumType, str string, length int) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.gchar        // in, none, string
	var carg3 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string, nullable-string

	carg1 = C.GChecksumType(checksumType)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gssize(length)

	cret = C.g_compute_checksum_for_string(carg1, carg2, carg3)
	runtime.KeepAlive(checksumType)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// ComputeHmacForBytes wraps g_compute_hmac_for_bytes
// 
// see also https://docs.gtk.org/glib/func.g_compute_hmac_for_bytes.html
//
func ComputeHmacForBytes(digestType ChecksumType, key *Bytes, data *Bytes) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.GBytes       // in, none, converted
	var carg3 *C.GBytes       // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	carg2 = (*C.GBytes)(UnsafeBytesToGlibNone(key))
	carg3 = (*C.GBytes)(UnsafeBytesToGlibNone(data))

	cret = C.g_compute_hmac_for_bytes(carg1, carg2, carg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ComputeHmacForData wraps g_compute_hmac_for_data
// 
// see also https://docs.gtk.org/glib/func.g_compute_hmac_for_data.html
//
func ComputeHmacForData(digestType ChecksumType, key []byte, data []byte) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg5)
	var carg5 C.gsize         // implicit
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")
	_ = data
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_compute_hmac_for_data(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(data)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ComputeHmacForString wraps g_compute_hmac_for_string
// 
// see also https://docs.gtk.org/glib/func.g_compute_hmac_for_string.html
//
func ComputeHmacForString(digestType ChecksumType, key []byte, str string, length int) string {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var carg4 *C.gchar        // in, none, string
	var carg5 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.gssize(length)

	cret = C.g_compute_hmac_for_string(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Convert wraps g_convert
// 
// see also https://docs.gtk.org/glib/func.g_convert.html
//
func Convert(str string, toCodeset string, fromCodeset string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 *C.gchar  // in, none, string
	var carg4 *C.gchar  // in, none, string
	var carg5 C.gsize   // out, full, casted
	var carg6 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(carg4))

	cret = C.g_convert(carg1, carg2, carg3, carg4, &carg5, &carg6, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg5)
	bytesWritten = uint(carg6)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// ConvertErrorQuark wraps g_convert_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_convert_error_quark.html
func ConvertErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_convert_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ConvertWithFallback wraps g_convert_with_fallback
// 
// see also https://docs.gtk.org/glib/func.g_convert_with_fallback.html
//
func ConvertWithFallback(str string, toCodeset string, fromCodeset string, fallback string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 *C.gchar  // in, none, string
	var carg4 *C.gchar  // in, none, string
	var carg5 *C.gchar  // in, none, string
	var carg6 C.gsize   // out, full, casted
	var carg7 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.gchar)(unsafe.Pointer(C.CString(fallback)))
	defer C.free(unsafe.Pointer(carg5))

	cret = C.g_convert_with_fallback(carg1, carg2, carg3, carg4, carg5, &carg6, &carg7, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)
	runtime.KeepAlive(fallback)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg6)
	bytesWritten = uint(carg7)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// Dcgettext wraps g_dcgettext
// 
// see also https://docs.gtk.org/glib/func.g_dcgettext.html
//
func Dcgettext(domain string, msgid string, category int32) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(category)

	cret = C.g_dcgettext(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(category)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dgettext wraps g_dgettext
// 
// see also https://docs.gtk.org/glib/func.g_dgettext.html
//
func Dgettext(domain string, msgid string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_dgettext(carg1, carg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dngettext wraps g_dngettext
// 
// see also https://docs.gtk.org/glib/func.g_dngettext.html
//
func Dngettext(domain string, msgid string, msgidPlural string, n uint32) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 *C.gchar // in, none, string
	var carg4 C.gulong // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgidPlural)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.gulong(n)

	cret = C.g_dngettext(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgidPlural)
	runtime.KeepAlive(n)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dpgettext wraps g_dpgettext
// 
// see also https://docs.gtk.org/glib/func.g_dpgettext.html
//
func Dpgettext(domain string, msgctxtid string, msgidoffset uint) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgctxtid)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(msgidoffset)

	cret = C.g_dpgettext(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(msgctxtid)
	runtime.KeepAlive(msgidoffset)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Dpgettext2 wraps g_dpgettext2
// 
// see also https://docs.gtk.org/glib/func.g_dpgettext2.html
//
func Dpgettext2(domain string, _context string, msgid string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 *C.gchar // in, none, string
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	if domain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(_context)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_dpgettext2(carg1, carg2, carg3)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(msgid)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// EnvironGetenv wraps g_environ_getenv
// 
// see also https://docs.gtk.org/glib/func.g_environ_getenv.html
//
func EnvironGetenv(envp []string, variable string) string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, none, string, nullable

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_environ_getenv(carg1, carg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// EnvironSetenv wraps g_environ_setenv
// 
// see also https://docs.gtk.org/glib/func.g_environ_setenv.html
//
func EnvironSetenv(envp []string, variable string, value string, overwrite bool) []string {
	var carg1 **C.gchar  // in, transfer: full, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar   // in, none, string
	var carg3 *C.gchar   // in, none, string
	var carg4 C.gboolean // in
	var cret  **C.gchar  // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg3))
	if overwrite {
		carg4 = C.TRUE
	}

	cret = C.g_environ_setenv(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// EnvironUnsetenv wraps g_environ_unsetenv
// 
// see also https://docs.gtk.org/glib/func.g_environ_unsetenv.html
//
func EnvironUnsetenv(envp []string, variable string) []string {
	var carg1 **C.gchar // in, transfer: full, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = envp
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_environ_unsetenv(carg1, carg2)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(variable)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// FileErrorFromErrno wraps g_file_error_from_errno
// 
// see also https://docs.gtk.org/glib/func.g_file_error_from_errno.html
//
func FileErrorFromErrno(errNo int32) FileError {
	var carg1 C.gint       // in, none, casted
	var cret  C.GFileError // return, none, casted

	carg1 = C.gint(errNo)

	cret = C.g_file_error_from_errno(carg1)
	runtime.KeepAlive(errNo)

	var goret FileError

	goret = FileError(cret)

	return goret
}

// FileErrorQuark wraps g_file_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_file_error_quark.html
func FileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// FileGetContents wraps g_file_get_contents
// 
// see also https://docs.gtk.org/glib/func.g_file_get_contents.html
//
func FileGetContents(filename string) (string, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gsize    // implicit
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_get_contents(carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(filename)

	var contents string
	var goret    bool
	var _goerr   error

	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return contents, goret, _goerr
}

// FileOpenTmp wraps g_file_open_tmp
// 
// see also https://docs.gtk.org/glib/func.g_file_open_tmp.html
//
func FileOpenTmp(tmpl string) (string, int32, error) {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var carg2 *C.gchar  // out, full, string
	var cret  C.gint    // return, none, casted
	var _cerr *C.GError // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_file_open_tmp(carg1, &carg2, &_cerr)
	runtime.KeepAlive(tmpl)

	var nameUsed string
	var goret    int32
	var _goerr   error

	nameUsed = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	goret = int32(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return nameUsed, goret, _goerr
}

// FileReadLink wraps g_file_read_link
// 
// see also https://docs.gtk.org/glib/func.g_file_read_link.html
//
func FileReadLink(filename string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_file_read_link(carg1, &_cerr)
	runtime.KeepAlive(filename)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileSetContents wraps g_file_set_contents
// 
// see also https://docs.gtk.org/glib/func.g_file_set_contents.html
//
func FileSetContents(filename string, contents string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gssize   // implicit
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_file_set_contents(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FileSetContentsFull wraps g_file_set_contents_full
// 
// see also https://docs.gtk.org/glib/func.g_file_set_contents_full.html
//
func FileSetContentsFull(filename string, contents string, flags FileSetContentsFlags, mode int32) (bool, error) {
	var carg1 *C.gchar                // in, none, string
	var carg2 *C.gchar                // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg3)
	var carg3 C.gssize                // implicit
	var carg4 C.GFileSetContentsFlags // in, none, casted
	var carg5 C.int                   // in, none, casted
	var cret  C.gboolean              // return
	var _cerr *C.GError               // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	_ = contents
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg4 = C.GFileSetContentsFlags(flags)
	carg5 = C.int(mode)

	cret = C.g_file_set_contents_full(carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mode)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// TestFile wraps g_file_test
// 
// see also https://docs.gtk.org/glib/func.g_file_test.html
//
func TestFile(filename string, test FileTest) bool {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GFileTest // in, none, casted
	var cret  C.gboolean  // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GFileTest(test)

	cret = C.g_file_test(carg1, carg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(test)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// FilenameDisplayBasename wraps g_filename_display_basename
// 
// see also https://docs.gtk.org/glib/func.g_filename_display_basename.html
//
func FilenameDisplayBasename(filename string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_display_basename(carg1)
	runtime.KeepAlive(filename)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FilenameDisplayName wraps g_filename_display_name
// 
// see also https://docs.gtk.org/glib/func.g_filename_display_name.html
//
func FilenameDisplayName(filename string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_display_name(carg1)
	runtime.KeepAlive(filename)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FilenameFromURI wraps g_filename_from_uri
// 
// see also https://docs.gtk.org/glib/func.g_filename_from_uri.html
//
func FilenameFromURI(uri string) (string, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, full, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_filename_from_uri(carg1, &carg2, &_cerr)
	runtime.KeepAlive(uri)

	var hostname string
	var goret    string
	var _goerr   error

	if carg2 != nil {
		hostname = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return hostname, goret, _goerr
}

// FilenameFromUTF8 wraps g_filename_from_utf8
// 
// see also https://docs.gtk.org/glib/func.g_filename_from_utf8.html
//
func FilenameFromUTF8(utf8string string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8string)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_filename_from_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(utf8string)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// FilenameToURI wraps g_filename_to_uri
// 
// see also https://docs.gtk.org/glib/func.g_filename_to_uri.html
//
func FilenameToURI(filename string, hostname string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if hostname != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_filename_to_uri(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(hostname)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// FilenameToUTF8 wraps g_filename_to_utf8
// 
// see also https://docs.gtk.org/glib/func.g_filename_to_utf8.html
//
func FilenameToUTF8(opsysstring string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(opsysstring)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_filename_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(opsysstring)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// FindProgramInPath wraps g_find_program_in_path
// 
// see also https://docs.gtk.org/glib/func.g_find_program_in_path.html
//
func FindProgramInPath(program string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(program)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_find_program_in_path(carg1)
	runtime.KeepAlive(program)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FormatSize wraps g_format_size
// 
// see also https://docs.gtk.org/glib/func.g_format_size.html
//
func FormatSize(size uint64) string {
	var carg1 C.guint64 // in, none, casted
	var cret  *C.gchar  // return, full, string

	carg1 = C.guint64(size)

	cret = C.g_format_size(carg1)
	runtime.KeepAlive(size)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// FormatSizeFull wraps g_format_size_full
// 
// see also https://docs.gtk.org/glib/func.g_format_size_full.html
//
func FormatSizeFull(size uint64, flags FormatSizeFlags) string {
	var carg1 C.guint64          // in, none, casted
	var carg2 C.GFormatSizeFlags // in, none, casted
	var cret  *C.gchar           // return, full, string

	carg1 = C.guint64(size)
	carg2 = C.GFormatSizeFlags(flags)

	cret = C.g_format_size_full(carg1, carg2)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetApplicationName wraps g_get_application_name
// 
// see also https://docs.gtk.org/glib/func.g_get_application_name.html
//
func GetApplicationName() string {
	var cret *C.gchar // return, none, string, nullable-string

	cret = C.g_get_application_name()

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetCharset wraps g_get_charset
// 
// see also https://docs.gtk.org/glib/func.g_get_charset.html
//
func GetCharset() (string, bool) {
	var carg1 *C.char    // out, none, string
	var cret  C.gboolean // return

	cret = C.g_get_charset(&carg1)

	var charset string
	var goret   bool

	charset = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	if cret != 0 {
		goret = true
	}

	return charset, goret
}

// GetCodeset wraps g_get_codeset
// 
// see also https://docs.gtk.org/glib/func.g_get_codeset.html
//
func GetCodeset() string {
	var cret *C.gchar // return, full, string

	cret = C.g_get_codeset()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetConsoleCharset wraps g_get_console_charset
// 
// see also https://docs.gtk.org/glib/func.g_get_console_charset.html
//
func GetConsoleCharset() (string, bool) {
	var carg1 *C.char    // out, none, string
	var cret  C.gboolean // return

	cret = C.g_get_console_charset(&carg1)

	var charset string
	var goret   bool

	charset = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	if cret != 0 {
		goret = true
	}

	return charset, goret
}

// GetCurrentDir wraps g_get_current_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_current_dir.html
//
func GetCurrentDir() string {
	var cret *C.gchar // return, full, string

	cret = C.g_get_current_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetEnviron wraps g_get_environ
// 
// see also https://docs.gtk.org/glib/func.g_get_environ.html
//
func GetEnviron() []string {
	var cret **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_environ()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetHomeDir wraps g_get_home_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_home_dir.html
//
func GetHomeDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_home_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetHostName wraps g_get_host_name
// 
// see also https://docs.gtk.org/glib/func.g_get_host_name.html
//
func GetHostName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_host_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetLanguageNames wraps g_get_language_names
// 
// see also https://docs.gtk.org/glib/func.g_get_language_names.html
//
func GetLanguageNames() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_language_names()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetLanguageNamesWithCategory wraps g_get_language_names_with_category
// 
// see also https://docs.gtk.org/glib/func.g_get_language_names_with_category.html
//
func GetLanguageNamesWithCategory(categoryName string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: none, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(categoryName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_language_names_with_category(carg1)
	runtime.KeepAlive(categoryName)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetLocaleVariants wraps g_get_locale_variants
// 
// see also https://docs.gtk.org/glib/func.g_get_locale_variants.html
//
func GetLocaleVariants(locale string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_locale_variants(carg1)
	runtime.KeepAlive(locale)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetMonotonicTime wraps g_get_monotonic_time
// 
// see also https://docs.gtk.org/glib/func.g_get_monotonic_time.html
//
func GetMonotonicTime() int64 {
	var cret C.gint64 // return, none, casted

	cret = C.g_get_monotonic_time()

	var goret int64

	goret = int64(cret)

	return goret
}

// GetNumProcessors wraps g_get_num_processors
// 
// see also https://docs.gtk.org/glib/func.g_get_num_processors.html
//
func GetNumProcessors() uint {
	var cret C.guint // return, none, casted

	cret = C.g_get_num_processors()

	var goret uint

	goret = uint(cret)

	return goret
}

// GetOsInfo wraps g_get_os_info
// 
// see also https://docs.gtk.org/glib/func.g_get_os_info.html
//
func GetOsInfo(keyName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(keyName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_get_os_info(carg1)
	runtime.KeepAlive(keyName)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetPrgname wraps g_get_prgname
// 
// see also https://docs.gtk.org/glib/func.g_get_prgname.html
//
func GetPrgname() string {
	var cret *C.gchar // return, none, string, nullable-string

	cret = C.g_get_prgname()

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetRealName wraps g_get_real_name
// 
// see also https://docs.gtk.org/glib/func.g_get_real_name.html
//
func GetRealName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_real_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetRealTime wraps g_get_real_time
// 
// see also https://docs.gtk.org/glib/func.g_get_real_time.html
//
func GetRealTime() int64 {
	var cret C.gint64 // return, none, casted

	cret = C.g_get_real_time()

	var goret int64

	goret = int64(cret)

	return goret
}

// GetSystemConfigDirs wraps g_get_system_config_dirs
// 
// see also https://docs.gtk.org/glib/func.g_get_system_config_dirs.html
//
func GetSystemConfigDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_system_config_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetSystemDataDirs wraps g_get_system_data_dirs
// 
// see also https://docs.gtk.org/glib/func.g_get_system_data_dirs.html
//
func GetSystemDataDirs() []string {
	var cret **C.gchar // return, transfer: none, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_get_system_data_dirs()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (const gchar* const*) because of unknown reason")

	return goret
}

// GetTmpDir wraps g_get_tmp_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_tmp_dir.html
//
func GetTmpDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_tmp_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserCacheDir wraps g_get_user_cache_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_cache_dir.html
//
func GetUserCacheDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_cache_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserConfigDir wraps g_get_user_config_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_config_dir.html
//
func GetUserConfigDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_config_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserDataDir wraps g_get_user_data_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_data_dir.html
//
func GetUserDataDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_data_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserName wraps g_get_user_name
// 
// see also https://docs.gtk.org/glib/func.g_get_user_name.html
//
func GetUserName() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_name()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserRuntimeDir wraps g_get_user_runtime_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_runtime_dir.html
//
func GetUserRuntimeDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_runtime_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUserSpecialDir wraps g_get_user_special_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_special_dir.html
//
func GetUserSpecialDir(directory UserDirectory) string {
	var carg1 C.GUserDirectory // in, none, casted
	var cret  *C.gchar         // return, none, string, nullable

	carg1 = C.GUserDirectory(directory)

	cret = C.g_get_user_special_dir(carg1)
	runtime.KeepAlive(directory)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUserStateDir wraps g_get_user_state_dir
// 
// see also https://docs.gtk.org/glib/func.g_get_user_state_dir.html
//
func GetUserStateDir() string {
	var cret *C.gchar // return, none, string

	cret = C.g_get_user_state_dir()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Getenv wraps g_getenv
// 
// see also https://docs.gtk.org/glib/func.g_getenv.html
//
func Getenv(variable string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_getenv(carg1)
	runtime.KeepAlive(variable)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// HostnameIsASCIIEncoded wraps g_hostname_is_ascii_encoded
// 
// see also https://docs.gtk.org/glib/func.g_hostname_is_ascii_encoded.html
//
func HostnameIsASCIIEncoded(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_ascii_encoded(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameIsIpAddress wraps g_hostname_is_ip_address
// 
// see also https://docs.gtk.org/glib/func.g_hostname_is_ip_address.html
//
func HostnameIsIpAddress(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_ip_address(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameIsNonASCII wraps g_hostname_is_non_ascii
// 
// see also https://docs.gtk.org/glib/func.g_hostname_is_non_ascii.html
//
func HostnameIsNonASCII(hostname string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_is_non_ascii(carg1)
	runtime.KeepAlive(hostname)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HostnameToASCII wraps g_hostname_to_ascii
// 
// see also https://docs.gtk.org/glib/func.g_hostname_to_ascii.html
//
func HostnameToASCII(hostname string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_to_ascii(carg1)
	runtime.KeepAlive(hostname)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// HostnameToUnicode wraps g_hostname_to_unicode
// 
// see also https://docs.gtk.org/glib/func.g_hostname_to_unicode.html
//
func HostnameToUnicode(hostname string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_hostname_to_unicode(carg1)
	runtime.KeepAlive(hostname)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// IdleAddFull wraps g_idle_add_full
// 
// see also https://docs.gtk.org/glib/func.g_idle_add_full.html
//
func IdleAddFull(priority int32, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.GSourceFunc    // callback, scope: notified, closure: carg3, destroy: carg4
	var carg3 C.gpointer       // implicit
	var carg4 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg3 = C.gpointer(userdata.Register(function))
	carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_idle_add_full(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// InternStaticString wraps g_intern_static_string
// 
// see also https://docs.gtk.org/glib/func.g_intern_static_string.html
//
func InternStaticString(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_intern_static_string(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// InternString wraps g_intern_string
// 
// see also https://docs.gtk.org/glib/func.g_intern_string.html
//
func InternString(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_intern_string(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Listenv wraps g_listenv
// 
// see also https://docs.gtk.org/glib/func.g_listenv.html
//
func Listenv() []string {
	var cret **C.gchar // return, transfer: full, C Pointers: 2, Name: array[filename], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	cret = C.g_listenv()

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// LocaleFromUTF8 wraps g_locale_from_utf8
// 
// see also https://docs.gtk.org/glib/func.g_locale_from_utf8.html
//
func LocaleFromUTF8(utf8string string, len int) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8string)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_locale_from_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(utf8string)
	runtime.KeepAlive(len)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// LocaleToUTF8 wraps g_locale_to_utf8
// 
// see also https://docs.gtk.org/glib/func.g_locale_to_utf8.html
//
func LocaleToUTF8(opsysstring string) (uint, uint, string, error) {
	var carg1 *C.gchar  // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize  // implicit
	var carg3 C.gsize   // out, full, casted
	var carg4 C.gsize   // out, full, casted
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	_ = opsysstring
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_locale_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(opsysstring)

	var bytesRead    uint
	var bytesWritten uint
	var goret        string
	var _goerr       error

	bytesRead = uint(carg3)
	bytesWritten = uint(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return bytesRead, bytesWritten, goret, _goerr
}

// LogGetDebugEnabled wraps g_log_get_debug_enabled
// 
// see also https://docs.gtk.org/glib/func.g_log_get_debug_enabled.html
//
func LogGetDebugEnabled() bool {
	var cret C.gboolean // return

	cret = C.g_log_get_debug_enabled()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogRemoveHandler wraps g_log_remove_handler
// 
// see also https://docs.gtk.org/glib/func.g_log_remove_handler.html
//
func LogRemoveHandler(logDomain string, handlerId uint) {
	var carg1 *C.gchar // in, none, string
	var carg2 C.guint  // in, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(handlerId)

	C.g_log_remove_handler(carg1, carg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(handlerId)
}

// LogSetAlwaysFatal wraps g_log_set_always_fatal
// 
// see also https://docs.gtk.org/glib/func.g_log_set_always_fatal.html
//
func LogSetAlwaysFatal(fatalMask LogLevelFlags) LogLevelFlags {
	var carg1 C.GLogLevelFlags // in, none, casted
	var cret  C.GLogLevelFlags // return, none, casted

	carg1 = C.GLogLevelFlags(fatalMask)

	cret = C.g_log_set_always_fatal(carg1)
	runtime.KeepAlive(fatalMask)

	var goret LogLevelFlags

	goret = LogLevelFlags(cret)

	return goret
}

// LogSetDebugEnabled wraps g_log_set_debug_enabled
// 
// see also https://docs.gtk.org/glib/func.g_log_set_debug_enabled.html
//
func LogSetDebugEnabled(enabled bool) {
	var carg1 C.gboolean // in

	if enabled {
		carg1 = C.TRUE
	}

	C.g_log_set_debug_enabled(carg1)
	runtime.KeepAlive(enabled)
}

// LogSetFatalMask wraps g_log_set_fatal_mask
// 
// see also https://docs.gtk.org/glib/func.g_log_set_fatal_mask.html
//
func LogSetFatalMask(logDomain string, fatalMask LogLevelFlags) LogLevelFlags {
	var carg1 *C.gchar         // in, none, string
	var carg2 C.GLogLevelFlags // in, none, casted
	var cret  C.GLogLevelFlags // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GLogLevelFlags(fatalMask)

	cret = C.g_log_set_fatal_mask(carg1, carg2)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(fatalMask)

	var goret LogLevelFlags

	goret = LogLevelFlags(cret)

	return goret
}

// LogSetHandlerFull wraps g_log_set_handler_full
// 
// see also https://docs.gtk.org/glib/func.g_log_set_handler_full.html
//
func LogSetHandlerFull(logDomain string, logLevels LogLevelFlags, logFunc LogFunc) uint {
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 C.GLogLevelFlags // in, none, casted
	var carg3 C.GLogFunc       // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	if logDomain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GLogLevelFlags(logLevels)
	carg3 = (*[0]byte)(C._goglib_glib2_LogFunc)
	carg4 = C.gpointer(userdata.Register(logFunc))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_log_set_handler_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevels)
	runtime.KeepAlive(logFunc)

	var goret uint

	goret = uint(cret)

	return goret
}

// LogSetWriterFunc wraps g_log_set_writer_func
// 
// see also https://docs.gtk.org/glib/func.g_log_set_writer_func.html
//
func LogSetWriterFunc() {
	var carg1 C.GLogWriterFunc // implicit
	var carg2 C.gpointer       // implicit
	var carg3 C.GDestroyNotify // implicit

	C.g_log_set_writer_func(carg1, carg2, carg3)
}

// LogStructuredArray wraps g_log_structured_array
// 
// see also https://docs.gtk.org/glib/func.g_log_structured_array.html
//
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.GLogField     // in, transfer: none, C Pointers: 1, Name: array[LogField], array (inner GLogField (*typesystem.Record), length-by: carg3)
	var carg3 C.gsize          // implicit

	carg1 = C.GLogLevelFlags(logLevel)
	_ = fields
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []LogField (const GLogField*) because of unimplemented: non-fixed size array")

	C.g_log_structured_array(carg1, carg2, carg3)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogWriterDefaultSetUseStderr wraps g_log_writer_default_set_use_stderr
// 
// see also https://docs.gtk.org/glib/func.g_log_writer_default_set_use_stderr.html
//
func LogWriterDefaultSetUseStderr(useStderr bool) {
	var carg1 C.gboolean // in

	if useStderr {
		carg1 = C.TRUE
	}

	C.g_log_writer_default_set_use_stderr(carg1)
	runtime.KeepAlive(useStderr)
}

// LogWriterDefaultWouldDrop wraps g_log_writer_default_would_drop
// 
// see also https://docs.gtk.org/glib/func.g_log_writer_default_would_drop.html
//
func LogWriterDefaultWouldDrop(logLevel LogLevelFlags, logDomain string) bool {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.char          // in, none, string, nullable-string
	var cret  C.gboolean       // return

	carg1 = C.GLogLevelFlags(logLevel)
	if logDomain != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_log_writer_default_would_drop(carg1, carg2)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(logDomain)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogWriterFormatFields wraps g_log_writer_format_fields
// 
// see also https://docs.gtk.org/glib/func.g_log_writer_format_fields.html
//
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var carg1 C.GLogLevelFlags // in, none, casted
	var carg2 *C.GLogField     // in, transfer: none, C Pointers: 1, Name: array[LogField], array (inner GLogField (*typesystem.Record), length-by: carg3)
	var carg3 C.gsize          // implicit
	var carg4 C.gboolean       // in
	var cret  *C.gchar         // return, full, string

	carg1 = C.GLogLevelFlags(logLevel)
	_ = fields
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []LogField (const GLogField*) because of unimplemented: non-fixed size array")
	if useColor {
		carg4 = C.TRUE
	}

	cret = C.g_log_writer_format_fields(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(useColor)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// LogWriterIsJournald wraps g_log_writer_is_journald
// 
// see also https://docs.gtk.org/glib/func.g_log_writer_is_journald.html
//
func LogWriterIsJournald(outputFd int32) bool {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gint(outputFd)

	cret = C.g_log_writer_is_journald(carg1)
	runtime.KeepAlive(outputFd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LogWriterSupportsColor wraps g_log_writer_supports_color
// 
// see also https://docs.gtk.org/glib/func.g_log_writer_supports_color.html
//
func LogWriterSupportsColor(outputFd int32) bool {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gint(outputFd)

	cret = C.g_log_writer_supports_color(carg1)
	runtime.KeepAlive(outputFd)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MainDepth wraps g_main_depth
// 
// see also https://docs.gtk.org/glib/func.g_main_depth.html
//
func MainDepth() int32 {
	var cret C.gint // return, none, casted

	cret = C.g_main_depth()

	var goret int32

	goret = int32(cret)

	return goret
}

// MarkupErrorQuark wraps g_markup_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_markup_error_quark.html
func MarkupErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_markup_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// MarkupEscapeText wraps g_markup_escape_text
// 
// see also https://docs.gtk.org/glib/func.g_markup_escape_text.html
//
func MarkupEscapeText(text string, length int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)

	cret = C.g_markup_escape_text(carg1, carg2)
	runtime.KeepAlive(text)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// MkdirWithParents wraps g_mkdir_with_parents
// 
// see also https://docs.gtk.org/glib/func.g_mkdir_with_parents.html
//
func MkdirWithParents(pathname string, mode int32) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pathname)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(mode)

	cret = C.g_mkdir_with_parents(carg1, carg2)
	runtime.KeepAlive(pathname)
	runtime.KeepAlive(mode)

	var goret int32

	goret = int32(cret)

	return goret
}

// NumberParserErrorQuark wraps g_number_parser_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_number_parser_error_quark.html
func NumberParserErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_number_parser_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// OnErrorQuery wraps g_on_error_query
// 
// see also https://docs.gtk.org/glib/func.g_on_error_query.html
//
func OnErrorQuery(prgName string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_on_error_query(carg1)
	runtime.KeepAlive(prgName)
}

// OnErrorStackTrace wraps g_on_error_stack_trace
// 
// see also https://docs.gtk.org/glib/func.g_on_error_stack_trace.html
//
func OnErrorStackTrace(prgName string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if prgName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgName)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_on_error_stack_trace(carg1)
	runtime.KeepAlive(prgName)
}

// OptionErrorQuark wraps g_option_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_option_error_quark.html
func OptionErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_option_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ParseDebugString wraps g_parse_debug_string
// 
// see also https://docs.gtk.org/glib/func.g_parse_debug_string.html
//
func ParseDebugString(str string, keys []DebugKey) uint {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var carg2 *C.GDebugKey // in, transfer: none, C Pointers: 1, Name: array[DebugKey], array (inner GDebugKey (*typesystem.Record), length-by: carg3)
	var carg3 C.guint      // implicit
	var cret  C.guint      // return, none, casted

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = keys
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []DebugKey (const GDebugKey*) because of unimplemented: non-fixed size array")

	cret = C.g_parse_debug_string(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(keys)

	var goret uint

	goret = uint(cret)

	return goret
}

// PathGetBasename wraps g_path_get_basename
// 
// see also https://docs.gtk.org/glib/func.g_path_get_basename.html
//
func PathGetBasename(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_get_basename(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// PathGetDirname wraps g_path_get_dirname
// 
// see also https://docs.gtk.org/glib/func.g_path_get_dirname.html
//
func PathGetDirname(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_get_dirname(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// PathIsAbsolute wraps g_path_is_absolute
// 
// see also https://docs.gtk.org/glib/func.g_path_is_absolute.html
//
func PathIsAbsolute(fileName string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_is_absolute(carg1)
	runtime.KeepAlive(fileName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PathSkipRoot wraps g_path_skip_root
// 
// see also https://docs.gtk.org/glib/func.g_path_skip_root.html
//
func PathSkipRoot(fileName string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_skip_root(carg1)
	runtime.KeepAlive(fileName)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// PatternMatchSimple wraps g_pattern_match_simple
// 
// see also https://docs.gtk.org/glib/func.g_pattern_match_simple.html
//
func PatternMatchSimple(pattern string, str string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_pattern_match_simple(carg1, carg2)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Poll wraps g_poll
// 
// see also https://docs.gtk.org/glib/func.g_poll.html
//
func Poll(fds *PollFD, nfds uint, timeout int32) int32 {
	var carg1 *C.GPollFD // in, none, converted
	var carg2 C.guint    // in, none, casted
	var carg3 C.gint     // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fds))
	carg2 = C.guint(nfds)
	carg3 = C.gint(timeout)

	cret = C.g_poll(carg1, carg2, carg3)
	runtime.KeepAlive(fds)
	runtime.KeepAlive(nfds)
	runtime.KeepAlive(timeout)

	var goret int32

	goret = int32(cret)

	return goret
}

// PropagateError wraps g_propagate_error
// 
// see also https://docs.gtk.org/glib/func.g_propagate_error.html
//
func PropagateError(src error) error {
	var carg2 *C.GError // in, full, converted
	var carg1 *C.GError // out, full, converted, nullable

	carg2 = (*C.GError)(UnsafeErrorToGlibFull(src))

	C.g_propagate_error(&carg1, carg2)
	runtime.KeepAlive(src)

	var dest error

	if carg1 != nil {
		dest = UnsafeErrorFromGlibFull(unsafe.Pointer(carg1))
	}

	return dest
}

// QuarkFromStaticString wraps g_quark_from_static_string
// 
// see also https://docs.gtk.org/glib/func.g_quark_from_static_string.html
//
func QuarkFromStaticString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_from_static_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// QuarkFromString wraps g_quark_from_string
// 
// see also https://docs.gtk.org/glib/func.g_quark_from_string.html
//
func QuarkFromString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_from_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// QuarkToString wraps g_quark_to_string
// 
// see also https://docs.gtk.org/glib/func.g_quark_to_string.html
//
func QuarkToString(quark Quark) string {
	var carg1 C.GQuark // in, none, casted, alias
	var cret  *C.gchar // return, none, string

	carg1 = C.GQuark(quark)

	cret = C.g_quark_to_string(carg1)
	runtime.KeepAlive(quark)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// QuarkTryString wraps g_quark_try_string
// 
// see also https://docs.gtk.org/glib/func.g_quark_try_string.html
//
func QuarkTryString(str string) Quark {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  C.GQuark // return, none, casted, alias

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_quark_try_string(carg1)
	runtime.KeepAlive(str)

	var goret Quark

	goret = Quark(cret)

	return goret
}

// RandomDouble wraps g_random_double
// 
// see also https://docs.gtk.org/glib/func.g_random_double.html
//
func RandomDouble() float64 {
	var cret C.gdouble // return, none, casted

	cret = C.g_random_double()

	var goret float64

	goret = float64(cret)

	return goret
}

// RandomDoubleRange wraps g_random_double_range
// 
// see also https://docs.gtk.org/glib/func.g_random_double_range.html
//
func RandomDoubleRange(begin float64, end float64) float64 {
	var carg1 C.gdouble // in, none, casted
	var carg2 C.gdouble // in, none, casted
	var cret  C.gdouble // return, none, casted

	carg1 = C.gdouble(begin)
	carg2 = C.gdouble(end)

	cret = C.g_random_double_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret float64

	goret = float64(cret)

	return goret
}

// RandomInt wraps g_random_int
// 
// see also https://docs.gtk.org/glib/func.g_random_int.html
//
func RandomInt() uint32 {
	var cret C.guint32 // return, none, casted

	cret = C.g_random_int()

	var goret uint32

	goret = uint32(cret)

	return goret
}

// RandomIntRange wraps g_random_int_range
// 
// see also https://docs.gtk.org/glib/func.g_random_int_range.html
//
func RandomIntRange(begin int32, end int32) int32 {
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_random_int_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// RandomSetSeed wraps g_random_set_seed
// 
// see also https://docs.gtk.org/glib/func.g_random_set_seed.html
//
func RandomSetSeed(seed uint32) {
	var carg1 C.guint32 // in, none, casted

	carg1 = C.guint32(seed)

	C.g_random_set_seed(carg1)
	runtime.KeepAlive(seed)
}

// RefCountCompare wraps g_ref_count_compare
// 
// see also https://docs.gtk.org/glib/func.g_ref_count_compare.html
//
func RefCountCompare(rc *int32, val int32) bool {
	var carg1 *C.grefcount // in, transfer: none, C Pointers: 1, Name: gint
	var carg2 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	_ = rc
	_ = carg1
	panic("unimplemented conversion of *int32 (grefcount*) because of no basic converter found")
	carg2 = C.gint(val)

	cret = C.g_ref_count_compare(carg1, carg2)
	runtime.KeepAlive(rc)
	runtime.KeepAlive(val)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RefCountInit wraps g_ref_count_init
// 
// see also https://docs.gtk.org/glib/func.g_ref_count_init.html
//
func RefCountInit() int32 {
	var carg1 C.grefcount // out, full, casted

	C.g_ref_count_init(&carg1)

	var rc int32

	rc = int32(carg1)

	return rc
}

// RefStringAcquire wraps g_ref_string_acquire
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_acquire.html
//
func RefStringAcquire(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_acquire(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringLength wraps g_ref_string_length
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_length.html
//
func RefStringLength(str string) uint {
	var carg1 *C.char // in, none, string
	var cret  C.gsize // return, none, casted

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_length(carg1)
	runtime.KeepAlive(str)

	var goret uint

	goret = uint(cret)

	return goret
}

// NewRefString wraps g_ref_string_new
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_new.html
//
func NewRefString(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_new(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringNewIntern wraps g_ref_string_new_intern
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_new_intern.html
//
func RefStringNewIntern(str string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_ref_string_new_intern(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringNewLen wraps g_ref_string_new_len
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_new_len.html
//
func RefStringNewLen(str string, len int) string {
	var carg1 *C.char  // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.char  // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_ref_string_new_len(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RefStringRelease wraps g_ref_string_release
// 
// see also https://docs.gtk.org/glib/func.g_ref_string_release.html
//
func RefStringRelease(str string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_ref_string_release(carg1)
	runtime.KeepAlive(str)
}

// ReloadUserSpecialDirsCache wraps g_reload_user_special_dirs_cache
// 
// see also https://docs.gtk.org/glib/func.g_reload_user_special_dirs_cache.html
//
func ReloadUserSpecialDirsCache() {

	C.g_reload_user_special_dirs_cache()
}

// SetApplicationName wraps g_set_application_name
// 
// see also https://docs.gtk.org/glib/func.g_set_application_name.html
//
func SetApplicationName(applicationName string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationName)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_set_application_name(carg1)
	runtime.KeepAlive(applicationName)
}

// SetErrorLiteral wraps g_set_error_literal
// 
// see also https://docs.gtk.org/glib/func.g_set_error_literal.html
//
func SetErrorLiteral(domain Quark, code int32, message string) error {
	var carg2 C.GQuark  // in, none, casted, alias
	var carg3 C.gint    // in, none, casted
	var carg4 *C.gchar  // in, none, string
	var carg1 *C.GError // out, full, converted

	carg2 = C.GQuark(domain)
	carg3 = C.gint(code)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_set_error_literal(&carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(message)

	var err error

	err = UnsafeErrorFromGlibFull(unsafe.Pointer(carg1))

	return err
}

// SetPrgname wraps g_set_prgname
// 
// see also https://docs.gtk.org/glib/func.g_set_prgname.html
//
func SetPrgname(prgname string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgname)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_set_prgname(carg1)
	runtime.KeepAlive(prgname)
}

// Setenv wraps g_setenv
// 
// see also https://docs.gtk.org/glib/func.g_setenv.html
//
func Setenv(variable string, value string, overwrite bool) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var carg3 C.gboolean // in
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg2))
	if overwrite {
		carg3 = C.TRUE
	}

	cret = C.g_setenv(carg1, carg2, carg3)
	runtime.KeepAlive(variable)
	runtime.KeepAlive(value)
	runtime.KeepAlive(overwrite)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ShellErrorQuark wraps g_shell_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_shell_error_quark.html
func ShellErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_shell_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// ShellParseArgv wraps g_shell_parse_argv
// 
// see also https://docs.gtk.org/glib/func.g_shell_parse_argv.html
//
func ShellParseArgv(commandLine string) ([]string, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gint     // implicit
	var carg3 **C.gchar  // out, transfer: full, C Pointers: 2, Name: array[filename], optional, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg2)
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_parse_argv(carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(commandLine)

	var argvp  []string
	var goret  bool
	var _goerr error

	_ = argvp
	_ = carg3
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return argvp, goret, _goerr
}

// ShellQuote wraps g_shell_quote
// 
// see also https://docs.gtk.org/glib/func.g_shell_quote.html
//
func ShellQuote(unquotedString string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(unquotedString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_quote(carg1)
	runtime.KeepAlive(unquotedString)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ShellUnquote wraps g_shell_unquote
// 
// see also https://docs.gtk.org/glib/func.g_shell_unquote.html
//
func ShellUnquote(quotedString string) (string, error) {
	var carg1 *C.gchar  // in, none, string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(quotedString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_shell_unquote(carg1, &_cerr)
	runtime.KeepAlive(quotedString)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SliceGetConfig wraps g_slice_get_config
// 
// see also https://docs.gtk.org/glib/func.g_slice_get_config.html
func SliceGetConfig(ckey SliceConfig) int64 {
	var carg1 C.GSliceConfig // in, none, casted
	var cret  C.gint64       // return, none, casted

	carg1 = C.GSliceConfig(ckey)

	cret = C.g_slice_get_config(carg1)
	runtime.KeepAlive(ckey)

	var goret int64

	goret = int64(cret)

	return goret
}

// SliceGetConfigState wraps g_slice_get_config_state
// 
// see also https://docs.gtk.org/glib/func.g_slice_get_config_state.html
func SliceGetConfigState(ckey SliceConfig, address int64, nValues *uint) *int64 {
	var carg1 C.GSliceConfig // in, none, casted
	var carg2 C.gint64       // in, none, casted
	var carg3 *C.guint       // in, transfer: none, C Pointers: 1, Name: guint
	var cret  *C.gint64      // return, transfer: none, C Pointers: 1, Name: gint64, scope: 

	carg1 = C.GSliceConfig(ckey)
	carg2 = C.gint64(address)
	_ = nValues
	_ = carg3
	panic("unimplemented conversion of *uint (guint*) because of no basic converter found")

	cret = C.g_slice_get_config_state(carg1, carg2, carg3)
	runtime.KeepAlive(ckey)
	runtime.KeepAlive(address)
	runtime.KeepAlive(nValues)

	var goret *int64

	_ = goret
	_ = cret
	panic("unimplemented conversion of *int64 (gint64*) because of unknown reason")

	return goret
}

// SliceSetConfig wraps g_slice_set_config
// 
// see also https://docs.gtk.org/glib/func.g_slice_set_config.html
func SliceSetConfig(ckey SliceConfig, value int64) {
	var carg1 C.GSliceConfig // in, none, casted
	var carg2 C.gint64       // in, none, casted

	carg1 = C.GSliceConfig(ckey)
	carg2 = C.gint64(value)

	C.g_slice_set_config(carg1, carg2)
	runtime.KeepAlive(ckey)
	runtime.KeepAlive(value)
}

// SpacedPrimesClosest wraps g_spaced_primes_closest
// 
// see also https://docs.gtk.org/glib/func.g_spaced_primes_closest.html
//
func SpacedPrimesClosest(num uint) uint {
	var carg1 C.guint // in, none, casted
	var cret  C.guint // return, none, casted

	carg1 = C.guint(num)

	cret = C.g_spaced_primes_closest(carg1)
	runtime.KeepAlive(num)

	var goret uint

	goret = uint(cret)

	return goret
}

// SpawnCheckWaitStatus wraps g_spawn_check_wait_status
// 
// see also https://docs.gtk.org/glib/func.g_spawn_check_wait_status.html
//
func SpawnCheckWaitStatus(waitStatus int32) (bool, error) {
	var carg1 C.gint     // in, none, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = C.gint(waitStatus)

	cret = C.g_spawn_check_wait_status(carg1, &_cerr)
	runtime.KeepAlive(waitStatus)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpawnClosePid wraps g_spawn_close_pid
// 
// see also https://docs.gtk.org/glib/func.g_spawn_close_pid.html
//
func SpawnClosePid(pid Pid) {
	var carg1 C.GPid // in, none, casted, alias

	carg1 = C.GPid(pid)

	C.g_spawn_close_pid(carg1)
	runtime.KeepAlive(pid)
}

// SpawnCommandLineAsync wraps g_spawn_command_line_async
// 
// see also https://docs.gtk.org/glib/func.g_spawn_command_line_async.html
//
func SpawnCommandLineAsync(commandLine string) (bool, error) {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_spawn_command_line_async(carg1, &_cerr)
	runtime.KeepAlive(commandLine)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SpawnCommandLineSync wraps g_spawn_command_line_sync
// 
// see also https://docs.gtk.org/glib/func.g_spawn_command_line_sync.html
//
func SpawnCommandLineSync(commandLine string) (string, string, int32, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], optional, array (inner unknown, zero-terminated)
	var carg3 *C.gchar   // out, transfer: full, C Pointers: 1, Name: array[unknown], optional, array (inner unknown, zero-terminated)
	var carg4 C.gint     // out, full, casted
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(commandLine)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_spawn_command_line_sync(carg1, &carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(commandLine)

	var standardOutput string
	var standardError  string
	var waitStatus     int32
	var goret          bool
	var _goerr         error

	_ = standardOutput
	_ = carg2
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	_ = standardError
	_ = carg3
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	waitStatus = int32(carg4)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return standardOutput, standardError, waitStatus, goret, _goerr
}

// SpawnErrorQuark wraps g_spawn_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_spawn_error_quark.html
func SpawnErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_spawn_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// SpawnExitErrorQuark wraps g_spawn_exit_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_spawn_exit_error_quark.html
func SpawnExitErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_spawn_exit_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// Stpcpy wraps g_stpcpy
// 
// see also https://docs.gtk.org/glib/func.g_stpcpy.html
//
func Stpcpy(dest string, src string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.char  // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_stpcpy(carg1, carg2)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// StrHasPrefix wraps g_str_has_prefix
// 
// see also https://docs.gtk.org/glib/func.g_str_has_prefix.html
//
func StrHasPrefix(str string, prefix string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(prefix)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_str_has_prefix(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(prefix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrHasSuffix wraps g_str_has_suffix
// 
// see also https://docs.gtk.org/glib/func.g_str_has_suffix.html
//
func StrHasSuffix(str string, suffix string) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(suffix)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_str_has_suffix(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(suffix)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrIsASCII wraps g_str_is_ascii
// 
// see also https://docs.gtk.org/glib/func.g_str_is_ascii.html
//
func StrIsASCII(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_str_is_ascii(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrMatchString wraps g_str_match_string
// 
// see also https://docs.gtk.org/glib/func.g_str_match_string.html
//
func StrMatchString(searchTerm string, potentialHit string, acceptAlternates bool) bool {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string
	var carg3 C.gboolean // in
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(searchTerm)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(potentialHit)))
	defer C.free(unsafe.Pointer(carg2))
	if acceptAlternates {
		carg3 = C.TRUE
	}

	cret = C.g_str_match_string(carg1, carg2, carg3)
	runtime.KeepAlive(searchTerm)
	runtime.KeepAlive(potentialHit)
	runtime.KeepAlive(acceptAlternates)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrToASCII wraps g_str_to_ascii
// 
// see also https://docs.gtk.org/glib/func.g_str_to_ascii.html
//
func StrToASCII(str string, fromLocale string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if fromLocale != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(fromLocale)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_str_to_ascii(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(fromLocale)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strcanon wraps g_strcanon
// 
// see also https://docs.gtk.org/glib/func.g_strcanon.html
//
func Strcanon(str string, validChars string, substitutor byte) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(validChars)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gchar(substitutor)

	cret = C.g_strcanon(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(validChars)
	runtime.KeepAlive(substitutor)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strchomp wraps g_strchomp
// 
// see also https://docs.gtk.org/glib/func.g_strchomp.html
//
func Strchomp(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strchomp(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strchug wraps g_strchug
// 
// see also https://docs.gtk.org/glib/func.g_strchug.html
//
func Strchug(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strchug(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strcmp0 wraps g_strcmp0
// 
// see also https://docs.gtk.org/glib/func.g_strcmp0.html
//
func Strcmp0(str1 string, str2 string) int32 {
	var carg1 *C.char // in, none, string, nullable-string
	var carg2 *C.char // in, none, string, nullable-string
	var cret  C.int   // return, none, casted

	if str1 != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(str1)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if str2 != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(str2)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_strcmp0(carg1, carg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var goret int32

	goret = int32(cret)

	return goret
}

// Strcompress wraps g_strcompress
// 
// see also https://docs.gtk.org/glib/func.g_strcompress.html
//
func Strcompress(source string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strcompress(carg1)
	runtime.KeepAlive(source)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdelimit wraps g_strdelimit
// 
// see also https://docs.gtk.org/glib/func.g_strdelimit.html
//
func Strdelimit(str string, delimiters string, newDelimiter byte) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var carg3 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if delimiters != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiters)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = C.gchar(newDelimiter)

	cret = C.g_strdelimit(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiters)
	runtime.KeepAlive(newDelimiter)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdup wraps g_strdup
// 
// see also https://docs.gtk.org/glib/func.g_strdup.html
//
func Strdup(str string) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_strdup(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strdupv wraps g_strdupv
// 
// see also https://docs.gtk.org/glib/func.g_strdupv.html
//
func Strdupv(strArray []string) []string {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strdupv(carg1)
	runtime.KeepAlive(strArray)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// Strerror wraps g_strerror
// 
// see also https://docs.gtk.org/glib/func.g_strerror.html
//
func Strerror(errnum int32) string {
	var carg1 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = C.gint(errnum)

	cret = C.g_strerror(carg1)
	runtime.KeepAlive(errnum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strescape wraps g_strescape
// 
// see also https://docs.gtk.org/glib/func.g_strescape.html
//
func Strescape(source string, exceptions string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(carg1))
	if exceptions != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(exceptions)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_strescape(carg1, carg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(exceptions)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strfreev wraps g_strfreev
// 
// see also https://docs.gtk.org/glib/func.g_strfreev.html
//
func Strfreev(strArray []string) {
	var carg1 **C.gchar // in, transfer: full, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	C.g_strfreev(carg1)
	runtime.KeepAlive(strArray)
}

// StripContext wraps g_strip_context
// 
// see also https://docs.gtk.org/glib/func.g_strip_context.html
//
func StripContext(msgid string, msgval string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msgid)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(msgval)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strip_context(carg1, carg2)
	runtime.KeepAlive(msgid)
	runtime.KeepAlive(msgval)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strjoinv wraps g_strjoinv
// 
// see also https://docs.gtk.org/glib/func.g_strjoinv.html
//
func Strjoinv(separator string, strArray []string) string {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var carg2 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  *C.gchar  // return, full, string

	if separator != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(separator)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = strArray
	_ = carg2
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strjoinv(carg1, carg2)
	runtime.KeepAlive(separator)
	runtime.KeepAlive(strArray)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strlcat wraps g_strlcat
// 
// see also https://docs.gtk.org/glib/func.g_strlcat.html
//
func Strlcat(dest string, src string, destSize uint) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(destSize)

	cret = C.g_strlcat(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destSize)

	var goret uint

	goret = uint(cret)

	return goret
}

// Strlcpy wraps g_strlcpy
// 
// see also https://docs.gtk.org/glib/func.g_strlcpy.html
//
func Strlcpy(dest string, src string, destSize uint) uint {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(destSize)

	cret = C.g_strlcpy(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destSize)

	var goret uint

	goret = uint(cret)

	return goret
}

// Strndup wraps g_strndup
// 
// see also https://docs.gtk.org/glib/func.g_strndup.html
//
func Strndup(str string, n uint) string {
	var carg1 *C.gchar // in, none, string, nullable-string
	var carg2 C.gsize  // in, none, casted
	var cret  *C.gchar // return, full, string, nullable-string

	if str != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.gsize(n)

	cret = C.g_strndup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(n)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Strnfill wraps g_strnfill
// 
// see also https://docs.gtk.org/glib/func.g_strnfill.html
//
func Strnfill(length uint, fillChar byte) string {
	var carg1 C.gsize  // in, none, casted
	var carg2 C.gchar  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = C.gsize(length)
	carg2 = C.gchar(fillChar)

	cret = C.g_strnfill(carg1, carg2)
	runtime.KeepAlive(length)
	runtime.KeepAlive(fillChar)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strreverse wraps g_strreverse
// 
// see also https://docs.gtk.org/glib/func.g_strreverse.html
//
func Strreverse(str string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strreverse(carg1)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Strrstr wraps g_strrstr
// 
// see also https://docs.gtk.org/glib/func.g_strrstr.html
//
func Strrstr(haystack string, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strrstr(carg1, carg2)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// StrrstrLen wraps g_strrstr_len
// 
// see also https://docs.gtk.org/glib/func.g_strrstr_len.html
//
func StrrstrLen(haystack string, haystackLen int, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(haystackLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_strrstr_len(carg1, carg2, carg3)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(haystackLen)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Strsignal wraps g_strsignal
// 
// see also https://docs.gtk.org/glib/func.g_strsignal.html
//
func Strsignal(signum int32) string {
	var carg1 C.gint   // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = C.gint(signum)

	cret = C.g_strsignal(carg1)
	runtime.KeepAlive(signum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Strsplit wraps g_strsplit
// 
// see also https://docs.gtk.org/glib/func.g_strsplit.html
//
func Strsplit(str string, delimiter string, maxTokens int32) []string {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string
	var carg3 C.gint    // in, none, casted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiter)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(maxTokens)

	cret = C.g_strsplit(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiter)
	runtime.KeepAlive(maxTokens)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// StrsplitSet wraps g_strsplit_set
// 
// see also https://docs.gtk.org/glib/func.g_strsplit_set.html
//
func StrsplitSet(str string, delimiters string, maxTokens int32) []string {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // in, none, string
	var carg3 C.gint    // in, none, casted
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(delimiters)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(maxTokens)

	cret = C.g_strsplit_set(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(delimiters)
	runtime.KeepAlive(maxTokens)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// StrstrLen wraps g_strstr_len
// 
// see also https://docs.gtk.org/glib/func.g_strstr_len.html
//
func StrstrLen(haystack string, haystackLen int, needle string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var carg3 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(haystack)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(haystackLen)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(needle)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_strstr_len(carg1, carg2, carg3)
	runtime.KeepAlive(haystack)
	runtime.KeepAlive(haystackLen)
	runtime.KeepAlive(needle)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// Strtod wraps g_strtod
// 
// see also https://docs.gtk.org/glib/func.g_strtod.html
//
func Strtod(nptr string) (string, float64) {
	var carg1 *C.gchar  // in, none, string
	var carg2 *C.gchar  // out, none, string
	var cret  C.gdouble // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(nptr)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_strtod(carg1, &carg2)
	runtime.KeepAlive(nptr)

	var endptr string
	var goret  float64

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	goret = float64(cret)

	return endptr, goret
}

// StrvContains wraps g_strv_contains
// 
// see also https://docs.gtk.org/glib/func.g_strv_contains.html
//
func StrvContains(strv []string, str string) bool {
	var carg1 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	_ = strv
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_strv_contains(carg1, carg2)
	runtime.KeepAlive(strv)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrvEqual wraps g_strv_equal
// 
// see also https://docs.gtk.org/glib/func.g_strv_equal.html
//
func StrvEqual(strv1 []string, strv2 []string) bool {
	var carg1 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg2 **C.gchar  // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.gboolean // return

	_ = strv1
	_ = carg1
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")
	_ = strv2
	_ = carg2
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	cret = C.g_strv_equal(carg1, carg2)
	runtime.KeepAlive(strv1)
	runtime.KeepAlive(strv2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// StrvLength wraps g_strv_length
// 
// see also https://docs.gtk.org/glib/func.g_strv_length.html
//
func StrvLength(strArray []string) uint {
	var carg1 **C.gchar // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var cret  C.guint   // return, none, casted

	_ = strArray
	_ = carg1
	panic("unimplemented conversion of []string (gchar**) because of unimplemented: inner pointers in array")

	cret = C.g_strv_length(carg1)
	runtime.KeepAlive(strArray)

	var goret uint

	goret = uint(cret)

	return goret
}

// TestAssertExpectedMessagesInternal wraps g_test_assert_expected_messages_internal
// 
// see also https://docs.gtk.org/glib/func.g_test_assert_expected_messages_internal.html
func TestAssertExpectedMessagesInternal(domain string, file string, line int32, fn string) {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string
	var carg3 C.int   // in, none, casted
	var carg4 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_test_assert_expected_messages_internal(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
}

// TestBug wraps g_test_bug
// 
// see also https://docs.gtk.org/glib/func.g_test_bug.html
//
func TestBug(bugUriSnippet string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(bugUriSnippet)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_bug(carg1)
	runtime.KeepAlive(bugUriSnippet)
}

// TestBugBase wraps g_test_bug_base
// 
// see also https://docs.gtk.org/glib/func.g_test_bug_base.html
//
func TestBugBase(uriPattern string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uriPattern)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_bug_base(carg1)
	runtime.KeepAlive(uriPattern)
}

// TestDisableCrashReporting wraps g_test_disable_crash_reporting
// 
// see also https://docs.gtk.org/glib/func.g_test_disable_crash_reporting.html
//
func TestDisableCrashReporting() {

	C.g_test_disable_crash_reporting()
}

// TestExpectMessage wraps g_test_expect_message
// 
// see also https://docs.gtk.org/glib/func.g_test_expect_message.html
//
func TestExpectMessage(logDomain string, logLevel LogLevelFlags, pattern string) {
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 C.GLogLevelFlags // in, none, casted
	var carg3 *C.gchar         // in, none, string

	if logDomain != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.GLogLevelFlags(logLevel)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_test_expect_message(carg1, carg2, carg3)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(pattern)
}

// TestFail wraps g_test_fail
// 
// see also https://docs.gtk.org/glib/func.g_test_fail.html
//
func TestFail() {

	C.g_test_fail()
}

// TestFailed wraps g_test_failed
// 
// see also https://docs.gtk.org/glib/func.g_test_failed.html
//
func TestFailed() bool {
	var cret C.gboolean // return

	cret = C.g_test_failed()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestGetDir wraps g_test_get_dir
// 
// see also https://docs.gtk.org/glib/func.g_test_get_dir.html
//
func TestGetDir(fileType TestFileType) string {
	var carg1 C.GTestFileType // in, none, casted
	var cret  *C.gchar        // return, none, string

	carg1 = C.GTestFileType(fileType)

	cret = C.g_test_get_dir(carg1)
	runtime.KeepAlive(fileType)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestGetPath wraps g_test_get_path
// 
// see also https://docs.gtk.org/glib/func.g_test_get_path.html
//
func TestGetPath() string {
	var cret *C.char // return, none, string

	cret = C.g_test_get_path()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestIncomplete wraps g_test_incomplete
// 
// see also https://docs.gtk.org/glib/func.g_test_incomplete.html
//
func TestIncomplete(msg string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if msg != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msg)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_test_incomplete(carg1)
	runtime.KeepAlive(msg)
}

// TestLogTypeName wraps g_test_log_type_name
// 
// see also https://docs.gtk.org/glib/func.g_test_log_type_name.html
func TestLogTypeName(logType TestLogType) string {
	var carg1 C.GTestLogType // in, none, casted
	var cret  *C.char        // return, none, string

	carg1 = C.GTestLogType(logType)

	cret = C.g_test_log_type_name(carg1)
	runtime.KeepAlive(logType)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// TestRandDouble wraps g_test_rand_double
// 
// see also https://docs.gtk.org/glib/func.g_test_rand_double.html
//
func TestRandDouble() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_rand_double()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestRandDoubleRange wraps g_test_rand_double_range
// 
// see also https://docs.gtk.org/glib/func.g_test_rand_double_range.html
//
func TestRandDoubleRange(rangeStart float64, rangeEnd float64) float64 {
	var carg1 C.double // in, none, casted
	var carg2 C.double // in, none, casted
	var cret  C.double // return, none, casted

	carg1 = C.double(rangeStart)
	carg2 = C.double(rangeEnd)

	cret = C.g_test_rand_double_range(carg1, carg2)
	runtime.KeepAlive(rangeStart)
	runtime.KeepAlive(rangeEnd)

	var goret float64

	goret = float64(cret)

	return goret
}

// TestRandInt wraps g_test_rand_int
// 
// see also https://docs.gtk.org/glib/func.g_test_rand_int.html
//
func TestRandInt() int32 {
	var cret C.gint32 // return, none, casted

	cret = C.g_test_rand_int()

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRandIntRange wraps g_test_rand_int_range
// 
// see also https://docs.gtk.org/glib/func.g_test_rand_int_range.html
//
func TestRandIntRange(begin int32, end int32) int32 {
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_test_rand_int_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRun wraps g_test_run
// 
// see also https://docs.gtk.org/glib/func.g_test_run.html
//
func TestRun() int32 {
	var cret C.int // return, none, casted

	cret = C.g_test_run()

	var goret int32

	goret = int32(cret)

	return goret
}

// TestRunSuite wraps g_test_run_suite
// 
// see also https://docs.gtk.org/glib/func.g_test_run_suite.html
//
func TestRunSuite(suite *TestSuite) int32 {
	var carg1 *C.GTestSuite // in, none, converted
	var cret  C.int         // return, none, casted

	carg1 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))

	cret = C.g_test_run_suite(carg1)
	runtime.KeepAlive(suite)

	var goret int32

	goret = int32(cret)

	return goret
}

// TestSetNonfatalAssertions wraps g_test_set_nonfatal_assertions
// 
// see also https://docs.gtk.org/glib/func.g_test_set_nonfatal_assertions.html
//
func TestSetNonfatalAssertions() {

	C.g_test_set_nonfatal_assertions()
}

// TestSkip wraps g_test_skip
// 
// see also https://docs.gtk.org/glib/func.g_test_skip.html
//
func TestSkip(msg string) {
	var carg1 *C.gchar // in, none, string, nullable-string

	if msg != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(msg)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_test_skip(carg1)
	runtime.KeepAlive(msg)
}

// TestSubprocess wraps g_test_subprocess
// 
// see also https://docs.gtk.org/glib/func.g_test_subprocess.html
//
func TestSubprocess() bool {
	var cret C.gboolean // return

	cret = C.g_test_subprocess()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestSummary wraps g_test_summary
// 
// see also https://docs.gtk.org/glib/func.g_test_summary.html
//
func TestSummary(summary string) {
	var carg1 *C.char // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(summary)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_test_summary(carg1)
	runtime.KeepAlive(summary)
}

// TestTimerElapsed wraps g_test_timer_elapsed
// 
// see also https://docs.gtk.org/glib/func.g_test_timer_elapsed.html
//
func TestTimerElapsed() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_timer_elapsed()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestTimerLast wraps g_test_timer_last
// 
// see also https://docs.gtk.org/glib/func.g_test_timer_last.html
//
func TestTimerLast() float64 {
	var cret C.double // return, none, casted

	cret = C.g_test_timer_last()

	var goret float64

	goret = float64(cret)

	return goret
}

// TestTimerStart wraps g_test_timer_start
// 
// see also https://docs.gtk.org/glib/func.g_test_timer_start.html
//
func TestTimerStart() {

	C.g_test_timer_start()
}

// TestTrapAssertions wraps g_test_trap_assertions
// 
// see also https://docs.gtk.org/glib/func.g_test_trap_assertions.html
func TestTrapAssertions(domain string, file string, line int32, fn string, assertionFlags uint64, pattern string) {
	var carg1 *C.char   // in, none, string
	var carg2 *C.char   // in, none, string
	var carg3 C.int     // in, none, casted
	var carg4 *C.char   // in, none, string
	var carg5 C.guint64 // in, none, casted
	var carg6 *C.char   // in, none, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.int(line)
	carg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.guint64(assertionFlags)
	carg6 = (*C.char)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg6))

	C.g_test_trap_assertions(carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(assertionFlags)
	runtime.KeepAlive(pattern)
}

// TestTrapHasPassed wraps g_test_trap_has_passed
// 
// see also https://docs.gtk.org/glib/func.g_test_trap_has_passed.html
//
func TestTrapHasPassed() bool {
	var cret C.gboolean // return

	cret = C.g_test_trap_has_passed()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestTrapReachedTimeout wraps g_test_trap_reached_timeout
// 
// see also https://docs.gtk.org/glib/func.g_test_trap_reached_timeout.html
//
func TestTrapReachedTimeout() bool {
	var cret C.gboolean // return

	cret = C.g_test_trap_reached_timeout()

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// TestTrapSubprocess wraps g_test_trap_subprocess
// 
// see also https://docs.gtk.org/glib/func.g_test_trap_subprocess.html
//
func TestTrapSubprocess(testPath string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var carg1 *C.char                // in, none, string, nullable-string
	var carg2 C.guint64              // in, none, casted
	var carg3 C.GTestSubprocessFlags // in, none, casted

	if testPath != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(testPath)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.guint64(usecTimeout)
	carg3 = C.GTestSubprocessFlags(testFlags)

	C.g_test_trap_subprocess(carg1, carg2, carg3)
	runtime.KeepAlive(testPath)
	runtime.KeepAlive(usecTimeout)
	runtime.KeepAlive(testFlags)
}

// TestTrapSubprocessWithEnvp wraps g_test_trap_subprocess_with_envp
// 
// see also https://docs.gtk.org/glib/func.g_test_trap_subprocess_with_envp.html
//
func TestTrapSubprocessWithEnvp(testPath string, envp []string, usecTimeout uint64, testFlags TestSubprocessFlags) {
	var carg1 *C.char                // in, none, string, nullable-string
	var carg2 **C.char               // in, transfer: none, C Pointers: 2, Name: array[filename], nullable, array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg3 C.guint64              // in, none, casted
	var carg4 C.GTestSubprocessFlags // in, none, casted

	if testPath != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(testPath)))
		defer C.free(unsafe.Pointer(carg1))
	}
	_ = envp
	_ = carg2
	panic("unimplemented conversion of []string (const char* const*) because of unimplemented: inner pointers in array")
	carg3 = C.guint64(usecTimeout)
	carg4 = C.GTestSubprocessFlags(testFlags)

	C.g_test_trap_subprocess_with_envp(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(testPath)
	runtime.KeepAlive(envp)
	runtime.KeepAlive(usecTimeout)
	runtime.KeepAlive(testFlags)
}

// TimeoutAddFull wraps g_timeout_add_full
// 
// see also https://docs.gtk.org/glib/func.g_timeout_add_full.html
//
func TimeoutAddFull(priority int32, interval uint, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.guint          // in, none, casted
	var carg3 C.GSourceFunc    // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.guint(interval)
	carg3 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_timeout_add_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// TimeoutAddSecondsFull wraps g_timeout_add_seconds_full
// 
// see also https://docs.gtk.org/glib/func.g_timeout_add_seconds_full.html
//
func TimeoutAddSecondsFull(priority int32, interval uint, function SourceFunc) uint {
	var carg1 C.gint           // in, none, casted
	var carg2 C.guint          // in, none, casted
	var carg3 C.GSourceFunc    // callback, scope: notified, closure: carg4, destroy: carg5
	var carg4 C.gpointer       // implicit
	var carg5 C.GDestroyNotify // implicit
	var cret  C.guint          // return, none, casted

	carg1 = C.gint(priority)
	carg2 = C.guint(interval)
	carg3 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg4 = C.gpointer(userdata.Register(function))
	carg5 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	cret = C.g_timeout_add_seconds_full(carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(function)

	var goret uint

	goret = uint(cret)

	return goret
}

// UCS4ToUTF8 wraps g_ucs4_to_utf8
// 
// see also https://docs.gtk.org/glib/func.g_ucs4_to_utf8.html
//
func UCS4ToUTF8(str []uint32) (int32, int32, string, error) {
	var carg1 *C.gunichar // in, transfer: none, C Pointers: 1, Name: array[gunichar], array (inner gunichar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong     // implicit
	var carg3 C.glong     // out, full, casted
	var carg4 C.glong     // out, full, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint32 (const gunichar*) because of unimplemented: non-fixed size array")

	cret = C.g_ucs4_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        string
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UnicharBreakType wraps g_unichar_break_type
// 
// see also https://docs.gtk.org/glib/func.g_unichar_break_type.html
//
func UnicharBreakType(c uint32) UnicodeBreakType {
	var carg1 C.gunichar          // in, none, casted
	var cret  C.GUnicodeBreakType // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_break_type(carg1)
	runtime.KeepAlive(c)

	var goret UnicodeBreakType

	goret = UnicodeBreakType(cret)

	return goret
}

// UnicharCombiningClass wraps g_unichar_combining_class
// 
// see also https://docs.gtk.org/glib/func.g_unichar_combining_class.html
//
func UnicharCombiningClass(uc uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(uc)

	cret = C.g_unichar_combining_class(carg1)
	runtime.KeepAlive(uc)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicharCompose wraps g_unichar_compose
// 
// see also https://docs.gtk.org/glib/func.g_unichar_compose.html
//
func UnicharCompose(a uint32, b uint32) (uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // in, none, casted
	var carg3 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(a)
	carg2 = C.gunichar(b)

	cret = C.g_unichar_compose(carg1, carg2, &carg3)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var ch    uint32
	var goret bool

	ch = uint32(carg3)
	if cret != 0 {
		goret = true
	}

	return ch, goret
}

// UnicharDecompose wraps g_unichar_decompose
// 
// see also https://docs.gtk.org/glib/func.g_unichar_decompose.html
//
func UnicharDecompose(ch uint32) (uint32, uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // out, full, casted
	var carg3 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_decompose(carg1, &carg2, &carg3)
	runtime.KeepAlive(ch)

	var a     uint32
	var b     uint32
	var goret bool

	a = uint32(carg2)
	b = uint32(carg3)
	if cret != 0 {
		goret = true
	}

	return a, b, goret
}

// UnicharDigitValue wraps g_unichar_digit_value
// 
// see also https://docs.gtk.org/glib/func.g_unichar_digit_value.html
//
func UnicharDigitValue(c uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_digit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicharFullyDecompose wraps g_unichar_fully_decompose
// 
// see also https://docs.gtk.org/glib/func.g_unichar_fully_decompose.html
//
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gboolean // in
	var carg4 C.gsize    // in, none, casted
	var carg3 C.gunichar // out, transfer: none, C Pointers: 0, Name: gunichar, optional, caller-allocates
	var cret  C.gsize    // return, none, casted

	carg1 = C.gunichar(ch)
	if compat {
		carg2 = C.TRUE
	}
	carg4 = C.gsize(resultLen)

	cret = C.g_unichar_fully_decompose(carg1, carg2, &carg3, carg4)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(compat)
	runtime.KeepAlive(resultLen)

	var result uint32
	var goret  uint

	_ = result
	_ = carg3
	panic("unimplemented conversion of uint32 (gunichar) because of unknown reason")
	goret = uint(cret)

	return result, goret
}

// UnicharGetMirrorChar wraps g_unichar_get_mirror_char
// 
// see also https://docs.gtk.org/glib/func.g_unichar_get_mirror_char.html
//
func UnicharGetMirrorChar(ch uint32) (uint32, bool) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gunichar // out, full, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_get_mirror_char(carg1, &carg2)
	runtime.KeepAlive(ch)

	var mirroredCh uint32
	var goret      bool

	mirroredCh = uint32(carg2)
	if cret != 0 {
		goret = true
	}

	return mirroredCh, goret
}

// UnicharGetScript wraps g_unichar_get_script
// 
// see also https://docs.gtk.org/glib/func.g_unichar_get_script.html
//
func UnicharGetScript(ch uint32) UnicodeScript {
	var carg1 C.gunichar       // in, none, casted
	var cret  C.GUnicodeScript // return, none, casted

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_get_script(carg1)
	runtime.KeepAlive(ch)

	var goret UnicodeScript

	goret = UnicodeScript(cret)

	return goret
}

// UnicharIsalnum wraps g_unichar_isalnum
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isalnum.html
//
func UnicharIsalnum(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isalnum(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsalpha wraps g_unichar_isalpha
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isalpha.html
//
func UnicharIsalpha(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isalpha(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIscntrl wraps g_unichar_iscntrl
// 
// see also https://docs.gtk.org/glib/func.g_unichar_iscntrl.html
//
func UnicharIscntrl(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iscntrl(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsdefined wraps g_unichar_isdefined
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isdefined.html
//
func UnicharIsdefined(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isdefined(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsdigit wraps g_unichar_isdigit
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isdigit.html
//
func UnicharIsdigit(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isdigit(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsgraph wraps g_unichar_isgraph
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isgraph.html
//
func UnicharIsgraph(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isgraph(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIslower wraps g_unichar_islower
// 
// see also https://docs.gtk.org/glib/func.g_unichar_islower.html
//
func UnicharIslower(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_islower(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsmark wraps g_unichar_ismark
// 
// see also https://docs.gtk.org/glib/func.g_unichar_ismark.html
//
func UnicharIsmark(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_ismark(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsprint wraps g_unichar_isprint
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isprint.html
//
func UnicharIsprint(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isprint(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIspunct wraps g_unichar_ispunct
// 
// see also https://docs.gtk.org/glib/func.g_unichar_ispunct.html
//
func UnicharIspunct(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_ispunct(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsspace wraps g_unichar_isspace
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isspace.html
//
func UnicharIsspace(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isspace(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIstitle wraps g_unichar_istitle
// 
// see also https://docs.gtk.org/glib/func.g_unichar_istitle.html
//
func UnicharIstitle(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_istitle(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsupper wraps g_unichar_isupper
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isupper.html
//
func UnicharIsupper(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isupper(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIswide wraps g_unichar_iswide
// 
// see also https://docs.gtk.org/glib/func.g_unichar_iswide.html
//
func UnicharIswide(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iswide(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIswideCjk wraps g_unichar_iswide_cjk
// 
// see also https://docs.gtk.org/glib/func.g_unichar_iswide_cjk.html
//
func UnicharIswideCjk(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iswide_cjk(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIsxdigit wraps g_unichar_isxdigit
// 
// see also https://docs.gtk.org/glib/func.g_unichar_isxdigit.html
//
func UnicharIsxdigit(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_isxdigit(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharIszerowidth wraps g_unichar_iszerowidth
// 
// see also https://docs.gtk.org/glib/func.g_unichar_iszerowidth.html
//
func UnicharIszerowidth(c uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(c)

	cret = C.g_unichar_iszerowidth(carg1)
	runtime.KeepAlive(c)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharToUTF8 wraps g_unichar_to_utf8
// 
// see also https://docs.gtk.org/glib/func.g_unichar_to_utf8.html
//
func UnicharToUTF8(c uint32) (byte, int32) {
	var carg1 C.gunichar // in, none, casted
	var carg2 C.gchar    // out, transfer: none, C Pointers: 0, Name: gchar, optional, caller-allocates
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_to_utf8(carg1, &carg2)
	runtime.KeepAlive(c)

	var outbuf byte
	var goret  int32

	_ = outbuf
	_ = carg2
	panic("unimplemented conversion of byte (gchar) because of unknown reason")
	goret = int32(cret)

	return outbuf, goret
}

// UnicharTolower wraps g_unichar_tolower
// 
// see also https://docs.gtk.org/glib/func.g_unichar_tolower.html
//
func UnicharTolower(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_tolower(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharTotitle wraps g_unichar_totitle
// 
// see also https://docs.gtk.org/glib/func.g_unichar_totitle.html
//
func UnicharTotitle(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_totitle(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharToupper wraps g_unichar_toupper
// 
// see also https://docs.gtk.org/glib/func.g_unichar_toupper.html
//
func UnicharToupper(c uint32) uint32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_toupper(carg1)
	runtime.KeepAlive(c)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UnicharType wraps g_unichar_type
// 
// see also https://docs.gtk.org/glib/func.g_unichar_type.html
//
func UnicharType(c uint32) UnicodeType {
	var carg1 C.gunichar     // in, none, casted
	var cret  C.GUnicodeType // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_type(carg1)
	runtime.KeepAlive(c)

	var goret UnicodeType

	goret = UnicodeType(cret)

	return goret
}

// UnicharValidate wraps g_unichar_validate
// 
// see also https://docs.gtk.org/glib/func.g_unichar_validate.html
//
func UnicharValidate(ch uint32) bool {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gboolean // return

	carg1 = C.gunichar(ch)

	cret = C.g_unichar_validate(carg1)
	runtime.KeepAlive(ch)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UnicharXdigitValue wraps g_unichar_xdigit_value
// 
// see also https://docs.gtk.org/glib/func.g_unichar_xdigit_value.html
//
func UnicharXdigitValue(c uint32) int32 {
	var carg1 C.gunichar // in, none, casted
	var cret  C.gint     // return, none, casted

	carg1 = C.gunichar(c)

	cret = C.g_unichar_xdigit_value(carg1)
	runtime.KeepAlive(c)

	var goret int32

	goret = int32(cret)

	return goret
}

// UnicodeCanonicalOrdering wraps g_unicode_canonical_ordering
// 
// see also https://docs.gtk.org/glib/func.g_unicode_canonical_ordering.html
//
func UnicodeCanonicalOrdering(str []uint32) {
	var carg1 *C.gunichar // in, transfer: none, C Pointers: 1, Name: array[gunichar], array (inner gunichar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize     // implicit

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint32 (gunichar*) because of unimplemented: non-fixed size array")

	C.g_unicode_canonical_ordering(carg1, carg2)
	runtime.KeepAlive(str)
}

// Unsetenv wraps g_unsetenv
// 
// see also https://docs.gtk.org/glib/func.g_unsetenv.html
//
func Unsetenv(variable string) {
	var carg1 *C.gchar // in, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(variable)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_unsetenv(carg1)
	runtime.KeepAlive(variable)
}

// Usleep wraps g_usleep
// 
// see also https://docs.gtk.org/glib/func.g_usleep.html
//
func Usleep(microseconds uint32) {
	var carg1 C.gulong // in, none, casted

	carg1 = C.gulong(microseconds)

	C.g_usleep(carg1)
	runtime.KeepAlive(microseconds)
}

// UTF16ToUCS4 wraps g_utf16_to_ucs4
// 
// see also https://docs.gtk.org/glib/func.g_utf16_to_ucs4.html
//
func UTF16ToUCS4(str []uint16) (int32, int32, *uint32, error) {
	var carg1 *C.gunichar2 // in, transfer: none, C Pointers: 1, Name: array[guint16], array (inner guint16 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong      // implicit
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gunichar  // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 
	var _cerr *C.GError    // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint16 (const gunichar2*) because of unimplemented: non-fixed size array")

	cret = C.g_utf16_to_ucs4(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint32
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF16ToUTF8 wraps g_utf16_to_utf8
// 
// see also https://docs.gtk.org/glib/func.g_utf16_to_utf8.html
//
func UTF16ToUTF8(str []uint16) (int32, int32, string, error) {
	var carg1 *C.gunichar2 // in, transfer: none, C Pointers: 1, Name: array[guint16], array (inner guint16 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.glong      // implicit
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gchar     // return, full, string
	var _cerr *C.GError    // out, full, converted, nullable

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint16 (const gunichar2*) because of unimplemented: non-fixed size array")

	cret = C.g_utf16_to_utf8(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)

	var itemsRead    int32
	var itemsWritten int32
	var goret        string
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8Casefold wraps g_utf8_casefold
// 
// see also https://docs.gtk.org/glib/func.g_utf8_casefold.html
//
func UTF8Casefold(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_casefold(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Collate wraps g_utf8_collate
// 
// see also https://docs.gtk.org/glib/func.g_utf8_collate.html
//
func UTF8Collate(str1 string, str2 string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.gint   // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str1)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str2)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_collate(carg1, carg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8CollateKey wraps g_utf8_collate_key
// 
// see also https://docs.gtk.org/glib/func.g_utf8_collate_key.html
//
func UTF8CollateKey(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_collate_key(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8CollateKeyForFilename wraps g_utf8_collate_key_for_filename
// 
// see also https://docs.gtk.org/glib/func.g_utf8_collate_key_for_filename.html
//
func UTF8CollateKeyForFilename(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_collate_key_for_filename(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8FindNextChar wraps g_utf8_find_next_char
// 
// see also https://docs.gtk.org/glib/func.g_utf8_find_next_char.html
//
func UTF8FindNextChar(p string, end string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string, nullable-string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	if end != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(end)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_utf8_find_next_char(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(end)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8FindPrevChar wraps g_utf8_find_prev_char
// 
// see also https://docs.gtk.org/glib/func.g_utf8_find_prev_char.html
//
func UTF8FindPrevChar(str string, p string) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_find_prev_char(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(p)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8GetChar wraps g_utf8_get_char
// 
// see also https://docs.gtk.org/glib/func.g_utf8_get_char.html
//
func UTF8GetChar(p string) uint32 {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gunichar // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_utf8_get_char(carg1)
	runtime.KeepAlive(p)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UTF8GetCharValidated wraps g_utf8_get_char_validated
// 
// see also https://docs.gtk.org/glib/func.g_utf8_get_char_validated.html
//
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var cret  C.gunichar // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(maxLen)

	cret = C.g_utf8_get_char_validated(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(maxLen)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// UTF8MakeValid wraps g_utf8_make_valid
// 
// see also https://docs.gtk.org/glib/func.g_utf8_make_valid.html
//
func UTF8MakeValid(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_make_valid(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Normalize wraps g_utf8_normalize
// 
// see also https://docs.gtk.org/glib/func.g_utf8_normalize.html
//
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gssize         // in, none, casted
	var carg3 C.GNormalizeMode // in, none, casted
	var cret  *C.gchar         // return, full, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.GNormalizeMode(mode)

	cret = C.g_utf8_normalize(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)
	runtime.KeepAlive(mode)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UTF8OffsetToPointer wraps g_utf8_offset_to_pointer
// 
// see also https://docs.gtk.org/glib/func.g_utf8_offset_to_pointer.html
//
func UTF8OffsetToPointer(str string, offset int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.glong  // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(offset)

	cret = C.g_utf8_offset_to_pointer(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(offset)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8PointerToOffset wraps g_utf8_pointer_to_offset
// 
// see also https://docs.gtk.org/glib/func.g_utf8_pointer_to_offset.html
//
func UTF8PointerToOffset(str string, pos string) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var cret  C.glong  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(pos)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_utf8_pointer_to_offset(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(pos)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8PrevChar wraps g_utf8_prev_char
// 
// see also https://docs.gtk.org/glib/func.g_utf8_prev_char.html
//
func UTF8PrevChar(p string) string {
	var carg1 *C.gchar // in, none, string
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_utf8_prev_char(carg1)
	runtime.KeepAlive(p)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8Strchr wraps g_utf8_strchr
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strchr.html
//
func UTF8Strchr(p string, len int, c uint32) string {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var carg3 C.gunichar // in, none, casted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.gunichar(c)

	cret = C.g_utf8_strchr(carg1, carg2, carg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8Strdown wraps g_utf8_strdown
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strdown.html
//
func UTF8Strdown(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strdown(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Strlen wraps g_utf8_strlen
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strlen.html
//
func UTF8Strlen(p string, max int) int32 {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  C.glong  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(max)

	cret = C.g_utf8_strlen(carg1, carg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(max)

	var goret int32

	goret = int32(cret)

	return goret
}

// UTF8Strncpy wraps g_utf8_strncpy
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strncpy.html
//
func UTF8Strncpy(dest string, src string, n uint) string {
	var carg1 *C.gchar // in, none, string
	var carg2 *C.gchar // in, none, string
	var carg3 C.gsize  // in, none, casted
	var cret  *C.gchar // return, none, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gsize(n)

	cret = C.g_utf8_strncpy(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(n)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// UTF8Strrchr wraps g_utf8_strrchr
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strrchr.html
//
func UTF8Strrchr(p string, len int, c uint32) string {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gssize   // in, none, casted
	var carg3 C.gunichar // in, none, casted
	var cret  *C.gchar   // return, none, string, nullable-string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)
	carg3 = C.gunichar(c)

	cret = C.g_utf8_strrchr(carg1, carg2, carg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UTF8Strreverse wraps g_utf8_strreverse
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strreverse.html
//
func UTF8Strreverse(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strreverse(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Strup wraps g_utf8_strup
// 
// see also https://docs.gtk.org/glib/func.g_utf8_strup.html
//
func UTF8Strup(str string, len int) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gssize // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_utf8_strup(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Substring wraps g_utf8_substring
// 
// see also https://docs.gtk.org/glib/func.g_utf8_substring.html
//
func UTF8Substring(str string, startPos int32, endPos int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.glong  // in, none, casted
	var carg3 C.glong  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(startPos)
	carg3 = C.glong(endPos)

	cret = C.g_utf8_substring(carg1, carg2, carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8ToUCS4 wraps g_utf8_to_ucs4
// 
// see also https://docs.gtk.org/glib/func.g_utf8_to_ucs4.html
//
func UTF8ToUCS4(str string, len int32) (int32, int32, *uint32, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.glong     // in, none, casted
	var carg3 C.glong     // out, full, casted
	var carg4 C.glong     // out, full, casted
	var cret  *C.gunichar // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_ucs4(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint32
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8ToUCS4Fast wraps g_utf8_to_ucs4_fast
// 
// see also https://docs.gtk.org/glib/func.g_utf8_to_ucs4_fast.html
//
func UTF8ToUCS4Fast(str string, len int32) (int32, *uint32) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.glong     // in, none, casted
	var carg3 C.glong     // out, full, casted
	var cret  *C.gunichar // return, transfer: full, C Pointers: 1, Name: gunichar, scope: 

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_ucs4_fast(carg1, carg2, &carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsWritten int32
	var goret        *uint32

	itemsWritten = int32(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint32 (gunichar*) because of unknown reason")

	return itemsWritten, goret
}

// UTF8ToUTF16 wraps g_utf8_to_utf16
// 
// see also https://docs.gtk.org/glib/func.g_utf8_to_utf16.html
//
func UTF8ToUTF16(str string, len int32) (int32, int32, *uint16, error) {
	var carg1 *C.gchar     // in, none, string
	var carg2 C.glong      // in, none, casted
	var carg3 C.glong      // out, full, casted
	var carg4 C.glong      // out, full, casted
	var cret  *C.gunichar2 // return, transfer: full, C Pointers: 1, Name: guint16, scope: 
	var _cerr *C.GError    // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.glong(len)

	cret = C.g_utf8_to_utf16(carg1, carg2, &carg3, &carg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var itemsRead    int32
	var itemsWritten int32
	var goret        *uint16
	var _goerr       error

	itemsRead = int32(carg3)
	itemsWritten = int32(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of *uint16 (gunichar2*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return itemsRead, itemsWritten, goret, _goerr
}

// UTF8TruncateMiddle wraps g_utf8_truncate_middle
// 
// see also https://docs.gtk.org/glib/func.g_utf8_truncate_middle.html
//
func UTF8TruncateMiddle(str string, truncateLength uint) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gsize  // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gsize(truncateLength)

	cret = C.g_utf8_truncate_middle(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(truncateLength)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UTF8Validate wraps g_utf8_validate
// 
// see also https://docs.gtk.org/glib/func.g_utf8_validate.html
//
func UTF8Validate(str string) (string, bool) {
	var carg1 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize   // implicit
	var carg3 *C.gchar   // out, none, string
	var cret  C.gboolean // return

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_utf8_validate(carg1, carg2, &carg3)
	runtime.KeepAlive(str)

	var end   string
	var goret bool

	end = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	if cret != 0 {
		goret = true
	}

	return end, goret
}

// UTF8ValidateLen wraps g_utf8_validate_len
// 
// see also https://docs.gtk.org/glib/func.g_utf8_validate_len.html
//
func UTF8ValidateLen(str string) (string, bool) {
	var carg1 *C.gchar   // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize    // implicit
	var carg3 *C.gchar   // out, none, string
	var cret  C.gboolean // return

	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_utf8_validate_len(carg1, carg2, &carg3)
	runtime.KeepAlive(str)

	var end   string
	var goret bool

	end = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	if cret != 0 {
		goret = true
	}

	return end, goret
}

// UuidStringIsValid wraps g_uuid_string_is_valid
// 
// see also https://docs.gtk.org/glib/func.g_uuid_string_is_valid.html
//
func UuidStringIsValid(str string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uuid_string_is_valid(carg1)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// UuidStringRandom wraps g_uuid_string_random
// 
// see also https://docs.gtk.org/glib/func.g_uuid_string_random.html
//
func UuidStringRandom() string {
	var cret *C.gchar // return, full, string

	cret = C.g_uuid_string_random()

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// AsyncQueue wraps GAsyncQueue
// 
// see also https://docs.gtk.org/glib/struct.AsyncQueue.html
//
type AsyncQueue struct {
	*asyncQueue
}

// asyncQueue is the struct that's finalized
type asyncQueue struct {
	native *C.GAsyncQueue
}

// UnsafeAsyncQueueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (a *AsyncQueue) instance() *C.GAsyncQueue {
	if a == nil {
		return nil
	}
	return a.native
}

// UnsafeAsyncQueueFromGlibBorrow is used to convert raw C.GAsyncQueue pointers to go. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibBorrow(p unsafe.Pointer) *AsyncQueue {
	if p == nil {
		return nil
	}
	return &AsyncQueue{&asyncQueue{(*C.GAsyncQueue)(p)}}
}

// UnsafeAsyncQueueFromGlibNone is used to convert raw C.GAsyncQueue pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibNone(p unsafe.Pointer) *AsyncQueue {
	C.g_async_queue_ref((*C.GAsyncQueue)(p))
	wrapped := UnsafeAsyncQueueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.asyncQueue,
		func (intern *asyncQueue) {
			C.g_async_queue_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeAsyncQueueFromGlibFull is used to convert raw C.GAsyncQueue pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeAsyncQueueFromGlibFull(p unsafe.Pointer) *AsyncQueue {
	wrapped := UnsafeAsyncQueueFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.asyncQueue,
		func (intern *asyncQueue) {
			C.g_async_queue_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeAsyncQueueRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [AsyncQueue.UnsafeAsyncQueueUnref], then [AsyncQueue] will leak memory.
func UnsafeAsyncQueueRef(a *AsyncQueue) {
	C.g_async_queue_ref((*C.GAsyncQueue)(a.native))
}

// UnsafeAsyncQueueUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [AsyncQueue] is expected to work anymore.
func UnsafeAsyncQueueUnref(a *AsyncQueue) {
	C.g_async_queue_unref(a.native)
}

// UnsafeAsyncQueueToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeAsyncQueueToGlibNone(a *AsyncQueue) unsafe.Pointer {
	if a == nil {
		return nil
	}
	return unsafe.Pointer(a.native)
}

// UnsafeAsyncQueueToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeAsyncQueueToGlibFull(a *AsyncQueue) unsafe.Pointer {
	if a == nil {
		return nil
	}
	runtime.SetFinalizer(a.asyncQueue, nil)
	_p := unsafe.Pointer(a.native)
	a.native = nil // AsyncQueue is invalid from here on
	return _p
}

// NewAsyncQueue wraps g_async_queue_new
// 
// see also https://docs.gtk.org/glib/func.g_async_queue_new.html
//
func NewAsyncQueue() *AsyncQueue {
	var cret *C.GAsyncQueue // return, full, converted

	cret = C.g_async_queue_new()

	var goret *AsyncQueue

	goret = UnsafeAsyncQueueFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Length wraps g_async_queue_length
// 
// see also https://docs.gtk.org/glib/method.g_async_queue_length.g_async_queue_length.html
//
func (queue *AsyncQueue) Length() int32 {
	var carg0 *C.GAsyncQueue // in, none, converted
	var cret  C.gint         // return, none, casted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	cret = C.g_async_queue_length(carg0)
	runtime.KeepAlive(queue)

	var goret int32

	goret = int32(cret)

	return goret
}

// LengthUnlocked wraps g_async_queue_length_unlocked
// 
// see also https://docs.gtk.org/glib/method.g_async_queue_length_unlocked.g_async_queue_length_unlocked.html
//
func (queue *AsyncQueue) LengthUnlocked() int32 {
	var carg0 *C.GAsyncQueue // in, none, converted
	var cret  C.gint         // return, none, casted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	cret = C.g_async_queue_length_unlocked(carg0)
	runtime.KeepAlive(queue)

	var goret int32

	goret = int32(cret)

	return goret
}

// Lock wraps g_async_queue_lock
// 
// see also https://docs.gtk.org/glib/method.g_async_queue_lock.g_async_queue_lock.html
//
func (queue *AsyncQueue) Lock() {
	var carg0 *C.GAsyncQueue // in, none, converted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	C.g_async_queue_lock(carg0)
	runtime.KeepAlive(queue)
}

// Unlock wraps g_async_queue_unlock
// 
// see also https://docs.gtk.org/glib/method.g_async_queue_unlock.g_async_queue_unlock.html
//
func (queue *AsyncQueue) Unlock() {
	var carg0 *C.GAsyncQueue // in, none, converted

	carg0 = (*C.GAsyncQueue)(UnsafeAsyncQueueToGlibNone(queue))

	C.g_async_queue_unlock(carg0)
	runtime.KeepAlive(queue)
}

// BookmarkFile wraps GBookmarkFile
// 
// see also https://docs.gtk.org/glib/struct.BookmarkFile.html
//
type BookmarkFile struct {
	*bookmarkFile
}

// bookmarkFile is the struct that's finalized
type bookmarkFile struct {
	native *C.GBookmarkFile
}

// UnsafeBookmarkFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *BookmarkFile) instance() *C.GBookmarkFile {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBookmarkFileFromGlibBorrow is used to convert raw C.GBookmarkFile pointers to go. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibBorrow(p unsafe.Pointer) *BookmarkFile {
	if p == nil {
		return nil
	}
	return &BookmarkFile{&bookmarkFile{(*C.GBookmarkFile)(p)}}
}

// UnsafeBookmarkFileFromGlibNone is used to convert raw C.GBookmarkFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibNone(p unsafe.Pointer) *BookmarkFile {
	wrapped := UnsafeBookmarkFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeBookmarkFileFromGlibFull is used to convert raw C.GBookmarkFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeBookmarkFileFromGlibFull(p unsafe.Pointer) *BookmarkFile {
	wrapped := UnsafeBookmarkFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.bookmarkFile,
		func (intern *bookmarkFile) {
			C.g_bookmark_file_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeBookmarkFileFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [BookmarkFile] is expected to work anymore.
func UnsafeBookmarkFileFree(b *BookmarkFile) {
	C.g_bookmark_file_free(b.native)
}

// UnsafeBookmarkFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBookmarkFileToGlibNone(b *BookmarkFile) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeBookmarkFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeBookmarkFileToGlibFull(b *BookmarkFile) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.bookmarkFile, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // BookmarkFile is invalid from here on
	return _p
}

// NewBookmarkFile wraps g_bookmark_file_new
// 
// see also https://docs.gtk.org/glib/func.g_bookmark_file_new.html
//
func NewBookmarkFile() *BookmarkFile {
	var cret *C.GBookmarkFile // return, full, converted

	cret = C.g_bookmark_file_new()

	var goret *BookmarkFile

	goret = UnsafeBookmarkFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// BookmarkFileErrorQuark wraps g_bookmark_file_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_bookmark_file_error_quark.html
func BookmarkFileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_bookmark_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// AddApplication wraps g_bookmark_file_add_application
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_add_application.g_bookmark_file_add_application.html
//
func (bookmark *BookmarkFile) AddApplication(uri string, name string, exec string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var carg3 *C.gchar         // in, none, string, nullable-string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if name != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if exec != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(exec)))
		defer C.free(unsafe.Pointer(carg3))
	}

	C.g_bookmark_file_add_application(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)
	runtime.KeepAlive(exec)
}

// AddGroup wraps g_bookmark_file_add_group
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_add_group.g_bookmark_file_add_group.html
//
func (bookmark *BookmarkFile) AddGroup(uri string, group string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_add_group(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)
}

// Copy wraps g_bookmark_file_copy
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_copy.g_bookmark_file_copy.html
//
func (bookmark *BookmarkFile) Copy() *BookmarkFile {
	var carg0 *C.GBookmarkFile // in, none, converted
	var cret  *C.GBookmarkFile // return, full, converted

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_copy(carg0)
	runtime.KeepAlive(bookmark)

	var goret *BookmarkFile

	goret = UnsafeBookmarkFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetApplications wraps g_bookmark_file_get_applications
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_applications.g_bookmark_file_get_applications.html
//
func (bookmark *BookmarkFile) GetApplications(uri string) (uint, []string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_applications(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetDescription wraps g_bookmark_file_get_description
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_description.g_bookmark_file_get_description.html
//
func (bookmark *BookmarkFile) GetDescription(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_description(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetGroups wraps g_bookmark_file_get_groups
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_groups.g_bookmark_file_get_groups.html
//
func (bookmark *BookmarkFile) GetGroups(uri string) (uint, []string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_groups(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetIcon wraps g_bookmark_file_get_icon
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_icon.g_bookmark_file_get_icon.html
//
func (bookmark *BookmarkFile) GetIcon(uri string) (string, string, bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // out, full, string
	var carg3 *C.gchar         // out, full, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_icon(carg0, carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var href     string
	var mimeType string
	var goret    bool
	var _goerr   error

	href = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	mimeType = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return href, mimeType, goret, _goerr
}

// GetIsPrivate wraps g_bookmark_file_get_is_private
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_is_private.g_bookmark_file_get_is_private.html
//
func (bookmark *BookmarkFile) GetIsPrivate(uri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_is_private(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetMimeType wraps g_bookmark_file_get_mime_type
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_mime_type.g_bookmark_file_get_mime_type.html
//
func (bookmark *BookmarkFile) GetMimeType(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_get_mime_type(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetSize wraps g_bookmark_file_get_size
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_size.g_bookmark_file_get_size.html
//
func (bookmark *BookmarkFile) GetSize() int32 {
	var carg0 *C.GBookmarkFile // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_get_size(carg0)
	runtime.KeepAlive(bookmark)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetTitle wraps g_bookmark_file_get_title
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_title.g_bookmark_file_get_title.html
//
func (bookmark *BookmarkFile) GetTitle(uri string) (string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var cret  *C.gchar         // return, full, string
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_bookmark_file_get_title(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetUris wraps g_bookmark_file_get_uris
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_get_uris.g_bookmark_file_get_uris.html
//
func (bookmark *BookmarkFile) GetUris() (uint, []string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 C.gsize          // out, full, casted
	var cret  **C.gchar        // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive))

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_get_uris(carg0, &carg1)
	runtime.KeepAlive(bookmark)

	var length uint
	var goret  []string

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return length, goret
}

// HasApplication wraps g_bookmark_file_has_application
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_has_application.g_bookmark_file_has_application.html
//
func (bookmark *BookmarkFile) HasApplication(uri string, name string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_has_application(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasGroup wraps g_bookmark_file_has_group
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_has_group.g_bookmark_file_has_group.html
//
func (bookmark *BookmarkFile) HasGroup(uri string, group string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_has_group(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasItem wraps g_bookmark_file_has_item
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_has_item.g_bookmark_file_has_item.html
//
func (bookmark *BookmarkFile) HasItem(uri string) bool {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_has_item(carg0, carg1)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadFromData wraps g_bookmark_file_load_from_data
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_load_from_data.g_bookmark_file_load_from_data.html
//
func (bookmark *BookmarkFile) LoadFromData(data string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize          // implicit
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")

	cret = C.g_bookmark_file_load_from_data(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(data)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromDataDirs wraps g_bookmark_file_load_from_data_dirs
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_load_from_data_dirs.g_bookmark_file_load_from_data_dirs.html
//
func (bookmark *BookmarkFile) LoadFromDataDirs(file string) (string, bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // out, full, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_load_from_data_dirs(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(file)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromFile wraps g_bookmark_file_load_from_file
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_load_from_file.g_bookmark_file_load_from_file.html
//
func (bookmark *BookmarkFile) LoadFromFile(filename string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_load_from_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MoveItem wraps g_bookmark_file_move_item
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_move_item.g_bookmark_file_move_item.html
//
func (bookmark *BookmarkFile) MoveItem(oldUri string, newUri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(oldUri)))
	defer C.free(unsafe.Pointer(carg1))
	if newUri != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(newUri)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_bookmark_file_move_item(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(oldUri)
	runtime.KeepAlive(newUri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveApplication wraps g_bookmark_file_remove_application
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_remove_application.g_bookmark_file_remove_application.html
//
func (bookmark *BookmarkFile) RemoveApplication(uri string, name string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_remove_application(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(name)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveGroup wraps g_bookmark_file_remove_group
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_remove_group.g_bookmark_file_remove_group.html
//
func (bookmark *BookmarkFile) RemoveGroup(uri string, group string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(group)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_bookmark_file_remove_group(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(group)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveItem wraps g_bookmark_file_remove_item
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_remove_item.g_bookmark_file_remove_item.html
//
func (bookmark *BookmarkFile) RemoveItem(uri string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_remove_item(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDescription wraps g_bookmark_file_set_description
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_description.g_bookmark_file_set_description.html
//
func (bookmark *BookmarkFile) SetDescription(uri string, description string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_description(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(description)
}

// SetGroups wraps g_bookmark_file_set_groups
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_groups.g_bookmark_file_set_groups.html
//
func (bookmark *BookmarkFile) SetGroups(uri string, groups []string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 **C.gchar        // in, transfer: none, C Pointers: 2, Name: array[utf8], nullable, array (inner gchar* (*typesystem.StringPrimitive), length-by: carg3)
	var carg3 C.gsize          // implicit

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	_ = groups
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []string (const gchar**) because of unimplemented: inner pointers in array")

	C.g_bookmark_file_set_groups(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(groups)
}

// SetIcon wraps g_bookmark_file_set_icon
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_icon.g_bookmark_file_set_icon.html
//
func (bookmark *BookmarkFile) SetIcon(uri string, href string, mimeType string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string, nullable-string
	var carg3 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if href != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(href)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_bookmark_file_set_icon(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(href)
	runtime.KeepAlive(mimeType)
}

// SetIsPrivate wraps g_bookmark_file_set_is_private
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_is_private.g_bookmark_file_set_is_private.html
//
func (bookmark *BookmarkFile) SetIsPrivate(uri string, isPrivate bool) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 C.gboolean       // in

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	if isPrivate {
		carg2 = C.TRUE
	}

	C.g_bookmark_file_set_is_private(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(isPrivate)
}

// SetMimeType wraps g_bookmark_file_set_mime_type
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_mime_type.g_bookmark_file_set_mime_type.html
//
func (bookmark *BookmarkFile) SetMimeType(uri string, mimeType string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_mime_type(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(mimeType)
}

// SetTitle wraps g_bookmark_file_set_title
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_set_title.g_bookmark_file_set_title.html
//
func (bookmark *BookmarkFile) SetTitle(uri string, title string) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string, nullable-string
	var carg2 *C.gchar         // in, none, string

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	if uri != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_bookmark_file_set_title(carg0, carg1, carg2)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(title)
}

// ToData wraps g_bookmark_file_to_data
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_to_data.g_bookmark_file_to_data.html
//
func (bookmark *BookmarkFile) ToData() (uint, string, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 C.gsize          // out, full, casted
	var cret  *C.gchar         // return, transfer: full, C Pointers: 1, Name: array[unknown], scope: , array (inner unknown)
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))

	cret = C.g_bookmark_file_to_data(carg0, &carg1, &_cerr)
	runtime.KeepAlive(bookmark)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// ToFile wraps g_bookmark_file_to_file
// 
// see also https://docs.gtk.org/glib/method.g_bookmark_file_to_file.g_bookmark_file_to_file.html
//
func (bookmark *BookmarkFile) ToFile(filename string) (bool, error) {
	var carg0 *C.GBookmarkFile // in, none, converted
	var carg1 *C.gchar         // in, none, string
	var cret  C.gboolean       // return
	var _cerr *C.GError        // out, full, converted, nullable

	carg0 = (*C.GBookmarkFile)(UnsafeBookmarkFileToGlibNone(bookmark))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_bookmark_file_to_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(bookmark)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ByteArray wraps GByteArray
// 
// see also https://docs.gtk.org/glib/struct.ByteArray.html
//
type ByteArray struct {
	*byteArray
}

// byteArray is the struct that's finalized
type byteArray struct {
	native *C.GByteArray
}

// UnsafeByteArrayToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *ByteArray) instance() *C.GByteArray {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeByteArrayFromGlibBorrow is used to convert raw C.GByteArray pointers to go. This is used by the bindings internally.
func UnsafeByteArrayFromGlibBorrow(p unsafe.Pointer) *ByteArray {
	if p == nil {
		return nil
	}
	return &ByteArray{&byteArray{(*C.GByteArray)(p)}}
}

// UnsafeByteArrayFromGlibNone is used to convert raw C.GByteArray pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeByteArrayFromGlibNone(p unsafe.Pointer) *ByteArray {
	wrapped := UnsafeByteArrayFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ByteArray because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeByteArrayFromGlibFull is used to convert raw C.GByteArray pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeByteArrayFromGlibFull(p unsafe.Pointer) *ByteArray {
	wrapped := UnsafeByteArrayFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.byteArray,
		func (intern *byteArray) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeByteArrayFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ByteArray] is expected to work anymore.
func UnsafeByteArrayFree(b *ByteArray) {
	C.free(unsafe.Pointer(b.native))
}

// UnsafeByteArrayToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeByteArrayToGlibNone(b *ByteArray) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeByteArrayToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeByteArrayToGlibFull(b *ByteArray) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.byteArray, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // ByteArray is invalid from here on
	return _p
}

// Bytes wraps GBytes
// 
// see also https://docs.gtk.org/glib/struct.Bytes.html
//
type Bytes struct {
	*bytes
}

// bytes is the struct that's finalized
type bytes struct {
	native *C.GBytes
}

// UnsafeBytesToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (b *Bytes) instance() *C.GBytes {
	if b == nil {
		return nil
	}
	return b.native
}

// UnsafeBytesFromGlibBorrow is used to convert raw C.GBytes pointers to go. This is used by the bindings internally.
func UnsafeBytesFromGlibBorrow(p unsafe.Pointer) *Bytes {
	if p == nil {
		return nil
	}
	return &Bytes{&bytes{(*C.GBytes)(p)}}
}

// UnsafeBytesFromGlibNone is used to convert raw C.GBytes pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeBytesFromGlibNone(p unsafe.Pointer) *Bytes {
	C.g_bytes_ref((*C.GBytes)(p))
	wrapped := UnsafeBytesFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.bytes,
		func (intern *bytes) {
			C.g_bytes_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeBytesFromGlibFull is used to convert raw C.GBytes pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeBytesFromGlibFull(p unsafe.Pointer) *Bytes {
	wrapped := UnsafeBytesFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.bytes,
		func (intern *bytes) {
			C.g_bytes_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeBytesRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Bytes.UnsafeBytesUnref], then [Bytes] will leak memory.
func UnsafeBytesRef(b *Bytes) {
	C.g_bytes_ref((*C.GBytes)(b.native))
}

// UnsafeBytesUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Bytes] is expected to work anymore.
func UnsafeBytesUnref(b *Bytes) {
	C.g_bytes_unref(b.native)
}

// UnsafeBytesToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeBytesToGlibNone(b *Bytes) unsafe.Pointer {
	if b == nil {
		return nil
	}
	return unsafe.Pointer(b.native)
}

// UnsafeBytesToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeBytesToGlibFull(b *Bytes) unsafe.Pointer {
	if b == nil {
		return nil
	}
	runtime.SetFinalizer(b.bytes, nil)
	_p := unsafe.Pointer(b.native)
	b.native = nil // Bytes is invalid from here on
	return _p
}

// GetSize wraps g_bytes_get_size
// 
// see also https://docs.gtk.org/glib/method.g_bytes_get_size.g_bytes_get_size.html
//
func (bytes *Bytes) GetSize() uint {
	var carg0 *C.GBytes // in, none, converted
	var cret  C.gsize   // return, none, casted

	carg0 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))

	cret = C.g_bytes_get_size(carg0)
	runtime.KeepAlive(bytes)

	var goret uint

	goret = uint(cret)

	return goret
}

// NewFromBytes wraps g_bytes_new_from_bytes
// 
// see also https://docs.gtk.org/glib/method.g_bytes_new_from_bytes.g_bytes_new_from_bytes.html
//
func (bytes *Bytes) NewFromBytes(offset uint, length uint) *Bytes {
	var carg0 *C.GBytes // in, none, converted
	var carg1 C.gsize   // in, none, casted
	var carg2 C.gsize   // in, none, casted
	var cret  *C.GBytes // return, full, converted

	carg0 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))
	carg1 = C.gsize(offset)
	carg2 = C.gsize(length)

	cret = C.g_bytes_new_from_bytes(carg0, carg1, carg2)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(length)

	var goret *Bytes

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Checksum wraps GChecksum
// 
// see also https://docs.gtk.org/glib/struct.Checksum.html
//
type Checksum struct {
	*checksum
}

// checksum is the struct that's finalized
type checksum struct {
	native *C.GChecksum
}

// UnsafeChecksumToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *Checksum) instance() *C.GChecksum {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeChecksumFromGlibBorrow is used to convert raw C.GChecksum pointers to go. This is used by the bindings internally.
func UnsafeChecksumFromGlibBorrow(p unsafe.Pointer) *Checksum {
	if p == nil {
		return nil
	}
	return &Checksum{&checksum{(*C.GChecksum)(p)}}
}

// UnsafeChecksumFromGlibNone is used to convert raw C.GChecksum pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeChecksumFromGlibNone(p unsafe.Pointer) *Checksum {
	wrapped := UnsafeChecksumFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeChecksumFromGlibFull is used to convert raw C.GChecksum pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeChecksumFromGlibFull(p unsafe.Pointer) *Checksum {
	wrapped := UnsafeChecksumFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.checksum,
		func (intern *checksum) {
			C.g_checksum_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeChecksumFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Checksum] is expected to work anymore.
func UnsafeChecksumFree(c *Checksum) {
	C.g_checksum_free(c.native)
}

// UnsafeChecksumToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeChecksumToGlibNone(c *Checksum) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeChecksumToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeChecksumToGlibFull(c *Checksum) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.checksum, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // Checksum is invalid from here on
	return _p
}

// NewChecksum wraps g_checksum_new
// 
// see also https://docs.gtk.org/glib/func.g_checksum_new.html
//
func NewChecksum(checksumType ChecksumType) *Checksum {
	var carg1 C.GChecksumType // in, none, casted
	var cret  *C.GChecksum    // return, full, converted, nullable

	carg1 = C.GChecksumType(checksumType)

	cret = C.g_checksum_new(carg1)
	runtime.KeepAlive(checksumType)

	var goret *Checksum

	if cret != nil {
		goret = UnsafeChecksumFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// ChecksumTypeGetLength wraps g_checksum_type_get_length
// 
// see also https://docs.gtk.org/glib/func.g_checksum_type_get_length.html
//
func ChecksumTypeGetLength(checksumType ChecksumType) int {
	var carg1 C.GChecksumType // in, none, casted
	var cret  C.gssize        // return, none, casted

	carg1 = C.GChecksumType(checksumType)

	cret = C.g_checksum_type_get_length(carg1)
	runtime.KeepAlive(checksumType)

	var goret int

	goret = int(cret)

	return goret
}

// Copy wraps g_checksum_copy
// 
// see also https://docs.gtk.org/glib/method.g_checksum_copy.g_checksum_copy.html
//
func (checksum *Checksum) Copy() *Checksum {
	var carg0 *C.GChecksum // in, none, converted
	var cret  *C.GChecksum // return, full, converted

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	cret = C.g_checksum_copy(carg0)
	runtime.KeepAlive(checksum)

	var goret *Checksum

	goret = UnsafeChecksumFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_checksum_get_string
// 
// see also https://docs.gtk.org/glib/method.g_checksum_get_string.g_checksum_get_string.html
//
func (checksum *Checksum) GetString() string {
	var carg0 *C.GChecksum // in, none, converted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	cret = C.g_checksum_get_string(carg0)
	runtime.KeepAlive(checksum)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Reset wraps g_checksum_reset
// 
// see also https://docs.gtk.org/glib/method.g_checksum_reset.g_checksum_reset.html
//
func (checksum *Checksum) Reset() {
	var carg0 *C.GChecksum // in, none, converted

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))

	C.g_checksum_reset(carg0)
	runtime.KeepAlive(checksum)
}

// Update wraps g_checksum_update
// 
// see also https://docs.gtk.org/glib/method.g_checksum_update.g_checksum_update.html
//
func (checksum *Checksum) Update(data []uint8) {
	var carg0 *C.GChecksum // in, none, converted
	var carg1 *C.guchar    // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize     // implicit

	carg0 = (*C.GChecksum)(UnsafeChecksumToGlibNone(checksum))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guchar*) because of unimplemented: non-fixed size array")

	C.g_checksum_update(carg0, carg1, carg2)
	runtime.KeepAlive(checksum)
	runtime.KeepAlive(data)
}

// Cond wraps GCond
// 
// see also https://docs.gtk.org/glib/struct.Cond.html
//
type Cond struct {
	*cond
}

// cond is the struct that's finalized
type cond struct {
	native *C.GCond
}

// UnsafeCondToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (c *Cond) instance() *C.GCond {
	if c == nil {
		return nil
	}
	return c.native
}

// UnsafeCondFromGlibBorrow is used to convert raw C.GCond pointers to go. This is used by the bindings internally.
func UnsafeCondFromGlibBorrow(p unsafe.Pointer) *Cond {
	if p == nil {
		return nil
	}
	return &Cond{&cond{(*C.GCond)(p)}}
}

// UnsafeCondFromGlibNone is used to convert raw C.GCond pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeCondFromGlibNone(p unsafe.Pointer) *Cond {
	wrapped := UnsafeCondFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Cond because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeCondFromGlibFull is used to convert raw C.GCond pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeCondFromGlibFull(p unsafe.Pointer) *Cond {
	wrapped := UnsafeCondFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.cond,
		func (intern *cond) {
			C.g_cond_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeCondFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Cond] is expected to work anymore.
func UnsafeCondFree(c *Cond) {
	C.g_cond_free(c.native)
}

// UnsafeCondToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeCondToGlibNone(c *Cond) unsafe.Pointer {
	if c == nil {
		return nil
	}
	return unsafe.Pointer(c.native)
}

// UnsafeCondToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeCondToGlibFull(c *Cond) unsafe.Pointer {
	if c == nil {
		return nil
	}
	runtime.SetFinalizer(c.cond, nil)
	_p := unsafe.Pointer(c.native)
	c.native = nil // Cond is invalid from here on
	return _p
}

// Broadcast wraps g_cond_broadcast
// 
// see also https://docs.gtk.org/glib/method.g_cond_broadcast.g_cond_broadcast.html
//
func (cond *Cond) Broadcast() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_broadcast(carg0)
	runtime.KeepAlive(cond)
}

// Clear wraps g_cond_clear
// 
// see also https://docs.gtk.org/glib/method.g_cond_clear.g_cond_clear.html
//
func (cond *Cond) Clear() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_clear(carg0)
	runtime.KeepAlive(cond)
}

// Init wraps g_cond_init
// 
// see also https://docs.gtk.org/glib/method.g_cond_init.g_cond_init.html
//
func (cond *Cond) Init() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_init(carg0)
	runtime.KeepAlive(cond)
}

// Signal wraps g_cond_signal
// 
// see also https://docs.gtk.org/glib/method.g_cond_signal.g_cond_signal.html
//
func (cond *Cond) Signal() {
	var carg0 *C.GCond // in, none, converted

	carg0 = (*C.GCond)(UnsafeCondToGlibNone(cond))

	C.g_cond_signal(carg0)
	runtime.KeepAlive(cond)
}

// Data wraps GData
// 
// see also https://docs.gtk.org/glib/struct.Data.html
//
type Data struct {
	*data
}

// data is the struct that's finalized
type data struct {
	native *C.GData
}

// UnsafeDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *Data) instance() *C.GData {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDataFromGlibBorrow is used to convert raw C.GData pointers to go. This is used by the bindings internally.
func UnsafeDataFromGlibBorrow(p unsafe.Pointer) *Data {
	if p == nil {
		return nil
	}
	return &Data{&data{(*C.GData)(p)}}
}

// UnsafeDataFromGlibNone is used to convert raw C.GData pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDataFromGlibNone(p unsafe.Pointer) *Data {
	wrapped := UnsafeDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Data because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDataFromGlibFull is used to convert raw C.GData pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDataFromGlibFull(p unsafe.Pointer) *Data {
	wrapped := UnsafeDataFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.data,
		func (intern *data) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDataFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Data] is expected to work anymore.
func UnsafeDataFree(d *Data) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDataToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDataToGlibNone(d *Data) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDataToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDataToGlibFull(d *Data) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.data, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // Data is invalid from here on
	return _p
}

// DebugKey wraps GDebugKey
// 
// see also https://docs.gtk.org/glib/struct.DebugKey.html
//
type DebugKey struct {
	*debugKey
}

// debugKey is the struct that's finalized
type debugKey struct {
	native *C.GDebugKey
}

// UnsafeDebugKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *DebugKey) instance() *C.GDebugKey {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDebugKeyFromGlibBorrow is used to convert raw C.GDebugKey pointers to go. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibBorrow(p unsafe.Pointer) *DebugKey {
	if p == nil {
		return nil
	}
	return &DebugKey{&debugKey{(*C.GDebugKey)(p)}}
}

// UnsafeDebugKeyFromGlibNone is used to convert raw C.GDebugKey pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibNone(p unsafe.Pointer) *DebugKey {
	wrapped := UnsafeDebugKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to DebugKey because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeDebugKeyFromGlibFull is used to convert raw C.GDebugKey pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDebugKeyFromGlibFull(p unsafe.Pointer) *DebugKey {
	wrapped := UnsafeDebugKeyFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.debugKey,
		func (intern *debugKey) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeDebugKeyFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [DebugKey] is expected to work anymore.
func UnsafeDebugKeyFree(d *DebugKey) {
	C.free(unsafe.Pointer(d.native))
}

// UnsafeDebugKeyToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDebugKeyToGlibNone(d *DebugKey) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDebugKeyToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDebugKeyToGlibFull(d *DebugKey) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.debugKey, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // DebugKey is invalid from here on
	return _p
}

// Dir wraps GDir
// 
// see also https://docs.gtk.org/glib/struct.Dir.html
//
type Dir struct {
	*dir
}

// dir is the struct that's finalized
type dir struct {
	native *C.GDir
}

// UnsafeDirToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (d *Dir) instance() *C.GDir {
	if d == nil {
		return nil
	}
	return d.native
}

// UnsafeDirFromGlibBorrow is used to convert raw C.GDir pointers to go. This is used by the bindings internally.
func UnsafeDirFromGlibBorrow(p unsafe.Pointer) *Dir {
	if p == nil {
		return nil
	}
	return &Dir{&dir{(*C.GDir)(p)}}
}

// UnsafeDirFromGlibNone is used to convert raw C.GDir pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeDirFromGlibNone(p unsafe.Pointer) *Dir {
	C.g_dir_ref((*C.GDir)(p))
	wrapped := UnsafeDirFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.dir,
		func (intern *dir) {
			C.g_dir_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeDirFromGlibFull is used to convert raw C.GDir pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeDirFromGlibFull(p unsafe.Pointer) *Dir {
	wrapped := UnsafeDirFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.dir,
		func (intern *dir) {
			C.g_dir_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeDirRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Dir.UnsafeDirUnref], then [Dir] will leak memory.
func UnsafeDirRef(d *Dir) {
	C.g_dir_ref((*C.GDir)(d.native))
}

// UnsafeDirUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Dir] is expected to work anymore.
func UnsafeDirUnref(d *Dir) {
	C.g_dir_unref(d.native)
}

// UnsafeDirToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeDirToGlibNone(d *Dir) unsafe.Pointer {
	if d == nil {
		return nil
	}
	return unsafe.Pointer(d.native)
}

// UnsafeDirToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeDirToGlibFull(d *Dir) unsafe.Pointer {
	if d == nil {
		return nil
	}
	runtime.SetFinalizer(d.dir, nil)
	_p := unsafe.Pointer(d.native)
	d.native = nil // Dir is invalid from here on
	return _p
}

// DirOpen wraps g_dir_open
// 
// see also https://docs.gtk.org/glib/func.g_dir_open.html
//
func DirOpen(path string, flags uint) (*Dir, error) {
	var carg1 *C.gchar  // in, none, string
	var carg2 C.guint   // in, none, casted
	var cret  *C.GDir   // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(flags)

	cret = C.g_dir_open(carg1, carg2, &_cerr)
	runtime.KeepAlive(path)
	runtime.KeepAlive(flags)

	var goret  *Dir
	var _goerr error

	goret = UnsafeDirFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// DirMakeTmp wraps g_dir_make_tmp
// 
// see also https://docs.gtk.org/glib/func.g_dir_make_tmp.html
//
func DirMakeTmp(tmpl string) (string, error) {
	var carg1 *C.gchar  // in, none, string, nullable-string
	var cret  *C.gchar  // return, full, string
	var _cerr *C.GError // out, full, converted, nullable

	if tmpl != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_dir_make_tmp(carg1, &_cerr)
	runtime.KeepAlive(tmpl)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Close wraps g_dir_close
// 
// see also https://docs.gtk.org/glib/method.g_dir_close.g_dir_close.html
//
func (dir *Dir) Close() {
	var carg0 *C.GDir // in, none, converted

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	C.g_dir_close(carg0)
	runtime.KeepAlive(dir)
}

// ReadName wraps g_dir_read_name
// 
// see also https://docs.gtk.org/glib/method.g_dir_read_name.g_dir_read_name.html
//
func (dir *Dir) ReadName() string {
	var carg0 *C.GDir  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	cret = C.g_dir_read_name(carg0)
	runtime.KeepAlive(dir)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Rewind wraps g_dir_rewind
// 
// see also https://docs.gtk.org/glib/method.g_dir_rewind.g_dir_rewind.html
//
func (dir *Dir) Rewind() {
	var carg0 *C.GDir // in, none, converted

	carg0 = (*C.GDir)(UnsafeDirToGlibNone(dir))

	C.g_dir_rewind(carg0)
	runtime.KeepAlive(dir)
}

// HashTableIter wraps GHashTableIter
// 
// see also https://docs.gtk.org/glib/struct.HashTableIter.html
//
type HashTableIter struct {
	*hashTableIter
}

// hashTableIter is the struct that's finalized
type hashTableIter struct {
	native *C.GHashTableIter
}

// UnsafeHashTableIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *HashTableIter) instance() *C.GHashTableIter {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHashTableIterFromGlibBorrow is used to convert raw C.GHashTableIter pointers to go. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibBorrow(p unsafe.Pointer) *HashTableIter {
	if p == nil {
		return nil
	}
	return &HashTableIter{&hashTableIter{(*C.GHashTableIter)(p)}}
}

// UnsafeHashTableIterFromGlibNone is used to convert raw C.GHashTableIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibNone(p unsafe.Pointer) *HashTableIter {
	wrapped := UnsafeHashTableIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to HashTableIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHashTableIterFromGlibFull is used to convert raw C.GHashTableIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHashTableIterFromGlibFull(p unsafe.Pointer) *HashTableIter {
	wrapped := UnsafeHashTableIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hashTableIter,
		func (intern *hashTableIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHashTableIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [HashTableIter] is expected to work anymore.
func UnsafeHashTableIterFree(h *HashTableIter) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHashTableIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHashTableIterToGlibNone(h *HashTableIter) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHashTableIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHashTableIterToGlibFull(h *HashTableIter) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hashTableIter, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // HashTableIter is invalid from here on
	return _p
}

// Remove wraps g_hash_table_iter_remove
// 
// see also https://docs.gtk.org/glib/method.g_hash_table_iter_remove.g_hash_table_iter_remove.html
//
func (iter *HashTableIter) Remove() {
	var carg0 *C.GHashTableIter // in, none, converted

	carg0 = (*C.GHashTableIter)(UnsafeHashTableIterToGlibNone(iter))

	C.g_hash_table_iter_remove(carg0)
	runtime.KeepAlive(iter)
}

// Steal wraps g_hash_table_iter_steal
// 
// see also https://docs.gtk.org/glib/method.g_hash_table_iter_steal.g_hash_table_iter_steal.html
//
func (iter *HashTableIter) Steal() {
	var carg0 *C.GHashTableIter // in, none, converted

	carg0 = (*C.GHashTableIter)(UnsafeHashTableIterToGlibNone(iter))

	C.g_hash_table_iter_steal(carg0)
	runtime.KeepAlive(iter)
}

// Hmac wraps GHmac
// 
// see also https://docs.gtk.org/glib/struct.Hmac.html
//
type Hmac struct {
	*hmac
}

// hmac is the struct that's finalized
type hmac struct {
	native *C.GHmac
}

// UnsafeHmacToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *Hmac) instance() *C.GHmac {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHmacFromGlibBorrow is used to convert raw C.GHmac pointers to go. This is used by the bindings internally.
func UnsafeHmacFromGlibBorrow(p unsafe.Pointer) *Hmac {
	if p == nil {
		return nil
	}
	return &Hmac{&hmac{(*C.GHmac)(p)}}
}

// UnsafeHmacFromGlibNone is used to convert raw C.GHmac pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHmacFromGlibNone(p unsafe.Pointer) *Hmac {
	C.g_hmac_ref((*C.GHmac)(p))
	wrapped := UnsafeHmacFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.hmac,
		func (intern *hmac) {
			C.g_hmac_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeHmacFromGlibFull is used to convert raw C.GHmac pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHmacFromGlibFull(p unsafe.Pointer) *Hmac {
	wrapped := UnsafeHmacFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hmac,
		func (intern *hmac) {
			C.g_hmac_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeHmacRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Hmac.UnsafeHmacUnref], then [Hmac] will leak memory.
func UnsafeHmacRef(h *Hmac) {
	C.g_hmac_ref((*C.GHmac)(h.native))
}

// UnsafeHmacUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Hmac] is expected to work anymore.
func UnsafeHmacUnref(h *Hmac) {
	C.g_hmac_unref(h.native)
}

// UnsafeHmacToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHmacToGlibNone(h *Hmac) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHmacToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHmacToGlibFull(h *Hmac) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hmac, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // Hmac is invalid from here on
	return _p
}

// NewHmac wraps g_hmac_new
// 
// see also https://docs.gtk.org/glib/func.g_hmac_new.html
//
func NewHmac(digestType ChecksumType, key []byte) *Hmac {
	var carg1 C.GChecksumType // in, none, casted
	var carg2 *C.guchar       // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg3)
	var carg3 C.gsize         // implicit
	var cret  *C.GHmac        // return, full, converted, nullable

	carg1 = C.GChecksumType(digestType)
	_ = key
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	cret = C.g_hmac_new(carg1, carg2, carg3)
	runtime.KeepAlive(digestType)
	runtime.KeepAlive(key)

	var goret *Hmac

	if cret != nil {
		goret = UnsafeHmacFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// Copy wraps g_hmac_copy
// 
// see also https://docs.gtk.org/glib/method.g_hmac_copy.g_hmac_copy.html
//
func (hmac *Hmac) Copy() *Hmac {
	var carg0 *C.GHmac // in, none, converted
	var cret  *C.GHmac // return, full, converted

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))

	cret = C.g_hmac_copy(carg0)
	runtime.KeepAlive(hmac)

	var goret *Hmac

	goret = UnsafeHmacFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_hmac_get_string
// 
// see also https://docs.gtk.org/glib/method.g_hmac_get_string.g_hmac_get_string.html
//
func (hmac *Hmac) GetString() string {
	var carg0 *C.GHmac // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))

	cret = C.g_hmac_get_string(carg0)
	runtime.KeepAlive(hmac)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// Update wraps g_hmac_update
// 
// see also https://docs.gtk.org/glib/method.g_hmac_update.g_hmac_update.html
//
func (hmac *Hmac) Update(data []byte) {
	var carg0 *C.GHmac  // in, none, converted
	var carg1 *C.guchar // in, transfer: none, C Pointers: 1, Name: array[guchar], array (inner guchar (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gssize  // implicit

	carg0 = (*C.GHmac)(UnsafeHmacToGlibNone(hmac))
	_ = data
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []byte (const guchar*) because of unimplemented: non-fixed size array")

	C.g_hmac_update(carg0, carg1, carg2)
	runtime.KeepAlive(hmac)
	runtime.KeepAlive(data)
}

// Hook wraps GHook
// 
// see also https://docs.gtk.org/glib/struct.Hook.html
//
type Hook struct {
	*hook
}

// hook is the struct that's finalized
type hook struct {
	native *C.GHook
}

// UnsafeHookToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *Hook) instance() *C.GHook {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHookFromGlibBorrow is used to convert raw C.GHook pointers to go. This is used by the bindings internally.
func UnsafeHookFromGlibBorrow(p unsafe.Pointer) *Hook {
	if p == nil {
		return nil
	}
	return &Hook{&hook{(*C.GHook)(p)}}
}

// UnsafeHookFromGlibNone is used to convert raw C.GHook pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHookFromGlibNone(p unsafe.Pointer) *Hook {
	wrapped := UnsafeHookFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Hook because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHookFromGlibFull is used to convert raw C.GHook pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHookFromGlibFull(p unsafe.Pointer) *Hook {
	wrapped := UnsafeHookFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hook,
		func (intern *hook) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHookFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Hook] is expected to work anymore.
func UnsafeHookFree(h *Hook) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHookToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHookToGlibNone(h *Hook) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHookToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHookToGlibFull(h *Hook) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hook, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // Hook is invalid from here on
	return _p
}

// HookDestroy wraps g_hook_destroy
// 
// see also https://docs.gtk.org/glib/func.g_hook_destroy.html
//
func HookDestroy(hookList *HookList, hookId uint32) bool {
	var carg1 *C.GHookList // in, none, converted
	var carg2 C.gulong     // in, none, casted
	var cret  C.gboolean   // return

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = C.gulong(hookId)

	cret = C.g_hook_destroy(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hookId)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// HookDestroyLink wraps g_hook_destroy_link
// 
// see also https://docs.gtk.org/glib/func.g_hook_destroy_link.html
//
func HookDestroyLink(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_destroy_link(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookFree wraps g_hook_free
// 
// see also https://docs.gtk.org/glib/func.g_hook_free.html
//
func HookFree(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_free(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookInsertBefore wraps g_hook_insert_before
// 
// see also https://docs.gtk.org/glib/func.g_hook_insert_before.html
//
func HookInsertBefore(hookList *HookList, sibling *Hook, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted, nullable
	var carg3 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if sibling != nil {
		carg2 = (*C.GHook)(UnsafeHookToGlibNone(sibling))
	}
	carg3 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_insert_before(carg1, carg2, carg3)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(hook)
}

// HookPrepend wraps g_hook_prepend
// 
// see also https://docs.gtk.org/glib/func.g_hook_prepend.html
//
func HookPrepend(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_prepend(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// HookUnref wraps g_hook_unref
// 
// see also https://docs.gtk.org/glib/func.g_hook_unref.html
//
func HookUnref(hookList *HookList, hook *Hook) {
	var carg1 *C.GHookList // in, none, converted
	var carg2 *C.GHook     // in, none, converted

	carg1 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg2 = (*C.GHook)(UnsafeHookToGlibNone(hook))

	C.g_hook_unref(carg1, carg2)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hook)
}

// CompareIDs wraps g_hook_compare_ids
// 
// see also https://docs.gtk.org/glib/method.g_hook_compare_ids.g_hook_compare_ids.html
//
func (newHook *Hook) CompareIDs(sibling *Hook) int32 {
	var carg0 *C.GHook // in, none, converted
	var carg1 *C.GHook // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GHook)(UnsafeHookToGlibNone(newHook))
	carg1 = (*C.GHook)(UnsafeHookToGlibNone(sibling))

	cret = C.g_hook_compare_ids(carg0, carg1)
	runtime.KeepAlive(newHook)
	runtime.KeepAlive(sibling)

	var goret int32

	goret = int32(cret)

	return goret
}

// HookList wraps GHookList
// 
// see also https://docs.gtk.org/glib/struct.HookList.html
//
type HookList struct {
	*hookList
}

// hookList is the struct that's finalized
type hookList struct {
	native *C.GHookList
}

// UnsafeHookListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (h *HookList) instance() *C.GHookList {
	if h == nil {
		return nil
	}
	return h.native
}

// UnsafeHookListFromGlibBorrow is used to convert raw C.GHookList pointers to go. This is used by the bindings internally.
func UnsafeHookListFromGlibBorrow(p unsafe.Pointer) *HookList {
	if p == nil {
		return nil
	}
	return &HookList{&hookList{(*C.GHookList)(p)}}
}

// UnsafeHookListFromGlibNone is used to convert raw C.GHookList pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeHookListFromGlibNone(p unsafe.Pointer) *HookList {
	wrapped := UnsafeHookListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to HookList because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeHookListFromGlibFull is used to convert raw C.GHookList pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeHookListFromGlibFull(p unsafe.Pointer) *HookList {
	wrapped := UnsafeHookListFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.hookList,
		func (intern *hookList) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeHookListFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [HookList] is expected to work anymore.
func UnsafeHookListFree(h *HookList) {
	C.free(unsafe.Pointer(h.native))
}

// UnsafeHookListToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeHookListToGlibNone(h *HookList) unsafe.Pointer {
	if h == nil {
		return nil
	}
	return unsafe.Pointer(h.native)
}

// UnsafeHookListToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeHookListToGlibFull(h *HookList) unsafe.Pointer {
	if h == nil {
		return nil
	}
	runtime.SetFinalizer(h.hookList, nil)
	_p := unsafe.Pointer(h.native)
	h.native = nil // HookList is invalid from here on
	return _p
}

// Clear wraps g_hook_list_clear
// 
// see also https://docs.gtk.org/glib/method.g_hook_list_clear.g_hook_list_clear.html
//
func (hookList *HookList) Clear() {
	var carg0 *C.GHookList // in, none, converted

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))

	C.g_hook_list_clear(carg0)
	runtime.KeepAlive(hookList)
}

// Init wraps g_hook_list_init
// 
// see also https://docs.gtk.org/glib/method.g_hook_list_init.g_hook_list_init.html
//
func (hookList *HookList) Init(hookSize uint) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.guint      // in, none, casted

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	carg1 = C.guint(hookSize)

	C.g_hook_list_init(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(hookSize)
}

// Invoke wraps g_hook_list_invoke
// 
// see also https://docs.gtk.org/glib/method.g_hook_list_invoke.g_hook_list_invoke.html
//
func (hookList *HookList) Invoke(mayRecurse bool) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if mayRecurse {
		carg1 = C.TRUE
	}

	C.g_hook_list_invoke(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(mayRecurse)
}

// InvokeCheck wraps g_hook_list_invoke_check
// 
// see also https://docs.gtk.org/glib/method.g_hook_list_invoke_check.g_hook_list_invoke_check.html
//
func (hookList *HookList) InvokeCheck(mayRecurse bool) {
	var carg0 *C.GHookList // in, none, converted
	var carg1 C.gboolean   // in

	carg0 = (*C.GHookList)(UnsafeHookListToGlibNone(hookList))
	if mayRecurse {
		carg1 = C.TRUE
	}

	C.g_hook_list_invoke_check(carg0, carg1)
	runtime.KeepAlive(hookList)
	runtime.KeepAlive(mayRecurse)
}

// IOChannel wraps GIOChannel
// 
// see also https://docs.gtk.org/glib/struct.IOChannel.html
//
type IOChannel struct {
	*iOChannel
}

// iOChannel is the struct that's finalized
type iOChannel struct {
	native *C.GIOChannel
}

// UnsafeIOChannelToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOChannel) instance() *C.GIOChannel {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOChannelFromGlibBorrow is used to convert raw C.GIOChannel pointers to go. This is used by the bindings internally.
func UnsafeIOChannelFromGlibBorrow(p unsafe.Pointer) *IOChannel {
	if p == nil {
		return nil
	}
	return &IOChannel{&iOChannel{(*C.GIOChannel)(p)}}
}

// UnsafeIOChannelFromGlibNone is used to convert raw C.GIOChannel pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOChannelFromGlibNone(p unsafe.Pointer) *IOChannel {
	C.g_io_channel_ref((*C.GIOChannel)(p))
	wrapped := UnsafeIOChannelFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.iOChannel,
		func (intern *iOChannel) {
			C.g_io_channel_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOChannelFromGlibFull is used to convert raw C.GIOChannel pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOChannelFromGlibFull(p unsafe.Pointer) *IOChannel {
	wrapped := UnsafeIOChannelFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOChannel,
		func (intern *iOChannel) {
			C.g_io_channel_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeIOChannelRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [IOChannel.UnsafeIOChannelUnref], then [IOChannel] will leak memory.
func UnsafeIOChannelRef(i *IOChannel) {
	C.g_io_channel_ref((*C.GIOChannel)(i.native))
}

// UnsafeIOChannelUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOChannel] is expected to work anymore.
func UnsafeIOChannelUnref(i *IOChannel) {
	C.g_io_channel_unref(i.native)
}

// UnsafeIOChannelToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOChannelToGlibNone(i *IOChannel) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOChannelToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOChannelToGlibFull(i *IOChannel) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOChannel, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOChannel is invalid from here on
	return _p
}

// NewIOChannelFile wraps g_io_channel_new_file
// 
// see also https://docs.gtk.org/glib/func.g_io_channel_new_file.html
//
func NewIOChannelFile(filename string, mode string) (*IOChannel, error) {
	var carg1 *C.gchar      // in, none, string
	var carg2 *C.gchar      // in, none, string
	var cret  *C.GIOChannel // return, full, converted
	var _cerr *C.GError     // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(mode)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_io_channel_new_file(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(mode)

	var goret  *IOChannel
	var _goerr error

	goret = UnsafeIOChannelFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IOChannelErrorFromErrno wraps g_io_channel_error_from_errno
// 
// see also https://docs.gtk.org/glib/func.g_io_channel_error_from_errno.html
//
func IOChannelErrorFromErrno(en int32) IOChannelError {
	var carg1 C.gint            // in, none, casted
	var cret  C.GIOChannelError // return, none, casted

	carg1 = C.gint(en)

	cret = C.g_io_channel_error_from_errno(carg1)
	runtime.KeepAlive(en)

	var goret IOChannelError

	goret = IOChannelError(cret)

	return goret
}

// IOChannelErrorQuark wraps g_io_channel_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_io_channel_error_quark.html
func IOChannelErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_io_channel_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// Flush wraps g_io_channel_flush
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_flush.g_io_channel_flush.html
//
func (channel *IOChannel) Flush() (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_flush(carg0, &_cerr)
	runtime.KeepAlive(channel)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBufferCondition wraps g_io_channel_get_buffer_condition
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_buffer_condition.g_io_channel_get_buffer_condition.html
//
func (channel *IOChannel) GetBufferCondition() IOCondition {
	var carg0 *C.GIOChannel  // in, none, converted
	var cret  C.GIOCondition // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffer_condition(carg0)
	runtime.KeepAlive(channel)

	var goret IOCondition

	goret = IOCondition(cret)

	return goret
}

// GetBufferSize wraps g_io_channel_get_buffer_size
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_buffer_size.g_io_channel_get_buffer_size.html
//
func (channel *IOChannel) GetBufferSize() uint {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gsize       // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffer_size(carg0)
	runtime.KeepAlive(channel)

	var goret uint

	goret = uint(cret)

	return goret
}

// GetBuffered wraps g_io_channel_get_buffered
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_buffered.g_io_channel_get_buffered.html
//
func (channel *IOChannel) GetBuffered() bool {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_buffered(carg0)
	runtime.KeepAlive(channel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetCloseOnUnref wraps g_io_channel_get_close_on_unref
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_close_on_unref.g_io_channel_get_close_on_unref.html
//
func (channel *IOChannel) GetCloseOnUnref() bool {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_close_on_unref(carg0)
	runtime.KeepAlive(channel)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetEncoding wraps g_io_channel_get_encoding
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_encoding.g_io_channel_get_encoding.html
//
func (channel *IOChannel) GetEncoding() string {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_encoding(carg0)
	runtime.KeepAlive(channel)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetFlags wraps g_io_channel_get_flags
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_flags.g_io_channel_get_flags.html
//
func (channel *IOChannel) GetFlags() IOFlags {
	var carg0 *C.GIOChannel // in, none, converted
	var cret  C.GIOFlags    // return, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_flags(carg0)
	runtime.KeepAlive(channel)

	var goret IOFlags

	goret = IOFlags(cret)

	return goret
}

// GetLineTerm wraps g_io_channel_get_line_term
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_get_line_term.g_io_channel_get_line_term.html
//
func (channel *IOChannel) GetLineTerm() (int32, string) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gint        // out, full, casted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_get_line_term(carg0, &carg1)
	runtime.KeepAlive(channel)

	var length int32
	var goret  string

	length = int32(carg1)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return length, goret
}

// Init wraps g_io_channel_init
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_init.g_io_channel_init.html
//
func (channel *IOChannel) Init() {
	var carg0 *C.GIOChannel // in, none, converted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	C.g_io_channel_init(carg0)
	runtime.KeepAlive(channel)
}

// ReadLine wraps g_io_channel_read_line
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_read_line.g_io_channel_read_line.html
//
func (channel *IOChannel) ReadLine() (string, uint, uint, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // out, full, string
	var carg2 C.gsize       // out, full, casted
	var carg3 C.gsize       // out, full, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_line(carg0, &carg1, &carg2, &carg3, &_cerr)
	runtime.KeepAlive(channel)

	var strReturn     string
	var length        uint
	var terminatorPos uint
	var goret         IOStatus
	var _goerr        error

	strReturn = C.GoString((*C.char)(unsafe.Pointer(carg1)))
	defer C.free(unsafe.Pointer(carg1))
	length = uint(carg2)
	terminatorPos = uint(carg3)
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return strReturn, length, terminatorPos, goret, _goerr
}

// ReadToEnd wraps g_io_channel_read_to_end
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_read_to_end.g_io_channel_read_to_end.html
//
func (channel *IOChannel) ReadToEnd() (string, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // out, transfer: full, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gsize       // implicit
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_to_end(carg0, &carg1, &carg2, &_cerr)
	runtime.KeepAlive(channel)

	var strReturn string
	var goret     IOStatus
	var _goerr    error

	_ = strReturn
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (gchar*) because of unknown reason")
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return strReturn, goret, _goerr
}

// ReadUnichar wraps g_io_channel_read_unichar
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_read_unichar.g_io_channel_read_unichar.html
//
func (channel *IOChannel) ReadUnichar() (uint32, IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gunichar    // out, full, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))

	cret = C.g_io_channel_read_unichar(carg0, &carg1, &_cerr)
	runtime.KeepAlive(channel)

	var thechar uint32
	var goret   IOStatus
	var _goerr  error

	thechar = uint32(carg1)
	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return thechar, goret, _goerr
}

// SeekPosition wraps g_io_channel_seek_position
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_seek_position.g_io_channel_seek_position.html
//
func (channel *IOChannel) SeekPosition(offset int64, typ SeekType) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gint64      // in, none, casted
	var carg2 C.GSeekType   // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gint64(offset)
	carg2 = C.GSeekType(typ)

	cret = C.g_io_channel_seek_position(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(typ)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBufferSize wraps g_io_channel_set_buffer_size
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_buffer_size.g_io_channel_set_buffer_size.html
//
func (channel *IOChannel) SetBufferSize(size uint) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gsize       // in, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gsize(size)

	C.g_io_channel_set_buffer_size(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(size)
}

// SetBuffered wraps g_io_channel_set_buffered
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_buffered.g_io_channel_set_buffered.html
//
func (channel *IOChannel) SetBuffered(buffered bool) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if buffered {
		carg1 = C.TRUE
	}

	C.g_io_channel_set_buffered(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(buffered)
}

// SetCloseOnUnref wraps g_io_channel_set_close_on_unref
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_close_on_unref.g_io_channel_set_close_on_unref.html
//
func (channel *IOChannel) SetCloseOnUnref(doClose bool) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if doClose {
		carg1 = C.TRUE
	}

	C.g_io_channel_set_close_on_unref(carg0, carg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(doClose)
}

// SetEncoding wraps g_io_channel_set_encoding
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_encoding.g_io_channel_set_encoding.html
//
func (channel *IOChannel) SetEncoding(encoding string) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if encoding != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(encoding)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_io_channel_set_encoding(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(encoding)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetFlags wraps g_io_channel_set_flags
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_flags.g_io_channel_set_flags.html
//
func (channel *IOChannel) SetFlags(flags IOFlags) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.GIOFlags    // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.GIOFlags(flags)

	cret = C.g_io_channel_set_flags(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flags)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetLineTerm wraps g_io_channel_set_line_term
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_set_line_term.g_io_channel_set_line_term.html
//
func (channel *IOChannel) SetLineTerm(lineTerm string, length int32) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 *C.gchar      // in, none, string, nullable-string
	var carg2 C.gint        // in, none, casted

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if lineTerm != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(lineTerm)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = C.gint(length)

	C.g_io_channel_set_line_term(carg0, carg1, carg2)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(lineTerm)
	runtime.KeepAlive(length)
}

// Shutdown wraps g_io_channel_shutdown
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_shutdown.g_io_channel_shutdown.html
//
func (channel *IOChannel) Shutdown(flush bool) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gboolean    // in
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	if flush {
		carg1 = C.TRUE
	}

	cret = C.g_io_channel_shutdown(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(flush)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// WriteUnichar wraps g_io_channel_write_unichar
// 
// see also https://docs.gtk.org/glib/method.g_io_channel_write_unichar.g_io_channel_write_unichar.html
//
func (channel *IOChannel) WriteUnichar(thechar uint32) (IOStatus, error) {
	var carg0 *C.GIOChannel // in, none, converted
	var carg1 C.gunichar    // in, none, casted
	var cret  C.GIOStatus   // return, none, casted
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GIOChannel)(UnsafeIOChannelToGlibNone(channel))
	carg1 = C.gunichar(thechar)

	cret = C.g_io_channel_write_unichar(carg0, carg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(thechar)

	var goret  IOStatus
	var _goerr error

	goret = IOStatus(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// IOFuncs wraps GIOFuncs
// 
// see also https://docs.gtk.org/glib/struct.IOFuncs.html
//
type IOFuncs struct {
	*iOFuncs
}

// iOFuncs is the struct that's finalized
type iOFuncs struct {
	native *C.GIOFuncs
}

// UnsafeIOFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (i *IOFuncs) instance() *C.GIOFuncs {
	if i == nil {
		return nil
	}
	return i.native
}

// UnsafeIOFuncsFromGlibBorrow is used to convert raw C.GIOFuncs pointers to go. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibBorrow(p unsafe.Pointer) *IOFuncs {
	if p == nil {
		return nil
	}
	return &IOFuncs{&iOFuncs{(*C.GIOFuncs)(p)}}
}

// UnsafeIOFuncsFromGlibNone is used to convert raw C.GIOFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibNone(p unsafe.Pointer) *IOFuncs {
	wrapped := UnsafeIOFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to IOFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeIOFuncsFromGlibFull is used to convert raw C.GIOFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeIOFuncsFromGlibFull(p unsafe.Pointer) *IOFuncs {
	wrapped := UnsafeIOFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.iOFuncs,
		func (intern *iOFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeIOFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [IOFuncs] is expected to work anymore.
func UnsafeIOFuncsFree(i *IOFuncs) {
	C.free(unsafe.Pointer(i.native))
}

// UnsafeIOFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeIOFuncsToGlibNone(i *IOFuncs) unsafe.Pointer {
	if i == nil {
		return nil
	}
	return unsafe.Pointer(i.native)
}

// UnsafeIOFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeIOFuncsToGlibFull(i *IOFuncs) unsafe.Pointer {
	if i == nil {
		return nil
	}
	runtime.SetFinalizer(i.iOFuncs, nil)
	_p := unsafe.Pointer(i.native)
	i.native = nil // IOFuncs is invalid from here on
	return _p
}

// KeyFile wraps GKeyFile
// 
// see also https://docs.gtk.org/glib/struct.KeyFile.html
//
type KeyFile struct {
	*keyFile
}

// keyFile is the struct that's finalized
type keyFile struct {
	native *C.GKeyFile
}

// UnsafeKeyFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (k *KeyFile) instance() *C.GKeyFile {
	if k == nil {
		return nil
	}
	return k.native
}

// UnsafeKeyFileFromGlibBorrow is used to convert raw C.GKeyFile pointers to go. This is used by the bindings internally.
func UnsafeKeyFileFromGlibBorrow(p unsafe.Pointer) *KeyFile {
	if p == nil {
		return nil
	}
	return &KeyFile{&keyFile{(*C.GKeyFile)(p)}}
}

// UnsafeKeyFileFromGlibNone is used to convert raw C.GKeyFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeKeyFileFromGlibNone(p unsafe.Pointer) *KeyFile {
	C.g_key_file_ref((*C.GKeyFile)(p))
	wrapped := UnsafeKeyFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.keyFile,
		func (intern *keyFile) {
			C.g_key_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeKeyFileFromGlibFull is used to convert raw C.GKeyFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeKeyFileFromGlibFull(p unsafe.Pointer) *KeyFile {
	wrapped := UnsafeKeyFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.keyFile,
		func (intern *keyFile) {
			C.g_key_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeKeyFileRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [KeyFile.UnsafeKeyFileUnref], then [KeyFile] will leak memory.
func UnsafeKeyFileRef(k *KeyFile) {
	C.g_key_file_ref((*C.GKeyFile)(k.native))
}

// UnsafeKeyFileUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [KeyFile] is expected to work anymore.
func UnsafeKeyFileUnref(k *KeyFile) {
	C.g_key_file_unref(k.native)
}

// UnsafeKeyFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeKeyFileToGlibNone(k *KeyFile) unsafe.Pointer {
	if k == nil {
		return nil
	}
	return unsafe.Pointer(k.native)
}

// UnsafeKeyFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeKeyFileToGlibFull(k *KeyFile) unsafe.Pointer {
	if k == nil {
		return nil
	}
	runtime.SetFinalizer(k.keyFile, nil)
	_p := unsafe.Pointer(k.native)
	k.native = nil // KeyFile is invalid from here on
	return _p
}

// NewKeyFile wraps g_key_file_new
// 
// see also https://docs.gtk.org/glib/func.g_key_file_new.html
//
func NewKeyFile() *KeyFile {
	var cret *C.GKeyFile // return, full, converted

	cret = C.g_key_file_new()

	var goret *KeyFile

	goret = UnsafeKeyFileFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// KeyFileErrorQuark wraps g_key_file_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_key_file_error_quark.html
func KeyFileErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_key_file_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// GetBoolean wraps g_key_file_get_boolean
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_boolean.g_key_file_get_boolean.html
//
func (keyFile *KeyFile) GetBoolean(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_boolean(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBooleanList wraps g_key_file_get_boolean_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_boolean_list.g_key_file_get_boolean_list.html
//
func (keyFile *KeyFile) GetBooleanList(groupName string, key string) (uint, []bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gboolean // return, transfer: container, C Pointers: 1, Name: array[gboolean], scope: , array (inner gboolean (*typesystem.BooleanPrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_boolean_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []bool
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []bool (gboolean*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetComment wraps g_key_file_get_comment
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_comment.g_key_file_get_comment.html
//
func (keyFile *KeyFile) GetComment(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_key_file_get_comment(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDouble wraps g_key_file_get_double
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_double.g_key_file_get_double.html
//
func (keyFile *KeyFile) GetDouble(groupName string, key string) (float64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gdouble   // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_double(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  float64
	var _goerr error

	goret = float64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetDoubleList wraps g_key_file_get_double_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_double_list.g_key_file_get_double_list.html
//
func (keyFile *KeyFile) GetDoubleList(groupName string, key string) (uint, []float64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gdouble  // return, transfer: container, C Pointers: 1, Name: array[gdouble], scope: , array (inner gdouble (*typesystem.CastablePrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_double_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []float64
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []float64 (gdouble*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetGroups wraps g_key_file_get_groups
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_groups.g_key_file_get_groups.html
//
func (keyFile *KeyFile) GetGroups() (uint, []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_get_groups(carg0, &carg1)
	runtime.KeepAlive(keyFile)

	var length uint
	var goret  []string

	length = uint(carg1)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return length, goret
}

// GetInt64 wraps g_key_file_get_int64
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_int64.g_key_file_get_int64.html
//
func (keyFile *KeyFile) GetInt64(groupName string, key string) (int64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gint64    // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_int64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  int64
	var _goerr error

	goret = int64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetInteger wraps g_key_file_get_integer
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_integer.g_key_file_get_integer.html
//
func (keyFile *KeyFile) GetInteger(groupName string, key string) (int32, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gint      // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_integer(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  int32
	var _goerr error

	goret = int32(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetIntegerList wraps g_key_file_get_integer_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_integer_list.g_key_file_get_integer_list.html
//
func (keyFile *KeyFile) GetIntegerList(groupName string, key string) (uint, []int32, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  *C.gint     // return, transfer: container, C Pointers: 1, Name: array[gint], scope: , array (inner gint (*typesystem.CastablePrimitive))
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_integer_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []int32
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []int32 (gint*) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetKeys wraps g_key_file_get_keys
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_keys.g_key_file_get_keys.html
//
func (keyFile *KeyFile) GetKeys(groupName string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_get_keys(carg0, carg1, &carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg2)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetLocaleForKey wraps g_key_file_get_locale_for_key
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_locale_for_key.g_key_file_get_locale_for_key.html
//
func (keyFile *KeyFile) GetLocaleForKey(groupName string, key string, locale string) string {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string, nullable-string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_for_key(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetLocaleString wraps g_key_file_get_locale_string
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_locale_string.g_key_file_get_locale_string.html
//
func (keyFile *KeyFile) GetLocaleString(groupName string, key string, locale string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_string(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetLocaleStringList wraps g_key_file_get_locale_string_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_locale_string_list.g_key_file_get_locale_string_list.html
//
func (keyFile *KeyFile) GetLocaleStringList(groupName string, key string, locale string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if locale != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_key_file_get_locale_string_list(carg0, carg1, carg2, carg3, &carg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg4)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetStartGroup wraps g_key_file_get_start_group
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_start_group.g_key_file_get_start_group.html
//
func (keyFile *KeyFile) GetStartGroup() string {
	var carg0 *C.GKeyFile // in, none, converted
	var cret  *C.gchar    // return, full, string, nullable-string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_get_start_group(carg0)
	runtime.KeepAlive(keyFile)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetString wraps g_key_file_get_string
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_string.g_key_file_get_string.html
//
func (keyFile *KeyFile) GetString(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_string(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetStringList wraps g_key_file_get_string_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_string_list.g_key_file_get_string_list.html
//
func (keyFile *KeyFile) GetStringList(groupName string, key string) (uint, []string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gsize     // out, full, casted
	var cret  **C.gchar   // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_string_list(carg0, carg1, carg2, &carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var length uint
	var goret  []string
	var _goerr error

	length = uint(carg3)
	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// GetUint64 wraps g_key_file_get_uint64
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_uint64.g_key_file_get_uint64.html
//
func (keyFile *KeyFile) GetUint64(groupName string, key string) (uint64, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.guint64   // return, none, casted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_uint64(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  uint64
	var _goerr error

	goret = uint64(cret)
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetValue wraps g_key_file_get_value
// 
// see also https://docs.gtk.org/glib/method.g_key_file_get_value.g_key_file_get_value.html
//
func (keyFile *KeyFile) GetValue(groupName string, key string) (string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_get_value(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// HasGroup wraps g_key_file_has_group
// 
// see also https://docs.gtk.org/glib/method.g_key_file_has_group.g_key_file_has_group.html
//
func (keyFile *KeyFile) HasGroup(groupName string) bool {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_has_group(carg0, carg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// LoadFromBytes wraps g_key_file_load_from_bytes
// 
// see also https://docs.gtk.org/glib/method.g_key_file_load_from_bytes.g_key_file_load_from_bytes.html
//
func (keyFile *KeyFile) LoadFromBytes(bytes *Bytes, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.GBytes       // in, none, converted
	var carg2 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.GBytes)(UnsafeBytesToGlibNone(bytes))
	carg2 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_bytes(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromData wraps g_key_file_load_from_data
// 
// see also https://docs.gtk.org/glib/method.g_key_file_load_from_data.g_key_file_load_from_data.html
//
func (keyFile *KeyFile) LoadFromData(data string, length uint, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gsize         // in, none, casted
	var carg3 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(data)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gsize(length)
	carg3 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_data(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(data)
	runtime.KeepAlive(length)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// LoadFromDataDirs wraps g_key_file_load_from_data_dirs
// 
// see also https://docs.gtk.org/glib/method.g_key_file_load_from_data_dirs.g_key_file_load_from_data_dirs.html
//
func (keyFile *KeyFile) LoadFromDataDirs(file string, flags KeyFileFlags) (string, bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg3 C.GKeyFileFlags // in, none, casted
	var carg2 *C.gchar        // out, full, string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg3 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_data_dirs(carg0, carg1, &carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg2)))
	defer C.free(unsafe.Pointer(carg2))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromDirs wraps g_key_file_load_from_dirs
// 
// see also https://docs.gtk.org/glib/method.g_key_file_load_from_dirs.g_key_file_load_from_dirs.html
//
func (keyFile *KeyFile) LoadFromDirs(file string, searchDirs []string, flags KeyFileFlags) (string, bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 **C.gchar       // in, transfer: none, C Pointers: 2, Name: array[filename], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var carg4 C.GKeyFileFlags // in, none, casted
	var carg3 *C.gchar        // out, full, string
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	_ = searchDirs
	_ = carg2
	panic("unimplemented conversion of []string (const gchar**) because of unimplemented: inner pointers in array")
	carg4 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_dirs(carg0, carg1, carg2, &carg3, carg4, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(searchDirs)
	runtime.KeepAlive(flags)

	var fullPath string
	var goret    bool
	var _goerr   error

	fullPath = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return fullPath, goret, _goerr
}

// LoadFromFile wraps g_key_file_load_from_file
// 
// see also https://docs.gtk.org/glib/method.g_key_file_load_from_file.g_key_file_load_from_file.html
//
func (keyFile *KeyFile) LoadFromFile(file string, flags KeyFileFlags) (bool, error) {
	var carg0 *C.GKeyFile     // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.GKeyFileFlags // in, none, casted
	var cret  C.gboolean      // return
	var _cerr *C.GError       // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GKeyFileFlags(flags)

	cret = C.g_key_file_load_from_file(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveComment wraps g_key_file_remove_comment
// 
// see also https://docs.gtk.org/glib/method.g_key_file_remove_comment.g_key_file_remove_comment.html
//
func (keyFile *KeyFile) RemoveComment(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_key_file_remove_comment(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveGroup wraps g_key_file_remove_group
// 
// see also https://docs.gtk.org/glib/method.g_key_file_remove_group.g_key_file_remove_group.html
//
func (keyFile *KeyFile) RemoveGroup(groupName string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_remove_group(carg0, carg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RemoveKey wraps g_key_file_remove_key
// 
// see also https://docs.gtk.org/glib/method.g_key_file_remove_key.g_key_file_remove_key.html
//
func (keyFile *KeyFile) RemoveKey(groupName string, key string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))

	cret = C.g_key_file_remove_key(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SaveToFile wraps g_key_file_save_to_file
// 
// see also https://docs.gtk.org/glib/method.g_key_file_save_to_file.g_key_file_save_to_file.html
//
func (keyFile *KeyFile) SaveToFile(filename string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_key_file_save_to_file(carg0, carg1, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(filename)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetBoolean wraps g_key_file_set_boolean
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_boolean.g_key_file_set_boolean.html
//
func (keyFile *KeyFile) SetBoolean(groupName string, key string, value bool) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gboolean  // in

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	if value {
		carg3 = C.TRUE
	}

	C.g_key_file_set_boolean(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetBooleanList wraps g_key_file_set_boolean_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_boolean_list.g_key_file_set_boolean_list.html
//
func (keyFile *KeyFile) SetBooleanList(groupName string, key string, list []bool) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gboolean // in, transfer: none, C Pointers: 1, Name: array[gboolean], array (inner gboolean (*typesystem.BooleanPrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []bool (gboolean*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_boolean_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetComment wraps g_key_file_set_comment
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_comment.g_key_file_set_comment.html
//
func (keyFile *KeyFile) SetComment(groupName string, key string, comment string) (bool, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string, nullable-string
	var carg3 *C.gchar    // in, none, string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	if groupName != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if key != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
		defer C.free(unsafe.Pointer(carg2))
	}
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(comment)))
	defer C.free(unsafe.Pointer(carg3))

	cret = C.g_key_file_set_comment(carg0, carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(comment)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// SetDouble wraps g_key_file_set_double
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_double.g_key_file_set_double.html
//
func (keyFile *KeyFile) SetDouble(groupName string, key string, value float64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gdouble   // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gdouble(value)

	C.g_key_file_set_double(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetDoubleList wraps g_key_file_set_double_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_double_list.g_key_file_set_double_list.html
//
func (keyFile *KeyFile) SetDoubleList(groupName string, key string, list []float64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gdouble  // in, transfer: none, C Pointers: 1, Name: array[gdouble], array (inner gdouble (*typesystem.CastablePrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []float64 (gdouble*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_double_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetInt64 wraps g_key_file_set_int64
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_int64.g_key_file_set_int64.html
//
func (keyFile *KeyFile) SetInt64(groupName string, key string, value int64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gint64    // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint64(value)

	C.g_key_file_set_int64(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetInteger wraps g_key_file_set_integer
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_integer.g_key_file_set_integer.html
//
func (keyFile *KeyFile) SetInteger(groupName string, key string, value int32) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.gint      // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.gint(value)

	C.g_key_file_set_integer(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetIntegerList wraps g_key_file_set_integer_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_integer_list.g_key_file_set_integer_list.html
//
func (keyFile *KeyFile) SetIntegerList(groupName string, key string, list []int32) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gint     // in, transfer: none, C Pointers: 1, Name: array[gint], array (inner gint (*typesystem.CastablePrimitive), length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []int32 (gint*) because of unimplemented: non-fixed size array")

	C.g_key_file_set_integer_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetListSeparator wraps g_key_file_set_list_separator
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_list_separator.g_key_file_set_list_separator.html
//
func (keyFile *KeyFile) SetListSeparator(separator byte) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gchar     // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = C.gchar(separator)

	C.g_key_file_set_list_separator(carg0, carg1)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(separator)
}

// SetLocaleString wraps g_key_file_set_locale_string
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_locale_string.g_key_file_set_locale_string.html
//
func (keyFile *KeyFile) SetLocaleString(groupName string, key string, locale string, str string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string
	var carg4 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg4))

	C.g_key_file_set_locale_string(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(str)
}

// SetLocaleStringList wraps g_key_file_set_locale_string_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_locale_string_list.g_key_file_set_locale_string_list.html
//
func (keyFile *KeyFile) SetLocaleStringList(groupName string, key string, locale string, list []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string
	var carg4 **C.gchar   // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg5)
	var carg5 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(locale)))
	defer C.free(unsafe.Pointer(carg3))
	_ = list
	_ = carg4
	_ = carg5
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_key_file_set_locale_string_list(carg0, carg1, carg2, carg3, carg4, carg5)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(locale)
	runtime.KeepAlive(list)
}

// SetString wraps g_key_file_set_string
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_string.g_key_file_set_string.html
//
func (keyFile *KeyFile) SetString(groupName string, key string, str string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_key_file_set_string(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(str)
}

// SetStringList wraps g_key_file_set_string_list
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_string_list.g_key_file_set_string_list.html
//
func (keyFile *KeyFile) SetStringList(groupName string, key string, list []string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 **C.gchar   // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated, length-by: carg4)
	var carg4 C.gsize     // implicit

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	_ = list
	_ = carg3
	_ = carg4
	panic("unimplemented conversion of []string (const gchar* const*) because of unimplemented: inner pointers in array")

	C.g_key_file_set_string_list(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(list)
}

// SetUint64 wraps g_key_file_set_uint64
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_uint64.g_key_file_set_uint64.html
//
func (keyFile *KeyFile) SetUint64(groupName string, key string, value uint64) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.guint64   // in, none, casted

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.guint64(value)

	C.g_key_file_set_uint64(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetValue wraps g_key_file_set_value
// 
// see also https://docs.gtk.org/glib/method.g_key_file_set_value.g_key_file_set_value.html
//
func (keyFile *KeyFile) SetValue(groupName string, key string, value string) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg3))

	C.g_key_file_set_value(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// ToData wraps g_key_file_to_data
// 
// see also https://docs.gtk.org/glib/method.g_key_file_to_data.g_key_file_to_data.html
//
func (keyFile *KeyFile) ToData() (uint, string, error) {
	var carg0 *C.GKeyFile // in, none, converted
	var carg1 C.gsize     // out, full, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GKeyFile)(UnsafeKeyFileToGlibNone(keyFile))

	cret = C.g_key_file_to_data(carg0, &carg1, &_cerr)
	runtime.KeepAlive(keyFile)

	var length uint
	var goret  string
	var _goerr error

	length = uint(carg1)
	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return length, goret, _goerr
}

// LogField wraps GLogField
// 
// see also https://docs.gtk.org/glib/struct.LogField.html
//
type LogField struct {
	*logField
}

// logField is the struct that's finalized
type logField struct {
	native *C.GLogField
}

// UnsafeLogFieldToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (l *LogField) instance() *C.GLogField {
	if l == nil {
		return nil
	}
	return l.native
}

// UnsafeLogFieldFromGlibBorrow is used to convert raw C.GLogField pointers to go. This is used by the bindings internally.
func UnsafeLogFieldFromGlibBorrow(p unsafe.Pointer) *LogField {
	if p == nil {
		return nil
	}
	return &LogField{&logField{(*C.GLogField)(p)}}
}

// UnsafeLogFieldFromGlibNone is used to convert raw C.GLogField pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeLogFieldFromGlibNone(p unsafe.Pointer) *LogField {
	wrapped := UnsafeLogFieldFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to LogField because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeLogFieldFromGlibFull is used to convert raw C.GLogField pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeLogFieldFromGlibFull(p unsafe.Pointer) *LogField {
	wrapped := UnsafeLogFieldFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.logField,
		func (intern *logField) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeLogFieldFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [LogField] is expected to work anymore.
func UnsafeLogFieldFree(l *LogField) {
	C.free(unsafe.Pointer(l.native))
}

// UnsafeLogFieldToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeLogFieldToGlibNone(l *LogField) unsafe.Pointer {
	if l == nil {
		return nil
	}
	return unsafe.Pointer(l.native)
}

// UnsafeLogFieldToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeLogFieldToGlibFull(l *LogField) unsafe.Pointer {
	if l == nil {
		return nil
	}
	runtime.SetFinalizer(l.logField, nil)
	_p := unsafe.Pointer(l.native)
	l.native = nil // LogField is invalid from here on
	return _p
}

// MainContext wraps GMainContext
// 
// see also https://docs.gtk.org/glib/struct.MainContext.html
//
type MainContext struct {
	*mainContext
}

// mainContext is the struct that's finalized
type mainContext struct {
	native *C.GMainContext
}

// UnsafeMainContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MainContext) instance() *C.GMainContext {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMainContextFromGlibBorrow is used to convert raw C.GMainContext pointers to go. This is used by the bindings internally.
func UnsafeMainContextFromGlibBorrow(p unsafe.Pointer) *MainContext {
	if p == nil {
		return nil
	}
	return &MainContext{&mainContext{(*C.GMainContext)(p)}}
}

// UnsafeMainContextFromGlibNone is used to convert raw C.GMainContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMainContextFromGlibNone(p unsafe.Pointer) *MainContext {
	C.g_main_context_ref((*C.GMainContext)(p))
	wrapped := UnsafeMainContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mainContext,
		func (intern *mainContext) {
			C.g_main_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainContextFromGlibFull is used to convert raw C.GMainContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMainContextFromGlibFull(p unsafe.Pointer) *MainContext {
	wrapped := UnsafeMainContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mainContext,
		func (intern *mainContext) {
			C.g_main_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainContextRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MainContext.UnsafeMainContextUnref], then [MainContext] will leak memory.
func UnsafeMainContextRef(m *MainContext) {
	C.g_main_context_ref((*C.GMainContext)(m.native))
}

// UnsafeMainContextUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MainContext] is expected to work anymore.
func UnsafeMainContextUnref(m *MainContext) {
	C.g_main_context_unref(m.native)
}

// UnsafeMainContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMainContextToGlibNone(m *MainContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMainContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMainContextToGlibFull(m *MainContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mainContext, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MainContext is invalid from here on
	return _p
}

// NewMainContext wraps g_main_context_new
// 
// see also https://docs.gtk.org/glib/func.g_main_context_new.html
//
func NewMainContext() *MainContext {
	var cret *C.GMainContext // return, full, converted

	cret = C.g_main_context_new()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewMainContextWithFlags wraps g_main_context_new_with_flags
// 
// see also https://docs.gtk.org/glib/func.g_main_context_new_with_flags.html
//
func NewMainContextWithFlags(flags MainContextFlags) *MainContext {
	var carg1 C.GMainContextFlags // in, none, casted
	var cret  *C.GMainContext     // return, full, converted

	carg1 = C.GMainContextFlags(flags)

	cret = C.g_main_context_new_with_flags(carg1)
	runtime.KeepAlive(flags)

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// MainContextDefault wraps g_main_context_default
// 
// see also https://docs.gtk.org/glib/func.g_main_context_default.html
//
func MainContextDefault() *MainContext {
	var cret *C.GMainContext // return, none, converted

	cret = C.g_main_context_default()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// MainContextGetThreadDefault wraps g_main_context_get_thread_default
// 
// see also https://docs.gtk.org/glib/func.g_main_context_get_thread_default.html
//
func MainContextGetThreadDefault() *MainContext {
	var cret *C.GMainContext // return, none, converted, nullable

	cret = C.g_main_context_get_thread_default()

	var goret *MainContext

	if cret != nil {
		goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// MainContextRefThreadDefault wraps g_main_context_ref_thread_default
// 
// see also https://docs.gtk.org/glib/func.g_main_context_ref_thread_default.html
//
func MainContextRefThreadDefault() *MainContext {
	var cret *C.GMainContext // return, full, converted

	cret = C.g_main_context_ref_thread_default()

	var goret *MainContext

	goret = UnsafeMainContextFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Acquire wraps g_main_context_acquire
// 
// see also https://docs.gtk.org/glib/method.g_main_context_acquire.g_main_context_acquire.html
//
func (_context *MainContext) Acquire() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_acquire(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// AddPoll wraps g_main_context_add_poll
// 
// see also https://docs.gtk.org/glib/method.g_main_context_add_poll.g_main_context_add_poll.html
//
func (_context *MainContext) AddPoll(fd *PollFD, priority int32) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted
	var carg2 C.gint          // in, none, casted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fd))
	carg2 = C.gint(priority)

	C.g_main_context_add_poll(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(priority)
}

// Check wraps g_main_context_check
// 
// see also https://docs.gtk.org/glib/method.g_main_context_check.g_main_context_check.html
//
func (_context *MainContext) Check(maxPriority int32, fds []PollFD) bool {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gint          // in, none, casted
	var carg2 *C.GPollFD      // in, transfer: none, C Pointers: 1, Name: array[PollFD], array (inner GPollFD (*typesystem.Record), length-by: carg3)
	var carg3 C.gint          // implicit
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = C.gint(maxPriority)
	_ = fds
	_ = carg2
	_ = carg3
	panic("unimplemented conversion of []PollFD (GPollFD*) because of unimplemented: non-fixed size array")

	cret = C.g_main_context_check(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(maxPriority)
	runtime.KeepAlive(fds)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Dispatch wraps g_main_context_dispatch
// 
// see also https://docs.gtk.org/glib/method.g_main_context_dispatch.g_main_context_dispatch.html
//
func (_context *MainContext) Dispatch() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_dispatch(carg0)
	runtime.KeepAlive(_context)
}

// InvokeFull wraps g_main_context_invoke_full
// 
// see also https://docs.gtk.org/glib/method.g_main_context_invoke_full.g_main_context_invoke_full.html
//
func (_context *MainContext) InvokeFull(priority int32, function SourceFunc) {
	var carg0 *C.GMainContext  // in, none, converted
	var carg1 C.gint           // in, none, casted
	var carg2 C.GSourceFunc    // callback, scope: notified, closure: carg3, destroy: carg4
	var carg3 C.gpointer       // implicit
	var carg4 C.GDestroyNotify // implicit

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = C.gint(priority)
	carg2 = (*[0]byte)(C._goglib_glib2_SourceFunc)
	carg3 = C.gpointer(userdata.Register(function))
	carg4 = (C.GDestroyNotify)((*[0]byte)(C.destroyUserdata))

	C.g_main_context_invoke_full(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)
}

// IsOwner wraps g_main_context_is_owner
// 
// see also https://docs.gtk.org/glib/method.g_main_context_is_owner.g_main_context_is_owner.html
//
func (_context *MainContext) IsOwner() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_is_owner(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Iteration wraps g_main_context_iteration
// 
// see also https://docs.gtk.org/glib/method.g_main_context_iteration.g_main_context_iteration.html
//
func (_context *MainContext) Iteration(mayBlock bool) bool {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gboolean      // in
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	if mayBlock {
		carg1 = C.TRUE
	}

	cret = C.g_main_context_iteration(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(mayBlock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Pending wraps g_main_context_pending
// 
// see also https://docs.gtk.org/glib/method.g_main_context_pending.g_main_context_pending.html
//
func (_context *MainContext) Pending() bool {
	var carg0 *C.GMainContext // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_pending(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PopThreadDefault wraps g_main_context_pop_thread_default
// 
// see also https://docs.gtk.org/glib/method.g_main_context_pop_thread_default.g_main_context_pop_thread_default.html
//
func (_context *MainContext) PopThreadDefault() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_pop_thread_default(carg0)
	runtime.KeepAlive(_context)
}

// Prepare wraps g_main_context_prepare
// 
// see also https://docs.gtk.org/glib/method.g_main_context_prepare.g_main_context_prepare.html
//
func (_context *MainContext) Prepare() (int32, bool) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 C.gint          // out, full, casted
	var cret  C.gboolean      // return

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	cret = C.g_main_context_prepare(carg0, &carg1)
	runtime.KeepAlive(_context)

	var priority int32
	var goret    bool

	priority = int32(carg1)
	if cret != 0 {
		goret = true
	}

	return priority, goret
}

// PushThreadDefault wraps g_main_context_push_thread_default
// 
// see also https://docs.gtk.org/glib/method.g_main_context_push_thread_default.g_main_context_push_thread_default.html
//
func (_context *MainContext) PushThreadDefault() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_push_thread_default(carg0)
	runtime.KeepAlive(_context)
}

// Release wraps g_main_context_release
// 
// see also https://docs.gtk.org/glib/method.g_main_context_release.g_main_context_release.html
//
func (_context *MainContext) Release() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_release(carg0)
	runtime.KeepAlive(_context)
}

// RemovePoll wraps g_main_context_remove_poll
// 
// see also https://docs.gtk.org/glib/method.g_main_context_remove_poll.g_main_context_remove_poll.html
//
func (_context *MainContext) RemovePoll(fd *PollFD) {
	var carg0 *C.GMainContext // in, none, converted
	var carg1 *C.GPollFD      // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	carg1 = (*C.GPollFD)(UnsafePollFDToGlibNone(fd))

	C.g_main_context_remove_poll(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(fd)
}

// Wakeup wraps g_main_context_wakeup
// 
// see also https://docs.gtk.org/glib/method.g_main_context_wakeup.g_main_context_wakeup.html
//
func (_context *MainContext) Wakeup() {
	var carg0 *C.GMainContext // in, none, converted

	carg0 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))

	C.g_main_context_wakeup(carg0)
	runtime.KeepAlive(_context)
}

// MainLoop wraps GMainLoop
// 
// see also https://docs.gtk.org/glib/struct.MainLoop.html
//
type MainLoop struct {
	*mainLoop
}

// mainLoop is the struct that's finalized
type mainLoop struct {
	native *C.GMainLoop
}

// UnsafeMainLoopToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MainLoop) instance() *C.GMainLoop {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMainLoopFromGlibBorrow is used to convert raw C.GMainLoop pointers to go. This is used by the bindings internally.
func UnsafeMainLoopFromGlibBorrow(p unsafe.Pointer) *MainLoop {
	if p == nil {
		return nil
	}
	return &MainLoop{&mainLoop{(*C.GMainLoop)(p)}}
}

// UnsafeMainLoopFromGlibNone is used to convert raw C.GMainLoop pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMainLoopFromGlibNone(p unsafe.Pointer) *MainLoop {
	C.g_main_loop_ref((*C.GMainLoop)(p))
	wrapped := UnsafeMainLoopFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mainLoop,
		func (intern *mainLoop) {
			C.g_main_loop_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainLoopFromGlibFull is used to convert raw C.GMainLoop pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMainLoopFromGlibFull(p unsafe.Pointer) *MainLoop {
	wrapped := UnsafeMainLoopFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mainLoop,
		func (intern *mainLoop) {
			C.g_main_loop_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMainLoopRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MainLoop.UnsafeMainLoopUnref], then [MainLoop] will leak memory.
func UnsafeMainLoopRef(m *MainLoop) {
	C.g_main_loop_ref((*C.GMainLoop)(m.native))
}

// UnsafeMainLoopUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MainLoop] is expected to work anymore.
func UnsafeMainLoopUnref(m *MainLoop) {
	C.g_main_loop_unref(m.native)
}

// UnsafeMainLoopToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMainLoopToGlibNone(m *MainLoop) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMainLoopToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMainLoopToGlibFull(m *MainLoop) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mainLoop, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MainLoop is invalid from here on
	return _p
}

// NewMainLoop wraps g_main_loop_new
// 
// see also https://docs.gtk.org/glib/func.g_main_loop_new.html
//
func NewMainLoop(_context *MainContext, isRunning bool) *MainLoop {
	var carg1 *C.GMainContext // in, none, converted, nullable
	var carg2 C.gboolean      // in
	var cret  *C.GMainLoop    // return, full, converted

	if _context != nil {
		carg1 = (*C.GMainContext)(UnsafeMainContextToGlibNone(_context))
	}
	if isRunning {
		carg2 = C.TRUE
	}

	cret = C.g_main_loop_new(carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(isRunning)

	var goret *MainLoop

	goret = UnsafeMainLoopFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContext wraps g_main_loop_get_context
// 
// see also https://docs.gtk.org/glib/method.g_main_loop_get_context.g_main_loop_get_context.html
//
func (loop *MainLoop) GetContext() *MainContext {
	var carg0 *C.GMainLoop    // in, none, converted
	var cret  *C.GMainContext // return, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	cret = C.g_main_loop_get_context(carg0)
	runtime.KeepAlive(loop)

	var goret *MainContext

	goret = UnsafeMainContextFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsRunning wraps g_main_loop_is_running
// 
// see also https://docs.gtk.org/glib/method.g_main_loop_is_running.g_main_loop_is_running.html
//
func (loop *MainLoop) IsRunning() bool {
	var carg0 *C.GMainLoop // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	cret = C.g_main_loop_is_running(carg0)
	runtime.KeepAlive(loop)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Quit wraps g_main_loop_quit
// 
// see also https://docs.gtk.org/glib/method.g_main_loop_quit.g_main_loop_quit.html
//
func (loop *MainLoop) Quit() {
	var carg0 *C.GMainLoop // in, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	C.g_main_loop_quit(carg0)
	runtime.KeepAlive(loop)
}

// Run wraps g_main_loop_run
// 
// see also https://docs.gtk.org/glib/method.g_main_loop_run.g_main_loop_run.html
//
func (loop *MainLoop) Run() {
	var carg0 *C.GMainLoop // in, none, converted

	carg0 = (*C.GMainLoop)(UnsafeMainLoopToGlibNone(loop))

	C.g_main_loop_run(carg0)
	runtime.KeepAlive(loop)
}

// MappedFile wraps GMappedFile
// 
// see also https://docs.gtk.org/glib/struct.MappedFile.html
//
type MappedFile struct {
	*mappedFile
}

// mappedFile is the struct that's finalized
type mappedFile struct {
	native *C.GMappedFile
}

// UnsafeMappedFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MappedFile) instance() *C.GMappedFile {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMappedFileFromGlibBorrow is used to convert raw C.GMappedFile pointers to go. This is used by the bindings internally.
func UnsafeMappedFileFromGlibBorrow(p unsafe.Pointer) *MappedFile {
	if p == nil {
		return nil
	}
	return &MappedFile{&mappedFile{(*C.GMappedFile)(p)}}
}

// UnsafeMappedFileFromGlibNone is used to convert raw C.GMappedFile pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMappedFileFromGlibNone(p unsafe.Pointer) *MappedFile {
	C.g_mapped_file_ref((*C.GMappedFile)(p))
	wrapped := UnsafeMappedFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.mappedFile,
		func (intern *mappedFile) {
			C.g_mapped_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMappedFileFromGlibFull is used to convert raw C.GMappedFile pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMappedFileFromGlibFull(p unsafe.Pointer) *MappedFile {
	wrapped := UnsafeMappedFileFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.mappedFile,
		func (intern *mappedFile) {
			C.g_mapped_file_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMappedFileRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MappedFile.UnsafeMappedFileUnref], then [MappedFile] will leak memory.
func UnsafeMappedFileRef(m *MappedFile) {
	C.g_mapped_file_ref((*C.GMappedFile)(m.native))
}

// UnsafeMappedFileUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MappedFile] is expected to work anymore.
func UnsafeMappedFileUnref(m *MappedFile) {
	C.g_mapped_file_unref(m.native)
}

// UnsafeMappedFileToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMappedFileToGlibNone(m *MappedFile) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMappedFileToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMappedFileToGlibFull(m *MappedFile) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.mappedFile, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MappedFile is invalid from here on
	return _p
}

// NewMappedFile wraps g_mapped_file_new
// 
// see also https://docs.gtk.org/glib/func.g_mapped_file_new.html
//
func NewMappedFile(filename string, writable bool) (*MappedFile, error) {
	var carg1 *C.gchar       // in, none, string
	var carg2 C.gboolean     // in
	var cret  *C.GMappedFile // return, full, converted
	var _cerr *C.GError      // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(carg1))
	if writable {
		carg2 = C.TRUE
	}

	cret = C.g_mapped_file_new(carg1, carg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(writable)

	var goret  *MappedFile
	var _goerr error

	goret = UnsafeMappedFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// NewMappedFileFromFd wraps g_mapped_file_new_from_fd
// 
// see also https://docs.gtk.org/glib/func.g_mapped_file_new_from_fd.html
//
func NewMappedFileFromFd(fd int32, writable bool) (*MappedFile, error) {
	var carg1 C.gint         // in, none, casted
	var carg2 C.gboolean     // in
	var cret  *C.GMappedFile // return, full, converted
	var _cerr *C.GError      // out, full, converted, nullable

	carg1 = C.gint(fd)
	if writable {
		carg2 = C.TRUE
	}

	cret = C.g_mapped_file_new_from_fd(carg1, carg2, &_cerr)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(writable)

	var goret  *MappedFile
	var _goerr error

	goret = UnsafeMappedFileFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetBytes wraps g_mapped_file_get_bytes
// 
// see also https://docs.gtk.org/glib/method.g_mapped_file_get_bytes.g_mapped_file_get_bytes.html
//
func (file *MappedFile) GetBytes() *Bytes {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  *C.GBytes      // return, full, converted

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_bytes(carg0)
	runtime.KeepAlive(file)

	var goret *Bytes

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// GetContents wraps g_mapped_file_get_contents
// 
// see also https://docs.gtk.org/glib/method.g_mapped_file_get_contents.g_mapped_file_get_contents.html
//
func (file *MappedFile) GetContents() string {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  *C.gchar       // return, none, string, nullable-string

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_contents(carg0)
	runtime.KeepAlive(file)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetLength wraps g_mapped_file_get_length
// 
// see also https://docs.gtk.org/glib/method.g_mapped_file_get_length.g_mapped_file_get_length.html
//
func (file *MappedFile) GetLength() uint {
	var carg0 *C.GMappedFile // in, none, converted
	var cret  C.gsize        // return, none, casted

	carg0 = (*C.GMappedFile)(UnsafeMappedFileToGlibNone(file))

	cret = C.g_mapped_file_get_length(carg0)
	runtime.KeepAlive(file)

	var goret uint

	goret = uint(cret)

	return goret
}

// MarkupParseContext wraps GMarkupParseContext
// 
// see also https://docs.gtk.org/glib/struct.MarkupParseContext.html
//
type MarkupParseContext struct {
	*markupParseContext
}

// markupParseContext is the struct that's finalized
type markupParseContext struct {
	native *C.GMarkupParseContext
}

// UnsafeMarkupParseContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MarkupParseContext) instance() *C.GMarkupParseContext {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMarkupParseContextFromGlibBorrow is used to convert raw C.GMarkupParseContext pointers to go. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibBorrow(p unsafe.Pointer) *MarkupParseContext {
	if p == nil {
		return nil
	}
	return &MarkupParseContext{&markupParseContext{(*C.GMarkupParseContext)(p)}}
}

// UnsafeMarkupParseContextFromGlibNone is used to convert raw C.GMarkupParseContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibNone(p unsafe.Pointer) *MarkupParseContext {
	C.g_markup_parse_context_ref((*C.GMarkupParseContext)(p))
	wrapped := UnsafeMarkupParseContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.markupParseContext,
		func (intern *markupParseContext) {
			C.g_markup_parse_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMarkupParseContextFromGlibFull is used to convert raw C.GMarkupParseContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMarkupParseContextFromGlibFull(p unsafe.Pointer) *MarkupParseContext {
	wrapped := UnsafeMarkupParseContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.markupParseContext,
		func (intern *markupParseContext) {
			C.g_markup_parse_context_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMarkupParseContextRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MarkupParseContext.UnsafeMarkupParseContextUnref], then [MarkupParseContext] will leak memory.
func UnsafeMarkupParseContextRef(m *MarkupParseContext) {
	C.g_markup_parse_context_ref((*C.GMarkupParseContext)(m.native))
}

// UnsafeMarkupParseContextUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MarkupParseContext] is expected to work anymore.
func UnsafeMarkupParseContextUnref(m *MarkupParseContext) {
	C.g_markup_parse_context_unref(m.native)
}

// UnsafeMarkupParseContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMarkupParseContextToGlibNone(m *MarkupParseContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMarkupParseContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMarkupParseContextToGlibFull(m *MarkupParseContext) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.markupParseContext, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MarkupParseContext is invalid from here on
	return _p
}

// EndParse wraps g_markup_parse_context_end_parse
// 
// see also https://docs.gtk.org/glib/method.g_markup_parse_context_end_parse.g_markup_parse_context_end_parse.html
//
func (_context *MarkupParseContext) EndParse() (bool, error) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_end_parse(carg0, &_cerr)
	runtime.KeepAlive(_context)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// GetElement wraps g_markup_parse_context_get_element
// 
// see also https://docs.gtk.org/glib/method.g_markup_parse_context_get_element.g_markup_parse_context_get_element.html
//
func (_context *MarkupParseContext) GetElement() string {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  *C.gchar               // return, none, string

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_get_element(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetElementStack wraps g_markup_parse_context_get_element_stack
// 
// see also https://docs.gtk.org/glib/method.g_markup_parse_context_get_element_stack.g_markup_parse_context_get_element_stack.html
//
func (_context *MarkupParseContext) GetElementStack() []string {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var cret  *C.GSList              // container, transfer: none

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	cret = C.g_markup_parse_context_get_element_stack(carg0)
	runtime.KeepAlive(_context)

	var goret []string

	goret = UnsafeSListFromGlibNone(
		unsafe.Pointer(cret),
		func(v unsafe.Pointer) string {
			var dst string // string
			dst = C.GoString((*C.char)(v))
			return dst
		},
	)

	return goret
}

// GetPosition wraps g_markup_parse_context_get_position
// 
// see also https://docs.gtk.org/glib/method.g_markup_parse_context_get_position.g_markup_parse_context_get_position.html
//
func (_context *MarkupParseContext) GetPosition() (int32, int32) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var carg1 C.gint                 // out, full, casted
	var carg2 C.gint                 // out, full, casted

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))

	C.g_markup_parse_context_get_position(carg0, &carg1, &carg2)
	runtime.KeepAlive(_context)

	var lineNumber int32
	var charNumber int32

	lineNumber = int32(carg1)
	charNumber = int32(carg2)

	return lineNumber, charNumber
}

// Parse wraps g_markup_parse_context_parse
// 
// see also https://docs.gtk.org/glib/method.g_markup_parse_context_parse.g_markup_parse_context_parse.html
//
func (_context *MarkupParseContext) Parse(text string, textLen int) (bool, error) {
	var carg0 *C.GMarkupParseContext // in, none, converted
	var carg1 *C.gchar               // in, none, string
	var carg2 C.gssize               // in, none, casted
	var cret  C.gboolean             // return
	var _cerr *C.GError              // out, full, converted, nullable

	carg0 = (*C.GMarkupParseContext)(UnsafeMarkupParseContextToGlibNone(_context))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(textLen)

	cret = C.g_markup_parse_context_parse(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(textLen)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MarkupParser wraps GMarkupParser
// 
// see also https://docs.gtk.org/glib/struct.MarkupParser.html
//
type MarkupParser struct {
	*markupParser
}

// markupParser is the struct that's finalized
type markupParser struct {
	native *C.GMarkupParser
}

// UnsafeMarkupParserToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MarkupParser) instance() *C.GMarkupParser {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMarkupParserFromGlibBorrow is used to convert raw C.GMarkupParser pointers to go. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibBorrow(p unsafe.Pointer) *MarkupParser {
	if p == nil {
		return nil
	}
	return &MarkupParser{&markupParser{(*C.GMarkupParser)(p)}}
}

// UnsafeMarkupParserFromGlibNone is used to convert raw C.GMarkupParser pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibNone(p unsafe.Pointer) *MarkupParser {
	wrapped := UnsafeMarkupParserFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MarkupParser because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMarkupParserFromGlibFull is used to convert raw C.GMarkupParser pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMarkupParserFromGlibFull(p unsafe.Pointer) *MarkupParser {
	wrapped := UnsafeMarkupParserFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.markupParser,
		func (intern *markupParser) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMarkupParserFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MarkupParser] is expected to work anymore.
func UnsafeMarkupParserFree(m *MarkupParser) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMarkupParserToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMarkupParserToGlibNone(m *MarkupParser) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMarkupParserToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMarkupParserToGlibFull(m *MarkupParser) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.markupParser, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MarkupParser is invalid from here on
	return _p
}

// MatchInfo wraps GMatchInfo
// 
// see also https://docs.gtk.org/glib/struct.MatchInfo.html
//
type MatchInfo struct {
	*matchInfo
}

// matchInfo is the struct that's finalized
type matchInfo struct {
	native *C.GMatchInfo
}

// UnsafeMatchInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MatchInfo) instance() *C.GMatchInfo {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMatchInfoFromGlibBorrow is used to convert raw C.GMatchInfo pointers to go. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibBorrow(p unsafe.Pointer) *MatchInfo {
	if p == nil {
		return nil
	}
	return &MatchInfo{&matchInfo{(*C.GMatchInfo)(p)}}
}

// UnsafeMatchInfoFromGlibNone is used to convert raw C.GMatchInfo pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibNone(p unsafe.Pointer) *MatchInfo {
	C.g_match_info_ref((*C.GMatchInfo)(p))
	wrapped := UnsafeMatchInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.matchInfo,
		func (intern *matchInfo) {
			C.g_match_info_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMatchInfoFromGlibFull is used to convert raw C.GMatchInfo pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMatchInfoFromGlibFull(p unsafe.Pointer) *MatchInfo {
	wrapped := UnsafeMatchInfoFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.matchInfo,
		func (intern *matchInfo) {
			C.g_match_info_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeMatchInfoRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [MatchInfo.UnsafeMatchInfoUnref], then [MatchInfo] will leak memory.
func UnsafeMatchInfoRef(m *MatchInfo) {
	C.g_match_info_ref((*C.GMatchInfo)(m.native))
}

// UnsafeMatchInfoUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MatchInfo] is expected to work anymore.
func UnsafeMatchInfoUnref(m *MatchInfo) {
	C.g_match_info_unref(m.native)
}

// UnsafeMatchInfoToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMatchInfoToGlibNone(m *MatchInfo) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMatchInfoToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMatchInfoToGlibFull(m *MatchInfo) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.matchInfo, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MatchInfo is invalid from here on
	return _p
}

// ExpandReferences wraps g_match_info_expand_references
// 
// see also https://docs.gtk.org/glib/method.g_match_info_expand_references.g_match_info_expand_references.html
//
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.gchar      // return, full, string, nullable-string
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(stringToExpand)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_expand_references(carg0, carg1, &_cerr)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(stringToExpand)

	var goret  string
	var _goerr error

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Fetch wraps g_match_info_fetch
// 
// see also https://docs.gtk.org/glib/method.g_match_info_fetch.g_match_info_fetch.html
//
func (matchInfo *MatchInfo) Fetch(matchNum int32) string {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 C.gint        // in, none, casted
	var cret  *C.gchar      // return, full, string, nullable-string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = C.gint(matchNum)

	cret = C.g_match_info_fetch(carg0, carg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FetchAll wraps g_match_info_fetch_all
// 
// see also https://docs.gtk.org/glib/method.g_match_info_fetch_all.g_match_info_fetch_all.html
//
func (matchInfo *MatchInfo) FetchAll() []string {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  **C.gchar     // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_fetch_all(carg0)
	runtime.KeepAlive(matchInfo)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// FetchNamed wraps g_match_info_fetch_named
// 
// see also https://docs.gtk.org/glib/method.g_match_info_fetch_named.g_match_info_fetch_named.html
//
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var cret  *C.gchar      // return, full, string, nullable-string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_fetch_named(carg0, carg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FetchNamedPos wraps g_match_info_fetch_named_pos
// 
// see also https://docs.gtk.org/glib/method.g_match_info_fetch_named_pos.g_match_info_fetch_named_pos.html
//
func (matchInfo *MatchInfo) FetchNamedPos(name string) (int32, int32, bool) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 *C.gchar      // in, none, string
	var carg2 C.gint        // out, full, casted
	var carg3 C.gint        // out, full, casted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_match_info_fetch_named_pos(carg0, carg1, &carg2, &carg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var startPos int32
	var endPos   int32
	var goret    bool

	startPos = int32(carg2)
	endPos = int32(carg3)
	if cret != 0 {
		goret = true
	}

	return startPos, endPos, goret
}

// FetchPos wraps g_match_info_fetch_pos
// 
// see also https://docs.gtk.org/glib/method.g_match_info_fetch_pos.g_match_info_fetch_pos.html
//
func (matchInfo *MatchInfo) FetchPos(matchNum int32) (int32, int32, bool) {
	var carg0 *C.GMatchInfo // in, none, converted
	var carg1 C.gint        // in, none, casted
	var carg2 C.gint        // out, full, casted
	var carg3 C.gint        // out, full, casted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))
	carg1 = C.gint(matchNum)

	cret = C.g_match_info_fetch_pos(carg0, carg1, &carg2, &carg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var startPos int32
	var endPos   int32
	var goret    bool

	startPos = int32(carg2)
	endPos = int32(carg3)
	if cret != 0 {
		goret = true
	}

	return startPos, endPos, goret
}

// GetMatchCount wraps g_match_info_get_match_count
// 
// see also https://docs.gtk.org/glib/method.g_match_info_get_match_count.g_match_info_get_match_count.html
//
func (matchInfo *MatchInfo) GetMatchCount() int32 {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gint        // return, none, casted

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_match_count(carg0)
	runtime.KeepAlive(matchInfo)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetRegex wraps g_match_info_get_regex
// 
// see also https://docs.gtk.org/glib/method.g_match_info_get_regex.g_match_info_get_regex.html
//
func (matchInfo *MatchInfo) GetRegex() *Regex {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  *C.GRegex     // return, none, converted

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_regex(carg0)
	runtime.KeepAlive(matchInfo)

	var goret *Regex

	goret = UnsafeRegexFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetString wraps g_match_info_get_string
// 
// see also https://docs.gtk.org/glib/method.g_match_info_get_string.g_match_info_get_string.html
//
func (matchInfo *MatchInfo) GetString() string {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  *C.gchar      // return, none, string

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_get_string(carg0)
	runtime.KeepAlive(matchInfo)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// IsPartialMatch wraps g_match_info_is_partial_match
// 
// see also https://docs.gtk.org/glib/method.g_match_info_is_partial_match.g_match_info_is_partial_match.html
//
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_is_partial_match(carg0)
	runtime.KeepAlive(matchInfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Matches wraps g_match_info_matches
// 
// see also https://docs.gtk.org/glib/method.g_match_info_matches.g_match_info_matches.html
//
func (matchInfo *MatchInfo) Matches() bool {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_matches(carg0)
	runtime.KeepAlive(matchInfo)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Next wraps g_match_info_next
// 
// see also https://docs.gtk.org/glib/method.g_match_info_next.g_match_info_next.html
//
func (matchInfo *MatchInfo) Next() (bool, error) {
	var carg0 *C.GMatchInfo // in, none, converted
	var cret  C.gboolean    // return
	var _cerr *C.GError     // out, full, converted, nullable

	carg0 = (*C.GMatchInfo)(UnsafeMatchInfoToGlibNone(matchInfo))

	cret = C.g_match_info_next(carg0, &_cerr)
	runtime.KeepAlive(matchInfo)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// MemVTable wraps GMemVTable
// 
// see also https://docs.gtk.org/glib/struct.MemVTable.html
//
type MemVTable struct {
	*memVTable
}

// memVTable is the struct that's finalized
type memVTable struct {
	native *C.GMemVTable
}

// UnsafeMemVTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (m *MemVTable) instance() *C.GMemVTable {
	if m == nil {
		return nil
	}
	return m.native
}

// UnsafeMemVTableFromGlibBorrow is used to convert raw C.GMemVTable pointers to go. This is used by the bindings internally.
func UnsafeMemVTableFromGlibBorrow(p unsafe.Pointer) *MemVTable {
	if p == nil {
		return nil
	}
	return &MemVTable{&memVTable{(*C.GMemVTable)(p)}}
}

// UnsafeMemVTableFromGlibNone is used to convert raw C.GMemVTable pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeMemVTableFromGlibNone(p unsafe.Pointer) *MemVTable {
	wrapped := UnsafeMemVTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to MemVTable because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeMemVTableFromGlibFull is used to convert raw C.GMemVTable pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeMemVTableFromGlibFull(p unsafe.Pointer) *MemVTable {
	wrapped := UnsafeMemVTableFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.memVTable,
		func (intern *memVTable) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeMemVTableFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [MemVTable] is expected to work anymore.
func UnsafeMemVTableFree(m *MemVTable) {
	C.free(unsafe.Pointer(m.native))
}

// UnsafeMemVTableToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeMemVTableToGlibNone(m *MemVTable) unsafe.Pointer {
	if m == nil {
		return nil
	}
	return unsafe.Pointer(m.native)
}

// UnsafeMemVTableToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeMemVTableToGlibFull(m *MemVTable) unsafe.Pointer {
	if m == nil {
		return nil
	}
	runtime.SetFinalizer(m.memVTable, nil)
	_p := unsafe.Pointer(m.native)
	m.native = nil // MemVTable is invalid from here on
	return _p
}

// Node wraps GNode
// 
// see also https://docs.gtk.org/glib/struct.Node.html
//
type Node struct {
	*node
}

// node is the struct that's finalized
type node struct {
	native *C.GNode
}

// UnsafeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (n *Node) instance() *C.GNode {
	if n == nil {
		return nil
	}
	return n.native
}

// UnsafeNodeFromGlibBorrow is used to convert raw C.GNode pointers to go. This is used by the bindings internally.
func UnsafeNodeFromGlibBorrow(p unsafe.Pointer) *Node {
	if p == nil {
		return nil
	}
	return &Node{&node{(*C.GNode)(p)}}
}

// UnsafeNodeFromGlibNone is used to convert raw C.GNode pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeNodeFromGlibNone(p unsafe.Pointer) *Node {
	wrapped := UnsafeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Node because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeNodeFromGlibFull is used to convert raw C.GNode pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeNodeFromGlibFull(p unsafe.Pointer) *Node {
	wrapped := UnsafeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.node,
		func (intern *node) {
			C.g_node_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeNodeDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Node] is expected to work anymore.
func UnsafeNodeDestroy(n *Node) {
	C.g_node_destroy(n.native)
}

// UnsafeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeNodeToGlibNone(n *Node) unsafe.Pointer {
	if n == nil {
		return nil
	}
	return unsafe.Pointer(n.native)
}

// UnsafeNodeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeNodeToGlibFull(n *Node) unsafe.Pointer {
	if n == nil {
		return nil
	}
	runtime.SetFinalizer(n.node, nil)
	_p := unsafe.Pointer(n.native)
	n.native = nil // Node is invalid from here on
	return _p
}

// ChildPosition wraps g_node_child_position
// 
// see also https://docs.gtk.org/glib/method.g_node_child_position.g_node_child_position.html
//
func (node *Node) ChildPosition(child *Node) int32 {
	var carg0 *C.GNode // in, none, converted
	var carg1 *C.GNode // in, none, converted
	var cret  C.gint   // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))
	carg1 = (*C.GNode)(UnsafeNodeToGlibNone(child))

	cret = C.g_node_child_position(carg0, carg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(child)

	var goret int32

	goret = int32(cret)

	return goret
}

// Depth wraps g_node_depth
// 
// see also https://docs.gtk.org/glib/method.g_node_depth.g_node_depth.html
//
func (node *Node) Depth() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	cret = C.g_node_depth(carg0)
	runtime.KeepAlive(node)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsAncestor wraps g_node_is_ancestor
// 
// see also https://docs.gtk.org/glib/method.g_node_is_ancestor.g_node_is_ancestor.html
//
func (node *Node) IsAncestor(descendant *Node) bool {
	var carg0 *C.GNode   // in, none, converted
	var carg1 *C.GNode   // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))
	carg1 = (*C.GNode)(UnsafeNodeToGlibNone(descendant))

	cret = C.g_node_is_ancestor(carg0, carg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(descendant)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MaxHeight wraps g_node_max_height
// 
// see also https://docs.gtk.org/glib/method.g_node_max_height.g_node_max_height.html
//
func (root *Node) MaxHeight() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(root))

	cret = C.g_node_max_height(carg0)
	runtime.KeepAlive(root)

	var goret uint

	goret = uint(cret)

	return goret
}

// NChildren wraps g_node_n_children
// 
// see also https://docs.gtk.org/glib/method.g_node_n_children.g_node_n_children.html
//
func (node *Node) NChildren() uint {
	var carg0 *C.GNode // in, none, converted
	var cret  C.guint  // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	cret = C.g_node_n_children(carg0)
	runtime.KeepAlive(node)

	var goret uint

	goret = uint(cret)

	return goret
}

// NNodes wraps g_node_n_nodes
// 
// see also https://docs.gtk.org/glib/method.g_node_n_nodes.g_node_n_nodes.html
//
func (root *Node) NNodes(flags TraverseFlags) uint {
	var carg0 *C.GNode         // in, none, converted
	var carg1 C.GTraverseFlags // in, none, casted
	var cret  C.guint          // return, none, casted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(root))
	carg1 = C.GTraverseFlags(flags)

	cret = C.g_node_n_nodes(carg0, carg1)
	runtime.KeepAlive(root)
	runtime.KeepAlive(flags)

	var goret uint

	goret = uint(cret)

	return goret
}

// ReverseChildren wraps g_node_reverse_children
// 
// see also https://docs.gtk.org/glib/method.g_node_reverse_children.g_node_reverse_children.html
//
func (node *Node) ReverseChildren() {
	var carg0 *C.GNode // in, none, converted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	C.g_node_reverse_children(carg0)
	runtime.KeepAlive(node)
}

// Unlink wraps g_node_unlink
// 
// see also https://docs.gtk.org/glib/method.g_node_unlink.g_node_unlink.html
//
func (node *Node) Unlink() {
	var carg0 *C.GNode // in, none, converted

	carg0 = (*C.GNode)(UnsafeNodeToGlibNone(node))

	C.g_node_unlink(carg0)
	runtime.KeepAlive(node)
}

// Once wraps GOnce
// 
// see also https://docs.gtk.org/glib/struct.Once.html
//
type Once struct {
	*once
}

// once is the struct that's finalized
type once struct {
	native *C.GOnce
}

// UnsafeOnceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *Once) instance() *C.GOnce {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOnceFromGlibBorrow is used to convert raw C.GOnce pointers to go. This is used by the bindings internally.
func UnsafeOnceFromGlibBorrow(p unsafe.Pointer) *Once {
	if p == nil {
		return nil
	}
	return &Once{&once{(*C.GOnce)(p)}}
}

// UnsafeOnceFromGlibNone is used to convert raw C.GOnce pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOnceFromGlibNone(p unsafe.Pointer) *Once {
	wrapped := UnsafeOnceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Once because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOnceFromGlibFull is used to convert raw C.GOnce pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOnceFromGlibFull(p unsafe.Pointer) *Once {
	wrapped := UnsafeOnceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.once,
		func (intern *once) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOnceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Once] is expected to work anymore.
func UnsafeOnceFree(o *Once) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOnceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOnceToGlibNone(o *Once) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOnceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOnceToGlibFull(o *Once) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.once, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // Once is invalid from here on
	return _p
}

// OnceInitEnterImpl wraps g_once_init_enter_impl
// 
// see also https://docs.gtk.org/glib/func.g_once_init_enter_impl.html
func OnceInitEnterImpl(location *uint) bool {
	var carg1 *C.gsize   // in, transfer: none, C Pointers: 1, Name: gsize
	var cret  C.gboolean // return

	_ = location
	_ = carg1
	panic("unimplemented conversion of *uint (volatile gsize*) because of no basic converter found")

	cret = C.g_once_init_enter_impl(carg1)
	runtime.KeepAlive(location)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// OptionContext wraps GOptionContext
// 
// see also https://docs.gtk.org/glib/struct.OptionContext.html
//
type OptionContext struct {
	*optionContext
}

// optionContext is the struct that's finalized
type optionContext struct {
	native *C.GOptionContext
}

// UnsafeOptionContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionContext) instance() *C.GOptionContext {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionContextFromGlibBorrow is used to convert raw C.GOptionContext pointers to go. This is used by the bindings internally.
func UnsafeOptionContextFromGlibBorrow(p unsafe.Pointer) *OptionContext {
	if p == nil {
		return nil
	}
	return &OptionContext{&optionContext{(*C.GOptionContext)(p)}}
}

// UnsafeOptionContextFromGlibNone is used to convert raw C.GOptionContext pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionContextFromGlibNone(p unsafe.Pointer) *OptionContext {
	wrapped := UnsafeOptionContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OptionContext because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOptionContextFromGlibFull is used to convert raw C.GOptionContext pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionContextFromGlibFull(p unsafe.Pointer) *OptionContext {
	wrapped := UnsafeOptionContextFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionContext,
		func (intern *optionContext) {
			C.g_option_context_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionContextFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionContext] is expected to work anymore.
func UnsafeOptionContextFree(o *OptionContext) {
	C.g_option_context_free(o.native)
}

// UnsafeOptionContextToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionContextToGlibNone(o *OptionContext) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionContextToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionContextToGlibFull(o *OptionContext) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionContext, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionContext is invalid from here on
	return _p
}

// AddGroup wraps g_option_context_add_group
// 
// see also https://docs.gtk.org/glib/method.g_option_context_add_group.g_option_context_add_group.html
//
func (_context *OptionContext) AddGroup(group *OptionGroup) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionGroup   // in, full, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibFull(group))

	C.g_option_context_add_group(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(group)
}

// AddMainEntries wraps g_option_context_add_main_entries
// 
// see also https://docs.gtk.org/glib/method.g_option_context_add_main_entries.g_option_context_add_main_entries.html
//
func (_context *OptionContext) AddMainEntries(entries []OptionEntry, translationDomain string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionEntry   // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)
	var carg2 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")
	if translationDomain != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(translationDomain)))
		defer C.free(unsafe.Pointer(carg2))
	}

	C.g_option_context_add_main_entries(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(entries)
	runtime.KeepAlive(translationDomain)
}

// GetDescription wraps g_option_context_get_description
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_description.g_option_context_get_description.html
//
func (_context *OptionContext) GetDescription() string {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.gchar          // return, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_description(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetHelp wraps g_option_context_get_help
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_help.g_option_context_get_help.html
//
func (_context *OptionContext) GetHelp(mainHelp bool, group *OptionGroup) string {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in
	var carg2 *C.GOptionGroup   // in, none, converted, nullable
	var cret  *C.gchar          // return, full, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if mainHelp {
		carg1 = C.TRUE
	}
	if group != nil {
		carg2 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	}

	cret = C.g_option_context_get_help(carg0, carg1, carg2)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(mainHelp)
	runtime.KeepAlive(group)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// GetHelpEnabled wraps g_option_context_get_help_enabled
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_help_enabled.g_option_context_get_help_enabled.html
//
func (_context *OptionContext) GetHelpEnabled() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_help_enabled(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetIgnoreUnknownOptions wraps g_option_context_get_ignore_unknown_options
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_ignore_unknown_options.g_option_context_get_ignore_unknown_options.html
//
func (_context *OptionContext) GetIgnoreUnknownOptions() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_ignore_unknown_options(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMainGroup wraps g_option_context_get_main_group
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_main_group.g_option_context_get_main_group.html
//
func (_context *OptionContext) GetMainGroup() *OptionGroup {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.GOptionGroup   // return, none, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_main_group(carg0)
	runtime.KeepAlive(_context)

	var goret *OptionGroup

	goret = UnsafeOptionGroupFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetStrictPosix wraps g_option_context_get_strict_posix
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_strict_posix.g_option_context_get_strict_posix.html
//
func (_context *OptionContext) GetStrictPosix() bool {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  C.gboolean        // return

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_strict_posix(carg0)
	runtime.KeepAlive(_context)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetSummary wraps g_option_context_get_summary
// 
// see also https://docs.gtk.org/glib/method.g_option_context_get_summary.g_option_context_get_summary.html
//
func (_context *OptionContext) GetSummary() string {
	var carg0 *C.GOptionContext // in, none, converted
	var cret  *C.gchar          // return, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))

	cret = C.g_option_context_get_summary(carg0)
	runtime.KeepAlive(_context)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// SetDescription wraps g_option_context_set_description
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_description.g_option_context_set_description.html
//
func (_context *OptionContext) SetDescription(description string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if description != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_option_context_set_description(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(description)
}

// SetHelpEnabled wraps g_option_context_set_help_enabled
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_help_enabled.g_option_context_set_help_enabled.html
//
func (_context *OptionContext) SetHelpEnabled(helpEnabled bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if helpEnabled {
		carg1 = C.TRUE
	}

	C.g_option_context_set_help_enabled(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(helpEnabled)
}

// SetIgnoreUnknownOptions wraps g_option_context_set_ignore_unknown_options
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_ignore_unknown_options.g_option_context_set_ignore_unknown_options.html
//
func (_context *OptionContext) SetIgnoreUnknownOptions(ignoreUnknown bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if ignoreUnknown {
		carg1 = C.TRUE
	}

	C.g_option_context_set_ignore_unknown_options(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(ignoreUnknown)
}

// SetMainGroup wraps g_option_context_set_main_group
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_main_group.g_option_context_set_main_group.html
//
func (_context *OptionContext) SetMainGroup(group *OptionGroup) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.GOptionGroup   // in, full, converted

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibFull(group))

	C.g_option_context_set_main_group(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(group)
}

// SetStrictPosix wraps g_option_context_set_strict_posix
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_strict_posix.g_option_context_set_strict_posix.html
//
func (_context *OptionContext) SetStrictPosix(strictPosix bool) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 C.gboolean        // in

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if strictPosix {
		carg1 = C.TRUE
	}

	C.g_option_context_set_strict_posix(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(strictPosix)
}

// SetSummary wraps g_option_context_set_summary
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_summary.g_option_context_set_summary.html
//
func (_context *OptionContext) SetSummary(summary string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string, nullable-string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	if summary != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(carg1))
	}

	C.g_option_context_set_summary(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(summary)
}

// SetTranslationDomain wraps g_option_context_set_translation_domain
// 
// see also https://docs.gtk.org/glib/method.g_option_context_set_translation_domain.g_option_context_set_translation_domain.html
//
func (_context *OptionContext) SetTranslationDomain(domain string) {
	var carg0 *C.GOptionContext // in, none, converted
	var carg1 *C.gchar          // in, none, string

	carg0 = (*C.GOptionContext)(UnsafeOptionContextToGlibNone(_context))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_option_context_set_translation_domain(carg0, carg1)
	runtime.KeepAlive(_context)
	runtime.KeepAlive(domain)
}

// OptionEntry wraps GOptionEntry
// 
// see also https://docs.gtk.org/glib/struct.OptionEntry.html
//
type OptionEntry struct {
	*optionEntry
}

// optionEntry is the struct that's finalized
type optionEntry struct {
	native *C.GOptionEntry
}

// UnsafeOptionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionEntry) instance() *C.GOptionEntry {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionEntryFromGlibBorrow is used to convert raw C.GOptionEntry pointers to go. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibBorrow(p unsafe.Pointer) *OptionEntry {
	if p == nil {
		return nil
	}
	return &OptionEntry{&optionEntry{(*C.GOptionEntry)(p)}}
}

// UnsafeOptionEntryFromGlibNone is used to convert raw C.GOptionEntry pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibNone(p unsafe.Pointer) *OptionEntry {
	wrapped := UnsafeOptionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to OptionEntry because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeOptionEntryFromGlibFull is used to convert raw C.GOptionEntry pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionEntryFromGlibFull(p unsafe.Pointer) *OptionEntry {
	wrapped := UnsafeOptionEntryFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionEntry,
		func (intern *optionEntry) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeOptionEntryFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionEntry] is expected to work anymore.
func UnsafeOptionEntryFree(o *OptionEntry) {
	C.free(unsafe.Pointer(o.native))
}

// UnsafeOptionEntryToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionEntryToGlibNone(o *OptionEntry) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionEntryToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionEntryToGlibFull(o *OptionEntry) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionEntry, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionEntry is invalid from here on
	return _p
}

// OptionGroup wraps GOptionGroup
// 
// see also https://docs.gtk.org/glib/struct.OptionGroup.html
//
type OptionGroup struct {
	*optionGroup
}

// optionGroup is the struct that's finalized
type optionGroup struct {
	native *C.GOptionGroup
}

// UnsafeOptionGroupToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (o *OptionGroup) instance() *C.GOptionGroup {
	if o == nil {
		return nil
	}
	return o.native
}

// UnsafeOptionGroupFromGlibBorrow is used to convert raw C.GOptionGroup pointers to go. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibBorrow(p unsafe.Pointer) *OptionGroup {
	if p == nil {
		return nil
	}
	return &OptionGroup{&optionGroup{(*C.GOptionGroup)(p)}}
}

// UnsafeOptionGroupFromGlibNone is used to convert raw C.GOptionGroup pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibNone(p unsafe.Pointer) *OptionGroup {
	C.g_option_group_ref((*C.GOptionGroup)(p))
	wrapped := UnsafeOptionGroupFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.optionGroup,
		func (intern *optionGroup) {
			C.g_option_group_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionGroupFromGlibFull is used to convert raw C.GOptionGroup pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeOptionGroupFromGlibFull(p unsafe.Pointer) *OptionGroup {
	wrapped := UnsafeOptionGroupFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.optionGroup,
		func (intern *optionGroup) {
			C.g_option_group_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeOptionGroupRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [OptionGroup.UnsafeOptionGroupUnref], then [OptionGroup] will leak memory.
func UnsafeOptionGroupRef(o *OptionGroup) {
	C.g_option_group_ref((*C.GOptionGroup)(o.native))
}

// UnsafeOptionGroupUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [OptionGroup] is expected to work anymore.
func UnsafeOptionGroupUnref(o *OptionGroup) {
	C.g_option_group_unref(o.native)
}

// UnsafeOptionGroupToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeOptionGroupToGlibNone(o *OptionGroup) unsafe.Pointer {
	if o == nil {
		return nil
	}
	return unsafe.Pointer(o.native)
}

// UnsafeOptionGroupToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeOptionGroupToGlibFull(o *OptionGroup) unsafe.Pointer {
	if o == nil {
		return nil
	}
	runtime.SetFinalizer(o.optionGroup, nil)
	_p := unsafe.Pointer(o.native)
	o.native = nil // OptionGroup is invalid from here on
	return _p
}

// AddEntries wraps g_option_group_add_entries
// 
// see also https://docs.gtk.org/glib/method.g_option_group_add_entries.g_option_group_add_entries.html
//
func (group *OptionGroup) AddEntries(entries []OptionEntry) {
	var carg0 *C.GOptionGroup // in, none, converted
	var carg1 *C.GOptionEntry // in, transfer: none, C Pointers: 1, Name: array[OptionEntry], array (inner GOptionEntry (*typesystem.Record), zero-terminated)

	carg0 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	_ = entries
	_ = carg1
	panic("unimplemented conversion of []OptionEntry (const GOptionEntry*) because of unimplemented: non-fixed size array")

	C.g_option_group_add_entries(carg0, carg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(entries)
}

// SetTranslationDomain wraps g_option_group_set_translation_domain
// 
// see also https://docs.gtk.org/glib/method.g_option_group_set_translation_domain.g_option_group_set_translation_domain.html
//
func (group *OptionGroup) SetTranslationDomain(domain string) {
	var carg0 *C.GOptionGroup // in, none, converted
	var carg1 *C.gchar        // in, none, string

	carg0 = (*C.GOptionGroup)(UnsafeOptionGroupToGlibNone(group))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_option_group_set_translation_domain(carg0, carg1)
	runtime.KeepAlive(group)
	runtime.KeepAlive(domain)
}

// PathBuf wraps GPathBuf
// 
// see also https://docs.gtk.org/glib/struct.PathBuf.html
//
type PathBuf struct {
	*pathBuf
}

// pathBuf is the struct that's finalized
type pathBuf struct {
	native *C.GPathBuf
}

// UnsafePathBufToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PathBuf) instance() *C.GPathBuf {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePathBufFromGlibBorrow is used to convert raw C.GPathBuf pointers to go. This is used by the bindings internally.
func UnsafePathBufFromGlibBorrow(p unsafe.Pointer) *PathBuf {
	if p == nil {
		return nil
	}
	return &PathBuf{&pathBuf{(*C.GPathBuf)(p)}}
}

// UnsafePathBufFromGlibNone is used to convert raw C.GPathBuf pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePathBufFromGlibNone(p unsafe.Pointer) *PathBuf {
	wrapped := UnsafePathBufFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PathBuf because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePathBufFromGlibFull is used to convert raw C.GPathBuf pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePathBufFromGlibFull(p unsafe.Pointer) *PathBuf {
	wrapped := UnsafePathBufFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pathBuf,
		func (intern *pathBuf) {
			C.g_path_buf_free(intern.native)
		},
	)
	return wrapped
}

// UnsafePathBufFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PathBuf] is expected to work anymore.
func UnsafePathBufFree(p *PathBuf) {
	C.g_path_buf_free(p.native)
}

// UnsafePathBufToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePathBufToGlibNone(p *PathBuf) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePathBufToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePathBufToGlibFull(p *PathBuf) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pathBuf, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PathBuf is invalid from here on
	return _p
}

// Clear wraps g_path_buf_clear
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_clear.g_path_buf_clear.html
//
func (buf *PathBuf) Clear() {
	var carg0 *C.GPathBuf // in, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	C.g_path_buf_clear(carg0)
	runtime.KeepAlive(buf)
}

// ClearToPath wraps g_path_buf_clear_to_path
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_clear_to_path.g_path_buf_clear_to_path.html
//
func (buf *PathBuf) ClearToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_clear_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// FreeToPath wraps g_path_buf_free_to_path
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_free_to_path.g_path_buf_free_to_path.html
//
func (buf *PathBuf) FreeToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_free_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// Init wraps g_path_buf_init
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_init.g_path_buf_init.html
//
func (buf *PathBuf) Init() *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_init(carg0)
	runtime.KeepAlive(buf)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// InitFromPath wraps g_path_buf_init_from_path
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_init_from_path.g_path_buf_init_from_path.html
//
func (buf *PathBuf) InitFromPath(path string) *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string, nullable-string
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	if path != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_path_buf_init_from_path(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Pop wraps g_path_buf_pop
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_pop.g_path_buf_pop.html
//
func (buf *PathBuf) Pop() bool {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_pop(carg0)
	runtime.KeepAlive(buf)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Push wraps g_path_buf_push
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_push.g_path_buf_push.html
//
func (buf *PathBuf) Push(path string) *PathBuf {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  *C.GPathBuf // return, none, converted

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_buf_push(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(path)

	var goret *PathBuf

	goret = UnsafePathBufFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SetExtension wraps g_path_buf_set_extension
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_set_extension.g_path_buf_set_extension.html
//
func (buf *PathBuf) SetExtension(extension string) bool {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string, nullable-string
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	if extension != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_path_buf_set_extension(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(extension)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SetFilename wraps g_path_buf_set_filename
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_set_filename.g_path_buf_set_filename.html
//
func (buf *PathBuf) SetFilename(fileName string) bool {
	var carg0 *C.GPathBuf // in, none, converted
	var carg1 *C.char     // in, none, string
	var cret  C.gboolean  // return

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_path_buf_set_filename(carg0, carg1)
	runtime.KeepAlive(buf)
	runtime.KeepAlive(fileName)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ToPath wraps g_path_buf_to_path
// 
// see also https://docs.gtk.org/glib/method.g_path_buf_to_path.g_path_buf_to_path.html
//
func (buf *PathBuf) ToPath() string {
	var carg0 *C.GPathBuf // in, none, converted
	var cret  *C.char     // return, full, string, nullable

	carg0 = (*C.GPathBuf)(UnsafePathBufToGlibNone(buf))

	cret = C.g_path_buf_to_path(carg0)
	runtime.KeepAlive(buf)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// PatternSpec wraps GPatternSpec
// 
// see also https://docs.gtk.org/glib/struct.PatternSpec.html
//
type PatternSpec struct {
	*patternSpec
}

// patternSpec is the struct that's finalized
type patternSpec struct {
	native *C.GPatternSpec
}

// UnsafePatternSpecToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PatternSpec) instance() *C.GPatternSpec {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePatternSpecFromGlibBorrow is used to convert raw C.GPatternSpec pointers to go. This is used by the bindings internally.
func UnsafePatternSpecFromGlibBorrow(p unsafe.Pointer) *PatternSpec {
	if p == nil {
		return nil
	}
	return &PatternSpec{&patternSpec{(*C.GPatternSpec)(p)}}
}

// UnsafePatternSpecFromGlibNone is used to convert raw C.GPatternSpec pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePatternSpecFromGlibNone(p unsafe.Pointer) *PatternSpec {
	wrapped := UnsafePatternSpecFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafePatternSpecFromGlibFull is used to convert raw C.GPatternSpec pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePatternSpecFromGlibFull(p unsafe.Pointer) *PatternSpec {
	wrapped := UnsafePatternSpecFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.patternSpec,
		func (intern *patternSpec) {
			C.g_pattern_spec_free(intern.native)
		},
	)
	return wrapped
}

// UnsafePatternSpecFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PatternSpec] is expected to work anymore.
func UnsafePatternSpecFree(p *PatternSpec) {
	C.g_pattern_spec_free(p.native)
}

// UnsafePatternSpecToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePatternSpecToGlibNone(p *PatternSpec) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePatternSpecToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePatternSpecToGlibFull(p *PatternSpec) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.patternSpec, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PatternSpec is invalid from here on
	return _p
}

// NewPatternSpec wraps g_pattern_spec_new
// 
// see also https://docs.gtk.org/glib/func.g_pattern_spec_new.html
//
func NewPatternSpec(pattern string) *PatternSpec {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GPatternSpec // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pattern_spec_new(carg1)
	runtime.KeepAlive(pattern)

	var goret *PatternSpec

	goret = UnsafePatternSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_pattern_spec_copy
// 
// see also https://docs.gtk.org/glib/method.g_pattern_spec_copy.g_pattern_spec_copy.html
//
func (pspec *PatternSpec) Copy() *PatternSpec {
	var carg0 *C.GPatternSpec // in, none, converted
	var cret  *C.GPatternSpec // return, full, converted

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))

	cret = C.g_pattern_spec_copy(carg0)
	runtime.KeepAlive(pspec)

	var goret *PatternSpec

	goret = UnsafePatternSpecFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Equal wraps g_pattern_spec_equal
// 
// see also https://docs.gtk.org/glib/method.g_pattern_spec_equal.g_pattern_spec_equal.html
//
func (pspec1 *PatternSpec) Equal(pspec2 *PatternSpec) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 *C.GPatternSpec // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec1))
	carg1 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec2))

	cret = C.g_pattern_spec_equal(carg0, carg1)
	runtime.KeepAlive(pspec1)
	runtime.KeepAlive(pspec2)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Match wraps g_pattern_spec_match
// 
// see also https://docs.gtk.org/glib/method.g_pattern_spec_match.g_pattern_spec_match.html
//
func (pspec *PatternSpec) Match(stringLength uint, str string, stringReversed string) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 C.gsize         // in, none, casted
	var carg2 *C.gchar        // in, none, string
	var carg3 *C.gchar        // in, none, string, nullable-string
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))
	carg1 = C.gsize(stringLength)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	if stringReversed != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(stringReversed)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_pattern_spec_match(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(stringLength)
	runtime.KeepAlive(str)
	runtime.KeepAlive(stringReversed)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// MatchString wraps g_pattern_spec_match_string
// 
// see also https://docs.gtk.org/glib/method.g_pattern_spec_match_string.g_pattern_spec_match_string.html
//
func (pspec *PatternSpec) MatchString(str string) bool {
	var carg0 *C.GPatternSpec // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GPatternSpec)(UnsafePatternSpecToGlibNone(pspec))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_pattern_spec_match_string(carg0, carg1)
	runtime.KeepAlive(pspec)
	runtime.KeepAlive(str)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// PollFD wraps GPollFD
// 
// see also https://docs.gtk.org/glib/struct.PollFD.html
//
type PollFD struct {
	*pollFD
}

// pollFD is the struct that's finalized
type pollFD struct {
	native *C.GPollFD
}

// UnsafePollFDToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (p *PollFD) instance() *C.GPollFD {
	if p == nil {
		return nil
	}
	return p.native
}

// UnsafePollFDFromGlibBorrow is used to convert raw C.GPollFD pointers to go. This is used by the bindings internally.
func UnsafePollFDFromGlibBorrow(p unsafe.Pointer) *PollFD {
	if p == nil {
		return nil
	}
	return &PollFD{&pollFD{(*C.GPollFD)(p)}}
}

// UnsafePollFDFromGlibNone is used to convert raw C.GPollFD pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafePollFDFromGlibNone(p unsafe.Pointer) *PollFD {
	wrapped := UnsafePollFDFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to PollFD because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafePollFDFromGlibFull is used to convert raw C.GPollFD pointers to go while taking ownership. This is used by the bindings internally.
func UnsafePollFDFromGlibFull(p unsafe.Pointer) *PollFD {
	wrapped := UnsafePollFDFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.pollFD,
		func (intern *pollFD) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafePollFDFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [PollFD] is expected to work anymore.
func UnsafePollFDFree(p *PollFD) {
	C.free(unsafe.Pointer(p.native))
}

// UnsafePollFDToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafePollFDToGlibNone(p *PollFD) unsafe.Pointer {
	if p == nil {
		return nil
	}
	return unsafe.Pointer(p.native)
}

// UnsafePollFDToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafePollFDToGlibFull(p *PollFD) unsafe.Pointer {
	if p == nil {
		return nil
	}
	runtime.SetFinalizer(p.pollFD, nil)
	_p := unsafe.Pointer(p.native)
	p.native = nil // PollFD is invalid from here on
	return _p
}

// RWLock wraps GRWLock
// 
// see also https://docs.gtk.org/glib/struct.RWLock.html
//
type RWLock struct {
	*rWLock
}

// rWLock is the struct that's finalized
type rWLock struct {
	native *C.GRWLock
}

// UnsafeRWLockToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RWLock) instance() *C.GRWLock {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRWLockFromGlibBorrow is used to convert raw C.GRWLock pointers to go. This is used by the bindings internally.
func UnsafeRWLockFromGlibBorrow(p unsafe.Pointer) *RWLock {
	if p == nil {
		return nil
	}
	return &RWLock{&rWLock{(*C.GRWLock)(p)}}
}

// UnsafeRWLockFromGlibNone is used to convert raw C.GRWLock pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRWLockFromGlibNone(p unsafe.Pointer) *RWLock {
	wrapped := UnsafeRWLockFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RWLock because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRWLockFromGlibFull is used to convert raw C.GRWLock pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRWLockFromGlibFull(p unsafe.Pointer) *RWLock {
	wrapped := UnsafeRWLockFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.rWLock,
		func (intern *rWLock) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRWLockFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RWLock] is expected to work anymore.
func UnsafeRWLockFree(r *RWLock) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRWLockToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRWLockToGlibNone(r *RWLock) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRWLockToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRWLockToGlibFull(r *RWLock) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.rWLock, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RWLock is invalid from here on
	return _p
}

// Clear wraps g_rw_lock_clear
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_clear.g_rw_lock_clear.html
//
func (rwLock *RWLock) Clear() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_clear(carg0)
	runtime.KeepAlive(rwLock)
}

// Init wraps g_rw_lock_init
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_init.g_rw_lock_init.html
//
func (rwLock *RWLock) Init() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_init(carg0)
	runtime.KeepAlive(rwLock)
}

// ReaderLock wraps g_rw_lock_reader_lock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_reader_lock.g_rw_lock_reader_lock.html
//
func (rwLock *RWLock) ReaderLock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_reader_lock(carg0)
	runtime.KeepAlive(rwLock)
}

// ReaderTrylock wraps g_rw_lock_reader_trylock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_reader_trylock.g_rw_lock_reader_trylock.html
//
func (rwLock *RWLock) ReaderTrylock() bool {
	var carg0 *C.GRWLock // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	cret = C.g_rw_lock_reader_trylock(carg0)
	runtime.KeepAlive(rwLock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// ReaderUnlock wraps g_rw_lock_reader_unlock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_reader_unlock.g_rw_lock_reader_unlock.html
//
func (rwLock *RWLock) ReaderUnlock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_reader_unlock(carg0)
	runtime.KeepAlive(rwLock)
}

// WriterLock wraps g_rw_lock_writer_lock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_writer_lock.g_rw_lock_writer_lock.html
//
func (rwLock *RWLock) WriterLock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_writer_lock(carg0)
	runtime.KeepAlive(rwLock)
}

// WriterTrylock wraps g_rw_lock_writer_trylock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_writer_trylock.g_rw_lock_writer_trylock.html
//
func (rwLock *RWLock) WriterTrylock() bool {
	var carg0 *C.GRWLock // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	cret = C.g_rw_lock_writer_trylock(carg0)
	runtime.KeepAlive(rwLock)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// WriterUnlock wraps g_rw_lock_writer_unlock
// 
// see also https://docs.gtk.org/glib/method.g_rw_lock_writer_unlock.g_rw_lock_writer_unlock.html
//
func (rwLock *RWLock) WriterUnlock() {
	var carg0 *C.GRWLock // in, none, converted

	carg0 = (*C.GRWLock)(UnsafeRWLockToGlibNone(rwLock))

	C.g_rw_lock_writer_unlock(carg0)
	runtime.KeepAlive(rwLock)
}

// Rand wraps GRand
// 
// see also https://docs.gtk.org/glib/struct.Rand.html
//
type Rand struct {
	*rand
}

// rand is the struct that's finalized
type rand struct {
	native *C.GRand
}

// UnsafeRandToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *Rand) instance() *C.GRand {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRandFromGlibBorrow is used to convert raw C.GRand pointers to go. This is used by the bindings internally.
func UnsafeRandFromGlibBorrow(p unsafe.Pointer) *Rand {
	if p == nil {
		return nil
	}
	return &Rand{&rand{(*C.GRand)(p)}}
}

// UnsafeRandFromGlibNone is used to convert raw C.GRand pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRandFromGlibNone(p unsafe.Pointer) *Rand {
	wrapped := UnsafeRandFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeRandFromGlibFull is used to convert raw C.GRand pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRandFromGlibFull(p unsafe.Pointer) *Rand {
	wrapped := UnsafeRandFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.rand,
		func (intern *rand) {
			C.g_rand_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeRandFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Rand] is expected to work anymore.
func UnsafeRandFree(r *Rand) {
	C.g_rand_free(r.native)
}

// UnsafeRandToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRandToGlibNone(r *Rand) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRandToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRandToGlibFull(r *Rand) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.rand, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // Rand is invalid from here on
	return _p
}

// NewRand wraps g_rand_new
// 
// see also https://docs.gtk.org/glib/func.g_rand_new.html
//
func NewRand() *Rand {
	var cret *C.GRand // return, full, converted

	cret = C.g_rand_new()

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewRandWithSeed wraps g_rand_new_with_seed
// 
// see also https://docs.gtk.org/glib/func.g_rand_new_with_seed.html
//
func NewRandWithSeed(seed uint32) *Rand {
	var carg1 C.guint32 // in, none, casted
	var cret  *C.GRand  // return, full, converted

	carg1 = C.guint32(seed)

	cret = C.g_rand_new_with_seed(carg1)
	runtime.KeepAlive(seed)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewRandWithSeedArray wraps g_rand_new_with_seed_array
// 
// see also https://docs.gtk.org/glib/func.g_rand_new_with_seed_array.html
//
func NewRandWithSeedArray(seed *uint32, seedLength uint) *Rand {
	var carg1 *C.guint32 // in, transfer: none, C Pointers: 1, Name: guint32
	var carg2 C.guint    // in, none, casted
	var cret  *C.GRand   // return, full, converted

	_ = seed
	_ = carg1
	panic("unimplemented conversion of *uint32 (const guint32*) because of no basic converter found")
	carg2 = C.guint(seedLength)

	cret = C.g_rand_new_with_seed_array(carg1, carg2)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Copy wraps g_rand_copy
// 
// see also https://docs.gtk.org/glib/method.g_rand_copy.g_rand_copy.html
//
func (rand *Rand) Copy() *Rand {
	var carg0 *C.GRand // in, none, converted
	var cret  *C.GRand // return, full, converted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_copy(carg0)
	runtime.KeepAlive(rand)

	var goret *Rand

	goret = UnsafeRandFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Double wraps g_rand_double
// 
// see also https://docs.gtk.org/glib/method.g_rand_double.g_rand_double.html
//
func (rand *Rand) Double() float64 {
	var carg0 *C.GRand  // in, none, converted
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_double(carg0)
	runtime.KeepAlive(rand)

	var goret float64

	goret = float64(cret)

	return goret
}

// DoubleRange wraps g_rand_double_range
// 
// see also https://docs.gtk.org/glib/method.g_rand_double_range.g_rand_double_range.html
//
func (rand *Rand) DoubleRange(begin float64, end float64) float64 {
	var carg0 *C.GRand  // in, none, converted
	var carg1 C.gdouble // in, none, casted
	var carg2 C.gdouble // in, none, casted
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.gdouble(begin)
	carg2 = C.gdouble(end)

	cret = C.g_rand_double_range(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret float64

	goret = float64(cret)

	return goret
}

// Int wraps g_rand_int
// 
// see also https://docs.gtk.org/glib/method.g_rand_int.g_rand_int.html
//
func (rand *Rand) Int() uint32 {
	var carg0 *C.GRand  // in, none, converted
	var cret  C.guint32 // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))

	cret = C.g_rand_int(carg0)
	runtime.KeepAlive(rand)

	var goret uint32

	goret = uint32(cret)

	return goret
}

// IntRange wraps g_rand_int_range
// 
// see also https://docs.gtk.org/glib/method.g_rand_int_range.g_rand_int_range.html
//
func (rand *Rand) IntRange(begin int32, end int32) int32 {
	var carg0 *C.GRand // in, none, converted
	var carg1 C.gint32 // in, none, casted
	var carg2 C.gint32 // in, none, casted
	var cret  C.gint32 // return, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.gint32(begin)
	carg2 = C.gint32(end)

	cret = C.g_rand_int_range(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret int32

	goret = int32(cret)

	return goret
}

// SetSeed wraps g_rand_set_seed
// 
// see also https://docs.gtk.org/glib/method.g_rand_set_seed.g_rand_set_seed.html
//
func (rand *Rand) SetSeed(seed uint32) {
	var carg0 *C.GRand  // in, none, converted
	var carg1 C.guint32 // in, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	carg1 = C.guint32(seed)

	C.g_rand_set_seed(carg0, carg1)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(seed)
}

// SetSeedArray wraps g_rand_set_seed_array
// 
// see also https://docs.gtk.org/glib/method.g_rand_set_seed_array.g_rand_set_seed_array.html
//
func (rand *Rand) SetSeedArray(seed *uint32, seedLength uint) {
	var carg0 *C.GRand   // in, none, converted
	var carg1 *C.guint32 // in, transfer: none, C Pointers: 1, Name: guint32
	var carg2 C.guint    // in, none, casted

	carg0 = (*C.GRand)(UnsafeRandToGlibNone(rand))
	_ = seed
	_ = carg1
	panic("unimplemented conversion of *uint32 (const guint32*) because of no basic converter found")
	carg2 = C.guint(seedLength)

	C.g_rand_set_seed_array(carg0, carg1, carg2)
	runtime.KeepAlive(rand)
	runtime.KeepAlive(seed)
	runtime.KeepAlive(seedLength)
}

// RecMutex wraps GRecMutex
// 
// see also https://docs.gtk.org/glib/struct.RecMutex.html
//
type RecMutex struct {
	*recMutex
}

// recMutex is the struct that's finalized
type recMutex struct {
	native *C.GRecMutex
}

// UnsafeRecMutexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *RecMutex) instance() *C.GRecMutex {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRecMutexFromGlibBorrow is used to convert raw C.GRecMutex pointers to go. This is used by the bindings internally.
func UnsafeRecMutexFromGlibBorrow(p unsafe.Pointer) *RecMutex {
	if p == nil {
		return nil
	}
	return &RecMutex{&recMutex{(*C.GRecMutex)(p)}}
}

// UnsafeRecMutexFromGlibNone is used to convert raw C.GRecMutex pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRecMutexFromGlibNone(p unsafe.Pointer) *RecMutex {
	wrapped := UnsafeRecMutexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to RecMutex because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeRecMutexFromGlibFull is used to convert raw C.GRecMutex pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRecMutexFromGlibFull(p unsafe.Pointer) *RecMutex {
	wrapped := UnsafeRecMutexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.recMutex,
		func (intern *recMutex) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeRecMutexFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [RecMutex] is expected to work anymore.
func UnsafeRecMutexFree(r *RecMutex) {
	C.free(unsafe.Pointer(r.native))
}

// UnsafeRecMutexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRecMutexToGlibNone(r *RecMutex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRecMutexToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRecMutexToGlibFull(r *RecMutex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.recMutex, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // RecMutex is invalid from here on
	return _p
}

// Clear wraps g_rec_mutex_clear
// 
// see also https://docs.gtk.org/glib/method.g_rec_mutex_clear.g_rec_mutex_clear.html
//
func (recMutex *RecMutex) Clear() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_clear(carg0)
	runtime.KeepAlive(recMutex)
}

// Init wraps g_rec_mutex_init
// 
// see also https://docs.gtk.org/glib/method.g_rec_mutex_init.g_rec_mutex_init.html
//
func (recMutex *RecMutex) Init() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_init(carg0)
	runtime.KeepAlive(recMutex)
}

// Lock wraps g_rec_mutex_lock
// 
// see also https://docs.gtk.org/glib/method.g_rec_mutex_lock.g_rec_mutex_lock.html
//
func (recMutex *RecMutex) Lock() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_lock(carg0)
	runtime.KeepAlive(recMutex)
}

// Trylock wraps g_rec_mutex_trylock
// 
// see also https://docs.gtk.org/glib/method.g_rec_mutex_trylock.g_rec_mutex_trylock.html
//
func (recMutex *RecMutex) Trylock() bool {
	var carg0 *C.GRecMutex // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	cret = C.g_rec_mutex_trylock(carg0)
	runtime.KeepAlive(recMutex)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Unlock wraps g_rec_mutex_unlock
// 
// see also https://docs.gtk.org/glib/method.g_rec_mutex_unlock.g_rec_mutex_unlock.html
//
func (recMutex *RecMutex) Unlock() {
	var carg0 *C.GRecMutex // in, none, converted

	carg0 = (*C.GRecMutex)(UnsafeRecMutexToGlibNone(recMutex))

	C.g_rec_mutex_unlock(carg0)
	runtime.KeepAlive(recMutex)
}

// Regex wraps GRegex
// 
// see also https://docs.gtk.org/glib/struct.Regex.html
//
type Regex struct {
	*regex
}

// regex is the struct that's finalized
type regex struct {
	native *C.GRegex
}

// UnsafeRegexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (r *Regex) instance() *C.GRegex {
	if r == nil {
		return nil
	}
	return r.native
}

// UnsafeRegexFromGlibBorrow is used to convert raw C.GRegex pointers to go. This is used by the bindings internally.
func UnsafeRegexFromGlibBorrow(p unsafe.Pointer) *Regex {
	if p == nil {
		return nil
	}
	return &Regex{&regex{(*C.GRegex)(p)}}
}

// UnsafeRegexFromGlibNone is used to convert raw C.GRegex pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeRegexFromGlibNone(p unsafe.Pointer) *Regex {
	C.g_regex_ref((*C.GRegex)(p))
	wrapped := UnsafeRegexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.regex,
		func (intern *regex) {
			C.g_regex_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeRegexFromGlibFull is used to convert raw C.GRegex pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeRegexFromGlibFull(p unsafe.Pointer) *Regex {
	wrapped := UnsafeRegexFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.regex,
		func (intern *regex) {
			C.g_regex_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeRegexRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Regex.UnsafeRegexUnref], then [Regex] will leak memory.
func UnsafeRegexRef(r *Regex) {
	C.g_regex_ref((*C.GRegex)(r.native))
}

// UnsafeRegexUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Regex] is expected to work anymore.
func UnsafeRegexUnref(r *Regex) {
	C.g_regex_unref(r.native)
}

// UnsafeRegexToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeRegexToGlibNone(r *Regex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	return unsafe.Pointer(r.native)
}

// UnsafeRegexToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeRegexToGlibFull(r *Regex) unsafe.Pointer {
	if r == nil {
		return nil
	}
	runtime.SetFinalizer(r.regex, nil)
	_p := unsafe.Pointer(r.native)
	r.native = nil // Regex is invalid from here on
	return _p
}

// NewRegex wraps g_regex_new
// 
// see also https://docs.gtk.org/glib/func.g_regex_new.html
//
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var carg1 *C.gchar             // in, none, string
	var carg2 C.GRegexCompileFlags // in, none, casted
	var carg3 C.GRegexMatchFlags   // in, none, casted
	var cret  *C.GRegex            // return, full, converted, nullable
	var _cerr *C.GError            // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexCompileFlags(compileOptions)
	carg3 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_new(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret  *Regex
	var _goerr error

	if cret != nil {
		goret = UnsafeRegexFromGlibFull(unsafe.Pointer(cret))
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// RegexCheckReplacement wraps g_regex_check_replacement
// 
// see also https://docs.gtk.org/glib/func.g_regex_check_replacement.html
//
func RegexCheckReplacement(replacement string) (bool, bool, error) {
	var carg1 *C.gchar   // in, none, string
	var carg2 C.gboolean // out
	var cret  C.gboolean // return
	var _cerr *C.GError  // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_regex_check_replacement(carg1, &carg2, &_cerr)
	runtime.KeepAlive(replacement)

	var hasReferences bool
	var goret         bool
	var _goerr        error

	if carg2 != 0 {
		hasReferences = true
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return hasReferences, goret, _goerr
}

// RegexErrorQuark wraps g_regex_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_regex_error_quark.html
func RegexErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_regex_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// RegexEscapeNul wraps g_regex_escape_nul
// 
// see also https://docs.gtk.org/glib/func.g_regex_escape_nul.html
//
func RegexEscapeNul(str string, length int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(length)

	cret = C.g_regex_escape_nul(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegexEscapeString wraps g_regex_escape_string
// 
// see also https://docs.gtk.org/glib/func.g_regex_escape_string.html
//
func RegexEscapeString(str string, length int32) string {
	var carg1 *C.gchar // in, none, string
	var carg2 C.gint   // in, none, casted
	var cret  *C.gchar // return, full, string

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gint(length)

	cret = C.g_regex_escape_string(carg1, carg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// RegexMatchSimple wraps g_regex_match_simple
// 
// see also https://docs.gtk.org/glib/func.g_regex_match_simple.html
//
func RegexMatchSimple(pattern string, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 C.GRegexCompileFlags // in, none, casted
	var carg4 C.GRegexMatchFlags   // in, none, casted
	var cret  C.gboolean           // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GRegexCompileFlags(compileOptions)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_simple(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// RegexSplitSimple wraps g_regex_split_simple
// 
// see also https://docs.gtk.org/glib/func.g_regex_split_simple.html
//
func RegexSplitSimple(pattern string, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var carg1 *C.gchar             // in, none, string
	var carg2 *C.gchar             // in, none, string
	var carg3 C.GRegexCompileFlags // in, none, casted
	var carg4 C.GRegexMatchFlags   // in, none, casted
	var cret  **C.gchar            // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GRegexCompileFlags(compileOptions)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_split_simple(carg1, carg2, carg3, carg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// GetCaptureCount wraps g_regex_get_capture_count
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_capture_count.g_regex_get_capture_count.html
//
func (regex *Regex) GetCaptureCount() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_capture_count(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetCompileFlags wraps g_regex_get_compile_flags
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_compile_flags.g_regex_get_compile_flags.html
//
func (regex *Regex) GetCompileFlags() RegexCompileFlags {
	var carg0 *C.GRegex            // in, none, converted
	var cret  C.GRegexCompileFlags // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_compile_flags(carg0)
	runtime.KeepAlive(regex)

	var goret RegexCompileFlags

	goret = RegexCompileFlags(cret)

	return goret
}

// GetHasCrOrLf wraps g_regex_get_has_cr_or_lf
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_has_cr_or_lf.g_regex_get_has_cr_or_lf.html
//
func (regex *Regex) GetHasCrOrLf() bool {
	var carg0 *C.GRegex  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_has_cr_or_lf(carg0)
	runtime.KeepAlive(regex)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetMatchFlags wraps g_regex_get_match_flags
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_match_flags.g_regex_get_match_flags.html
//
func (regex *Regex) GetMatchFlags() RegexMatchFlags {
	var carg0 *C.GRegex          // in, none, converted
	var cret  C.GRegexMatchFlags // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_match_flags(carg0)
	runtime.KeepAlive(regex)

	var goret RegexMatchFlags

	goret = RegexMatchFlags(cret)

	return goret
}

// GetMaxBackref wraps g_regex_get_max_backref
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_max_backref.g_regex_get_max_backref.html
//
func (regex *Regex) GetMaxBackref() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_max_backref(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetMaxLookbehind wraps g_regex_get_max_lookbehind
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_max_lookbehind.g_regex_get_max_lookbehind.html
//
func (regex *Regex) GetMaxLookbehind() int32 {
	var carg0 *C.GRegex // in, none, converted
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_max_lookbehind(carg0)
	runtime.KeepAlive(regex)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetPattern wraps g_regex_get_pattern
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_pattern.g_regex_get_pattern.html
//
func (regex *Regex) GetPattern() string {
	var carg0 *C.GRegex // in, none, converted
	var cret  *C.gchar  // return, none, string

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))

	cret = C.g_regex_get_pattern(carg0)
	runtime.KeepAlive(regex)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetStringNumber wraps g_regex_get_string_number
// 
// see also https://docs.gtk.org/glib/method.g_regex_get_string_number.g_regex_get_string_number.html
//
func (regex *Regex) GetStringNumber(name string) int32 {
	var carg0 *C.GRegex // in, none, converted
	var carg1 *C.gchar  // in, none, string
	var cret  C.gint    // return, none, casted

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_regex_get_string_number(carg0, carg1)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(name)

	var goret int32

	goret = int32(cret)

	return goret
}

// Match wraps g_regex_match
// 
// see also https://docs.gtk.org/glib/method.g_regex_match.g_regex_match.html
//
func (regex *Regex) Match(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var carg3 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match(carg0, carg1, carg2, &carg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return matchInfo, goret
}

// MatchAll wraps g_regex_match_all
// 
// see also https://docs.gtk.org/glib/method.g_regex_match_all.g_regex_match_all.html
//
func (regex *Regex) MatchAll(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var carg3 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_all(carg0, carg1, carg2, &carg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return matchInfo, goret
}

// MatchAllFull wraps g_regex_match_all_full
// 
// see also https://docs.gtk.org/glib/method.g_regex_match_all_full.g_regex_match_all_full.html
//
func (regex *Regex) MatchAllFull(str string, startPosition int32, matchOptions RegexMatchFlags) (*MatchInfo, bool, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_all_full(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool
	var _goerr    error

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return matchInfo, goret, _goerr
}

// MatchFull wraps g_regex_match_full
// 
// see also https://docs.gtk.org/glib/method.g_regex_match_full.g_regex_match_full.html
//
func (regex *Regex) MatchFull(str string, startPosition int32, matchOptions RegexMatchFlags) (*MatchInfo, bool, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 *C.GMatchInfo      // out, full, converted
	var cret  C.gboolean         // return
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_match_full(carg0, carg1, carg2, carg3, carg4, &carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)

	var matchInfo *MatchInfo
	var goret     bool
	var _goerr    error

	matchInfo = UnsafeMatchInfoFromGlibFull(unsafe.Pointer(carg5))
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return matchInfo, goret, _goerr
}

// Replace wraps g_regex_replace
// 
// see also https://docs.gtk.org/glib/method.g_regex_replace.g_regex_replace.html
//
func (regex *Regex) Replace(str string, startPosition int32, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 *C.gchar           // in, none, string
	var carg5 C.GRegexMatchFlags // in, none, casted
	var cret  *C.gchar           // return, full, string
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_replace(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(replacement)
	runtime.KeepAlive(matchOptions)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// ReplaceLiteral wraps g_regex_replace_literal
// 
// see also https://docs.gtk.org/glib/method.g_regex_replace_literal.g_regex_replace_literal.html
//
func (regex *Regex) ReplaceLiteral(str string, startPosition int32, replacement string, matchOptions RegexMatchFlags) (string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 *C.gchar           // in, none, string
	var carg5 C.GRegexMatchFlags // in, none, casted
	var cret  *C.gchar           // return, full, string
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_replace_literal(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(replacement)
	runtime.KeepAlive(matchOptions)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Split wraps g_regex_split
// 
// see also https://docs.gtk.org/glib/method.g_regex_split.g_regex_split.html
//
func (regex *Regex) Split(str string, matchOptions RegexMatchFlags) []string {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, none, string
	var carg2 C.GRegexMatchFlags // in, none, casted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GRegexMatchFlags(matchOptions)

	cret = C.g_regex_split(carg0, carg1, carg2)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// SplitFull wraps g_regex_split_full
// 
// see also https://docs.gtk.org/glib/method.g_regex_split_full.g_regex_split_full.html
//
func (regex *Regex) SplitFull(str string, startPosition int32, matchOptions RegexMatchFlags, maxTokens int32) ([]string, error) {
	var carg0 *C.GRegex          // in, none, converted
	var carg1 *C.gchar           // in, transfer: none, C Pointers: 1, Name: array[unknown], array (inner unknown, length-by: carg2)
	var carg2 C.gssize           // implicit
	var carg3 C.gint             // in, none, casted
	var carg4 C.GRegexMatchFlags // in, none, casted
	var carg5 C.gint             // in, none, casted
	var cret  **C.gchar          // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)
	var _cerr *C.GError          // out, full, converted, nullable

	carg0 = (*C.GRegex)(UnsafeRegexToGlibNone(regex))
	_ = str
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of string (const gchar*) because of unimplemented: non-fixed size array")
	carg3 = C.gint(startPosition)
	carg4 = C.GRegexMatchFlags(matchOptions)
	carg5 = C.gint(maxTokens)

	cret = C.g_regex_split_full(carg0, carg1, carg2, carg3, carg4, carg5, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPosition)
	runtime.KeepAlive(matchOptions)
	runtime.KeepAlive(maxTokens)

	var goret  []string
	var _goerr error

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// Scanner wraps GScanner
// 
// see also https://docs.gtk.org/glib/struct.Scanner.html
//
type Scanner struct {
	*scanner
}

// scanner is the struct that's finalized
type scanner struct {
	native *C.GScanner
}

// UnsafeScannerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *Scanner) instance() *C.GScanner {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeScannerFromGlibBorrow is used to convert raw C.GScanner pointers to go. This is used by the bindings internally.
func UnsafeScannerFromGlibBorrow(p unsafe.Pointer) *Scanner {
	if p == nil {
		return nil
	}
	return &Scanner{&scanner{(*C.GScanner)(p)}}
}

// UnsafeScannerFromGlibNone is used to convert raw C.GScanner pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeScannerFromGlibNone(p unsafe.Pointer) *Scanner {
	wrapped := UnsafeScannerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Scanner because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeScannerFromGlibFull is used to convert raw C.GScanner pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeScannerFromGlibFull(p unsafe.Pointer) *Scanner {
	wrapped := UnsafeScannerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.scanner,
		func (intern *scanner) {
			C.g_scanner_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeScannerDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Scanner] is expected to work anymore.
func UnsafeScannerDestroy(s *Scanner) {
	C.g_scanner_destroy(s.native)
}

// UnsafeScannerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeScannerToGlibNone(s *Scanner) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeScannerToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeScannerToGlibFull(s *Scanner) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.scanner, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // Scanner is invalid from here on
	return _p
}

// CurLine wraps g_scanner_cur_line
// 
// see also https://docs.gtk.org/glib/method.g_scanner_cur_line.g_scanner_cur_line.html
//
func (scanner *Scanner) CurLine() uint {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_line(carg0)
	runtime.KeepAlive(scanner)

	var goret uint

	goret = uint(cret)

	return goret
}

// CurPosition wraps g_scanner_cur_position
// 
// see also https://docs.gtk.org/glib/method.g_scanner_cur_position.g_scanner_cur_position.html
//
func (scanner *Scanner) CurPosition() uint {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_position(carg0)
	runtime.KeepAlive(scanner)

	var goret uint

	goret = uint(cret)

	return goret
}

// CurToken wraps g_scanner_cur_token
// 
// see also https://docs.gtk.org/glib/method.g_scanner_cur_token.g_scanner_cur_token.html
//
func (scanner *Scanner) CurToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_cur_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// EOF wraps g_scanner_eof
// 
// see also https://docs.gtk.org/glib/method.g_scanner_eof.g_scanner_eof.html
//
func (scanner *Scanner) EOF() bool {
	var carg0 *C.GScanner // in, none, converted
	var cret  C.gboolean  // return

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_eof(carg0)
	runtime.KeepAlive(scanner)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// GetNextToken wraps g_scanner_get_next_token
// 
// see also https://docs.gtk.org/glib/method.g_scanner_get_next_token.g_scanner_get_next_token.html
//
func (scanner *Scanner) GetNextToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_get_next_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// InputFile wraps g_scanner_input_file
// 
// see also https://docs.gtk.org/glib/method.g_scanner_input_file.g_scanner_input_file.html
//
func (scanner *Scanner) InputFile(inputFd int32) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.gint      // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.gint(inputFd)

	C.g_scanner_input_file(carg0, carg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(inputFd)
}

// InputText wraps g_scanner_input_text
// 
// see also https://docs.gtk.org/glib/method.g_scanner_input_text.g_scanner_input_text.html
//
func (scanner *Scanner) InputText(text string, textLen uint) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.guint     // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.guint(textLen)

	C.g_scanner_input_text(carg0, carg1, carg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(text)
	runtime.KeepAlive(textLen)
}

// PeekNextToken wraps g_scanner_peek_next_token
// 
// see also https://docs.gtk.org/glib/method.g_scanner_peek_next_token.g_scanner_peek_next_token.html
//
func (scanner *Scanner) PeekNextToken() TokenType {
	var carg0 *C.GScanner  // in, none, converted
	var cret  C.GTokenType // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	cret = C.g_scanner_peek_next_token(carg0)
	runtime.KeepAlive(scanner)

	var goret TokenType

	goret = TokenType(cret)

	return goret
}

// ScopeRemoveSymbol wraps g_scanner_scope_remove_symbol
// 
// see also https://docs.gtk.org/glib/method.g_scanner_scope_remove_symbol.g_scanner_scope_remove_symbol.html
//
func (scanner *Scanner) ScopeRemoveSymbol(scopeId uint, symbol string) {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.guint     // in, none, casted
	var carg2 *C.gchar    // in, none, string

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.guint(scopeId)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(carg2))

	C.g_scanner_scope_remove_symbol(carg0, carg1, carg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
}

// SetScope wraps g_scanner_set_scope
// 
// see also https://docs.gtk.org/glib/method.g_scanner_set_scope.g_scanner_set_scope.html
//
func (scanner *Scanner) SetScope(scopeId uint) uint {
	var carg0 *C.GScanner // in, none, converted
	var carg1 C.guint     // in, none, casted
	var cret  C.guint     // return, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.guint(scopeId)

	cret = C.g_scanner_set_scope(carg0, carg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)

	var goret uint

	goret = uint(cret)

	return goret
}

// SyncFileOffset wraps g_scanner_sync_file_offset
// 
// see also https://docs.gtk.org/glib/method.g_scanner_sync_file_offset.g_scanner_sync_file_offset.html
//
func (scanner *Scanner) SyncFileOffset() {
	var carg0 *C.GScanner // in, none, converted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))

	C.g_scanner_sync_file_offset(carg0)
	runtime.KeepAlive(scanner)
}

// UnexpToken wraps g_scanner_unexp_token
// 
// see also https://docs.gtk.org/glib/method.g_scanner_unexp_token.g_scanner_unexp_token.html
//
func (scanner *Scanner) UnexpToken(expectedToken TokenType, identifierSpec string, symbolSpec string, symbolName string, message string, isError int32) {
	var carg0 *C.GScanner  // in, none, converted
	var carg1 C.GTokenType // in, none, casted
	var carg2 *C.gchar     // in, none, string
	var carg3 *C.gchar     // in, none, string
	var carg4 *C.gchar     // in, none, string
	var carg5 *C.gchar     // in, none, string
	var carg6 C.gint       // in, none, casted

	carg0 = (*C.GScanner)(UnsafeScannerToGlibNone(scanner))
	carg1 = C.GTokenType(expectedToken)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(identifierSpec)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(symbolSpec)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = (*C.gchar)(unsafe.Pointer(C.CString(symbolName)))
	defer C.free(unsafe.Pointer(carg4))
	carg5 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(carg5))
	carg6 = C.gint(isError)

	C.g_scanner_unexp_token(carg0, carg1, carg2, carg3, carg4, carg5, carg6)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(expectedToken)
	runtime.KeepAlive(identifierSpec)
	runtime.KeepAlive(symbolSpec)
	runtime.KeepAlive(symbolName)
	runtime.KeepAlive(message)
	runtime.KeepAlive(isError)
}

// ScannerConfig wraps GScannerConfig
// 
// see also https://docs.gtk.org/glib/struct.ScannerConfig.html
//
type ScannerConfig struct {
	*scannerConfig
}

// scannerConfig is the struct that's finalized
type scannerConfig struct {
	native *C.GScannerConfig
}

// UnsafeScannerConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *ScannerConfig) instance() *C.GScannerConfig {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeScannerConfigFromGlibBorrow is used to convert raw C.GScannerConfig pointers to go. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibBorrow(p unsafe.Pointer) *ScannerConfig {
	if p == nil {
		return nil
	}
	return &ScannerConfig{&scannerConfig{(*C.GScannerConfig)(p)}}
}

// UnsafeScannerConfigFromGlibNone is used to convert raw C.GScannerConfig pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibNone(p unsafe.Pointer) *ScannerConfig {
	wrapped := UnsafeScannerConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to ScannerConfig because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeScannerConfigFromGlibFull is used to convert raw C.GScannerConfig pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeScannerConfigFromGlibFull(p unsafe.Pointer) *ScannerConfig {
	wrapped := UnsafeScannerConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.scannerConfig,
		func (intern *scannerConfig) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeScannerConfigFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [ScannerConfig] is expected to work anymore.
func UnsafeScannerConfigFree(s *ScannerConfig) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeScannerConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeScannerConfigToGlibNone(s *ScannerConfig) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeScannerConfigToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeScannerConfigToGlibFull(s *ScannerConfig) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.scannerConfig, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // ScannerConfig is invalid from here on
	return _p
}

// Sequence wraps GSequence
// 
// see also https://docs.gtk.org/glib/struct.Sequence.html
//
type Sequence struct {
	*sequence
}

// sequence is the struct that's finalized
type sequence struct {
	native *C.GSequence
}

// UnsafeSequenceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *Sequence) instance() *C.GSequence {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSequenceFromGlibBorrow is used to convert raw C.GSequence pointers to go. This is used by the bindings internally.
func UnsafeSequenceFromGlibBorrow(p unsafe.Pointer) *Sequence {
	if p == nil {
		return nil
	}
	return &Sequence{&sequence{(*C.GSequence)(p)}}
}

// UnsafeSequenceFromGlibNone is used to convert raw C.GSequence pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSequenceFromGlibNone(p unsafe.Pointer) *Sequence {
	wrapped := UnsafeSequenceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Sequence because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSequenceFromGlibFull is used to convert raw C.GSequence pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSequenceFromGlibFull(p unsafe.Pointer) *Sequence {
	wrapped := UnsafeSequenceFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sequence,
		func (intern *sequence) {
			C.g_sequence_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeSequenceFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Sequence] is expected to work anymore.
func UnsafeSequenceFree(s *Sequence) {
	C.g_sequence_free(s.native)
}

// UnsafeSequenceToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSequenceToGlibNone(s *Sequence) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSequenceToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSequenceToGlibFull(s *Sequence) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sequence, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // Sequence is invalid from here on
	return _p
}

// SequenceMove wraps g_sequence_move
// 
// see also https://docs.gtk.org/glib/func.g_sequence_move.html
//
func SequenceMove(src *SequenceIter, dest *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(src))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(dest))

	C.g_sequence_move(carg1, carg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// SequenceMoveRange wraps g_sequence_move_range
// 
// see also https://docs.gtk.org/glib/func.g_sequence_move_range.html
//
func SequenceMoveRange(dest *SequenceIter, begin *SequenceIter, end *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted
	var carg3 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(dest))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg3 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	C.g_sequence_move_range(carg1, carg2, carg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)
}

// SequenceRangeGetMidpoint wraps g_sequence_range_get_midpoint
// 
// see also https://docs.gtk.org/glib/func.g_sequence_range_get_midpoint.html
//
func SequenceRangeGetMidpoint(begin *SequenceIter, end *SequenceIter) *SequenceIter {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	cret = C.g_sequence_range_get_midpoint(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SequenceRemove wraps g_sequence_remove
// 
// see also https://docs.gtk.org/glib/func.g_sequence_remove.html
//
func SequenceRemove(iter *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	C.g_sequence_remove(carg1)
	runtime.KeepAlive(iter)
}

// SequenceRemoveRange wraps g_sequence_remove_range
// 
// see also https://docs.gtk.org/glib/func.g_sequence_remove_range.html
//
func SequenceRemoveRange(begin *SequenceIter, end *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(begin))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(end))

	C.g_sequence_remove_range(carg1, carg2)
	runtime.KeepAlive(begin)
	runtime.KeepAlive(end)
}

// SequenceSwap wraps g_sequence_swap
// 
// see also https://docs.gtk.org/glib/func.g_sequence_swap.html
//
func SequenceSwap(a *SequenceIter, b *SequenceIter) {
	var carg1 *C.GSequenceIter // in, none, converted
	var carg2 *C.GSequenceIter // in, none, converted

	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(a))
	carg2 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(b))

	C.g_sequence_swap(carg1, carg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)
}

// GetBeginIter wraps g_sequence_get_begin_iter
// 
// see also https://docs.gtk.org/glib/method.g_sequence_get_begin_iter.g_sequence_get_begin_iter.html
//
func (seq *Sequence) GetBeginIter() *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_begin_iter(carg0)
	runtime.KeepAlive(seq)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetEndIter wraps g_sequence_get_end_iter
// 
// see also https://docs.gtk.org/glib/method.g_sequence_get_end_iter.g_sequence_get_end_iter.html
//
func (seq *Sequence) GetEndIter() *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_end_iter(carg0)
	runtime.KeepAlive(seq)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetIterAtPos wraps g_sequence_get_iter_at_pos
// 
// see also https://docs.gtk.org/glib/method.g_sequence_get_iter_at_pos.g_sequence_get_iter_at_pos.html
//
func (seq *Sequence) GetIterAtPos(pos int32) *SequenceIter {
	var carg0 *C.GSequence     // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))
	carg1 = C.gint(pos)

	cret = C.g_sequence_get_iter_at_pos(carg0, carg1)
	runtime.KeepAlive(seq)
	runtime.KeepAlive(pos)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// GetLength wraps g_sequence_get_length
// 
// see also https://docs.gtk.org/glib/method.g_sequence_get_length.g_sequence_get_length.html
//
func (seq *Sequence) GetLength() int32 {
	var carg0 *C.GSequence // in, none, converted
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_get_length(carg0)
	runtime.KeepAlive(seq)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsEmpty wraps g_sequence_is_empty
// 
// see also https://docs.gtk.org/glib/method.g_sequence_is_empty.g_sequence_is_empty.html
//
func (seq *Sequence) IsEmpty() bool {
	var carg0 *C.GSequence // in, none, converted
	var cret  C.gboolean   // return

	carg0 = (*C.GSequence)(UnsafeSequenceToGlibNone(seq))

	cret = C.g_sequence_is_empty(carg0)
	runtime.KeepAlive(seq)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// SequenceIter wraps GSequenceIter
// 
// see also https://docs.gtk.org/glib/struct.SequenceIter.html
//
type SequenceIter struct {
	*sequenceIter
}

// sequenceIter is the struct that's finalized
type sequenceIter struct {
	native *C.GSequenceIter
}

// UnsafeSequenceIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SequenceIter) instance() *C.GSequenceIter {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSequenceIterFromGlibBorrow is used to convert raw C.GSequenceIter pointers to go. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibBorrow(p unsafe.Pointer) *SequenceIter {
	if p == nil {
		return nil
	}
	return &SequenceIter{&sequenceIter{(*C.GSequenceIter)(p)}}
}

// UnsafeSequenceIterFromGlibNone is used to convert raw C.GSequenceIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibNone(p unsafe.Pointer) *SequenceIter {
	wrapped := UnsafeSequenceIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SequenceIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSequenceIterFromGlibFull is used to convert raw C.GSequenceIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSequenceIterFromGlibFull(p unsafe.Pointer) *SequenceIter {
	wrapped := UnsafeSequenceIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sequenceIter,
		func (intern *sequenceIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSequenceIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SequenceIter] is expected to work anymore.
func UnsafeSequenceIterFree(s *SequenceIter) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSequenceIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSequenceIterToGlibNone(s *SequenceIter) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSequenceIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSequenceIterToGlibFull(s *SequenceIter) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sequenceIter, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SequenceIter is invalid from here on
	return _p
}

// Compare wraps g_sequence_iter_compare
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_compare.g_sequence_iter_compare.html
//
func (a *SequenceIter) Compare(b *SequenceIter) int32 {
	var carg0 *C.GSequenceIter // in, none, converted
	var carg1 *C.GSequenceIter // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(a))
	carg1 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(b))

	cret = C.g_sequence_iter_compare(carg0, carg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetPosition wraps g_sequence_iter_get_position
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_get_position.g_sequence_iter_get_position.html
//
func (iter *SequenceIter) GetPosition() int32 {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gint           // return, none, casted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_get_position(carg0)
	runtime.KeepAlive(iter)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetSequence wraps g_sequence_iter_get_sequence
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_get_sequence.g_sequence_iter_get_sequence.html
//
func (iter *SequenceIter) GetSequence() *Sequence {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequence     // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_get_sequence(carg0)
	runtime.KeepAlive(iter)

	var goret *Sequence

	goret = UnsafeSequenceFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// IsBegin wraps g_sequence_iter_is_begin
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_is_begin.g_sequence_iter_is_begin.html
//
func (iter *SequenceIter) IsBegin() bool {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_is_begin(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsEnd wraps g_sequence_iter_is_end
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_is_end.g_sequence_iter_is_end.html
//
func (iter *SequenceIter) IsEnd() bool {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  C.gboolean       // return

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_is_end(carg0)
	runtime.KeepAlive(iter)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Move wraps g_sequence_iter_move
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_move.g_sequence_iter_move.html
//
func (iter *SequenceIter) Move(delta int32) *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var carg1 C.gint           // in, none, casted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))
	carg1 = C.gint(delta)

	cret = C.g_sequence_iter_move(carg0, carg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(delta)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Next wraps g_sequence_iter_next
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_next.g_sequence_iter_next.html
//
func (iter *SequenceIter) Next() *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_next(carg0)
	runtime.KeepAlive(iter)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// Prev wraps g_sequence_iter_prev
// 
// see also https://docs.gtk.org/glib/method.g_sequence_iter_prev.g_sequence_iter_prev.html
//
func (iter *SequenceIter) Prev() *SequenceIter {
	var carg0 *C.GSequenceIter // in, none, converted
	var cret  *C.GSequenceIter // return, none, converted

	carg0 = (*C.GSequenceIter)(UnsafeSequenceIterToGlibNone(iter))

	cret = C.g_sequence_iter_prev(carg0)
	runtime.KeepAlive(iter)

	var goret *SequenceIter

	goret = UnsafeSequenceIterFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// SourceCallbackFuncs wraps GSourceCallbackFuncs
// 
// see also https://docs.gtk.org/glib/struct.SourceCallbackFuncs.html
//
type SourceCallbackFuncs struct {
	*sourceCallbackFuncs
}

// sourceCallbackFuncs is the struct that's finalized
type sourceCallbackFuncs struct {
	native *C.GSourceCallbackFuncs
}

// UnsafeSourceCallbackFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SourceCallbackFuncs) instance() *C.GSourceCallbackFuncs {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSourceCallbackFuncsFromGlibBorrow is used to convert raw C.GSourceCallbackFuncs pointers to go. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibBorrow(p unsafe.Pointer) *SourceCallbackFuncs {
	if p == nil {
		return nil
	}
	return &SourceCallbackFuncs{&sourceCallbackFuncs{(*C.GSourceCallbackFuncs)(p)}}
}

// UnsafeSourceCallbackFuncsFromGlibNone is used to convert raw C.GSourceCallbackFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibNone(p unsafe.Pointer) *SourceCallbackFuncs {
	wrapped := UnsafeSourceCallbackFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SourceCallbackFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSourceCallbackFuncsFromGlibFull is used to convert raw C.GSourceCallbackFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsFromGlibFull(p unsafe.Pointer) *SourceCallbackFuncs {
	wrapped := UnsafeSourceCallbackFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sourceCallbackFuncs,
		func (intern *sourceCallbackFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSourceCallbackFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SourceCallbackFuncs] is expected to work anymore.
func UnsafeSourceCallbackFuncsFree(s *SourceCallbackFuncs) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSourceCallbackFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSourceCallbackFuncsToGlibNone(s *SourceCallbackFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSourceCallbackFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSourceCallbackFuncsToGlibFull(s *SourceCallbackFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sourceCallbackFuncs, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SourceCallbackFuncs is invalid from here on
	return _p
}

// SourceFuncs wraps GSourceFuncs
// 
// see also https://docs.gtk.org/glib/struct.SourceFuncs.html
//
type SourceFuncs struct {
	*sourceFuncs
}

// sourceFuncs is the struct that's finalized
type sourceFuncs struct {
	native *C.GSourceFuncs
}

// UnsafeSourceFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *SourceFuncs) instance() *C.GSourceFuncs {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeSourceFuncsFromGlibBorrow is used to convert raw C.GSourceFuncs pointers to go. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibBorrow(p unsafe.Pointer) *SourceFuncs {
	if p == nil {
		return nil
	}
	return &SourceFuncs{&sourceFuncs{(*C.GSourceFuncs)(p)}}
}

// UnsafeSourceFuncsFromGlibNone is used to convert raw C.GSourceFuncs pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibNone(p unsafe.Pointer) *SourceFuncs {
	wrapped := UnsafeSourceFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to SourceFuncs because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeSourceFuncsFromGlibFull is used to convert raw C.GSourceFuncs pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeSourceFuncsFromGlibFull(p unsafe.Pointer) *SourceFuncs {
	wrapped := UnsafeSourceFuncsFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.sourceFuncs,
		func (intern *sourceFuncs) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeSourceFuncsFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [SourceFuncs] is expected to work anymore.
func UnsafeSourceFuncsFree(s *SourceFuncs) {
	C.free(unsafe.Pointer(s.native))
}

// UnsafeSourceFuncsToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeSourceFuncsToGlibNone(s *SourceFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeSourceFuncsToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeSourceFuncsToGlibFull(s *SourceFuncs) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.sourceFuncs, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // SourceFuncs is invalid from here on
	return _p
}

// StringChunk wraps GStringChunk
// 
// see also https://docs.gtk.org/glib/struct.StringChunk.html
//
type StringChunk struct {
	*stringChunk
}

// stringChunk is the struct that's finalized
type stringChunk struct {
	native *C.GStringChunk
}

// UnsafeStringChunkToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StringChunk) instance() *C.GStringChunk {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStringChunkFromGlibBorrow is used to convert raw C.GStringChunk pointers to go. This is used by the bindings internally.
func UnsafeStringChunkFromGlibBorrow(p unsafe.Pointer) *StringChunk {
	if p == nil {
		return nil
	}
	return &StringChunk{&stringChunk{(*C.GStringChunk)(p)}}
}

// UnsafeStringChunkFromGlibNone is used to convert raw C.GStringChunk pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStringChunkFromGlibNone(p unsafe.Pointer) *StringChunk {
	wrapped := UnsafeStringChunkFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to StringChunk because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeStringChunkFromGlibFull is used to convert raw C.GStringChunk pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStringChunkFromGlibFull(p unsafe.Pointer) *StringChunk {
	wrapped := UnsafeStringChunkFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.stringChunk,
		func (intern *stringChunk) {
			C.g_string_chunk_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeStringChunkFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StringChunk] is expected to work anymore.
func UnsafeStringChunkFree(s *StringChunk) {
	C.g_string_chunk_free(s.native)
}

// UnsafeStringChunkToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStringChunkToGlibNone(s *StringChunk) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStringChunkToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStringChunkToGlibFull(s *StringChunk) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.stringChunk, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StringChunk is invalid from here on
	return _p
}

// Clear wraps g_string_chunk_clear
// 
// see also https://docs.gtk.org/glib/method.g_string_chunk_clear.g_string_chunk_clear.html
//
func (chunk *StringChunk) Clear() {
	var carg0 *C.GStringChunk // in, none, converted

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))

	C.g_string_chunk_clear(carg0)
	runtime.KeepAlive(chunk)
}

// Insert wraps g_string_chunk_insert
// 
// see also https://docs.gtk.org/glib/method.g_string_chunk_insert.g_string_chunk_insert.html
//
func (chunk *StringChunk) Insert(str string) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_string_chunk_insert(carg0, carg1)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InsertConst wraps g_string_chunk_insert_const
// 
// see also https://docs.gtk.org/glib/method.g_string_chunk_insert_const.g_string_chunk_insert_const.html
//
func (chunk *StringChunk) InsertConst(str string) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_string_chunk_insert_const(carg0, carg1)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// InsertLen wraps g_string_chunk_insert_len
// 
// see also https://docs.gtk.org/glib/method.g_string_chunk_insert_len.g_string_chunk_insert_len.html
//
func (chunk *StringChunk) InsertLen(str string, len int) string {
	var carg0 *C.GStringChunk // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var carg2 C.gssize        // in, none, casted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GStringChunk)(UnsafeStringChunkToGlibNone(chunk))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(len)

	cret = C.g_string_chunk_insert_len(carg0, carg1, carg2)
	runtime.KeepAlive(chunk)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// StrvBuilder wraps GStrvBuilder
// 
// see also https://docs.gtk.org/glib/struct.StrvBuilder.html
//
type StrvBuilder struct {
	*strvBuilder
}

// strvBuilder is the struct that's finalized
type strvBuilder struct {
	native *C.GStrvBuilder
}

// UnsafeStrvBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (s *StrvBuilder) instance() *C.GStrvBuilder {
	if s == nil {
		return nil
	}
	return s.native
}

// UnsafeStrvBuilderFromGlibBorrow is used to convert raw C.GStrvBuilder pointers to go. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibBorrow(p unsafe.Pointer) *StrvBuilder {
	if p == nil {
		return nil
	}
	return &StrvBuilder{&strvBuilder{(*C.GStrvBuilder)(p)}}
}

// UnsafeStrvBuilderFromGlibNone is used to convert raw C.GStrvBuilder pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibNone(p unsafe.Pointer) *StrvBuilder {
	C.g_strv_builder_ref((*C.GStrvBuilder)(p))
	wrapped := UnsafeStrvBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.strvBuilder,
		func (intern *strvBuilder) {
			C.g_strv_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeStrvBuilderFromGlibFull is used to convert raw C.GStrvBuilder pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeStrvBuilderFromGlibFull(p unsafe.Pointer) *StrvBuilder {
	wrapped := UnsafeStrvBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.strvBuilder,
		func (intern *strvBuilder) {
			C.g_strv_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeStrvBuilderRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [StrvBuilder.UnsafeStrvBuilderUnref], then [StrvBuilder] will leak memory.
func UnsafeStrvBuilderRef(s *StrvBuilder) {
	C.g_strv_builder_ref((*C.GStrvBuilder)(s.native))
}

// UnsafeStrvBuilderUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [StrvBuilder] is expected to work anymore.
func UnsafeStrvBuilderUnref(s *StrvBuilder) {
	C.g_strv_builder_unref(s.native)
}

// UnsafeStrvBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeStrvBuilderToGlibNone(s *StrvBuilder) unsafe.Pointer {
	if s == nil {
		return nil
	}
	return unsafe.Pointer(s.native)
}

// UnsafeStrvBuilderToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeStrvBuilderToGlibFull(s *StrvBuilder) unsafe.Pointer {
	if s == nil {
		return nil
	}
	runtime.SetFinalizer(s.strvBuilder, nil)
	_p := unsafe.Pointer(s.native)
	s.native = nil // StrvBuilder is invalid from here on
	return _p
}

// NewStrvBuilder wraps g_strv_builder_new
// 
// see also https://docs.gtk.org/glib/func.g_strv_builder_new.html
//
func NewStrvBuilder() *StrvBuilder {
	var cret *C.GStrvBuilder // return, full, converted

	cret = C.g_strv_builder_new()

	var goret *StrvBuilder

	goret = UnsafeStrvBuilderFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Add wraps g_strv_builder_add
// 
// see also https://docs.gtk.org/glib/method.g_strv_builder_add.g_strv_builder_add.html
//
func (builder *StrvBuilder) Add(value string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 *C.char         // in, none, string

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(carg1))

	C.g_strv_builder_add(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Addv wraps g_strv_builder_addv
// 
// see also https://docs.gtk.org/glib/method.g_strv_builder_addv.g_strv_builder_addv.html
//
func (builder *StrvBuilder) Addv(value []string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 **C.char        // in, transfer: none, C Pointers: 2, Name: array[utf8], array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	_ = value
	_ = carg1
	panic("unimplemented conversion of []string (const char**) because of unimplemented: inner pointers in array")

	C.g_strv_builder_addv(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// Take wraps g_strv_builder_take
// 
// see also https://docs.gtk.org/glib/method.g_strv_builder_take.g_strv_builder_take.html
//
func (builder *StrvBuilder) Take(value string) {
	var carg0 *C.GStrvBuilder // in, none, converted
	var carg1 *C.char         // in, full, string

	carg0 = (*C.GStrvBuilder)(UnsafeStrvBuilderToGlibNone(builder))
	carg1 = (*C.char)(unsafe.Pointer(C.CString(value)))

	C.g_strv_builder_take(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(value)
}

// TestCase wraps GTestCase
// 
// see also https://docs.gtk.org/glib/struct.TestCase.html
//
type TestCase struct {
	*testCase
}

// testCase is the struct that's finalized
type testCase struct {
	native *C.GTestCase
}

// UnsafeTestCaseToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestCase) instance() *C.GTestCase {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestCaseFromGlibBorrow is used to convert raw C.GTestCase pointers to go. This is used by the bindings internally.
func UnsafeTestCaseFromGlibBorrow(p unsafe.Pointer) *TestCase {
	if p == nil {
		return nil
	}
	return &TestCase{&testCase{(*C.GTestCase)(p)}}
}

// UnsafeTestCaseFromGlibNone is used to convert raw C.GTestCase pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestCaseFromGlibNone(p unsafe.Pointer) *TestCase {
	wrapped := UnsafeTestCaseFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestCase because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestCaseFromGlibFull is used to convert raw C.GTestCase pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestCaseFromGlibFull(p unsafe.Pointer) *TestCase {
	wrapped := UnsafeTestCaseFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testCase,
		func (intern *testCase) {
			C.g_test_case_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestCaseFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestCase] is expected to work anymore.
func UnsafeTestCaseFree(t *TestCase) {
	C.g_test_case_free(t.native)
}

// UnsafeTestCaseToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestCaseToGlibNone(t *TestCase) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestCaseToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestCaseToGlibFull(t *TestCase) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testCase, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestCase is invalid from here on
	return _p
}

// TestConfig wraps GTestConfig
// 
// see also https://docs.gtk.org/glib/struct.TestConfig.html
type TestConfig struct {
	*testConfig
}

// testConfig is the struct that's finalized
type testConfig struct {
	native *C.GTestConfig
}

// UnsafeTestConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestConfig) instance() *C.GTestConfig {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestConfigFromGlibBorrow is used to convert raw C.GTestConfig pointers to go. This is used by the bindings internally.
func UnsafeTestConfigFromGlibBorrow(p unsafe.Pointer) *TestConfig {
	if p == nil {
		return nil
	}
	return &TestConfig{&testConfig{(*C.GTestConfig)(p)}}
}

// UnsafeTestConfigFromGlibNone is used to convert raw C.GTestConfig pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestConfigFromGlibNone(p unsafe.Pointer) *TestConfig {
	wrapped := UnsafeTestConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestConfig because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestConfigFromGlibFull is used to convert raw C.GTestConfig pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestConfigFromGlibFull(p unsafe.Pointer) *TestConfig {
	wrapped := UnsafeTestConfigFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testConfig,
		func (intern *testConfig) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTestConfigFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestConfig] is expected to work anymore.
func UnsafeTestConfigFree(t *TestConfig) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTestConfigToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestConfigToGlibNone(t *TestConfig) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestConfigToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestConfigToGlibFull(t *TestConfig) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testConfig, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestConfig is invalid from here on
	return _p
}

// TestLogBuffer wraps GTestLogBuffer
// 
// see also https://docs.gtk.org/glib/struct.TestLogBuffer.html
type TestLogBuffer struct {
	*testLogBuffer
}

// testLogBuffer is the struct that's finalized
type testLogBuffer struct {
	native *C.GTestLogBuffer
}

// UnsafeTestLogBufferToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestLogBuffer) instance() *C.GTestLogBuffer {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestLogBufferFromGlibBorrow is used to convert raw C.GTestLogBuffer pointers to go. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibBorrow(p unsafe.Pointer) *TestLogBuffer {
	if p == nil {
		return nil
	}
	return &TestLogBuffer{&testLogBuffer{(*C.GTestLogBuffer)(p)}}
}

// UnsafeTestLogBufferFromGlibNone is used to convert raw C.GTestLogBuffer pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibNone(p unsafe.Pointer) *TestLogBuffer {
	wrapped := UnsafeTestLogBufferFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestLogBuffer because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestLogBufferFromGlibFull is used to convert raw C.GTestLogBuffer pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestLogBufferFromGlibFull(p unsafe.Pointer) *TestLogBuffer {
	wrapped := UnsafeTestLogBufferFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testLogBuffer,
		func (intern *testLogBuffer) {
			C.g_test_log_buffer_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestLogBufferFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestLogBuffer] is expected to work anymore.
func UnsafeTestLogBufferFree(t *TestLogBuffer) {
	C.g_test_log_buffer_free(t.native)
}

// UnsafeTestLogBufferToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestLogBufferToGlibNone(t *TestLogBuffer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestLogBufferToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestLogBufferToGlibFull(t *TestLogBuffer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testLogBuffer, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestLogBuffer is invalid from here on
	return _p
}

// Push wraps g_test_log_buffer_push
// 
// see also https://docs.gtk.org/glib/method.g_test_log_buffer_push.g_test_log_buffer_push.html
//
func (tbuffer *TestLogBuffer) Push(nBytes uint, bytes *uint8) {
	var carg0 *C.GTestLogBuffer // in, none, converted
	var carg1 C.guint           // in, none, casted
	var carg2 *C.guint8         // in, transfer: none, C Pointers: 1, Name: guint8

	carg0 = (*C.GTestLogBuffer)(UnsafeTestLogBufferToGlibNone(tbuffer))
	carg1 = C.guint(nBytes)
	_ = bytes
	_ = carg2
	panic("unimplemented conversion of *uint8 (const guint8*) because of no basic converter found")

	C.g_test_log_buffer_push(carg0, carg1, carg2)
	runtime.KeepAlive(tbuffer)
	runtime.KeepAlive(nBytes)
	runtime.KeepAlive(bytes)
}

// TestSuite wraps GTestSuite
// 
// see also https://docs.gtk.org/glib/struct.TestSuite.html
//
type TestSuite struct {
	*testSuite
}

// testSuite is the struct that's finalized
type testSuite struct {
	native *C.GTestSuite
}

// UnsafeTestSuiteToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TestSuite) instance() *C.GTestSuite {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTestSuiteFromGlibBorrow is used to convert raw C.GTestSuite pointers to go. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibBorrow(p unsafe.Pointer) *TestSuite {
	if p == nil {
		return nil
	}
	return &TestSuite{&testSuite{(*C.GTestSuite)(p)}}
}

// UnsafeTestSuiteFromGlibNone is used to convert raw C.GTestSuite pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibNone(p unsafe.Pointer) *TestSuite {
	wrapped := UnsafeTestSuiteFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TestSuite because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTestSuiteFromGlibFull is used to convert raw C.GTestSuite pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTestSuiteFromGlibFull(p unsafe.Pointer) *TestSuite {
	wrapped := UnsafeTestSuiteFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.testSuite,
		func (intern *testSuite) {
			C.g_test_suite_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeTestSuiteFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TestSuite] is expected to work anymore.
func UnsafeTestSuiteFree(t *TestSuite) {
	C.g_test_suite_free(t.native)
}

// UnsafeTestSuiteToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTestSuiteToGlibNone(t *TestSuite) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTestSuiteToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTestSuiteToGlibFull(t *TestSuite) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.testSuite, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TestSuite is invalid from here on
	return _p
}

// Add wraps g_test_suite_add
// 
// see also https://docs.gtk.org/glib/method.g_test_suite_add.g_test_suite_add.html
//
func (suite *TestSuite) Add(testCase *TestCase) {
	var carg0 *C.GTestSuite // in, none, converted
	var carg1 *C.GTestCase  // in, none, converted

	carg0 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))
	carg1 = (*C.GTestCase)(UnsafeTestCaseToGlibNone(testCase))

	C.g_test_suite_add(carg0, carg1)
	runtime.KeepAlive(suite)
	runtime.KeepAlive(testCase)
}

// AddSuite wraps g_test_suite_add_suite
// 
// see also https://docs.gtk.org/glib/method.g_test_suite_add_suite.g_test_suite_add_suite.html
//
func (suite *TestSuite) AddSuite(nestedsuite *TestSuite) {
	var carg0 *C.GTestSuite // in, none, converted
	var carg1 *C.GTestSuite // in, none, converted

	carg0 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(suite))
	carg1 = (*C.GTestSuite)(UnsafeTestSuiteToGlibNone(nestedsuite))

	C.g_test_suite_add_suite(carg0, carg1)
	runtime.KeepAlive(suite)
	runtime.KeepAlive(nestedsuite)
}

// TimeZone wraps GTimeZone
// 
// see also https://docs.gtk.org/glib/struct.TimeZone.html
//
type TimeZone struct {
	*timeZone
}

// timeZone is the struct that's finalized
type timeZone struct {
	native *C.GTimeZone
}

// UnsafeTimeZoneToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TimeZone) instance() *C.GTimeZone {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTimeZoneFromGlibBorrow is used to convert raw C.GTimeZone pointers to go. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibBorrow(p unsafe.Pointer) *TimeZone {
	if p == nil {
		return nil
	}
	return &TimeZone{&timeZone{(*C.GTimeZone)(p)}}
}

// UnsafeTimeZoneFromGlibNone is used to convert raw C.GTimeZone pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibNone(p unsafe.Pointer) *TimeZone {
	C.g_time_zone_ref((*C.GTimeZone)(p))
	wrapped := UnsafeTimeZoneFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.timeZone,
		func (intern *timeZone) {
			C.g_time_zone_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimeZoneFromGlibFull is used to convert raw C.GTimeZone pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTimeZoneFromGlibFull(p unsafe.Pointer) *TimeZone {
	wrapped := UnsafeTimeZoneFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.timeZone,
		func (intern *timeZone) {
			C.g_time_zone_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimeZoneRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [TimeZone.UnsafeTimeZoneUnref], then [TimeZone] will leak memory.
func UnsafeTimeZoneRef(t *TimeZone) {
	C.g_time_zone_ref((*C.GTimeZone)(t.native))
}

// UnsafeTimeZoneUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TimeZone] is expected to work anymore.
func UnsafeTimeZoneUnref(t *TimeZone) {
	C.g_time_zone_unref(t.native)
}

// UnsafeTimeZoneToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTimeZoneToGlibNone(t *TimeZone) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTimeZoneToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTimeZoneToGlibFull(t *TimeZone) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.timeZone, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TimeZone is invalid from here on
	return _p
}

// NewTimeZoneIdentifier wraps g_time_zone_new_identifier
// 
// see also https://docs.gtk.org/glib/func.g_time_zone_new_identifier.html
//
func NewTimeZoneIdentifier(identifier string) *TimeZone {
	var carg1 *C.gchar     // in, none, string, nullable-string
	var cret  *C.GTimeZone // return, full, converted, nullable

	if identifier != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(identifier)))
		defer C.free(unsafe.Pointer(carg1))
	}

	cret = C.g_time_zone_new_identifier(carg1)
	runtime.KeepAlive(identifier)

	var goret *TimeZone

	if cret != nil {
		goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))
	}

	return goret
}

// NewTimeZoneLocal wraps g_time_zone_new_local
// 
// see also https://docs.gtk.org/glib/func.g_time_zone_new_local.html
//
func NewTimeZoneLocal() *TimeZone {
	var cret *C.GTimeZone // return, full, converted

	cret = C.g_time_zone_new_local()

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewTimeZoneOffset wraps g_time_zone_new_offset
// 
// see also https://docs.gtk.org/glib/func.g_time_zone_new_offset.html
//
func NewTimeZoneOffset(seconds int32) *TimeZone {
	var carg1 C.gint32     // in, none, casted
	var cret  *C.GTimeZone // return, full, converted

	carg1 = C.gint32(seconds)

	cret = C.g_time_zone_new_offset(carg1)
	runtime.KeepAlive(seconds)

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewTimeZoneUtc wraps g_time_zone_new_utc
// 
// see also https://docs.gtk.org/glib/func.g_time_zone_new_utc.html
//
func NewTimeZoneUtc() *TimeZone {
	var cret *C.GTimeZone // return, full, converted

	cret = C.g_time_zone_new_utc()

	var goret *TimeZone

	goret = UnsafeTimeZoneFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// FindInterval wraps g_time_zone_find_interval
// 
// see also https://docs.gtk.org/glib/method.g_time_zone_find_interval.g_time_zone_find_interval.html
//
func (tz *TimeZone) FindInterval(typ TimeType, time int64) int32 {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.GTimeType  // in, none, casted
	var carg2 C.gint64     // in, none, casted
	var cret  C.gint       // return, none, casted

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.GTimeType(typ)
	carg2 = C.gint64(time)

	cret = C.g_time_zone_find_interval(carg0, carg1, carg2)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(time)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetAbbreviation wraps g_time_zone_get_abbreviation
// 
// see also https://docs.gtk.org/glib/method.g_time_zone_get_abbreviation.g_time_zone_get_abbreviation.html
//
func (tz *TimeZone) GetAbbreviation(interval int32) string {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_get_abbreviation(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetIdentifier wraps g_time_zone_get_identifier
// 
// see also https://docs.gtk.org/glib/method.g_time_zone_get_identifier.g_time_zone_get_identifier.html
//
func (tz *TimeZone) GetIdentifier() string {
	var carg0 *C.GTimeZone // in, none, converted
	var cret  *C.gchar     // return, none, string

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))

	cret = C.g_time_zone_get_identifier(carg0)
	runtime.KeepAlive(tz)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetOffset wraps g_time_zone_get_offset
// 
// see also https://docs.gtk.org/glib/method.g_time_zone_get_offset.g_time_zone_get_offset.html
//
func (tz *TimeZone) GetOffset(interval int32) int32 {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  C.gint32     // return, none, casted

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_get_offset(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret int32

	goret = int32(cret)

	return goret
}

// IsDst wraps g_time_zone_is_dst
// 
// see also https://docs.gtk.org/glib/method.g_time_zone_is_dst.g_time_zone_is_dst.html
//
func (tz *TimeZone) IsDst(interval int32) bool {
	var carg0 *C.GTimeZone // in, none, converted
	var carg1 C.gint       // in, none, casted
	var cret  C.gboolean   // return

	carg0 = (*C.GTimeZone)(UnsafeTimeZoneToGlibNone(tz))
	carg1 = C.gint(interval)

	cret = C.g_time_zone_is_dst(carg0, carg1)
	runtime.KeepAlive(tz)
	runtime.KeepAlive(interval)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Timer wraps GTimer
// 
// see also https://docs.gtk.org/glib/struct.Timer.html
//
type Timer struct {
	*timer
}

// timer is the struct that's finalized
type timer struct {
	native *C.GTimer
}

// UnsafeTimerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *Timer) instance() *C.GTimer {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTimerFromGlibBorrow is used to convert raw C.GTimer pointers to go. This is used by the bindings internally.
func UnsafeTimerFromGlibBorrow(p unsafe.Pointer) *Timer {
	if p == nil {
		return nil
	}
	return &Timer{&timer{(*C.GTimer)(p)}}
}

// UnsafeTimerFromGlibNone is used to convert raw C.GTimer pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTimerFromGlibNone(p unsafe.Pointer) *Timer {
	wrapped := UnsafeTimerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to Timer because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTimerFromGlibFull is used to convert raw C.GTimer pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTimerFromGlibFull(p unsafe.Pointer) *Timer {
	wrapped := UnsafeTimerFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.timer,
		func (intern *timer) {
			C.g_timer_destroy(intern.native)
		},
	)
	return wrapped
}

// UnsafeTimerDestroy unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Timer] is expected to work anymore.
func UnsafeTimerDestroy(t *Timer) {
	C.g_timer_destroy(t.native)
}

// UnsafeTimerToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTimerToGlibNone(t *Timer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTimerToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTimerToGlibFull(t *Timer) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.timer, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // Timer is invalid from here on
	return _p
}

// Continue wraps g_timer_continue
// 
// see also https://docs.gtk.org/glib/method.g_timer_continue.g_timer_continue.html
//
func (timer *Timer) Continue() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_continue(carg0)
	runtime.KeepAlive(timer)
}

// Elapsed wraps g_timer_elapsed
// 
// see also https://docs.gtk.org/glib/method.g_timer_elapsed.g_timer_elapsed.html
//
func (timer *Timer) Elapsed(microseconds *uint32) float64 {
	var carg0 *C.GTimer // in, none, converted
	var carg1 *C.gulong // in, transfer: none, C Pointers: 1, Name: gulong
	var cret  C.gdouble // return, none, casted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))
	_ = microseconds
	_ = carg1
	panic("unimplemented conversion of *uint32 (gulong*) because of no basic converter found")

	cret = C.g_timer_elapsed(carg0, carg1)
	runtime.KeepAlive(timer)
	runtime.KeepAlive(microseconds)

	var goret float64

	goret = float64(cret)

	return goret
}

// IsActive wraps g_timer_is_active
// 
// see also https://docs.gtk.org/glib/method.g_timer_is_active.g_timer_is_active.html
//
func (timer *Timer) IsActive() bool {
	var carg0 *C.GTimer  // in, none, converted
	var cret  C.gboolean // return

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	cret = C.g_timer_is_active(carg0)
	runtime.KeepAlive(timer)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Reset wraps g_timer_reset
// 
// see also https://docs.gtk.org/glib/method.g_timer_reset.g_timer_reset.html
//
func (timer *Timer) Reset() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_reset(carg0)
	runtime.KeepAlive(timer)
}

// Start wraps g_timer_start
// 
// see also https://docs.gtk.org/glib/method.g_timer_start.g_timer_start.html
//
func (timer *Timer) Start() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_start(carg0)
	runtime.KeepAlive(timer)
}

// Stop wraps g_timer_stop
// 
// see also https://docs.gtk.org/glib/method.g_timer_stop.g_timer_stop.html
//
func (timer *Timer) Stop() {
	var carg0 *C.GTimer // in, none, converted

	carg0 = (*C.GTimer)(UnsafeTimerToGlibNone(timer))

	C.g_timer_stop(carg0)
	runtime.KeepAlive(timer)
}

// TreeNode wraps GTreeNode
// 
// see also https://docs.gtk.org/glib/struct.TreeNode.html
//
type TreeNode struct {
	*treeNode
}

// treeNode is the struct that's finalized
type treeNode struct {
	native *C.GTreeNode
}

// UnsafeTreeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (t *TreeNode) instance() *C.GTreeNode {
	if t == nil {
		return nil
	}
	return t.native
}

// UnsafeTreeNodeFromGlibBorrow is used to convert raw C.GTreeNode pointers to go. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibBorrow(p unsafe.Pointer) *TreeNode {
	if p == nil {
		return nil
	}
	return &TreeNode{&treeNode{(*C.GTreeNode)(p)}}
}

// UnsafeTreeNodeFromGlibNone is used to convert raw C.GTreeNode pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibNone(p unsafe.Pointer) *TreeNode {
	wrapped := UnsafeTreeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to TreeNode because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeTreeNodeFromGlibFull is used to convert raw C.GTreeNode pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeTreeNodeFromGlibFull(p unsafe.Pointer) *TreeNode {
	wrapped := UnsafeTreeNodeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.treeNode,
		func (intern *treeNode) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeTreeNodeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [TreeNode] is expected to work anymore.
func UnsafeTreeNodeFree(t *TreeNode) {
	C.free(unsafe.Pointer(t.native))
}

// UnsafeTreeNodeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeTreeNodeToGlibNone(t *TreeNode) unsafe.Pointer {
	if t == nil {
		return nil
	}
	return unsafe.Pointer(t.native)
}

// UnsafeTreeNodeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeTreeNodeToGlibFull(t *TreeNode) unsafe.Pointer {
	if t == nil {
		return nil
	}
	runtime.SetFinalizer(t.treeNode, nil)
	_p := unsafe.Pointer(t.native)
	t.native = nil // TreeNode is invalid from here on
	return _p
}

// Next wraps g_tree_node_next
// 
// see also https://docs.gtk.org/glib/method.g_tree_node_next.g_tree_node_next.html
//
func (node *TreeNode) Next() *TreeNode {
	var carg0 *C.GTreeNode // in, none, converted
	var cret  *C.GTreeNode // return, none, converted, nullable

	carg0 = (*C.GTreeNode)(UnsafeTreeNodeToGlibNone(node))

	cret = C.g_tree_node_next(carg0)
	runtime.KeepAlive(node)

	var goret *TreeNode

	if cret != nil {
		goret = UnsafeTreeNodeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Previous wraps g_tree_node_previous
// 
// see also https://docs.gtk.org/glib/method.g_tree_node_previous.g_tree_node_previous.html
//
func (node *TreeNode) Previous() *TreeNode {
	var carg0 *C.GTreeNode // in, none, converted
	var cret  *C.GTreeNode // return, none, converted, nullable

	carg0 = (*C.GTreeNode)(UnsafeTreeNodeToGlibNone(node))

	cret = C.g_tree_node_previous(carg0)
	runtime.KeepAlive(node)

	var goret *TreeNode

	if cret != nil {
		goret = UnsafeTreeNodeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Uri wraps GUri
// 
// see also https://docs.gtk.org/glib/struct.Uri.html
//
type Uri struct {
	*uri
}

// uri is the struct that's finalized
type uri struct {
	native *C.GUri
}

// UnsafeUriToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (u *Uri) instance() *C.GUri {
	if u == nil {
		return nil
	}
	return u.native
}

// UnsafeUriFromGlibBorrow is used to convert raw C.GUri pointers to go. This is used by the bindings internally.
func UnsafeUriFromGlibBorrow(p unsafe.Pointer) *Uri {
	if p == nil {
		return nil
	}
	return &Uri{&uri{(*C.GUri)(p)}}
}

// UnsafeUriFromGlibNone is used to convert raw C.GUri pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeUriFromGlibNone(p unsafe.Pointer) *Uri {
	C.g_uri_ref((*C.GUri)(p))
	wrapped := UnsafeUriFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.uri,
		func (intern *uri) {
			C.g_uri_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeUriFromGlibFull is used to convert raw C.GUri pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeUriFromGlibFull(p unsafe.Pointer) *Uri {
	wrapped := UnsafeUriFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.uri,
		func (intern *uri) {
			C.g_uri_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeUriRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [Uri.UnsafeUriUnref], then [Uri] will leak memory.
func UnsafeUriRef(u *Uri) {
	C.g_uri_ref((*C.GUri)(u.native))
}

// UnsafeUriUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [Uri] is expected to work anymore.
func UnsafeUriUnref(u *Uri) {
	C.g_uri_unref(u.native)
}

// UnsafeUriToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeUriToGlibNone(u *Uri) unsafe.Pointer {
	if u == nil {
		return nil
	}
	return unsafe.Pointer(u.native)
}

// UnsafeUriToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeUriToGlibFull(u *Uri) unsafe.Pointer {
	if u == nil {
		return nil
	}
	runtime.SetFinalizer(u.uri, nil)
	_p := unsafe.Pointer(u.native)
	u.native = nil // Uri is invalid from here on
	return _p
}

// UriBuild wraps g_uri_build
// 
// see also https://docs.gtk.org/glib/func.g_uri_build.html
//
func UriBuild(flags UriFlags, scheme string, userinfo string, host string, port int32, path string, query string, fragment string) *Uri {
	var carg1 C.GUriFlags // in, none, casted
	var carg2 *C.gchar    // in, none, string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 *C.gchar    // in, none, string, nullable-string
	var carg5 C.gint      // in, none, casted
	var carg6 *C.gchar    // in, none, string
	var carg7 *C.gchar    // in, none, string, nullable-string
	var carg8 *C.gchar    // in, none, string, nullable-string
	var cret  *C.GUri     // return, full, converted

	carg1 = C.GUriFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg2))
	if userinfo != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if host != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.gint(port)
	carg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg6))
	if query != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg7))
	}
	if fragment != "" {
		carg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg8))
	}

	cret = C.g_uri_build(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret *Uri

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// UriBuildWithUser wraps g_uri_build_with_user
// 
// see also https://docs.gtk.org/glib/func.g_uri_build_with_user.html
//
func UriBuildWithUser(flags UriFlags, scheme string, user string, password string, authParams string, host string, port int32, path string, query string, fragment string) *Uri {
	var carg1  C.GUriFlags // in, none, casted
	var carg2  *C.gchar    // in, none, string
	var carg3  *C.gchar    // in, none, string, nullable-string
	var carg4  *C.gchar    // in, none, string, nullable-string
	var carg5  *C.gchar    // in, none, string, nullable-string
	var carg6  *C.gchar    // in, none, string, nullable-string
	var carg7  C.gint      // in, none, casted
	var carg8  *C.gchar    // in, none, string
	var carg9  *C.gchar    // in, none, string, nullable-string
	var carg10 *C.gchar    // in, none, string, nullable-string
	var cret   *C.GUri     // return, full, converted

	carg1 = C.GUriFlags(flags)
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(carg2))
	if user != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if password != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if authParams != "" {
		carg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if host != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg6))
	}
	carg7 = C.gint(port)
	carg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg8))
	if query != "" {
		carg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if fragment != "" {
		carg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg10))
	}

	cret = C.g_uri_build_with_user(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9, carg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret *Uri

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// UriErrorQuark wraps g_uri_error_quark
// 
// see also https://docs.gtk.org/glib/func.g_uri_error_quark.html
func UriErrorQuark() Quark {
	var cret C.GQuark // return, none, casted, alias

	cret = C.g_uri_error_quark()

	var goret Quark

	goret = Quark(cret)

	return goret
}

// UriEscapeBytes wraps g_uri_escape_bytes
// 
// see also https://docs.gtk.org/glib/func.g_uri_escape_bytes.html
//
func UriEscapeBytes(unescaped []uint8, reservedCharsAllowed string) string {
	var carg1 *C.guint8 // in, transfer: none, C Pointers: 1, Name: array[guint8], array (inner guint8 (*typesystem.CastablePrimitive), length-by: carg2)
	var carg2 C.gsize   // implicit
	var carg3 *C.char   // in, none, string, nullable-string
	var cret  *C.char   // return, full, string

	_ = unescaped
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []uint8 (const guint8*) because of unimplemented: non-fixed size array")
	if reservedCharsAllowed != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_escape_bytes(carg1, carg2, carg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriEscapeString wraps g_uri_escape_string
// 
// see also https://docs.gtk.org/glib/func.g_uri_escape_string.html
//
func UriEscapeString(unescaped string, reservedCharsAllowed string, allowUtf8 bool) string {
	var carg1 *C.char    // in, none, string
	var carg2 *C.char    // in, none, string, nullable-string
	var carg3 C.gboolean // in
	var cret  *C.char    // return, full, string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(unescaped)))
	defer C.free(unsafe.Pointer(carg1))
	if reservedCharsAllowed != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if allowUtf8 {
		carg3 = C.TRUE
	}

	cret = C.g_uri_escape_string(carg1, carg2, carg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)
	runtime.KeepAlive(allowUtf8)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriIsValid wraps g_uri_is_valid
// 
// see also https://docs.gtk.org/glib/func.g_uri_is_valid.html
//
func UriIsValid(uriString string, flags UriFlags) (bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_is_valid(carg1, carg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var goret  bool
	var _goerr error

	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriJoin wraps g_uri_join
// 
// see also https://docs.gtk.org/glib/func.g_uri_join.html
//
func UriJoin(flags UriFlags, scheme string, userinfo string, host string, port int32, path string, query string, fragment string) string {
	var carg1 C.GUriFlags // in, none, casted
	var carg2 *C.gchar    // in, none, string, nullable-string
	var carg3 *C.gchar    // in, none, string, nullable-string
	var carg4 *C.gchar    // in, none, string, nullable-string
	var carg5 C.gint      // in, none, casted
	var carg6 *C.gchar    // in, none, string
	var carg7 *C.gchar    // in, none, string, nullable-string
	var carg8 *C.gchar    // in, none, string, nullable-string
	var cret  *C.gchar    // return, full, string

	carg1 = C.GUriFlags(flags)
	if scheme != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if userinfo != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if host != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg4))
	}
	carg5 = C.gint(port)
	carg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg6))
	if query != "" {
		carg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg7))
	}
	if fragment != "" {
		carg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg8))
	}

	cret = C.g_uri_join(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriJoinWithUser wraps g_uri_join_with_user
// 
// see also https://docs.gtk.org/glib/func.g_uri_join_with_user.html
//
func UriJoinWithUser(flags UriFlags, scheme string, user string, password string, authParams string, host string, port int32, path string, query string, fragment string) string {
	var carg1  C.GUriFlags // in, none, casted
	var carg2  *C.gchar    // in, none, string, nullable-string
	var carg3  *C.gchar    // in, none, string, nullable-string
	var carg4  *C.gchar    // in, none, string, nullable-string
	var carg5  *C.gchar    // in, none, string, nullable-string
	var carg6  *C.gchar    // in, none, string, nullable-string
	var carg7  C.gint      // in, none, casted
	var carg8  *C.gchar    // in, none, string
	var carg9  *C.gchar    // in, none, string, nullable-string
	var carg10 *C.gchar    // in, none, string, nullable-string
	var cret   *C.gchar    // return, full, string

	carg1 = C.GUriFlags(flags)
	if scheme != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if user != "" {
		carg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if password != "" {
		carg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if authParams != "" {
		carg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if host != "" {
		carg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(carg6))
	}
	carg7 = C.gint(port)
	carg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(carg8))
	if query != "" {
		carg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if fragment != "" {
		carg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(carg10))
	}

	cret = C.g_uri_join_with_user(carg1, carg2, carg3, carg4, carg5, carg6, carg7, carg8, carg9, carg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriListExtractUris wraps g_uri_list_extract_uris
// 
// see also https://docs.gtk.org/glib/func.g_uri_list_extract_uris.html
//
func UriListExtractUris(uriList string) []string {
	var carg1 *C.gchar  // in, none, string
	var cret  **C.gchar // return, transfer: full, C Pointers: 2, Name: array[utf8], scope: , array (inner gchar* (*typesystem.StringPrimitive), zero-terminated)

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriList)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_list_extract_uris(carg1)
	runtime.KeepAlive(uriList)

	var goret []string

	_ = goret
	_ = cret
	panic("unimplemented conversion of []string (gchar**) because of unknown reason")

	return goret
}

// UriParse wraps g_uri_parse
// 
// see also https://docs.gtk.org/glib/func.g_uri_parse.html
//
func UriParse(uriString string, flags UriFlags) (*Uri, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  *C.GUri     // return, full, converted
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_parse(carg1, carg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var goret  *Uri
	var _goerr error

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriParseScheme wraps g_uri_parse_scheme
// 
// see also https://docs.gtk.org/glib/func.g_uri_parse_scheme.html
//
func UriParseScheme(uri string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, full, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_parse_scheme(carg1)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UriPeekScheme wraps g_uri_peek_scheme
// 
// see also https://docs.gtk.org/glib/func.g_uri_peek_scheme.html
//
func UriPeekScheme(uri string) string {
	var carg1 *C.char // in, none, string
	var cret  *C.char // return, none, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_uri_peek_scheme(carg1)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// UriResolveRelative wraps g_uri_resolve_relative
// 
// see also https://docs.gtk.org/glib/func.g_uri_resolve_relative.html
//
func UriResolveRelative(baseUriString string, uriRef string, flags UriFlags) (string, error) {
	var carg1 *C.gchar    // in, none, string, nullable-string
	var carg2 *C.gchar    // in, none, string
	var carg3 C.GUriFlags // in, none, casted
	var cret  *C.gchar    // return, full, string
	var _cerr *C.GError   // out, full, converted, nullable

	if baseUriString != "" {
		carg1 = (*C.gchar)(unsafe.Pointer(C.CString(baseUriString)))
		defer C.free(unsafe.Pointer(carg1))
	}
	carg2 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg2))
	carg3 = C.GUriFlags(flags)

	cret = C.g_uri_resolve_relative(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(baseUriString)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var goret  string
	var _goerr error

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriSplit wraps g_uri_split
// 
// see also https://docs.gtk.org/glib/func.g_uri_split.html
//
func UriSplit(uriRef string, flags UriFlags) (string, string, string, int32, string, string, string, bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var carg3 *C.gchar    // out, full, string, nullable-string
	var carg4 *C.gchar    // out, full, string, nullable-string
	var carg5 *C.gchar    // out, full, string, nullable-string
	var carg6 C.gint      // out, full, casted
	var carg7 *C.gchar    // out, full, string
	var carg8 *C.gchar    // out, full, string, nullable-string
	var carg9 *C.gchar    // out, full, string, nullable-string
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split(carg1, carg2, &carg3, &carg4, &carg5, &carg6, &carg7, &carg8, &carg9, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var scheme   string
	var userinfo string
	var host     string
	var port     int32
	var path     string
	var query    string
	var fragment string
	var goret    bool
	var _goerr   error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		userinfo = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if carg5 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg5)))
		defer C.free(unsafe.Pointer(carg5))
	}
	port = int32(carg6)
	path = C.GoString((*C.char)(unsafe.Pointer(carg7)))
	defer C.free(unsafe.Pointer(carg7))
	if carg8 != nil {
		query = C.GoString((*C.char)(unsafe.Pointer(carg8)))
		defer C.free(unsafe.Pointer(carg8))
	}
	if carg9 != nil {
		fragment = C.GoString((*C.char)(unsafe.Pointer(carg9)))
		defer C.free(unsafe.Pointer(carg9))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, userinfo, host, port, path, query, fragment, goret, _goerr
}

// UriSplitNetwork wraps g_uri_split_network
// 
// see also https://docs.gtk.org/glib/func.g_uri_split_network.html
//
func UriSplitNetwork(uriString string, flags UriFlags) (string, string, int32, bool, error) {
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var carg3 *C.gchar    // out, full, string, nullable-string
	var carg4 *C.gchar    // out, full, string, nullable-string
	var carg5 C.gint      // out, full, casted
	var cret  C.gboolean  // return
	var _cerr *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split_network(carg1, carg2, &carg3, &carg4, &carg5, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var scheme string
	var host   string
	var port   int32
	var goret  bool
	var _goerr error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	port = int32(carg5)
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, host, port, goret, _goerr
}

// UriSplitWithUser wraps g_uri_split_with_user
// 
// see also https://docs.gtk.org/glib/func.g_uri_split_with_user.html
//
func UriSplitWithUser(uriRef string, flags UriFlags) (string, string, string, string, string, int32, string, string, string, bool, error) {
	var carg1  *C.gchar    // in, none, string
	var carg2  C.GUriFlags // in, none, casted
	var carg3  *C.gchar    // out, full, string, nullable-string
	var carg4  *C.gchar    // out, full, string, nullable-string
	var carg5  *C.gchar    // out, full, string, nullable-string
	var carg6  *C.gchar    // out, full, string, nullable-string
	var carg7  *C.gchar    // out, full, string, nullable-string
	var carg8  C.gint      // out, full, casted
	var carg9  *C.gchar    // out, full, string
	var carg10 *C.gchar    // out, full, string, nullable-string
	var carg11 *C.gchar    // out, full, string, nullable-string
	var cret   C.gboolean  // return
	var _cerr  *C.GError   // out, full, converted, nullable

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_split_with_user(carg1, carg2, &carg3, &carg4, &carg5, &carg6, &carg7, &carg8, &carg9, &carg10, &carg11, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var scheme     string
	var user       string
	var password   string
	var authParams string
	var host       string
	var port       int32
	var path       string
	var query      string
	var fragment   string
	var goret      bool
	var _goerr     error

	if carg3 != nil {
		scheme = C.GoString((*C.char)(unsafe.Pointer(carg3)))
		defer C.free(unsafe.Pointer(carg3))
	}
	if carg4 != nil {
		user = C.GoString((*C.char)(unsafe.Pointer(carg4)))
		defer C.free(unsafe.Pointer(carg4))
	}
	if carg5 != nil {
		password = C.GoString((*C.char)(unsafe.Pointer(carg5)))
		defer C.free(unsafe.Pointer(carg5))
	}
	if carg6 != nil {
		authParams = C.GoString((*C.char)(unsafe.Pointer(carg6)))
		defer C.free(unsafe.Pointer(carg6))
	}
	if carg7 != nil {
		host = C.GoString((*C.char)(unsafe.Pointer(carg7)))
		defer C.free(unsafe.Pointer(carg7))
	}
	port = int32(carg8)
	path = C.GoString((*C.char)(unsafe.Pointer(carg9)))
	defer C.free(unsafe.Pointer(carg9))
	if carg10 != nil {
		query = C.GoString((*C.char)(unsafe.Pointer(carg10)))
		defer C.free(unsafe.Pointer(carg10))
	}
	if carg11 != nil {
		fragment = C.GoString((*C.char)(unsafe.Pointer(carg11)))
		defer C.free(unsafe.Pointer(carg11))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return scheme, user, password, authParams, host, port, path, query, fragment, goret, _goerr
}

// UriUnescapeBytes wraps g_uri_unescape_bytes
// 
// see also https://docs.gtk.org/glib/func.g_uri_unescape_bytes.html
//
func UriUnescapeBytes(escapedString string, length int, illegalCharacters string) (*Bytes, error) {
	var carg1 *C.char   // in, none, string
	var carg2 C.gssize  // in, none, casted
	var carg3 *C.char   // in, none, string, nullable-string
	var cret  *C.GBytes // return, full, converted
	var _cerr *C.GError // out, full, converted, nullable

	carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)
	if illegalCharacters != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_unescape_bytes(carg1, carg2, carg3, &_cerr)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(length)
	runtime.KeepAlive(illegalCharacters)

	var goret  *Bytes
	var _goerr error

	goret = UnsafeBytesFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// UriUnescapeSegment wraps g_uri_unescape_segment
// 
// see also https://docs.gtk.org/glib/func.g_uri_unescape_segment.html
//
func UriUnescapeSegment(escapedString string, escapedStringEnd string, illegalCharacters string) string {
	var carg1 *C.char // in, none, string, nullable-string
	var carg2 *C.char // in, none, string, nullable-string
	var carg3 *C.char // in, none, string, nullable-string
	var cret  *C.char // return, full, string, nullable-string

	if escapedString != "" {
		carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if escapedStringEnd != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(escapedStringEnd)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if illegalCharacters != "" {
		carg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg3))
	}

	cret = C.g_uri_unescape_segment(carg1, carg2, carg3)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(escapedStringEnd)
	runtime.KeepAlive(illegalCharacters)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// UriUnescapeString wraps g_uri_unescape_string
// 
// see also https://docs.gtk.org/glib/func.g_uri_unescape_string.html
//
func UriUnescapeString(escapedString string, illegalCharacters string) string {
	var carg1 *C.char // in, none, string
	var carg2 *C.char // in, none, string, nullable-string
	var cret  *C.char // return, full, string, nullable-string

	carg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(carg1))
	if illegalCharacters != "" {
		carg2 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_uri_unescape_string(carg1, carg2)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
		defer C.free(unsafe.Pointer(cret))
	}

	return goret
}

// GetAuthParams wraps g_uri_get_auth_params
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_auth_params.g_uri_get_auth_params.html
//
func (uri *Uri) GetAuthParams() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_auth_params(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetFlags wraps g_uri_get_flags
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_flags.g_uri_get_flags.html
//
func (uri *Uri) GetFlags() UriFlags {
	var carg0 *C.GUri     // in, none, converted
	var cret  C.GUriFlags // return, none, casted

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_flags(carg0)
	runtime.KeepAlive(uri)

	var goret UriFlags

	goret = UriFlags(cret)

	return goret
}

// GetFragment wraps g_uri_get_fragment
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_fragment.g_uri_get_fragment.html
//
func (uri *Uri) GetFragment() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_fragment(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetHost wraps g_uri_get_host
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_host.g_uri_get_host.html
//
func (uri *Uri) GetHost() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_host(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPassword wraps g_uri_get_password
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_password.g_uri_get_password.html
//
func (uri *Uri) GetPassword() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_password(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetPath wraps g_uri_get_path
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_path.g_uri_get_path.html
//
func (uri *Uri) GetPath() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_path(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetPort wraps g_uri_get_port
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_port.g_uri_get_port.html
//
func (uri *Uri) GetPort() int32 {
	var carg0 *C.GUri // in, none, converted
	var cret  C.gint  // return, none, casted

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_port(carg0)
	runtime.KeepAlive(uri)

	var goret int32

	goret = int32(cret)

	return goret
}

// GetQuery wraps g_uri_get_query
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_query.g_uri_get_query.html
//
func (uri *Uri) GetQuery() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_query(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetScheme wraps g_uri_get_scheme
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_scheme.g_uri_get_scheme.html
//
func (uri *Uri) GetScheme() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_scheme(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))

	return goret
}

// GetUser wraps g_uri_get_user
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_user.g_uri_get_user.html
//
func (uri *Uri) GetUser() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_user(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// GetUserinfo wraps g_uri_get_userinfo
// 
// see also https://docs.gtk.org/glib/method.g_uri_get_userinfo.g_uri_get_userinfo.html
//
func (uri *Uri) GetUserinfo() string {
	var carg0 *C.GUri  // in, none, converted
	var cret  *C.gchar // return, none, string, nullable-string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_get_userinfo(carg0)
	runtime.KeepAlive(uri)

	var goret string

	if cret != nil {
		goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	}

	return goret
}

// ParseRelative wraps g_uri_parse_relative
// 
// see also https://docs.gtk.org/glib/method.g_uri_parse_relative.g_uri_parse_relative.html
//
func (baseUri *Uri) ParseRelative(uriRef string, flags UriFlags) (*Uri, error) {
	var carg0 *C.GUri     // in, none, converted
	var carg1 *C.gchar    // in, none, string
	var carg2 C.GUriFlags // in, none, casted
	var cret  *C.GUri     // return, full, converted
	var _cerr *C.GError   // out, full, converted, nullable

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(baseUri))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.GUriFlags(flags)

	cret = C.g_uri_parse_relative(carg0, carg1, carg2, &_cerr)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var goret  *Uri
	var _goerr error

	goret = UnsafeUriFromGlibFull(unsafe.Pointer(cret))
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return goret, _goerr
}

// String wraps g_uri_to_string
// 
// see also https://docs.gtk.org/glib/method.g_uri_to_string.g_uri_to_string.html
//
func (uri *Uri) String() string {
	var carg0 *C.GUri // in, none, converted
	var cret  *C.char // return, full, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))

	cret = C.g_uri_to_string(carg0)
	runtime.KeepAlive(uri)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// ToStringPartial wraps g_uri_to_string_partial
// 
// see also https://docs.gtk.org/glib/method.g_uri_to_string_partial.g_uri_to_string_partial.html
//
func (uri *Uri) ToStringPartial(flags UriHideFlags) string {
	var carg0 *C.GUri         // in, none, converted
	var carg1 C.GUriHideFlags // in, none, casted
	var cret  *C.char         // return, full, string

	carg0 = (*C.GUri)(UnsafeUriToGlibNone(uri))
	carg1 = C.GUriHideFlags(flags)

	cret = C.g_uri_to_string_partial(carg0, carg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(flags)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// UriParamsIter wraps GUriParamsIter
// 
// see also https://docs.gtk.org/glib/struct.UriParamsIter.html
//
type UriParamsIter struct {
	*uriParamsIter
}

// uriParamsIter is the struct that's finalized
type uriParamsIter struct {
	native *C.GUriParamsIter
}

// UnsafeUriParamsIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (u *UriParamsIter) instance() *C.GUriParamsIter {
	if u == nil {
		return nil
	}
	return u.native
}

// UnsafeUriParamsIterFromGlibBorrow is used to convert raw C.GUriParamsIter pointers to go. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibBorrow(p unsafe.Pointer) *UriParamsIter {
	if p == nil {
		return nil
	}
	return &UriParamsIter{&uriParamsIter{(*C.GUriParamsIter)(p)}}
}

// UnsafeUriParamsIterFromGlibNone is used to convert raw C.GUriParamsIter pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibNone(p unsafe.Pointer) *UriParamsIter {
	wrapped := UnsafeUriParamsIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	log.Println("WARNING: not attaching a finalizer to UriParamsIter because no cgo ref function or copy method is available. This may leak memory. Please file an issue")
	return wrapped
}

// UnsafeUriParamsIterFromGlibFull is used to convert raw C.GUriParamsIter pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeUriParamsIterFromGlibFull(p unsafe.Pointer) *UriParamsIter {
	wrapped := UnsafeUriParamsIterFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.uriParamsIter,
		func (intern *uriParamsIter) {
			C.free(unsafe.Pointer(intern.native))
		},
	)
	return wrapped
}

// UnsafeUriParamsIterFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [UriParamsIter] is expected to work anymore.
func UnsafeUriParamsIterFree(u *UriParamsIter) {
	C.free(unsafe.Pointer(u.native))
}

// UnsafeUriParamsIterToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeUriParamsIterToGlibNone(u *UriParamsIter) unsafe.Pointer {
	if u == nil {
		return nil
	}
	return unsafe.Pointer(u.native)
}

// UnsafeUriParamsIterToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeUriParamsIterToGlibFull(u *UriParamsIter) unsafe.Pointer {
	if u == nil {
		return nil
	}
	runtime.SetFinalizer(u.uriParamsIter, nil)
	_p := unsafe.Pointer(u.native)
	u.native = nil // UriParamsIter is invalid from here on
	return _p
}

// Init wraps g_uri_params_iter_init
// 
// see also https://docs.gtk.org/glib/method.g_uri_params_iter_init.g_uri_params_iter_init.html
//
func (iter *UriParamsIter) Init(params string, length int, separators string, flags UriParamsFlags) {
	var carg0 *C.GUriParamsIter // in, none, converted
	var carg1 *C.gchar          // in, none, string
	var carg2 C.gssize          // in, none, casted
	var carg3 *C.gchar          // in, none, string
	var carg4 C.GUriParamsFlags // in, none, casted

	carg0 = (*C.GUriParamsIter)(UnsafeUriParamsIterToGlibNone(iter))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(params)))
	defer C.free(unsafe.Pointer(carg1))
	carg2 = C.gssize(length)
	carg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(carg3))
	carg4 = C.GUriParamsFlags(flags)

	C.g_uri_params_iter_init(carg0, carg1, carg2, carg3, carg4)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(params)
	runtime.KeepAlive(length)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)
}

// Next wraps g_uri_params_iter_next
// 
// see also https://docs.gtk.org/glib/method.g_uri_params_iter_next.g_uri_params_iter_next.html
//
func (iter *UriParamsIter) Next() (string, string, bool, error) {
	var carg0 *C.GUriParamsIter // in, none, converted
	var carg1 *C.gchar          // out, full, string, nullable-string
	var carg2 *C.gchar          // out, full, string, nullable-string
	var cret  C.gboolean        // return
	var _cerr *C.GError         // out, full, converted, nullable

	carg0 = (*C.GUriParamsIter)(UnsafeUriParamsIterToGlibNone(iter))

	cret = C.g_uri_params_iter_next(carg0, &carg1, &carg2, &_cerr)
	runtime.KeepAlive(iter)

	var attribute string
	var value     string
	var goret     bool
	var _goerr    error

	if carg1 != nil {
		attribute = C.GoString((*C.char)(unsafe.Pointer(carg1)))
		defer C.free(unsafe.Pointer(carg1))
	}
	if carg2 != nil {
		value = C.GoString((*C.char)(unsafe.Pointer(carg2)))
		defer C.free(unsafe.Pointer(carg2))
	}
	if cret != 0 {
		goret = true
	}
	if _cerr != nil {
		_goerr = UnsafeErrorFromGlibFull(unsafe.Pointer(_cerr))
	}

	return attribute, value, goret, _goerr
}

// VariantBuilder wraps GVariantBuilder
// 
// see also https://docs.gtk.org/glib/struct.VariantBuilder.html
//
type VariantBuilder struct {
	*variantBuilder
}

// variantBuilder is the struct that's finalized
type variantBuilder struct {
	native *C.GVariantBuilder
}

// UnsafeVariantBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantBuilder) instance() *C.GVariantBuilder {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantBuilderFromGlibBorrow is used to convert raw C.GVariantBuilder pointers to go. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibBorrow(p unsafe.Pointer) *VariantBuilder {
	if p == nil {
		return nil
	}
	return &VariantBuilder{&variantBuilder{(*C.GVariantBuilder)(p)}}
}

// UnsafeVariantBuilderFromGlibNone is used to convert raw C.GVariantBuilder pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibNone(p unsafe.Pointer) *VariantBuilder {
	C.g_variant_builder_ref((*C.GVariantBuilder)(p))
	wrapped := UnsafeVariantBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.variantBuilder,
		func (intern *variantBuilder) {
			C.g_variant_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantBuilderFromGlibFull is used to convert raw C.GVariantBuilder pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantBuilderFromGlibFull(p unsafe.Pointer) *VariantBuilder {
	wrapped := UnsafeVariantBuilderFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantBuilder,
		func (intern *variantBuilder) {
			C.g_variant_builder_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantBuilderRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [VariantBuilder.UnsafeVariantBuilderUnref], then [VariantBuilder] will leak memory.
func UnsafeVariantBuilderRef(v *VariantBuilder) {
	C.g_variant_builder_ref((*C.GVariantBuilder)(v.native))
}

// UnsafeVariantBuilderUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantBuilder] is expected to work anymore.
func UnsafeVariantBuilderUnref(v *VariantBuilder) {
	C.g_variant_builder_unref(v.native)
}

// UnsafeVariantBuilderToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantBuilderToGlibNone(v *VariantBuilder) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantBuilderToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantBuilderToGlibFull(v *VariantBuilder) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantBuilder, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantBuilder is invalid from here on
	return _p
}

// NewVariantBuilder wraps g_variant_builder_new
// 
// see also https://docs.gtk.org/glib/func.g_variant_builder_new.html
//
func NewVariantBuilder(typ *VariantType) *VariantBuilder {
	var carg1 *C.GVariantType    // in, none, converted
	var cret  *C.GVariantBuilder // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_builder_new(carg1)
	runtime.KeepAlive(typ)

	var goret *VariantBuilder

	goret = UnsafeVariantBuilderFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// Close wraps g_variant_builder_close
// 
// see also https://docs.gtk.org/glib/method.g_variant_builder_close.g_variant_builder_close.html
//
func (builder *VariantBuilder) Close() {
	var carg0 *C.GVariantBuilder // in, none, converted

	carg0 = (*C.GVariantBuilder)(UnsafeVariantBuilderToGlibNone(builder))

	C.g_variant_builder_close(carg0)
	runtime.KeepAlive(builder)
}

// Open wraps g_variant_builder_open
// 
// see also https://docs.gtk.org/glib/method.g_variant_builder_open.g_variant_builder_open.html
//
func (builder *VariantBuilder) Open(typ *VariantType) {
	var carg0 *C.GVariantBuilder // in, none, converted
	var carg1 *C.GVariantType    // in, none, converted

	carg0 = (*C.GVariantBuilder)(UnsafeVariantBuilderToGlibNone(builder))
	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	C.g_variant_builder_open(carg0, carg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
}

// VariantDict wraps GVariantDict
// 
// see also https://docs.gtk.org/glib/struct.VariantDict.html
//
type VariantDict struct {
	*variantDict
}

// variantDict is the struct that's finalized
type variantDict struct {
	native *C.GVariantDict
}

// UnsafeVariantDictToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantDict) instance() *C.GVariantDict {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantDictFromGlibBorrow is used to convert raw C.GVariantDict pointers to go. This is used by the bindings internally.
func UnsafeVariantDictFromGlibBorrow(p unsafe.Pointer) *VariantDict {
	if p == nil {
		return nil
	}
	return &VariantDict{&variantDict{(*C.GVariantDict)(p)}}
}

// UnsafeVariantDictFromGlibNone is used to convert raw C.GVariantDict pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantDictFromGlibNone(p unsafe.Pointer) *VariantDict {
	C.g_variant_dict_ref((*C.GVariantDict)(p))
	wrapped := UnsafeVariantDictFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	runtime.SetFinalizer(
		wrapped.variantDict,
		func (intern *variantDict) {
			C.g_variant_dict_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantDictFromGlibFull is used to convert raw C.GVariantDict pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantDictFromGlibFull(p unsafe.Pointer) *VariantDict {
	wrapped := UnsafeVariantDictFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantDict,
		func (intern *variantDict) {
			C.g_variant_dict_unref(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantDictRef increases the refcount on the underlying resource. This is used by the bindings internally.
// 
// When this is called without an associated call to [VariantDict.UnsafeVariantDictUnref], then [VariantDict] will leak memory.
func UnsafeVariantDictRef(v *VariantDict) {
	C.g_variant_dict_ref((*C.GVariantDict)(v.native))
}

// UnsafeVariantDictUnref unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantDict] is expected to work anymore.
func UnsafeVariantDictUnref(v *VariantDict) {
	C.g_variant_dict_unref(v.native)
}

// UnsafeVariantDictToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantDictToGlibNone(v *VariantDict) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantDictToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantDictToGlibFull(v *VariantDict) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantDict, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantDict is invalid from here on
	return _p
}

// Clear wraps g_variant_dict_clear
// 
// see also https://docs.gtk.org/glib/method.g_variant_dict_clear.g_variant_dict_clear.html
//
func (dict *VariantDict) Clear() {
	var carg0 *C.GVariantDict // in, none, converted

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))

	C.g_variant_dict_clear(carg0)
	runtime.KeepAlive(dict)
}

// Contains wraps g_variant_dict_contains
// 
// see also https://docs.gtk.org/glib/method.g_variant_dict_contains.g_variant_dict_contains.html
//
func (dict *VariantDict) Contains(key string) bool {
	var carg0 *C.GVariantDict // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_dict_contains(carg0, carg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Remove wraps g_variant_dict_remove
// 
// see also https://docs.gtk.org/glib/method.g_variant_dict_remove.g_variant_dict_remove.html
//
func (dict *VariantDict) Remove(key string) bool {
	var carg0 *C.GVariantDict // in, none, converted
	var carg1 *C.gchar        // in, none, string
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantDict)(UnsafeVariantDictToGlibNone(dict))
	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_dict_remove(carg0, carg1)
	runtime.KeepAlive(dict)
	runtime.KeepAlive(key)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantType wraps GVariantType
// 
// see also https://docs.gtk.org/glib/struct.VariantType.html
//
type VariantType struct {
	*variantType
}

// variantType is the struct that's finalized
type variantType struct {
	native *C.GVariantType
}

// UnsafeVariantTypeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func (v *VariantType) instance() *C.GVariantType {
	if v == nil {
		return nil
	}
	return v.native
}

// UnsafeVariantTypeFromGlibBorrow is used to convert raw C.GVariantType pointers to go. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibBorrow(p unsafe.Pointer) *VariantType {
	if p == nil {
		return nil
	}
	return &VariantType{&variantType{(*C.GVariantType)(p)}}
}

// UnsafeVariantTypeFromGlibNone is used to convert raw C.GVariantType pointers to go without transferring ownership. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibNone(p unsafe.Pointer) *VariantType {
	wrapped := UnsafeVariantTypeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}

	return wrapped.Copy() // create an owned copy

}

// UnsafeVariantTypeFromGlibFull is used to convert raw C.GVariantType pointers to go while taking ownership. This is used by the bindings internally.
func UnsafeVariantTypeFromGlibFull(p unsafe.Pointer) *VariantType {
	wrapped := UnsafeVariantTypeFromGlibBorrow(p)
	if wrapped == nil {
		return nil
	}
	runtime.SetFinalizer(
		wrapped.variantType,
		func (intern *variantType) {
			C.g_variant_type_free(intern.native)
		},
	)
	return wrapped
}

// UnsafeVariantTypeFree unrefs/frees the underlying resource. This is used by the bindings internally.
// 
// After this is called, no other method on [VariantType] is expected to work anymore.
func UnsafeVariantTypeFree(v *VariantType) {
	C.g_variant_type_free(v.native)
}

// UnsafeVariantTypeToGlibNone returns the underlying C pointer. This is used by the bindings internally.
func UnsafeVariantTypeToGlibNone(v *VariantType) unsafe.Pointer {
	if v == nil {
		return nil
	}
	return unsafe.Pointer(v.native)
}

// UnsafeVariantTypeToGlibFull returns the underlying C pointer and gives up ownership.
// This is used by the bindings internally.
func UnsafeVariantTypeToGlibFull(v *VariantType) unsafe.Pointer {
	if v == nil {
		return nil
	}
	runtime.SetFinalizer(v.variantType, nil)
	_p := unsafe.Pointer(v.native)
	v.native = nil // VariantType is invalid from here on
	return _p
}

// NewVariantType wraps g_variant_type_new
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_new.html
//
func NewVariantType(typeString string) *VariantType {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_new(carg1)
	runtime.KeepAlive(typeString)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeArray wraps g_variant_type_new_array
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_new_array.html
//
func NewVariantTypeArray(element *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(element))

	cret = C.g_variant_type_new_array(carg1)
	runtime.KeepAlive(element)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeDictEntry wraps g_variant_type_new_dict_entry
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_new_dict_entry.html
//
func NewVariantTypeDictEntry(key *VariantType, value *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var carg2 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(key))
	carg2 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(value))

	cret = C.g_variant_type_new_dict_entry(carg1, carg2)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeMaybe wraps g_variant_type_new_maybe
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_new_maybe.html
//
func NewVariantTypeMaybe(element *VariantType) *VariantType {
	var carg1 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(element))

	cret = C.g_variant_type_new_maybe(carg1)
	runtime.KeepAlive(element)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// NewVariantTypeTuple wraps g_variant_type_new_tuple
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_new_tuple.html
//
func NewVariantTypeTuple(items []*VariantType) *VariantType {
	var carg1 **C.GVariantType // in, transfer: none, C Pointers: 2, Name: array[VariantType], array (inner GVariantType* (*typesystem.Record), length-by: carg2)
	var carg2 C.gint           // implicit
	var cret  *C.GVariantType  // return, full, converted

	_ = items
	_ = carg1
	_ = carg2
	panic("unimplemented conversion of []*VariantType (const GVariantType* const*) because of unimplemented: inner pointers in array")

	cret = C.g_variant_type_new_tuple(carg1, carg2)
	runtime.KeepAlive(items)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// VariantTypeChecked wraps g_variant_type_checked_
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_checked_.html
func VariantTypeChecked(typeString string) *VariantType {
	var carg1 *C.gchar        // in, none, string
	var cret  *C.GVariantType // return, none, converted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_checked_(carg1)
	runtime.KeepAlive(typeString)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// VariantTypeStringGetDepth wraps g_variant_type_string_get_depth_
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_string_get_depth_.html
func VariantTypeStringGetDepth(typeString string) uint {
	var carg1 *C.gchar // in, none, string
	var cret  C.gsize  // return, none, casted

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_string_get_depth_(carg1)
	runtime.KeepAlive(typeString)

	var goret uint

	goret = uint(cret)

	return goret
}

// VariantTypeStringIsValid wraps g_variant_type_string_is_valid
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_string_is_valid.html
//
func VariantTypeStringIsValid(typeString string) bool {
	var carg1 *C.gchar   // in, none, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(typeString)))
	defer C.free(unsafe.Pointer(carg1))

	cret = C.g_variant_type_string_is_valid(carg1)
	runtime.KeepAlive(typeString)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// VariantTypeStringScan wraps g_variant_type_string_scan
// 
// see also https://docs.gtk.org/glib/func.g_variant_type_string_scan.html
//
func VariantTypeStringScan(str string, limit string) (string, bool) {
	var carg1 *C.gchar   // in, none, string
	var carg2 *C.gchar   // in, none, string, nullable-string
	var carg3 *C.gchar   // out, full, string
	var cret  C.gboolean // return

	carg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(carg1))
	if limit != "" {
		carg2 = (*C.gchar)(unsafe.Pointer(C.CString(limit)))
		defer C.free(unsafe.Pointer(carg2))
	}

	cret = C.g_variant_type_string_scan(carg1, carg2, &carg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(limit)

	var endptr string
	var goret  bool

	endptr = C.GoString((*C.char)(unsafe.Pointer(carg3)))
	defer C.free(unsafe.Pointer(carg3))
	if cret != 0 {
		goret = true
	}

	return endptr, goret
}

// Copy wraps g_variant_type_copy
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_copy.g_variant_type_copy.html
//
func (typ *VariantType) Copy() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, full, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_copy(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibFull(unsafe.Pointer(cret))

	return goret
}

// DupString wraps g_variant_type_dup_string
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_dup_string.g_variant_type_dup_string.html
//
func (typ *VariantType) DupString() string {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.gchar        // return, full, string

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_dup_string(carg0)
	runtime.KeepAlive(typ)

	var goret string

	goret = C.GoString((*C.char)(unsafe.Pointer(cret)))
	defer C.free(unsafe.Pointer(cret))

	return goret
}

// Element wraps g_variant_type_element
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_element.g_variant_type_element.html
//
func (typ *VariantType) Element() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_element(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// First wraps g_variant_type_first
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_first.g_variant_type_first.html
//
func (typ *VariantType) First() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_first(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	if cret != nil {
		goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// GetStringLength wraps g_variant_type_get_string_length
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_get_string_length.g_variant_type_get_string_length.html
//
func (typ *VariantType) GetStringLength() uint {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_get_string_length(carg0)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// IsArray wraps g_variant_type_is_array
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_array.g_variant_type_is_array.html
//
func (typ *VariantType) IsArray() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_array(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsBasic wraps g_variant_type_is_basic
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_basic.g_variant_type_is_basic.html
//
func (typ *VariantType) IsBasic() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_basic(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsContainer wraps g_variant_type_is_container
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_container.g_variant_type_is_container.html
//
func (typ *VariantType) IsContainer() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_container(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsDefinite wraps g_variant_type_is_definite
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_definite.g_variant_type_is_definite.html
//
func (typ *VariantType) IsDefinite() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_definite(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsDictEntry wraps g_variant_type_is_dict_entry
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_dict_entry.g_variant_type_is_dict_entry.html
//
func (typ *VariantType) IsDictEntry() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_dict_entry(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsMaybe wraps g_variant_type_is_maybe
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_maybe.g_variant_type_is_maybe.html
//
func (typ *VariantType) IsMaybe() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_maybe(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsSubtypeOf wraps g_variant_type_is_subtype_of
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_subtype_of.g_variant_type_is_subtype_of.html
//
func (typ *VariantType) IsSubtypeOf(supertype *VariantType) bool {
	var carg0 *C.GVariantType // in, none, converted
	var carg1 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))
	carg1 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(supertype))

	cret = C.g_variant_type_is_subtype_of(carg0, carg1)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(supertype)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsTuple wraps g_variant_type_is_tuple
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_tuple.g_variant_type_is_tuple.html
//
func (typ *VariantType) IsTuple() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_tuple(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// IsVariant wraps g_variant_type_is_variant
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_is_variant.g_variant_type_is_variant.html
//
func (typ *VariantType) IsVariant() bool {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gboolean      // return

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_is_variant(carg0)
	runtime.KeepAlive(typ)

	var goret bool

	if cret != 0 {
		goret = true
	}

	return goret
}

// Key wraps g_variant_type_key
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_key.g_variant_type_key.html
//
func (typ *VariantType) Key() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_key(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

// NItems wraps g_variant_type_n_items
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_n_items.g_variant_type_n_items.html
//
func (typ *VariantType) NItems() uint {
	var carg0 *C.GVariantType // in, none, converted
	var cret  C.gsize         // return, none, casted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_n_items(carg0)
	runtime.KeepAlive(typ)

	var goret uint

	goret = uint(cret)

	return goret
}

// Next wraps g_variant_type_next
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_next.g_variant_type_next.html
//
func (typ *VariantType) Next() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted, nullable

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_next(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	if cret != nil {
		goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))
	}

	return goret
}

// Value wraps g_variant_type_value
// 
// see also https://docs.gtk.org/glib/method.g_variant_type_value.g_variant_type_value.html
//
func (typ *VariantType) Value() *VariantType {
	var carg0 *C.GVariantType // in, none, converted
	var cret  *C.GVariantType // return, none, converted

	carg0 = (*C.GVariantType)(UnsafeVariantTypeToGlibNone(typ))

	cret = C.g_variant_type_value(carg0)
	runtime.KeepAlive(typ)

	var goret *VariantType

	goret = UnsafeVariantTypeFromGlibNone(unsafe.Pointer(cret))

	return goret
}

